
captivatesEnv.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002c2f4  08000140  08000140  00010140  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001978  0802c438  0802c438  0003c438  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0802ddb0  0802ddb0  0003ddb0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000020  0802ddb8  0802ddb8  0003ddb8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000014  0802ddd8  0802ddd8  0003ddd8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000214  20000004  0802ddec  00040004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 TIMERSERVER_CONTEXT 00000099  20000218  0802e000  00040218  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 BLE_DRIVER_CONTEXT 00000041  200002b4  0802e099  000402b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 SYSTEM_DRIVER_CONTEXT 00000011  200002f8  0802e0da  000402f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 BLE_APP_CONTEXT 00000088  2000030c  0802e0eb  0004030c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00013814  20000398  0802e173  00040398  2**3
                  ALLOC
 12 ._user_heap_stack 00000604  20013bac  0802e173  00043bac  2**0
                  ALLOC
 13 .ARM.attributes 00000030  00000000  00000000  00040394  2**0
                  CONTENTS, READONLY
 14 MAPPING_TABLE 00000028  20030000  20030000  00050000  2**2
                  ALLOC
 15 MB_MEM1       000001b7  20030028  20030028  00050000  2**2
                  ALLOC
 16 MB_MEM2       00000877  200301e0  200301e0  00050000  2**2
                  ALLOC
 17 .debug_info   000c23c3  00000000  00000000  000403c4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_abbrev 000131e5  00000000  00000000  00102787  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_aranges 00005300  00000000  00000000  00115970  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_ranges 00004c88  00000000  00000000  0011ac70  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0004a5d7  00000000  00000000  0011f8f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line   00075232  00000000  00000000  00169ecf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_str    001350b0  00000000  00000000  001df101  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .comment      000000cc  00000000  00000000  003141b1  2**0
                  CONTENTS, READONLY
 25 .debug_frame  000167ec  00000000  00000000  00314280  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000140 <__do_global_dtors_aux>:
 8000140:	b510      	push	{r4, lr}
 8000142:	4c05      	ldr	r4, [pc, #20]	; (8000158 <__do_global_dtors_aux+0x18>)
 8000144:	7823      	ldrb	r3, [r4, #0]
 8000146:	b933      	cbnz	r3, 8000156 <__do_global_dtors_aux+0x16>
 8000148:	4b04      	ldr	r3, [pc, #16]	; (800015c <__do_global_dtors_aux+0x1c>)
 800014a:	b113      	cbz	r3, 8000152 <__do_global_dtors_aux+0x12>
 800014c:	4804      	ldr	r0, [pc, #16]	; (8000160 <__do_global_dtors_aux+0x20>)
 800014e:	f3af 8000 	nop.w
 8000152:	2301      	movs	r3, #1
 8000154:	7023      	strb	r3, [r4, #0]
 8000156:	bd10      	pop	{r4, pc}
 8000158:	20000398 	.word	0x20000398
 800015c:	00000000 	.word	0x00000000
 8000160:	0802c41c 	.word	0x0802c41c

08000164 <frame_dummy>:
 8000164:	b508      	push	{r3, lr}
 8000166:	4b03      	ldr	r3, [pc, #12]	; (8000174 <frame_dummy+0x10>)
 8000168:	b11b      	cbz	r3, 8000172 <frame_dummy+0xe>
 800016a:	4903      	ldr	r1, [pc, #12]	; (8000178 <frame_dummy+0x14>)
 800016c:	4803      	ldr	r0, [pc, #12]	; (800017c <frame_dummy+0x18>)
 800016e:	f3af 8000 	nop.w
 8000172:	bd08      	pop	{r3, pc}
 8000174:	00000000 	.word	0x00000000
 8000178:	2000039c 	.word	0x2000039c
 800017c:	0802c41c 	.word	0x0802c41c

08000180 <bsec_get_version>:
 8000180:	b508      	push	{r3, lr}
 8000182:	4601      	mov	r1, r0
 8000184:	4802      	ldr	r0, [pc, #8]	; (8000190 <bsec_get_version+0x10>)
 8000186:	f000 fb0f 	bl	80007a8 <bsec_codegen_get_version>
 800018a:	2000      	movs	r0, #0
 800018c:	bd08      	pop	{r3, pc}
 800018e:	bf00      	nop
 8000190:	20010e30 	.word	0x20010e30

08000194 <bsec_init>:
 8000194:	b508      	push	{r3, lr}
 8000196:	4802      	ldr	r0, [pc, #8]	; (80001a0 <bsec_init+0xc>)
 8000198:	f000 fb0e 	bl	80007b8 <bsec_codegen_init>
 800019c:	2000      	movs	r0, #0
 800019e:	bd08      	pop	{r3, pc}
 80001a0:	20010e30 	.word	0x20010e30

080001a4 <bsec_reset_output>:
 80001a4:	4601      	mov	r1, r0
 80001a6:	4801      	ldr	r0, [pc, #4]	; (80001ac <bsec_reset_output+0x8>)
 80001a8:	f000 bb08 	b.w	80007bc <bsec_codegen_reset_output>
 80001ac:	20010e30 	.word	0x20010e30

080001b0 <bsec_update_subscription>:
 80001b0:	b530      	push	{r4, r5, lr}
 80001b2:	b085      	sub	sp, #20
 80001b4:	460d      	mov	r5, r1
 80001b6:	f10d 040f 	add.w	r4, sp, #15
 80001ba:	4601      	mov	r1, r0
 80001bc:	9201      	str	r2, [sp, #4]
 80001be:	4804      	ldr	r0, [pc, #16]	; (80001d0 <bsec_update_subscription+0x20>)
 80001c0:	9400      	str	r4, [sp, #0]
 80001c2:	462a      	mov	r2, r5
 80001c4:	f000 fee0 	bl	8000f88 <bsec_codegen_update_subscription>
 80001c8:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80001cc:	b005      	add	sp, #20
 80001ce:	bd30      	pop	{r4, r5, pc}
 80001d0:	20010e30 	.word	0x20010e30

080001d4 <bsec_do_steps>:
 80001d4:	b530      	push	{r4, r5, lr}
 80001d6:	b085      	sub	sp, #20
 80001d8:	460d      	mov	r5, r1
 80001da:	f10d 040f 	add.w	r4, sp, #15
 80001de:	4601      	mov	r1, r0
 80001e0:	9201      	str	r2, [sp, #4]
 80001e2:	4804      	ldr	r0, [pc, #16]	; (80001f4 <bsec_do_steps+0x20>)
 80001e4:	9400      	str	r4, [sp, #0]
 80001e6:	462a      	mov	r2, r5
 80001e8:	f000 f870 	bl	80002cc <bsec_codegen_do_steps>
 80001ec:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80001f0:	b005      	add	sp, #20
 80001f2:	bd30      	pop	{r4, r5, pc}
 80001f4:	20010e30 	.word	0x20010e30

080001f8 <bsec_set_configuration>:
 80001f8:	b530      	push	{r4, r5, lr}
 80001fa:	b083      	sub	sp, #12
 80001fc:	460d      	mov	r5, r1
 80001fe:	4614      	mov	r4, r2
 8000200:	4601      	mov	r1, r0
 8000202:	9300      	str	r3, [sp, #0]
 8000204:	462a      	mov	r2, r5
 8000206:	4623      	mov	r3, r4
 8000208:	4802      	ldr	r0, [pc, #8]	; (8000214 <bsec_set_configuration+0x1c>)
 800020a:	f000 fe17 	bl	8000e3c <bsec_codegen_set_configuration>
 800020e:	b003      	add	sp, #12
 8000210:	bd30      	pop	{r4, r5, pc}
 8000212:	bf00      	nop
 8000214:	20010e30 	.word	0x20010e30

08000218 <bsec_set_state>:
 8000218:	b530      	push	{r4, r5, lr}
 800021a:	b083      	sub	sp, #12
 800021c:	460d      	mov	r5, r1
 800021e:	4614      	mov	r4, r2
 8000220:	4601      	mov	r1, r0
 8000222:	9300      	str	r3, [sp, #0]
 8000224:	462a      	mov	r2, r5
 8000226:	4623      	mov	r3, r4
 8000228:	4802      	ldr	r0, [pc, #8]	; (8000234 <bsec_set_state+0x1c>)
 800022a:	f000 fe5d 	bl	8000ee8 <bsec_codegen_set_state>
 800022e:	b003      	add	sp, #12
 8000230:	bd30      	pop	{r4, r5, pc}
 8000232:	bf00      	nop
 8000234:	20010e30 	.word	0x20010e30

08000238 <bsec_get_configuration>:
 8000238:	b5f0      	push	{r4, r5, r6, r7, lr}
 800023a:	b087      	sub	sp, #28
 800023c:	468c      	mov	ip, r1
 800023e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8000240:	9300      	str	r3, [sp, #0]
 8000242:	4617      	mov	r7, r2
 8000244:	f10d 0413 	add.w	r4, sp, #19
 8000248:	ad05      	add	r5, sp, #20
 800024a:	e9cd 4502 	strd	r4, r5, [sp, #8]
 800024e:	4601      	mov	r1, r0
 8000250:	463b      	mov	r3, r7
 8000252:	4806      	ldr	r0, [pc, #24]	; (800026c <bsec_get_configuration+0x34>)
 8000254:	9601      	str	r6, [sp, #4]
 8000256:	4662      	mov	r2, ip
 8000258:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800025a:	f000 f9ef 	bl	800063c <bsec_codegen_get_configuration>
 800025e:	9b05      	ldr	r3, [sp, #20]
 8000260:	f99d 0013 	ldrsb.w	r0, [sp, #19]
 8000264:	6023      	str	r3, [r4, #0]
 8000266:	b007      	add	sp, #28
 8000268:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800026a:	bf00      	nop
 800026c:	20010e30 	.word	0x20010e30

08000270 <bsec_get_state>:
 8000270:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000272:	b087      	sub	sp, #28
 8000274:	468c      	mov	ip, r1
 8000276:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8000278:	9300      	str	r3, [sp, #0]
 800027a:	4617      	mov	r7, r2
 800027c:	f10d 0413 	add.w	r4, sp, #19
 8000280:	ad05      	add	r5, sp, #20
 8000282:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8000286:	4601      	mov	r1, r0
 8000288:	463b      	mov	r3, r7
 800028a:	4806      	ldr	r0, [pc, #24]	; (80002a4 <bsec_get_state+0x34>)
 800028c:	9601      	str	r6, [sp, #4]
 800028e:	4662      	mov	r2, ip
 8000290:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8000292:	f000 fa3b 	bl	800070c <bsec_codegen_get_state>
 8000296:	9b05      	ldr	r3, [sp, #20]
 8000298:	f99d 0013 	ldrsb.w	r0, [sp, #19]
 800029c:	6023      	str	r3, [r4, #0]
 800029e:	b007      	add	sp, #28
 80002a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80002a2:	bf00      	nop
 80002a4:	20010e30 	.word	0x20010e30

080002a8 <bsec_sensor_control>:
 80002a8:	b530      	push	{r4, r5, lr}
 80002aa:	b085      	sub	sp, #20
 80002ac:	460d      	mov	r5, r1
 80002ae:	f10d 010f 	add.w	r1, sp, #15
 80002b2:	9201      	str	r2, [sp, #4]
 80002b4:	462b      	mov	r3, r5
 80002b6:	4602      	mov	r2, r0
 80002b8:	9100      	str	r1, [sp, #0]
 80002ba:	4803      	ldr	r0, [pc, #12]	; (80002c8 <bsec_sensor_control+0x20>)
 80002bc:	f000 fa84 	bl	80007c8 <bsec_codegen_sensor_control>
 80002c0:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80002c4:	b005      	add	sp, #20
 80002c6:	bd30      	pop	{r4, r5, pc}
 80002c8:	20010e30 	.word	0x20010e30

080002cc <bsec_codegen_do_steps>:
 80002cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d0:	b08b      	sub	sp, #44	; 0x2c
 80002d2:	461d      	mov	r5, r3
 80002d4:	9c14      	ldr	r4, [sp, #80]	; 0x50
 80002d6:	9303      	str	r3, [sp, #12]
 80002d8:	2300      	movs	r3, #0
 80002da:	7023      	strb	r3, [r4, #0]
 80002dc:	782c      	ldrb	r4, [r5, #0]
 80002de:	9102      	str	r1, [sp, #8]
 80002e0:	4605      	mov	r5, r0
 80002e2:	4617      	mov	r7, r2
 80002e4:	b18c      	cbz	r4, 800030a <bsec_codegen_do_steps+0x3e>
 80002e6:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80002e8:	eb02 1404 	add.w	r4, r2, r4, lsl #4
 80002ec:	461a      	mov	r2, r3
 80002ee:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80002f0:	f04f 0c00 	mov.w	ip, #0
 80002f4:	2000      	movs	r0, #0
 80002f6:	2100      	movs	r1, #0
 80002f8:	735a      	strb	r2, [r3, #13]
 80002fa:	f8c3 c008 	str.w	ip, [r3, #8]
 80002fe:	731a      	strb	r2, [r3, #12]
 8000300:	739a      	strb	r2, [r3, #14]
 8000302:	e8e3 0104 	strd	r0, r1, [r3], #16
 8000306:	429c      	cmp	r4, r3
 8000308:	d1f6      	bne.n	80002f8 <bsec_codegen_do_steps+0x2c>
 800030a:	2f00      	cmp	r7, #0
 800030c:	f000 8177 	beq.w	80005fe <bsec_codegen_do_steps+0x332>
 8000310:	f04f 0e00 	mov.w	lr, #0
 8000314:	f8df a31c 	ldr.w	sl, [pc, #796]	; 8000634 <bsec_codegen_do_steps+0x368>
 8000318:	f8df b31c 	ldr.w	fp, [pc, #796]	; 8000638 <bsec_codegen_do_steps+0x36c>
 800031c:	9902      	ldr	r1, [sp, #8]
 800031e:	46f4      	mov	ip, lr
 8000320:	f04f 0901 	mov.w	r9, #1
 8000324:	e028      	b.n	8000378 <bsec_codegen_do_steps+0xac>
 8000326:	f016 0601 	ands.w	r6, r6, #1
 800032a:	46d8      	mov	r8, fp
 800032c:	445b      	add	r3, fp
 800032e:	d035      	beq.n	800039c <bsec_codegen_do_steps+0xd0>
 8000330:	ea12 040c 	ands.w	r4, r2, ip
 8000334:	ea4c 0c02 	orr.w	ip, ip, r2
 8000338:	f040 80f0 	bne.w	800051c <bsec_codegen_do_steps+0x250>
 800033c:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8000340:	edd1 7a02 	vldr	s15, [r1, #8]
 8000344:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8000348:	f603 22d4 	addw	r2, r3, #2772	; 0xad4
 800034c:	ed92 7a00 	vldr	s14, [r2]
 8000350:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000354:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000358:	f603 23f4 	addw	r3, r3, #2804	; 0xaf4
 800035c:	f10e 0e01 	add.w	lr, lr, #1
 8000360:	f101 0110 	add.w	r1, r1, #16
 8000364:	d422      	bmi.n	80003ac <bsec_codegen_do_steps+0xe0>
 8000366:	ed93 7a00 	vldr	s14, [r3]
 800036a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800036e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000372:	dc1b      	bgt.n	80003ac <bsec_codegen_do_steps+0xe0>
 8000374:	45be      	cmp	lr, r7
 8000376:	d01e      	beq.n	80003b6 <bsec_codegen_do_steps+0xea>
 8000378:	7b4b      	ldrb	r3, [r1, #13]
 800037a:	1e58      	subs	r0, r3, #1
 800037c:	b2c0      	uxtb	r0, r0
 800037e:	2817      	cmp	r0, #23
 8000380:	fa4a f600 	asr.w	r6, sl, r0
 8000384:	fa09 f200 	lsl.w	r2, r9, r0
 8000388:	d9cd      	bls.n	8000326 <bsec_codegen_do_steps+0x5a>
 800038a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800038c:	23ff      	movs	r3, #255	; 0xff
 800038e:	7013      	strb	r3, [r2, #0]
 8000390:	2600      	movs	r6, #0
 8000392:	9b03      	ldr	r3, [sp, #12]
 8000394:	701e      	strb	r6, [r3, #0]
 8000396:	b00b      	add	sp, #44	; 0x2c
 8000398:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800039c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800039e:	23ff      	movs	r3, #255	; 0xff
 80003a0:	7013      	strb	r3, [r2, #0]
 80003a2:	9b03      	ldr	r3, [sp, #12]
 80003a4:	701e      	strb	r6, [r3, #0]
 80003a6:	b00b      	add	sp, #44	; 0x2c
 80003a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80003ac:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80003ae:	23fe      	movs	r3, #254	; 0xfe
 80003b0:	7013      	strb	r3, [r2, #0]
 80003b2:	2600      	movs	r6, #0
 80003b4:	e7ed      	b.n	8000392 <bsec_codegen_do_steps+0xc6>
 80003b6:	f10d 0b20 	add.w	fp, sp, #32
 80003ba:	f10d 0a18 	add.w	sl, sp, #24
 80003be:	465b      	mov	r3, fp
 80003c0:	4652      	mov	r2, sl
 80003c2:	4639      	mov	r1, r7
 80003c4:	f88d 0016 	strb.w	r0, [sp, #22]
 80003c8:	9802      	ldr	r0, [sp, #8]
 80003ca:	f88d 4015 	strb.w	r4, [sp, #21]
 80003ce:	f001 fa37 	bl	8001840 <bsec_Bsec_getInputSample>
 80003d2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80003d6:	2100      	movs	r1, #0
 80003d8:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80003dc:	428b      	cmp	r3, r1
 80003de:	bf08      	it	eq
 80003e0:	4282      	cmpeq	r2, r0
 80003e2:	d00b      	beq.n	80003fc <bsec_codegen_do_steps+0x130>
 80003e4:	ed9d 0a06 	vldr	s0, [sp, #24]
 80003e8:	4628      	mov	r0, r5
 80003ea:	f001 fa43 	bl	8001874 <bsec_Bsec_isGasIndexNew>
 80003ee:	2800      	cmp	r0, #0
 80003f0:	f040 80af 	bne.w	8000552 <bsec_codegen_do_steps+0x286>
 80003f4:	2f00      	cmp	r7, #0
 80003f6:	d044      	beq.n	8000482 <bsec_codegen_do_steps+0x1b6>
 80003f8:	f8df 823c 	ldr.w	r8, [pc, #572]	; 8000638 <bsec_codegen_do_steps+0x36c>
 80003fc:	f89d e015 	ldrb.w	lr, [sp, #21]
 8000400:	9c02      	ldr	r4, [sp, #8]
 8000402:	4673      	mov	r3, lr
 8000404:	4626      	mov	r6, r4
 8000406:	f04f 0c00 	mov.w	ip, #0
 800040a:	f04f 0904 	mov.w	r9, #4
 800040e:	46a6      	mov	lr, r4
 8000410:	9302      	str	r3, [sp, #8]
 8000412:	7b73      	ldrb	r3, [r6, #13]
 8000414:	4443      	add	r3, r8
 8000416:	e9d6 0100 	ldrd	r0, r1, [r6]
 800041a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 800041e:	f503 738f 	add.w	r3, r3, #286	; 0x11e
 8000422:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8000426:	e9d3 2300 	ldrd	r2, r3, [r3]
 800042a:	4299      	cmp	r1, r3
 800042c:	bf08      	it	eq
 800042e:	4290      	cmpeq	r0, r2
 8000430:	f10c 0c01 	add.w	ip, ip, #1
 8000434:	f106 0610 	add.w	r6, r6, #16
 8000438:	d104      	bne.n	8000444 <bsec_codegen_do_steps+0x178>
 800043a:	9c02      	ldr	r4, [sp, #8]
 800043c:	b914      	cbnz	r4, 8000444 <bsec_codegen_do_steps+0x178>
 800043e:	9c14      	ldr	r4, [sp, #80]	; 0x50
 8000440:	f884 9000 	strb.w	r9, [r4]
 8000444:	45bc      	cmp	ip, r7
 8000446:	dbe4      	blt.n	8000412 <bsec_codegen_do_steps+0x146>
 8000448:	4299      	cmp	r1, r3
 800044a:	9e02      	ldr	r6, [sp, #8]
 800044c:	bf0a      	itet	eq
 800044e:	4290      	cmpeq	r0, r2
 8000450:	2301      	movne	r3, #1
 8000452:	2300      	moveq	r3, #0
 8000454:	4674      	mov	r4, lr
 8000456:	46b6      	mov	lr, r6
 8000458:	f88d 3017 	strb.w	r3, [sp, #23]
 800045c:	2600      	movs	r6, #0
 800045e:	4673      	mov	r3, lr
 8000460:	e001      	b.n	8000466 <bsec_codegen_do_steps+0x19a>
 8000462:	f89d 3015 	ldrb.w	r3, [sp, #21]
 8000466:	ed94 0a02 	vldr	s0, [r4, #8]
 800046a:	7b61      	ldrb	r1, [r4, #13]
 800046c:	9300      	str	r3, [sp, #0]
 800046e:	e9d4 2300 	ldrd	r2, r3, [r4]
 8000472:	3601      	adds	r6, #1
 8000474:	4628      	mov	r0, r5
 8000476:	f002 fce7 	bl	8002e48 <bsec_ChannelHub_setInput>
 800047a:	42be      	cmp	r6, r7
 800047c:	f104 0410 	add.w	r4, r4, #16
 8000480:	dbef      	blt.n	8000462 <bsec_codegen_do_steps+0x196>
 8000482:	f895 3cb3 	ldrb.w	r3, [r5, #3251]	; 0xcb3
 8000486:	2b00      	cmp	r3, #0
 8000488:	d171      	bne.n	800056e <bsec_codegen_do_steps+0x2a2>
 800048a:	f895 1c84 	ldrb.w	r1, [r5, #3204]	; 0xc84
 800048e:	f895 2cb2 	ldrb.w	r2, [r5, #3250]	; 0xcb2
 8000492:	4628      	mov	r0, r5
 8000494:	f001 fef0 	bl	8002278 <bsec_ChannelHub_do>
 8000498:	9b03      	ldr	r3, [sp, #12]
 800049a:	781e      	ldrb	r6, [r3, #0]
 800049c:	2e00      	cmp	r6, #0
 800049e:	d05c      	beq.n	800055a <bsec_codegen_do_steps+0x28e>
 80004a0:	2400      	movs	r4, #0
 80004a2:	4f62      	ldr	r7, [pc, #392]	; (800062c <bsec_codegen_do_steps+0x360>)
 80004a4:	4626      	mov	r6, r4
 80004a6:	f64f 79ff 	movw	r9, #65535	; 0xffff
 80004aa:	4652      	mov	r2, sl
 80004ac:	e002      	b.n	80004b4 <bsec_codegen_do_steps+0x1e8>
 80004ae:	3401      	adds	r4, #1
 80004b0:	2c1a      	cmp	r4, #26
 80004b2:	d02a      	beq.n	800050a <bsec_codegen_do_steps+0x23e>
 80004b4:	fa47 f104 	asr.w	r1, r7, r4
 80004b8:	07cb      	lsls	r3, r1, #31
 80004ba:	d5f8      	bpl.n	80004ae <bsec_codegen_do_steps+0x1e2>
 80004bc:	4b5c      	ldr	r3, [pc, #368]	; (8000630 <bsec_codegen_do_steps+0x364>)
 80004be:	5ce1      	ldrb	r1, [r4, r3]
 80004c0:	eb05 0141 	add.w	r1, r5, r1, lsl #1
 80004c4:	f04f 0801 	mov.w	r8, #1
 80004c8:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 80004cc:	4549      	cmp	r1, r9
 80004ce:	fa08 f004 	lsl.w	r0, r8, r4
 80004d2:	d021      	beq.n	8000518 <bsec_codegen_do_steps+0x24c>
 80004d4:	f8d5 1a54 	ldr.w	r1, [r5, #2644]	; 0xa54
 80004d8:	4208      	tst	r0, r1
 80004da:	f104 0401 	add.w	r4, r4, #1
 80004de:	d0e7      	beq.n	80004b0 <bsec_codegen_do_steps+0x1e4>
 80004e0:	f10d 0016 	add.w	r0, sp, #22
 80004e4:	fa5f fa84 	uxtb.w	sl, r4
 80004e8:	4651      	mov	r1, sl
 80004ea:	9000      	str	r0, [sp, #0]
 80004ec:	465b      	mov	r3, fp
 80004ee:	4628      	mov	r0, r5
 80004f0:	9202      	str	r2, [sp, #8]
 80004f2:	f002 fb9f 	bl	8002c34 <bsec_ChannelHub_getOutput>
 80004f6:	9b03      	ldr	r3, [sp, #12]
 80004f8:	9a02      	ldr	r2, [sp, #8]
 80004fa:	7819      	ldrb	r1, [r3, #0]
 80004fc:	42b1      	cmp	r1, r6
 80004fe:	f106 0001 	add.w	r0, r6, #1
 8000502:	d810      	bhi.n	8000526 <bsec_codegen_do_steps+0x25a>
 8000504:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8000506:	2303      	movs	r3, #3
 8000508:	7013      	strb	r3, [r2, #0]
 800050a:	2300      	movs	r3, #0
 800050c:	f8c5 3a54 	str.w	r3, [r5, #2644]	; 0xa54
 8000510:	4628      	mov	r0, r5
 8000512:	f001 f803 	bl	800151c <bsec_Bsec_applyUpdateSubscription>
 8000516:	e73c      	b.n	8000392 <bsec_codegen_do_steps+0xc6>
 8000518:	4444      	add	r4, r8
 800051a:	e7c9      	b.n	80004b0 <bsec_codegen_do_steps+0x1e4>
 800051c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800051e:	23fa      	movs	r3, #250	; 0xfa
 8000520:	7013      	strb	r3, [r2, #0]
 8000522:	2600      	movs	r6, #0
 8000524:	e735      	b.n	8000392 <bsec_codegen_do_steps+0xc6>
 8000526:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8000528:	b2c6      	uxtb	r6, r0
 800052a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800052e:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
 8000532:	eb03 1c0c 	add.w	ip, r3, ip, lsl #4
 8000536:	e9cc 0100 	strd	r0, r1, [ip]
 800053a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800053e:	9906      	ldr	r1, [sp, #24]
 8000540:	f88c a00d 	strb.w	sl, [ip, #13]
 8000544:	f88c 800c 	strb.w	r8, [ip, #12]
 8000548:	f8cc 1008 	str.w	r1, [ip, #8]
 800054c:	f88c 300e 	strb.w	r3, [ip, #14]
 8000550:	e7ae      	b.n	80004b0 <bsec_codegen_do_steps+0x1e4>
 8000552:	2301      	movs	r3, #1
 8000554:	f88d 3015 	strb.w	r3, [sp, #21]
 8000558:	e74c      	b.n	80003f4 <bsec_codegen_do_steps+0x128>
 800055a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800055c:	2302      	movs	r3, #2
 800055e:	7013      	strb	r3, [r2, #0]
 8000560:	2300      	movs	r3, #0
 8000562:	f8c5 3a54 	str.w	r3, [r5, #2644]	; 0xa54
 8000566:	4628      	mov	r0, r5
 8000568:	f000 ffd8 	bl	800151c <bsec_Bsec_applyUpdateSubscription>
 800056c:	e711      	b.n	8000392 <bsec_codegen_do_steps+0xc6>
 800056e:	f10d 0315 	add.w	r3, sp, #21
 8000572:	465a      	mov	r2, fp
 8000574:	4651      	mov	r1, sl
 8000576:	4628      	mov	r0, r5
 8000578:	f002 fb4a 	bl	8002c10 <bsec_ChannelHub_getInput>
 800057c:	f10d 0317 	add.w	r3, sp, #23
 8000580:	465a      	mov	r2, fp
 8000582:	a907      	add	r1, sp, #28
 8000584:	4628      	mov	r0, r5
 8000586:	f002 fd15 	bl	8002fb4 <bsec_b_ChannelHub_getInput>
 800058a:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800058e:	b113      	cbz	r3, 8000596 <bsec_codegen_do_steps+0x2ca>
 8000590:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8000594:	b933      	cbnz	r3, 80005a4 <bsec_codegen_do_steps+0x2d8>
 8000596:	f895 2cb2 	ldrb.w	r2, [r5, #3250]	; 0xcb2
 800059a:	1e51      	subs	r1, r2, #1
 800059c:	b2c9      	uxtb	r1, r1
 800059e:	f885 1c84 	strb.w	r1, [r5, #3204]	; 0xc84
 80005a2:	e776      	b.n	8000492 <bsec_codegen_do_steps+0x1c6>
 80005a4:	ed9d 0a06 	vldr	s0, [sp, #24]
 80005a8:	f029 f85c 	bl	8029664 <roundf>
 80005ac:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80005b0:	f895 2c7c 	ldrb.w	r2, [r5, #3196]	; 0xc7c
 80005b4:	edcd 7a02 	vstr	s15, [sp, #8]
 80005b8:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80005bc:	f88d 3016 	strb.w	r3, [sp, #22]
 80005c0:	429a      	cmp	r2, r3
 80005c2:	d002      	beq.n	80005ca <bsec_codegen_do_steps+0x2fe>
 80005c4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80005c6:	2305      	movs	r3, #5
 80005c8:	7013      	strb	r3, [r2, #0]
 80005ca:	ed9d 0a06 	vldr	s0, [sp, #24]
 80005ce:	f895 4cb2 	ldrb.w	r4, [r5, #3250]	; 0xcb2
 80005d2:	f029 f847 	bl	8029664 <roundf>
 80005d6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80005da:	2101      	movs	r1, #1
 80005dc:	ee17 3a90 	vmov	r3, s15
 80005e0:	440b      	add	r3, r1
 80005e2:	b2db      	uxtb	r3, r3
 80005e4:	fbb3 f2f4 	udiv	r2, r3, r4
 80005e8:	fb04 3312 	mls	r3, r4, r2, r3
 80005ec:	f89d 2016 	ldrb.w	r2, [sp, #22]
 80005f0:	f885 3c7c 	strb.w	r3, [r5, #3196]	; 0xc7c
 80005f4:	f885 1cb4 	strb.w	r1, [r5, #3252]	; 0xcb4
 80005f8:	f885 2cb5 	strb.w	r2, [r5, #3253]	; 0xcb5
 80005fc:	e7cb      	b.n	8000596 <bsec_codegen_do_steps+0x2ca>
 80005fe:	f10d 0b20 	add.w	fp, sp, #32
 8000602:	f10d 0a18 	add.w	sl, sp, #24
 8000606:	9802      	ldr	r0, [sp, #8]
 8000608:	f88d 7015 	strb.w	r7, [sp, #21]
 800060c:	465b      	mov	r3, fp
 800060e:	4652      	mov	r2, sl
 8000610:	4639      	mov	r1, r7
 8000612:	f001 f915 	bl	8001840 <bsec_Bsec_getInputSample>
 8000616:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800061a:	2100      	movs	r1, #0
 800061c:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8000620:	428b      	cmp	r3, r1
 8000622:	bf08      	it	eq
 8000624:	4282      	cmpeq	r2, r0
 8000626:	f43f af2c 	beq.w	8000482 <bsec_codegen_do_steps+0x1b6>
 800062a:	e6db      	b.n	80003e4 <bsec_codegen_do_steps+0x118>
 800062c:	03f279ef 	.word	0x03f279ef
 8000630:	0802d6bc 	.word	0x0802d6bc
 8000634:	00e0200f 	.word	0x00e0200f
 8000638:	0802d6d8 	.word	0x0802d6d8

0800063c <bsec_codegen_get_configuration>:
 800063c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000640:	b085      	sub	sp, #20
 8000642:	e9dd 8a10 	ldrd	r8, sl, [sp, #64]	; 0x40
 8000646:	461d      	mov	r5, r3
 8000648:	23df      	movs	r3, #223	; 0xdf
 800064a:	f888 3000 	strb.w	r3, [r8]
 800064e:	2400      	movs	r4, #0
 8000650:	2310      	movs	r3, #16
 8000652:	2d17      	cmp	r5, #23
 8000654:	f8ca 4000 	str.w	r4, [sl]
 8000658:	9303      	str	r3, [sp, #12]
 800065a:	d92a      	bls.n	80006b2 <bsec_codegen_get_configuration+0x76>
 800065c:	4617      	mov	r7, r2
 800065e:	2900      	cmp	r1, #0
 8000660:	d134      	bne.n	80006cc <bsec_codegen_get_configuration+0x90>
 8000662:	4606      	mov	r6, r0
 8000664:	460c      	mov	r4, r1
 8000666:	f888 1000 	strb.w	r1, [r8]
 800066a:	468b      	mov	fp, r1
 800066c:	f240 7917 	movw	r9, #1815	; 0x717
 8000670:	e001      	b.n	8000676 <bsec_codegen_get_configuration+0x3a>
 8000672:	2c0b      	cmp	r4, #11
 8000674:	d020      	beq.n	80006b8 <bsec_codegen_get_configuration+0x7c>
 8000676:	fa49 f304 	asr.w	r3, r9, r4
 800067a:	07db      	lsls	r3, r3, #31
 800067c:	f104 0401 	add.w	r4, r4, #1
 8000680:	d5f7      	bpl.n	8000672 <bsec_codegen_get_configuration+0x36>
 8000682:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8000686:	f8cd b000 	str.w	fp, [sp]
 800068a:	b2e1      	uxtb	r1, r4
 800068c:	4630      	mov	r0, r6
 800068e:	f002 fa4b 	bl	8002b28 <bsec_ChannelHub_getChannelConfiguration>
 8000692:	2800      	cmp	r0, #0
 8000694:	d0ed      	beq.n	8000672 <bsec_codegen_get_configuration+0x36>
 8000696:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000698:	9301      	str	r3, [sp, #4]
 800069a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800069c:	9300      	str	r3, [sp, #0]
 800069e:	aa03      	add	r2, sp, #12
 80006a0:	4603      	mov	r3, r0
 80006a2:	4629      	mov	r1, r5
 80006a4:	4638      	mov	r0, r7
 80006a6:	f000 ff17 	bl	80014d8 <bsec_Bsec_append>
 80006aa:	f888 0000 	strb.w	r0, [r8]
 80006ae:	2800      	cmp	r0, #0
 80006b0:	d0df      	beq.n	8000672 <bsec_codegen_get_configuration+0x36>
 80006b2:	b005      	add	sp, #20
 80006b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80006b8:	f998 3000 	ldrsb.w	r3, [r8]
 80006bc:	2b00      	cmp	r3, #0
 80006be:	d1f8      	bne.n	80006b2 <bsec_codegen_get_configuration+0x76>
 80006c0:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
 80006c4:	4630      	mov	r0, r6
 80006c6:	f001 f81d 	bl	8001704 <bsec_Bsec_getHyperConfiguration>
 80006ca:	b978      	cbnz	r0, 80006ec <bsec_codegen_get_configuration+0xb0>
 80006cc:	f998 4000 	ldrsb.w	r4, [r8]
 80006d0:	2c00      	cmp	r4, #0
 80006d2:	d1ee      	bne.n	80006b2 <bsec_codegen_get_configuration+0x76>
 80006d4:	9b03      	ldr	r3, [sp, #12]
 80006d6:	f8ca 3000 	str.w	r3, [sl]
 80006da:	4638      	mov	r0, r7
 80006dc:	4651      	mov	r1, sl
 80006de:	f000 ffb9 	bl	8001654 <bsec_Bsec_frameSerializedData>
 80006e2:	f888 4000 	strb.w	r4, [r8]
 80006e6:	b005      	add	sp, #20
 80006e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80006ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80006ee:	9301      	str	r3, [sp, #4]
 80006f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80006f2:	9300      	str	r3, [sp, #0]
 80006f4:	4629      	mov	r1, r5
 80006f6:	4603      	mov	r3, r0
 80006f8:	aa03      	add	r2, sp, #12
 80006fa:	4638      	mov	r0, r7
 80006fc:	f000 feec 	bl	80014d8 <bsec_Bsec_append>
 8000700:	4604      	mov	r4, r0
 8000702:	f888 0000 	strb.w	r0, [r8]
 8000706:	2c00      	cmp	r4, #0
 8000708:	d1d3      	bne.n	80006b2 <bsec_codegen_get_configuration+0x76>
 800070a:	e7e3      	b.n	80006d4 <bsec_codegen_get_configuration+0x98>

0800070c <bsec_codegen_get_state>:
 800070c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000710:	b085      	sub	sp, #20
 8000712:	e9dd 8a10 	ldrd	r8, sl, [sp, #64]	; 0x40
 8000716:	461d      	mov	r5, r3
 8000718:	23df      	movs	r3, #223	; 0xdf
 800071a:	f888 3000 	strb.w	r3, [r8]
 800071e:	2400      	movs	r4, #0
 8000720:	2310      	movs	r3, #16
 8000722:	2d18      	cmp	r5, #24
 8000724:	f8ca 4000 	str.w	r4, [sl]
 8000728:	9303      	str	r3, [sp, #12]
 800072a:	d929      	bls.n	8000780 <bsec_codegen_get_state+0x74>
 800072c:	4617      	mov	r7, r2
 800072e:	bb51      	cbnz	r1, 8000786 <bsec_codegen_get_state+0x7a>
 8000730:	4606      	mov	r6, r0
 8000732:	460c      	mov	r4, r1
 8000734:	f888 1000 	strb.w	r1, [r8]
 8000738:	468b      	mov	fp, r1
 800073a:	f240 7917 	movw	r9, #1815	; 0x717
 800073e:	e001      	b.n	8000744 <bsec_codegen_get_state+0x38>
 8000740:	2c0b      	cmp	r4, #11
 8000742:	d020      	beq.n	8000786 <bsec_codegen_get_state+0x7a>
 8000744:	fa49 f304 	asr.w	r3, r9, r4
 8000748:	07db      	lsls	r3, r3, #31
 800074a:	f104 0401 	add.w	r4, r4, #1
 800074e:	d5f7      	bpl.n	8000740 <bsec_codegen_get_state+0x34>
 8000750:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8000754:	f8cd b000 	str.w	fp, [sp]
 8000758:	b2e1      	uxtb	r1, r4
 800075a:	4630      	mov	r0, r6
 800075c:	f002 fa1e 	bl	8002b9c <bsec_ChannelHub_getChannelState>
 8000760:	2800      	cmp	r0, #0
 8000762:	d0ed      	beq.n	8000740 <bsec_codegen_get_state+0x34>
 8000764:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000766:	9301      	str	r3, [sp, #4]
 8000768:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800076a:	9300      	str	r3, [sp, #0]
 800076c:	aa03      	add	r2, sp, #12
 800076e:	4603      	mov	r3, r0
 8000770:	4629      	mov	r1, r5
 8000772:	4638      	mov	r0, r7
 8000774:	f000 feb0 	bl	80014d8 <bsec_Bsec_append>
 8000778:	f888 0000 	strb.w	r0, [r8]
 800077c:	2800      	cmp	r0, #0
 800077e:	d0df      	beq.n	8000740 <bsec_codegen_get_state+0x34>
 8000780:	b005      	add	sp, #20
 8000782:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000786:	f998 4000 	ldrsb.w	r4, [r8]
 800078a:	2c00      	cmp	r4, #0
 800078c:	d1f8      	bne.n	8000780 <bsec_codegen_get_state+0x74>
 800078e:	9b03      	ldr	r3, [sp, #12]
 8000790:	f8ca 3000 	str.w	r3, [sl]
 8000794:	4638      	mov	r0, r7
 8000796:	4651      	mov	r1, sl
 8000798:	f000 ff5c 	bl	8001654 <bsec_Bsec_frameSerializedData>
 800079c:	f888 4000 	strb.w	r4, [r8]
 80007a0:	b005      	add	sp, #20
 80007a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80007a6:	bf00      	nop

080007a8 <bsec_codegen_get_version>:
 80007a8:	2202      	movs	r2, #2
 80007aa:	2300      	movs	r3, #0
 80007ac:	700a      	strb	r2, [r1, #0]
 80007ae:	704a      	strb	r2, [r1, #1]
 80007b0:	708b      	strb	r3, [r1, #2]
 80007b2:	70cb      	strb	r3, [r1, #3]
 80007b4:	4770      	bx	lr
 80007b6:	bf00      	nop

080007b8 <bsec_codegen_init>:
 80007b8:	f000 bd8c 	b.w	80012d4 <bsec_constructor_bsec>

080007bc <bsec_codegen_reset_output>:
 80007bc:	b508      	push	{r3, lr}
 80007be:	f001 f8d7 	bl	8001970 <bsec_Bsec_resetOutput>
 80007c2:	2000      	movs	r0, #0
 80007c4:	bd08      	pop	{r3, pc}
 80007c6:	bf00      	nop

080007c8 <bsec_codegen_sensor_control>:
 80007c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80007cc:	ed2d 8b02 	vpush	{d8}
 80007d0:	b097      	sub	sp, #92	; 0x5c
 80007d2:	f04f 0800 	mov.w	r8, #0
 80007d6:	9d23      	ldr	r5, [sp, #140]	; 0x8c
 80007d8:	4604      	mov	r4, r0
 80007da:	f600 419e 	addw	r1, r0, #3230	; 0xc9e
 80007de:	e9c5 8800 	strd	r8, r8, [r5]
 80007e2:	e9c5 8802 	strd	r8, r8, [r5, #8]
 80007e6:	4693      	mov	fp, r2
 80007e8:	f885 8039 	strb.w	r8, [r5, #57]	; 0x39
 80007ec:	2214      	movs	r2, #20
 80007ee:	f8a5 803a 	strh.w	r8, [r5, #58]	; 0x3a
 80007f2:	f8a5 803c 	strh.w	r8, [r5, #60]	; 0x3c
 80007f6:	f885 803e 	strb.w	r8, [r5, #62]	; 0x3e
 80007fa:	f105 0010 	add.w	r0, r5, #16
 80007fe:	f604 498a 	addw	r9, r4, #3210	; 0xc8a
 8000802:	461e      	mov	r6, r3
 8000804:	f02b fc6c 	bl	802c0e0 <memcpy>
 8000808:	4649      	mov	r1, r9
 800080a:	2214      	movs	r2, #20
 800080c:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8000810:	f02b fc66 	bl	802c0e0 <memcpy>
 8000814:	f894 3cb2 	ldrb.w	r3, [r4, #3250]	; 0xcb2
 8000818:	f885 3038 	strb.w	r3, [r5, #56]	; 0x38
 800081c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800081e:	f883 8000 	strb.w	r8, [r3]
 8000822:	f8b4 3c24 	ldrh.w	r3, [r4, #3108]	; 0xc24
 8000826:	9302      	str	r3, [sp, #8]
 8000828:	4620      	mov	r0, r4
 800082a:	f504 6a2c 	add.w	sl, r4, #2752	; 0xac0
 800082e:	f000 fe75 	bl	800151c <bsec_Bsec_applyUpdateSubscription>
 8000832:	e9da 2300 	ldrd	r2, r3, [sl]
 8000836:	ea52 0103 	orrs.w	r1, r2, r3
 800083a:	d004      	beq.n	8000846 <bsec_codegen_sensor_control+0x7e>
 800083c:	f894 1c85 	ldrb.w	r1, [r4, #3205]	; 0xc85
 8000840:	2900      	cmp	r1, #0
 8000842:	f000 8100 	beq.w	8000a46 <bsec_codegen_sensor_control+0x27e>
 8000846:	f894 3cb3 	ldrb.w	r3, [r4, #3251]	; 0xcb3
 800084a:	b39b      	cbz	r3, 80008b4 <bsec_codegen_sensor_control+0xec>
 800084c:	f894 3cb2 	ldrb.w	r3, [r4, #3250]	; 0xcb2
 8000850:	f894 2cb5 	ldrb.w	r2, [r4, #3253]	; 0xcb5
 8000854:	3b01      	subs	r3, #1
 8000856:	b2db      	uxtb	r3, r3
 8000858:	429a      	cmp	r2, r3
 800085a:	d104      	bne.n	8000866 <bsec_codegen_sensor_control+0x9e>
 800085c:	f894 3c85 	ldrb.w	r3, [r4, #3205]	; 0xc85
 8000860:	2b02      	cmp	r3, #2
 8000862:	f000 815f 	beq.w	8000b24 <bsec_codegen_sensor_control+0x35c>
 8000866:	f894 3c80 	ldrb.w	r3, [r4, #3200]	; 0xc80
 800086a:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
 800086e:	f894 2c7e 	ldrb.w	r2, [r4, #3198]	; 0xc7e
 8000872:	4ba7      	ldr	r3, [pc, #668]	; (8000b10 <bsec_codegen_sensor_control+0x348>)
 8000874:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
 8000878:	f894 1c7f 	ldrb.w	r1, [r4, #3199]	; 0xc7f
 800087c:	f885 103c 	strb.w	r1, [r5, #60]	; 0x3c
 8000880:	eb1b 0303 	adds.w	r3, fp, r3
 8000884:	f04f 0200 	mov.w	r2, #0
 8000888:	eb46 0202 	adc.w	r2, r6, r2
 800088c:	2101      	movs	r1, #1
 800088e:	e9c5 3200 	strd	r3, r2, [r5]
 8000892:	f885 1039 	strb.w	r1, [r5, #57]	; 0x39
 8000896:	2202      	movs	r2, #2
 8000898:	4629      	mov	r1, r5
 800089a:	4620      	mov	r0, r4
 800089c:	f001 fa20 	bl	8001ce0 <bsec_Bsec_setSensorOpMode>
 80008a0:	2304      	movs	r3, #4
 80008a2:	f8a4 3c22 	strh.w	r3, [r4, #3106]	; 0xc22
 80008a6:	e9ca b600 	strd	fp, r6, [sl]
 80008aa:	b017      	add	sp, #92	; 0x5c
 80008ac:	ecbd 8b02 	vpop	{d8}
 80008b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008b4:	f10d 0736 	add.w	r7, sp, #54	; 0x36
 80008b8:	f10d 0335 	add.w	r3, sp, #53	; 0x35
 80008bc:	9700      	str	r7, [sp, #0]
 80008be:	462a      	mov	r2, r5
 80008c0:	2101      	movs	r1, #1
 80008c2:	4620      	mov	r0, r4
 80008c4:	f000 fe30 	bl	8001528 <bsec_Bsec_checkIfSensorRequired>
 80008c8:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 80008cc:	f8bd 8036 	ldrh.w	r8, [sp, #54]	; 0x36
 80008d0:	b13b      	cbz	r3, 80008e2 <bsec_codegen_sensor_control+0x11a>
 80008d2:	f894 3c80 	ldrb.w	r3, [r4, #3200]	; 0xc80
 80008d6:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
 80008da:	f894 3c7e 	ldrb.w	r3, [r4, #3198]	; 0xc7e
 80008de:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
 80008e2:	f10d 0335 	add.w	r3, sp, #53	; 0x35
 80008e6:	462a      	mov	r2, r5
 80008e8:	9700      	str	r7, [sp, #0]
 80008ea:	2102      	movs	r1, #2
 80008ec:	4620      	mov	r0, r4
 80008ee:	f000 fe1b 	bl	8001528 <bsec_Bsec_checkIfSensorRequired>
 80008f2:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
 80008f6:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 80008fa:	4590      	cmp	r8, r2
 80008fc:	bf28      	it	cs
 80008fe:	4690      	movcs	r8, r2
 8000900:	b13b      	cbz	r3, 8000912 <bsec_codegen_sensor_control+0x14a>
 8000902:	f894 3c7f 	ldrb.w	r3, [r4, #3199]	; 0xc7f
 8000906:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
 800090a:	f894 3c7e 	ldrb.w	r3, [r4, #3198]	; 0xc7e
 800090e:	f885 303b 	strb.w	r3, [r5, #59]	; 0x3b
 8000912:	f10d 0335 	add.w	r3, sp, #53	; 0x35
 8000916:	462a      	mov	r2, r5
 8000918:	9700      	str	r7, [sp, #0]
 800091a:	2103      	movs	r1, #3
 800091c:	4620      	mov	r0, r4
 800091e:	f000 fe03 	bl	8001528 <bsec_Bsec_checkIfSensorRequired>
 8000922:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
 8000926:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 800092a:	4590      	cmp	r8, r2
 800092c:	bf28      	it	cs
 800092e:	4690      	movcs	r8, r2
 8000930:	2b00      	cmp	r3, #0
 8000932:	f040 80cf 	bne.w	8000ad4 <bsec_codegen_sensor_control+0x30c>
 8000936:	9700      	str	r7, [sp, #0]
 8000938:	f10d 0335 	add.w	r3, sp, #53	; 0x35
 800093c:	462a      	mov	r2, r5
 800093e:	2104      	movs	r1, #4
 8000940:	4620      	mov	r0, r4
 8000942:	f000 fdf1 	bl	8001528 <bsec_Bsec_checkIfSensorRequired>
 8000946:	f8bd 7036 	ldrh.w	r7, [sp, #54]	; 0x36
 800094a:	9a02      	ldr	r2, [sp, #8]
 800094c:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 8000950:	4547      	cmp	r7, r8
 8000952:	bf28      	it	cs
 8000954:	4647      	movcs	r7, r8
 8000956:	4297      	cmp	r7, r2
 8000958:	bf28      	it	cs
 800095a:	4617      	movcs	r7, r2
 800095c:	2b00      	cmp	r3, #0
 800095e:	f040 816d 	bne.w	8000c3c <bsec_codegen_sensor_control+0x474>
 8000962:	f604 28c8 	addw	r8, r4, #2760	; 0xac8
 8000966:	f8b4 3c7a 	ldrh.w	r3, [r4, #3194]	; 0xc7a
 800096a:	fbb3 f2f7 	udiv	r2, r3, r7
 800096e:	fb07 3212 	mls	r2, r7, r2, r3
 8000972:	1abf      	subs	r7, r7, r2
 8000974:	b2bf      	uxth	r7, r7
 8000976:	f8b4 2c26 	ldrh.w	r2, [r4, #3110]	; 0xc26
 800097a:	f8ca 6004 	str.w	r6, [sl, #4]
 800097e:	443b      	add	r3, r7
 8000980:	b29b      	uxth	r3, r3
 8000982:	fbb3 f1f2 	udiv	r1, r3, r2
 8000986:	fb02 3311 	mls	r3, r2, r1, r3
 800098a:	ed9f 1b5d 	vldr	d1, [pc, #372]	; 8000b00 <bsec_codegen_sensor_control+0x338>
 800098e:	f8ca b000 	str.w	fp, [sl]
 8000992:	ed9f 0b5d 	vldr	d0, [pc, #372]	; 8000b08 <bsec_codegen_sensor_control+0x340>
 8000996:	f8a4 3c7a 	strh.w	r3, [r4, #3194]	; 0xc7a
 800099a:	f8a4 7c22 	strh.w	r7, [r4, #3106]	; 0xc22
 800099e:	f8ad 2036 	strh.w	r2, [sp, #54]	; 0x36
 80009a2:	f028 ff03 	bl	80297ac <pow>
 80009a6:	f006 f8c1 	bl	8006b2c <bsec_rt_roundd>
 80009aa:	ec51 0b10 	vmov	r0, r1, d0
 80009ae:	f007 fd61 	bl	8008474 <__aeabi_d2lz>
 80009b2:	460b      	mov	r3, r1
 80009b4:	fba0 0107 	umull	r0, r1, r0, r7
 80009b8:	fb03 1107 	mla	r1, r3, r7, r1
 80009bc:	e9d8 3200 	ldrd	r3, r2, [r8]
 80009c0:	eb10 070b 	adds.w	r7, r0, fp
 80009c4:	eb41 0606 	adc.w	r6, r1, r6
 80009c8:	f04f 0800 	mov.w	r8, #0
 80009cc:	1af8      	subs	r0, r7, r3
 80009ce:	e9c5 7600 	strd	r7, r6, [r5]
 80009d2:	eb66 0102 	sbc.w	r1, r6, r2
 80009d6:	f884 8c82 	strb.w	r8, [r4, #3202]	; 0xc82
 80009da:	f007 fca5 	bl	8008328 <__aeabi_l2f>
 80009de:	eddf 8a4d 	vldr	s17, [pc, #308]	; 8000b14 <bsec_codegen_sensor_control+0x34c>
 80009e2:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 8000b18 <bsec_codegen_sensor_control+0x350>
 80009e6:	ee07 0a90 	vmov	s15, r0
 80009ea:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 80009ee:	eef4 7ac8 	vcmpe.f32	s15, s16
 80009f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80009f6:	d41e      	bmi.n	8000a36 <bsec_codegen_sensor_control+0x26e>
 80009f8:	ed9f 7a48 	vldr	s14, [pc, #288]	; 8000b1c <bsec_codegen_sensor_control+0x354>
 80009fc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000a00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000a04:	dc17      	bgt.n	8000a36 <bsec_codegen_sensor_control+0x26e>
 8000a06:	f8d4 0ad0 	ldr.w	r0, [r4, #2768]	; 0xad0
 8000a0a:	f8d4 1ad4 	ldr.w	r1, [r4, #2772]	; 0xad4
 8000a0e:	1a38      	subs	r0, r7, r0
 8000a10:	eb66 0101 	sbc.w	r1, r6, r1
 8000a14:	f007 fc88 	bl	8008328 <__aeabi_l2f>
 8000a18:	ee07 0a90 	vmov	s15, r0
 8000a1c:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 8000a20:	eef4 7ac8 	vcmpe.f32	s15, s16
 8000a24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000a28:	bf46      	itte	mi
 8000a2a:	2366      	movmi	r3, #102	; 0x66
 8000a2c:	f884 3c83 	strbmi.w	r3, [r4, #3203]	; 0xc83
 8000a30:	f884 8c83 	strbpl.w	r8, [r4, #3203]	; 0xc83
 8000a34:	e739      	b.n	80008aa <bsec_codegen_sensor_control+0xe2>
 8000a36:	2365      	movs	r3, #101	; 0x65
 8000a38:	f884 3c83 	strb.w	r3, [r4, #3203]	; 0xc83
 8000a3c:	b017      	add	sp, #92	; 0x5c
 8000a3e:	ecbd 8b02 	vpop	{d8}
 8000a42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000a46:	ebbb 0102 	subs.w	r1, fp, r2
 8000a4a:	eb66 0303 	sbc.w	r3, r6, r3
 8000a4e:	ed9f 1b2c 	vldr	d1, [pc, #176]	; 8000b00 <bsec_codegen_sensor_control+0x338>
 8000a52:	ed9f 0b2d 	vldr	d0, [pc, #180]	; 8000b08 <bsec_codegen_sensor_control+0x340>
 8000a56:	9108      	str	r1, [sp, #32]
 8000a58:	9309      	str	r3, [sp, #36]	; 0x24
 8000a5a:	f028 fea7 	bl	80297ac <pow>
 8000a5e:	f8b4 2c22 	ldrh.w	r2, [r4, #3106]	; 0xc22
 8000a62:	eeb0 8a40 	vmov.f32	s16, s0
 8000a66:	eef0 8a60 	vmov.f32	s17, s1
 8000a6a:	2300      	movs	r3, #0
 8000a6c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8000a70:	f006 f85c 	bl	8006b2c <bsec_rt_roundd>
 8000a74:	ec51 0b10 	vmov	r0, r1, d0
 8000a78:	f007 fcfc 	bl	8008474 <__aeabi_d2lz>
 8000a7c:	468c      	mov	ip, r1
 8000a7e:	9904      	ldr	r1, [sp, #16]
 8000a80:	9f04      	ldr	r7, [sp, #16]
 8000a82:	fba0 0101 	umull	r0, r1, r0, r1
 8000a86:	fb0c 1107 	mla	r1, ip, r7, r1
 8000a8a:	9f08      	ldr	r7, [sp, #32]
 8000a8c:	1bc7      	subs	r7, r0, r7
 8000a8e:	9706      	str	r7, [sp, #24]
 8000a90:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8000a92:	eb61 0707 	sbc.w	r7, r1, r7
 8000a96:	9707      	str	r7, [sp, #28]
 8000a98:	e9dd 7806 	ldrd	r7, r8, [sp, #24]
 8000a9c:	0902      	lsrs	r2, r0, #4
 8000a9e:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8000aa2:	110b      	asrs	r3, r1, #4
 8000aa4:	42ba      	cmp	r2, r7
 8000aa6:	eb73 0708 	sbcs.w	r7, r3, r8
 8000aaa:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8000aae:	f2c0 815c 	blt.w	8000d6a <bsec_codegen_sensor_control+0x5a2>
 8000ab2:	9f08      	ldr	r7, [sp, #32]
 8000ab4:	1a3f      	subs	r7, r7, r0
 8000ab6:	970a      	str	r7, [sp, #40]	; 0x28
 8000ab8:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8000aba:	eb67 0101 	sbc.w	r1, r7, r1
 8000abe:	910b      	str	r1, [sp, #44]	; 0x2c
 8000ac0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8000ac4:	4282      	cmp	r2, r0
 8000ac6:	418b      	sbcs	r3, r1
 8000ac8:	f6bf aebd 	bge.w	8000846 <bsec_codegen_sensor_control+0x7e>
 8000acc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8000ace:	2364      	movs	r3, #100	; 0x64
 8000ad0:	7013      	strb	r3, [r2, #0]
 8000ad2:	e6b8      	b.n	8000846 <bsec_codegen_sensor_control+0x7e>
 8000ad4:	4b12      	ldr	r3, [pc, #72]	; (8000b20 <bsec_codegen_sensor_control+0x358>)
 8000ad6:	f894 2c7e 	ldrb.w	r2, [r4, #3198]	; 0xc7e
 8000ada:	7b5b      	ldrb	r3, [r3, #13]
 8000adc:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
 8000ae0:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8000ae4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000ae8:	f8b3 3a68 	ldrh.w	r3, [r3, #2664]	; 0xa68
 8000aec:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
 8000af0:	4293      	cmp	r3, r2
 8000af2:	f43f af20 	beq.w	8000936 <bsec_codegen_sensor_control+0x16e>
 8000af6:	68ab      	ldr	r3, [r5, #8]
 8000af8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000afc:	60ab      	str	r3, [r5, #8]
 8000afe:	e71a      	b.n	8000936 <bsec_codegen_sensor_control+0x16e>
 8000b00:	00000000 	.word	0x00000000
 8000b04:	401c0000 	.word	0x401c0000
 8000b08:	00000000 	.word	0x00000000
 8000b0c:	40240000 	.word	0x40240000
 8000b10:	02160ec0 	.word	0x02160ec0
 8000b14:	4e6e6b28 	.word	0x4e6e6b28
 8000b18:	42700000 	.word	0x42700000
 8000b1c:	43700000 	.word	0x43700000
 8000b20:	0802d6d8 	.word	0x0802d6d8
 8000b24:	f894 3cb4 	ldrb.w	r3, [r4, #3252]	; 0xcb4
 8000b28:	2b00      	cmp	r3, #0
 8000b2a:	f43f ae9c 	beq.w	8000866 <bsec_codegen_sensor_control+0x9e>
 8000b2e:	f894 3c87 	ldrb.w	r3, [r4, #3207]	; 0xc87
 8000b32:	f894 0c86 	ldrb.w	r0, [r4, #3206]	; 0xc86
 8000b36:	4418      	add	r0, r3
 8000b38:	f006 ff74 	bl	8007a24 <__aeabi_i2d>
 8000b3c:	ec41 0b10 	vmov	d0, r0, r1
 8000b40:	f894 0c88 	ldrb.w	r0, [r4, #3208]	; 0xc88
 8000b44:	f000 fbd4 	bl	80012f0 <bsec_rem>
 8000b48:	f894 2c86 	ldrb.w	r2, [r4, #3206]	; 0xc86
 8000b4c:	3001      	adds	r0, #1
 8000b4e:	b2c3      	uxtb	r3, r0
 8000b50:	429a      	cmp	r2, r3
 8000b52:	f884 3c88 	strb.w	r3, [r4, #3208]	; 0xc88
 8000b56:	f4bf ae86 	bcs.w	8000866 <bsec_codegen_sensor_control+0x9e>
 8000b5a:	4649      	mov	r1, r9
 8000b5c:	2214      	movs	r2, #20
 8000b5e:	a811      	add	r0, sp, #68	; 0x44
 8000b60:	f02b fabe 	bl	802c0e0 <memcpy>
 8000b64:	f8bd 0044 	ldrh.w	r0, [sp, #68]	; 0x44
 8000b68:	f006 ff4c 	bl	8007a04 <__aeabi_ui2d>
 8000b6c:	af11      	add	r7, sp, #68	; 0x44
 8000b6e:	4680      	mov	r8, r0
 8000b70:	4689      	mov	r9, r1
 8000b72:	f837 0f02 	ldrh.w	r0, [r7, #2]!
 8000b76:	f006 ff45 	bl	8007a04 <__aeabi_ui2d>
 8000b7a:	460b      	mov	r3, r1
 8000b7c:	4602      	mov	r2, r0
 8000b7e:	4649      	mov	r1, r9
 8000b80:	4640      	mov	r0, r8
 8000b82:	f006 fe03 	bl	800778c <__adddf3>
 8000b86:	f10d 0356 	add.w	r3, sp, #86	; 0x56
 8000b8a:	42bb      	cmp	r3, r7
 8000b8c:	4680      	mov	r8, r0
 8000b8e:	4689      	mov	r9, r1
 8000b90:	d1ef      	bne.n	8000b72 <bsec_codegen_sensor_control+0x3aa>
 8000b92:	f007 fc6f 	bl	8008474 <__aeabi_d2lz>
 8000b96:	f894 8c87 	ldrb.w	r8, [r4, #3207]	; 0xc87
 8000b9a:	f8df e29c 	ldr.w	lr, [pc, #668]	; 8000e38 <bsec_codegen_sensor_control+0x670>
 8000b9e:	fba8 2300 	umull	r2, r3, r8, r0
 8000ba2:	fb01 3308 	mla	r3, r1, r8, r3
 8000ba6:	00df      	lsls	r7, r3, #3
 8000ba8:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8000bac:	eb1c 0c02 	adds.w	ip, ip, r2
 8000bb0:	ea47 7752 	orr.w	r7, r7, r2, lsr #29
 8000bb4:	eb43 0707 	adc.w	r7, r3, r7
 8000bb8:	ea4f 018c 	mov.w	r1, ip, lsl #2
 8000bbc:	00bf      	lsls	r7, r7, #2
 8000bbe:	ea47 779c 	orr.w	r7, r7, ip, lsr #30
 8000bc2:	ebb1 0c02 	subs.w	ip, r1, r2
 8000bc6:	fba2 010e 	umull	r0, r1, r2, lr
 8000bca:	fb0e 1103 	mla	r1, lr, r3, r1
 8000bce:	eb67 0703 	sbc.w	r7, r7, r3
 8000bd2:	eb10 030b 	adds.w	r3, r0, fp
 8000bd6:	eb41 0206 	adc.w	r2, r1, r6
 8000bda:	00bf      	lsls	r7, r7, #2
 8000bdc:	e9c5 3200 	strd	r3, r2, [r5]
 8000be0:	ea47 779c 	orr.w	r7, r7, ip, lsr #30
 8000be4:	4629      	mov	r1, r5
 8000be6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8000bea:	2200      	movs	r2, #0
 8000bec:	4620      	mov	r0, r4
 8000bee:	e9cd c70e 	strd	ip, r7, [sp, #56]	; 0x38
 8000bf2:	f001 f875 	bl	8001ce0 <bsec_Bsec_setSensorOpMode>
 8000bf6:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
 8000bfa:	2301      	movs	r3, #1
 8000bfc:	f1b8 0f00 	cmp.w	r8, #0
 8000c00:	f884 3c88 	strb.w	r3, [r4, #3208]	; 0xc88
 8000c04:	f179 0300 	sbcs.w	r3, r9, #0
 8000c08:	f2c0 80d9 	blt.w	8000dbe <bsec_codegen_sensor_control+0x5f6>
 8000c0c:	220a      	movs	r2, #10
 8000c0e:	2300      	movs	r3, #0
 8000c10:	4640      	mov	r0, r8
 8000c12:	4649      	mov	r1, r9
 8000c14:	f007 fc16 	bl	8008444 <__aeabi_uldivmod>
 8000c18:	220a      	movs	r2, #10
 8000c1a:	4605      	mov	r5, r0
 8000c1c:	2300      	movs	r3, #0
 8000c1e:	4640      	mov	r0, r8
 8000c20:	4649      	mov	r1, r9
 8000c22:	f007 fc0f 	bl	8008444 <__aeabi_uldivmod>
 8000c26:	2b00      	cmp	r3, #0
 8000c28:	bf08      	it	eq
 8000c2a:	2a05      	cmpeq	r2, #5
 8000c2c:	f080 80ea 	bcs.w	8000e04 <bsec_codegen_sensor_control+0x63c>
 8000c30:	b2a8      	uxth	r0, r5
 8000c32:	f8a4 0c22 	strh.w	r0, [r4, #3106]	; 0xc22
 8000c36:	e9ca b600 	strd	fp, r6, [sl]
 8000c3a:	e636      	b.n	80008aa <bsec_codegen_sensor_control+0xe2>
 8000c3c:	2301      	movs	r3, #1
 8000c3e:	f885 3039 	strb.w	r3, [r5, #57]	; 0x39
 8000c42:	f894 2c7d 	ldrb.w	r2, [r4, #3197]	; 0xc7d
 8000c46:	f202 621b 	addw	r2, r2, #1563	; 0x61b
 8000c4a:	f10d 0335 	add.w	r3, sp, #53	; 0x35
 8000c4e:	f834 2012 	ldrh.w	r2, [r4, r2, lsl #1]
 8000c52:	81aa      	strh	r2, [r5, #12]
 8000c54:	f894 2c7f 	ldrb.w	r2, [r4, #3199]	; 0xc7f
 8000c58:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
 8000c5c:	f894 2c7e 	ldrb.w	r2, [r4, #3198]	; 0xc7e
 8000c60:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
 8000c64:	a911      	add	r1, sp, #68	; 0x44
 8000c66:	aa0e      	add	r2, sp, #56	; 0x38
 8000c68:	4620      	mov	r0, r4
 8000c6a:	f002 f9df 	bl	800302c <bsec_c_ChannelHub_getInput>
 8000c6e:	eddd 7a11 	vldr	s15, [sp, #68]	; 0x44
 8000c72:	eef5 7a40 	vcmp.f32	s15, #0.0
 8000c76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000c7a:	d10e      	bne.n	8000c9a <bsec_codegen_sensor_control+0x4d2>
 8000c7c:	f894 3c82 	ldrb.w	r3, [r4, #3202]	; 0xc82
 8000c80:	b95b      	cbnz	r3, 8000c9a <bsec_codegen_sensor_control+0x4d2>
 8000c82:	f894 3c7d 	ldrb.w	r3, [r4, #3197]	; 0xc7d
 8000c86:	f203 6317 	addw	r3, r3, #1559	; 0x617
 8000c8a:	f604 28c8 	addw	r8, r4, #2760	; 0xac8
 8000c8e:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
 8000c92:	81eb      	strh	r3, [r5, #14]
 8000c94:	e9c8 b600 	strd	fp, r6, [r8]
 8000c98:	e665      	b.n	8000966 <bsec_codegen_sensor_control+0x19e>
 8000c9a:	f604 28c8 	addw	r8, r4, #2760	; 0xac8
 8000c9e:	f504 692d 	add.w	r9, r4, #2768	; 0xad0
 8000ca2:	e9d8 2300 	ldrd	r2, r3, [r8]
 8000ca6:	e9d9 0100 	ldrd	r0, r1, [r9]
 8000caa:	4282      	cmp	r2, r0
 8000cac:	eb73 0c01 	sbcs.w	ip, r3, r1
 8000cb0:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 8000cb4:	da03      	bge.n	8000cbe <bsec_codegen_sensor_control+0x4f6>
 8000cb6:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 8000cba:	4602      	mov	r2, r0
 8000cbc:	460b      	mov	r3, r1
 8000cbe:	ebbb 0002 	subs.w	r0, fp, r2
 8000cc2:	eb66 0103 	sbc.w	r1, r6, r3
 8000cc6:	f007 fb2f 	bl	8008328 <__aeabi_l2f>
 8000cca:	eddf 7a53 	vldr	s15, [pc, #332]	; 8000e18 <bsec_codegen_sensor_control+0x650>
 8000cce:	ee07 0a10 	vmov	s14, r0
 8000cd2:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8000cd6:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 8000cda:	ed8d 0a11 	vstr	s0, [sp, #68]	; 0x44
 8000cde:	f028 febd 	bl	8029a5c <powf>
 8000ce2:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
 8000ce6:	eeb0 8a40 	vmov.f32	s16, s0
 8000cea:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
 8000cee:	f028 feb5 	bl	8029a5c <powf>
 8000cf2:	ed9d 7a11 	vldr	s14, [sp, #68]	; 0x44
 8000cf6:	eddf 4a49 	vldr	s9, [pc, #292]	; 8000e1c <bsec_codegen_sensor_control+0x654>
 8000cfa:	eddf 7a49 	vldr	s15, [pc, #292]	; 8000e20 <bsec_codegen_sensor_control+0x658>
 8000cfe:	ed9f 5a49 	vldr	s10, [pc, #292]	; 8000e24 <bsec_codegen_sensor_control+0x65c>
 8000d02:	eddf 5a49 	vldr	s11, [pc, #292]	; 8000e28 <bsec_codegen_sensor_control+0x660>
 8000d06:	ed9f 6a49 	vldr	s12, [pc, #292]	; 8000e2c <bsec_codegen_sensor_control+0x664>
 8000d0a:	eddf 6a49 	vldr	s13, [pc, #292]	; 8000e30 <bsec_codegen_sensor_control+0x668>
 8000d0e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8000d12:	ee28 8a24 	vmul.f32	s16, s16, s9
 8000d16:	ee67 7a07 	vmul.f32	s15, s14, s14
 8000d1a:	ee38 8a00 	vadd.f32	s16, s16, s0
 8000d1e:	ee67 7a85 	vmul.f32	s15, s15, s10
 8000d22:	ee27 7a25 	vmul.f32	s14, s14, s11
 8000d26:	ee78 7a27 	vadd.f32	s15, s16, s15
 8000d2a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8000d2e:	ee77 7a86 	vadd.f32	s15, s15, s12
 8000d32:	ee27 0aa6 	vmul.f32	s0, s15, s13
 8000d36:	f028 fc95 	bl	8029664 <roundf>
 8000d3a:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8000d3e:	f894 3c82 	ldrb.w	r3, [r4, #3202]	; 0xc82
 8000d42:	ee10 2a10 	vmov	r2, s0
 8000d46:	81ea      	strh	r2, [r5, #14]
 8000d48:	bb53      	cbnz	r3, 8000da0 <bsec_codegen_sensor_control+0x5d8>
 8000d4a:	9300      	str	r3, [sp, #0]
 8000d4c:	ed9f 0a39 	vldr	s0, [pc, #228]	; 8000e34 <bsec_codegen_sensor_control+0x66c>
 8000d50:	465a      	mov	r2, fp
 8000d52:	4633      	mov	r3, r6
 8000d54:	2116      	movs	r1, #22
 8000d56:	4620      	mov	r0, r4
 8000d58:	f002 f876 	bl	8002e48 <bsec_ChannelHub_setInput>
 8000d5c:	f894 3c82 	ldrb.w	r3, [r4, #3202]	; 0xc82
 8000d60:	2b00      	cmp	r3, #0
 8000d62:	d097      	beq.n	8000c94 <bsec_codegen_sensor_control+0x4cc>
 8000d64:	e9c9 b600 	strd	fp, r6, [r9]
 8000d68:	e5fd      	b.n	8000966 <bsec_codegen_sensor_control+0x19e>
 8000d6a:	eeb0 0a48 	vmov.f32	s0, s16
 8000d6e:	eef0 0a68 	vmov.f32	s1, s17
 8000d72:	e9da 6700 	ldrd	r6, r7, [sl]
 8000d76:	f8b4 8c22 	ldrh.w	r8, [r4, #3106]	; 0xc22
 8000d7a:	f005 fed7 	bl	8006b2c <bsec_rt_roundd>
 8000d7e:	ec51 0b10 	vmov	r0, r1, d0
 8000d82:	f007 fb77 	bl	8008474 <__aeabi_d2lz>
 8000d86:	fba0 2308 	umull	r2, r3, r0, r8
 8000d8a:	1996      	adds	r6, r2, r6
 8000d8c:	fb01 3308 	mla	r3, r1, r8, r3
 8000d90:	eb47 0303 	adc.w	r3, r7, r3
 8000d94:	e9c5 6300 	strd	r6, r3, [r5]
 8000d98:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8000d9a:	2264      	movs	r2, #100	; 0x64
 8000d9c:	701a      	strb	r2, [r3, #0]
 8000d9e:	e584      	b.n	80008aa <bsec_codegen_sensor_control+0xe2>
 8000da0:	2300      	movs	r3, #0
 8000da2:	9300      	str	r3, [sp, #0]
 8000da4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8000da8:	4633      	mov	r3, r6
 8000daa:	465a      	mov	r2, fp
 8000dac:	2116      	movs	r1, #22
 8000dae:	4620      	mov	r0, r4
 8000db0:	f002 f84a 	bl	8002e48 <bsec_ChannelHub_setInput>
 8000db4:	68ab      	ldr	r3, [r5, #8]
 8000db6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8000dba:	60ab      	str	r3, [r5, #8]
 8000dbc:	e7ce      	b.n	8000d5c <bsec_codegen_sensor_control+0x594>
 8000dbe:	f1b9 4f00 	cmp.w	r9, #2147483648	; 0x80000000
 8000dc2:	bf08      	it	eq
 8000dc4:	f1b8 0f00 	cmpeq.w	r8, #0
 8000dc8:	d01f      	beq.n	8000e0a <bsec_codegen_sensor_control+0x642>
 8000dca:	f1d8 0800 	rsbs	r8, r8, #0
 8000dce:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
 8000dd2:	220a      	movs	r2, #10
 8000dd4:	2300      	movs	r3, #0
 8000dd6:	4640      	mov	r0, r8
 8000dd8:	4649      	mov	r1, r9
 8000dda:	f007 fb33 	bl	8008444 <__aeabi_uldivmod>
 8000dde:	4603      	mov	r3, r0
 8000de0:	460d      	mov	r5, r1
 8000de2:	9302      	str	r3, [sp, #8]
 8000de4:	4640      	mov	r0, r8
 8000de6:	4649      	mov	r1, r9
 8000de8:	220a      	movs	r2, #10
 8000dea:	2300      	movs	r3, #0
 8000dec:	9503      	str	r5, [sp, #12]
 8000dee:	f007 fb29 	bl	8008444 <__aeabi_uldivmod>
 8000df2:	2b00      	cmp	r3, #0
 8000df4:	bf08      	it	eq
 8000df6:	2a05      	cmpeq	r2, #5
 8000df8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8000dfc:	d208      	bcs.n	8000e10 <bsec_codegen_sensor_control+0x648>
 8000dfe:	4240      	negs	r0, r0
 8000e00:	b280      	uxth	r0, r0
 8000e02:	e716      	b.n	8000c32 <bsec_codegen_sensor_control+0x46a>
 8000e04:	1c68      	adds	r0, r5, #1
 8000e06:	b280      	uxth	r0, r0
 8000e08:	e713      	b.n	8000c32 <bsec_codegen_sensor_control+0x46a>
 8000e0a:	f243 3033 	movw	r0, #13107	; 0x3333
 8000e0e:	e710      	b.n	8000c32 <bsec_codegen_sensor_control+0x46a>
 8000e10:	43c0      	mvns	r0, r0
 8000e12:	b280      	uxth	r0, r0
 8000e14:	e70d      	b.n	8000c32 <bsec_codegen_sensor_control+0x46a>
 8000e16:	bf00      	nop
 8000e18:	4e6e6b28 	.word	0x4e6e6b28
 8000e1c:	b0078259 	.word	0xb0078259
 8000e20:	34c2e0df 	.word	0x34c2e0df
 8000e24:	b8d96737 	.word	0xb8d96737
 8000e28:	3c868e5a 	.word	0x3c868e5a
 8000e2c:	3ee4926a 	.word	0x3ee4926a
 8000e30:	447a0000 	.word	0x447a0000
 8000e34:	00000000 	.word	0x00000000
 8000e38:	08583b00 	.word	0x08583b00

08000e3c <bsec_codegen_set_configuration>:
 8000e3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e40:	b08b      	sub	sp, #44	; 0x2c
 8000e42:	4688      	mov	r8, r1
 8000e44:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 8000e48:	4616      	mov	r6, r2
 8000e4a:	2100      	movs	r1, #0
 8000e4c:	f500 622c 	add.w	r2, r0, #2752	; 0xac0
 8000e50:	4605      	mov	r5, r0
 8000e52:	f10d 0b1e 	add.w	fp, sp, #30
 8000e56:	2000      	movs	r0, #0
 8000e58:	f10d 0a20 	add.w	sl, sp, #32
 8000e5c:	e9c2 0100 	strd	r0, r1, [r2]
 8000e60:	461c      	mov	r4, r3
 8000e62:	4631      	mov	r1, r6
 8000e64:	465b      	mov	r3, fp
 8000e66:	4640      	mov	r0, r8
 8000e68:	464a      	mov	r2, r9
 8000e6a:	f8cd a000 	str.w	sl, [sp]
 8000e6e:	f000 ffb1 	bl	8001dd4 <bsec_Bsec_validateSerialization>
 8000e72:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000e76:	bb13      	cbnz	r3, 8000ebe <bsec_codegen_set_configuration+0x82>
 8000e78:	f10d 031f 	add.w	r3, sp, #31
 8000e7c:	3e08      	subs	r6, #8
 8000e7e:	9305      	str	r3, [sp, #20]
 8000e80:	9f08      	ldr	r7, [sp, #32]
 8000e82:	42b7      	cmp	r7, r6
 8000e84:	464b      	mov	r3, r9
 8000e86:	4622      	mov	r2, r4
 8000e88:	4651      	mov	r1, sl
 8000e8a:	4640      	mov	r0, r8
 8000e8c:	d225      	bcs.n	8000eda <bsec_codegen_set_configuration+0x9e>
 8000e8e:	af09      	add	r7, sp, #36	; 0x24
 8000e90:	9702      	str	r7, [sp, #8]
 8000e92:	9f05      	ldr	r7, [sp, #20]
 8000e94:	e9cd b700 	strd	fp, r7, [sp]
 8000e98:	f000 fd10 	bl	80018bc <bsec_Bsec_parse>
 8000e9c:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000ea0:	4622      	mov	r2, r4
 8000ea2:	4628      	mov	r0, r5
 8000ea4:	b95b      	cbnz	r3, 8000ebe <bsec_codegen_set_configuration+0x82>
 8000ea6:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8000eaa:	29fe      	cmp	r1, #254	; 0xfe
 8000eac:	d00b      	beq.n	8000ec6 <bsec_codegen_set_configuration+0x8a>
 8000eae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000eb0:	f001 f9a8 	bl	8002204 <bsec_ChannelHub_configureChannel>
 8000eb4:	4603      	mov	r3, r0
 8000eb6:	f88d 001e 	strb.w	r0, [sp, #30]
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d0e0      	beq.n	8000e80 <bsec_codegen_set_configuration+0x44>
 8000ebe:	4618      	mov	r0, r3
 8000ec0:	b00b      	add	sp, #44	; 0x2c
 8000ec2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ec6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8000ec8:	4621      	mov	r1, r4
 8000eca:	f001 f809 	bl	8001ee0 <bsec_b_Bsec_setHyperConfiguration>
 8000ece:	4603      	mov	r3, r0
 8000ed0:	f88d 001e 	strb.w	r0, [sp, #30]
 8000ed4:	2b00      	cmp	r3, #0
 8000ed6:	d0d3      	beq.n	8000e80 <bsec_codegen_set_configuration+0x44>
 8000ed8:	e7f1      	b.n	8000ebe <bsec_codegen_set_configuration+0x82>
 8000eda:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000ede:	4618      	mov	r0, r3
 8000ee0:	b00b      	add	sp, #44	; 0x2c
 8000ee2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ee6:	bf00      	nop

08000ee8 <bsec_codegen_set_state>:
 8000ee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000eec:	b08b      	sub	sp, #44	; 0x2c
 8000eee:	460f      	mov	r7, r1
 8000ef0:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 8000ef4:	f10d 0b1e 	add.w	fp, sp, #30
 8000ef8:	f10d 0a20 	add.w	sl, sp, #32
 8000efc:	4611      	mov	r1, r2
 8000efe:	4615      	mov	r5, r2
 8000f00:	4680      	mov	r8, r0
 8000f02:	461c      	mov	r4, r3
 8000f04:	4638      	mov	r0, r7
 8000f06:	465b      	mov	r3, fp
 8000f08:	464a      	mov	r2, r9
 8000f0a:	f8cd a000 	str.w	sl, [sp]
 8000f0e:	f000 ff61 	bl	8001dd4 <bsec_Bsec_validateSerialization>
 8000f12:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000f16:	bb13      	cbnz	r3, 8000f5e <bsec_codegen_set_state+0x76>
 8000f18:	f10d 031f 	add.w	r3, sp, #31
 8000f1c:	3d08      	subs	r5, #8
 8000f1e:	9305      	str	r3, [sp, #20]
 8000f20:	9e08      	ldr	r6, [sp, #32]
 8000f22:	42ae      	cmp	r6, r5
 8000f24:	464b      	mov	r3, r9
 8000f26:	4622      	mov	r2, r4
 8000f28:	4651      	mov	r1, sl
 8000f2a:	4638      	mov	r0, r7
 8000f2c:	d225      	bcs.n	8000f7a <bsec_codegen_set_state+0x92>
 8000f2e:	ae09      	add	r6, sp, #36	; 0x24
 8000f30:	9602      	str	r6, [sp, #8]
 8000f32:	9e05      	ldr	r6, [sp, #20]
 8000f34:	e9cd b600 	strd	fp, r6, [sp]
 8000f38:	f000 fcc0 	bl	80018bc <bsec_Bsec_parse>
 8000f3c:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000f40:	4622      	mov	r2, r4
 8000f42:	4640      	mov	r0, r8
 8000f44:	b95b      	cbnz	r3, 8000f5e <bsec_codegen_set_state+0x76>
 8000f46:	f89d 101f 	ldrb.w	r1, [sp, #31]
 8000f4a:	29fe      	cmp	r1, #254	; 0xfe
 8000f4c:	d00b      	beq.n	8000f66 <bsec_codegen_set_state+0x7e>
 8000f4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000f50:	f001 ff40 	bl	8002dd4 <bsec_ChannelHub_setChannelState>
 8000f54:	4603      	mov	r3, r0
 8000f56:	f88d 001e 	strb.w	r0, [sp, #30]
 8000f5a:	2b00      	cmp	r3, #0
 8000f5c:	d0e0      	beq.n	8000f20 <bsec_codegen_set_state+0x38>
 8000f5e:	4618      	mov	r0, r3
 8000f60:	b00b      	add	sp, #44	; 0x2c
 8000f62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f66:	9909      	ldr	r1, [sp, #36]	; 0x24
 8000f68:	4620      	mov	r0, r4
 8000f6a:	f001 f883 	bl	8002074 <bsec_b_Bsec_setHyperState>
 8000f6e:	4603      	mov	r3, r0
 8000f70:	f88d 001e 	strb.w	r0, [sp, #30]
 8000f74:	2b00      	cmp	r3, #0
 8000f76:	d0d3      	beq.n	8000f20 <bsec_codegen_set_state+0x38>
 8000f78:	e7f1      	b.n	8000f5e <bsec_codegen_set_state+0x76>
 8000f7a:	f99d 301e 	ldrsb.w	r3, [sp, #30]
 8000f7e:	4618      	mov	r0, r3
 8000f80:	b00b      	add	sp, #44	; 0x2c
 8000f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000f86:	bf00      	nop

08000f88 <bsec_codegen_update_subscription>:
 8000f88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f8c:	ed2d 8b04 	vpush	{d8-d9}
 8000f90:	b08f      	sub	sp, #60	; 0x3c
 8000f92:	f04f 0900 	mov.w	r9, #0
 8000f96:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8000f98:	4616      	mov	r6, r2
 8000f9a:	4604      	mov	r4, r0
 8000f9c:	460d      	mov	r5, r1
 8000f9e:	f887 9000 	strb.w	r9, [r7]
 8000fa2:	f500 6144 	add.w	r1, r0, #3136	; 0xc40
 8000fa6:	2226      	movs	r2, #38	; 0x26
 8000fa8:	a804      	add	r0, sp, #16
 8000faa:	4698      	mov	r8, r3
 8000fac:	f02b f898 	bl	802c0e0 <memcpy>
 8000fb0:	bb76      	cbnz	r6, 8001010 <bsec_codegen_update_subscription+0x88>
 8000fb2:	230c      	movs	r3, #12
 8000fb4:	f884 6cb3 	strb.w	r6, [r4, #3251]	; 0xcb3
 8000fb8:	703b      	strb	r3, [r7, #0]
 8000fba:	a904      	add	r1, sp, #16
 8000fbc:	4620      	mov	r0, r4
 8000fbe:	f000 fae1 	bl	8001584 <bsec_Bsec_checkSamplIntvlCompatibility>
 8000fc2:	2800      	cmp	r0, #0
 8000fc4:	f040 8121 	bne.w	800120a <bsec_codegen_update_subscription+0x282>
 8000fc8:	f997 0000 	ldrsb.w	r0, [r7]
 8000fcc:	2800      	cmp	r0, #0
 8000fce:	db55      	blt.n	800107c <bsec_codegen_update_subscription+0xf4>
 8000fd0:	4eb9      	ldr	r6, [pc, #740]	; (80012b8 <bsec_codegen_update_subscription+0x330>)
 8000fd2:	f8df 92f8 	ldr.w	r9, [pc, #760]	; 80012cc <bsec_codegen_update_subscription+0x344>
 8000fd6:	2300      	movs	r3, #0
 8000fd8:	e003      	b.n	8000fe2 <bsec_codegen_update_subscription+0x5a>
 8000fda:	1c5d      	adds	r5, r3, #1
 8000fdc:	2d1a      	cmp	r5, #26
 8000fde:	462b      	mov	r3, r5
 8000fe0:	d04c      	beq.n	800107c <bsec_codegen_update_subscription+0xf4>
 8000fe2:	fa46 f203 	asr.w	r2, r6, r3
 8000fe6:	07d5      	lsls	r5, r2, #31
 8000fe8:	d5f7      	bpl.n	8000fda <bsec_codegen_update_subscription+0x52>
 8000fea:	f813 2009 	ldrb.w	r2, [r3, r9]
 8000fee:	a90e      	add	r1, sp, #56	; 0x38
 8000ff0:	eb01 0042 	add.w	r0, r1, r2, lsl #1
 8000ff4:	f202 611f 	addw	r1, r2, #1567	; 0x61f
 8000ff8:	f830 2c2a 	ldrh.w	r2, [r0, #-42]
 8000ffc:	f834 1011 	ldrh.w	r1, [r4, r1, lsl #1]
 8001000:	1c5d      	adds	r5, r3, #1
 8001002:	4291      	cmp	r1, r2
 8001004:	4620      	mov	r0, r4
 8001006:	b2e9      	uxtb	r1, r5
 8001008:	d0e8      	beq.n	8000fdc <bsec_codegen_update_subscription+0x54>
 800100a:	f000 fc97 	bl	800193c <bsec_Bsec_requestOutput>
 800100e:	e7e5      	b.n	8000fdc <bsec_codegen_update_subscription+0x54>
 8001010:	792b      	ldrb	r3, [r5, #4]
 8001012:	3b01      	subs	r3, #1
 8001014:	b2da      	uxtb	r2, r3
 8001016:	2a01      	cmp	r2, #1
 8001018:	d93f      	bls.n	800109a <bsec_codegen_update_subscription+0x112>
 800101a:	2200      	movs	r2, #0
 800101c:	f8cd 8004 	str.w	r8, [sp, #4]
 8001020:	f8df a294 	ldr.w	sl, [pc, #660]	; 80012b8 <bsec_codegen_update_subscription+0x330>
 8001024:	ed9f 8aa5 	vldr	s16, [pc, #660]	; 80012bc <bsec_codegen_update_subscription+0x334>
 8001028:	ed9f 9aa5 	vldr	s18, [pc, #660]	; 80012c0 <bsec_codegen_update_subscription+0x338>
 800102c:	eddf 8aa5 	vldr	s17, [pc, #660]	; 80012c4 <bsec_codegen_update_subscription+0x33c>
 8001030:	f884 2cb3 	strb.w	r2, [r4, #3251]	; 0xcb3
 8001034:	eb05 06c6 	add.w	r6, r5, r6, lsl #3
 8001038:	4690      	mov	r8, r2
 800103a:	e011      	b.n	8001060 <bsec_codegen_update_subscription+0xd8>
 800103c:	fa4a f203 	asr.w	r2, sl, r3
 8001040:	07d2      	lsls	r2, r2, #31
 8001042:	d510      	bpl.n	8001066 <bsec_codegen_update_subscription+0xde>
 8001044:	2201      	movs	r2, #1
 8001046:	fa02 f303 	lsl.w	r3, r2, r3
 800104a:	ea13 0b08 	ands.w	fp, r3, r8
 800104e:	f000 8092 	beq.w	8001176 <bsec_codegen_update_subscription+0x1ee>
 8001052:	23f3      	movs	r3, #243	; 0xf3
 8001054:	703b      	strb	r3, [r7, #0]
 8001056:	3508      	adds	r5, #8
 8001058:	42b5      	cmp	r5, r6
 800105a:	d009      	beq.n	8001070 <bsec_codegen_update_subscription+0xe8>
 800105c:	792b      	ldrb	r3, [r5, #4]
 800105e:	3b01      	subs	r3, #1
 8001060:	b2db      	uxtb	r3, r3
 8001062:	2b19      	cmp	r3, #25
 8001064:	d9ea      	bls.n	800103c <bsec_codegen_update_subscription+0xb4>
 8001066:	3508      	adds	r5, #8
 8001068:	230a      	movs	r3, #10
 800106a:	42b5      	cmp	r5, r6
 800106c:	703b      	strb	r3, [r7, #0]
 800106e:	d1f5      	bne.n	800105c <bsec_codegen_update_subscription+0xd4>
 8001070:	f997 3000 	ldrsb.w	r3, [r7]
 8001074:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8001078:	2b00      	cmp	r3, #0
 800107a:	da9e      	bge.n	8000fba <bsec_codegen_update_subscription+0x32>
 800107c:	f898 3000 	ldrb.w	r3, [r8]
 8001080:	2b07      	cmp	r3, #7
 8001082:	d821      	bhi.n	80010c8 <bsec_codegen_update_subscription+0x140>
 8001084:	23f1      	movs	r3, #241	; 0xf1
 8001086:	703b      	strb	r3, [r7, #0]
 8001088:	f04f 0e00 	mov.w	lr, #0
 800108c:	f888 e000 	strb.w	lr, [r8]
 8001090:	b00f      	add	sp, #60	; 0x3c
 8001092:	ecbd 8b04 	vpop	{d8-d9}
 8001096:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800109a:	edd5 7a00 	vldr	s15, [r5]
 800109e:	eef5 7a40 	vcmp.f32	s15, #0.0
 80010a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010a6:	d1b8      	bne.n	800101a <bsec_codegen_update_subscription+0x92>
 80010a8:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 80010ac:	f247 5330 	movw	r3, #30000	; 0x7530
 80010b0:	429a      	cmp	r2, r3
 80010b2:	f000 80e9 	beq.w	8001288 <bsec_codegen_update_subscription+0x300>
 80010b6:	f8bd 2012 	ldrh.w	r2, [sp, #18]
 80010ba:	429a      	cmp	r2, r3
 80010bc:	f000 80e4 	beq.w	8001288 <bsec_codegen_update_subscription+0x300>
 80010c0:	230b      	movs	r3, #11
 80010c2:	46ce      	mov	lr, r9
 80010c4:	703b      	strb	r3, [r7, #0]
 80010c6:	e7e1      	b.n	800108c <bsec_codegen_update_subscription+0x104>
 80010c8:	2500      	movs	r5, #0
 80010ca:	f8df a204 	ldr.w	sl, [pc, #516]	; 80012d0 <bsec_codegen_update_subscription+0x348>
 80010ce:	ed9f 6a7b 	vldr	s12, [pc, #492]	; 80012bc <bsec_codegen_update_subscription+0x334>
 80010d2:	4979      	ldr	r1, [pc, #484]	; (80012b8 <bsec_codegen_update_subscription+0x330>)
 80010d4:	4f7c      	ldr	r7, [pc, #496]	; (80012c8 <bsec_codegen_update_subscription+0x340>)
 80010d6:	f8df c1f4 	ldr.w	ip, [pc, #500]	; 80012cc <bsec_codegen_update_subscription+0x344>
 80010da:	eddf 5a79 	vldr	s11, [pc, #484]	; 80012c0 <bsec_codegen_update_subscription+0x338>
 80010de:	f8dd b074 	ldr.w	fp, [sp, #116]	; 0x74
 80010e2:	46ae      	mov	lr, r5
 80010e4:	e002      	b.n	80010ec <bsec_codegen_update_subscription+0x164>
 80010e6:	3501      	adds	r5, #1
 80010e8:	2d18      	cmp	r5, #24
 80010ea:	d0cf      	beq.n	800108c <bsec_codegen_update_subscription+0x104>
 80010ec:	2201      	movs	r2, #1
 80010ee:	40aa      	lsls	r2, r5
 80010f0:	ea12 0f0a 	tst.w	r2, sl
 80010f4:	d0f7      	beq.n	80010e6 <bsec_codegen_update_subscription+0x15e>
 80010f6:	f10e 0e01 	add.w	lr, lr, #1
 80010fa:	fa5f fe8e 	uxtb.w	lr, lr
 80010fe:	f10e 36ff 	add.w	r6, lr, #4294967295	; 0xffffffff
 8001102:	eb0b 06c6 	add.w	r6, fp, r6, lsl #3
 8001106:	3501      	adds	r5, #1
 8001108:	7135      	strb	r5, [r6, #4]
 800110a:	ed86 6a00 	vstr	s12, [r6]
 800110e:	2300      	movs	r3, #0
 8001110:	f64f 79ff 	movw	r9, #65535	; 0xffff
 8001114:	e00c      	b.n	8001130 <bsec_codegen_update_subscription+0x1a8>
 8001116:	4548      	cmp	r0, r9
 8001118:	d007      	beq.n	800112a <bsec_codegen_update_subscription+0x1a2>
 800111a:	ee07 0a90 	vmov	s15, r0
 800111e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001122:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 8001126:	ed86 7a00 	vstr	s14, [r6]
 800112a:	3301      	adds	r3, #1
 800112c:	2b1a      	cmp	r3, #26
 800112e:	d0db      	beq.n	80010e8 <bsec_codegen_update_subscription+0x160>
 8001130:	fa41 f003 	asr.w	r0, r1, r3
 8001134:	07c0      	lsls	r0, r0, #31
 8001136:	d5f8      	bpl.n	800112a <bsec_codegen_update_subscription+0x1a2>
 8001138:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 800113c:	4202      	tst	r2, r0
 800113e:	d0f4      	beq.n	800112a <bsec_codegen_update_subscription+0x1a2>
 8001140:	edd6 7a00 	vldr	s15, [r6]
 8001144:	f813 000c 	ldrb.w	r0, [r3, ip]
 8001148:	eef4 7a46 	vcmp.f32	s15, s12
 800114c:	f200 601f 	addw	r0, r0, #1567	; 0x61f
 8001150:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001154:	f834 0010 	ldrh.w	r0, [r4, r0, lsl #1]
 8001158:	d0dd      	beq.n	8001116 <bsec_codegen_update_subscription+0x18e>
 800115a:	ee07 0a10 	vmov	s14, r0
 800115e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001162:	eec5 6a87 	vdiv.f32	s13, s11, s14
 8001166:	eef4 7ae6 	vcmpe.f32	s15, s13
 800116a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800116e:	bf48      	it	mi
 8001170:	edc6 6a00 	vstrmi	s13, [r6]
 8001174:	e7d9      	b.n	800112a <bsec_codegen_update_subscription+0x1a2>
 8001176:	edd5 7a00 	vldr	s15, [r5]
 800117a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800117e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001182:	ea48 0803 	orr.w	r8, r8, r3
 8001186:	d12a      	bne.n	80011de <bsec_codegen_update_subscription+0x256>
 8001188:	23f6      	movs	r3, #246	; 0xf6
 800118a:	703b      	strb	r3, [r7, #0]
 800118c:	edd5 7a00 	vldr	s15, [r5]
 8001190:	eef5 7a40 	vcmp.f32	s15, #0.0
 8001194:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001198:	eeb0 0a67 	vmov.f32	s0, s15
 800119c:	d11f      	bne.n	80011de <bsec_codegen_update_subscription+0x256>
 800119e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80011a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011a6:	dc32      	bgt.n	800120e <bsec_codegen_update_subscription+0x286>
 80011a8:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80011ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011b0:	bf14      	ite	ne
 80011b2:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 80011b6:	2300      	moveq	r3, #0
 80011b8:	b29b      	uxth	r3, r3
 80011ba:	9302      	str	r3, [sp, #8]
 80011bc:	f997 3000 	ldrsb.w	r3, [r7]
 80011c0:	2b00      	cmp	r3, #0
 80011c2:	f47f af48 	bne.w	8001056 <bsec_codegen_update_subscription+0xce>
 80011c6:	4a41      	ldr	r2, [pc, #260]	; (80012cc <bsec_codegen_update_subscription+0x344>)
 80011c8:	792b      	ldrb	r3, [r5, #4]
 80011ca:	4413      	add	r3, r2
 80011cc:	aa0e      	add	r2, sp, #56	; 0x38
 80011ce:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 80011d2:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80011d6:	9a02      	ldr	r2, [sp, #8]
 80011d8:	f823 2c2a 	strh.w	r2, [r3, #-42]
 80011dc:	e73b      	b.n	8001056 <bsec_codegen_update_subscription+0xce>
 80011de:	eef4 7a48 	vcmp.f32	s15, s16
 80011e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011e6:	d04c      	beq.n	8001282 <bsec_codegen_update_subscription+0x2fa>
 80011e8:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 80011ec:	eef4 7ac7 	vcmpe.f32	s15, s14
 80011f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011f4:	dc04      	bgt.n	8001200 <bsec_codegen_update_subscription+0x278>
 80011f6:	eef4 7ae8 	vcmpe.f32	s15, s17
 80011fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011fe:	d54d      	bpl.n	800129c <bsec_codegen_update_subscription+0x314>
 8001200:	23f2      	movs	r3, #242	; 0xf2
 8001202:	703b      	strb	r3, [r7, #0]
 8001204:	ed95 0a00 	vldr	s0, [r5]
 8001208:	e7c9      	b.n	800119e <bsec_codegen_update_subscription+0x216>
 800120a:	7038      	strb	r0, [r7, #0]
 800120c:	e6de      	b.n	8000fcc <bsec_codegen_update_subscription+0x44>
 800120e:	eeb4 0ac8 	vcmpe.f32	s0, s16
 8001212:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001216:	d5c7      	bpl.n	80011a8 <bsec_codegen_update_subscription+0x220>
 8001218:	ee89 0a00 	vdiv.f32	s0, s18, s0
 800121c:	f028 fa22 	bl	8029664 <roundf>
 8001220:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8001224:	ee10 3a10 	vmov	r3, s0
 8001228:	b29b      	uxth	r3, r3
 800122a:	e9cd 3602 	strd	r3, r6, [sp, #8]
 800122e:	461e      	mov	r6, r3
 8001230:	4a26      	ldr	r2, [pc, #152]	; (80012cc <bsec_codegen_update_subscription+0x344>)
 8001232:	792b      	ldrb	r3, [r5, #4]
 8001234:	4413      	add	r3, r2
 8001236:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 800123a:	445b      	add	r3, fp
 800123c:	f203 538b 	addw	r3, r3, #1419	; 0x58b
 8001240:	f10b 0b13 	add.w	fp, fp, #19
 8001244:	f834 9013 	ldrh.w	r9, [r4, r3, lsl #1]
 8001248:	4648      	mov	r0, r9
 800124a:	f006 fbdb 	bl	8007a04 <__aeabi_ui2d>
 800124e:	a318      	add	r3, pc, #96	; (adr r3, 80012b0 <bsec_codegen_update_subscription+0x328>)
 8001250:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001254:	f006 fc50 	bl	8007af8 <__aeabi_dmul>
 8001258:	ec41 0b10 	vmov	d0, r0, r1
 800125c:	f005 fc66 	bl	8006b2c <bsec_rt_roundd>
 8001260:	ec51 0b10 	vmov	r0, r1, d0
 8001264:	f006 ff20 	bl	80080a8 <__aeabi_d2uiz>
 8001268:	b280      	uxth	r0, r0
 800126a:	eba9 0300 	sub.w	r3, r9, r0
 800126e:	b29b      	uxth	r3, r3
 8001270:	4481      	add	r9, r0
 8001272:	42b3      	cmp	r3, r6
 8001274:	fa1f f989 	uxth.w	r9, r9
 8001278:	d813      	bhi.n	80012a2 <bsec_codegen_update_subscription+0x31a>
 800127a:	45b1      	cmp	r9, r6
 800127c:	d311      	bcc.n	80012a2 <bsec_codegen_update_subscription+0x31a>
 800127e:	9e03      	ldr	r6, [sp, #12]
 8001280:	e79c      	b.n	80011bc <bsec_codegen_update_subscription+0x234>
 8001282:	eeb0 0a67 	vmov.f32	s0, s15
 8001286:	e78f      	b.n	80011a8 <bsec_codegen_update_subscription+0x220>
 8001288:	f994 3c83 	ldrsb.w	r3, [r4, #3203]	; 0xc83
 800128c:	2b00      	cmp	r3, #0
 800128e:	f47f aefa 	bne.w	8001086 <bsec_codegen_update_subscription+0xfe>
 8001292:	2201      	movs	r2, #1
 8001294:	469e      	mov	lr, r3
 8001296:	f884 2c82 	strb.w	r2, [r4, #3202]	; 0xc82
 800129a:	e6f7      	b.n	800108c <bsec_codegen_update_subscription+0x104>
 800129c:	eeb0 0a67 	vmov.f32	s0, s15
 80012a0:	e77d      	b.n	800119e <bsec_codegen_update_subscription+0x216>
 80012a2:	f1bb 0f72 	cmp.w	fp, #114	; 0x72
 80012a6:	d1c3      	bne.n	8001230 <bsec_codegen_update_subscription+0x2a8>
 80012a8:	23f4      	movs	r3, #244	; 0xf4
 80012aa:	9e03      	ldr	r6, [sp, #12]
 80012ac:	703b      	strb	r3, [r7, #0]
 80012ae:	e6d2      	b.n	8001056 <bsec_codegen_update_subscription+0xce>
 80012b0:	47ae147b 	.word	0x47ae147b
 80012b4:	3f847ae1 	.word	0x3f847ae1
 80012b8:	03f279ef 	.word	0x03f279ef
 80012bc:	477fff00 	.word	0x477fff00
 80012c0:	42c80000 	.word	0x42c80000
 80012c4:	3ada740e 	.word	0x3ada740e
 80012c8:	0802d654 	.word	0x0802d654
 80012cc:	0802d6bc 	.word	0x0802d6bc
 80012d0:	00e0200f 	.word	0x00e0200f

080012d4 <bsec_constructor_bsec>:
 80012d4:	b510      	push	{r4, lr}
 80012d6:	4604      	mov	r4, r0
 80012d8:	f000 ff22 	bl	8002120 <bsec_ChannelHub_ChannelHub>
 80012dc:	4620      	mov	r0, r4
 80012de:	f000 fcc7 	bl	8001c70 <bsec_Bsec_setHyperState>
 80012e2:	4620      	mov	r0, r4
 80012e4:	f000 fb5c 	bl	80019a0 <bsec_Bsec_setHyperConfiguration>
 80012e8:	4620      	mov	r0, r4
 80012ea:	bd10      	pop	{r4, pc}
 80012ec:	0000      	movs	r0, r0
	...

080012f0 <bsec_rem>:
 80012f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80012f2:	ed2d 8b02 	vpush	{d8}
 80012f6:	ec57 6b10 	vmov	r6, r7, d0
 80012fa:	4605      	mov	r5, r0
 80012fc:	f005 fc16 	bl	8006b2c <bsec_rt_roundd>
 8001300:	ec51 0b10 	vmov	r0, r1, d0
 8001304:	f006 fed0 	bl	80080a8 <__aeabi_d2uiz>
 8001308:	b2c4      	uxtb	r4, r0
 800130a:	4620      	mov	r0, r4
 800130c:	f006 fb8a 	bl	8007a24 <__aeabi_i2d>
 8001310:	4632      	mov	r2, r6
 8001312:	463b      	mov	r3, r7
 8001314:	f006 fe58 	bl	8007fc8 <__aeabi_dcmpeq>
 8001318:	b138      	cbz	r0, 800132a <bsec_rem+0x3a>
 800131a:	fbb5 f3f4 	udiv	r3, r5, r4
 800131e:	ecbd 8b02 	vpop	{d8}
 8001322:	fb04 5013 	mls	r0, r4, r3, r5
 8001326:	b2c0      	uxtb	r0, r0
 8001328:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800132a:	4628      	mov	r0, r5
 800132c:	f006 fb6a 	bl	8007a04 <__aeabi_ui2d>
 8001330:	2200      	movs	r2, #0
 8001332:	ec41 0b18 	vmov	d8, r0, r1
 8001336:	2300      	movs	r3, #0
 8001338:	4630      	mov	r0, r6
 800133a:	4639      	mov	r1, r7
 800133c:	f006 fe44 	bl	8007fc8 <__aeabi_dcmpeq>
 8001340:	bbe8      	cbnz	r0, 80013be <bsec_rem+0xce>
 8001342:	ec47 6b10 	vmov	d0, r6, r7
 8001346:	f028 f8bf 	bl	80294c8 <trunc>
 800134a:	4630      	mov	r0, r6
 800134c:	ec53 2b10 	vmov	r2, r3, d0
 8001350:	4639      	mov	r1, r7
 8001352:	f006 fe39 	bl	8007fc8 <__aeabi_dcmpeq>
 8001356:	bb90      	cbnz	r0, 80013be <bsec_rem+0xce>
 8001358:	4632      	mov	r2, r6
 800135a:	463b      	mov	r3, r7
 800135c:	ec51 0b18 	vmov	r0, r1, d8
 8001360:	f006 fcf4 	bl	8007d4c <__aeabi_ddiv>
 8001364:	ec41 0b10 	vmov	d0, r0, r1
 8001368:	f028 f822 	bl	80293b0 <fabs>
 800136c:	ec55 4b10 	vmov	r4, r5, d0
 8001370:	4b1f      	ldr	r3, [pc, #124]	; (80013f0 <bsec_rem+0x100>)
 8001372:	2200      	movs	r2, #0
 8001374:	ee10 0a10 	vmov	r0, s0
 8001378:	4629      	mov	r1, r5
 800137a:	f006 fa07 	bl	800778c <__adddf3>
 800137e:	ec41 0b10 	vmov	d0, r0, r1
 8001382:	f028 f821 	bl	80293c8 <floor>
 8001386:	4620      	mov	r0, r4
 8001388:	ec53 2b10 	vmov	r2, r3, d0
 800138c:	4629      	mov	r1, r5
 800138e:	f006 f9fb 	bl	8007788 <__aeabi_dsub>
 8001392:	ec41 0b10 	vmov	d0, r0, r1
 8001396:	f028 f80b 	bl	80293b0 <fabs>
 800139a:	4b16      	ldr	r3, [pc, #88]	; (80013f4 <bsec_rem+0x104>)
 800139c:	4620      	mov	r0, r4
 800139e:	4629      	mov	r1, r5
 80013a0:	2200      	movs	r2, #0
 80013a2:	ec55 4b10 	vmov	r4, r5, d0
 80013a6:	f006 fba7 	bl	8007af8 <__aeabi_dmul>
 80013aa:	4602      	mov	r2, r0
 80013ac:	460b      	mov	r3, r1
 80013ae:	4620      	mov	r0, r4
 80013b0:	4629      	mov	r1, r5
 80013b2:	f006 fe1d 	bl	8007ff0 <__aeabi_dcmple>
 80013b6:	b110      	cbz	r0, 80013be <bsec_rem+0xce>
 80013b8:	ed9f 0b0b 	vldr	d0, [pc, #44]	; 80013e8 <bsec_rem+0xf8>
 80013bc:	e007      	b.n	80013ce <bsec_rem+0xde>
 80013be:	ec47 6b11 	vmov	d1, r6, r7
 80013c2:	eeb0 0a48 	vmov.f32	s0, s16
 80013c6:	eef0 0a68 	vmov.f32	s1, s17
 80013ca:	f028 f9b3 	bl	8029734 <fmod>
 80013ce:	f005 fbad 	bl	8006b2c <bsec_rt_roundd>
 80013d2:	ec51 0b10 	vmov	r0, r1, d0
 80013d6:	f006 fe67 	bl	80080a8 <__aeabi_d2uiz>
 80013da:	ecbd 8b02 	vpop	{d8}
 80013de:	b2c0      	uxtb	r0, r0
 80013e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80013e2:	bf00      	nop
 80013e4:	f3af 8000 	nop.w
	...
 80013f0:	3fe00000 	.word	0x3fe00000
 80013f4:	3cb00000 	.word	0x3cb00000

080013f8 <bsec_Bsec_applyUpdateSubscription.part.0>:
 80013f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80013fc:	4606      	mov	r6, r0
 80013fe:	4d32      	ldr	r5, [pc, #200]	; (80014c8 <bsec_Bsec_applyUpdateSubscription.part.0+0xd0>)
 8001400:	4f32      	ldr	r7, [pc, #200]	; (80014cc <bsec_Bsec_applyUpdateSubscription.part.0+0xd4>)
 8001402:	f001 fcb9 	bl	8002d78 <bsec_ChannelHub_resetSamplIntvls>
 8001406:	2300      	movs	r3, #0
 8001408:	e003      	b.n	8001412 <bsec_Bsec_applyUpdateSubscription.part.0+0x1a>
 800140a:	1c5c      	adds	r4, r3, #1
 800140c:	2c1a      	cmp	r4, #26
 800140e:	4623      	mov	r3, r4
 8001410:	d010      	beq.n	8001434 <bsec_Bsec_applyUpdateSubscription.part.0+0x3c>
 8001412:	fa45 f203 	asr.w	r2, r5, r3
 8001416:	07d1      	lsls	r1, r2, #31
 8001418:	d5f7      	bpl.n	800140a <bsec_Bsec_applyUpdateSubscription.part.0+0x12>
 800141a:	5dda      	ldrb	r2, [r3, r7]
 800141c:	f202 621f 	addw	r2, r2, #1567	; 0x61f
 8001420:	1c5c      	adds	r4, r3, #1
 8001422:	f836 2012 	ldrh.w	r2, [r6, r2, lsl #1]
 8001426:	b2e1      	uxtb	r1, r4
 8001428:	4630      	mov	r0, r6
 800142a:	f001 fd75 	bl	8002f18 <bsec_ChannelHub_updateOutputSamplIntvl>
 800142e:	2c1a      	cmp	r4, #26
 8001430:	4623      	mov	r3, r4
 8001432:	d1ee      	bne.n	8001412 <bsec_Bsec_applyUpdateSubscription.part.0+0x1a>
 8001434:	4630      	mov	r0, r6
 8001436:	f001 fc23 	bl	8002c80 <bsec_ChannelHub_recalculateDownsampling>
 800143a:	f8df 908c 	ldr.w	r9, [pc, #140]	; 80014c8 <bsec_Bsec_applyUpdateSubscription.part.0+0xd0>
 800143e:	4f23      	ldr	r7, [pc, #140]	; (80014cc <bsec_Bsec_applyUpdateSubscription.part.0+0xd4>)
 8001440:	f8df 8090 	ldr.w	r8, [pc, #144]	; 80014d4 <bsec_Bsec_applyUpdateSubscription.part.0+0xdc>
 8001444:	2500      	movs	r5, #0
 8001446:	e002      	b.n	800144e <bsec_Bsec_applyUpdateSubscription.part.0+0x56>
 8001448:	3501      	adds	r5, #1
 800144a:	2d1a      	cmp	r5, #26
 800144c:	d01a      	beq.n	8001484 <bsec_Bsec_applyUpdateSubscription.part.0+0x8c>
 800144e:	fa49 f305 	asr.w	r3, r9, r5
 8001452:	07da      	lsls	r2, r3, #31
 8001454:	d5f8      	bpl.n	8001448 <bsec_Bsec_applyUpdateSubscription.part.0+0x50>
 8001456:	5deb      	ldrb	r3, [r5, r7]
 8001458:	4433      	add	r3, r6
 800145a:	f893 3c65 	ldrb.w	r3, [r3, #3173]	; 0xc65
 800145e:	2b00      	cmp	r3, #0
 8001460:	d0f2      	beq.n	8001448 <bsec_Bsec_applyUpdateSubscription.part.0+0x50>
 8001462:	f938 a015 	ldrsh.w	sl, [r8, r5, lsl #1]
 8001466:	2300      	movs	r3, #0
 8001468:	e002      	b.n	8001470 <bsec_Bsec_applyUpdateSubscription.part.0+0x78>
 800146a:	2c0b      	cmp	r4, #11
 800146c:	4623      	mov	r3, r4
 800146e:	d0eb      	beq.n	8001448 <bsec_Bsec_applyUpdateSubscription.part.0+0x50>
 8001470:	fa4a f203 	asr.w	r2, sl, r3
 8001474:	1c5c      	adds	r4, r3, #1
 8001476:	07d3      	lsls	r3, r2, #31
 8001478:	d5f7      	bpl.n	800146a <bsec_Bsec_applyUpdateSubscription.part.0+0x72>
 800147a:	b2e1      	uxtb	r1, r4
 800147c:	4630      	mov	r0, r6
 800147e:	f001 fd13 	bl	8002ea8 <bsec_ChannelHub_updateChannelInterfaceDependency>
 8001482:	e7f2      	b.n	800146a <bsec_Bsec_applyUpdateSubscription.part.0+0x72>
 8001484:	2400      	movs	r4, #0
 8001486:	4621      	mov	r1, r4
 8001488:	f886 4c81 	strb.w	r4, [r6, #3201]	; 0xc81
 800148c:	2213      	movs	r2, #19
 800148e:	f606 4066 	addw	r0, r6, #3174	; 0xc66
 8001492:	f02a fe33 	bl	802c0fc <memset>
 8001496:	4b0e      	ldr	r3, [pc, #56]	; (80014d0 <bsec_Bsec_applyUpdateSubscription.part.0+0xd8>)
 8001498:	f886 4c7d 	strb.w	r4, [r6, #3197]	; 0xc7d
 800149c:	78db      	ldrb	r3, [r3, #3]
 800149e:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80014a2:	4621      	mov	r1, r4
 80014a4:	f8b3 0a68 	ldrh.w	r0, [r3, #2664]	; 0xa68
 80014a8:	f606 4328 	addw	r3, r6, #3112	; 0xc28
 80014ac:	f833 2b02 	ldrh.w	r2, [r3], #2
 80014b0:	4290      	cmp	r0, r2
 80014b2:	f101 0101 	add.w	r1, r1, #1
 80014b6:	d003      	beq.n	80014c0 <bsec_Bsec_applyUpdateSubscription.part.0+0xc8>
 80014b8:	2904      	cmp	r1, #4
 80014ba:	d1f7      	bne.n	80014ac <bsec_Bsec_applyUpdateSubscription.part.0+0xb4>
 80014bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80014c0:	f886 1c7d 	strb.w	r1, [r6, #3197]	; 0xc7d
 80014c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80014c8:	03f279ef 	.word	0x03f279ef
 80014cc:	0802d6bc 	.word	0x0802d6bc
 80014d0:	0802d6d8 	.word	0x0802d6d8
 80014d4:	0802d620 	.word	0x0802d620

080014d8 <bsec_Bsec_append>:
 80014d8:	b4f0      	push	{r4, r5, r6, r7}
 80014da:	6814      	ldr	r4, [r2, #0]
 80014dc:	9e04      	ldr	r6, [sp, #16]
 80014de:	18e7      	adds	r7, r4, r3
 80014e0:	428f      	cmp	r7, r1
 80014e2:	d815      	bhi.n	8001510 <bsec_Bsec_append+0x38>
 80014e4:	9905      	ldr	r1, [sp, #20]
 80014e6:	428b      	cmp	r3, r1
 80014e8:	d815      	bhi.n	8001516 <bsec_Bsec_append+0x3e>
 80014ea:	2b00      	cmp	r3, #0
 80014ec:	dd0c      	ble.n	8001508 <bsec_Bsec_append+0x30>
 80014ee:	1e71      	subs	r1, r6, #1
 80014f0:	18cd      	adds	r5, r1, r3
 80014f2:	f1c6 0601 	rsb	r6, r6, #1
 80014f6:	e000      	b.n	80014fa <bsec_Bsec_append+0x22>
 80014f8:	6814      	ldr	r4, [r2, #0]
 80014fa:	1873      	adds	r3, r6, r1
 80014fc:	4423      	add	r3, r4
 80014fe:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8001502:	54c4      	strb	r4, [r0, r3]
 8001504:	42a9      	cmp	r1, r5
 8001506:	d1f7      	bne.n	80014f8 <bsec_Bsec_append+0x20>
 8001508:	6017      	str	r7, [r2, #0]
 800150a:	2000      	movs	r0, #0
 800150c:	bcf0      	pop	{r4, r5, r6, r7}
 800150e:	4770      	bx	lr
 8001510:	f06f 0028 	mvn.w	r0, #40	; 0x28
 8001514:	e7fa      	b.n	800150c <bsec_Bsec_append+0x34>
 8001516:	f06f 0025 	mvn.w	r0, #37	; 0x25
 800151a:	e7f7      	b.n	800150c <bsec_Bsec_append+0x34>

0800151c <bsec_Bsec_applyUpdateSubscription>:
 800151c:	f890 3c81 	ldrb.w	r3, [r0, #3201]	; 0xc81
 8001520:	b903      	cbnz	r3, 8001524 <bsec_Bsec_applyUpdateSubscription+0x8>
 8001522:	4770      	bx	lr
 8001524:	e768      	b.n	80013f8 <bsec_Bsec_applyUpdateSubscription.part.0>
 8001526:	bf00      	nop

08001528 <bsec_Bsec_checkIfSensorRequired>:
 8001528:	b470      	push	{r4, r5, r6}
 800152a:	3901      	subs	r1, #1
 800152c:	4d14      	ldr	r5, [pc, #80]	; (8001580 <bsec_Bsec_checkIfSensorRequired+0x58>)
 800152e:	9c03      	ldr	r4, [sp, #12]
 8001530:	5c6d      	ldrb	r5, [r5, r1]
 8001532:	eb00 0545 	add.w	r5, r0, r5, lsl #1
 8001536:	2600      	movs	r6, #0
 8001538:	f8b5 5a68 	ldrh.w	r5, [r5, #2664]	; 0xa68
 800153c:	701e      	strb	r6, [r3, #0]
 800153e:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8001542:	42b5      	cmp	r5, r6
 8001544:	8025      	strh	r5, [r4, #0]
 8001546:	d013      	beq.n	8001570 <bsec_Bsec_checkIfSensorRequired+0x48>
 8001548:	f8b0 6c7a 	ldrh.w	r6, [r0, #3194]	; 0xc7a
 800154c:	fbb6 f4f5 	udiv	r4, r6, r5
 8001550:	fb05 6514 	mls	r5, r5, r4, r6
 8001554:	b2ad      	uxth	r5, r5
 8001556:	b96d      	cbnz	r5, 8001574 <bsec_Bsec_checkIfSensorRequired+0x4c>
 8001558:	2001      	movs	r0, #1
 800155a:	6894      	ldr	r4, [r2, #8]
 800155c:	7018      	strb	r0, [r3, #0]
 800155e:	b2c9      	uxtb	r1, r1
 8001560:	fa00 f101 	lsl.w	r1, r0, r1
 8001564:	4321      	orrs	r1, r4
 8001566:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
 800156a:	f882 003e 	strb.w	r0, [r2, #62]	; 0x3e
 800156e:	6091      	str	r1, [r2, #8]
 8001570:	bc70      	pop	{r4, r5, r6}
 8001572:	4770      	bx	lr
 8001574:	f890 0c82 	ldrb.w	r0, [r0, #3202]	; 0xc82
 8001578:	2800      	cmp	r0, #0
 800157a:	d0f9      	beq.n	8001570 <bsec_Bsec_checkIfSensorRequired+0x48>
 800157c:	e7ec      	b.n	8001558 <bsec_Bsec_checkIfSensorRequired+0x30>
 800157e:	bf00      	nop
 8001580:	0802d6d8 	.word	0x0802d6d8

08001584 <bsec_Bsec_checkSamplIntvlCompatibility>:
 8001584:	2300      	movs	r3, #0
 8001586:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001588:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 8001650 <bsec_Bsec_checkSamplIntvlCompatibility+0xcc>
 800158c:	4d2f      	ldr	r5, [pc, #188]	; (800164c <bsec_Bsec_checkSamplIntvlCompatibility+0xc8>)
 800158e:	461c      	mov	r4, r3
 8001590:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
 8001594:	f04f 0e01 	mov.w	lr, #1
 8001598:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800159c:	e005      	b.n	80015aa <bsec_Bsec_checkSamplIntvlCompatibility+0x26>
 800159e:	42b2      	cmp	r2, r6
 80015a0:	bf18      	it	ne
 80015a2:	2401      	movne	r4, #1
 80015a4:	3301      	adds	r3, #1
 80015a6:	2b1a      	cmp	r3, #26
 80015a8:	d010      	beq.n	80015cc <bsec_Bsec_checkSamplIntvlCompatibility+0x48>
 80015aa:	fa45 f203 	asr.w	r2, r5, r3
 80015ae:	07d2      	lsls	r2, r2, #31
 80015b0:	d5f8      	bpl.n	80015a4 <bsec_Bsec_checkSamplIntvlCompatibility+0x20>
 80015b2:	f813 200c 	ldrb.w	r2, [r3, ip]
 80015b6:	443a      	add	r2, r7
 80015b8:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 80015bc:	f5b2 6fe1 	cmp.w	r2, #1800	; 0x708
 80015c0:	d1ed      	bne.n	800159e <bsec_Bsec_checkSamplIntvlCompatibility+0x1a>
 80015c2:	3301      	adds	r3, #1
 80015c4:	2b1a      	cmp	r3, #26
 80015c6:	f880 ecb3 	strb.w	lr, [r0, #3251]	; 0xcb3
 80015ca:	d1ee      	bne.n	80015aa <bsec_Bsec_checkSamplIntvlCompatibility+0x26>
 80015cc:	f890 3cb3 	ldrb.w	r3, [r0, #3251]	; 0xcb3
 80015d0:	bb8b      	cbnz	r3, 8001636 <bsec_Bsec_checkSamplIntvlCompatibility+0xb2>
 80015d2:	f8b0 7c24 	ldrh.w	r7, [r0, #3108]	; 0xc24
 80015d6:	4c1d      	ldr	r4, [pc, #116]	; (800164c <bsec_Bsec_checkSamplIntvlCompatibility+0xc8>)
 80015d8:	4d1d      	ldr	r5, [pc, #116]	; (8001650 <bsec_Bsec_checkSamplIntvlCompatibility+0xcc>)
 80015da:	4638      	mov	r0, r7
 80015dc:	fa44 f203 	asr.w	r2, r4, r3
 80015e0:	07d6      	lsls	r6, r2, #31
 80015e2:	d506      	bpl.n	80015f2 <bsec_Bsec_checkSamplIntvlCompatibility+0x6e>
 80015e4:	5d5a      	ldrb	r2, [r3, r5]
 80015e6:	3a01      	subs	r2, #1
 80015e8:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 80015ec:	4290      	cmp	r0, r2
 80015ee:	bf28      	it	cs
 80015f0:	4610      	movcs	r0, r2
 80015f2:	3301      	adds	r3, #1
 80015f4:	2b1a      	cmp	r3, #26
 80015f6:	d1f1      	bne.n	80015dc <bsec_Bsec_checkSamplIntvlCompatibility+0x58>
 80015f8:	f64f 76ff 	movw	r6, #65535	; 0xffff
 80015fc:	42b0      	cmp	r0, r6
 80015fe:	d023      	beq.n	8001648 <bsec_Bsec_checkSamplIntvlCompatibility+0xc4>
 8001600:	fbb7 f3f0 	udiv	r3, r7, r0
 8001604:	fb00 7313 	mls	r3, r0, r3, r7
 8001608:	b29b      	uxth	r3, r3
 800160a:	b98b      	cbnz	r3, 8001630 <bsec_Bsec_checkSamplIntvlCompatibility+0xac>
 800160c:	4d0f      	ldr	r5, [pc, #60]	; (800164c <bsec_Bsec_checkSamplIntvlCompatibility+0xc8>)
 800160e:	4f10      	ldr	r7, [pc, #64]	; (8001650 <bsec_Bsec_checkSamplIntvlCompatibility+0xcc>)
 8001610:	fa45 f203 	asr.w	r2, r5, r3
 8001614:	07d2      	lsls	r2, r2, #31
 8001616:	d514      	bpl.n	8001642 <bsec_Bsec_checkSamplIntvlCompatibility+0xbe>
 8001618:	5dda      	ldrb	r2, [r3, r7]
 800161a:	3a01      	subs	r2, #1
 800161c:	f831 4012 	ldrh.w	r4, [r1, r2, lsl #1]
 8001620:	42b4      	cmp	r4, r6
 8001622:	d00e      	beq.n	8001642 <bsec_Bsec_checkSamplIntvlCompatibility+0xbe>
 8001624:	fbb4 f2f0 	udiv	r2, r4, r0
 8001628:	fb00 4212 	mls	r2, r0, r2, r4
 800162c:	b292      	uxth	r2, r2
 800162e:	b142      	cbz	r2, 8001642 <bsec_Bsec_checkSamplIntvlCompatibility+0xbe>
 8001630:	f06f 000f 	mvn.w	r0, #15
 8001634:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001636:	2c00      	cmp	r4, #0
 8001638:	bf0c      	ite	eq
 800163a:	2000      	moveq	r0, #0
 800163c:	f06f 000f 	mvnne.w	r0, #15
 8001640:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001642:	3301      	adds	r3, #1
 8001644:	2b1a      	cmp	r3, #26
 8001646:	d1e3      	bne.n	8001610 <bsec_Bsec_checkSamplIntvlCompatibility+0x8c>
 8001648:	2000      	movs	r0, #0
 800164a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800164c:	03f279ef 	.word	0x03f279ef
 8001650:	0802d6bc 	.word	0x0802d6bc

08001654 <bsec_Bsec_frameSerializedData>:
 8001654:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001656:	b089      	sub	sp, #36	; 0x24
 8001658:	4604      	mov	r4, r0
 800165a:	460d      	mov	r5, r1
 800165c:	4b28      	ldr	r3, [pc, #160]	; (8001700 <bsec_Bsec_frameSerializedData+0xac>)
 800165e:	9302      	str	r3, [sp, #8]
 8001660:	a902      	add	r1, sp, #8
 8001662:	a803      	add	r0, sp, #12
 8001664:	2204      	movs	r2, #4
 8001666:	f02a fd3b 	bl	802c0e0 <memcpy>
 800166a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800166e:	f89d 000c 	ldrb.w	r0, [sp, #12]
 8001672:	f89d 100d 	ldrb.w	r1, [sp, #13]
 8001676:	f89d 200e 	ldrb.w	r2, [sp, #14]
 800167a:	70e3      	strb	r3, [r4, #3]
 800167c:	7020      	strb	r0, [r4, #0]
 800167e:	7061      	strb	r1, [r4, #1]
 8001680:	70a2      	strb	r2, [r4, #2]
 8001682:	a904      	add	r1, sp, #16
 8001684:	a806      	add	r0, sp, #24
 8001686:	f240 16bd 	movw	r6, #445	; 0x1bd
 800168a:	2700      	movs	r7, #0
 800168c:	2208      	movs	r2, #8
 800168e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001692:	f02a fd25 	bl	802c0e0 <memcpy>
 8001696:	a906      	add	r1, sp, #24
 8001698:	1d20      	adds	r0, r4, #4
 800169a:	2208      	movs	r2, #8
 800169c:	f02a fd20 	bl	802c0e0 <memcpy>
 80016a0:	682b      	ldr	r3, [r5, #0]
 80016a2:	a902      	add	r1, sp, #8
 80016a4:	3b10      	subs	r3, #16
 80016a6:	a803      	add	r0, sp, #12
 80016a8:	2204      	movs	r2, #4
 80016aa:	9302      	str	r3, [sp, #8]
 80016ac:	f02a fd18 	bl	802c0e0 <memcpy>
 80016b0:	f89d 000c 	ldrb.w	r0, [sp, #12]
 80016b4:	f89d 100d 	ldrb.w	r1, [sp, #13]
 80016b8:	f89d 200e 	ldrb.w	r2, [sp, #14]
 80016bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80016c0:	7320      	strb	r0, [r4, #12]
 80016c2:	73a2      	strb	r2, [r4, #14]
 80016c4:	73e3      	strb	r3, [r4, #15]
 80016c6:	7361      	strb	r1, [r4, #13]
 80016c8:	6829      	ldr	r1, [r5, #0]
 80016ca:	4620      	mov	r0, r4
 80016cc:	aa01      	add	r2, sp, #4
 80016ce:	f005 fabd 	bl	8006c4c <bsec_crcCcitt2>
 80016d2:	682b      	ldr	r3, [r5, #0]
 80016d4:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80016d8:	f89d 1005 	ldrb.w	r1, [sp, #5]
 80016dc:	4423      	add	r3, r4
 80016de:	2200      	movs	r2, #0
 80016e0:	7118      	strb	r0, [r3, #4]
 80016e2:	682b      	ldr	r3, [r5, #0]
 80016e4:	4423      	add	r3, r4
 80016e6:	7159      	strb	r1, [r3, #5]
 80016e8:	682b      	ldr	r3, [r5, #0]
 80016ea:	4423      	add	r3, r4
 80016ec:	719a      	strb	r2, [r3, #6]
 80016ee:	6828      	ldr	r0, [r5, #0]
 80016f0:	4404      	add	r4, r0
 80016f2:	71e2      	strb	r2, [r4, #7]
 80016f4:	682b      	ldr	r3, [r5, #0]
 80016f6:	3308      	adds	r3, #8
 80016f8:	602b      	str	r3, [r5, #0]
 80016fa:	b009      	add	sp, #36	; 0x24
 80016fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80016fe:	bf00      	nop
 8001700:	02020000 	.word	0x02020000

08001704 <bsec_Bsec_getHyperConfiguration>:
 8001704:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001708:	b084      	sub	sp, #16
 800170a:	4606      	mov	r6, r0
 800170c:	4617      	mov	r7, r2
 800170e:	240c      	movs	r4, #12
 8001710:	f10d 0207 	add.w	r2, sp, #7
 8001714:	20fe      	movs	r0, #254	; 0xfe
 8001716:	460d      	mov	r5, r1
 8001718:	f88d 4007 	strb.w	r4, [sp, #7]
 800171c:	f005 f9e6 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8001720:	f89d 8007 	ldrb.w	r8, [sp, #7]
 8001724:	9003      	str	r0, [sp, #12]
 8001726:	f1b8 0f00 	cmp.w	r8, #0
 800172a:	d028      	beq.n	800177e <bsec_Bsec_getHyperConfiguration+0x7a>
 800172c:	2401      	movs	r4, #1
 800172e:	f606 4a9e 	addw	sl, r6, #3230	; 0xc9e
 8001732:	f606 498a 	addw	r9, r6, #3210	; 0xc8a
 8001736:	b2e3      	uxtb	r3, r4
 8001738:	3b01      	subs	r3, #1
 800173a:	2b0b      	cmp	r3, #11
 800173c:	d80e      	bhi.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 800173e:	e8df f003 	tbb	[pc, r3]
 8001742:	5f67      	.short	0x5f67
 8001744:	4f576f77 	.word	0x4f576f77
 8001748:	30373f47 	.word	0x30373f47
 800174c:	0613      	.short	0x0613
 800174e:	f896 0cb2 	ldrb.w	r0, [r6, #3250]	; 0xcb2
 8001752:	ab03      	add	r3, sp, #12
 8001754:	463a      	mov	r2, r7
 8001756:	4629      	mov	r1, r5
 8001758:	f001 fe20 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800175c:	45a0      	cmp	r8, r4
 800175e:	f104 0301 	add.w	r3, r4, #1
 8001762:	d00b      	beq.n	800177c <bsec_Bsec_getHyperConfiguration+0x78>
 8001764:	461c      	mov	r4, r3
 8001766:	e7e6      	b.n	8001736 <bsec_Bsec_getHyperConfiguration+0x32>
 8001768:	ab03      	add	r3, sp, #12
 800176a:	463a      	mov	r2, r7
 800176c:	4629      	mov	r1, r5
 800176e:	4650      	mov	r0, sl
 8001770:	f001 fd12 	bl	8003198 <bsec_bb_Entity_serializeAndAdd>
 8001774:	45a0      	cmp	r8, r4
 8001776:	f104 0301 	add.w	r3, r4, #1
 800177a:	d1f3      	bne.n	8001764 <bsec_Bsec_getHyperConfiguration+0x60>
 800177c:	9803      	ldr	r0, [sp, #12]
 800177e:	f8ad 000a 	strh.w	r0, [sp, #10]
 8001782:	2202      	movs	r2, #2
 8001784:	f10d 010a 	add.w	r1, sp, #10
 8001788:	a802      	add	r0, sp, #8
 800178a:	f02a fca9 	bl	802c0e0 <memcpy>
 800178e:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8001792:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8001796:	9803      	ldr	r0, [sp, #12]
 8001798:	702a      	strb	r2, [r5, #0]
 800179a:	706b      	strb	r3, [r5, #1]
 800179c:	b004      	add	sp, #16
 800179e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80017a2:	ab03      	add	r3, sp, #12
 80017a4:	463a      	mov	r2, r7
 80017a6:	4629      	mov	r1, r5
 80017a8:	4648      	mov	r0, r9
 80017aa:	f001 fcf5 	bl	8003198 <bsec_bb_Entity_serializeAndAdd>
 80017ae:	e7d5      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 80017b0:	ab03      	add	r3, sp, #12
 80017b2:	463a      	mov	r2, r7
 80017b4:	4629      	mov	r1, r5
 80017b6:	f606 4086 	addw	r0, r6, #3206	; 0xc86
 80017ba:	f001 fd69 	bl	8003290 <bsec_d_Entity_serializeAndAdd>
 80017be:	e7cd      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 80017c0:	f896 0c84 	ldrb.w	r0, [r6, #3204]	; 0xc84
 80017c4:	ab03      	add	r3, sp, #12
 80017c6:	463a      	mov	r2, r7
 80017c8:	4629      	mov	r1, r5
 80017ca:	f001 fde7 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 80017ce:	e7c5      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 80017d0:	f8b6 0c24 	ldrh.w	r0, [r6, #3108]	; 0xc24
 80017d4:	ab03      	add	r3, sp, #12
 80017d6:	463a      	mov	r2, r7
 80017d8:	4629      	mov	r1, r5
 80017da:	f001 fd21 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 80017de:	e7bd      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 80017e0:	ab03      	add	r3, sp, #12
 80017e2:	463a      	mov	r2, r7
 80017e4:	4629      	mov	r1, r5
 80017e6:	f606 30fc 	addw	r0, r6, #3068	; 0xbfc
 80017ea:	f001 fc6d 	bl	80030c8 <bsec_ab_Entity_serializeAndAdd>
 80017ee:	e7b5      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 80017f0:	ab03      	add	r3, sp, #12
 80017f2:	463a      	mov	r2, r7
 80017f4:	4629      	mov	r1, r5
 80017f6:	f606 3018 	addw	r0, r6, #2840	; 0xb18
 80017fa:	f002 fa71 	bl	8003ce0 <bsec_y_Entity_serializeAndAdd>
 80017fe:	e7ad      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 8001800:	f896 0c7f 	ldrb.w	r0, [r6, #3199]	; 0xc7f
 8001804:	ab03      	add	r3, sp, #12
 8001806:	463a      	mov	r2, r7
 8001808:	4629      	mov	r1, r5
 800180a:	f001 fdc7 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800180e:	e7a5      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 8001810:	f896 0c7e 	ldrb.w	r0, [r6, #3198]	; 0xc7e
 8001814:	ab03      	add	r3, sp, #12
 8001816:	463a      	mov	r2, r7
 8001818:	4629      	mov	r1, r5
 800181a:	f001 fdbf 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800181e:	e79d      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 8001820:	ab03      	add	r3, sp, #12
 8001822:	463a      	mov	r2, r7
 8001824:	4629      	mov	r1, r5
 8001826:	f606 4028 	addw	r0, r6, #3112	; 0xc28
 800182a:	f002 fa2d 	bl	8003c88 <bsec_x_Entity_serializeAndAdd>
 800182e:	e795      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>
 8001830:	f896 0c80 	ldrb.w	r0, [r6, #3200]	; 0xc80
 8001834:	ab03      	add	r3, sp, #12
 8001836:	463a      	mov	r2, r7
 8001838:	4629      	mov	r1, r5
 800183a:	f001 fdaf 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800183e:	e78d      	b.n	800175c <bsec_Bsec_getHyperConfiguration+0x58>

08001840 <bsec_Bsec_getInputSample>:
 8001840:	b4f0      	push	{r4, r5, r6, r7}
 8001842:	2600      	movs	r6, #0
 8001844:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8001848:	2500      	movs	r5, #0
 800184a:	6016      	str	r6, [r2, #0]
 800184c:	e9c3 4500 	strd	r4, r5, [r3]
 8001850:	b169      	cbz	r1, 800186e <bsec_Bsec_getInputSample+0x2e>
 8001852:	eb00 1401 	add.w	r4, r0, r1, lsl #4
 8001856:	7b41      	ldrb	r1, [r0, #13]
 8001858:	2918      	cmp	r1, #24
 800185a:	d105      	bne.n	8001868 <bsec_Bsec_getInputSample+0x28>
 800185c:	e9d0 6700 	ldrd	r6, r7, [r0]
 8001860:	6881      	ldr	r1, [r0, #8]
 8001862:	6011      	str	r1, [r2, #0]
 8001864:	e9c3 6700 	strd	r6, r7, [r3]
 8001868:	3010      	adds	r0, #16
 800186a:	42a0      	cmp	r0, r4
 800186c:	d1f3      	bne.n	8001856 <bsec_Bsec_getInputSample+0x16>
 800186e:	bcf0      	pop	{r4, r5, r6, r7}
 8001870:	4770      	bx	lr
 8001872:	bf00      	nop

08001874 <bsec_Bsec_isGasIndexNew>:
 8001874:	b500      	push	{lr}
 8001876:	ed2d 8b02 	vpush	{d8}
 800187a:	b085      	sub	sp, #20
 800187c:	f10d 0303 	add.w	r3, sp, #3
 8001880:	aa02      	add	r2, sp, #8
 8001882:	a901      	add	r1, sp, #4
 8001884:	eeb0 8a40 	vmov.f32	s16, s0
 8001888:	f001 f9c2 	bl	8002c10 <bsec_ChannelHub_getInput>
 800188c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001890:	b16b      	cbz	r3, 80018ae <bsec_Bsec_isGasIndexNew+0x3a>
 8001892:	eddd 7a01 	vldr	s15, [sp, #4]
 8001896:	eef4 7a48 	vcmp.f32	s15, s16
 800189a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800189e:	bf14      	ite	ne
 80018a0:	2001      	movne	r0, #1
 80018a2:	2000      	moveq	r0, #0
 80018a4:	b005      	add	sp, #20
 80018a6:	ecbd 8b02 	vpop	{d8}
 80018aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80018ae:	2001      	movs	r0, #1
 80018b0:	b005      	add	sp, #20
 80018b2:	ecbd 8b02 	vpop	{d8}
 80018b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80018ba:	bf00      	nop

080018bc <bsec_Bsec_parse>:
 80018bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80018c0:	b083      	sub	sp, #12
 80018c2:	e9dd a90c 	ldrd	sl, r9, [sp, #48]	; 0x30
 80018c6:	2400      	movs	r4, #0
 80018c8:	f88a 4000 	strb.w	r4, [sl]
 80018cc:	f889 4000 	strb.w	r4, [r9]
 80018d0:	460d      	mov	r5, r1
 80018d2:	6809      	ldr	r1, [r1, #0]
 80018d4:	4606      	mov	r6, r0
 80018d6:	4408      	add	r0, r1
 80018d8:	4690      	mov	r8, r2
 80018da:	7842      	ldrb	r2, [r0, #1]
 80018dc:	f816 c001 	ldrb.w	ip, [r6, r1]
 80018e0:	f88d 2005 	strb.w	r2, [sp, #5]
 80018e4:	a901      	add	r1, sp, #4
 80018e6:	2202      	movs	r2, #2
 80018e8:	f10d 0006 	add.w	r0, sp, #6
 80018ec:	469b      	mov	fp, r3
 80018ee:	f88d c004 	strb.w	ip, [sp, #4]
 80018f2:	f02a fbf5 	bl	802c0e0 <memcpy>
 80018f6:	f8bd 7006 	ldrh.w	r7, [sp, #6]
 80018fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80018fc:	455f      	cmp	r7, fp
 80018fe:	601f      	str	r7, [r3, #0]
 8001900:	d905      	bls.n	800190e <bsec_Bsec_parse+0x52>
 8001902:	23e0      	movs	r3, #224	; 0xe0
 8001904:	f88a 3000 	strb.w	r3, [sl]
 8001908:	b003      	add	sp, #12
 800190a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800190e:	b157      	cbz	r7, 8001926 <bsec_Bsec_parse+0x6a>
 8001910:	4623      	mov	r3, r4
 8001912:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 8001916:	682a      	ldr	r2, [r5, #0]
 8001918:	18f0      	adds	r0, r6, r3
 800191a:	3301      	adds	r3, #1
 800191c:	5c82      	ldrb	r2, [r0, r2]
 800191e:	f801 2f01 	strb.w	r2, [r1, #1]!
 8001922:	429f      	cmp	r7, r3
 8001924:	d1f7      	bne.n	8001916 <bsec_Bsec_parse+0x5a>
 8001926:	f898 3002 	ldrb.w	r3, [r8, #2]
 800192a:	f889 3000 	strb.w	r3, [r9]
 800192e:	682b      	ldr	r3, [r5, #0]
 8001930:	443b      	add	r3, r7
 8001932:	602b      	str	r3, [r5, #0]
 8001934:	b003      	add	sp, #12
 8001936:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800193a:	bf00      	nop

0800193c <bsec_Bsec_requestOutput>:
 800193c:	4b0b      	ldr	r3, [pc, #44]	; (800196c <bsec_Bsec_requestOutput+0x30>)
 800193e:	4419      	add	r1, r3
 8001940:	b410      	push	{r4}
 8001942:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 8001946:	eb00 0143 	add.w	r1, r0, r3, lsl #1
 800194a:	f8b1 4c3e 	ldrh.w	r4, [r1, #3134]	; 0xc3e
 800194e:	4294      	cmp	r4, r2
 8001950:	d004      	beq.n	800195c <bsec_Bsec_requestOutput+0x20>
 8001952:	3b01      	subs	r3, #1
 8001954:	4403      	add	r3, r0
 8001956:	2401      	movs	r4, #1
 8001958:	f883 4c66 	strb.w	r4, [r3, #3174]	; 0xc66
 800195c:	2301      	movs	r3, #1
 800195e:	f8a1 2c3e 	strh.w	r2, [r1, #3134]	; 0xc3e
 8001962:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001966:	f880 3c81 	strb.w	r3, [r0, #3201]	; 0xc81
 800196a:	4770      	bx	lr
 800196c:	0802d6bc 	.word	0x0802d6bc

08001970 <bsec_Bsec_resetOutput>:
 8001970:	3901      	subs	r1, #1
 8001972:	2903      	cmp	r1, #3
 8001974:	d900      	bls.n	8001978 <bsec_Bsec_resetOutput+0x8>
 8001976:	4770      	bx	lr
 8001978:	b510      	push	{r4, lr}
 800197a:	4604      	mov	r4, r0
 800197c:	3068      	adds	r0, #104	; 0x68
 800197e:	f003 fe4f 	bl	8005620 <bsec_GasHumidityBaselineTracker_setState>
 8001982:	4620      	mov	r0, r4
 8001984:	2101      	movs	r1, #1
 8001986:	f001 fb27 	bl	8002fd8 <bsec_b_ChannelHub_updateChannelInterfaceDependency>
 800198a:	4b04      	ldr	r3, [pc, #16]	; (800199c <bsec_Bsec_resetOutput+0x2c>)
 800198c:	6623      	str	r3, [r4, #96]	; 0x60
 800198e:	4620      	mov	r0, r4
 8001990:	6663      	str	r3, [r4, #100]	; 0x64
 8001992:	2102      	movs	r1, #2
 8001994:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001998:	f001 bb1e 	b.w	8002fd8 <bsec_b_ChannelHub_updateChannelInterfaceDependency>
 800199c:	42480000 	.word	0x42480000

080019a0 <bsec_Bsec_setHyperConfiguration>:
 80019a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80019a4:	2305      	movs	r3, #5
 80019a6:	4605      	mov	r5, r0
 80019a8:	f44f 7281 	mov.w	r2, #258	; 0x102
 80019ac:	f8a0 2c7e 	strh.w	r2, [r0, #3198]	; 0xc7e
 80019b0:	f880 3c80 	strb.w	r3, [r0, #3200]	; 0xc80
 80019b4:	2218      	movs	r2, #24
 80019b6:	4999      	ldr	r1, [pc, #612]	; (8001c1c <bsec_Bsec_setHyperConfiguration+0x27c>)
 80019b8:	f600 4028 	addw	r0, r0, #3112	; 0xc28
 80019bc:	f605 3416 	addw	r4, r5, #2838	; 0xb16
 80019c0:	f02a fb8e 	bl	802c0e0 <memcpy>
 80019c4:	f605 36fa 	addw	r6, r5, #3066	; 0xbfa
 80019c8:	4623      	mov	r3, r4
 80019ca:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80019ce:	f823 2f02 	strh.w	r2, [r3, #2]!
 80019d2:	42b3      	cmp	r3, r6
 80019d4:	d1fb      	bne.n	80019ce <bsec_Bsec_setHyperConfiguration+0x2e>
 80019d6:	4892      	ldr	r0, [pc, #584]	; (8001c20 <bsec_Bsec_setHyperConfiguration+0x280>)
 80019d8:	f8df 926c 	ldr.w	r9, [pc, #620]	; 8001c48 <bsec_Bsec_setHyperConfiguration+0x2a8>
 80019dc:	f8df c26c 	ldr.w	ip, [pc, #620]	; 8001c4c <bsec_Bsec_setHyperConfiguration+0x2ac>
 80019e0:	4b90      	ldr	r3, [pc, #576]	; (8001c24 <bsec_Bsec_setHyperConfiguration+0x284>)
 80019e2:	4a91      	ldr	r2, [pc, #580]	; (8001c28 <bsec_Bsec_setHyperConfiguration+0x288>)
 80019e4:	4991      	ldr	r1, [pc, #580]	; (8001c2c <bsec_Bsec_setHyperConfiguration+0x28c>)
 80019e6:	f8df a268 	ldr.w	sl, [pc, #616]	; 8001c50 <bsec_Bsec_setHyperConfiguration+0x2b0>
 80019ea:	f8c5 cbe0 	str.w	ip, [r5, #3040]	; 0xbe0
 80019ee:	f44f 67e1 	mov.w	r7, #1800	; 0x708
 80019f2:	f04f 1c64 	mov.w	ip, #6553700	; 0x640064
 80019f6:	f240 5edc 	movw	lr, #1500	; 0x5dc
 80019fa:	f04f 0864 	mov.w	r8, #100	; 0x64
 80019fe:	f8c5 0b18 	str.w	r0, [r5, #2840]	; 0xb18
 8001a02:	f8c5 0b1c 	str.w	r0, [r5, #2844]	; 0xb1c
 8001a06:	f8c5 0b28 	str.w	r0, [r5, #2856]	; 0xb28
 8001a0a:	f8c5 0b48 	str.w	r0, [r5, #2888]	; 0xb48
 8001a0e:	f8c5 0b30 	str.w	r0, [r5, #2864]	; 0xb30
 8001a12:	f8c5 9b24 	str.w	r9, [r5, #2852]	; 0xb24
 8001a16:	f247 5030 	movw	r0, #30000	; 0x7530
 8001a1a:	f8c5 9b44 	str.w	r9, [r5, #2884]	; 0xb44
 8001a1e:	f605 29d8 	addw	r9, r5, #2776	; 0xad8
 8001a22:	f8a5 ebde 	strh.w	lr, [r5, #3038]	; 0xbde
 8001a26:	f8c5 cb20 	str.w	ip, [r5, #2848]	; 0xb20
 8001a2a:	f8c5 cb40 	str.w	ip, [r5, #2880]	; 0xb40
 8001a2e:	f8c5 cb4c 	str.w	ip, [r5, #2892]	; 0xb4c
 8001a32:	f8c5 3bb0 	str.w	r3, [r5, #2992]	; 0xbb0
 8001a36:	f8c5 3bb4 	str.w	r3, [r5, #2996]	; 0xbb4
 8001a3a:	f8c5 3bb8 	str.w	r3, [r5, #3000]	; 0xbb8
 8001a3e:	f8c5 3bbc 	str.w	r3, [r5, #3004]	; 0xbbc
 8001a42:	f8c5 3bc0 	str.w	r3, [r5, #3008]	; 0xbc0
 8001a46:	f8a5 8b58 	strh.w	r8, [r5, #2904]	; 0xb58
 8001a4a:	f8a5 8b50 	strh.w	r8, [r5, #2896]	; 0xb50
 8001a4e:	f8a5 7ba4 	strh.w	r7, [r5, #2980]	; 0xba4
 8001a52:	f8a5 7b8a 	strh.w	r7, [r5, #2954]	; 0xb8a
 8001a56:	f8a5 7b9c 	strh.w	r7, [r5, #2972]	; 0xb9c
 8001a5a:	f8c5 2b64 	str.w	r2, [r5, #2916]	; 0xb64
 8001a5e:	f8c5 2b68 	str.w	r2, [r5, #2920]	; 0xb68
 8001a62:	f8c5 2b6c 	str.w	r2, [r5, #2924]	; 0xb6c
 8001a66:	f8c5 2b70 	str.w	r2, [r5, #2928]	; 0xb70
 8001a6a:	f8c5 2b74 	str.w	r2, [r5, #2932]	; 0xb74
 8001a6e:	f8c5 1b8c 	str.w	r1, [r5, #2956]	; 0xb8c
 8001a72:	f8c5 1b90 	str.w	r1, [r5, #2960]	; 0xb90
 8001a76:	f8c5 1b94 	str.w	r1, [r5, #2964]	; 0xb94
 8001a7a:	f8c5 1b98 	str.w	r1, [r5, #2968]	; 0xb98
 8001a7e:	f8c5 ab3c 	str.w	sl, [r5, #2876]	; 0xb3c
 8001a82:	f8a5 8b56 	strh.w	r8, [r5, #2902]	; 0xb56
 8001a86:	f8c5 2b7c 	str.w	r2, [r5, #2940]	; 0xb7c
 8001a8a:	f8a5 7ba2 	strh.w	r7, [r5, #2978]	; 0xba2
 8001a8e:	f8a5 7b9e 	strh.w	r7, [r5, #2974]	; 0xb9e
 8001a92:	f8a5 ebea 	strh.w	lr, [r5, #3050]	; 0xbea
 8001a96:	f8c5 cb2c 	str.w	ip, [r5, #2860]	; 0xb2c
 8001a9a:	f8c5 2b78 	str.w	r2, [r5, #2936]	; 0xb78
 8001a9e:	f8a5 7ba0 	strh.w	r7, [r5, #2976]	; 0xba0
 8001aa2:	f8c5 3bc4 	str.w	r3, [r5, #3012]	; 0xbc4
 8001aa6:	f8c5 3bc8 	str.w	r3, [r5, #3016]	; 0xbc8
 8001aaa:	f8a5 ebec 	strh.w	lr, [r5, #3052]	; 0xbec
 8001aae:	f8c5 1b34 	str.w	r1, [r5, #2868]	; 0xb34
 8001ab2:	f8c5 1b38 	str.w	r1, [r5, #2872]	; 0xb38
 8001ab6:	f8a5 0b52 	strh.w	r0, [r5, #2898]	; 0xb52
 8001aba:	495d      	ldr	r1, [pc, #372]	; (8001c30 <bsec_Bsec_setHyperConfiguration+0x290>)
 8001abc:	f8a5 0b54 	strh.w	r0, [r5, #2900]	; 0xb54
 8001ac0:	2240      	movs	r2, #64	; 0x40
 8001ac2:	4648      	mov	r0, r9
 8001ac4:	f02a fb0c 	bl	802c0e0 <memcpy>
 8001ac8:	f505 622e 	add.w	r2, r5, #2784	; 0xae0
 8001acc:	4959      	ldr	r1, [pc, #356]	; (8001c34 <bsec_Bsec_setHyperConfiguration+0x294>)
 8001ace:	6011      	str	r1, [r2, #0]
 8001ad0:	464f      	mov	r7, r9
 8001ad2:	f605 21dc 	addw	r1, r5, #2780	; 0xadc
 8001ad6:	f605 22e4 	addw	r2, r5, #2788	; 0xae4
 8001ada:	f605 20ec 	addw	r0, r5, #2796	; 0xaec
 8001ade:	2300      	movs	r3, #0
 8001ae0:	f8df c170 	ldr.w	ip, [pc, #368]	; 8001c54 <bsec_Bsec_setHyperConfiguration+0x2b4>
 8001ae4:	600b      	str	r3, [r1, #0]
 8001ae6:	603b      	str	r3, [r7, #0]
 8001ae8:	f505 612f 	add.w	r1, r5, #2800	; 0xaf0
 8001aec:	f8c2 c000 	str.w	ip, [r2]
 8001af0:	f505 6730 	add.w	r7, r5, #2816	; 0xb00
 8001af4:	6003      	str	r3, [r0, #0]
 8001af6:	f605 22f4 	addw	r2, r5, #2804	; 0xaf4
 8001afa:	f605 20fc 	addw	r0, r5, #2812	; 0xafc
 8001afe:	f8df e158 	ldr.w	lr, [pc, #344]	; 8001c58 <bsec_Bsec_setHyperConfiguration+0x2b8>
 8001b02:	f8df 8158 	ldr.w	r8, [pc, #344]	; 8001c5c <bsec_Bsec_setHyperConfiguration+0x2bc>
 8001b06:	600b      	str	r3, [r1, #0]
 8001b08:	f605 2cf8 	addw	ip, r5, #2808	; 0xaf8
 8001b0c:	6013      	str	r3, [r2, #0]
 8001b0e:	f605 3104 	addw	r1, r5, #2820	; 0xb04
 8001b12:	f8c7 e000 	str.w	lr, [r7]
 8001b16:	f605 320c 	addw	r2, r5, #2828	; 0xb0c
 8001b1a:	f8c0 8000 	str.w	r8, [r0]
 8001b1e:	f505 6731 	add.w	r7, r5, #2832	; 0xb10
 8001b22:	f605 3014 	addw	r0, r5, #2836	; 0xb14
 8001b26:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 8001b2a:	f8df a134 	ldr.w	sl, [pc, #308]	; 8001c60 <bsec_Bsec_setHyperConfiguration+0x2c0>
 8001b2e:	f8df 9134 	ldr.w	r9, [pc, #308]	; 8001c64 <bsec_Bsec_setHyperConfiguration+0x2c4>
 8001b32:	f8df 8134 	ldr.w	r8, [pc, #308]	; 8001c68 <bsec_Bsec_setHyperConfiguration+0x2c8>
 8001b36:	f8cc a000 	str.w	sl, [ip]
 8001b3a:	4633      	mov	r3, r6
 8001b3c:	f8c1 9000 	str.w	r9, [r1]
 8001b40:	f8c2 e000 	str.w	lr, [r2]
 8001b44:	f505 6142 	add.w	r1, r5, #3104	; 0xc20
 8001b48:	f8c7 e000 	str.w	lr, [r7]
 8001b4c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001b50:	f8c0 8000 	str.w	r8, [r0]
 8001b54:	f823 2f02 	strh.w	r2, [r3, #2]!
 8001b58:	428b      	cmp	r3, r1
 8001b5a:	d1fb      	bne.n	8001b54 <bsec_Bsec_setHyperConfiguration+0x1b4>
 8001b5c:	4b36      	ldr	r3, [pc, #216]	; (8001c38 <bsec_Bsec_setHyperConfiguration+0x298>)
 8001b5e:	f8c5 3c84 	str.w	r3, [r5, #3204]	; 0xc84
 8001b62:	f247 5230 	movw	r2, #30000	; 0x7530
 8001b66:	f8a5 2c24 	strh.w	r2, [r5, #3108]	; 0xc24
 8001b6a:	4f34      	ldr	r7, [pc, #208]	; (8001c3c <bsec_Bsec_setHyperConfiguration+0x29c>)
 8001b6c:	4834      	ldr	r0, [pc, #208]	; (8001c40 <bsec_Bsec_setHyperConfiguration+0x2a0>)
 8001b6e:	f605 4388 	addw	r3, r5, #3208	; 0xc88
 8001b72:	f605 4c9c 	addw	ip, r5, #3228	; 0xc9c
 8001b76:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8001b7a:	2205      	movs	r2, #5
 8001b7c:	e003      	b.n	8001b86 <bsec_Bsec_setHyperConfiguration+0x1e6>
 8001b7e:	f917 2f01 	ldrsb.w	r2, [r7, #1]!
 8001b82:	f830 1f02 	ldrh.w	r1, [r0, #2]!
 8001b86:	f823 2f02 	strh.w	r2, [r3, #2]!
 8001b8a:	4563      	cmp	r3, ip
 8001b8c:	8299      	strh	r1, [r3, #20]
 8001b8e:	d1f6      	bne.n	8001b7e <bsec_Bsec_setHyperConfiguration+0x1de>
 8001b90:	220a      	movs	r2, #10
 8001b92:	2300      	movs	r3, #0
 8001b94:	f885 2cb2 	strb.w	r2, [r5, #3250]	; 0xcb2
 8001b98:	f8a5 3c26 	strh.w	r3, [r5, #3110]	; 0xc26
 8001b9c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8001ba0:	f834 3f02 	ldrh.w	r3, [r4, #2]!
 8001ba4:	428b      	cmp	r3, r1
 8001ba6:	d005      	beq.n	8001bb4 <bsec_Bsec_setHyperConfiguration+0x214>
 8001ba8:	f8b5 2c26 	ldrh.w	r2, [r5, #3110]	; 0xc26
 8001bac:	429a      	cmp	r2, r3
 8001bae:	bf38      	it	cc
 8001bb0:	f8a5 3c26 	strhcc.w	r3, [r5, #3110]	; 0xc26
 8001bb4:	42b4      	cmp	r4, r6
 8001bb6:	d1f3      	bne.n	8001ba0 <bsec_Bsec_setHyperConfiguration+0x200>
 8001bb8:	4c22      	ldr	r4, [pc, #136]	; (8001c44 <bsec_Bsec_setHyperConfiguration+0x2a4>)
 8001bba:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 8001c6c <bsec_Bsec_setHyperConfiguration+0x2cc>
 8001bbe:	2300      	movs	r3, #0
 8001bc0:	2701      	movs	r7, #1
 8001bc2:	fa44 f203 	asr.w	r2, r4, r3
 8001bc6:	07d2      	lsls	r2, r2, #31
 8001bc8:	d511      	bpl.n	8001bee <bsec_Bsec_setHyperConfiguration+0x24e>
 8001bca:	f813 200c 	ldrb.w	r2, [r3, ip]
 8001bce:	eb05 0142 	add.w	r1, r5, r2, lsl #1
 8001bd2:	3a01      	subs	r2, #1
 8001bd4:	f8b1 0bfa 	ldrh.w	r0, [r1, #3066]	; 0xbfa
 8001bd8:	f8b1 6c3e 	ldrh.w	r6, [r1, #3134]	; 0xc3e
 8001bdc:	4286      	cmp	r6, r0
 8001bde:	bf1c      	itt	ne
 8001be0:	1952      	addne	r2, r2, r5
 8001be2:	f882 7c66 	strbne.w	r7, [r2, #3174]	; 0xc66
 8001be6:	f8a1 0c3e 	strh.w	r0, [r1, #3134]	; 0xc3e
 8001bea:	f885 7c81 	strb.w	r7, [r5, #3201]	; 0xc81
 8001bee:	3301      	adds	r3, #1
 8001bf0:	2b1a      	cmp	r3, #26
 8001bf2:	d1e6      	bne.n	8001bc2 <bsec_Bsec_setHyperConfiguration+0x222>
 8001bf4:	f605 4365 	addw	r3, r5, #3173	; 0xc65
 8001bf8:	f605 4178 	addw	r1, r5, #3192	; 0xc78
 8001bfc:	2201      	movs	r2, #1
 8001bfe:	f803 2f01 	strb.w	r2, [r3, #1]!
 8001c02:	428b      	cmp	r3, r1
 8001c04:	d1fb      	bne.n	8001bfe <bsec_Bsec_setHyperConfiguration+0x25e>
 8001c06:	f895 3c81 	ldrb.w	r3, [r5, #3201]	; 0xc81
 8001c0a:	b90b      	cbnz	r3, 8001c10 <bsec_Bsec_setHyperConfiguration+0x270>
 8001c0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001c10:	4628      	mov	r0, r5
 8001c12:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001c16:	f7ff bbef 	b.w	80013f8 <bsec_Bsec_applyUpdateSubscription.part.0>
 8001c1a:	bf00      	nop
 8001c1c:	0802d564 	.word	0x0802d564
 8001c20:	75307530 	.word	0x75307530
 8001c24:	17701770 	.word	0x17701770
 8001c28:	012c012c 	.word	0x012c012c
 8001c2c:	07080708 	.word	0x07080708
 8001c30:	0802d590 	.word	0x0802d590
 8001c34:	c2820000 	.word	0xc2820000
 8001c38:	0a050000 	.word	0x0a050000
 8001c3c:	0802d558 	.word	0x0802d558
 8001c40:	0802d57c 	.word	0x0802d57c
 8001c44:	03f279ef 	.word	0x03f279ef
 8001c48:	75300064 	.word	0x75300064
 8001c4c:	05dc05dc 	.word	0x05dc05dc
 8001c50:	00640708 	.word	0x00640708
 8001c54:	432a0000 	.word	0x432a0000
 8001c58:	42fa0000 	.word	0x42fa0000
 8001c5c:	42c80000 	.word	0x42c80000
 8001c60:	49f42400 	.word	0x49f42400
 8001c64:	4cc474f8 	.word	0x4cc474f8
 8001c68:	41100000 	.word	0x41100000
 8001c6c:	0802d6bc 	.word	0x0802d6bc

08001c70 <bsec_Bsec_setHyperState>:
 8001c70:	b470      	push	{r4, r5, r6}
 8001c72:	2200      	movs	r2, #0
 8001c74:	2300      	movs	r3, #0
 8001c76:	f500 642c 	add.w	r4, r0, #2752	; 0xac0
 8001c7a:	2100      	movs	r1, #0
 8001c7c:	f880 1c7d 	strb.w	r1, [r0, #3197]	; 0xc7d
 8001c80:	f8a0 1c7a 	strh.w	r1, [r0, #3194]	; 0xc7a
 8001c84:	f500 652d 	add.w	r5, r0, #2768	; 0xad0
 8001c88:	e9c4 2300 	strd	r2, r3, [r4]
 8001c8c:	f600 26c8 	addw	r6, r0, #2760	; 0xac8
 8001c90:	f247 5430 	movw	r4, #30000	; 0x7530
 8001c94:	e9c6 2300 	strd	r2, r3, [r6]
 8001c98:	e9c5 2300 	strd	r2, r3, [r5]
 8001c9c:	f8a0 4c22 	strh.w	r4, [r0, #3106]	; 0xc22
 8001ca0:	f600 433e 	addw	r3, r0, #3134	; 0xc3e
 8001ca4:	f600 4265 	addw	r2, r0, #3173	; 0xc65
 8001ca8:	f600 4564 	addw	r5, r0, #3172	; 0xc64
 8001cac:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8001cb0:	f823 4f02 	strh.w	r4, [r3, #2]!
 8001cb4:	42ab      	cmp	r3, r5
 8001cb6:	f802 1f01 	strb.w	r1, [r2, #1]!
 8001cba:	d1f9      	bne.n	8001cb0 <bsec_Bsec_setHyperState+0x40>
 8001cbc:	f44f 42cc 	mov.w	r2, #26112	; 0x6600
 8001cc0:	2301      	movs	r3, #1
 8001cc2:	bc70      	pop	{r4, r5, r6}
 8001cc4:	f880 1c81 	strb.w	r1, [r0, #3201]	; 0xc81
 8001cc8:	f880 1c7c 	strb.w	r1, [r0, #3196]	; 0xc7c
 8001ccc:	f880 1cb3 	strb.w	r1, [r0, #3251]	; 0xcb3
 8001cd0:	f8a0 1cb4 	strh.w	r1, [r0, #3252]	; 0xcb4
 8001cd4:	f8a0 2c82 	strh.w	r2, [r0, #3202]	; 0xc82
 8001cd8:	f880 3c88 	strb.w	r3, [r0, #3208]	; 0xc88
 8001cdc:	4770      	bx	lr
 8001cde:	bf00      	nop

08001ce0 <bsec_Bsec_setSensorOpMode>:
 8001ce0:	f890 3c85 	ldrb.w	r3, [r0, #3205]	; 0xc85
 8001ce4:	4293      	cmp	r3, r2
 8001ce6:	d011      	beq.n	8001d0c <bsec_Bsec_setSensorOpMode+0x2c>
 8001ce8:	b96a      	cbnz	r2, 8001d06 <bsec_Bsec_setSensorOpMode+0x26>
 8001cea:	2300      	movs	r3, #0
 8001cec:	f880 3c7c 	strb.w	r3, [r0, #3196]	; 0xc7c
 8001cf0:	608b      	str	r3, [r1, #8]
 8001cf2:	f881 303d 	strb.w	r3, [r1, #61]	; 0x3d
 8001cf6:	2300      	movs	r3, #0
 8001cf8:	f880 2c85 	strb.w	r2, [r0, #3205]	; 0xc85
 8001cfc:	f880 3cb4 	strb.w	r3, [r0, #3252]	; 0xcb4
 8001d00:	f881 203e 	strb.w	r2, [r1, #62]	; 0x3e
 8001d04:	4770      	bx	lr
 8001d06:	1e93      	subs	r3, r2, #2
 8001d08:	2b01      	cmp	r3, #1
 8001d0a:	d9ee      	bls.n	8001cea <bsec_Bsec_setSensorOpMode+0xa>
 8001d0c:	f8b0 3c48 	ldrh.w	r3, [r0, #3144]	; 0xc48
 8001d10:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 8001d14:	b470      	push	{r4, r5, r6}
 8001d16:	d047      	beq.n	8001da8 <bsec_Bsec_setSensorOpMode+0xc8>
 8001d18:	688b      	ldr	r3, [r1, #8]
 8001d1a:	f8b0 4c4a 	ldrh.w	r4, [r0, #3146]	; 0xc4a
 8001d1e:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d22:	f8b0 4c4c 	ldrh.w	r4, [r0, #3148]	; 0xc4c
 8001d26:	bf04      	itt	eq
 8001d28:	f043 0301 	orreq.w	r3, r3, #1
 8001d2c:	608b      	streq	r3, [r1, #8]
 8001d2e:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d32:	f8b0 4c4e 	ldrh.w	r4, [r0, #3150]	; 0xc4e
 8001d36:	bf04      	itt	eq
 8001d38:	f043 0302 	orreq.w	r3, r3, #2
 8001d3c:	608b      	streq	r3, [r1, #8]
 8001d3e:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d42:	f8b0 4c64 	ldrh.w	r4, [r0, #3172]	; 0xc64
 8001d46:	bf04      	itt	eq
 8001d48:	f043 0308 	orreq.w	r3, r3, #8
 8001d4c:	608b      	streq	r3, [r1, #8]
 8001d4e:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d52:	f8b0 4c5c 	ldrh.w	r4, [r0, #3164]	; 0xc5c
 8001d56:	bf04      	itt	eq
 8001d58:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
 8001d5c:	608b      	streq	r3, [r1, #8]
 8001d5e:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d62:	d010      	beq.n	8001d86 <bsec_Bsec_setSensorOpMode+0xa6>
 8001d64:	f8b0 4c5e 	ldrh.w	r4, [r0, #3166]	; 0xc5e
 8001d68:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d6c:	d00b      	beq.n	8001d86 <bsec_Bsec_setSensorOpMode+0xa6>
 8001d6e:	f8b0 4c60 	ldrh.w	r4, [r0, #3168]	; 0xc60
 8001d72:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d76:	d006      	beq.n	8001d86 <bsec_Bsec_setSensorOpMode+0xa6>
 8001d78:	f8b0 4c62 	ldrh.w	r4, [r0, #3170]	; 0xc62
 8001d7c:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 8001d80:	d001      	beq.n	8001d86 <bsec_Bsec_setSensorOpMode+0xa6>
 8001d82:	b143      	cbz	r3, 8001d96 <bsec_Bsec_setSensorOpMode+0xb6>
 8001d84:	e004      	b.n	8001d90 <bsec_Bsec_setSensorOpMode+0xb0>
 8001d86:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001d8a:	f043 030f 	orr.w	r3, r3, #15
 8001d8e:	608b      	str	r3, [r1, #8]
 8001d90:	2301      	movs	r3, #1
 8001d92:	f881 303d 	strb.w	r3, [r1, #61]	; 0x3d
 8001d96:	2300      	movs	r3, #0
 8001d98:	f880 2c85 	strb.w	r2, [r0, #3205]	; 0xc85
 8001d9c:	f880 3cb4 	strb.w	r3, [r0, #3252]	; 0xcb4
 8001da0:	bc70      	pop	{r4, r5, r6}
 8001da2:	f881 203e 	strb.w	r2, [r1, #62]	; 0x3e
 8001da6:	4770      	bx	lr
 8001da8:	4b09      	ldr	r3, [pc, #36]	; (8001dd0 <bsec_Bsec_setSensorOpMode+0xf0>)
 8001daa:	688d      	ldr	r5, [r1, #8]
 8001dac:	7b5c      	ldrb	r4, [r3, #13]
 8001dae:	eb00 0444 	add.w	r4, r0, r4, lsl #1
 8001db2:	f045 0304 	orr.w	r3, r5, #4
 8001db6:	f8b4 6a68 	ldrh.w	r6, [r4, #2664]	; 0xa68
 8001dba:	608b      	str	r3, [r1, #8]
 8001dbc:	f64f 74ff 	movw	r4, #65535	; 0xffff
 8001dc0:	42a6      	cmp	r6, r4
 8001dc2:	d0aa      	beq.n	8001d1a <bsec_Bsec_setSensorOpMode+0x3a>
 8001dc4:	f445 5300 	orr.w	r3, r5, #8192	; 0x2000
 8001dc8:	f043 0304 	orr.w	r3, r3, #4
 8001dcc:	608b      	str	r3, [r1, #8]
 8001dce:	e7a4      	b.n	8001d1a <bsec_Bsec_setSensorOpMode+0x3a>
 8001dd0:	0802d6d8 	.word	0x0802d6d8

08001dd4 <bsec_Bsec_validateSerialization>:
 8001dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dd6:	b089      	sub	sp, #36	; 0x24
 8001dd8:	460c      	mov	r4, r1
 8001dda:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8001ddc:	2100      	movs	r1, #0
 8001dde:	2c17      	cmp	r4, #23
 8001de0:	461e      	mov	r6, r3
 8001de2:	6029      	str	r1, [r5, #0]
 8001de4:	d803      	bhi.n	8001dee <bsec_Bsec_validateSerialization+0x1a>
 8001de6:	23db      	movs	r3, #219	; 0xdb
 8001de8:	7033      	strb	r3, [r6, #0]
 8001dea:	b009      	add	sp, #36	; 0x24
 8001dec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dee:	4294      	cmp	r4, r2
 8001df0:	d903      	bls.n	8001dfa <bsec_Bsec_validateSerialization+0x26>
 8001df2:	23da      	movs	r3, #218	; 0xda
 8001df4:	7033      	strb	r3, [r6, #0]
 8001df6:	b009      	add	sp, #36	; 0x24
 8001df8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dfa:	4607      	mov	r7, r0
 8001dfc:	a902      	add	r1, sp, #8
 8001dfe:	783a      	ldrb	r2, [r7, #0]
 8001e00:	787b      	ldrb	r3, [r7, #1]
 8001e02:	f88d 2008 	strb.w	r2, [sp, #8]
 8001e06:	78ba      	ldrb	r2, [r7, #2]
 8001e08:	f88d 3009 	strb.w	r3, [sp, #9]
 8001e0c:	f88d 200a 	strb.w	r2, [sp, #10]
 8001e10:	78fb      	ldrb	r3, [r7, #3]
 8001e12:	f88d 300b 	strb.w	r3, [sp, #11]
 8001e16:	2204      	movs	r2, #4
 8001e18:	a803      	add	r0, sp, #12
 8001e1a:	f02a f961 	bl	802c0e0 <memcpy>
 8001e1e:	9b03      	ldr	r3, [sp, #12]
 8001e20:	4a2e      	ldr	r2, [pc, #184]	; (8001edc <bsec_Bsec_validateSerialization+0x108>)
 8001e22:	4293      	cmp	r3, r2
 8001e24:	d004      	beq.n	8001e30 <bsec_Bsec_validateSerialization+0x5c>
 8001e26:	3301      	adds	r3, #1
 8001e28:	d002      	beq.n	8001e30 <bsec_Bsec_validateSerialization+0x5c>
 8001e2a:	23de      	movs	r3, #222	; 0xde
 8001e2c:	7033      	strb	r3, [r6, #0]
 8001e2e:	e7dc      	b.n	8001dea <bsec_Bsec_validateSerialization+0x16>
 8001e30:	2208      	movs	r2, #8
 8001e32:	1d39      	adds	r1, r7, #4
 8001e34:	a806      	add	r0, sp, #24
 8001e36:	f02a f953 	bl	802c0e0 <memcpy>
 8001e3a:	a906      	add	r1, sp, #24
 8001e3c:	2208      	movs	r2, #8
 8001e3e:	a804      	add	r0, sp, #16
 8001e40:	f02a f94e 	bl	802c0e0 <memcpy>
 8001e44:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8001e48:	2100      	movs	r1, #0
 8001e4a:	f240 10bd 	movw	r0, #445	; 0x1bd
 8001e4e:	428b      	cmp	r3, r1
 8001e50:	bf08      	it	eq
 8001e52:	4282      	cmpeq	r2, r0
 8001e54:	d007      	beq.n	8001e66 <bsec_Bsec_validateSerialization+0x92>
 8001e56:	2b00      	cmp	r3, #0
 8001e58:	bf08      	it	eq
 8001e5a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
 8001e5e:	d002      	beq.n	8001e66 <bsec_Bsec_validateSerialization+0x92>
 8001e60:	23dd      	movs	r3, #221	; 0xdd
 8001e62:	7033      	strb	r3, [r6, #0]
 8001e64:	e7c1      	b.n	8001dea <bsec_Bsec_validateSerialization+0x16>
 8001e66:	7b3a      	ldrb	r2, [r7, #12]
 8001e68:	7b7b      	ldrb	r3, [r7, #13]
 8001e6a:	f88d 2008 	strb.w	r2, [sp, #8]
 8001e6e:	7bba      	ldrb	r2, [r7, #14]
 8001e70:	f88d 3009 	strb.w	r3, [sp, #9]
 8001e74:	a902      	add	r1, sp, #8
 8001e76:	7bfb      	ldrb	r3, [r7, #15]
 8001e78:	f88d 200a 	strb.w	r2, [sp, #10]
 8001e7c:	a803      	add	r0, sp, #12
 8001e7e:	2204      	movs	r2, #4
 8001e80:	f88d 300b 	strb.w	r3, [sp, #11]
 8001e84:	f02a f92c 	bl	802c0e0 <memcpy>
 8001e88:	9903      	ldr	r1, [sp, #12]
 8001e8a:	f101 0318 	add.w	r3, r1, #24
 8001e8e:	42a3      	cmp	r3, r4
 8001e90:	d002      	beq.n	8001e98 <bsec_Bsec_validateSerialization+0xc4>
 8001e92:	23d8      	movs	r3, #216	; 0xd8
 8001e94:	7033      	strb	r3, [r6, #0]
 8001e96:	e7a8      	b.n	8001dea <bsec_Bsec_validateSerialization+0x16>
 8001e98:	aa01      	add	r2, sp, #4
 8001e9a:	4638      	mov	r0, r7
 8001e9c:	3110      	adds	r1, #16
 8001e9e:	f004 fed5 	bl	8006c4c <bsec_crcCcitt2>
 8001ea2:	1938      	adds	r0, r7, r4
 8001ea4:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8001ea8:	f810 3c04 	ldrb.w	r3, [r0, #-4]
 8001eac:	429a      	cmp	r2, r3
 8001eae:	d002      	beq.n	8001eb6 <bsec_Bsec_validateSerialization+0xe2>
 8001eb0:	23dc      	movs	r3, #220	; 0xdc
 8001eb2:	7033      	strb	r3, [r6, #0]
 8001eb4:	e799      	b.n	8001dea <bsec_Bsec_validateSerialization+0x16>
 8001eb6:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8001eba:	f810 3c03 	ldrb.w	r3, [r0, #-3]
 8001ebe:	429a      	cmp	r2, r3
 8001ec0:	d1f6      	bne.n	8001eb0 <bsec_Bsec_validateSerialization+0xdc>
 8001ec2:	f810 3c02 	ldrb.w	r3, [r0, #-2]
 8001ec6:	2b00      	cmp	r3, #0
 8001ec8:	d1f2      	bne.n	8001eb0 <bsec_Bsec_validateSerialization+0xdc>
 8001eca:	f810 3c01 	ldrb.w	r3, [r0, #-1]
 8001ece:	2b00      	cmp	r3, #0
 8001ed0:	d1ee      	bne.n	8001eb0 <bsec_Bsec_validateSerialization+0xdc>
 8001ed2:	2210      	movs	r2, #16
 8001ed4:	602a      	str	r2, [r5, #0]
 8001ed6:	7033      	strb	r3, [r6, #0]
 8001ed8:	e787      	b.n	8001dea <bsec_Bsec_validateSerialization+0x16>
 8001eda:	bf00      	nop
 8001edc:	02020000 	.word	0x02020000

08001ee0 <bsec_b_Bsec_setHyperConfiguration>:
 8001ee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001ee4:	b086      	sub	sp, #24
 8001ee6:	ab04      	add	r3, sp, #16
 8001ee8:	ae05      	add	r6, sp, #20
 8001eea:	e9cd 3600 	strd	r3, r6, [sp]
 8001eee:	4604      	mov	r4, r0
 8001ef0:	f10d 030f 	add.w	r3, sp, #15
 8001ef4:	20fe      	movs	r0, #254	; 0xfe
 8001ef6:	460d      	mov	r5, r1
 8001ef8:	f004 fdca 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8001efc:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8001f00:	2800      	cmp	r0, #0
 8001f02:	d161      	bne.n	8001fc8 <bsec_b_Bsec_setHyperConfiguration+0xe8>
 8001f04:	f04f 0a01 	mov.w	sl, #1
 8001f08:	f604 499e 	addw	r9, r4, #3230	; 0xc9e
 8001f0c:	f604 488a 	addw	r8, r4, #3210	; 0xc8a
 8001f10:	f604 4786 	addw	r7, r4, #3206	; 0xc86
 8001f14:	fa5f f38a 	uxtb.w	r3, sl
 8001f18:	3b01      	subs	r3, #1
 8001f1a:	2b0a      	cmp	r3, #10
 8001f1c:	f200 809f 	bhi.w	800205e <bsec_b_Bsec_setHyperConfiguration+0x17e>
 8001f20:	e8df f003 	tbb	[pc, r3]
 8001f24:	7d848b92 	.word	0x7d848b92
 8001f28:	61686f76 	.word	0x61686f76
 8001f2c:	555b      	.short	0x555b
 8001f2e:	06          	.byte	0x06
 8001f2f:	00          	.byte	0x00
 8001f30:	464a      	mov	r2, r9
 8001f32:	4631      	mov	r1, r6
 8001f34:	4628      	mov	r0, r5
 8001f36:	f001 fb7f 	bl	8003638 <bsec_l_Entity_parseAndDeserialize>
 8001f3a:	f10a 0a01 	add.w	sl, sl, #1
 8001f3e:	f1ba 0f0d 	cmp.w	sl, #13
 8001f42:	d1e7      	bne.n	8001f14 <bsec_b_Bsec_setHyperConfiguration+0x34>
 8001f44:	2300      	movs	r3, #0
 8001f46:	f8a4 3c26 	strh.w	r3, [r4, #3110]	; 0xc26
 8001f4a:	f604 35fa 	addw	r5, r4, #3066	; 0xbfa
 8001f4e:	f604 3316 	addw	r3, r4, #2838	; 0xb16
 8001f52:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8001f56:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 8001f5a:	4282      	cmp	r2, r0
 8001f5c:	d005      	beq.n	8001f6a <bsec_b_Bsec_setHyperConfiguration+0x8a>
 8001f5e:	f8b4 1c26 	ldrh.w	r1, [r4, #3110]	; 0xc26
 8001f62:	4291      	cmp	r1, r2
 8001f64:	bf38      	it	cc
 8001f66:	f8a4 2c26 	strhcc.w	r2, [r4, #3110]	; 0xc26
 8001f6a:	429d      	cmp	r5, r3
 8001f6c:	d1f3      	bne.n	8001f56 <bsec_b_Bsec_setHyperConfiguration+0x76>
 8001f6e:	4d3f      	ldr	r5, [pc, #252]	; (800206c <bsec_b_Bsec_setHyperConfiguration+0x18c>)
 8001f70:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 8002070 <bsec_b_Bsec_setHyperConfiguration+0x190>
 8001f74:	2300      	movs	r3, #0
 8001f76:	2701      	movs	r7, #1
 8001f78:	fa45 f203 	asr.w	r2, r5, r3
 8001f7c:	07d2      	lsls	r2, r2, #31
 8001f7e:	d511      	bpl.n	8001fa4 <bsec_b_Bsec_setHyperConfiguration+0xc4>
 8001f80:	f813 200c 	ldrb.w	r2, [r3, ip]
 8001f84:	eb04 0142 	add.w	r1, r4, r2, lsl #1
 8001f88:	3a01      	subs	r2, #1
 8001f8a:	f8b1 0bfa 	ldrh.w	r0, [r1, #3066]	; 0xbfa
 8001f8e:	f8b1 6c3e 	ldrh.w	r6, [r1, #3134]	; 0xc3e
 8001f92:	4286      	cmp	r6, r0
 8001f94:	bf1c      	itt	ne
 8001f96:	1912      	addne	r2, r2, r4
 8001f98:	f882 7c66 	strbne.w	r7, [r2, #3174]	; 0xc66
 8001f9c:	f8a1 0c3e 	strh.w	r0, [r1, #3134]	; 0xc3e
 8001fa0:	f884 7c81 	strb.w	r7, [r4, #3201]	; 0xc81
 8001fa4:	3301      	adds	r3, #1
 8001fa6:	2b1a      	cmp	r3, #26
 8001fa8:	d1e6      	bne.n	8001f78 <bsec_b_Bsec_setHyperConfiguration+0x98>
 8001faa:	f604 4365 	addw	r3, r4, #3173	; 0xc65
 8001fae:	f604 4178 	addw	r1, r4, #3192	; 0xc78
 8001fb2:	2201      	movs	r2, #1
 8001fb4:	f803 2f01 	strb.w	r2, [r3, #1]!
 8001fb8:	428b      	cmp	r3, r1
 8001fba:	d1fb      	bne.n	8001fb4 <bsec_b_Bsec_setHyperConfiguration+0xd4>
 8001fbc:	f894 3c81 	ldrb.w	r3, [r4, #3201]	; 0xc81
 8001fc0:	2b00      	cmp	r3, #0
 8001fc2:	d148      	bne.n	8002056 <bsec_b_Bsec_setHyperConfiguration+0x176>
 8001fc4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8001fc8:	b006      	add	sp, #24
 8001fca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001fce:	4642      	mov	r2, r8
 8001fd0:	4631      	mov	r1, r6
 8001fd2:	4628      	mov	r0, r5
 8001fd4:	f001 fb30 	bl	8003638 <bsec_l_Entity_parseAndDeserialize>
 8001fd8:	e7af      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8001fda:	463a      	mov	r2, r7
 8001fdc:	4631      	mov	r1, r6
 8001fde:	4628      	mov	r0, r5
 8001fe0:	f001 f940 	bl	8003264 <bsec_d_Entity_parseAndDeserialize>
 8001fe4:	e7a9      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8001fe6:	4631      	mov	r1, r6
 8001fe8:	4628      	mov	r0, r5
 8001fea:	f001 f9c1 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8001fee:	f884 0c84 	strb.w	r0, [r4, #3204]	; 0xc84
 8001ff2:	e7a2      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8001ff4:	4631      	mov	r1, r6
 8001ff6:	4628      	mov	r0, r5
 8001ff8:	f001 f8fa 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8001ffc:	f8a4 0c24 	strh.w	r0, [r4, #3108]	; 0xc24
 8002000:	e79b      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8002002:	f604 32fc 	addw	r2, r4, #3068	; 0xbfc
 8002006:	4631      	mov	r1, r6
 8002008:	4628      	mov	r0, r5
 800200a:	f001 facb 	bl	80035a4 <bsec_k_Entity_parseAndDeserialize>
 800200e:	e794      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8002010:	f604 3218 	addw	r2, r4, #2840	; 0xb18
 8002014:	4631      	mov	r1, r6
 8002016:	4628      	mov	r0, r5
 8002018:	f001 fa7e 	bl	8003518 <bsec_j_Entity_parseAndDeserialize>
 800201c:	e78d      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 800201e:	f604 4228 	addw	r2, r4, #3112	; 0xc28
 8002022:	4631      	mov	r1, r6
 8002024:	4628      	mov	r0, r5
 8002026:	f001 fa37 	bl	8003498 <bsec_i_Entity_parseAndDeserialize>
 800202a:	e786      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 800202c:	4631      	mov	r1, r6
 800202e:	4628      	mov	r0, r5
 8002030:	f001 f99e 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8002034:	f884 0c80 	strb.w	r0, [r4, #3200]	; 0xc80
 8002038:	e77f      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 800203a:	4631      	mov	r1, r6
 800203c:	4628      	mov	r0, r5
 800203e:	f001 f997 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8002042:	f884 0c7f 	strb.w	r0, [r4, #3199]	; 0xc7f
 8002046:	e778      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8002048:	4631      	mov	r1, r6
 800204a:	4628      	mov	r0, r5
 800204c:	f001 f990 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8002050:	f884 0c7e 	strb.w	r0, [r4, #3198]	; 0xc7e
 8002054:	e771      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 8002056:	4620      	mov	r0, r4
 8002058:	f7ff f9ce 	bl	80013f8 <bsec_Bsec_applyUpdateSubscription.part.0>
 800205c:	e7b2      	b.n	8001fc4 <bsec_b_Bsec_setHyperConfiguration+0xe4>
 800205e:	4631      	mov	r1, r6
 8002060:	4628      	mov	r0, r5
 8002062:	f001 f985 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8002066:	f884 0cb2 	strb.w	r0, [r4, #3250]	; 0xcb2
 800206a:	e766      	b.n	8001f3a <bsec_b_Bsec_setHyperConfiguration+0x5a>
 800206c:	03f279ef 	.word	0x03f279ef
 8002070:	0802d6bc 	.word	0x0802d6bc

08002074 <bsec_b_Bsec_setHyperState>:
 8002074:	2903      	cmp	r1, #3
 8002076:	d916      	bls.n	80020a6 <bsec_b_Bsec_setHyperState+0x32>
 8002078:	b510      	push	{r4, lr}
 800207a:	b082      	sub	sp, #8
 800207c:	7802      	ldrb	r2, [r0, #0]
 800207e:	7843      	ldrb	r3, [r0, #1]
 8002080:	f88d 2004 	strb.w	r2, [sp, #4]
 8002084:	4604      	mov	r4, r0
 8002086:	2202      	movs	r2, #2
 8002088:	a901      	add	r1, sp, #4
 800208a:	f10d 0006 	add.w	r0, sp, #6
 800208e:	f88d 3005 	strb.w	r3, [sp, #5]
 8002092:	f02a f825 	bl	802c0e0 <memcpy>
 8002096:	78a3      	ldrb	r3, [r4, #2]
 8002098:	2bfe      	cmp	r3, #254	; 0xfe
 800209a:	bf0c      	ite	eq
 800209c:	2000      	moveq	r0, #0
 800209e:	f06f 0063 	mvnne.w	r0, #99	; 0x63
 80020a2:	b002      	add	sp, #8
 80020a4:	bd10      	pop	{r4, pc}
 80020a6:	f06f 0067 	mvn.w	r0, #103	; 0x67
 80020aa:	4770      	bx	lr

080020ac <bsec_ChannelHub_isChannelReady.part.0>:
 80020ac:	4b19      	ldr	r3, [pc, #100]	; (8002114 <bsec_ChannelHub_isChannelReady.part.0+0x68>)
 80020ae:	3901      	subs	r1, #1
 80020b0:	b470      	push	{r4, r5, r6}
 80020b2:	5c5b      	ldrb	r3, [r3, r1]
 80020b4:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80020b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80020bc:	f8b3 4a5a 	ldrh.w	r4, [r3, #2650]	; 0xa5a
 80020c0:	4294      	cmp	r4, r2
 80020c2:	d006      	beq.n	80020d2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
 80020c4:	4c14      	ldr	r4, [pc, #80]	; (8002118 <bsec_ChannelHub_isChannelReady.part.0+0x6c>)
 80020c6:	f8d0 2a58 	ldr.w	r2, [r0, #2648]	; 0xa58
 80020ca:	f934 4011 	ldrsh.w	r4, [r4, r1, lsl #1]
 80020ce:	4394      	bics	r4, r2
 80020d0:	d002      	beq.n	80020d8 <bsec_ChannelHub_isChannelReady.part.0+0x2c>
 80020d2:	2000      	movs	r0, #0
 80020d4:	bc70      	pop	{r4, r5, r6}
 80020d6:	4770      	bx	lr
 80020d8:	4c10      	ldr	r4, [pc, #64]	; (800211c <bsec_ChannelHub_isChannelReady.part.0+0x70>)
 80020da:	f8d0 5a3c 	ldr.w	r5, [r0, #2620]	; 0xa3c
 80020de:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
 80020e2:	43ac      	bics	r4, r5
 80020e4:	d1f5      	bne.n	80020d2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
 80020e6:	f8b3 5aac 	ldrh.w	r5, [r3, #2732]	; 0xaac
 80020ea:	f8b3 6a9e 	ldrh.w	r6, [r3, #2718]	; 0xa9e
 80020ee:	1c6c      	adds	r4, r5, #1
 80020f0:	b2a5      	uxth	r5, r4
 80020f2:	fbb5 f4f6 	udiv	r4, r5, r6
 80020f6:	fb06 5414 	mls	r4, r6, r4, r5
 80020fa:	b2a4      	uxth	r4, r4
 80020fc:	f8a3 4aac 	strh.w	r4, [r3, #2732]	; 0xaac
 8002100:	2c00      	cmp	r4, #0
 8002102:	d1e6      	bne.n	80020d2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
 8002104:	2301      	movs	r3, #1
 8002106:	fa03 f101 	lsl.w	r1, r3, r1
 800210a:	4311      	orrs	r1, r2
 800210c:	f8c0 1a58 	str.w	r1, [r0, #2648]	; 0xa58
 8002110:	4618      	mov	r0, r3
 8002112:	e7df      	b.n	80020d4 <bsec_ChannelHub_isChannelReady.part.0+0x28>
 8002114:	0802d614 	.word	0x0802d614
 8002118:	0802d5d0 	.word	0x0802d5d0
 800211c:	0802d5e8 	.word	0x0802d5e8

08002120 <bsec_ChannelHub_ChannelHub>:
 8002120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002122:	4604      	mov	r4, r0
 8002124:	f003 fb96 	bl	8005854 <bsec_GasHumidityPreProcessor_GasHumidityPreProcessor>
 8002128:	f504 70e0 	add.w	r0, r4, #448	; 0x1c0
 800212c:	f004 fa66 	bl	80065fc <bsec_SensorStatusTracker_SensorStatusTracker>
 8002130:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8002134:	f003 fdfc 	bl	8005d30 <bsec_IaqEstimator_IaqEstimator>
 8002138:	f104 0068 	add.w	r0, r4, #104	; 0x68
 800213c:	f002 fd6a 	bl	8004c14 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker>
 8002140:	f504 70ac 	add.w	r0, r4, #344	; 0x158
 8002144:	f004 f88c 	bl	8006260 <bsec_SensorHeatCompensator_SensorHeatCompensator>
 8002148:	210a      	movs	r1, #10
 800214a:	f504 70fc 	add.w	r0, r4, #504	; 0x1f8
 800214e:	f003 fcc7 	bl	8005ae0 <bsec_HumidityTemperatureCorrector_HumidityTemperatureCorrector>
 8002152:	f504 7004 	add.w	r0, r4, #528	; 0x210
 8002156:	f001 ff37 	bl	8003fc8 <bsec_GasEstimator_GasEstimator>
 800215a:	2600      	movs	r6, #0
 800215c:	f504 631d 	add.w	r3, r4, #2512	; 0x9d0
 8002160:	f604 02f8 	addw	r2, r4, #2296	; 0x8f8
 8002164:	f504 651f 	add.w	r5, r4, #2544	; 0x9f0
 8002168:	2000      	movs	r0, #0
 800216a:	2100      	movs	r1, #0
 800216c:	f843 6b04 	str.w	r6, [r3], #4
 8002170:	42ab      	cmp	r3, r5
 8002172:	e8e2 0102 	strd	r0, r1, [r2], #8
 8002176:	d1f9      	bne.n	800216c <bsec_ChannelHub_ChannelHub+0x4c>
 8002178:	2000      	movs	r0, #0
 800217a:	f04f 0c00 	mov.w	ip, #0
 800217e:	f8c4 0a3c 	str.w	r0, [r4, #2620]	; 0xa3c
 8002182:	f504 6113 	add.w	r1, r4, #2352	; 0x930
 8002186:	f604 223f 	addw	r2, r4, #2623	; 0xa3f
 800218a:	f604 253c 	addw	r5, r4, #2620	; 0xa3c
 800218e:	2600      	movs	r6, #0
 8002190:	2700      	movs	r7, #0
 8002192:	f843 cb04 	str.w	ip, [r3], #4
 8002196:	42ab      	cmp	r3, r5
 8002198:	e9e1 6702 	strd	r6, r7, [r1, #8]!
 800219c:	f802 0f01 	strb.w	r0, [r2, #1]!
 80021a0:	d1f7      	bne.n	8002192 <bsec_ChannelHub_ChannelHub+0x72>
 80021a2:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 80021a6:	f8c4 0a58 	str.w	r0, [r4, #2648]	; 0xa58
 80021aa:	f604 235c 	addw	r3, r4, #2652	; 0xa5c
 80021ae:	f604 256a 	addw	r5, r4, #2666	; 0xa6a
 80021b2:	2001      	movs	r0, #1
 80021b4:	2100      	movs	r1, #0
 80021b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80021ba:	f8a3 0044 	strh.w	r0, [r3, #68]	; 0x44
 80021be:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
 80021c2:	f823 2b02 	strh.w	r2, [r3], #2
 80021c6:	429d      	cmp	r5, r3
 80021c8:	d1f7      	bne.n	80021ba <bsec_ChannelHub_ChannelHub+0x9a>
 80021ca:	f8a4 2a6a 	strh.w	r2, [r4, #2666]	; 0xa6a
 80021ce:	f8a4 2a6c 	strh.w	r2, [r4, #2668]	; 0xa6c
 80021d2:	f8a4 2a6e 	strh.w	r2, [r4, #2670]	; 0xa6e
 80021d6:	f8a4 2a70 	strh.w	r2, [r4, #2672]	; 0xa70
 80021da:	f8a4 2a72 	strh.w	r2, [r4, #2674]	; 0xa72
 80021de:	f8a4 2a74 	strh.w	r2, [r4, #2676]	; 0xa74
 80021e2:	f8a4 2a76 	strh.w	r2, [r4, #2678]	; 0xa76
 80021e6:	f8a4 2a78 	strh.w	r2, [r4, #2680]	; 0xa78
 80021ea:	f604 2378 	addw	r3, r4, #2680	; 0xa78
 80021ee:	f604 219e 	addw	r1, r4, #2718	; 0xa9e
 80021f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80021f6:	f823 2f02 	strh.w	r2, [r3, #2]!
 80021fa:	428b      	cmp	r3, r1
 80021fc:	d1fb      	bne.n	80021f6 <bsec_ChannelHub_ChannelHub+0xd6>
 80021fe:	4620      	mov	r0, r4
 8002200:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002202:	bf00      	nop

08002204 <bsec_ChannelHub_configureChannel>:
 8002204:	b410      	push	{r4}
 8002206:	1e4c      	subs	r4, r1, #1
 8002208:	4611      	mov	r1, r2
 800220a:	461a      	mov	r2, r3
 800220c:	2c0a      	cmp	r4, #10
 800220e:	d807      	bhi.n	8002220 <bsec_ChannelHub_configureChannel+0x1c>
 8002210:	e8df f004 	tbb	[pc, r4]
 8002214:	0615100b 	.word	0x0615100b
 8002218:	06060619 	.word	0x06060619
 800221c:	251f      	.short	0x251f
 800221e:	2b          	.byte	0x2b
 800221f:	00          	.byte	0x00
 8002220:	f06f 0063 	mvn.w	r0, #99	; 0x63
 8002224:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002228:	4770      	bx	lr
 800222a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800222e:	3068      	adds	r0, #104	; 0x68
 8002230:	f002 bd96 	b.w	8004d60 <bsec_GasHumidityBaselineTracker_configure>
 8002234:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002238:	302c      	adds	r0, #44	; 0x2c
 800223a:	f003 bfb9 	b.w	80061b0 <bsec_b_IaqEstimator_configure>
 800223e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002242:	f003 bb13 	b.w	800586c <bsec_GasHumidityPreProcessor_configure>
 8002246:	f85d 4b04 	ldr.w	r4, [sp], #4
 800224a:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 800224e:	f004 b9ef 	b.w	8006630 <bsec_SensorStatusTracker_configure>
 8002252:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002256:	f500 70ac 	add.w	r0, r0, #344	; 0x158
 800225a:	f004 b849 	b.w	80062f0 <bsec_SensorHeatCompensator_configure>
 800225e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002262:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8002266:	f003 bc47 	b.w	8005af8 <bsec_HumidityTemperatureCorrector_configure>
 800226a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800226e:	f500 7004 	add.w	r0, r0, #528	; 0x210
 8002272:	f001 bf1f 	b.w	80040b4 <bsec_GasEstimator_configure>
 8002276:	bf00      	nop

08002278 <bsec_ChannelHub_do>:
 8002278:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800227c:	ed2d 8b02 	vpush	{d8}
 8002280:	2300      	movs	r3, #0
 8002282:	b09e      	sub	sp, #120	; 0x78
 8002284:	ed9f 8ae2 	vldr	s16, [pc, #904]	; 8002610 <bsec_ChannelHub_do+0x398>
 8002288:	f8c0 3a58 	str.w	r3, [r0, #2648]	; 0xa58
 800228c:	460d      	mov	r5, r1
 800228e:	2105      	movs	r1, #5
 8002290:	ee08 5a90 	vmov	s17, r5
 8002294:	4604      	mov	r4, r0
 8002296:	4692      	mov	sl, r2
 8002298:	f88d 3010 	strb.w	r3, [sp, #16]
 800229c:	f88d 3011 	strb.w	r3, [sp, #17]
 80022a0:	f88d 3012 	strb.w	r3, [sp, #18]
 80022a4:	ed8d 8a05 	vstr	s16, [sp, #20]
 80022a8:	ed8d 8a06 	vstr	s16, [sp, #24]
 80022ac:	ed8d 8a07 	vstr	s16, [sp, #28]
 80022b0:	ed8d 8a18 	vstr	s16, [sp, #96]	; 0x60
 80022b4:	ed8d 8a19 	vstr	s16, [sp, #100]	; 0x64
 80022b8:	ed8d 8a1a 	vstr	s16, [sp, #104]	; 0x68
 80022bc:	ed8d 8a1b 	vstr	s16, [sp, #108]	; 0x6c
 80022c0:	ed8d 8a1c 	vstr	s16, [sp, #112]	; 0x70
 80022c4:	ed8d 8a1d 	vstr	s16, [sp, #116]	; 0x74
 80022c8:	ed8d 8a08 	vstr	s16, [sp, #32]
 80022cc:	ed8d 8a09 	vstr	s16, [sp, #36]	; 0x24
 80022d0:	f7ff feec 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 80022d4:	2800      	cmp	r0, #0
 80022d6:	f000 80bb 	beq.w	8002450 <bsec_ChannelHub_do+0x1d8>
 80022da:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 80022de:	ed93 7a00 	vldr	s14, [r3]
 80022e2:	eef8 7ae8 	vcvt.f32.s32	s15, s17
 80022e6:	eeb4 7a67 	vcmp.f32	s14, s15
 80022ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80022ee:	f000 83b4 	beq.w	8002a5a <bsec_ChannelHub_do+0x7e2>
 80022f2:	2103      	movs	r1, #3
 80022f4:	4620      	mov	r0, r4
 80022f6:	4dc7      	ldr	r5, [pc, #796]	; (8002614 <bsec_ChannelHub_do+0x39c>)
 80022f8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 80022fc:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
 8002300:	f7ff fed4 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 8002304:	2800      	cmp	r0, #0
 8002306:	f040 80af 	bne.w	8002468 <bsec_ChannelHub_do+0x1f0>
 800230a:	2101      	movs	r1, #1
 800230c:	4620      	mov	r0, r4
 800230e:	f7ff fecd 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 8002312:	b158      	cbz	r0, 800232c <bsec_ChannelHub_do+0xb4>
 8002314:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 8002318:	ed93 7a00 	vldr	s14, [r3]
 800231c:	eef8 7ae8 	vcvt.f32.s32	s15, s17
 8002320:	eeb4 7a67 	vcmp.f32	s14, s15
 8002324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002328:	f000 8222 	beq.w	8002770 <bsec_ChannelHub_do+0x4f8>
 800232c:	2102      	movs	r1, #2
 800232e:	4620      	mov	r0, r4
 8002330:	f7ff febc 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 8002334:	b158      	cbz	r0, 800234e <bsec_ChannelHub_do+0xd6>
 8002336:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 800233a:	ed93 7a00 	vldr	s14, [r3]
 800233e:	eef8 7ae8 	vcvt.f32.s32	s15, s17
 8002342:	eeb4 7a67 	vcmp.f32	s14, s15
 8002346:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800234a:	f000 825c 	beq.w	8002806 <bsec_ChannelHub_do+0x58e>
 800234e:	2109      	movs	r1, #9
 8002350:	4620      	mov	r0, r4
 8002352:	f7ff feab 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 8002356:	b158      	cbz	r0, 8002370 <bsec_ChannelHub_do+0xf8>
 8002358:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 800235c:	ed93 7a00 	vldr	s14, [r3]
 8002360:	eef8 7ae8 	vcvt.f32.s32	s15, s17
 8002364:	eeb4 7a67 	vcmp.f32	s14, s15
 8002368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800236c:	f000 8306 	beq.w	800297c <bsec_ChannelHub_do+0x704>
 8002370:	ed9f 8aa7 	vldr	s16, [pc, #668]	; 8002610 <bsec_ChannelHub_do+0x398>
 8002374:	210a      	movs	r1, #10
 8002376:	4620      	mov	r0, r4
 8002378:	f7ff fe98 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 800237c:	b158      	cbz	r0, 8002396 <bsec_ChannelHub_do+0x11e>
 800237e:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 8002382:	eef8 8ae8 	vcvt.f32.s32	s17, s17
 8002386:	edd3 7a00 	vldr	s15, [r3]
 800238a:	eef4 7a68 	vcmp.f32	s15, s17
 800238e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002392:	f000 832c 	beq.w	80029ee <bsec_ChannelHub_do+0x776>
 8002396:	210b      	movs	r1, #11
 8002398:	4620      	mov	r0, r4
 800239a:	f7ff fe87 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 800239e:	2800      	cmp	r0, #0
 80023a0:	f040 813c 	bne.w	800261c <bsec_ChannelHub_do+0x3a4>
 80023a4:	796b      	ldrb	r3, [r5, #5]
 80023a6:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 80023aa:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80023ae:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 80023b2:	4291      	cmp	r1, r2
 80023b4:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 80023b8:	d004      	beq.n	80023c4 <bsec_ChannelHub_do+0x14c>
 80023ba:	f8d4 2a3c 	ldr.w	r2, [r4, #2620]	; 0xa3c
 80023be:	0752      	lsls	r2, r2, #29
 80023c0:	f100 8101 	bmi.w	80025c6 <bsec_ChannelHub_do+0x34e>
 80023c4:	79ab      	ldrb	r3, [r5, #6]
 80023c6:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 80023ca:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80023ce:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 80023d2:	4291      	cmp	r1, r2
 80023d4:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 80023d8:	d004      	beq.n	80023e4 <bsec_ChannelHub_do+0x16c>
 80023da:	f8d4 2a3c 	ldr.w	r2, [r4, #2620]	; 0xa3c
 80023de:	07d7      	lsls	r7, r2, #31
 80023e0:	f100 80cd 	bmi.w	800257e <bsec_ChannelHub_do+0x306>
 80023e4:	79eb      	ldrb	r3, [r5, #7]
 80023e6:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 80023ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80023ee:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 80023f2:	4291      	cmp	r1, r2
 80023f4:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 80023f8:	d004      	beq.n	8002404 <bsec_ChannelHub_do+0x18c>
 80023fa:	f8d4 2a3c 	ldr.w	r2, [r4, #2620]	; 0xa3c
 80023fe:	0790      	lsls	r0, r2, #30
 8002400:	f100 8099 	bmi.w	8002536 <bsec_ChannelHub_do+0x2be>
 8002404:	7a2b      	ldrb	r3, [r5, #8]
 8002406:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 800240a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800240e:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 8002412:	4291      	cmp	r1, r2
 8002414:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 8002418:	d003      	beq.n	8002422 <bsec_ChannelHub_do+0x1aa>
 800241a:	f8d4 2a3c 	ldr.w	r2, [r4, #2620]	; 0xa3c
 800241e:	0711      	lsls	r1, r2, #28
 8002420:	d465      	bmi.n	80024ee <bsec_ChannelHub_do+0x276>
 8002422:	7e6b      	ldrb	r3, [r5, #25]
 8002424:	eb04 0143 	add.w	r1, r4, r3, lsl #1
 8002428:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800242c:	f8b1 1a78 	ldrh.w	r1, [r1, #2680]	; 0xa78
 8002430:	4291      	cmp	r1, r2
 8002432:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
 8002436:	d003      	beq.n	8002440 <bsec_ChannelHub_do+0x1c8>
 8002438:	f8d4 2a3c 	ldr.w	r2, [r4, #2620]	; 0xa3c
 800243c:	0212      	lsls	r2, r2, #8
 800243e:	d432      	bmi.n	80024a6 <bsec_ChannelHub_do+0x22e>
 8002440:	2300      	movs	r3, #0
 8002442:	f8c4 3a3c 	str.w	r3, [r4, #2620]	; 0xa3c
 8002446:	b01e      	add	sp, #120	; 0x78
 8002448:	ecbd 8b02 	vpop	{d8}
 800244c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002450:	4d70      	ldr	r5, [pc, #448]	; (8002614 <bsec_ChannelHub_do+0x39c>)
 8002452:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8002456:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
 800245a:	2103      	movs	r1, #3
 800245c:	4620      	mov	r0, r4
 800245e:	f7ff fe25 	bl	80020ac <bsec_ChannelHub_isChannelReady.part.0>
 8002462:	2800      	cmp	r0, #0
 8002464:	f43f af51 	beq.w	800230a <bsec_ChannelHub_do+0x92>
 8002468:	f604 13ec 	addw	r3, r4, #2540	; 0x9ec
 800246c:	ed93 7a00 	vldr	s14, [r3]
 8002470:	eef8 7ae8 	vcvt.f32.s32	s15, s17
 8002474:	eeb4 7a67 	vcmp.f32	s14, s15
 8002478:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800247c:	f47f af45 	bne.w	800230a <bsec_ChannelHub_do+0x92>
 8002480:	f604 11d4 	addw	r1, r4, #2516	; 0x9d4
 8002484:	f604 12d8 	addw	r2, r4, #2520	; 0x9d8
 8002488:	f604 13dc 	addw	r3, r4, #2524	; 0x9dc
 800248c:	ed91 1a00 	vldr	s2, [r1]
 8002490:	edd2 0a00 	vldr	s1, [r2]
 8002494:	ed93 0a00 	vldr	s0, [r3]
 8002498:	aa06      	add	r2, sp, #24
 800249a:	ab07      	add	r3, sp, #28
 800249c:	a905      	add	r1, sp, #20
 800249e:	4620      	mov	r0, r4
 80024a0:	f003 fa00 	bl	80058a4 <bsec_GasHumidityPreProcessor_doStep>
 80024a4:	e731      	b.n	800230a <bsec_ChannelHub_do+0x92>
 80024a6:	f504 6213 	add.w	r2, r4, #2352	; 0x930
 80024aa:	e9d2 0100 	ldrd	r0, r1, [r2]
 80024ae:	f604 12ec 	addw	r2, r4, #2540	; 0x9ec
 80024b2:	ed9f 0a57 	vldr	s0, [pc, #348]	; 8002610 <bsec_ChannelHub_do+0x398>
 80024b6:	6816      	ldr	r6, [r2, #0]
 80024b8:	f203 227b 	addw	r2, r3, #635	; 0x27b
 80024bc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80024c0:	f503 7393 	add.w	r3, r3, #294	; 0x126
 80024c4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80024c8:	6016      	str	r6, [r2, #0]
 80024ca:	e9c3 0100 	strd	r0, r1, [r3]
 80024ce:	f027 f8c9 	bl	8029664 <roundf>
 80024d2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80024d6:	4425      	add	r5, r4
 80024d8:	ee17 3a90 	vmov	r3, s15
 80024dc:	f885 3a40 	strb.w	r3, [r5, #2624]	; 0xa40
 80024e0:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80024e4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80024e8:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 80024ec:	e7a8      	b.n	8002440 <bsec_ChannelHub_do+0x1c8>
 80024ee:	f504 6211 	add.w	r2, r4, #2320	; 0x910
 80024f2:	e9d2 0100 	ldrd	r0, r1, [r2]
 80024f6:	f604 12dc 	addw	r2, r4, #2524	; 0x9dc
 80024fa:	ed9f 0a45 	vldr	s0, [pc, #276]	; 8002610 <bsec_ChannelHub_do+0x398>
 80024fe:	6817      	ldr	r7, [r2, #0]
 8002500:	f203 227b 	addw	r2, r3, #635	; 0x27b
 8002504:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002508:	f503 7393 	add.w	r3, r3, #294	; 0x126
 800250c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8002510:	6017      	str	r7, [r2, #0]
 8002512:	e9c3 0100 	strd	r0, r1, [r3]
 8002516:	f027 f8a5 	bl	8029664 <roundf>
 800251a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800251e:	4426      	add	r6, r4
 8002520:	ee17 3a90 	vmov	r3, s15
 8002524:	f886 3a40 	strb.w	r3, [r6, #2624]	; 0xa40
 8002528:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 800252c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002530:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 8002534:	e775      	b.n	8002422 <bsec_ChannelHub_do+0x1aa>
 8002536:	f504 6210 	add.w	r2, r4, #2304	; 0x900
 800253a:	e9d2 0100 	ldrd	r0, r1, [r2]
 800253e:	f604 12d4 	addw	r2, r4, #2516	; 0x9d4
 8002542:	ed9f 0a33 	vldr	s0, [pc, #204]	; 8002610 <bsec_ChannelHub_do+0x398>
 8002546:	6817      	ldr	r7, [r2, #0]
 8002548:	f203 227b 	addw	r2, r3, #635	; 0x27b
 800254c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002550:	f503 7393 	add.w	r3, r3, #294	; 0x126
 8002554:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8002558:	6017      	str	r7, [r2, #0]
 800255a:	e9c3 0100 	strd	r0, r1, [r3]
 800255e:	f027 f881 	bl	8029664 <roundf>
 8002562:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002566:	4426      	add	r6, r4
 8002568:	ee17 3a90 	vmov	r3, s15
 800256c:	f886 3a40 	strb.w	r3, [r6, #2624]	; 0xa40
 8002570:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002574:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002578:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 800257c:	e742      	b.n	8002404 <bsec_ChannelHub_do+0x18c>
 800257e:	f604 02f8 	addw	r2, r4, #2296	; 0x8f8
 8002582:	e9d2 0100 	ldrd	r0, r1, [r2]
 8002586:	f504 621d 	add.w	r2, r4, #2512	; 0x9d0
 800258a:	ed9f 0a21 	vldr	s0, [pc, #132]	; 8002610 <bsec_ChannelHub_do+0x398>
 800258e:	6817      	ldr	r7, [r2, #0]
 8002590:	f203 227b 	addw	r2, r3, #635	; 0x27b
 8002594:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002598:	f503 7393 	add.w	r3, r3, #294	; 0x126
 800259c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80025a0:	6017      	str	r7, [r2, #0]
 80025a2:	e9c3 0100 	strd	r0, r1, [r3]
 80025a6:	f027 f85d 	bl	8029664 <roundf>
 80025aa:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80025ae:	4426      	add	r6, r4
 80025b0:	ee17 3a90 	vmov	r3, s15
 80025b4:	f886 3a40 	strb.w	r3, [r6, #2624]	; 0xa40
 80025b8:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80025bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80025c0:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 80025c4:	e70e      	b.n	80023e4 <bsec_ChannelHub_do+0x16c>
 80025c6:	f604 1208 	addw	r2, r4, #2312	; 0x908
 80025ca:	e9d2 0100 	ldrd	r0, r1, [r2]
 80025ce:	f604 12d8 	addw	r2, r4, #2520	; 0x9d8
 80025d2:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8002610 <bsec_ChannelHub_do+0x398>
 80025d6:	6817      	ldr	r7, [r2, #0]
 80025d8:	f203 227b 	addw	r2, r3, #635	; 0x27b
 80025dc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80025e0:	f503 7393 	add.w	r3, r3, #294	; 0x126
 80025e4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80025e8:	6017      	str	r7, [r2, #0]
 80025ea:	e9c3 0100 	strd	r0, r1, [r3]
 80025ee:	f027 f839 	bl	8029664 <roundf>
 80025f2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80025f6:	4426      	add	r6, r4
 80025f8:	ee17 3a90 	vmov	r3, s15
 80025fc:	f886 3a40 	strb.w	r3, [r6, #2624]	; 0xa40
 8002600:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002604:	f043 0320 	orr.w	r3, r3, #32
 8002608:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 800260c:	e6da      	b.n	80023c4 <bsec_ChannelHub_do+0x14c>
 800260e:	bf00      	nop
 8002610:	00000000 	.word	0x00000000
 8002614:	0802d6bc 	.word	0x0802d6bc
 8002618:	00000000 	.word	0x00000000
 800261c:	f604 11d4 	addw	r1, r4, #2516	; 0x9d4
 8002620:	edd1 1a00 	vldr	s3, [r1]
 8002624:	f504 601d 	add.w	r0, r4, #2512	; 0x9d0
 8002628:	f604 12d8 	addw	r2, r4, #2520	; 0x9d8
 800262c:	f604 18ec 	addw	r8, r4, #2540	; 0x9ec
 8002630:	f604 13dc 	addw	r3, r4, #2524	; 0x9dc
 8002634:	4651      	mov	r1, sl
 8002636:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 800263a:	ed90 2a00 	vldr	s4, [r0]
 800263e:	ed92 1a00 	vldr	s2, [r2]
 8002642:	ed93 0a00 	vldr	s0, [r3]
 8002646:	edd8 0a00 	vldr	s1, [r8]
 800264a:	f504 6611 	add.w	r6, r4, #2320	; 0x910
 800264e:	f10d 0313 	add.w	r3, sp, #19
 8002652:	aa14      	add	r2, sp, #80	; 0x50
 8002654:	f504 7004 	add.w	r0, r4, #528	; 0x210
 8002658:	fa5f fa8a 	uxtb.w	sl, sl
 800265c:	e9d6 6700 	ldrd	r6, r7, [r6]
 8002660:	f001 fdbe 	bl	80041e0 <bsec_GasEstimator_doStep>
 8002664:	ee07 aa90 	vmov	s15, sl
 8002668:	ed98 7a00 	vldr	s14, [r8]
 800266c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002670:	eeb4 7a67 	vcmp.f32	s14, s15
 8002674:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002678:	f47f ae94 	bne.w	80023a4 <bsec_ChannelHub_do+0x12c>
 800267c:	f8b4 2a96 	ldrh.w	r2, [r4, #2710]	; 0xa96
 8002680:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002684:	429a      	cmp	r2, r3
 8002686:	d017      	beq.n	80026b8 <bsec_ChannelHub_do+0x440>
 8002688:	7d6b      	ldrb	r3, [r5, #21]
 800268a:	9814      	ldr	r0, [sp, #80]	; 0x50
 800268c:	f89d 1013 	ldrb.w	r1, [sp, #19]
 8002690:	f203 227b 	addw	r2, r3, #635	; 0x27b
 8002694:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002698:	6010      	str	r0, [r2, #0]
 800269a:	f503 7293 	add.w	r2, r3, #294	; 0x126
 800269e:	4423      	add	r3, r4
 80026a0:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80026a4:	e9c2 6700 	strd	r6, r7, [r2]
 80026a8:	f883 1a3f 	strb.w	r1, [r3, #2623]	; 0xa3f
 80026ac:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80026b0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80026b4:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 80026b8:	f8b4 2a98 	ldrh.w	r2, [r4, #2712]	; 0xa98
 80026bc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026c0:	429a      	cmp	r2, r3
 80026c2:	d017      	beq.n	80026f4 <bsec_ChannelHub_do+0x47c>
 80026c4:	7dab      	ldrb	r3, [r5, #22]
 80026c6:	9815      	ldr	r0, [sp, #84]	; 0x54
 80026c8:	f89d 1013 	ldrb.w	r1, [sp, #19]
 80026cc:	f203 227b 	addw	r2, r3, #635	; 0x27b
 80026d0:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80026d4:	6010      	str	r0, [r2, #0]
 80026d6:	f503 7293 	add.w	r2, r3, #294	; 0x126
 80026da:	4423      	add	r3, r4
 80026dc:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80026e0:	e9c2 6700 	strd	r6, r7, [r2]
 80026e4:	f883 1a3f 	strb.w	r1, [r3, #2623]	; 0xa3f
 80026e8:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80026ec:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80026f0:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 80026f4:	f8b4 2a9a 	ldrh.w	r2, [r4, #2714]	; 0xa9a
 80026f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026fc:	429a      	cmp	r2, r3
 80026fe:	d017      	beq.n	8002730 <bsec_ChannelHub_do+0x4b8>
 8002700:	7deb      	ldrb	r3, [r5, #23]
 8002702:	9816      	ldr	r0, [sp, #88]	; 0x58
 8002704:	f89d 1013 	ldrb.w	r1, [sp, #19]
 8002708:	f203 227b 	addw	r2, r3, #635	; 0x27b
 800270c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002710:	6010      	str	r0, [r2, #0]
 8002712:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002716:	4423      	add	r3, r4
 8002718:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 800271c:	e9c2 6700 	strd	r6, r7, [r2]
 8002720:	f883 1a3f 	strb.w	r1, [r3, #2623]	; 0xa3f
 8002724:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002728:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800272c:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 8002730:	f8b4 2a9c 	ldrh.w	r2, [r4, #2716]	; 0xa9c
 8002734:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002738:	429a      	cmp	r2, r3
 800273a:	f43f ae33 	beq.w	80023a4 <bsec_ChannelHub_do+0x12c>
 800273e:	7e2b      	ldrb	r3, [r5, #24]
 8002740:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8002742:	f89d 1013 	ldrb.w	r1, [sp, #19]
 8002746:	f203 227b 	addw	r2, r3, #635	; 0x27b
 800274a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800274e:	6010      	str	r0, [r2, #0]
 8002750:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002754:	4423      	add	r3, r4
 8002756:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 800275a:	e9c2 6700 	strd	r6, r7, [r2]
 800275e:	f883 1a3f 	strb.w	r1, [r3, #2623]	; 0xa3f
 8002762:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002766:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800276a:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 800276e:	e619      	b.n	80023a4 <bsec_ChannelHub_do+0x12c>
 8002770:	f604 13e4 	addw	r3, r4, #2532	; 0x9e4
 8002774:	edd3 7a00 	vldr	s15, [r3]
 8002778:	f89d 2011 	ldrb.w	r2, [sp, #17]
 800277c:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8002780:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8002784:	ed9d 1a07 	vldr	s2, [sp, #28]
 8002788:	eddd 0a06 	vldr	s1, [sp, #24]
 800278c:	ed9d 0a05 	vldr	s0, [sp, #20]
 8002790:	eef5 7a40 	vcmp.f32	s15, #0.0
 8002794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002798:	bf14      	ite	ne
 800279a:	f04f 0c01 	movne.w	ip, #1
 800279e:	f04f 0c00 	moveq.w	ip, #0
 80027a2:	f8cd c000 	str.w	ip, [sp]
 80027a6:	f604 10e8 	addw	r0, r4, #2536	; 0x9e8
 80027aa:	edd0 1a00 	vldr	s3, [r0]
 80027ae:	f10d 0c20 	add.w	ip, sp, #32
 80027b2:	a818      	add	r0, sp, #96	; 0x60
 80027b4:	f8cd c008 	str.w	ip, [sp, #8]
 80027b8:	9001      	str	r0, [sp, #4]
 80027ba:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80027be:	f002 fb29 	bl	8004e14 <bsec_GasHumidityBaselineTracker_doStep>
 80027c2:	7c6b      	ldrb	r3, [r5, #17]
 80027c4:	9808      	ldr	r0, [sp, #32]
 80027c6:	ed1f 0a6c 	vldr	s0, [pc, #-432]	; 8002618 <bsec_ChannelHub_do+0x3a0>
 80027ca:	f203 217b 	addw	r1, r3, #635	; 0x27b
 80027ce:	f503 7293 	add.w	r2, r3, #294	; 0x126
 80027d2:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80027d6:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80027da:	6008      	str	r0, [r1, #0]
 80027dc:	e9c2 6700 	strd	r6, r7, [r2]
 80027e0:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 80027e4:	f026 ff3e 	bl	8029664 <roundf>
 80027e8:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80027ec:	eb04 0308 	add.w	r3, r4, r8
 80027f0:	ee17 2a90 	vmov	r2, s15
 80027f4:	f883 2a40 	strb.w	r2, [r3, #2624]	; 0xa40
 80027f8:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80027fc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002800:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 8002804:	e592      	b.n	800232c <bsec_ChannelHub_do+0xb4>
 8002806:	a912      	add	r1, sp, #72	; 0x48
 8002808:	aa10      	add	r2, sp, #64	; 0x40
 800280a:	ab0e      	add	r3, sp, #56	; 0x38
 800280c:	eddd 0a09 	vldr	s1, [sp, #36]	; 0x24
 8002810:	ed9d 0a08 	vldr	s0, [sp, #32]
 8002814:	9300      	str	r3, [sp, #0]
 8002816:	e9cd 2101 	strd	r2, r1, [sp, #4]
 800281a:	ab0c      	add	r3, sp, #48	; 0x30
 800281c:	aa0a      	add	r2, sp, #40	; 0x28
 800281e:	a918      	add	r1, sp, #96	; 0x60
 8002820:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8002824:	f003 fab4 	bl	8005d90 <bsec_IaqEstimator_doStep>
 8002828:	782b      	ldrb	r3, [r5, #0]
 800282a:	980a      	ldr	r0, [sp, #40]	; 0x28
 800282c:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
 8002830:	f203 217b 	addw	r1, r3, #635	; 0x27b
 8002834:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002838:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 800283c:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002840:	6008      	str	r0, [r1, #0]
 8002842:	e9c2 6700 	strd	r6, r7, [r2]
 8002846:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800284a:	f026 ff0b 	bl	8029664 <roundf>
 800284e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002852:	44a0      	add	r8, r4
 8002854:	ee17 2a90 	vmov	r2, s15
 8002858:	786b      	ldrb	r3, [r5, #1]
 800285a:	f888 2a40 	strb.w	r2, [r8, #2624]	; 0xa40
 800285e:	f8d4 0a54 	ldr.w	r0, [r4, #2644]	; 0xa54
 8002862:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8002866:	ed9d 0a0d 	vldr	s0, [sp, #52]	; 0x34
 800286a:	f203 217b 	addw	r1, r3, #635	; 0x27b
 800286e:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002872:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8002876:	f040 0001 	orr.w	r0, r0, #1
 800287a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 800287e:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 8002882:	f8c1 c000 	str.w	ip, [r1]
 8002886:	e9c2 6700 	strd	r6, r7, [r2]
 800288a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800288e:	f026 fee9 	bl	8029664 <roundf>
 8002892:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002896:	44a0      	add	r8, r4
 8002898:	ee17 2a90 	vmov	r2, s15
 800289c:	78ab      	ldrb	r3, [r5, #2]
 800289e:	f888 2a40 	strb.w	r2, [r8, #2624]	; 0xa40
 80028a2:	f8d4 0a54 	ldr.w	r0, [r4, #2644]	; 0xa54
 80028a6:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
 80028aa:	ed9d 0a0f 	vldr	s0, [sp, #60]	; 0x3c
 80028ae:	f203 217b 	addw	r1, r3, #635	; 0x27b
 80028b2:	f503 7293 	add.w	r2, r3, #294	; 0x126
 80028b6:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80028ba:	f040 0002 	orr.w	r0, r0, #2
 80028be:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80028c2:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 80028c6:	f8c1 c000 	str.w	ip, [r1]
 80028ca:	e9c2 6700 	strd	r6, r7, [r2]
 80028ce:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 80028d2:	f026 fec7 	bl	8029664 <roundf>
 80028d6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80028da:	44a0      	add	r8, r4
 80028dc:	ee17 2a90 	vmov	r2, s15
 80028e0:	78eb      	ldrb	r3, [r5, #3]
 80028e2:	f888 2a40 	strb.w	r2, [r8, #2624]	; 0xa40
 80028e6:	f8d4 0a54 	ldr.w	r0, [r4, #2644]	; 0xa54
 80028ea:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
 80028ee:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
 80028f2:	f203 217b 	addw	r1, r3, #635	; 0x27b
 80028f6:	f503 7293 	add.w	r2, r3, #294	; 0x126
 80028fa:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80028fe:	f040 0004 	orr.w	r0, r0, #4
 8002902:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002906:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 800290a:	f8c1 c000 	str.w	ip, [r1]
 800290e:	e9c2 6700 	strd	r6, r7, [r2]
 8002912:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8002916:	f026 fea5 	bl	8029664 <roundf>
 800291a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800291e:	44a0      	add	r8, r4
 8002920:	ee17 2a90 	vmov	r2, s15
 8002924:	7d2b      	ldrb	r3, [r5, #20]
 8002926:	f888 2a40 	strb.w	r2, [r8, #2624]	; 0xa40
 800292a:	f8d4 0a54 	ldr.w	r0, [r4, #2644]	; 0xa54
 800292e:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
 8002932:	ed9d 0a13 	vldr	s0, [sp, #76]	; 0x4c
 8002936:	f203 217b 	addw	r1, r3, #635	; 0x27b
 800293a:	f503 7293 	add.w	r2, r3, #294	; 0x126
 800293e:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8002942:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002946:	f040 0008 	orr.w	r0, r0, #8
 800294a:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 800294e:	f8c1 c000 	str.w	ip, [r1]
 8002952:	e9c2 6700 	strd	r6, r7, [r2]
 8002956:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800295a:	f026 fe83 	bl	8029664 <roundf>
 800295e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002962:	eb04 0308 	add.w	r3, r4, r8
 8002966:	ee17 2a90 	vmov	r2, s15
 800296a:	f883 2a40 	strb.w	r2, [r3, #2624]	; 0xa40
 800296e:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002972:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002976:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 800297a:	e4e8      	b.n	800234e <bsec_ChannelHub_do+0xd6>
 800297c:	f604 1308 	addw	r3, r4, #2312	; 0x908
 8002980:	e9d3 8900 	ldrd	r8, r9, [r3]
 8002984:	e9cd 8900 	strd	r8, r9, [sp]
 8002988:	f504 601e 	add.w	r0, r4, #2528	; 0x9e0
 800298c:	edd0 0a00 	vldr	s1, [r0]
 8002990:	f8b4 006a 	ldrh.w	r0, [r4, #106]	; 0x6a
 8002994:	f604 11d8 	addw	r1, r4, #2520	; 0x9d8
 8002998:	ed91 0a00 	vldr	s0, [r1]
 800299c:	9002      	str	r0, [sp, #8]
 800299e:	4632      	mov	r2, r6
 80029a0:	463b      	mov	r3, r7
 80029a2:	f504 70ac 	add.w	r0, r4, #344	; 0x158
 80029a6:	f003 fced 	bl	8006384 <bsec_SensorHeatCompensator_doStep>
 80029aa:	7b6b      	ldrb	r3, [r5, #13]
 80029ac:	f203 217b 	addw	r1, r3, #635	; 0x27b
 80029b0:	f503 7293 	add.w	r2, r3, #294	; 0x126
 80029b4:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80029b8:	eeb0 8a40 	vmov.f32	s16, s0
 80029bc:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80029c0:	ed81 8a00 	vstr	s16, [r1]
 80029c4:	ed9f 0a56 	vldr	s0, [pc, #344]	; 8002b20 <bsec_ChannelHub_do+0x8a8>
 80029c8:	e9c2 8900 	strd	r8, r9, [r2]
 80029cc:	1e5e      	subs	r6, r3, #1
 80029ce:	f026 fe49 	bl	8029664 <roundf>
 80029d2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80029d6:	19a3      	adds	r3, r4, r6
 80029d8:	ee17 2a90 	vmov	r2, s15
 80029dc:	f883 2a40 	strb.w	r2, [r3, #2624]	; 0xa40
 80029e0:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 80029e4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80029e8:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 80029ec:	e4c2      	b.n	8002374 <bsec_ChannelHub_do+0xfc>
 80029ee:	f604 12d4 	addw	r2, r4, #2516	; 0x9d4
 80029f2:	f604 13d8 	addw	r3, r4, #2520	; 0x9d8
 80029f6:	ed92 1a00 	vldr	s2, [r2]
 80029fa:	ed93 0a00 	vldr	s0, [r3]
 80029fe:	eef0 0a48 	vmov.f32	s1, s16
 8002a02:	f604 1308 	addw	r3, r4, #2312	; 0x908
 8002a06:	f504 70fc 	add.w	r0, r4, #504	; 0x1f8
 8002a0a:	e9d3 6700 	ldrd	r6, r7, [r3]
 8002a0e:	f003 f88f 	bl	8005b30 <bsec_HumidityTemperatureCorrector_doStep>
 8002a12:	7bab      	ldrb	r3, [r5, #14]
 8002a14:	f203 217b 	addw	r1, r3, #635	; 0x27b
 8002a18:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002a1c:	eef0 7a40 	vmov.f32	s15, s0
 8002a20:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002a24:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8002a28:	edc1 7a00 	vstr	s15, [r1]
 8002a2c:	ed9f 0a3c 	vldr	s0, [pc, #240]	; 8002b20 <bsec_ChannelHub_do+0x8a8>
 8002a30:	edcd 7a05 	vstr	s15, [sp, #20]
 8002a34:	e9c2 6700 	strd	r6, r7, [r2]
 8002a38:	1e5e      	subs	r6, r3, #1
 8002a3a:	f026 fe13 	bl	8029664 <roundf>
 8002a3e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002a42:	19a3      	adds	r3, r4, r6
 8002a44:	ee17 2a90 	vmov	r2, s15
 8002a48:	f883 2a40 	strb.w	r2, [r3, #2624]	; 0xa40
 8002a4c:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002a50:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002a54:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 8002a58:	e49d      	b.n	8002396 <bsec_ChannelHub_do+0x11e>
 8002a5a:	f504 6311 	add.w	r3, r4, #2320	; 0x910
 8002a5e:	e9d3 6700 	ldrd	r6, r7, [r3]
 8002a62:	f10d 0112 	add.w	r1, sp, #18
 8002a66:	ad09      	add	r5, sp, #36	; 0x24
 8002a68:	f10d 0011 	add.w	r0, sp, #17
 8002a6c:	9103      	str	r1, [sp, #12]
 8002a6e:	a904      	add	r1, sp, #16
 8002a70:	e9cd 1000 	strd	r1, r0, [sp]
 8002a74:	4632      	mov	r2, r6
 8002a76:	f504 70e0 	add.w	r0, r4, #448	; 0x1c0
 8002a7a:	463b      	mov	r3, r7
 8002a7c:	9502      	str	r5, [sp, #8]
 8002a7e:	f003 fdff 	bl	8006680 <bsec_SensorStatusTracker_doStep>
 8002a82:	4d28      	ldr	r5, [pc, #160]	; (8002b24 <bsec_ChannelHub_do+0x8ac>)
 8002a84:	f89d 2010 	ldrb.w	r2, [sp, #16]
 8002a88:	7aeb      	ldrb	r3, [r5, #11]
 8002a8a:	ee07 2a90 	vmov	s15, r2
 8002a8e:	f203 217b 	addw	r1, r3, #635	; 0x27b
 8002a92:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002a96:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002a9a:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8002a9e:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002aa2:	edc1 7a00 	vstr	s15, [r1]
 8002aa6:	eeb0 0a48 	vmov.f32	s0, s16
 8002aaa:	e9c2 6700 	strd	r6, r7, [r2]
 8002aae:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8002ab2:	f026 fdd7 	bl	8029664 <roundf>
 8002ab6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002aba:	44a0      	add	r8, r4
 8002abc:	ee17 2a90 	vmov	r2, s15
 8002ac0:	f888 2a40 	strb.w	r2, [r8, #2624]	; 0xa40
 8002ac4:	f89d 2011 	ldrb.w	r2, [sp, #17]
 8002ac8:	7b2b      	ldrb	r3, [r5, #12]
 8002aca:	f8d4 0a54 	ldr.w	r0, [r4, #2644]	; 0xa54
 8002ace:	ee07 2a90 	vmov	s15, r2
 8002ad2:	f203 217b 	addw	r1, r3, #635	; 0x27b
 8002ad6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002ada:	f503 7293 	add.w	r2, r3, #294	; 0x126
 8002ade:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002ae2:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8002ae6:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8002aea:	f8c4 0a54 	str.w	r0, [r4, #2644]	; 0xa54
 8002aee:	eeb0 0a48 	vmov.f32	s0, s16
 8002af2:	edc1 7a00 	vstr	s15, [r1]
 8002af6:	e9c2 6700 	strd	r6, r7, [r2]
 8002afa:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8002afe:	f026 fdb1 	bl	8029664 <roundf>
 8002b02:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8002b06:	eb04 0308 	add.w	r3, r4, r8
 8002b0a:	ee17 2a90 	vmov	r2, s15
 8002b0e:	f883 2a40 	strb.w	r2, [r3, #2624]	; 0xa40
 8002b12:	f8d4 3a54 	ldr.w	r3, [r4, #2644]	; 0xa54
 8002b16:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002b1a:	f8c4 3a54 	str.w	r3, [r4, #2644]	; 0xa54
 8002b1e:	e49c      	b.n	800245a <bsec_ChannelHub_do+0x1e2>
 8002b20:	00000000 	.word	0x00000000
 8002b24:	0802d6bc 	.word	0x0802d6bc

08002b28 <bsec_ChannelHub_getChannelConfiguration>:
 8002b28:	b410      	push	{r4}
 8002b2a:	1e4c      	subs	r4, r1, #1
 8002b2c:	4611      	mov	r1, r2
 8002b2e:	461a      	mov	r2, r3
 8002b30:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8002b34:	2c0a      	cmp	r4, #10
 8002b36:	d807      	bhi.n	8002b48 <bsec_ChannelHub_getChannelConfiguration+0x20>
 8002b38:	e8df f004 	tbb	[pc, r4]
 8002b3c:	06140f0a 	.word	0x06140f0a
 8002b40:	06060618 	.word	0x06060618
 8002b44:	241e      	.short	0x241e
 8002b46:	2a          	.byte	0x2a
 8002b47:	00          	.byte	0x00
 8002b48:	2000      	movs	r0, #0
 8002b4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b4e:	4770      	bx	lr
 8002b50:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b54:	3068      	adds	r0, #104	; 0x68
 8002b56:	f002 bc4d 	b.w	80053f4 <bsec_GasHumidityBaselineTracker_getConfiguration>
 8002b5a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b5e:	302c      	adds	r0, #44	; 0x2c
 8002b60:	f003 b9f6 	b.w	8005f50 <bsec_IaqEstimator_getConfiguration>
 8002b64:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b68:	f002 bef8 	b.w	800595c <bsec_GasHumidityPreProcessor_getConfiguration>
 8002b6c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b70:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 8002b74:	f003 be2e 	b.w	80067d4 <bsec_SensorStatusTracker_getConfiguration>
 8002b78:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b7c:	f500 70ac 	add.w	r0, r0, #344	; 0x158
 8002b80:	f003 bc8c 	b.w	800649c <bsec_SensorHeatCompensator_getConfiguration>
 8002b84:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b88:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8002b8c:	f003 b80c 	b.w	8005ba8 <bsec_HumidityTemperatureCorrector_getConfiguration>
 8002b90:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b94:	f500 7004 	add.w	r0, r0, #528	; 0x210
 8002b98:	f001 bd56 	b.w	8004648 <bsec_GasEstimator_getConfiguration>

08002b9c <bsec_ChannelHub_getChannelState>:
 8002b9c:	b410      	push	{r4}
 8002b9e:	1e4c      	subs	r4, r1, #1
 8002ba0:	4611      	mov	r1, r2
 8002ba2:	461a      	mov	r2, r3
 8002ba4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8002ba8:	2c0a      	cmp	r4, #10
 8002baa:	d807      	bhi.n	8002bbc <bsec_ChannelHub_getChannelState+0x20>
 8002bac:	e8df f004 	tbb	[pc, r4]
 8002bb0:	06140f0a 	.word	0x06140f0a
 8002bb4:	06060618 	.word	0x06060618
 8002bb8:	241e      	.short	0x241e
 8002bba:	2a          	.byte	0x2a
 8002bbb:	00          	.byte	0x00
 8002bbc:	2000      	movs	r0, #0
 8002bbe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bc2:	4770      	bx	lr
 8002bc4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bc8:	3068      	adds	r0, #104	; 0x68
 8002bca:	f002 bc85 	b.w	80054d8 <bsec_GasHumidityBaselineTracker_getState>
 8002bce:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bd2:	302c      	adds	r0, #44	; 0x2c
 8002bd4:	f003 ba32 	b.w	800603c <bsec_IaqEstimator_getState>
 8002bd8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bdc:	f002 bef0 	b.w	80059c0 <bsec_GasHumidityPreProcessor_getState>
 8002be0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002be4:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 8002be8:	f003 be42 	b.w	8006870 <bsec_SensorStatusTracker_getState>
 8002bec:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bf0:	f500 70ac 	add.w	r0, r0, #344	; 0x158
 8002bf4:	f003 bcb2 	b.w	800655c <bsec_SensorHeatCompensator_getState>
 8002bf8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002bfc:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8002c00:	f003 b804 	b.w	8005c0c <bsec_HumidityTemperatureCorrector_getState>
 8002c04:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002c08:	f500 7004 	add.w	r0, r0, #528	; 0x210
 8002c0c:	f001 bdd4 	b.w	80047b8 <bsec_GasEstimator_getState>

08002c10 <bsec_ChannelHub_getInput>:
 8002c10:	b470      	push	{r4, r5, r6}
 8002c12:	f600 15ec 	addw	r5, r0, #2540	; 0x9ec
 8002c16:	f500 6413 	add.w	r4, r0, #2352	; 0x930
 8002c1a:	682e      	ldr	r6, [r5, #0]
 8002c1c:	f8d0 0a3c 	ldr.w	r0, [r0, #2620]	; 0xa3c
 8002c20:	e9d4 4500 	ldrd	r4, r5, [r4]
 8002c24:	f3c0 50c0 	ubfx	r0, r0, #23, #1
 8002c28:	600e      	str	r6, [r1, #0]
 8002c2a:	e9c2 4500 	strd	r4, r5, [r2]
 8002c2e:	bc70      	pop	{r4, r5, r6}
 8002c30:	7018      	strb	r0, [r3, #0]
 8002c32:	4770      	bx	lr

08002c34 <bsec_ChannelHub_getOutput>:
 8002c34:	b4f0      	push	{r4, r5, r6, r7}
 8002c36:	3901      	subs	r1, #1
 8002c38:	4c10      	ldr	r4, [pc, #64]	; (8002c7c <bsec_ChannelHub_getOutput+0x48>)
 8002c3a:	9d04      	ldr	r5, [sp, #16]
 8002c3c:	5c64      	ldrb	r4, [r4, r1]
 8002c3e:	f204 277b 	addw	r7, r4, #635	; 0x27b
 8002c42:	f504 7693 	add.w	r6, r4, #294	; 0x126
 8002c46:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 8002c4a:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
 8002c4e:	f8d7 c000 	ldr.w	ip, [r7]
 8002c52:	f8c2 c000 	str.w	ip, [r2]
 8002c56:	e9d6 6700 	ldrd	r6, r7, [r6]
 8002c5a:	e9c3 6700 	strd	r6, r7, [r3]
 8002c5e:	4404      	add	r4, r0
 8002c60:	2201      	movs	r2, #1
 8002c62:	f894 3a3f 	ldrb.w	r3, [r4, #2623]	; 0xa3f
 8002c66:	702b      	strb	r3, [r5, #0]
 8002c68:	f8d0 3a54 	ldr.w	r3, [r0, #2644]	; 0xa54
 8002c6c:	fa02 f101 	lsl.w	r1, r2, r1
 8002c70:	ea23 0301 	bic.w	r3, r3, r1
 8002c74:	bcf0      	pop	{r4, r5, r6, r7}
 8002c76:	f8c0 3a54 	str.w	r3, [r0, #2644]	; 0xa54
 8002c7a:	4770      	bx	lr
 8002c7c:	0802d6bc 	.word	0x0802d6bc

08002c80 <bsec_ChannelHub_recalculateDownsampling>:
 8002c80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002c84:	4684      	mov	ip, r0
 8002c86:	4e37      	ldr	r6, [pc, #220]	; (8002d64 <bsec_ChannelHub_recalculateDownsampling+0xe4>)
 8002c88:	4c37      	ldr	r4, [pc, #220]	; (8002d68 <bsec_ChannelHub_recalculateDownsampling+0xe8>)
 8002c8a:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 8002d74 <bsec_ChannelHub_recalculateDownsampling+0xf4>
 8002c8e:	b083      	sub	sp, #12
 8002c90:	2100      	movs	r1, #0
 8002c92:	f240 7717 	movw	r7, #1815	; 0x717
 8002c96:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8002c9a:	e004      	b.n	8002ca6 <bsec_ChannelHub_recalculateDownsampling+0x26>
 8002c9c:	3101      	adds	r1, #1
 8002c9e:	290b      	cmp	r1, #11
 8002ca0:	f106 0604 	add.w	r6, r6, #4
 8002ca4:	d05a      	beq.n	8002d5c <bsec_ChannelHub_recalculateDownsampling+0xdc>
 8002ca6:	fa47 f301 	asr.w	r3, r7, r1
 8002caa:	07db      	lsls	r3, r3, #31
 8002cac:	d5f6      	bpl.n	8002c9c <bsec_ChannelHub_recalculateDownsampling+0x1c>
 8002cae:	4b2f      	ldr	r3, [pc, #188]	; (8002d6c <bsec_ChannelHub_recalculateDownsampling+0xec>)
 8002cb0:	f813 8001 	ldrb.w	r8, [r3, r1]
 8002cb4:	eb0c 0848 	add.w	r8, ip, r8, lsl #1
 8002cb8:	f8b8 9a5a 	ldrh.w	r9, [r8, #2650]	; 0xa5a
 8002cbc:	45f1      	cmp	r9, lr
 8002cbe:	d0ed      	beq.n	8002c9c <bsec_ChannelHub_recalculateDownsampling+0x1c>
 8002cc0:	2300      	movs	r3, #0
 8002cc2:	461d      	mov	r5, r3
 8002cc4:	2001      	movs	r0, #1
 8002cc6:	9601      	str	r6, [sp, #4]
 8002cc8:	fa00 f203 	lsl.w	r2, r0, r3
 8002ccc:	423a      	tst	r2, r7
 8002cce:	d010      	beq.n	8002cf2 <bsec_ChannelHub_recalculateDownsampling+0x72>
 8002cd0:	4e27      	ldr	r6, [pc, #156]	; (8002d70 <bsec_ChannelHub_recalculateDownsampling+0xf0>)
 8002cd2:	f936 b011 	ldrsh.w	fp, [r6, r1, lsl #1]
 8002cd6:	ea1b 0f02 	tst.w	fp, r2
 8002cda:	d00a      	beq.n	8002cf2 <bsec_ChannelHub_recalculateDownsampling+0x72>
 8002cdc:	4a23      	ldr	r2, [pc, #140]	; (8002d6c <bsec_ChannelHub_recalculateDownsampling+0xec>)
 8002cde:	5cd2      	ldrb	r2, [r2, r3]
 8002ce0:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
 8002ce4:	f8b2 2a5a 	ldrh.w	r2, [r2, #2650]	; 0xa5a
 8002ce8:	4572      	cmp	r2, lr
 8002cea:	d002      	beq.n	8002cf2 <bsec_ChannelHub_recalculateDownsampling+0x72>
 8002cec:	4295      	cmp	r5, r2
 8002cee:	bf38      	it	cc
 8002cf0:	4615      	movcc	r5, r2
 8002cf2:	3301      	adds	r3, #1
 8002cf4:	2b0b      	cmp	r3, #11
 8002cf6:	d1e7      	bne.n	8002cc8 <bsec_ChannelHub_recalculateDownsampling+0x48>
 8002cf8:	9e01      	ldr	r6, [sp, #4]
 8002cfa:	2300      	movs	r3, #0
 8002cfc:	f04f 0b01 	mov.w	fp, #1
 8002d00:	fa0b f203 	lsl.w	r2, fp, r3
 8002d04:	4222      	tst	r2, r4
 8002d06:	d00d      	beq.n	8002d24 <bsec_ChannelHub_recalculateDownsampling+0xa4>
 8002d08:	6830      	ldr	r0, [r6, #0]
 8002d0a:	4202      	tst	r2, r0
 8002d0c:	d00a      	beq.n	8002d24 <bsec_ChannelHub_recalculateDownsampling+0xa4>
 8002d0e:	f813 200a 	ldrb.w	r2, [r3, sl]
 8002d12:	eb0c 0242 	add.w	r2, ip, r2, lsl #1
 8002d16:	f8b2 2a68 	ldrh.w	r2, [r2, #2664]	; 0xa68
 8002d1a:	4572      	cmp	r2, lr
 8002d1c:	d002      	beq.n	8002d24 <bsec_ChannelHub_recalculateDownsampling+0xa4>
 8002d1e:	4295      	cmp	r5, r2
 8002d20:	bf38      	it	cc
 8002d22:	4615      	movcc	r5, r2
 8002d24:	3301      	adds	r3, #1
 8002d26:	2b18      	cmp	r3, #24
 8002d28:	d1ea      	bne.n	8002d00 <bsec_ChannelHub_recalculateDownsampling+0x80>
 8002d2a:	2d00      	cmp	r5, #0
 8002d2c:	d0b6      	beq.n	8002c9c <bsec_ChannelHub_recalculateDownsampling+0x1c>
 8002d2e:	fbb9 f2f5 	udiv	r2, r9, r5
 8002d32:	fb05 9912 	mls	r9, r5, r2, r9
 8002d36:	fa1f f389 	uxth.w	r3, r9
 8002d3a:	b292      	uxth	r2, r2
 8002d3c:	b13b      	cbz	r3, 8002d4e <bsec_ChannelHub_recalculateDownsampling+0xce>
 8002d3e:	f005 0001 	and.w	r0, r5, #1
 8002d42:	eb00 0555 	add.w	r5, r0, r5, lsr #1
 8002d46:	42ab      	cmp	r3, r5
 8002d48:	bfa4      	itt	ge
 8002d4a:	3201      	addge	r2, #1
 8002d4c:	b292      	uxthge	r2, r2
 8002d4e:	3101      	adds	r1, #1
 8002d50:	290b      	cmp	r1, #11
 8002d52:	f8a8 2a9e 	strh.w	r2, [r8, #2718]	; 0xa9e
 8002d56:	f106 0604 	add.w	r6, r6, #4
 8002d5a:	d1a4      	bne.n	8002ca6 <bsec_ChannelHub_recalculateDownsampling+0x26>
 8002d5c:	b003      	add	sp, #12
 8002d5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002d62:	bf00      	nop
 8002d64:	0802d5e8 	.word	0x0802d5e8
 8002d68:	00e0200f 	.word	0x00e0200f
 8002d6c:	0802d614 	.word	0x0802d614
 8002d70:	0802d5d0 	.word	0x0802d5d0
 8002d74:	0802d6d8 	.word	0x0802d6d8

08002d78 <bsec_ChannelHub_resetSamplIntvls>:
 8002d78:	b430      	push	{r4, r5}
 8002d7a:	f600 235c 	addw	r3, r0, #2652	; 0xa5c
 8002d7e:	f600 256a 	addw	r5, r0, #2666	; 0xa6a
 8002d82:	2401      	movs	r4, #1
 8002d84:	2100      	movs	r1, #0
 8002d86:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002d8a:	f8a3 4044 	strh.w	r4, [r3, #68]	; 0x44
 8002d8e:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
 8002d92:	f823 2b02 	strh.w	r2, [r3], #2
 8002d96:	429d      	cmp	r5, r3
 8002d98:	d1f7      	bne.n	8002d8a <bsec_ChannelHub_resetSamplIntvls+0x12>
 8002d9a:	f8a0 2a6a 	strh.w	r2, [r0, #2666]	; 0xa6a
 8002d9e:	f8a0 2a6c 	strh.w	r2, [r0, #2668]	; 0xa6c
 8002da2:	f8a0 2a6e 	strh.w	r2, [r0, #2670]	; 0xa6e
 8002da6:	f8a0 2a70 	strh.w	r2, [r0, #2672]	; 0xa70
 8002daa:	f8a0 2a72 	strh.w	r2, [r0, #2674]	; 0xa72
 8002dae:	f8a0 2a74 	strh.w	r2, [r0, #2676]	; 0xa74
 8002db2:	f8a0 2a76 	strh.w	r2, [r0, #2678]	; 0xa76
 8002db6:	f8a0 2a78 	strh.w	r2, [r0, #2680]	; 0xa78
 8002dba:	f600 2378 	addw	r3, r0, #2680	; 0xa78
 8002dbe:	f600 229e 	addw	r2, r0, #2718	; 0xa9e
 8002dc2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8002dc6:	f823 1f02 	strh.w	r1, [r3, #2]!
 8002dca:	4293      	cmp	r3, r2
 8002dcc:	d1fb      	bne.n	8002dc6 <bsec_ChannelHub_resetSamplIntvls+0x4e>
 8002dce:	bc30      	pop	{r4, r5}
 8002dd0:	4770      	bx	lr
 8002dd2:	bf00      	nop

08002dd4 <bsec_ChannelHub_setChannelState>:
 8002dd4:	b410      	push	{r4}
 8002dd6:	1e4c      	subs	r4, r1, #1
 8002dd8:	4611      	mov	r1, r2
 8002dda:	461a      	mov	r2, r3
 8002ddc:	2c0a      	cmp	r4, #10
 8002dde:	d807      	bhi.n	8002df0 <bsec_ChannelHub_setChannelState+0x1c>
 8002de0:	e8df f004 	tbb	[pc, r4]
 8002de4:	0615100b 	.word	0x0615100b
 8002de8:	06060619 	.word	0x06060619
 8002dec:	251f      	.short	0x251f
 8002dee:	2b          	.byte	0x2b
 8002def:	00          	.byte	0x00
 8002df0:	f06f 0063 	mvn.w	r0, #99	; 0x63
 8002df4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002df8:	4770      	bx	lr
 8002dfa:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002dfe:	3068      	adds	r0, #104	; 0x68
 8002e00:	f002 bca4 	b.w	800574c <bsec_b_GasHumidityBaselineTracker_setState>
 8002e04:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e08:	302c      	adds	r0, #44	; 0x2c
 8002e0a:	f003 b95b 	b.w	80060c4 <bsec_IaqEstimator_setState>
 8002e0e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e12:	f002 be07 	b.w	8005a24 <bsec_GasHumidityPreProcessor_setState>
 8002e16:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e1a:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 8002e1e:	f003 bdd9 	b.w	80069d4 <bsec_b_SensorStatusTracker_setState>
 8002e22:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e26:	f500 70ac 	add.w	r0, r0, #344	; 0x158
 8002e2a:	f003 bbcb 	b.w	80065c4 <bsec_SensorHeatCompensator_setState>
 8002e2e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e32:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8002e36:	f002 bf1b 	b.w	8005c70 <bsec_HumidityTemperatureCorrector_setState>
 8002e3a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002e3e:	f500 7004 	add.w	r0, r0, #528	; 0x210
 8002e42:	f001 bd21 	b.w	8004888 <bsec_GasEstimator_setState>
 8002e46:	bf00      	nop

08002e48 <bsec_ChannelHub_setInput>:
 8002e48:	e92d 0f70 	stmdb	sp!, {r4, r5, r6, r8, r9, sl, fp}
 8002e4c:	3901      	subs	r1, #1
 8002e4e:	4c15      	ldr	r4, [pc, #84]	; (8002ea4 <bsec_ChannelHub_setInput+0x5c>)
 8002e50:	f89d 601c 	ldrb.w	r6, [sp, #28]
 8002e54:	5c64      	ldrb	r4, [r4, r1]
 8002e56:	eb00 05c4 	add.w	r5, r0, r4, lsl #3
 8002e5a:	f505 650f 	add.w	r5, r5, #2288	; 0x8f0
 8002e5e:	e9d5 ab00 	ldrd	sl, fp, [r5]
 8002e62:	459b      	cmp	fp, r3
 8002e64:	bf08      	it	eq
 8002e66:	4592      	cmpeq	sl, r2
 8002e68:	4690      	mov	r8, r2
 8002e6a:	4699      	mov	r9, r3
 8002e6c:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8002e70:	d012      	beq.n	8002e98 <bsec_ChannelHub_setInput+0x50>
 8002e72:	f504 741d 	add.w	r4, r4, #628	; 0x274
 8002e76:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8002e7a:	ed84 0a00 	vstr	s0, [r4]
 8002e7e:	e9c5 8900 	strd	r8, r9, [r5]
 8002e82:	2201      	movs	r2, #1
 8002e84:	f8d0 3a3c 	ldr.w	r3, [r0, #2620]	; 0xa3c
 8002e88:	fa02 f101 	lsl.w	r1, r2, r1
 8002e8c:	430b      	orrs	r3, r1
 8002e8e:	e8bd 0f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp}
 8002e92:	f8c0 3a3c 	str.w	r3, [r0, #2620]	; 0xa3c
 8002e96:	4770      	bx	lr
 8002e98:	2e00      	cmp	r6, #0
 8002e9a:	d1ea      	bne.n	8002e72 <bsec_ChannelHub_setInput+0x2a>
 8002e9c:	e8bd 0f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp}
 8002ea0:	4770      	bx	lr
 8002ea2:	bf00      	nop
 8002ea4:	0802d6d8 	.word	0x0802d6d8

08002ea8 <bsec_ChannelHub_updateChannelInterfaceDependency>:
 8002ea8:	1e4b      	subs	r3, r1, #1
 8002eaa:	b2da      	uxtb	r2, r3
 8002eac:	2a0a      	cmp	r2, #10
 8002eae:	d900      	bls.n	8002eb2 <bsec_ChannelHub_updateChannelInterfaceDependency+0xa>
 8002eb0:	4770      	bx	lr
 8002eb2:	4a18      	ldr	r2, [pc, #96]	; (8002f14 <bsec_ChannelHub_updateChannelInterfaceDependency+0x6c>)
 8002eb4:	4411      	add	r1, r2
 8002eb6:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 8002eba:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8002ebe:	f8b2 1a5a 	ldrh.w	r1, [r2, #2650]	; 0xa5a
 8002ec2:	2b09      	cmp	r3, #9
 8002ec4:	d8f4      	bhi.n	8002eb0 <bsec_ChannelHub_updateChannelInterfaceDependency+0x8>
 8002ec6:	a201      	add	r2, pc, #4	; (adr r2, 8002ecc <bsec_ChannelHub_updateChannelInterfaceDependency+0x24>)
 8002ec8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002ecc:	08002efd 	.word	0x08002efd
 8002ed0:	08002f03 	.word	0x08002f03
 8002ed4:	08002f09 	.word	0x08002f09
 8002ed8:	08002eb1 	.word	0x08002eb1
 8002edc:	08002f0d 	.word	0x08002f0d
 8002ee0:	08002eb1 	.word	0x08002eb1
 8002ee4:	08002eb1 	.word	0x08002eb1
 8002ee8:	08002eb1 	.word	0x08002eb1
 8002eec:	08002eb1 	.word	0x08002eb1
 8002ef0:	08002ef5 	.word	0x08002ef5
 8002ef4:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8002ef8:	f002 bed6 	b.w	8005ca8 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>
 8002efc:	3068      	adds	r0, #104	; 0x68
 8002efe:	f002 bbaf 	b.w	8005660 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>
 8002f02:	302c      	adds	r0, #44	; 0x2c
 8002f04:	f003 b900 	b.w	8006108 <bsec_IaqEstimator_updateInterfaceDependency>
 8002f08:	f002 bda8 	b.w	8005a5c <bsec_GasHumidityPreProcessor_updateInterfaceDependency>
 8002f0c:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 8002f10:	f003 bd20 	b.w	8006954 <bsec_SensorStatusTracker_updateInterfaceDependency>
 8002f14:	0802d614 	.word	0x0802d614

08002f18 <bsec_ChannelHub_updateOutputSamplIntvl>:
 8002f18:	4b20      	ldr	r3, [pc, #128]	; (8002f9c <bsec_ChannelHub_updateOutputSamplIntvl+0x84>)
 8002f1a:	f8df c088 	ldr.w	ip, [pc, #136]	; 8002fa4 <bsec_ChannelHub_updateOutputSamplIntvl+0x8c>
 8002f1e:	3901      	subs	r1, #1
 8002f20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f22:	5c5b      	ldrb	r3, [r3, r1]
 8002f24:	f8df e080 	ldr.w	lr, [pc, #128]	; 8002fa8 <bsec_ChannelHub_updateOutputSamplIntvl+0x90>
 8002f28:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002f2c:	2601      	movs	r6, #1
 8002f2e:	f8a3 2a78 	strh.w	r2, [r3, #2680]	; 0xa78
 8002f32:	f240 7517 	movw	r5, #1815	; 0x717
 8002f36:	2300      	movs	r3, #0
 8002f38:	fa06 f403 	lsl.w	r4, r6, r3
 8002f3c:	422c      	tst	r4, r5
 8002f3e:	d00d      	beq.n	8002f5c <bsec_ChannelHub_updateOutputSamplIntvl+0x44>
 8002f40:	f93c 7011 	ldrsh.w	r7, [ip, r1, lsl #1]
 8002f44:	4227      	tst	r7, r4
 8002f46:	d009      	beq.n	8002f5c <bsec_ChannelHub_updateOutputSamplIntvl+0x44>
 8002f48:	f81e 4003 	ldrb.w	r4, [lr, r3]
 8002f4c:	eb00 0444 	add.w	r4, r0, r4, lsl #1
 8002f50:	f8b4 7a5a 	ldrh.w	r7, [r4, #2650]	; 0xa5a
 8002f54:	4297      	cmp	r7, r2
 8002f56:	bf88      	it	hi
 8002f58:	f8a4 2a5a 	strhhi.w	r2, [r4, #2650]	; 0xa5a
 8002f5c:	3301      	adds	r3, #1
 8002f5e:	2b0b      	cmp	r3, #11
 8002f60:	d1ea      	bne.n	8002f38 <bsec_ChannelHub_updateOutputSamplIntvl+0x20>
 8002f62:	4e0f      	ldr	r6, [pc, #60]	; (8002fa0 <bsec_ChannelHub_updateOutputSamplIntvl+0x88>)
 8002f64:	f8df c044 	ldr.w	ip, [pc, #68]	; 8002fac <bsec_ChannelHub_updateOutputSamplIntvl+0x94>
 8002f68:	f8df e044 	ldr.w	lr, [pc, #68]	; 8002fb0 <bsec_ChannelHub_updateOutputSamplIntvl+0x98>
 8002f6c:	2300      	movs	r3, #0
 8002f6e:	2501      	movs	r5, #1
 8002f70:	fa05 f403 	lsl.w	r4, r5, r3
 8002f74:	4234      	tst	r4, r6
 8002f76:	d00d      	beq.n	8002f94 <bsec_ChannelHub_updateOutputSamplIntvl+0x7c>
 8002f78:	f85c 7021 	ldr.w	r7, [ip, r1, lsl #2]
 8002f7c:	423c      	tst	r4, r7
 8002f7e:	d009      	beq.n	8002f94 <bsec_ChannelHub_updateOutputSamplIntvl+0x7c>
 8002f80:	f81e 4003 	ldrb.w	r4, [lr, r3]
 8002f84:	eb00 0444 	add.w	r4, r0, r4, lsl #1
 8002f88:	f8b4 7a68 	ldrh.w	r7, [r4, #2664]	; 0xa68
 8002f8c:	4297      	cmp	r7, r2
 8002f8e:	bf88      	it	hi
 8002f90:	f8a4 2a68 	strhhi.w	r2, [r4, #2664]	; 0xa68
 8002f94:	3301      	adds	r3, #1
 8002f96:	2b18      	cmp	r3, #24
 8002f98:	d1ea      	bne.n	8002f70 <bsec_ChannelHub_updateOutputSamplIntvl+0x58>
 8002f9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002f9c:	0802d6bc 	.word	0x0802d6bc
 8002fa0:	00e0200f 	.word	0x00e0200f
 8002fa4:	0802d620 	.word	0x0802d620
 8002fa8:	0802d614 	.word	0x0802d614
 8002fac:	0802d654 	.word	0x0802d654
 8002fb0:	0802d6d8 	.word	0x0802d6d8

08002fb4 <bsec_b_ChannelHub_getInput>:
 8002fb4:	b470      	push	{r4, r5, r6}
 8002fb6:	f600 15dc 	addw	r5, r0, #2524	; 0x9dc
 8002fba:	f500 6411 	add.w	r4, r0, #2320	; 0x910
 8002fbe:	682e      	ldr	r6, [r5, #0]
 8002fc0:	f8d0 0a3c 	ldr.w	r0, [r0, #2620]	; 0xa3c
 8002fc4:	e9d4 4500 	ldrd	r4, r5, [r4]
 8002fc8:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8002fcc:	600e      	str	r6, [r1, #0]
 8002fce:	e9c2 4500 	strd	r4, r5, [r2]
 8002fd2:	bc70      	pop	{r4, r5, r6}
 8002fd4:	7018      	strb	r0, [r3, #0]
 8002fd6:	4770      	bx	lr

08002fd8 <bsec_b_ChannelHub_updateChannelInterfaceDependency>:
 8002fd8:	1e4b      	subs	r3, r1, #1
 8002fda:	2b0a      	cmp	r3, #10
 8002fdc:	d810      	bhi.n	8003000 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x28>
 8002fde:	4a12      	ldr	r2, [pc, #72]	; (8003028 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x50>)
 8002fe0:	4411      	add	r1, r2
 8002fe2:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 8002fe6:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8002fea:	f8b2 1a5a 	ldrh.w	r1, [r2, #2650]	; 0xa5a
 8002fee:	2b09      	cmp	r3, #9
 8002ff0:	d809      	bhi.n	8003006 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x2e>
 8002ff2:	e8df f003 	tbb	[pc, r3]
 8002ff6:	0c09      	.short	0x0c09
 8002ff8:	0811080f 	.word	0x0811080f
 8002ffc:	15080808 	.word	0x15080808
 8003000:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003004:	e7f3      	b.n	8002fee <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x16>
 8003006:	4770      	bx	lr
 8003008:	3068      	adds	r0, #104	; 0x68
 800300a:	f002 bb29 	b.w	8005660 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>
 800300e:	302c      	adds	r0, #44	; 0x2c
 8003010:	f003 b87a 	b.w	8006108 <bsec_IaqEstimator_updateInterfaceDependency>
 8003014:	f002 bd22 	b.w	8005a5c <bsec_GasHumidityPreProcessor_updateInterfaceDependency>
 8003018:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
 800301c:	f003 bc9a 	b.w	8006954 <bsec_SensorStatusTracker_updateInterfaceDependency>
 8003020:	f500 70fc 	add.w	r0, r0, #504	; 0x1f8
 8003024:	f002 be40 	b.w	8005ca8 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>
 8003028:	0802d614 	.word	0x0802d614

0800302c <bsec_c_ChannelHub_getInput>:
 800302c:	b470      	push	{r4, r5, r6}
 800302e:	f600 15e4 	addw	r5, r0, #2532	; 0x9e4
 8003032:	f500 6412 	add.w	r4, r0, #2336	; 0x920
 8003036:	682e      	ldr	r6, [r5, #0]
 8003038:	f8d0 0a3c 	ldr.w	r0, [r0, #2620]	; 0xa3c
 800303c:	e9d4 4500 	ldrd	r4, r5, [r4]
 8003040:	f3c0 5040 	ubfx	r0, r0, #21, #1
 8003044:	600e      	str	r6, [r1, #0]
 8003046:	e9c2 4500 	strd	r4, r5, [r2]
 800304a:	bc70      	pop	{r4, r5, r6}
 800304c:	7018      	strb	r0, [r3, #0]
 800304e:	4770      	bx	lr

08003050 <bsec_Entity_parseAndDeserialize>:
 8003050:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003052:	460f      	mov	r7, r1
 8003054:	6809      	ldr	r1, [r1, #0]
 8003056:	4603      	mov	r3, r0
 8003058:	1e4c      	subs	r4, r1, #1
 800305a:	f100 060b 	add.w	r6, r0, #11
 800305e:	b085      	sub	sp, #20
 8003060:	4423      	add	r3, r4
 8003062:	4610      	mov	r0, r2
 8003064:	440e      	add	r6, r1
 8003066:	ac01      	add	r4, sp, #4
 8003068:	f813 5f01 	ldrb.w	r5, [r3, #1]!
 800306c:	f804 5b01 	strb.w	r5, [r4], #1
 8003070:	42b3      	cmp	r3, r6
 8003072:	d1f9      	bne.n	8003068 <bsec_Entity_parseAndDeserialize+0x18>
 8003074:	a901      	add	r1, sp, #4
 8003076:	220c      	movs	r2, #12
 8003078:	f029 f832 	bl	802c0e0 <memcpy>
 800307c:	683b      	ldr	r3, [r7, #0]
 800307e:	330c      	adds	r3, #12
 8003080:	603b      	str	r3, [r7, #0]
 8003082:	b005      	add	sp, #20
 8003084:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003086:	bf00      	nop

08003088 <bsec_Entity_serializeAndAdd>:
 8003088:	b5f0      	push	{r4, r5, r6, r7, lr}
 800308a:	461c      	mov	r4, r3
 800308c:	681b      	ldr	r3, [r3, #0]
 800308e:	330c      	adds	r3, #12
 8003090:	4293      	cmp	r3, r2
 8003092:	b085      	sub	sp, #20
 8003094:	d903      	bls.n	800309e <bsec_Entity_serializeAndAdd+0x16>
 8003096:	3201      	adds	r2, #1
 8003098:	6022      	str	r2, [r4, #0]
 800309a:	b005      	add	sp, #20
 800309c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800309e:	220c      	movs	r2, #12
 80030a0:	460f      	mov	r7, r1
 80030a2:	4601      	mov	r1, r0
 80030a4:	a801      	add	r0, sp, #4
 80030a6:	f029 f81b 	bl	802c0e0 <memcpy>
 80030aa:	ab01      	add	r3, sp, #4
 80030ac:	2200      	movs	r2, #0
 80030ae:	18bd      	adds	r5, r7, r2
 80030b0:	6820      	ldr	r0, [r4, #0]
 80030b2:	f813 6b01 	ldrb.w	r6, [r3], #1
 80030b6:	542e      	strb	r6, [r5, r0]
 80030b8:	3201      	adds	r2, #1
 80030ba:	2a0c      	cmp	r2, #12
 80030bc:	d1f7      	bne.n	80030ae <bsec_Entity_serializeAndAdd+0x26>
 80030be:	6823      	ldr	r3, [r4, #0]
 80030c0:	330c      	adds	r3, #12
 80030c2:	6023      	str	r3, [r4, #0]
 80030c4:	b005      	add	sp, #20
 80030c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080030c8 <bsec_ab_Entity_serializeAndAdd>:
 80030c8:	b570      	push	{r4, r5, r6, lr}
 80030ca:	461d      	mov	r5, r3
 80030cc:	681b      	ldr	r3, [r3, #0]
 80030ce:	3326      	adds	r3, #38	; 0x26
 80030d0:	4293      	cmp	r3, r2
 80030d2:	b08a      	sub	sp, #40	; 0x28
 80030d4:	d903      	bls.n	80030de <bsec_ab_Entity_serializeAndAdd+0x16>
 80030d6:	3201      	adds	r2, #1
 80030d8:	602a      	str	r2, [r5, #0]
 80030da:	b00a      	add	sp, #40	; 0x28
 80030dc:	bd70      	pop	{r4, r5, r6, pc}
 80030de:	466c      	mov	r4, sp
 80030e0:	2226      	movs	r2, #38	; 0x26
 80030e2:	460e      	mov	r6, r1
 80030e4:	4601      	mov	r1, r0
 80030e6:	4620      	mov	r0, r4
 80030e8:	f028 fffa 	bl	802c0e0 <memcpy>
 80030ec:	f1c4 0301 	rsb	r3, r4, #1
 80030f0:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 80030f4:	f10d 0125 	add.w	r1, sp, #37	; 0x25
 80030f8:	682c      	ldr	r4, [r5, #0]
 80030fa:	1898      	adds	r0, r3, r2
 80030fc:	4420      	add	r0, r4
 80030fe:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003102:	5434      	strb	r4, [r6, r0]
 8003104:	428a      	cmp	r2, r1
 8003106:	d1f7      	bne.n	80030f8 <bsec_ab_Entity_serializeAndAdd+0x30>
 8003108:	682b      	ldr	r3, [r5, #0]
 800310a:	3326      	adds	r3, #38	; 0x26
 800310c:	602b      	str	r3, [r5, #0]
 800310e:	b00a      	add	sp, #40	; 0x28
 8003110:	bd70      	pop	{r4, r5, r6, pc}
 8003112:	bf00      	nop

08003114 <bsec_b_Entity_parseAndDeserialize>:
 8003114:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003116:	680b      	ldr	r3, [r1, #0]
 8003118:	b083      	sub	sp, #12
 800311a:	4604      	mov	r4, r0
 800311c:	441c      	add	r4, r3
 800311e:	460f      	mov	r7, r1
 8003120:	4610      	mov	r0, r2
 8003122:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
 8003126:	f10d 0607 	add.w	r6, sp, #7
 800312a:	f814 5b01 	ldrb.w	r5, [r4], #1
 800312e:	f803 5f01 	strb.w	r5, [r3, #1]!
 8003132:	42b3      	cmp	r3, r6
 8003134:	d1f9      	bne.n	800312a <bsec_b_Entity_parseAndDeserialize+0x16>
 8003136:	2208      	movs	r2, #8
 8003138:	4669      	mov	r1, sp
 800313a:	f028 ffd1 	bl	802c0e0 <memcpy>
 800313e:	683b      	ldr	r3, [r7, #0]
 8003140:	3308      	adds	r3, #8
 8003142:	603b      	str	r3, [r7, #0]
 8003144:	b003      	add	sp, #12
 8003146:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003148 <bsec_b_Entity_serializeAndAdd>:
 8003148:	b570      	push	{r4, r5, r6, lr}
 800314a:	461c      	mov	r4, r3
 800314c:	681b      	ldr	r3, [r3, #0]
 800314e:	3308      	adds	r3, #8
 8003150:	4293      	cmp	r3, r2
 8003152:	b084      	sub	sp, #16
 8003154:	d903      	bls.n	800315e <bsec_b_Entity_serializeAndAdd+0x16>
 8003156:	3201      	adds	r2, #1
 8003158:	6022      	str	r2, [r4, #0]
 800315a:	b004      	add	sp, #16
 800315c:	bd70      	pop	{r4, r5, r6, pc}
 800315e:	2208      	movs	r2, #8
 8003160:	460d      	mov	r5, r1
 8003162:	4601      	mov	r1, r0
 8003164:	4668      	mov	r0, sp
 8003166:	f028 ffbb 	bl	802c0e0 <memcpy>
 800316a:	2208      	movs	r2, #8
 800316c:	eb0d 0002 	add.w	r0, sp, r2
 8003170:	4669      	mov	r1, sp
 8003172:	f028 ffb5 	bl	802c0e0 <memcpy>
 8003176:	f10d 0307 	add.w	r3, sp, #7
 800317a:	2200      	movs	r2, #0
 800317c:	18a8      	adds	r0, r5, r2
 800317e:	6821      	ldr	r1, [r4, #0]
 8003180:	f813 6f01 	ldrb.w	r6, [r3, #1]!
 8003184:	5446      	strb	r6, [r0, r1]
 8003186:	3201      	adds	r2, #1
 8003188:	2a08      	cmp	r2, #8
 800318a:	d1f7      	bne.n	800317c <bsec_b_Entity_serializeAndAdd+0x34>
 800318c:	6823      	ldr	r3, [r4, #0]
 800318e:	3308      	adds	r3, #8
 8003190:	6023      	str	r3, [r4, #0]
 8003192:	b004      	add	sp, #16
 8003194:	bd70      	pop	{r4, r5, r6, pc}
 8003196:	bf00      	nop

08003198 <bsec_bb_Entity_serializeAndAdd>:
 8003198:	b570      	push	{r4, r5, r6, lr}
 800319a:	461d      	mov	r5, r3
 800319c:	681b      	ldr	r3, [r3, #0]
 800319e:	3314      	adds	r3, #20
 80031a0:	4293      	cmp	r3, r2
 80031a2:	b08a      	sub	sp, #40	; 0x28
 80031a4:	d903      	bls.n	80031ae <bsec_bb_Entity_serializeAndAdd+0x16>
 80031a6:	3201      	adds	r2, #1
 80031a8:	602a      	str	r2, [r5, #0]
 80031aa:	b00a      	add	sp, #40	; 0x28
 80031ac:	bd70      	pop	{r4, r5, r6, pc}
 80031ae:	2214      	movs	r2, #20
 80031b0:	eb0d 0402 	add.w	r4, sp, r2
 80031b4:	460e      	mov	r6, r1
 80031b6:	4601      	mov	r1, r0
 80031b8:	4668      	mov	r0, sp
 80031ba:	f028 ff91 	bl	802c0e0 <memcpy>
 80031be:	4669      	mov	r1, sp
 80031c0:	2214      	movs	r2, #20
 80031c2:	4620      	mov	r0, r4
 80031c4:	f028 ff8c 	bl	802c0e0 <memcpy>
 80031c8:	f1c4 0301 	rsb	r3, r4, #1
 80031cc:	f10d 0213 	add.w	r2, sp, #19
 80031d0:	f10d 0127 	add.w	r1, sp, #39	; 0x27
 80031d4:	682c      	ldr	r4, [r5, #0]
 80031d6:	1898      	adds	r0, r3, r2
 80031d8:	4420      	add	r0, r4
 80031da:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 80031de:	5434      	strb	r4, [r6, r0]
 80031e0:	428a      	cmp	r2, r1
 80031e2:	d1f7      	bne.n	80031d4 <bsec_bb_Entity_serializeAndAdd+0x3c>
 80031e4:	682b      	ldr	r3, [r5, #0]
 80031e6:	3314      	adds	r3, #20
 80031e8:	602b      	str	r3, [r5, #0]
 80031ea:	b00a      	add	sp, #40	; 0x28
 80031ec:	bd70      	pop	{r4, r5, r6, pc}
 80031ee:	bf00      	nop

080031f0 <bsec_c_Entity_parseAndDeserialize>:
 80031f0:	b510      	push	{r4, lr}
 80031f2:	680b      	ldr	r3, [r1, #0]
 80031f4:	18c2      	adds	r2, r0, r3
 80031f6:	b082      	sub	sp, #8
 80031f8:	460c      	mov	r4, r1
 80031fa:	7852      	ldrb	r2, [r2, #1]
 80031fc:	5cc3      	ldrb	r3, [r0, r3]
 80031fe:	f88d 2005 	strb.w	r2, [sp, #5]
 8003202:	a901      	add	r1, sp, #4
 8003204:	2202      	movs	r2, #2
 8003206:	f10d 0006 	add.w	r0, sp, #6
 800320a:	f88d 3004 	strb.w	r3, [sp, #4]
 800320e:	f028 ff67 	bl	802c0e0 <memcpy>
 8003212:	6823      	ldr	r3, [r4, #0]
 8003214:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8003218:	3302      	adds	r3, #2
 800321a:	6023      	str	r3, [r4, #0]
 800321c:	b002      	add	sp, #8
 800321e:	bd10      	pop	{r4, pc}

08003220 <bsec_c_Entity_serializeAndAdd>:
 8003220:	b530      	push	{r4, r5, lr}
 8003222:	461c      	mov	r4, r3
 8003224:	681b      	ldr	r3, [r3, #0]
 8003226:	b085      	sub	sp, #20
 8003228:	3302      	adds	r3, #2
 800322a:	4293      	cmp	r3, r2
 800322c:	f8ad 0006 	strh.w	r0, [sp, #6]
 8003230:	d903      	bls.n	800323a <bsec_c_Entity_serializeAndAdd+0x1a>
 8003232:	3201      	adds	r2, #1
 8003234:	6022      	str	r2, [r4, #0]
 8003236:	b005      	add	sp, #20
 8003238:	bd30      	pop	{r4, r5, pc}
 800323a:	460d      	mov	r5, r1
 800323c:	2202      	movs	r2, #2
 800323e:	f10d 0106 	add.w	r1, sp, #6
 8003242:	a803      	add	r0, sp, #12
 8003244:	f028 ff4c 	bl	802c0e0 <memcpy>
 8003248:	6823      	ldr	r3, [r4, #0]
 800324a:	f89d 200c 	ldrb.w	r2, [sp, #12]
 800324e:	54ea      	strb	r2, [r5, r3]
 8003250:	6821      	ldr	r1, [r4, #0]
 8003252:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8003256:	4429      	add	r1, r5
 8003258:	704b      	strb	r3, [r1, #1]
 800325a:	6823      	ldr	r3, [r4, #0]
 800325c:	3302      	adds	r3, #2
 800325e:	6023      	str	r3, [r4, #0]
 8003260:	b005      	add	sp, #20
 8003262:	bd30      	pop	{r4, r5, pc}

08003264 <bsec_d_Entity_parseAndDeserialize>:
 8003264:	b530      	push	{r4, r5, lr}
 8003266:	460c      	mov	r4, r1
 8003268:	6809      	ldr	r1, [r1, #0]
 800326a:	1845      	adds	r5, r0, r1
 800326c:	b083      	sub	sp, #12
 800326e:	4603      	mov	r3, r0
 8003270:	4610      	mov	r0, r2
 8003272:	786a      	ldrb	r2, [r5, #1]
 8003274:	5c5b      	ldrb	r3, [r3, r1]
 8003276:	f88d 2005 	strb.w	r2, [sp, #5]
 800327a:	a901      	add	r1, sp, #4
 800327c:	2202      	movs	r2, #2
 800327e:	f88d 3004 	strb.w	r3, [sp, #4]
 8003282:	f028 ff2d 	bl	802c0e0 <memcpy>
 8003286:	6823      	ldr	r3, [r4, #0]
 8003288:	3302      	adds	r3, #2
 800328a:	6023      	str	r3, [r4, #0]
 800328c:	b003      	add	sp, #12
 800328e:	bd30      	pop	{r4, r5, pc}

08003290 <bsec_d_Entity_serializeAndAdd>:
 8003290:	b530      	push	{r4, r5, lr}
 8003292:	461c      	mov	r4, r3
 8003294:	681b      	ldr	r3, [r3, #0]
 8003296:	3302      	adds	r3, #2
 8003298:	4293      	cmp	r3, r2
 800329a:	b083      	sub	sp, #12
 800329c:	d903      	bls.n	80032a6 <bsec_d_Entity_serializeAndAdd+0x16>
 800329e:	3201      	adds	r2, #1
 80032a0:	6022      	str	r2, [r4, #0]
 80032a2:	b003      	add	sp, #12
 80032a4:	bd30      	pop	{r4, r5, pc}
 80032a6:	7802      	ldrb	r2, [r0, #0]
 80032a8:	7843      	ldrb	r3, [r0, #1]
 80032aa:	f88d 2000 	strb.w	r2, [sp]
 80032ae:	460d      	mov	r5, r1
 80032b0:	2202      	movs	r2, #2
 80032b2:	4669      	mov	r1, sp
 80032b4:	a801      	add	r0, sp, #4
 80032b6:	f88d 3001 	strb.w	r3, [sp, #1]
 80032ba:	f028 ff11 	bl	802c0e0 <memcpy>
 80032be:	6823      	ldr	r3, [r4, #0]
 80032c0:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80032c4:	54ea      	strb	r2, [r5, r3]
 80032c6:	6821      	ldr	r1, [r4, #0]
 80032c8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80032cc:	4429      	add	r1, r5
 80032ce:	704b      	strb	r3, [r1, #1]
 80032d0:	6823      	ldr	r3, [r4, #0]
 80032d2:	3302      	adds	r3, #2
 80032d4:	6023      	str	r3, [r4, #0]
 80032d6:	b003      	add	sp, #12
 80032d8:	bd30      	pop	{r4, r5, pc}
 80032da:	bf00      	nop

080032dc <bsec_e_Entity_parseAndDeserialize>:
 80032dc:	b530      	push	{r4, r5, lr}
 80032de:	680a      	ldr	r2, [r1, #0]
 80032e0:	b083      	sub	sp, #12
 80032e2:	1883      	adds	r3, r0, r2
 80032e4:	5c82      	ldrb	r2, [r0, r2]
 80032e6:	f88d 2004 	strb.w	r2, [sp, #4]
 80032ea:	7858      	ldrb	r0, [r3, #1]
 80032ec:	789d      	ldrb	r5, [r3, #2]
 80032ee:	f88d 0005 	strb.w	r0, [sp, #5]
 80032f2:	460c      	mov	r4, r1
 80032f4:	2204      	movs	r2, #4
 80032f6:	78db      	ldrb	r3, [r3, #3]
 80032f8:	f88d 3007 	strb.w	r3, [sp, #7]
 80032fc:	eb0d 0102 	add.w	r1, sp, r2
 8003300:	4668      	mov	r0, sp
 8003302:	f88d 5006 	strb.w	r5, [sp, #6]
 8003306:	f028 feeb 	bl	802c0e0 <memcpy>
 800330a:	6823      	ldr	r3, [r4, #0]
 800330c:	ed9d 0a00 	vldr	s0, [sp]
 8003310:	3304      	adds	r3, #4
 8003312:	6023      	str	r3, [r4, #0]
 8003314:	b003      	add	sp, #12
 8003316:	bd30      	pop	{r4, r5, pc}

08003318 <bsec_e_Entity_serializeAndAdd>:
 8003318:	b530      	push	{r4, r5, lr}
 800331a:	6813      	ldr	r3, [r2, #0]
 800331c:	3304      	adds	r3, #4
 800331e:	b085      	sub	sp, #20
 8003320:	428b      	cmp	r3, r1
 8003322:	4614      	mov	r4, r2
 8003324:	ed8d 0a01 	vstr	s0, [sp, #4]
 8003328:	d903      	bls.n	8003332 <bsec_e_Entity_serializeAndAdd+0x1a>
 800332a:	3101      	adds	r1, #1
 800332c:	6011      	str	r1, [r2, #0]
 800332e:	b005      	add	sp, #20
 8003330:	bd30      	pop	{r4, r5, pc}
 8003332:	2204      	movs	r2, #4
 8003334:	4605      	mov	r5, r0
 8003336:	eb0d 0102 	add.w	r1, sp, r2
 800333a:	a803      	add	r0, sp, #12
 800333c:	f028 fed0 	bl	802c0e0 <memcpy>
 8003340:	6823      	ldr	r3, [r4, #0]
 8003342:	f89d 200c 	ldrb.w	r2, [sp, #12]
 8003346:	54ea      	strb	r2, [r5, r3]
 8003348:	6823      	ldr	r3, [r4, #0]
 800334a:	f89d 000d 	ldrb.w	r0, [sp, #13]
 800334e:	f89d 100e 	ldrb.w	r1, [sp, #14]
 8003352:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8003356:	442b      	add	r3, r5
 8003358:	7058      	strb	r0, [r3, #1]
 800335a:	6823      	ldr	r3, [r4, #0]
 800335c:	442b      	add	r3, r5
 800335e:	7099      	strb	r1, [r3, #2]
 8003360:	6820      	ldr	r0, [r4, #0]
 8003362:	4405      	add	r5, r0
 8003364:	70ea      	strb	r2, [r5, #3]
 8003366:	6823      	ldr	r3, [r4, #0]
 8003368:	3304      	adds	r3, #4
 800336a:	6023      	str	r3, [r4, #0]
 800336c:	b005      	add	sp, #20
 800336e:	bd30      	pop	{r4, r5, pc}

08003370 <bsec_f_Entity_parseAndDeserialize>:
 8003370:	b510      	push	{r4, lr}
 8003372:	680b      	ldr	r3, [r1, #0]
 8003374:	b082      	sub	sp, #8
 8003376:	460c      	mov	r4, r1
 8003378:	5cc3      	ldrb	r3, [r0, r3]
 800337a:	f88d 3007 	strb.w	r3, [sp, #7]
 800337e:	2201      	movs	r2, #1
 8003380:	f10d 0107 	add.w	r1, sp, #7
 8003384:	f10d 0006 	add.w	r0, sp, #6
 8003388:	f028 feaa 	bl	802c0e0 <memcpy>
 800338c:	6823      	ldr	r3, [r4, #0]
 800338e:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8003392:	3301      	adds	r3, #1
 8003394:	6023      	str	r3, [r4, #0]
 8003396:	b002      	add	sp, #8
 8003398:	bd10      	pop	{r4, pc}
 800339a:	bf00      	nop

0800339c <bsec_f_Entity_serializeAndAdd>:
 800339c:	b530      	push	{r4, r5, lr}
 800339e:	461c      	mov	r4, r3
 80033a0:	681b      	ldr	r3, [r3, #0]
 80033a2:	b083      	sub	sp, #12
 80033a4:	1c5d      	adds	r5, r3, #1
 80033a6:	4295      	cmp	r5, r2
 80033a8:	f88d 0007 	strb.w	r0, [sp, #7]
 80033ac:	d903      	bls.n	80033b6 <bsec_f_Entity_serializeAndAdd+0x1a>
 80033ae:	3201      	adds	r2, #1
 80033b0:	6022      	str	r2, [r4, #0]
 80033b2:	b003      	add	sp, #12
 80033b4:	bd30      	pop	{r4, r5, pc}
 80033b6:	18c8      	adds	r0, r1, r3
 80033b8:	2201      	movs	r2, #1
 80033ba:	f10d 0107 	add.w	r1, sp, #7
 80033be:	f028 fe8f 	bl	802c0e0 <memcpy>
 80033c2:	6823      	ldr	r3, [r4, #0]
 80033c4:	3301      	adds	r3, #1
 80033c6:	6023      	str	r3, [r4, #0]
 80033c8:	b003      	add	sp, #12
 80033ca:	bd30      	pop	{r4, r5, pc}

080033cc <bsec_g_Entity_parseAndDeserialize>:
 80033cc:	b530      	push	{r4, r5, lr}
 80033ce:	680a      	ldr	r2, [r1, #0]
 80033d0:	b085      	sub	sp, #20
 80033d2:	460d      	mov	r5, r1
 80033d4:	f10d 0307 	add.w	r3, sp, #7
 80033d8:	4410      	add	r0, r2
 80033da:	f10d 040f 	add.w	r4, sp, #15
 80033de:	f810 2b01 	ldrb.w	r2, [r0], #1
 80033e2:	f803 2f01 	strb.w	r2, [r3, #1]!
 80033e6:	42a3      	cmp	r3, r4
 80033e8:	d1f9      	bne.n	80033de <bsec_g_Entity_parseAndDeserialize+0x12>
 80033ea:	2208      	movs	r2, #8
 80033ec:	eb0d 0102 	add.w	r1, sp, r2
 80033f0:	4668      	mov	r0, sp
 80033f2:	f028 fe75 	bl	802c0e0 <memcpy>
 80033f6:	682b      	ldr	r3, [r5, #0]
 80033f8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80033fc:	3308      	adds	r3, #8
 80033fe:	602b      	str	r3, [r5, #0]
 8003400:	b005      	add	sp, #20
 8003402:	bd30      	pop	{r4, r5, pc}

08003404 <bsec_g_Entity_serializeAndAdd>:
 8003404:	b570      	push	{r4, r5, r6, lr}
 8003406:	b084      	sub	sp, #16
 8003408:	e9cd 0100 	strd	r0, r1, [sp]
 800340c:	9c08      	ldr	r4, [sp, #32]
 800340e:	6826      	ldr	r6, [r4, #0]
 8003410:	3608      	adds	r6, #8
 8003412:	429e      	cmp	r6, r3
 8003414:	d903      	bls.n	800341e <bsec_g_Entity_serializeAndAdd+0x1a>
 8003416:	3301      	adds	r3, #1
 8003418:	6023      	str	r3, [r4, #0]
 800341a:	b004      	add	sp, #16
 800341c:	bd70      	pop	{r4, r5, r6, pc}
 800341e:	4615      	mov	r5, r2
 8003420:	2208      	movs	r2, #8
 8003422:	eb0d 0002 	add.w	r0, sp, r2
 8003426:	4669      	mov	r1, sp
 8003428:	f028 fe5a 	bl	802c0e0 <memcpy>
 800342c:	f10d 0207 	add.w	r2, sp, #7
 8003430:	2300      	movs	r3, #0
 8003432:	18e8      	adds	r0, r5, r3
 8003434:	6821      	ldr	r1, [r4, #0]
 8003436:	f812 6f01 	ldrb.w	r6, [r2, #1]!
 800343a:	5446      	strb	r6, [r0, r1]
 800343c:	3301      	adds	r3, #1
 800343e:	2b08      	cmp	r3, #8
 8003440:	d1f7      	bne.n	8003432 <bsec_g_Entity_serializeAndAdd+0x2e>
 8003442:	6823      	ldr	r3, [r4, #0]
 8003444:	3308      	adds	r3, #8
 8003446:	6023      	str	r3, [r4, #0]
 8003448:	b004      	add	sp, #16
 800344a:	bd70      	pop	{r4, r5, r6, pc}

0800344c <bsec_h_Entity_parseAndDeserialize>:
 800344c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800344e:	680b      	ldr	r3, [r1, #0]
 8003450:	b08b      	sub	sp, #44	; 0x2c
 8003452:	4604      	mov	r4, r0
 8003454:	3b01      	subs	r3, #1
 8003456:	441c      	add	r4, r3
 8003458:	460f      	mov	r7, r1
 800345a:	4610      	mov	r0, r2
 800345c:	466b      	mov	r3, sp
 800345e:	ae0a      	add	r6, sp, #40	; 0x28
 8003460:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003464:	f803 5b01 	strb.w	r5, [r3], #1
 8003468:	42b3      	cmp	r3, r6
 800346a:	d1f9      	bne.n	8003460 <bsec_h_Entity_parseAndDeserialize+0x14>
 800346c:	4669      	mov	r1, sp
 800346e:	2228      	movs	r2, #40	; 0x28
 8003470:	f028 fe36 	bl	802c0e0 <memcpy>
 8003474:	683b      	ldr	r3, [r7, #0]
 8003476:	3328      	adds	r3, #40	; 0x28
 8003478:	603b      	str	r3, [r7, #0]
 800347a:	b00b      	add	sp, #44	; 0x2c
 800347c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800347e:	bf00      	nop

08003480 <bsec_h_Entity_serializeAndAdd>:
 8003480:	b430      	push	{r4, r5}
 8003482:	681c      	ldr	r4, [r3, #0]
 8003484:	1c65      	adds	r5, r4, #1
 8003486:	4295      	cmp	r5, r2
 8003488:	bf9c      	itt	ls
 800348a:	5508      	strbls	r0, [r1, r4]
 800348c:	681a      	ldrls	r2, [r3, #0]
 800348e:	3201      	adds	r2, #1
 8003490:	bc30      	pop	{r4, r5}
 8003492:	601a      	str	r2, [r3, #0]
 8003494:	4770      	bx	lr
 8003496:	bf00      	nop

08003498 <bsec_i_Entity_parseAndDeserialize>:
 8003498:	b5f0      	push	{r4, r5, r6, r7, lr}
 800349a:	680b      	ldr	r3, [r1, #0]
 800349c:	b087      	sub	sp, #28
 800349e:	4604      	mov	r4, r0
 80034a0:	3b01      	subs	r3, #1
 80034a2:	441c      	add	r4, r3
 80034a4:	460f      	mov	r7, r1
 80034a6:	4610      	mov	r0, r2
 80034a8:	466b      	mov	r3, sp
 80034aa:	ae06      	add	r6, sp, #24
 80034ac:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80034b0:	f803 5b01 	strb.w	r5, [r3], #1
 80034b4:	42b3      	cmp	r3, r6
 80034b6:	d1f9      	bne.n	80034ac <bsec_i_Entity_parseAndDeserialize+0x14>
 80034b8:	4669      	mov	r1, sp
 80034ba:	2218      	movs	r2, #24
 80034bc:	f028 fe10 	bl	802c0e0 <memcpy>
 80034c0:	683b      	ldr	r3, [r7, #0]
 80034c2:	3318      	adds	r3, #24
 80034c4:	603b      	str	r3, [r7, #0]
 80034c6:	b007      	add	sp, #28
 80034c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034ca:	bf00      	nop

080034cc <bsec_i_Entity_serializeAndAdd>:
 80034cc:	b570      	push	{r4, r5, r6, lr}
 80034ce:	461d      	mov	r5, r3
 80034d0:	681b      	ldr	r3, [r3, #0]
 80034d2:	3328      	adds	r3, #40	; 0x28
 80034d4:	4293      	cmp	r3, r2
 80034d6:	b08a      	sub	sp, #40	; 0x28
 80034d8:	d903      	bls.n	80034e2 <bsec_i_Entity_serializeAndAdd+0x16>
 80034da:	3201      	adds	r2, #1
 80034dc:	602a      	str	r2, [r5, #0]
 80034de:	b00a      	add	sp, #40	; 0x28
 80034e0:	bd70      	pop	{r4, r5, r6, pc}
 80034e2:	466c      	mov	r4, sp
 80034e4:	2228      	movs	r2, #40	; 0x28
 80034e6:	460e      	mov	r6, r1
 80034e8:	4601      	mov	r1, r0
 80034ea:	4620      	mov	r0, r4
 80034ec:	f028 fdf8 	bl	802c0e0 <memcpy>
 80034f0:	f1c4 0301 	rsb	r3, r4, #1
 80034f4:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 80034f8:	f10d 0127 	add.w	r1, sp, #39	; 0x27
 80034fc:	682c      	ldr	r4, [r5, #0]
 80034fe:	1898      	adds	r0, r3, r2
 8003500:	4420      	add	r0, r4
 8003502:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003506:	5434      	strb	r4, [r6, r0]
 8003508:	428a      	cmp	r2, r1
 800350a:	d1f7      	bne.n	80034fc <bsec_i_Entity_serializeAndAdd+0x30>
 800350c:	682b      	ldr	r3, [r5, #0]
 800350e:	3328      	adds	r3, #40	; 0x28
 8003510:	602b      	str	r3, [r5, #0]
 8003512:	b00a      	add	sp, #40	; 0x28
 8003514:	bd70      	pop	{r4, r5, r6, pc}
 8003516:	bf00      	nop

08003518 <bsec_j_Entity_parseAndDeserialize>:
 8003518:	b5f0      	push	{r4, r5, r6, r7, lr}
 800351a:	680b      	ldr	r3, [r1, #0]
 800351c:	b0bb      	sub	sp, #236	; 0xec
 800351e:	4604      	mov	r4, r0
 8003520:	3b01      	subs	r3, #1
 8003522:	441c      	add	r4, r3
 8003524:	460f      	mov	r7, r1
 8003526:	4610      	mov	r0, r2
 8003528:	ab01      	add	r3, sp, #4
 800352a:	ae3a      	add	r6, sp, #232	; 0xe8
 800352c:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003530:	f803 5b01 	strb.w	r5, [r3], #1
 8003534:	42b3      	cmp	r3, r6
 8003536:	d1f9      	bne.n	800352c <bsec_j_Entity_parseAndDeserialize+0x14>
 8003538:	a901      	add	r1, sp, #4
 800353a:	22e4      	movs	r2, #228	; 0xe4
 800353c:	f028 fdd0 	bl	802c0e0 <memcpy>
 8003540:	683b      	ldr	r3, [r7, #0]
 8003542:	33e4      	adds	r3, #228	; 0xe4
 8003544:	603b      	str	r3, [r7, #0]
 8003546:	b03b      	add	sp, #236	; 0xec
 8003548:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800354a:	bf00      	nop

0800354c <bsec_j_Entity_serializeAndAdd>:
 800354c:	b570      	push	{r4, r5, r6, lr}
 800354e:	461d      	mov	r5, r3
 8003550:	681b      	ldr	r3, [r3, #0]
 8003552:	3310      	adds	r3, #16
 8003554:	4293      	cmp	r3, r2
 8003556:	b088      	sub	sp, #32
 8003558:	d903      	bls.n	8003562 <bsec_j_Entity_serializeAndAdd+0x16>
 800355a:	3201      	adds	r2, #1
 800355c:	602a      	str	r2, [r5, #0]
 800355e:	b008      	add	sp, #32
 8003560:	bd70      	pop	{r4, r5, r6, pc}
 8003562:	2210      	movs	r2, #16
 8003564:	eb0d 0402 	add.w	r4, sp, r2
 8003568:	460e      	mov	r6, r1
 800356a:	4601      	mov	r1, r0
 800356c:	4668      	mov	r0, sp
 800356e:	f028 fdb7 	bl	802c0e0 <memcpy>
 8003572:	4669      	mov	r1, sp
 8003574:	2210      	movs	r2, #16
 8003576:	4620      	mov	r0, r4
 8003578:	f028 fdb2 	bl	802c0e0 <memcpy>
 800357c:	f1c4 0001 	rsb	r0, r4, #1
 8003580:	f10d 020f 	add.w	r2, sp, #15
 8003584:	f10d 011f 	add.w	r1, sp, #31
 8003588:	682b      	ldr	r3, [r5, #0]
 800358a:	1884      	adds	r4, r0, r2
 800358c:	441c      	add	r4, r3
 800358e:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003592:	5533      	strb	r3, [r6, r4]
 8003594:	428a      	cmp	r2, r1
 8003596:	d1f7      	bne.n	8003588 <bsec_j_Entity_serializeAndAdd+0x3c>
 8003598:	682b      	ldr	r3, [r5, #0]
 800359a:	3310      	adds	r3, #16
 800359c:	602b      	str	r3, [r5, #0]
 800359e:	b008      	add	sp, #32
 80035a0:	bd70      	pop	{r4, r5, r6, pc}
 80035a2:	bf00      	nop

080035a4 <bsec_k_Entity_parseAndDeserialize>:
 80035a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80035a6:	680b      	ldr	r3, [r1, #0]
 80035a8:	b08b      	sub	sp, #44	; 0x2c
 80035aa:	4604      	mov	r4, r0
 80035ac:	3b01      	subs	r3, #1
 80035ae:	441c      	add	r4, r3
 80035b0:	460f      	mov	r7, r1
 80035b2:	4610      	mov	r0, r2
 80035b4:	466b      	mov	r3, sp
 80035b6:	f10d 0626 	add.w	r6, sp, #38	; 0x26
 80035ba:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80035be:	f803 5b01 	strb.w	r5, [r3], #1
 80035c2:	42b3      	cmp	r3, r6
 80035c4:	d1f9      	bne.n	80035ba <bsec_k_Entity_parseAndDeserialize+0x16>
 80035c6:	4669      	mov	r1, sp
 80035c8:	2226      	movs	r2, #38	; 0x26
 80035ca:	f028 fd89 	bl	802c0e0 <memcpy>
 80035ce:	683b      	ldr	r3, [r7, #0]
 80035d0:	3326      	adds	r3, #38	; 0x26
 80035d2:	603b      	str	r3, [r7, #0]
 80035d4:	b00b      	add	sp, #44	; 0x2c
 80035d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080035d8 <bsec_k_Entity_serializeAndAdd>:
 80035d8:	b530      	push	{r4, r5, lr}
 80035da:	461c      	mov	r4, r3
 80035dc:	681b      	ldr	r3, [r3, #0]
 80035de:	3304      	adds	r3, #4
 80035e0:	4293      	cmp	r3, r2
 80035e2:	b083      	sub	sp, #12
 80035e4:	d903      	bls.n	80035ee <bsec_k_Entity_serializeAndAdd+0x16>
 80035e6:	3201      	adds	r2, #1
 80035e8:	6022      	str	r2, [r4, #0]
 80035ea:	b003      	add	sp, #12
 80035ec:	bd30      	pop	{r4, r5, pc}
 80035ee:	8802      	ldrh	r2, [r0, #0]
 80035f0:	f8ad 2000 	strh.w	r2, [sp]
 80035f4:	2204      	movs	r2, #4
 80035f6:	460d      	mov	r5, r1
 80035f8:	8843      	ldrh	r3, [r0, #2]
 80035fa:	f8ad 3002 	strh.w	r3, [sp, #2]
 80035fe:	4669      	mov	r1, sp
 8003600:	eb0d 0002 	add.w	r0, sp, r2
 8003604:	f028 fd6c 	bl	802c0e0 <memcpy>
 8003608:	6823      	ldr	r3, [r4, #0]
 800360a:	f89d 2004 	ldrb.w	r2, [sp, #4]
 800360e:	54ea      	strb	r2, [r5, r3]
 8003610:	6823      	ldr	r3, [r4, #0]
 8003612:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8003616:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800361a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800361e:	442b      	add	r3, r5
 8003620:	7058      	strb	r0, [r3, #1]
 8003622:	6823      	ldr	r3, [r4, #0]
 8003624:	442b      	add	r3, r5
 8003626:	7099      	strb	r1, [r3, #2]
 8003628:	6821      	ldr	r1, [r4, #0]
 800362a:	440d      	add	r5, r1
 800362c:	70ea      	strb	r2, [r5, #3]
 800362e:	6823      	ldr	r3, [r4, #0]
 8003630:	3304      	adds	r3, #4
 8003632:	6023      	str	r3, [r4, #0]
 8003634:	b003      	add	sp, #12
 8003636:	bd30      	pop	{r4, r5, pc}

08003638 <bsec_l_Entity_parseAndDeserialize>:
 8003638:	b5f0      	push	{r4, r5, r6, r7, lr}
 800363a:	680b      	ldr	r3, [r1, #0]
 800363c:	b087      	sub	sp, #28
 800363e:	4604      	mov	r4, r0
 8003640:	3b01      	subs	r3, #1
 8003642:	441c      	add	r4, r3
 8003644:	460f      	mov	r7, r1
 8003646:	4610      	mov	r0, r2
 8003648:	ab01      	add	r3, sp, #4
 800364a:	ae06      	add	r6, sp, #24
 800364c:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003650:	f803 5b01 	strb.w	r5, [r3], #1
 8003654:	42b3      	cmp	r3, r6
 8003656:	d1f9      	bne.n	800364c <bsec_l_Entity_parseAndDeserialize+0x14>
 8003658:	a901      	add	r1, sp, #4
 800365a:	2214      	movs	r2, #20
 800365c:	f028 fd40 	bl	802c0e0 <memcpy>
 8003660:	683b      	ldr	r3, [r7, #0]
 8003662:	3314      	adds	r3, #20
 8003664:	603b      	str	r3, [r7, #0]
 8003666:	b007      	add	sp, #28
 8003668:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800366a:	bf00      	nop

0800366c <bsec_l_Entity_serializeAndAdd>:
 800366c:	b530      	push	{r4, r5, lr}
 800366e:	461c      	mov	r4, r3
 8003670:	681b      	ldr	r3, [r3, #0]
 8003672:	3302      	adds	r3, #2
 8003674:	4293      	cmp	r3, r2
 8003676:	b083      	sub	sp, #12
 8003678:	d903      	bls.n	8003682 <bsec_l_Entity_serializeAndAdd+0x16>
 800367a:	3201      	adds	r2, #1
 800367c:	6022      	str	r2, [r4, #0]
 800367e:	b003      	add	sp, #12
 8003680:	bd30      	pop	{r4, r5, pc}
 8003682:	7802      	ldrb	r2, [r0, #0]
 8003684:	7843      	ldrb	r3, [r0, #1]
 8003686:	f88d 2000 	strb.w	r2, [sp]
 800368a:	460d      	mov	r5, r1
 800368c:	2202      	movs	r2, #2
 800368e:	4669      	mov	r1, sp
 8003690:	a801      	add	r0, sp, #4
 8003692:	f88d 3001 	strb.w	r3, [sp, #1]
 8003696:	f028 fd23 	bl	802c0e0 <memcpy>
 800369a:	6823      	ldr	r3, [r4, #0]
 800369c:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80036a0:	54ea      	strb	r2, [r5, r3]
 80036a2:	6821      	ldr	r1, [r4, #0]
 80036a4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80036a8:	4429      	add	r1, r5
 80036aa:	704b      	strb	r3, [r1, #1]
 80036ac:	6823      	ldr	r3, [r4, #0]
 80036ae:	3302      	adds	r3, #2
 80036b0:	6023      	str	r3, [r4, #0]
 80036b2:	b003      	add	sp, #12
 80036b4:	bd30      	pop	{r4, r5, pc}
 80036b6:	bf00      	nop

080036b8 <bsec_m_Entity_parseAndDeserialize>:
 80036b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80036ba:	680b      	ldr	r3, [r1, #0]
 80036bc:	b085      	sub	sp, #20
 80036be:	4604      	mov	r4, r0
 80036c0:	3b01      	subs	r3, #1
 80036c2:	441c      	add	r4, r3
 80036c4:	460f      	mov	r7, r1
 80036c6:	4610      	mov	r0, r2
 80036c8:	466b      	mov	r3, sp
 80036ca:	ae04      	add	r6, sp, #16
 80036cc:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80036d0:	f803 5b01 	strb.w	r5, [r3], #1
 80036d4:	42b3      	cmp	r3, r6
 80036d6:	d1f9      	bne.n	80036cc <bsec_m_Entity_parseAndDeserialize+0x14>
 80036d8:	4669      	mov	r1, sp
 80036da:	2210      	movs	r2, #16
 80036dc:	f028 fd00 	bl	802c0e0 <memcpy>
 80036e0:	683b      	ldr	r3, [r7, #0]
 80036e2:	3310      	adds	r3, #16
 80036e4:	603b      	str	r3, [r7, #0]
 80036e6:	b005      	add	sp, #20
 80036e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036ea:	bf00      	nop

080036ec <bsec_m_Entity_serializeAndAdd>:
 80036ec:	b530      	push	{r4, r5, lr}
 80036ee:	461c      	mov	r4, r3
 80036f0:	681b      	ldr	r3, [r3, #0]
 80036f2:	b083      	sub	sp, #12
 80036f4:	1c5d      	adds	r5, r3, #1
 80036f6:	4295      	cmp	r5, r2
 80036f8:	f88d 0007 	strb.w	r0, [sp, #7]
 80036fc:	d903      	bls.n	8003706 <bsec_m_Entity_serializeAndAdd+0x1a>
 80036fe:	3201      	adds	r2, #1
 8003700:	6022      	str	r2, [r4, #0]
 8003702:	b003      	add	sp, #12
 8003704:	bd30      	pop	{r4, r5, pc}
 8003706:	18c8      	adds	r0, r1, r3
 8003708:	2201      	movs	r2, #1
 800370a:	f10d 0107 	add.w	r1, sp, #7
 800370e:	f028 fce7 	bl	802c0e0 <memcpy>
 8003712:	6823      	ldr	r3, [r4, #0]
 8003714:	3301      	adds	r3, #1
 8003716:	6023      	str	r3, [r4, #0]
 8003718:	b003      	add	sp, #12
 800371a:	bd30      	pop	{r4, r5, pc}

0800371c <bsec_n_Entity_parseAndDeserialize>:
 800371c:	b570      	push	{r4, r5, r6, lr}
 800371e:	4603      	mov	r3, r0
 8003720:	680d      	ldr	r5, [r1, #0]
 8003722:	b082      	sub	sp, #8
 8003724:	460c      	mov	r4, r1
 8003726:	1941      	adds	r1, r0, r5
 8003728:	4610      	mov	r0, r2
 800372a:	5d5a      	ldrb	r2, [r3, r5]
 800372c:	f88d 2004 	strb.w	r2, [sp, #4]
 8003730:	2204      	movs	r2, #4
 8003732:	784e      	ldrb	r6, [r1, #1]
 8003734:	788d      	ldrb	r5, [r1, #2]
 8003736:	78cb      	ldrb	r3, [r1, #3]
 8003738:	f88d 3007 	strb.w	r3, [sp, #7]
 800373c:	eb0d 0102 	add.w	r1, sp, r2
 8003740:	f88d 6005 	strb.w	r6, [sp, #5]
 8003744:	f88d 5006 	strb.w	r5, [sp, #6]
 8003748:	f028 fcca 	bl	802c0e0 <memcpy>
 800374c:	6823      	ldr	r3, [r4, #0]
 800374e:	3304      	adds	r3, #4
 8003750:	6023      	str	r3, [r4, #0]
 8003752:	b002      	add	sp, #8
 8003754:	bd70      	pop	{r4, r5, r6, pc}
 8003756:	bf00      	nop

08003758 <bsec_n_Entity_serializeAndAdd>:
 8003758:	b570      	push	{r4, r5, r6, lr}
 800375a:	461c      	mov	r4, r3
 800375c:	681b      	ldr	r3, [r3, #0]
 800375e:	3308      	adds	r3, #8
 8003760:	4293      	cmp	r3, r2
 8003762:	b082      	sub	sp, #8
 8003764:	d903      	bls.n	800376e <bsec_n_Entity_serializeAndAdd+0x16>
 8003766:	3201      	adds	r2, #1
 8003768:	6022      	str	r2, [r4, #0]
 800376a:	b002      	add	sp, #8
 800376c:	bd70      	pop	{r4, r5, r6, pc}
 800376e:	2208      	movs	r2, #8
 8003770:	460d      	mov	r5, r1
 8003772:	4601      	mov	r1, r0
 8003774:	4668      	mov	r0, sp
 8003776:	f028 fcb3 	bl	802c0e0 <memcpy>
 800377a:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
 800377e:	2200      	movs	r2, #0
 8003780:	18a8      	adds	r0, r5, r2
 8003782:	6821      	ldr	r1, [r4, #0]
 8003784:	f813 6f01 	ldrb.w	r6, [r3, #1]!
 8003788:	5446      	strb	r6, [r0, r1]
 800378a:	3201      	adds	r2, #1
 800378c:	2a08      	cmp	r2, #8
 800378e:	d1f7      	bne.n	8003780 <bsec_n_Entity_serializeAndAdd+0x28>
 8003790:	6823      	ldr	r3, [r4, #0]
 8003792:	3308      	adds	r3, #8
 8003794:	6023      	str	r3, [r4, #0]
 8003796:	b002      	add	sp, #8
 8003798:	bd70      	pop	{r4, r5, r6, pc}
 800379a:	bf00      	nop

0800379c <bsec_o_Entity_parseAndDeserialize>:
 800379c:	b530      	push	{r4, r5, lr}
 800379e:	460c      	mov	r4, r1
 80037a0:	6809      	ldr	r1, [r1, #0]
 80037a2:	1845      	adds	r5, r0, r1
 80037a4:	b083      	sub	sp, #12
 80037a6:	4603      	mov	r3, r0
 80037a8:	4610      	mov	r0, r2
 80037aa:	786a      	ldrb	r2, [r5, #1]
 80037ac:	5c5b      	ldrb	r3, [r3, r1]
 80037ae:	f88d 2005 	strb.w	r2, [sp, #5]
 80037b2:	a901      	add	r1, sp, #4
 80037b4:	2202      	movs	r2, #2
 80037b6:	f88d 3004 	strb.w	r3, [sp, #4]
 80037ba:	f028 fc91 	bl	802c0e0 <memcpy>
 80037be:	6823      	ldr	r3, [r4, #0]
 80037c0:	3302      	adds	r3, #2
 80037c2:	6023      	str	r3, [r4, #0]
 80037c4:	b003      	add	sp, #12
 80037c6:	bd30      	pop	{r4, r5, pc}

080037c8 <bsec_o_Entity_serializeAndAdd>:
 80037c8:	b570      	push	{r4, r5, r6, lr}
 80037ca:	461d      	mov	r5, r3
 80037cc:	681b      	ldr	r3, [r3, #0]
 80037ce:	3314      	adds	r3, #20
 80037d0:	4293      	cmp	r3, r2
 80037d2:	b08a      	sub	sp, #40	; 0x28
 80037d4:	d903      	bls.n	80037de <bsec_o_Entity_serializeAndAdd+0x16>
 80037d6:	3201      	adds	r2, #1
 80037d8:	602a      	str	r2, [r5, #0]
 80037da:	b00a      	add	sp, #40	; 0x28
 80037dc:	bd70      	pop	{r4, r5, r6, pc}
 80037de:	2214      	movs	r2, #20
 80037e0:	eb0d 0402 	add.w	r4, sp, r2
 80037e4:	460e      	mov	r6, r1
 80037e6:	4601      	mov	r1, r0
 80037e8:	4668      	mov	r0, sp
 80037ea:	f028 fc79 	bl	802c0e0 <memcpy>
 80037ee:	4669      	mov	r1, sp
 80037f0:	2214      	movs	r2, #20
 80037f2:	4620      	mov	r0, r4
 80037f4:	f028 fc74 	bl	802c0e0 <memcpy>
 80037f8:	f1c4 0301 	rsb	r3, r4, #1
 80037fc:	f10d 0213 	add.w	r2, sp, #19
 8003800:	f10d 0127 	add.w	r1, sp, #39	; 0x27
 8003804:	682c      	ldr	r4, [r5, #0]
 8003806:	1898      	adds	r0, r3, r2
 8003808:	4420      	add	r0, r4
 800380a:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 800380e:	5434      	strb	r4, [r6, r0]
 8003810:	428a      	cmp	r2, r1
 8003812:	d1f7      	bne.n	8003804 <bsec_o_Entity_serializeAndAdd+0x3c>
 8003814:	682b      	ldr	r3, [r5, #0]
 8003816:	3314      	adds	r3, #20
 8003818:	602b      	str	r3, [r5, #0]
 800381a:	b00a      	add	sp, #40	; 0x28
 800381c:	bd70      	pop	{r4, r5, r6, pc}
 800381e:	bf00      	nop

08003820 <bsec_p_Entity_parseAndDeserialize>:
 8003820:	b510      	push	{r4, lr}
 8003822:	680b      	ldr	r3, [r1, #0]
 8003824:	b082      	sub	sp, #8
 8003826:	460c      	mov	r4, r1
 8003828:	5cc3      	ldrb	r3, [r0, r3]
 800382a:	f88d 3007 	strb.w	r3, [sp, #7]
 800382e:	2201      	movs	r2, #1
 8003830:	f10d 0107 	add.w	r1, sp, #7
 8003834:	f10d 0006 	add.w	r0, sp, #6
 8003838:	f028 fc52 	bl	802c0e0 <memcpy>
 800383c:	6823      	ldr	r3, [r4, #0]
 800383e:	f99d 0006 	ldrsb.w	r0, [sp, #6]
 8003842:	3301      	adds	r3, #1
 8003844:	6023      	str	r3, [r4, #0]
 8003846:	b002      	add	sp, #8
 8003848:	bd10      	pop	{r4, pc}
 800384a:	bf00      	nop

0800384c <bsec_p_Entity_serializeAndAdd>:
 800384c:	b570      	push	{r4, r5, r6, lr}
 800384e:	461c      	mov	r4, r3
 8003850:	681b      	ldr	r3, [r3, #0]
 8003852:	3303      	adds	r3, #3
 8003854:	4293      	cmp	r3, r2
 8003856:	b082      	sub	sp, #8
 8003858:	d903      	bls.n	8003862 <bsec_p_Entity_serializeAndAdd+0x16>
 800385a:	3201      	adds	r2, #1
 800385c:	6022      	str	r2, [r4, #0]
 800385e:	b002      	add	sp, #8
 8003860:	bd70      	pop	{r4, r5, r6, pc}
 8003862:	7802      	ldrb	r2, [r0, #0]
 8003864:	7846      	ldrb	r6, [r0, #1]
 8003866:	7883      	ldrb	r3, [r0, #2]
 8003868:	f88d 2000 	strb.w	r2, [sp]
 800386c:	460d      	mov	r5, r1
 800386e:	2203      	movs	r2, #3
 8003870:	4669      	mov	r1, sp
 8003872:	a801      	add	r0, sp, #4
 8003874:	f88d 3002 	strb.w	r3, [sp, #2]
 8003878:	f88d 6001 	strb.w	r6, [sp, #1]
 800387c:	f028 fc30 	bl	802c0e0 <memcpy>
 8003880:	6823      	ldr	r3, [r4, #0]
 8003882:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8003886:	54ea      	strb	r2, [r5, r3]
 8003888:	6823      	ldr	r3, [r4, #0]
 800388a:	f89d 1005 	ldrb.w	r1, [sp, #5]
 800388e:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8003892:	442b      	add	r3, r5
 8003894:	7059      	strb	r1, [r3, #1]
 8003896:	6821      	ldr	r1, [r4, #0]
 8003898:	4429      	add	r1, r5
 800389a:	708a      	strb	r2, [r1, #2]
 800389c:	6823      	ldr	r3, [r4, #0]
 800389e:	3303      	adds	r3, #3
 80038a0:	6023      	str	r3, [r4, #0]
 80038a2:	b002      	add	sp, #8
 80038a4:	bd70      	pop	{r4, r5, r6, pc}
 80038a6:	bf00      	nop

080038a8 <bsec_q_Entity_parseAndDeserialize>:
 80038a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80038aa:	680b      	ldr	r3, [r1, #0]
 80038ac:	b087      	sub	sp, #28
 80038ae:	4604      	mov	r4, r0
 80038b0:	3b01      	subs	r3, #1
 80038b2:	441c      	add	r4, r3
 80038b4:	460f      	mov	r7, r1
 80038b6:	4610      	mov	r0, r2
 80038b8:	ab01      	add	r3, sp, #4
 80038ba:	ae06      	add	r6, sp, #24
 80038bc:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80038c0:	f803 5b01 	strb.w	r5, [r3], #1
 80038c4:	42b3      	cmp	r3, r6
 80038c6:	d1f9      	bne.n	80038bc <bsec_q_Entity_parseAndDeserialize+0x14>
 80038c8:	a901      	add	r1, sp, #4
 80038ca:	2214      	movs	r2, #20
 80038cc:	f028 fc08 	bl	802c0e0 <memcpy>
 80038d0:	683b      	ldr	r3, [r7, #0]
 80038d2:	3314      	adds	r3, #20
 80038d4:	603b      	str	r3, [r7, #0]
 80038d6:	b007      	add	sp, #28
 80038d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80038da:	bf00      	nop

080038dc <bsec_q_Entity_serializeAndAdd>:
 80038dc:	b570      	push	{r4, r5, r6, lr}
 80038de:	461d      	mov	r5, r3
 80038e0:	681b      	ldr	r3, [r3, #0]
 80038e2:	3310      	adds	r3, #16
 80038e4:	4293      	cmp	r3, r2
 80038e6:	b084      	sub	sp, #16
 80038e8:	d903      	bls.n	80038f2 <bsec_q_Entity_serializeAndAdd+0x16>
 80038ea:	3201      	adds	r2, #1
 80038ec:	602a      	str	r2, [r5, #0]
 80038ee:	b004      	add	sp, #16
 80038f0:	bd70      	pop	{r4, r5, r6, pc}
 80038f2:	466c      	mov	r4, sp
 80038f4:	2210      	movs	r2, #16
 80038f6:	460e      	mov	r6, r1
 80038f8:	4601      	mov	r1, r0
 80038fa:	4620      	mov	r0, r4
 80038fc:	f028 fbf0 	bl	802c0e0 <memcpy>
 8003900:	f1c4 0001 	rsb	r0, r4, #1
 8003904:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 8003908:	f10d 010f 	add.w	r1, sp, #15
 800390c:	682b      	ldr	r3, [r5, #0]
 800390e:	1884      	adds	r4, r0, r2
 8003910:	441c      	add	r4, r3
 8003912:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003916:	5533      	strb	r3, [r6, r4]
 8003918:	428a      	cmp	r2, r1
 800391a:	d1f7      	bne.n	800390c <bsec_q_Entity_serializeAndAdd+0x30>
 800391c:	682b      	ldr	r3, [r5, #0]
 800391e:	3310      	adds	r3, #16
 8003920:	602b      	str	r3, [r5, #0]
 8003922:	b004      	add	sp, #16
 8003924:	bd70      	pop	{r4, r5, r6, pc}
 8003926:	bf00      	nop

08003928 <bsec_r_Entity_parseAndDeserialize>:
 8003928:	b530      	push	{r4, r5, lr}
 800392a:	680d      	ldr	r5, [r1, #0]
 800392c:	4603      	mov	r3, r0
 800392e:	b083      	sub	sp, #12
 8003930:	460c      	mov	r4, r1
 8003932:	1941      	adds	r1, r0, r5
 8003934:	4610      	mov	r0, r2
 8003936:	5d5a      	ldrb	r2, [r3, r5]
 8003938:	f88d 2004 	strb.w	r2, [sp, #4]
 800393c:	784d      	ldrb	r5, [r1, #1]
 800393e:	788b      	ldrb	r3, [r1, #2]
 8003940:	f88d 3006 	strb.w	r3, [sp, #6]
 8003944:	2203      	movs	r2, #3
 8003946:	a901      	add	r1, sp, #4
 8003948:	f88d 5005 	strb.w	r5, [sp, #5]
 800394c:	f028 fbc8 	bl	802c0e0 <memcpy>
 8003950:	6823      	ldr	r3, [r4, #0]
 8003952:	3303      	adds	r3, #3
 8003954:	6023      	str	r3, [r4, #0]
 8003956:	b003      	add	sp, #12
 8003958:	bd30      	pop	{r4, r5, pc}
 800395a:	bf00      	nop

0800395c <bsec_r_Entity_serializeAndAdd>:
 800395c:	b570      	push	{r4, r5, r6, lr}
 800395e:	461d      	mov	r5, r3
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8003966:	4293      	cmp	r3, r2
 8003968:	f5ad 7d02 	sub.w	sp, sp, #520	; 0x208
 800396c:	d904      	bls.n	8003978 <bsec_r_Entity_serializeAndAdd+0x1c>
 800396e:	3201      	adds	r2, #1
 8003970:	602a      	str	r2, [r5, #0]
 8003972:	f50d 7d02 	add.w	sp, sp, #520	; 0x208
 8003976:	bd70      	pop	{r4, r5, r6, pc}
 8003978:	f44f 7202 	mov.w	r2, #520	; 0x208
 800397c:	466c      	mov	r4, sp
 800397e:	460e      	mov	r6, r1
 8003980:	4601      	mov	r1, r0
 8003982:	480f      	ldr	r0, [pc, #60]	; (80039c0 <bsec_r_Entity_serializeAndAdd+0x64>)
 8003984:	f028 fbac 	bl	802c0e0 <memcpy>
 8003988:	490d      	ldr	r1, [pc, #52]	; (80039c0 <bsec_r_Entity_serializeAndAdd+0x64>)
 800398a:	f44f 7202 	mov.w	r2, #520	; 0x208
 800398e:	4620      	mov	r0, r4
 8003990:	f028 fba6 	bl	802c0e0 <memcpy>
 8003994:	f1c4 0301 	rsb	r3, r4, #1
 8003998:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 800399c:	f20d 2107 	addw	r1, sp, #519	; 0x207
 80039a0:	682c      	ldr	r4, [r5, #0]
 80039a2:	1898      	adds	r0, r3, r2
 80039a4:	4420      	add	r0, r4
 80039a6:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 80039aa:	5434      	strb	r4, [r6, r0]
 80039ac:	428a      	cmp	r2, r1
 80039ae:	d1f7      	bne.n	80039a0 <bsec_r_Entity_serializeAndAdd+0x44>
 80039b0:	682b      	ldr	r3, [r5, #0]
 80039b2:	f503 7302 	add.w	r3, r3, #520	; 0x208
 80039b6:	602b      	str	r3, [r5, #0]
 80039b8:	f50d 7d02 	add.w	sp, sp, #520	; 0x208
 80039bc:	bd70      	pop	{r4, r5, r6, pc}
 80039be:	bf00      	nop
 80039c0:	20011ae8 	.word	0x20011ae8

080039c4 <bsec_s_Entity_parseAndDeserialize>:
 80039c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80039c6:	680b      	ldr	r3, [r1, #0]
 80039c8:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
 80039cc:	4604      	mov	r4, r0
 80039ce:	3b01      	subs	r3, #1
 80039d0:	441c      	add	r4, r3
 80039d2:	460f      	mov	r7, r1
 80039d4:	4610      	mov	r0, r2
 80039d6:	466b      	mov	r3, sp
 80039d8:	ae82      	add	r6, sp, #520	; 0x208
 80039da:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 80039de:	f803 5b01 	strb.w	r5, [r3], #1
 80039e2:	42b3      	cmp	r3, r6
 80039e4:	d1f9      	bne.n	80039da <bsec_s_Entity_parseAndDeserialize+0x16>
 80039e6:	4669      	mov	r1, sp
 80039e8:	f44f 7202 	mov.w	r2, #520	; 0x208
 80039ec:	f028 fb78 	bl	802c0e0 <memcpy>
 80039f0:	683b      	ldr	r3, [r7, #0]
 80039f2:	f503 7302 	add.w	r3, r3, #520	; 0x208
 80039f6:	603b      	str	r3, [r7, #0]
 80039f8:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
 80039fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80039fe:	bf00      	nop

08003a00 <bsec_s_Entity_serializeAndAdd>:
 8003a00:	b570      	push	{r4, r5, r6, lr}
 8003a02:	461d      	mov	r5, r3
 8003a04:	681b      	ldr	r3, [r3, #0]
 8003a06:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8003a0a:	4293      	cmp	r3, r2
 8003a0c:	b0e4      	sub	sp, #400	; 0x190
 8003a0e:	d903      	bls.n	8003a18 <bsec_s_Entity_serializeAndAdd+0x18>
 8003a10:	3201      	adds	r2, #1
 8003a12:	602a      	str	r2, [r5, #0]
 8003a14:	b064      	add	sp, #400	; 0x190
 8003a16:	bd70      	pop	{r4, r5, r6, pc}
 8003a18:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8003a1c:	466c      	mov	r4, sp
 8003a1e:	460e      	mov	r6, r1
 8003a20:	4601      	mov	r1, r0
 8003a22:	480e      	ldr	r0, [pc, #56]	; (8003a5c <bsec_s_Entity_serializeAndAdd+0x5c>)
 8003a24:	f028 fb5c 	bl	802c0e0 <memcpy>
 8003a28:	490c      	ldr	r1, [pc, #48]	; (8003a5c <bsec_s_Entity_serializeAndAdd+0x5c>)
 8003a2a:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8003a2e:	4620      	mov	r0, r4
 8003a30:	f028 fb56 	bl	802c0e0 <memcpy>
 8003a34:	f1c4 0301 	rsb	r3, r4, #1
 8003a38:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 8003a3c:	f20d 118f 	addw	r1, sp, #399	; 0x18f
 8003a40:	682c      	ldr	r4, [r5, #0]
 8003a42:	1898      	adds	r0, r3, r2
 8003a44:	4420      	add	r0, r4
 8003a46:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003a4a:	5434      	strb	r4, [r6, r0]
 8003a4c:	428a      	cmp	r2, r1
 8003a4e:	d1f7      	bne.n	8003a40 <bsec_s_Entity_serializeAndAdd+0x40>
 8003a50:	682b      	ldr	r3, [r5, #0]
 8003a52:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8003a56:	602b      	str	r3, [r5, #0]
 8003a58:	b064      	add	sp, #400	; 0x190
 8003a5a:	bd70      	pop	{r4, r5, r6, pc}
 8003a5c:	20011cf0 	.word	0x20011cf0

08003a60 <bsec_t_Entity_parseAndDeserialize>:
 8003a60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003a62:	680b      	ldr	r3, [r1, #0]
 8003a64:	b0e5      	sub	sp, #404	; 0x194
 8003a66:	4604      	mov	r4, r0
 8003a68:	3b01      	subs	r3, #1
 8003a6a:	441c      	add	r4, r3
 8003a6c:	460f      	mov	r7, r1
 8003a6e:	4610      	mov	r0, r2
 8003a70:	466b      	mov	r3, sp
 8003a72:	ae64      	add	r6, sp, #400	; 0x190
 8003a74:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003a78:	f803 5b01 	strb.w	r5, [r3], #1
 8003a7c:	42b3      	cmp	r3, r6
 8003a7e:	d1f9      	bne.n	8003a74 <bsec_t_Entity_parseAndDeserialize+0x14>
 8003a80:	4669      	mov	r1, sp
 8003a82:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8003a86:	f028 fb2b 	bl	802c0e0 <memcpy>
 8003a8a:	683b      	ldr	r3, [r7, #0]
 8003a8c:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8003a90:	603b      	str	r3, [r7, #0]
 8003a92:	b065      	add	sp, #404	; 0x194
 8003a94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003a96:	bf00      	nop

08003a98 <bsec_t_Entity_serializeAndAdd>:
 8003a98:	b570      	push	{r4, r5, r6, lr}
 8003a9a:	461d      	mov	r5, r3
 8003a9c:	681b      	ldr	r3, [r3, #0]
 8003a9e:	33a0      	adds	r3, #160	; 0xa0
 8003aa0:	4293      	cmp	r3, r2
 8003aa2:	b0d0      	sub	sp, #320	; 0x140
 8003aa4:	d903      	bls.n	8003aae <bsec_t_Entity_serializeAndAdd+0x16>
 8003aa6:	3201      	adds	r2, #1
 8003aa8:	602a      	str	r2, [r5, #0]
 8003aaa:	b050      	add	sp, #320	; 0x140
 8003aac:	bd70      	pop	{r4, r5, r6, pc}
 8003aae:	22a0      	movs	r2, #160	; 0xa0
 8003ab0:	eb0d 0402 	add.w	r4, sp, r2
 8003ab4:	460e      	mov	r6, r1
 8003ab6:	4601      	mov	r1, r0
 8003ab8:	4668      	mov	r0, sp
 8003aba:	f028 fb11 	bl	802c0e0 <memcpy>
 8003abe:	4669      	mov	r1, sp
 8003ac0:	22a0      	movs	r2, #160	; 0xa0
 8003ac2:	4620      	mov	r0, r4
 8003ac4:	f028 fb0c 	bl	802c0e0 <memcpy>
 8003ac8:	f1c4 0301 	rsb	r3, r4, #1
 8003acc:	f10d 029f 	add.w	r2, sp, #159	; 0x9f
 8003ad0:	f20d 113f 	addw	r1, sp, #319	; 0x13f
 8003ad4:	682c      	ldr	r4, [r5, #0]
 8003ad6:	1898      	adds	r0, r3, r2
 8003ad8:	4420      	add	r0, r4
 8003ada:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003ade:	5434      	strb	r4, [r6, r0]
 8003ae0:	428a      	cmp	r2, r1
 8003ae2:	d1f7      	bne.n	8003ad4 <bsec_t_Entity_serializeAndAdd+0x3c>
 8003ae4:	682b      	ldr	r3, [r5, #0]
 8003ae6:	33a0      	adds	r3, #160	; 0xa0
 8003ae8:	602b      	str	r3, [r5, #0]
 8003aea:	b050      	add	sp, #320	; 0x140
 8003aec:	bd70      	pop	{r4, r5, r6, pc}
 8003aee:	bf00      	nop

08003af0 <bsec_u_Entity_parseAndDeserialize>:
 8003af0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003af2:	680b      	ldr	r3, [r1, #0]
 8003af4:	b0a9      	sub	sp, #164	; 0xa4
 8003af6:	4604      	mov	r4, r0
 8003af8:	3b01      	subs	r3, #1
 8003afa:	441c      	add	r4, r3
 8003afc:	460f      	mov	r7, r1
 8003afe:	4610      	mov	r0, r2
 8003b00:	466b      	mov	r3, sp
 8003b02:	ae28      	add	r6, sp, #160	; 0xa0
 8003b04:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003b08:	f803 5b01 	strb.w	r5, [r3], #1
 8003b0c:	42b3      	cmp	r3, r6
 8003b0e:	d1f9      	bne.n	8003b04 <bsec_u_Entity_parseAndDeserialize+0x14>
 8003b10:	4669      	mov	r1, sp
 8003b12:	22a0      	movs	r2, #160	; 0xa0
 8003b14:	f028 fae4 	bl	802c0e0 <memcpy>
 8003b18:	683b      	ldr	r3, [r7, #0]
 8003b1a:	33a0      	adds	r3, #160	; 0xa0
 8003b1c:	603b      	str	r3, [r7, #0]
 8003b1e:	b029      	add	sp, #164	; 0xa4
 8003b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b22:	bf00      	nop

08003b24 <bsec_u_Entity_serializeAndAdd>:
 8003b24:	b530      	push	{r4, r5, lr}
 8003b26:	461c      	mov	r4, r3
 8003b28:	681b      	ldr	r3, [r3, #0]
 8003b2a:	3303      	adds	r3, #3
 8003b2c:	4293      	cmp	r3, r2
 8003b2e:	b083      	sub	sp, #12
 8003b30:	d903      	bls.n	8003b3a <bsec_u_Entity_serializeAndAdd+0x16>
 8003b32:	3201      	adds	r2, #1
 8003b34:	6022      	str	r2, [r4, #0]
 8003b36:	b003      	add	sp, #12
 8003b38:	bd30      	pop	{r4, r5, pc}
 8003b3a:	460d      	mov	r5, r1
 8003b3c:	2203      	movs	r2, #3
 8003b3e:	4601      	mov	r1, r0
 8003b40:	a801      	add	r0, sp, #4
 8003b42:	f028 facd 	bl	802c0e0 <memcpy>
 8003b46:	6823      	ldr	r3, [r4, #0]
 8003b48:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8003b4c:	54ea      	strb	r2, [r5, r3]
 8003b4e:	6823      	ldr	r3, [r4, #0]
 8003b50:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8003b54:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8003b58:	442b      	add	r3, r5
 8003b5a:	7059      	strb	r1, [r3, #1]
 8003b5c:	6821      	ldr	r1, [r4, #0]
 8003b5e:	4429      	add	r1, r5
 8003b60:	708a      	strb	r2, [r1, #2]
 8003b62:	6823      	ldr	r3, [r4, #0]
 8003b64:	3303      	adds	r3, #3
 8003b66:	6023      	str	r3, [r4, #0]
 8003b68:	b003      	add	sp, #12
 8003b6a:	bd30      	pop	{r4, r5, pc}

08003b6c <bsec_v_Entity_parseAndDeserialize>:
 8003b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b6e:	680b      	ldr	r3, [r1, #0]
 8003b70:	b0dd      	sub	sp, #372	; 0x174
 8003b72:	4604      	mov	r4, r0
 8003b74:	3b01      	subs	r3, #1
 8003b76:	441c      	add	r4, r3
 8003b78:	460f      	mov	r7, r1
 8003b7a:	4610      	mov	r0, r2
 8003b7c:	ab01      	add	r3, sp, #4
 8003b7e:	ae5c      	add	r6, sp, #368	; 0x170
 8003b80:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003b84:	f803 5b01 	strb.w	r5, [r3], #1
 8003b88:	42b3      	cmp	r3, r6
 8003b8a:	d1f9      	bne.n	8003b80 <bsec_v_Entity_parseAndDeserialize+0x14>
 8003b8c:	a901      	add	r1, sp, #4
 8003b8e:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 8003b92:	f028 faa5 	bl	802c0e0 <memcpy>
 8003b96:	683b      	ldr	r3, [r7, #0]
 8003b98:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8003b9c:	603b      	str	r3, [r7, #0]
 8003b9e:	b05d      	add	sp, #372	; 0x174
 8003ba0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003ba2:	bf00      	nop

08003ba4 <bsec_v_Entity_serializeAndAdd>:
 8003ba4:	b570      	push	{r4, r5, r6, lr}
 8003ba6:	461d      	mov	r5, r3
 8003ba8:	681b      	ldr	r3, [r3, #0]
 8003baa:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8003bae:	4293      	cmp	r3, r2
 8003bb0:	f5ad 7d36 	sub.w	sp, sp, #728	; 0x2d8
 8003bb4:	d904      	bls.n	8003bc0 <bsec_v_Entity_serializeAndAdd+0x1c>
 8003bb6:	3201      	adds	r2, #1
 8003bb8:	602a      	str	r2, [r5, #0]
 8003bba:	f50d 7d36 	add.w	sp, sp, #728	; 0x2d8
 8003bbe:	bd70      	pop	{r4, r5, r6, pc}
 8003bc0:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 8003bc4:	eb0d 0402 	add.w	r4, sp, r2
 8003bc8:	460e      	mov	r6, r1
 8003bca:	4601      	mov	r1, r0
 8003bcc:	4668      	mov	r0, sp
 8003bce:	f028 fa87 	bl	802c0e0 <memcpy>
 8003bd2:	4669      	mov	r1, sp
 8003bd4:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 8003bd8:	4620      	mov	r0, r4
 8003bda:	f028 fa81 	bl	802c0e0 <memcpy>
 8003bde:	f1c4 0301 	rsb	r3, r4, #1
 8003be2:	f20d 126b 	addw	r2, sp, #363	; 0x16b
 8003be6:	f20d 21d7 	addw	r1, sp, #727	; 0x2d7
 8003bea:	682c      	ldr	r4, [r5, #0]
 8003bec:	1898      	adds	r0, r3, r2
 8003bee:	4420      	add	r0, r4
 8003bf0:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003bf4:	5434      	strb	r4, [r6, r0]
 8003bf6:	428a      	cmp	r2, r1
 8003bf8:	d1f7      	bne.n	8003bea <bsec_v_Entity_serializeAndAdd+0x46>
 8003bfa:	682b      	ldr	r3, [r5, #0]
 8003bfc:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8003c00:	602b      	str	r3, [r5, #0]
 8003c02:	f50d 7d36 	add.w	sp, sp, #728	; 0x2d8
 8003c06:	bd70      	pop	{r4, r5, r6, pc}

08003c08 <bsec_w_Entity_parseAndDeserialize>:
 8003c08:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003c0a:	680b      	ldr	r3, [r1, #0]
 8003c0c:	b08f      	sub	sp, #60	; 0x3c
 8003c0e:	4604      	mov	r4, r0
 8003c10:	3b01      	subs	r3, #1
 8003c12:	441c      	add	r4, r3
 8003c14:	460f      	mov	r7, r1
 8003c16:	4610      	mov	r0, r2
 8003c18:	ab01      	add	r3, sp, #4
 8003c1a:	ae0e      	add	r6, sp, #56	; 0x38
 8003c1c:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 8003c20:	f803 5b01 	strb.w	r5, [r3], #1
 8003c24:	42b3      	cmp	r3, r6
 8003c26:	d1f9      	bne.n	8003c1c <bsec_w_Entity_parseAndDeserialize+0x14>
 8003c28:	a901      	add	r1, sp, #4
 8003c2a:	2234      	movs	r2, #52	; 0x34
 8003c2c:	f028 fa58 	bl	802c0e0 <memcpy>
 8003c30:	683b      	ldr	r3, [r7, #0]
 8003c32:	3334      	adds	r3, #52	; 0x34
 8003c34:	603b      	str	r3, [r7, #0]
 8003c36:	b00f      	add	sp, #60	; 0x3c
 8003c38:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c3a:	bf00      	nop

08003c3c <bsec_w_Entity_serializeAndAdd>:
 8003c3c:	b570      	push	{r4, r5, r6, lr}
 8003c3e:	461d      	mov	r5, r3
 8003c40:	681b      	ldr	r3, [r3, #0]
 8003c42:	3334      	adds	r3, #52	; 0x34
 8003c44:	4293      	cmp	r3, r2
 8003c46:	b08e      	sub	sp, #56	; 0x38
 8003c48:	d903      	bls.n	8003c52 <bsec_w_Entity_serializeAndAdd+0x16>
 8003c4a:	3201      	adds	r2, #1
 8003c4c:	602a      	str	r2, [r5, #0]
 8003c4e:	b00e      	add	sp, #56	; 0x38
 8003c50:	bd70      	pop	{r4, r5, r6, pc}
 8003c52:	ac01      	add	r4, sp, #4
 8003c54:	2234      	movs	r2, #52	; 0x34
 8003c56:	460e      	mov	r6, r1
 8003c58:	4601      	mov	r1, r0
 8003c5a:	4620      	mov	r0, r4
 8003c5c:	f028 fa40 	bl	802c0e0 <memcpy>
 8003c60:	f1c4 0301 	rsb	r3, r4, #1
 8003c64:	f10d 0203 	add.w	r2, sp, #3
 8003c68:	f10d 0137 	add.w	r1, sp, #55	; 0x37
 8003c6c:	682c      	ldr	r4, [r5, #0]
 8003c6e:	1898      	adds	r0, r3, r2
 8003c70:	4420      	add	r0, r4
 8003c72:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003c76:	5434      	strb	r4, [r6, r0]
 8003c78:	428a      	cmp	r2, r1
 8003c7a:	d1f7      	bne.n	8003c6c <bsec_w_Entity_serializeAndAdd+0x30>
 8003c7c:	682b      	ldr	r3, [r5, #0]
 8003c7e:	3334      	adds	r3, #52	; 0x34
 8003c80:	602b      	str	r3, [r5, #0]
 8003c82:	b00e      	add	sp, #56	; 0x38
 8003c84:	bd70      	pop	{r4, r5, r6, pc}
 8003c86:	bf00      	nop

08003c88 <bsec_x_Entity_serializeAndAdd>:
 8003c88:	b570      	push	{r4, r5, r6, lr}
 8003c8a:	461d      	mov	r5, r3
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	3318      	adds	r3, #24
 8003c90:	4293      	cmp	r3, r2
 8003c92:	b08c      	sub	sp, #48	; 0x30
 8003c94:	d903      	bls.n	8003c9e <bsec_x_Entity_serializeAndAdd+0x16>
 8003c96:	3201      	adds	r2, #1
 8003c98:	602a      	str	r2, [r5, #0]
 8003c9a:	b00c      	add	sp, #48	; 0x30
 8003c9c:	bd70      	pop	{r4, r5, r6, pc}
 8003c9e:	2218      	movs	r2, #24
 8003ca0:	eb0d 0402 	add.w	r4, sp, r2
 8003ca4:	460e      	mov	r6, r1
 8003ca6:	4601      	mov	r1, r0
 8003ca8:	4668      	mov	r0, sp
 8003caa:	f028 fa19 	bl	802c0e0 <memcpy>
 8003cae:	4669      	mov	r1, sp
 8003cb0:	2218      	movs	r2, #24
 8003cb2:	4620      	mov	r0, r4
 8003cb4:	f028 fa14 	bl	802c0e0 <memcpy>
 8003cb8:	f1c4 0301 	rsb	r3, r4, #1
 8003cbc:	f10d 0217 	add.w	r2, sp, #23
 8003cc0:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
 8003cc4:	682c      	ldr	r4, [r5, #0]
 8003cc6:	1898      	adds	r0, r3, r2
 8003cc8:	4420      	add	r0, r4
 8003cca:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003cce:	5434      	strb	r4, [r6, r0]
 8003cd0:	428a      	cmp	r2, r1
 8003cd2:	d1f7      	bne.n	8003cc4 <bsec_x_Entity_serializeAndAdd+0x3c>
 8003cd4:	682b      	ldr	r3, [r5, #0]
 8003cd6:	3318      	adds	r3, #24
 8003cd8:	602b      	str	r3, [r5, #0]
 8003cda:	b00c      	add	sp, #48	; 0x30
 8003cdc:	bd70      	pop	{r4, r5, r6, pc}
 8003cde:	bf00      	nop

08003ce0 <bsec_y_Entity_serializeAndAdd>:
 8003ce0:	b570      	push	{r4, r5, r6, lr}
 8003ce2:	461d      	mov	r5, r3
 8003ce4:	681b      	ldr	r3, [r3, #0]
 8003ce6:	33e4      	adds	r3, #228	; 0xe4
 8003ce8:	4293      	cmp	r3, r2
 8003cea:	b0f2      	sub	sp, #456	; 0x1c8
 8003cec:	d903      	bls.n	8003cf6 <bsec_y_Entity_serializeAndAdd+0x16>
 8003cee:	3201      	adds	r2, #1
 8003cf0:	602a      	str	r2, [r5, #0]
 8003cf2:	b072      	add	sp, #456	; 0x1c8
 8003cf4:	bd70      	pop	{r4, r5, r6, pc}
 8003cf6:	22e4      	movs	r2, #228	; 0xe4
 8003cf8:	eb0d 0402 	add.w	r4, sp, r2
 8003cfc:	460e      	mov	r6, r1
 8003cfe:	4601      	mov	r1, r0
 8003d00:	4668      	mov	r0, sp
 8003d02:	f028 f9ed 	bl	802c0e0 <memcpy>
 8003d06:	4669      	mov	r1, sp
 8003d08:	22e4      	movs	r2, #228	; 0xe4
 8003d0a:	4620      	mov	r0, r4
 8003d0c:	f028 f9e8 	bl	802c0e0 <memcpy>
 8003d10:	f1c4 0301 	rsb	r3, r4, #1
 8003d14:	f10d 02e3 	add.w	r2, sp, #227	; 0xe3
 8003d18:	f20d 11c7 	addw	r1, sp, #455	; 0x1c7
 8003d1c:	682c      	ldr	r4, [r5, #0]
 8003d1e:	1898      	adds	r0, r3, r2
 8003d20:	4420      	add	r0, r4
 8003d22:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8003d26:	5434      	strb	r4, [r6, r0]
 8003d28:	428a      	cmp	r2, r1
 8003d2a:	d1f7      	bne.n	8003d1c <bsec_y_Entity_serializeAndAdd+0x3c>
 8003d2c:	682b      	ldr	r3, [r5, #0]
 8003d2e:	33e4      	adds	r3, #228	; 0xe4
 8003d30:	602b      	str	r3, [r5, #0]
 8003d32:	b072      	add	sp, #456	; 0x1c8
 8003d34:	bd70      	pop	{r4, r5, r6, pc}
 8003d36:	bf00      	nop

08003d38 <bsec_GasEstimator_applyTransferFunction>:
 8003d38:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003d3a:	ed2d 8b04 	vpush	{d8-d9}
 8003d3e:	b08b      	sub	sp, #44	; 0x2c
 8003d40:	4605      	mov	r5, r0
 8003d42:	460c      	mov	r4, r1
 8003d44:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 8003d48:	4616      	mov	r6, r2
 8003d4a:	f004 f985 	bl	8008058 <__aeabi_d2iz>
 8003d4e:	4428      	add	r0, r5
 8003d50:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003d54:	2b01      	cmp	r3, #1
 8003d56:	d00b      	beq.n	8003d70 <bsec_GasEstimator_applyTransferFunction+0x38>
 8003d58:	2b02      	cmp	r3, #2
 8003d5a:	d040      	beq.n	8003dde <bsec_GasEstimator_applyTransferFunction+0xa6>
 8003d5c:	b363      	cbz	r3, 8003db8 <bsec_GasEstimator_applyTransferFunction+0x80>
 8003d5e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8003d60:	4621      	mov	r1, r4
 8003d62:	2228      	movs	r2, #40	; 0x28
 8003d64:	f028 f9bc 	bl	802c0e0 <memcpy>
 8003d68:	b00b      	add	sp, #44	; 0x2c
 8003d6a:	ecbd 8b04 	vpop	{d8-d9}
 8003d6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003d70:	9816      	ldr	r0, [sp, #88]	; 0x58
 8003d72:	2228      	movs	r2, #40	; 0x28
 8003d74:	4621      	mov	r1, r4
 8003d76:	f028 f9b3 	bl	802c0e0 <memcpy>
 8003d7a:	2e00      	cmp	r6, #0
 8003d7c:	d0f4      	beq.n	8003d68 <bsec_GasEstimator_applyTransferFunction+0x30>
 8003d7e:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8003d80:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8003d84:	eeb8 9a00 	vmov.f32	s18, #128	; 0xc0000000 -2.0
 8003d88:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8003d8c:	eef0 8a00 	vmov.f32	s17, #0	; 0x40000000  2.0
 8003d90:	ecb4 0a01 	vldmia	r4!, {s0}
 8003d94:	ee20 0a09 	vmul.f32	s0, s0, s18
 8003d98:	f025 fdb6 	bl	8029908 <expf>
 8003d9c:	ee30 0a08 	vadd.f32	s0, s0, s16
 8003da0:	42a6      	cmp	r6, r4
 8003da2:	eec8 7a80 	vdiv.f32	s15, s17, s0
 8003da6:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8003daa:	ece5 7a01 	vstmia	r5!, {s15}
 8003dae:	d1ef      	bne.n	8003d90 <bsec_GasEstimator_applyTransferFunction+0x58>
 8003db0:	b00b      	add	sp, #44	; 0x2c
 8003db2:	ecbd 8b04 	vpop	{d8-d9}
 8003db6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003db8:	ed9f 8a29 	vldr	s16, [pc, #164]	; 8003e60 <bsec_GasEstimator_applyTransferFunction+0x128>
 8003dbc:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8003dbe:	f104 0628 	add.w	r6, r4, #40	; 0x28
 8003dc2:	ecf4 0a01 	vldmia	r4!, {s1}
 8003dc6:	eeb0 0a48 	vmov.f32	s0, s16
 8003dca:	f025 fbf9 	bl	80295c0 <fmaxf>
 8003dce:	42a6      	cmp	r6, r4
 8003dd0:	eca5 0a01 	vstmia	r5!, {s0}
 8003dd4:	d1f5      	bne.n	8003dc2 <bsec_GasEstimator_applyTransferFunction+0x8a>
 8003dd6:	b00b      	add	sp, #44	; 0x2c
 8003dd8:	ecbd 8b04 	vpop	{d8-d9}
 8003ddc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003dde:	4621      	mov	r1, r4
 8003de0:	4668      	mov	r0, sp
 8003de2:	2228      	movs	r2, #40	; 0x28
 8003de4:	f028 f97c 	bl	802c0e0 <memcpy>
 8003de8:	ed9d 0a00 	vldr	s0, [sp]
 8003dec:	ad01      	add	r5, sp, #4
 8003dee:	eeb0 8a40 	vmov.f32	s16, s0
 8003df2:	462b      	mov	r3, r5
 8003df4:	af0a      	add	r7, sp, #40	; 0x28
 8003df6:	ecf3 7a01 	vldmia	r3!, {s15}
 8003dfa:	eef4 7a48 	vcmp.f32	s15, s16
 8003dfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003e02:	bfc8      	it	gt
 8003e04:	eeb0 8a67 	vmovgt.f32	s16, s15
 8003e08:	42bb      	cmp	r3, r7
 8003e0a:	d1f4      	bne.n	8003df6 <bsec_GasEstimator_applyTransferFunction+0xbe>
 8003e0c:	b17e      	cbz	r6, 8003e2e <bsec_GasEstimator_applyTransferFunction+0xf6>
 8003e0e:	eb0d 0686 	add.w	r6, sp, r6, lsl #2
 8003e12:	462c      	mov	r4, r5
 8003e14:	e001      	b.n	8003e1a <bsec_GasEstimator_applyTransferFunction+0xe2>
 8003e16:	ecb4 0a01 	vldmia	r4!, {s0}
 8003e1a:	ee30 0a48 	vsub.f32	s0, s0, s16
 8003e1e:	f025 fd73 	bl	8029908 <expf>
 8003e22:	42a6      	cmp	r6, r4
 8003e24:	ed04 0a01 	vstr	s0, [r4, #-4]
 8003e28:	d1f5      	bne.n	8003e16 <bsec_GasEstimator_applyTransferFunction+0xde>
 8003e2a:	ed9d 0a00 	vldr	s0, [sp]
 8003e2e:	eef0 7a40 	vmov.f32	s15, s0
 8003e32:	462b      	mov	r3, r5
 8003e34:	ecb3 7a01 	vldmia	r3!, {s14}
 8003e38:	42bb      	cmp	r3, r7
 8003e3a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8003e3e:	d1f9      	bne.n	8003e34 <bsec_GasEstimator_applyTransferFunction+0xfc>
 8003e40:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8003e42:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8003e46:	e001      	b.n	8003e4c <bsec_GasEstimator_applyTransferFunction+0x114>
 8003e48:	ecb5 0a01 	vldmia	r5!, {s0}
 8003e4c:	ee80 7a27 	vdiv.f32	s14, s0, s15
 8003e50:	eca3 7a01 	vstmia	r3!, {s14}
 8003e54:	4293      	cmp	r3, r2
 8003e56:	d1f7      	bne.n	8003e48 <bsec_GasEstimator_applyTransferFunction+0x110>
 8003e58:	b00b      	add	sp, #44	; 0x2c
 8003e5a:	ecbd 8b04 	vpop	{d8-d9}
 8003e5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003e60:	00000000 	.word	0x00000000

08003e64 <bsec_b_GasEstimator_applyTransferFunction.constprop.0>:
 8003e64:	b570      	push	{r4, r5, r6, lr}
 8003e66:	ed2d 8b04 	vpush	{d8-d9}
 8003e6a:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 8003e6e:	2801      	cmp	r0, #1
 8003e70:	b084      	sub	sp, #16
 8003e72:	4616      	mov	r6, r2
 8003e74:	461c      	mov	r4, r3
 8003e76:	460d      	mov	r5, r1
 8003e78:	d00a      	beq.n	8003e90 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x2c>
 8003e7a:	2802      	cmp	r0, #2
 8003e7c:	d04e      	beq.n	8003f1c <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0xb8>
 8003e7e:	b348      	cbz	r0, 8003ed4 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x70>
 8003e80:	4618      	mov	r0, r3
 8003e82:	2210      	movs	r2, #16
 8003e84:	f028 f92c 	bl	802c0e0 <memcpy>
 8003e88:	b004      	add	sp, #16
 8003e8a:	ecbd 8b04 	vpop	{d8-d9}
 8003e8e:	bd70      	pop	{r4, r5, r6, pc}
 8003e90:	2210      	movs	r2, #16
 8003e92:	4618      	mov	r0, r3
 8003e94:	f028 f924 	bl	802c0e0 <memcpy>
 8003e98:	2e00      	cmp	r6, #0
 8003e9a:	d0f5      	beq.n	8003e88 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x24>
 8003e9c:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 8003ea0:	eeb8 9a00 	vmov.f32	s18, #128	; 0xc0000000 -2.0
 8003ea4:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8003ea8:	eef0 8a00 	vmov.f32	s17, #0	; 0x40000000  2.0
 8003eac:	ecb5 0a01 	vldmia	r5!, {s0}
 8003eb0:	ee20 0a09 	vmul.f32	s0, s0, s18
 8003eb4:	f025 fd28 	bl	8029908 <expf>
 8003eb8:	ee30 0a08 	vadd.f32	s0, s0, s16
 8003ebc:	42ae      	cmp	r6, r5
 8003ebe:	eec8 7a80 	vdiv.f32	s15, s17, s0
 8003ec2:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8003ec6:	ece4 7a01 	vstmia	r4!, {s15}
 8003eca:	d1ef      	bne.n	8003eac <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x48>
 8003ecc:	b004      	add	sp, #16
 8003ece:	ecbd 8b04 	vpop	{d8-d9}
 8003ed2:	bd70      	pop	{r4, r5, r6, pc}
 8003ed4:	edd1 0a00 	vldr	s1, [r1]
 8003ed8:	ed9f 0a3a 	vldr	s0, [pc, #232]	; 8003fc4 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x160>
 8003edc:	f025 fb70 	bl	80295c0 <fmaxf>
 8003ee0:	ed84 0a00 	vstr	s0, [r4]
 8003ee4:	edd5 0a01 	vldr	s1, [r5, #4]
 8003ee8:	ed9f 0a36 	vldr	s0, [pc, #216]	; 8003fc4 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x160>
 8003eec:	f025 fb68 	bl	80295c0 <fmaxf>
 8003ef0:	ed84 0a01 	vstr	s0, [r4, #4]
 8003ef4:	edd5 0a02 	vldr	s1, [r5, #8]
 8003ef8:	ed9f 0a32 	vldr	s0, [pc, #200]	; 8003fc4 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x160>
 8003efc:	f025 fb60 	bl	80295c0 <fmaxf>
 8003f00:	ed84 0a02 	vstr	s0, [r4, #8]
 8003f04:	edd5 0a03 	vldr	s1, [r5, #12]
 8003f08:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 8003fc4 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x160>
 8003f0c:	f025 fb58 	bl	80295c0 <fmaxf>
 8003f10:	ed84 0a03 	vstr	s0, [r4, #12]
 8003f14:	b004      	add	sp, #16
 8003f16:	ecbd 8b04 	vpop	{d8-d9}
 8003f1a:	bd70      	pop	{r4, r5, r6, pc}
 8003f1c:	4668      	mov	r0, sp
 8003f1e:	2210      	movs	r2, #16
 8003f20:	f028 f8de 	bl	802c0e0 <memcpy>
 8003f24:	ed9d 0a00 	vldr	s0, [sp]
 8003f28:	ed9d 6a01 	vldr	s12, [sp, #4]
 8003f2c:	eddd 6a02 	vldr	s13, [sp, #8]
 8003f30:	ed9d 7a03 	vldr	s14, [sp, #12]
 8003f34:	eeb4 0ac6 	vcmpe.f32	s0, s12
 8003f38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003f3c:	bf54      	ite	pl
 8003f3e:	eeb0 8a40 	vmovpl.f32	s16, s0
 8003f42:	eeb0 8a46 	vmovmi.f32	s16, s12
 8003f46:	eef4 6a48 	vcmp.f32	s13, s16
 8003f4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003f4e:	bfc8      	it	gt
 8003f50:	eeb0 8a66 	vmovgt.f32	s16, s13
 8003f54:	eeb4 7a48 	vcmp.f32	s14, s16
 8003f58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003f5c:	bfc8      	it	gt
 8003f5e:	eeb0 8a47 	vmovgt.f32	s16, s14
 8003f62:	b1ae      	cbz	r6, 8003f90 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x12c>
 8003f64:	eb0d 0686 	add.w	r6, sp, r6, lsl #2
 8003f68:	ad01      	add	r5, sp, #4
 8003f6a:	e001      	b.n	8003f70 <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x10c>
 8003f6c:	ecb5 0a01 	vldmia	r5!, {s0}
 8003f70:	ee30 0a48 	vsub.f32	s0, s0, s16
 8003f74:	f025 fcc8 	bl	8029908 <expf>
 8003f78:	42b5      	cmp	r5, r6
 8003f7a:	ed05 0a01 	vstr	s0, [r5, #-4]
 8003f7e:	d1f5      	bne.n	8003f6c <bsec_b_GasEstimator_applyTransferFunction.constprop.0+0x108>
 8003f80:	ed9d 0a00 	vldr	s0, [sp]
 8003f84:	ed9d 6a01 	vldr	s12, [sp, #4]
 8003f88:	eddd 6a02 	vldr	s13, [sp, #8]
 8003f8c:	ed9d 7a03 	vldr	s14, [sp, #12]
 8003f90:	ee70 7a06 	vadd.f32	s15, s0, s12
 8003f94:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003f98:	ee77 7a87 	vadd.f32	s15, s15, s14
 8003f9c:	eec6 5a27 	vdiv.f32	s11, s12, s15
 8003fa0:	ee80 5a27 	vdiv.f32	s10, s0, s15
 8003fa4:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 8003fa8:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8003fac:	ed84 5a00 	vstr	s10, [r4]
 8003fb0:	edc4 5a01 	vstr	s11, [r4, #4]
 8003fb4:	ed84 6a02 	vstr	s12, [r4, #8]
 8003fb8:	edc4 6a03 	vstr	s13, [r4, #12]
 8003fbc:	b004      	add	sp, #16
 8003fbe:	ecbd 8b04 	vpop	{d8-d9}
 8003fc2:	bd70      	pop	{r4, r5, r6, pc}
 8003fc4:	00000000 	.word	0x00000000

08003fc8 <bsec_GasEstimator_GasEstimator>:
 8003fc8:	2300      	movs	r3, #0
 8003fca:	b430      	push	{r4, r5}
 8003fcc:	2202      	movs	r2, #2
 8003fce:	250b      	movs	r5, #11
 8003fd0:	f240 1401 	movw	r4, #257	; 0x101
 8003fd4:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
 8003fd8:	f8a0 36e4 	strh.w	r3, [r0, #1764]	; 0x6e4
 8003fdc:	f880 36e6 	strb.w	r3, [r0, #1766]	; 0x6e6
 8003fe0:	2100      	movs	r1, #0
 8003fe2:	7005      	strb	r5, [r0, #0]
 8003fe4:	8744      	strh	r4, [r0, #58]	; 0x3a
 8003fe6:	f100 0340 	add.w	r3, r0, #64	; 0x40
 8003fea:	f100 0268 	add.w	r2, r0, #104	; 0x68
 8003fee:	f843 1b04 	str.w	r1, [r3], #4
 8003ff2:	4293      	cmp	r3, r2
 8003ff4:	d1fb      	bne.n	8003fee <bsec_GasEstimator_GasEstimator+0x26>
 8003ff6:	2200      	movs	r2, #0
 8003ff8:	f100 0190 	add.w	r1, r0, #144	; 0x90
 8003ffc:	f843 2b04 	str.w	r2, [r3], #4
 8004000:	428b      	cmp	r3, r1
 8004002:	d1fb      	bne.n	8003ffc <bsec_GasEstimator_GasEstimator+0x34>
 8004004:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
 8004008:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
 800400c:	f8c0 2098 	str.w	r2, [r0, #152]	; 0x98
 8004010:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
 8004014:	f100 03a0 	add.w	r3, r0, #160	; 0xa0
 8004018:	f500 712a 	add.w	r1, r0, #680	; 0x2a8
 800401c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8004020:	f843 2b04 	str.w	r2, [r3], #4
 8004024:	428b      	cmp	r3, r1
 8004026:	d1fb      	bne.n	8004020 <bsec_GasEstimator_GasEstimator+0x58>
 8004028:	f500 6187 	add.w	r1, r0, #1080	; 0x438
 800402c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8004030:	f843 2b04 	str.w	r2, [r3], #4
 8004034:	428b      	cmp	r3, r1
 8004036:	d1fb      	bne.n	8004030 <bsec_GasEstimator_GasEstimator+0x68>
 8004038:	f500 619b 	add.w	r1, r0, #1240	; 0x4d8
 800403c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8004040:	f843 2b04 	str.w	r2, [r3], #4
 8004044:	428b      	cmp	r3, r1
 8004046:	d1fb      	bne.n	8004040 <bsec_GasEstimator_GasEstimator+0x78>
 8004048:	f640 220a 	movw	r2, #2570	; 0xa0a
 800404c:	2304      	movs	r3, #4
 800404e:	f8a0 24d8 	strh.w	r2, [r0, #1240]	; 0x4d8
 8004052:	f880 34da 	strb.w	r3, [r0, #1242]	; 0x4da
 8004056:	2100      	movs	r1, #0
 8004058:	f200 43dc 	addw	r3, r0, #1244	; 0x4dc
 800405c:	f500 62c9 	add.w	r2, r0, #1608	; 0x648
 8004060:	f843 1b04 	str.w	r1, [r3], #4
 8004064:	4293      	cmp	r3, r2
 8004066:	d1fb      	bne.n	8004060 <bsec_GasEstimator_GasEstimator+0x98>
 8004068:	2100      	movs	r1, #0
 800406a:	f200 627c 	addw	r2, r0, #1660	; 0x67c
 800406e:	f843 1b04 	str.w	r1, [r3], #4
 8004072:	429a      	cmp	r2, r3
 8004074:	d1fb      	bne.n	800406e <bsec_GasEstimator_GasEstimator+0xa6>
 8004076:	2100      	movs	r1, #0
 8004078:	f500 63d6 	add.w	r3, r0, #1712	; 0x6b0
 800407c:	f842 1b04 	str.w	r1, [r2], #4
 8004080:	4293      	cmp	r3, r2
 8004082:	d1fb      	bne.n	800407c <bsec_GasEstimator_GasEstimator+0xb4>
 8004084:	f200 61e4 	addw	r1, r0, #1764	; 0x6e4
 8004088:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 800408c:	f843 2b04 	str.w	r2, [r3], #4
 8004090:	428b      	cmp	r3, r1
 8004092:	d1fb      	bne.n	800408c <bsec_GasEstimator_GasEstimator+0xc4>
 8004094:	2200      	movs	r2, #0
 8004096:	1d03      	adds	r3, r0, #4
 8004098:	f100 012c 	add.w	r1, r0, #44	; 0x2c
 800409c:	f843 2b04 	str.w	r2, [r3], #4
 80040a0:	428b      	cmp	r3, r1
 80040a2:	d1fb      	bne.n	800409c <bsec_GasEstimator_GasEstimator+0xd4>
 80040a4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80040a8:	bc30      	pop	{r4, r5}
 80040aa:	62c2      	str	r2, [r0, #44]	; 0x2c
 80040ac:	6302      	str	r2, [r0, #48]	; 0x30
 80040ae:	6342      	str	r2, [r0, #52]	; 0x34
 80040b0:	8703      	strh	r3, [r0, #56]	; 0x38
 80040b2:	4770      	bx	lr

080040b4 <bsec_GasEstimator_configure>:
 80040b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80040b8:	b086      	sub	sp, #24
 80040ba:	ab04      	add	r3, sp, #16
 80040bc:	ae05      	add	r6, sp, #20
 80040be:	4604      	mov	r4, r0
 80040c0:	7800      	ldrb	r0, [r0, #0]
 80040c2:	e9cd 3600 	strd	r3, r6, [sp]
 80040c6:	f10d 030f 	add.w	r3, sp, #15
 80040ca:	460d      	mov	r5, r1
 80040cc:	f002 fce0 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80040d0:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80040d4:	bb10      	cbnz	r0, 800411c <bsec_GasEstimator_configure+0x68>
 80040d6:	f04f 0a01 	mov.w	sl, #1
 80040da:	f504 69d6 	add.w	r9, r4, #1712	; 0x6b0
 80040de:	f204 687c 	addw	r8, r4, #1660	; 0x67c
 80040e2:	f504 67c9 	add.w	r7, r4, #1608	; 0x648
 80040e6:	fa5f f38a 	uxtb.w	r3, sl
 80040ea:	3b01      	subs	r3, #1
 80040ec:	2b0d      	cmp	r3, #13
 80040ee:	d870      	bhi.n	80041d2 <bsec_GasEstimator_configure+0x11e>
 80040f0:	e8df f003 	tbb	[pc, r3]
 80040f4:	535a6168 	.word	0x535a6168
 80040f8:	373e454c 	.word	0x373e454c
 80040fc:	1e242a30 	.word	0x1e242a30
 8004100:	0717      	.short	0x0717
 8004102:	4631      	mov	r1, r6
 8004104:	4628      	mov	r0, r5
 8004106:	f7ff f933 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 800410a:	f884 06e5 	strb.w	r0, [r4, #1765]	; 0x6e5
 800410e:	f10a 0a01 	add.w	sl, sl, #1
 8004112:	f1ba 0f10 	cmp.w	sl, #16
 8004116:	d1e6      	bne.n	80040e6 <bsec_GasEstimator_configure+0x32>
 8004118:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 800411c:	b006      	add	sp, #24
 800411e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004122:	4631      	mov	r1, r6
 8004124:	4628      	mov	r0, r5
 8004126:	f7ff f923 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 800412a:	f884 06e4 	strb.w	r0, [r4, #1764]	; 0x6e4
 800412e:	e7ee      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 8004130:	464a      	mov	r2, r9
 8004132:	4631      	mov	r1, r6
 8004134:	4628      	mov	r0, r5
 8004136:	f7ff fd67 	bl	8003c08 <bsec_w_Entity_parseAndDeserialize>
 800413a:	e7e8      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 800413c:	4642      	mov	r2, r8
 800413e:	4631      	mov	r1, r6
 8004140:	4628      	mov	r0, r5
 8004142:	f7ff fd61 	bl	8003c08 <bsec_w_Entity_parseAndDeserialize>
 8004146:	e7e2      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 8004148:	463a      	mov	r2, r7
 800414a:	4631      	mov	r1, r6
 800414c:	4628      	mov	r0, r5
 800414e:	f7ff fd5b 	bl	8003c08 <bsec_w_Entity_parseAndDeserialize>
 8004152:	e7dc      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 8004154:	f204 42dc 	addw	r2, r4, #1244	; 0x4dc
 8004158:	4631      	mov	r1, r6
 800415a:	4628      	mov	r0, r5
 800415c:	f7ff fd06 	bl	8003b6c <bsec_v_Entity_parseAndDeserialize>
 8004160:	e7d5      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 8004162:	f504 629b 	add.w	r2, r4, #1240	; 0x4d8
 8004166:	4631      	mov	r1, r6
 8004168:	4628      	mov	r0, r5
 800416a:	f7ff fbdd 	bl	8003928 <bsec_r_Entity_parseAndDeserialize>
 800416e:	e7ce      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 8004170:	f504 6287 	add.w	r2, r4, #1080	; 0x438
 8004174:	4631      	mov	r1, r6
 8004176:	4628      	mov	r0, r5
 8004178:	f7ff fcba 	bl	8003af0 <bsec_u_Entity_parseAndDeserialize>
 800417c:	e7c7      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 800417e:	f504 722a 	add.w	r2, r4, #680	; 0x2a8
 8004182:	4631      	mov	r1, r6
 8004184:	4628      	mov	r0, r5
 8004186:	f7ff fc6b 	bl	8003a60 <bsec_t_Entity_parseAndDeserialize>
 800418a:	e7c0      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 800418c:	f104 02a0 	add.w	r2, r4, #160	; 0xa0
 8004190:	4631      	mov	r1, r6
 8004192:	4628      	mov	r0, r5
 8004194:	f7ff fc16 	bl	80039c4 <bsec_s_Entity_parseAndDeserialize>
 8004198:	e7b9      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 800419a:	f104 0290 	add.w	r2, r4, #144	; 0x90
 800419e:	4631      	mov	r1, r6
 80041a0:	4628      	mov	r0, r5
 80041a2:	f7ff fa89 	bl	80036b8 <bsec_m_Entity_parseAndDeserialize>
 80041a6:	e7b2      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 80041a8:	f104 0268 	add.w	r2, r4, #104	; 0x68
 80041ac:	4631      	mov	r1, r6
 80041ae:	4628      	mov	r0, r5
 80041b0:	f7ff f94c 	bl	800344c <bsec_h_Entity_parseAndDeserialize>
 80041b4:	e7ab      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 80041b6:	f104 0240 	add.w	r2, r4, #64	; 0x40
 80041ba:	4631      	mov	r1, r6
 80041bc:	4628      	mov	r0, r5
 80041be:	f7ff f945 	bl	800344c <bsec_h_Entity_parseAndDeserialize>
 80041c2:	e7a4      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 80041c4:	f104 023a 	add.w	r2, r4, #58	; 0x3a
 80041c8:	4631      	mov	r1, r6
 80041ca:	4628      	mov	r0, r5
 80041cc:	f7ff fbac 	bl	8003928 <bsec_r_Entity_parseAndDeserialize>
 80041d0:	e79d      	b.n	800410e <bsec_GasEstimator_configure+0x5a>
 80041d2:	4631      	mov	r1, r6
 80041d4:	4628      	mov	r0, r5
 80041d6:	f7ff f8cb 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 80041da:	f884 06e6 	strb.w	r0, [r4, #1766]	; 0x6e6
 80041de:	e796      	b.n	800410e <bsec_GasEstimator_configure+0x5a>

080041e0 <bsec_GasEstimator_doStep>:
 80041e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80041e4:	ed2d 8b04 	vpush	{d8-d9}
 80041e8:	2700      	movs	r7, #0
 80041ea:	f04f 0800 	mov.w	r8, #0
 80041ee:	6017      	str	r7, [r2, #0]
 80041f0:	6057      	str	r7, [r2, #4]
 80041f2:	6097      	str	r7, [r2, #8]
 80041f4:	60d7      	str	r7, [r2, #12]
 80041f6:	b0bb      	sub	sp, #236	; 0xec
 80041f8:	f883 8000 	strb.w	r8, [r3]
 80041fc:	eeb0 8a40 	vmov.f32	s16, s0
 8004200:	eeb0 0a60 	vmov.f32	s0, s1
 8004204:	461e      	mov	r6, r3
 8004206:	4615      	mov	r5, r2
 8004208:	4604      	mov	r4, r0
 800420a:	460f      	mov	r7, r1
 800420c:	eef0 9a41 	vmov.f32	s19, s2
 8004210:	eeb0 9a61 	vmov.f32	s18, s3
 8004214:	eef0 8a42 	vmov.f32	s17, s4
 8004218:	f025 fa24 	bl	8029664 <roundf>
 800421c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8004220:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8004224:	ee17 3a90 	vmov	r3, s15
 8004228:	3301      	adds	r3, #1
 800422a:	b2db      	uxtb	r3, r3
 800422c:	b132      	cbz	r2, 800423c <bsec_GasEstimator_doStep+0x5c>
 800422e:	2b01      	cmp	r3, #1
 8004230:	d070      	beq.n	8004314 <bsec_GasEstimator_doStep+0x134>
 8004232:	b03b      	add	sp, #236	; 0xec
 8004234:	ecbd 8b04 	vpop	{d8-d9}
 8004238:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800423c:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 8004240:	3201      	adds	r2, #1
 8004242:	b2d2      	uxtb	r2, r2
 8004244:	1c78      	adds	r0, r7, #1
 8004246:	b2c0      	uxtb	r0, r0
 8004248:	fbb2 f1f0 	udiv	r1, r2, r0
 800424c:	fb00 2211 	mls	r2, r0, r1, r2
 8004250:	b2d2      	uxtb	r2, r2
 8004252:	4293      	cmp	r3, r2
 8004254:	d013      	beq.n	800427e <bsec_GasEstimator_doStep+0x9e>
 8004256:	2100      	movs	r1, #0
 8004258:	1d23      	adds	r3, r4, #4
 800425a:	f104 022c 	add.w	r2, r4, #44	; 0x2c
 800425e:	f843 1b04 	str.w	r1, [r3], #4
 8004262:	4293      	cmp	r3, r2
 8004264:	d1fb      	bne.n	800425e <bsec_GasEstimator_doStep+0x7e>
 8004266:	2300      	movs	r3, #0
 8004268:	f44f 7280 	mov.w	r2, #256	; 0x100
 800426c:	62e3      	str	r3, [r4, #44]	; 0x2c
 800426e:	6323      	str	r3, [r4, #48]	; 0x30
 8004270:	6363      	str	r3, [r4, #52]	; 0x34
 8004272:	8722      	strh	r2, [r4, #56]	; 0x38
 8004274:	b03b      	add	sp, #236	; 0xec
 8004276:	ecbd 8b04 	vpop	{d8-d9}
 800427a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800427e:	1e5a      	subs	r2, r3, #1
 8004280:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8004284:	42bb      	cmp	r3, r7
 8004286:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
 800428a:	ed82 8a01 	vstr	s16, [r2, #4]
 800428e:	d1d0      	bne.n	8004232 <bsec_GasEstimator_doStep+0x52>
 8004290:	f10d 09b4 	add.w	r9, sp, #180	; 0xb4
 8004294:	f04f 0800 	mov.w	r8, #0
 8004298:	ab20      	add	r3, sp, #128	; 0x80
 800429a:	464a      	mov	r2, r9
 800429c:	f843 8b04 	str.w	r8, [r3], #4
 80042a0:	454b      	cmp	r3, r9
 80042a2:	f842 8b04 	str.w	r8, [r2], #4
 80042a6:	d1f9      	bne.n	800429c <bsec_GasEstimator_doStep+0xbc>
 80042a8:	1d23      	adds	r3, r4, #4
 80042aa:	4619      	mov	r1, r3
 80042ac:	2228      	movs	r2, #40	; 0x28
 80042ae:	4648      	mov	r0, r9
 80042b0:	f504 67c9 	add.w	r7, r4, #1608	; 0x648
 80042b4:	9306      	str	r3, [sp, #24]
 80042b6:	f027 ff13 	bl	802c0e0 <memcpy>
 80042ba:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80042bc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80042be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80042c0:	9137      	str	r1, [sp, #220]	; 0xdc
 80042c2:	4638      	mov	r0, r7
 80042c4:	9238      	str	r2, [sp, #224]	; 0xe0
 80042c6:	9339      	str	r3, [sp, #228]	; 0xe4
 80042c8:	f002 fc20 	bl	8006b0c <bsec_any>
 80042cc:	2800      	cmp	r0, #0
 80042ce:	f040 811d 	bne.w	800450c <bsec_GasEstimator_doStep+0x32c>
 80042d2:	f504 63d6 	add.w	r3, r4, #1712	; 0x6b0
 80042d6:	f204 61e4 	addw	r1, r4, #1764	; 0x6e4
 80042da:	aa20      	add	r2, sp, #128	; 0x80
 80042dc:	e00f      	b.n	80042fe <bsec_GasEstimator_doStep+0x11e>
 80042de:	ed53 6a0e 	vldr	s13, [r3, #-56]	; 0xffffffc8
 80042e2:	ed99 7a00 	vldr	s14, [r9]
 80042e6:	ee37 7a66 	vsub.f32	s14, s14, s13
 80042ea:	eec7 6a27 	vdiv.f32	s13, s14, s15
 80042ee:	edc2 6a00 	vstr	s13, [r2]
 80042f2:	4299      	cmp	r1, r3
 80042f4:	f109 0904 	add.w	r9, r9, #4
 80042f8:	f102 0204 	add.w	r2, r2, #4
 80042fc:	d01f      	beq.n	800433e <bsec_GasEstimator_doStep+0x15e>
 80042fe:	ecf3 7a01 	vldmia	r3!, {s15}
 8004302:	eef5 7a40 	vcmp.f32	s15, #0.0
 8004306:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800430a:	d1e8      	bne.n	80042de <bsec_GasEstimator_doStep+0xfe>
 800430c:	f8d9 0000 	ldr.w	r0, [r9]
 8004310:	6010      	str	r0, [r2, #0]
 8004312:	e7ee      	b.n	80042f2 <bsec_GasEstimator_doStep+0x112>
 8004314:	f894 26e6 	ldrb.w	r2, [r4, #1766]	; 0x6e6
 8004318:	f884 8039 	strb.w	r8, [r4, #57]	; 0x39
 800431c:	b10a      	cbz	r2, 8004322 <bsec_GasEstimator_doStep+0x142>
 800431e:	edc4 9a0b 	vstr	s19, [r4, #44]	; 0x2c
 8004322:	f894 26e4 	ldrb.w	r2, [r4, #1764]	; 0x6e4
 8004326:	b10a      	cbz	r2, 800432c <bsec_GasEstimator_doStep+0x14c>
 8004328:	ed84 9a0c 	vstr	s18, [r4, #48]	; 0x30
 800432c:	f894 26e5 	ldrb.w	r2, [r4, #1765]	; 0x6e5
 8004330:	b11a      	cbz	r2, 800433a <bsec_GasEstimator_doStep+0x15a>
 8004332:	edc4 8a0d 	vstr	s17, [r4, #52]	; 0x34
 8004336:	2201      	movs	r2, #1
 8004338:	e784      	b.n	8004244 <bsec_GasEstimator_doStep+0x64>
 800433a:	2201      	movs	r2, #1
 800433c:	e782      	b.n	8004244 <bsec_GasEstimator_doStep+0x64>
 800433e:	ab08      	add	r3, sp, #32
 8004340:	270d      	movs	r7, #13
 8004342:	f10d 0b30 	add.w	fp, sp, #48	; 0x30
 8004346:	f10d 0a58 	add.w	sl, sp, #88	; 0x58
 800434a:	9305      	str	r3, [sp, #20]
 800434c:	f104 082c 	add.w	r8, r4, #44	; 0x2c
 8004350:	f894 34d8 	ldrb.w	r3, [r4, #1240]	; 0x4d8
 8004354:	9307      	str	r3, [sp, #28]
 8004356:	2228      	movs	r2, #40	; 0x28
 8004358:	f894 34d9 	ldrb.w	r3, [r4, #1241]	; 0x4d9
 800435c:	9304      	str	r3, [sp, #16]
 800435e:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8004362:	4658      	mov	r0, fp
 8004364:	f894 94da 	ldrb.w	r9, [r4, #1242]	; 0x4da
 8004368:	f027 feba 	bl	802c0e0 <memcpy>
 800436c:	9b07      	ldr	r3, [sp, #28]
 800436e:	b1db      	cbz	r3, 80043a8 <bsec_GasEstimator_doStep+0x1c8>
 8004370:	aa20      	add	r2, sp, #128	; 0x80
 8004372:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8004376:	46dc      	mov	ip, fp
 8004378:	4620      	mov	r0, r4
 800437a:	eb04 0e83 	add.w	lr, r4, r3, lsl #2
 800437e:	ecbc 7a01 	vldmia	ip!, {s14}
 8004382:	a920      	add	r1, sp, #128	; 0x80
 8004384:	4602      	mov	r2, r0
 8004386:	ecf1 7a01 	vldmia	r1!, {s15}
 800438a:	edd2 6a28 	vldr	s13, [r2, #160]	; 0xa0
 800438e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004392:	42b9      	cmp	r1, r7
 8004394:	ee37 7a27 	vadd.f32	s14, s14, s15
 8004398:	f102 0228 	add.w	r2, r2, #40	; 0x28
 800439c:	d1f3      	bne.n	8004386 <bsec_GasEstimator_doStep+0x1a6>
 800439e:	3004      	adds	r0, #4
 80043a0:	4586      	cmp	lr, r0
 80043a2:	ed0c 7a01 	vstr	s14, [ip, #-4]
 80043a6:	d1ea      	bne.n	800437e <bsec_GasEstimator_doStep+0x19e>
 80043a8:	499f      	ldr	r1, [pc, #636]	; (8004628 <bsec_GasEstimator_doStep+0x448>)
 80043aa:	f8cd a008 	str.w	sl, [sp, #8]
 80043ae:	2000      	movs	r0, #0
 80043b0:	e9cd 0100 	strd	r0, r1, [sp]
 80043b4:	461a      	mov	r2, r3
 80043b6:	4659      	mov	r1, fp
 80043b8:	4620      	mov	r0, r4
 80043ba:	9307      	str	r3, [sp, #28]
 80043bc:	f7ff fcbc 	bl	8003d38 <bsec_GasEstimator_applyTransferFunction>
 80043c0:	9a04      	ldr	r2, [sp, #16]
 80043c2:	9b07      	ldr	r3, [sp, #28]
 80043c4:	2a00      	cmp	r2, #0
 80043c6:	d072      	beq.n	80044ae <bsec_GasEstimator_doStep+0x2ce>
 80043c8:	2228      	movs	r2, #40	; 0x28
 80043ca:	f104 0168 	add.w	r1, r4, #104	; 0x68
 80043ce:	a82d      	add	r0, sp, #180	; 0xb4
 80043d0:	9307      	str	r3, [sp, #28]
 80043d2:	f027 fe85 	bl	802c0e0 <memcpy>
 80043d6:	9b07      	ldr	r3, [sp, #28]
 80043d8:	f8cd 901c 	str.w	r9, [sp, #28]
 80043dc:	f8dd 9010 	ldr.w	r9, [sp, #16]
 80043e0:	af2d      	add	r7, sp, #180	; 0xb4
 80043e2:	46a6      	mov	lr, r4
 80043e4:	eb0a 0083 	add.w	r0, sl, r3, lsl #2
 80043e8:	f04f 0c00 	mov.w	ip, #0
 80043ec:	b18b      	cbz	r3, 8004412 <bsec_GasEstimator_doStep+0x232>
 80043ee:	ed97 7a00 	vldr	s14, [r7]
 80043f2:	4651      	mov	r1, sl
 80043f4:	4672      	mov	r2, lr
 80043f6:	ecf1 7a01 	vldmia	r1!, {s15}
 80043fa:	edd2 6aaa 	vldr	s13, [r2, #680]	; 0x2a8
 80043fe:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004402:	4288      	cmp	r0, r1
 8004404:	ee37 7a27 	vadd.f32	s14, s14, s15
 8004408:	f102 0228 	add.w	r2, r2, #40	; 0x28
 800440c:	d1f3      	bne.n	80043f6 <bsec_GasEstimator_doStep+0x216>
 800440e:	ed87 7a00 	vstr	s14, [r7]
 8004412:	f10c 0c01 	add.w	ip, ip, #1
 8004416:	45e1      	cmp	r9, ip
 8004418:	f107 0704 	add.w	r7, r7, #4
 800441c:	f10e 0e04 	add.w	lr, lr, #4
 8004420:	d1e4      	bne.n	80043ec <bsec_GasEstimator_doStep+0x20c>
 8004422:	2200      	movs	r2, #0
 8004424:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004428:	e9cd 2300 	strd	r2, r3, [sp]
 800442c:	f8dd 901c 	ldr.w	r9, [sp, #28]
 8004430:	9a04      	ldr	r2, [sp, #16]
 8004432:	f8cd b008 	str.w	fp, [sp, #8]
 8004436:	a92d      	add	r1, sp, #180	; 0xb4
 8004438:	4620      	mov	r0, r4
 800443a:	f7ff fc7d 	bl	8003d38 <bsec_GasEstimator_applyTransferFunction>
 800443e:	9805      	ldr	r0, [sp, #20]
 8004440:	2210      	movs	r2, #16
 8004442:	f104 0190 	add.w	r1, r4, #144	; 0x90
 8004446:	f027 fe4b 	bl	802c0e0 <memcpy>
 800444a:	f1b9 0f00 	cmp.w	r9, #0
 800444e:	d01f      	beq.n	8004490 <bsec_GasEstimator_doStep+0x2b0>
 8004450:	9b04      	ldr	r3, [sp, #16]
 8004452:	f8dd c014 	ldr.w	ip, [sp, #20]
 8004456:	eb0b 0183 	add.w	r1, fp, r3, lsl #2
 800445a:	f504 6787 	add.w	r7, r4, #1080	; 0x438
 800445e:	2000      	movs	r0, #0
 8004460:	ecbc 7a01 	vldmia	ip!, {s14}
 8004464:	465b      	mov	r3, fp
 8004466:	463a      	mov	r2, r7
 8004468:	4696      	mov	lr, r2
 800446a:	ecf3 7a01 	vldmia	r3!, {s15}
 800446e:	edde 6a00 	vldr	s13, [lr]
 8004472:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004476:	4299      	cmp	r1, r3
 8004478:	ee37 7a27 	vadd.f32	s14, s14, s15
 800447c:	f102 0210 	add.w	r2, r2, #16
 8004480:	d1f2      	bne.n	8004468 <bsec_GasEstimator_doStep+0x288>
 8004482:	3001      	adds	r0, #1
 8004484:	4581      	cmp	r9, r0
 8004486:	ed0c 7a01 	vstr	s14, [ip, #-4]
 800448a:	f107 0704 	add.w	r7, r7, #4
 800448e:	d1e7      	bne.n	8004460 <bsec_GasEstimator_doStep+0x280>
 8004490:	462b      	mov	r3, r5
 8004492:	464a      	mov	r2, r9
 8004494:	9905      	ldr	r1, [sp, #20]
 8004496:	4620      	mov	r0, r4
 8004498:	f7ff fce4 	bl	8003e64 <bsec_b_GasEstimator_applyTransferFunction.constprop.0>
 800449c:	2303      	movs	r3, #3
 800449e:	7033      	strb	r3, [r6, #0]
 80044a0:	9b06      	ldr	r3, [sp, #24]
 80044a2:	2200      	movs	r2, #0
 80044a4:	f843 2b04 	str.w	r2, [r3], #4
 80044a8:	4598      	cmp	r8, r3
 80044aa:	d1fb      	bne.n	80044a4 <bsec_GasEstimator_doStep+0x2c4>
 80044ac:	e6db      	b.n	8004266 <bsec_GasEstimator_doStep+0x86>
 80044ae:	f8dd b014 	ldr.w	fp, [sp, #20]
 80044b2:	9307      	str	r3, [sp, #28]
 80044b4:	2210      	movs	r2, #16
 80044b6:	f104 0190 	add.w	r1, r4, #144	; 0x90
 80044ba:	4658      	mov	r0, fp
 80044bc:	f027 fe10 	bl	802c0e0 <memcpy>
 80044c0:	f1b9 0f00 	cmp.w	r9, #0
 80044c4:	d0e4      	beq.n	8004490 <bsec_GasEstimator_doStep+0x2b0>
 80044c6:	9b07      	ldr	r3, [sp, #28]
 80044c8:	9f04      	ldr	r7, [sp, #16]
 80044ca:	46dc      	mov	ip, fp
 80044cc:	f504 6e87 	add.w	lr, r4, #1080	; 0x438
 80044d0:	eb0a 0083 	add.w	r0, sl, r3, lsl #2
 80044d4:	b193      	cbz	r3, 80044fc <bsec_GasEstimator_doStep+0x31c>
 80044d6:	ed9c 7a00 	vldr	s14, [ip]
 80044da:	4652      	mov	r2, sl
 80044dc:	4671      	mov	r1, lr
 80044de:	468b      	mov	fp, r1
 80044e0:	ecf2 7a01 	vldmia	r2!, {s15}
 80044e4:	eddb 6a00 	vldr	s13, [fp]
 80044e8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80044ec:	4290      	cmp	r0, r2
 80044ee:	ee37 7a27 	vadd.f32	s14, s14, s15
 80044f2:	f101 0110 	add.w	r1, r1, #16
 80044f6:	d1f2      	bne.n	80044de <bsec_GasEstimator_doStep+0x2fe>
 80044f8:	ed8c 7a00 	vstr	s14, [ip]
 80044fc:	3701      	adds	r7, #1
 80044fe:	45b9      	cmp	r9, r7
 8004500:	f10c 0c04 	add.w	ip, ip, #4
 8004504:	f10e 0e04 	add.w	lr, lr, #4
 8004508:	d1e4      	bne.n	80044d4 <bsec_GasEstimator_doStep+0x2f4>
 800450a:	e7c1      	b.n	8004490 <bsec_GasEstimator_doStep+0x2b0>
 800450c:	ed9f 7b44 	vldr	d7, [pc, #272]	; 8004620 <bsec_GasEstimator_doStep+0x440>
 8004510:	4945      	ldr	r1, [pc, #276]	; (8004628 <bsec_GasEstimator_doStep+0x448>)
 8004512:	4b46      	ldr	r3, [pc, #280]	; (800462c <bsec_GasEstimator_doStep+0x44c>)
 8004514:	f8cd 8020 	str.w	r8, [sp, #32]
 8004518:	aa08      	add	r2, sp, #32
 800451a:	9205      	str	r2, [sp, #20]
 800451c:	2000      	movs	r0, #0
 800451e:	f10d 0b30 	add.w	fp, sp, #48	; 0x30
 8004522:	f10d 0a58 	add.w	sl, sp, #88	; 0x58
 8004526:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
 800452a:	465a      	mov	r2, fp
 800452c:	9805      	ldr	r0, [sp, #20]
 800452e:	9309      	str	r3, [sp, #36]	; 0x24
 8004530:	4651      	mov	r1, sl
 8004532:	ed8d 7b16 	vstr	d7, [sp, #88]	; 0x58
 8004536:	eddf 8a3e 	vldr	s17, [pc, #248]	; 8004630 <bsec_GasEstimator_doStep+0x450>
 800453a:	ed9f 8a3e 	vldr	s16, [pc, #248]	; 8004634 <bsec_GasEstimator_doStep+0x454>
 800453e:	f002 fbab 	bl	8006c98 <bsec_polyfit>
 8004542:	463b      	mov	r3, r7
 8004544:	9f06      	ldr	r7, [sp, #24]
 8004546:	9404      	str	r4, [sp, #16]
 8004548:	f104 082c 	add.w	r8, r4, #44	; 0x2c
 800454c:	9507      	str	r5, [sp, #28]
 800454e:	461c      	mov	r4, r3
 8004550:	464d      	mov	r5, r9
 8004552:	ecb7 0a01 	vldmia	r7!, {s0}
 8004556:	f025 fa15 	bl	8029984 <logf>
 800455a:	ee60 7a28 	vmul.f32	s15, s0, s17
 800455e:	ecb4 7a01 	vldmia	r4!, {s14}
 8004562:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8004566:	45b8      	cmp	r8, r7
 8004568:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800456c:	ece5 7a01 	vstmia	r5!, {s15}
 8004570:	d1ef      	bne.n	8004552 <bsec_GasEstimator_doStep+0x372>
 8004572:	9c04      	ldr	r4, [sp, #16]
 8004574:	ed9f 5a30 	vldr	s10, [pc, #192]	; 8004638 <bsec_GasEstimator_doStep+0x458>
 8004578:	eddd 5a0c 	vldr	s11, [sp, #48]	; 0x30
 800457c:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8004580:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
 8004584:	ed9f 6a2d 	vldr	s12, [pc, #180]	; 800463c <bsec_GasEstimator_doStep+0x45c>
 8004588:	ed9d 4a0d 	vldr	s8, [sp, #52]	; 0x34
 800458c:	edd4 6a0c 	vldr	s13, [r4, #48]	; 0x30
 8004590:	eddf 4a2b 	vldr	s9, [pc, #172]	; 8004640 <bsec_GasEstimator_doStep+0x460>
 8004594:	9d07      	ldr	r5, [sp, #28]
 8004596:	ee27 7a05 	vmul.f32	s14, s14, s10
 800459a:	ee67 7aa5 	vmul.f32	s15, s15, s11
 800459e:	f204 6174 	addw	r1, r4, #1652	; 0x674
 80045a2:	f504 62cf 	add.w	r2, r4, #1656	; 0x678
 80045a6:	f504 63ce 	add.w	r3, r4, #1648	; 0x670
 80045aa:	ee37 7a06 	vadd.f32	s14, s14, s12
 80045ae:	ed91 5a00 	vldr	s10, [r1]
 80045b2:	edd2 5a00 	vldr	s11, [r2]
 80045b6:	ed93 6a00 	vldr	s12, [r3]
 80045ba:	ee77 7a84 	vadd.f32	s15, s15, s8
 80045be:	ee66 6aa4 	vmul.f32	s13, s13, s9
 80045c2:	ee37 7a45 	vsub.f32	s14, s14, s10
 80045c6:	ee77 7ae5 	vsub.f32	s15, s15, s11
 80045ca:	ee76 6ac6 	vsub.f32	s13, s13, s12
 80045ce:	ed8d 7a38 	vstr	s14, [sp, #224]	; 0xe0
 80045d2:	edcd 7a39 	vstr	s15, [sp, #228]	; 0xe4
 80045d6:	edcd 6a37 	vstr	s13, [sp, #220]	; 0xdc
 80045da:	f204 40dc 	addw	r0, r4, #1244	; 0x4dc
 80045de:	f10d 0c80 	add.w	ip, sp, #128	; 0x80
 80045e2:	2700      	movs	r7, #0
 80045e4:	f109 0134 	add.w	r1, r9, #52	; 0x34
 80045e8:	ed9f 7a16 	vldr	s14, [pc, #88]	; 8004644 <bsec_GasEstimator_doStep+0x464>
 80045ec:	464b      	mov	r3, r9
 80045ee:	4602      	mov	r2, r0
 80045f0:	4696      	mov	lr, r2
 80045f2:	ecf3 7a01 	vldmia	r3!, {s15}
 80045f6:	edde 6a00 	vldr	s13, [lr]
 80045fa:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80045fe:	4299      	cmp	r1, r3
 8004600:	ee37 7a27 	vadd.f32	s14, s14, s15
 8004604:	f102 021c 	add.w	r2, r2, #28
 8004608:	d1f2      	bne.n	80045f0 <bsec_GasEstimator_doStep+0x410>
 800460a:	3701      	adds	r7, #1
 800460c:	2f07      	cmp	r7, #7
 800460e:	ecac 7a01 	vstmia	ip!, {s14}
 8004612:	f100 0004 	add.w	r0, r0, #4
 8004616:	d1e7      	bne.n	80045e8 <bsec_GasEstimator_doStep+0x408>
 8004618:	e69a      	b.n	8004350 <bsec_GasEstimator_doStep+0x170>
 800461a:	bf00      	nop
 800461c:	f3af 8000 	nop.w
	...
 8004628:	3ff00000 	.word	0x3ff00000
 800462c:	49f42400 	.word	0x49f42400
 8004630:	3d99d165 	.word	0x3d99d165
 8004634:	3ec57e93 	.word	0x3ec57e93
 8004638:	3bac7690 	.word	0x3bac7690
 800463c:	3eaf286d 	.word	0x3eaf286d
 8004640:	3c23d70a 	.word	0x3c23d70a
 8004644:	00000000 	.word	0x00000000

08004648 <bsec_GasEstimator_getConfiguration>:
 8004648:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800464c:	b084      	sub	sp, #16
 800464e:	4606      	mov	r6, r0
 8004650:	4617      	mov	r7, r2
 8004652:	7800      	ldrb	r0, [r0, #0]
 8004654:	240f      	movs	r4, #15
 8004656:	f10d 0207 	add.w	r2, sp, #7
 800465a:	460d      	mov	r5, r1
 800465c:	f88d 4007 	strb.w	r4, [sp, #7]
 8004660:	f002 fa44 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8004664:	f89d 8007 	ldrb.w	r8, [sp, #7]
 8004668:	9003      	str	r0, [sp, #12]
 800466a:	f1b8 0f00 	cmp.w	r8, #0
 800466e:	d02b      	beq.n	80046c8 <bsec_GasEstimator_getConfiguration+0x80>
 8004670:	2401      	movs	r4, #1
 8004672:	f506 6ad6 	add.w	sl, r6, #1712	; 0x6b0
 8004676:	f206 697c 	addw	r9, r6, #1660	; 0x67c
 800467a:	b2e3      	uxtb	r3, r4
 800467c:	3b01      	subs	r3, #1
 800467e:	2b0e      	cmp	r3, #14
 8004680:	d810      	bhi.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 8004682:	e8df f003 	tbb	[pc, r3]
 8004686:	434b      	.short	0x434b
 8004688:	333b535b 	.word	0x333b535b
 800468c:	636b737b 	.word	0x636b737b
 8004690:	1591838a 	.word	0x1591838a
 8004694:	08          	.byte	0x08
 8004695:	00          	.byte	0x00
 8004696:	f896 06e6 	ldrb.w	r0, [r6, #1766]	; 0x6e6
 800469a:	ab03      	add	r3, sp, #12
 800469c:	463a      	mov	r2, r7
 800469e:	4629      	mov	r1, r5
 80046a0:	f7fe fe7c 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 80046a4:	45a0      	cmp	r8, r4
 80046a6:	f104 0301 	add.w	r3, r4, #1
 80046aa:	d00c      	beq.n	80046c6 <bsec_GasEstimator_getConfiguration+0x7e>
 80046ac:	461c      	mov	r4, r3
 80046ae:	e7e4      	b.n	800467a <bsec_GasEstimator_getConfiguration+0x32>
 80046b0:	ab03      	add	r3, sp, #12
 80046b2:	f896 06e5 	ldrb.w	r0, [r6, #1765]	; 0x6e5
 80046b6:	463a      	mov	r2, r7
 80046b8:	4629      	mov	r1, r5
 80046ba:	f7fe fe6f 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 80046be:	45a0      	cmp	r8, r4
 80046c0:	f104 0301 	add.w	r3, r4, #1
 80046c4:	d1f2      	bne.n	80046ac <bsec_GasEstimator_getConfiguration+0x64>
 80046c6:	9803      	ldr	r0, [sp, #12]
 80046c8:	f8ad 000a 	strh.w	r0, [sp, #10]
 80046cc:	2202      	movs	r2, #2
 80046ce:	f10d 010a 	add.w	r1, sp, #10
 80046d2:	a802      	add	r0, sp, #8
 80046d4:	f027 fd04 	bl	802c0e0 <memcpy>
 80046d8:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80046dc:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80046e0:	9803      	ldr	r0, [sp, #12]
 80046e2:	702a      	strb	r2, [r5, #0]
 80046e4:	706b      	strb	r3, [r5, #1]
 80046e6:	b004      	add	sp, #16
 80046e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80046ec:	ab03      	add	r3, sp, #12
 80046ee:	463a      	mov	r2, r7
 80046f0:	4629      	mov	r1, r5
 80046f2:	f506 702a 	add.w	r0, r6, #680	; 0x2a8
 80046f6:	f7ff f983 	bl	8003a00 <bsec_s_Entity_serializeAndAdd>
 80046fa:	e7d3      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 80046fc:	ab03      	add	r3, sp, #12
 80046fe:	463a      	mov	r2, r7
 8004700:	4629      	mov	r1, r5
 8004702:	f106 00a0 	add.w	r0, r6, #160	; 0xa0
 8004706:	f7ff f929 	bl	800395c <bsec_r_Entity_serializeAndAdd>
 800470a:	e7cb      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800470c:	ab03      	add	r3, sp, #12
 800470e:	463a      	mov	r2, r7
 8004710:	4629      	mov	r1, r5
 8004712:	f106 0040 	add.w	r0, r6, #64	; 0x40
 8004716:	f7fe fed9 	bl	80034cc <bsec_i_Entity_serializeAndAdd>
 800471a:	e7c3      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800471c:	ab03      	add	r3, sp, #12
 800471e:	463a      	mov	r2, r7
 8004720:	4629      	mov	r1, r5
 8004722:	f106 003a 	add.w	r0, r6, #58	; 0x3a
 8004726:	f7ff f891 	bl	800384c <bsec_p_Entity_serializeAndAdd>
 800472a:	e7bb      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800472c:	ab03      	add	r3, sp, #12
 800472e:	463a      	mov	r2, r7
 8004730:	4629      	mov	r1, r5
 8004732:	f106 0090 	add.w	r0, r6, #144	; 0x90
 8004736:	f7ff f8d1 	bl	80038dc <bsec_q_Entity_serializeAndAdd>
 800473a:	e7b3      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800473c:	ab03      	add	r3, sp, #12
 800473e:	463a      	mov	r2, r7
 8004740:	4629      	mov	r1, r5
 8004742:	f106 0068 	add.w	r0, r6, #104	; 0x68
 8004746:	f7fe fec1 	bl	80034cc <bsec_i_Entity_serializeAndAdd>
 800474a:	e7ab      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800474c:	ab03      	add	r3, sp, #12
 800474e:	463a      	mov	r2, r7
 8004750:	4629      	mov	r1, r5
 8004752:	f506 60c9 	add.w	r0, r6, #1608	; 0x648
 8004756:	f7ff fa71 	bl	8003c3c <bsec_w_Entity_serializeAndAdd>
 800475a:	e7a3      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800475c:	ab03      	add	r3, sp, #12
 800475e:	463a      	mov	r2, r7
 8004760:	4629      	mov	r1, r5
 8004762:	f206 40dc 	addw	r0, r6, #1244	; 0x4dc
 8004766:	f7ff fa1d 	bl	8003ba4 <bsec_v_Entity_serializeAndAdd>
 800476a:	e79b      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800476c:	ab03      	add	r3, sp, #12
 800476e:	463a      	mov	r2, r7
 8004770:	4629      	mov	r1, r5
 8004772:	f506 609b 	add.w	r0, r6, #1240	; 0x4d8
 8004776:	f7ff f9d5 	bl	8003b24 <bsec_u_Entity_serializeAndAdd>
 800477a:	e793      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800477c:	ab03      	add	r3, sp, #12
 800477e:	463a      	mov	r2, r7
 8004780:	4629      	mov	r1, r5
 8004782:	f506 6087 	add.w	r0, r6, #1080	; 0x438
 8004786:	f7ff f987 	bl	8003a98 <bsec_t_Entity_serializeAndAdd>
 800478a:	e78b      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800478c:	ab03      	add	r3, sp, #12
 800478e:	463a      	mov	r2, r7
 8004790:	4629      	mov	r1, r5
 8004792:	4650      	mov	r0, sl
 8004794:	f7ff fa52 	bl	8003c3c <bsec_w_Entity_serializeAndAdd>
 8004798:	e784      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 800479a:	ab03      	add	r3, sp, #12
 800479c:	463a      	mov	r2, r7
 800479e:	4629      	mov	r1, r5
 80047a0:	4648      	mov	r0, r9
 80047a2:	f7ff fa4b 	bl	8003c3c <bsec_w_Entity_serializeAndAdd>
 80047a6:	e77d      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>
 80047a8:	f896 06e4 	ldrb.w	r0, [r6, #1764]	; 0x6e4
 80047ac:	ab03      	add	r3, sp, #12
 80047ae:	463a      	mov	r2, r7
 80047b0:	4629      	mov	r1, r5
 80047b2:	f7fe fdf3 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 80047b6:	e775      	b.n	80046a4 <bsec_GasEstimator_getConfiguration+0x5c>

080047b8 <bsec_GasEstimator_getState>:
 80047b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80047bc:	b085      	sub	sp, #20
 80047be:	4606      	mov	r6, r0
 80047c0:	4690      	mov	r8, r2
 80047c2:	7800      	ldrb	r0, [r0, #0]
 80047c4:	2406      	movs	r4, #6
 80047c6:	f10d 0207 	add.w	r2, sp, #7
 80047ca:	460d      	mov	r5, r1
 80047cc:	f88d 4007 	strb.w	r4, [sp, #7]
 80047d0:	f002 f98c 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 80047d4:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80047d8:	9003      	str	r0, [sp, #12]
 80047da:	b327      	cbz	r7, 8004826 <bsec_GasEstimator_getState+0x6e>
 80047dc:	2401      	movs	r4, #1
 80047de:	f106 0904 	add.w	r9, r6, #4
 80047e2:	b2e3      	uxtb	r3, r4
 80047e4:	3b01      	subs	r3, #1
 80047e6:	2b05      	cmp	r3, #5
 80047e8:	d80b      	bhi.n	8004802 <bsec_GasEstimator_getState+0x4a>
 80047ea:	e8df f003 	tbb	[pc, r3]
 80047ee:	102e      	.short	0x102e
 80047f0:	0345353d 	.word	0x0345353d
 80047f4:	ed96 0a0d 	vldr	s0, [r6, #52]	; 0x34
 80047f8:	aa03      	add	r2, sp, #12
 80047fa:	4641      	mov	r1, r8
 80047fc:	4628      	mov	r0, r5
 80047fe:	f7fe fd8b 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8004802:	42a7      	cmp	r7, r4
 8004804:	f104 0301 	add.w	r3, r4, #1
 8004808:	d00c      	beq.n	8004824 <bsec_GasEstimator_getState+0x6c>
 800480a:	461c      	mov	r4, r3
 800480c:	e7e9      	b.n	80047e2 <bsec_GasEstimator_getState+0x2a>
 800480e:	ab03      	add	r3, sp, #12
 8004810:	f896 0038 	ldrb.w	r0, [r6, #56]	; 0x38
 8004814:	4642      	mov	r2, r8
 8004816:	4629      	mov	r1, r5
 8004818:	f7fe fdc0 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800481c:	42a7      	cmp	r7, r4
 800481e:	f104 0301 	add.w	r3, r4, #1
 8004822:	d1f2      	bne.n	800480a <bsec_GasEstimator_getState+0x52>
 8004824:	9803      	ldr	r0, [sp, #12]
 8004826:	f8ad 000a 	strh.w	r0, [sp, #10]
 800482a:	2202      	movs	r2, #2
 800482c:	f10d 010a 	add.w	r1, sp, #10
 8004830:	a802      	add	r0, sp, #8
 8004832:	f027 fc55 	bl	802c0e0 <memcpy>
 8004836:	f89d 2008 	ldrb.w	r2, [sp, #8]
 800483a:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800483e:	9803      	ldr	r0, [sp, #12]
 8004840:	702a      	strb	r2, [r5, #0]
 8004842:	706b      	strb	r3, [r5, #1]
 8004844:	b005      	add	sp, #20
 8004846:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800484a:	ab03      	add	r3, sp, #12
 800484c:	4642      	mov	r2, r8
 800484e:	4629      	mov	r1, r5
 8004850:	4648      	mov	r0, r9
 8004852:	f7fe fe3b 	bl	80034cc <bsec_i_Entity_serializeAndAdd>
 8004856:	e7d4      	b.n	8004802 <bsec_GasEstimator_getState+0x4a>
 8004858:	ed96 0a0b 	vldr	s0, [r6, #44]	; 0x2c
 800485c:	aa03      	add	r2, sp, #12
 800485e:	4641      	mov	r1, r8
 8004860:	4628      	mov	r0, r5
 8004862:	f7fe fd59 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8004866:	e7cc      	b.n	8004802 <bsec_GasEstimator_getState+0x4a>
 8004868:	f896 0039 	ldrb.w	r0, [r6, #57]	; 0x39
 800486c:	ab03      	add	r3, sp, #12
 800486e:	4642      	mov	r2, r8
 8004870:	4629      	mov	r1, r5
 8004872:	f7fe fd93 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 8004876:	e7c4      	b.n	8004802 <bsec_GasEstimator_getState+0x4a>
 8004878:	ed96 0a0c 	vldr	s0, [r6, #48]	; 0x30
 800487c:	aa03      	add	r2, sp, #12
 800487e:	4641      	mov	r1, r8
 8004880:	4628      	mov	r0, r5
 8004882:	f7fe fd49 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8004886:	e7bc      	b.n	8004802 <bsec_GasEstimator_getState+0x4a>

08004888 <bsec_GasEstimator_setState>:
 8004888:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800488c:	b086      	sub	sp, #24
 800488e:	ab04      	add	r3, sp, #16
 8004890:	af05      	add	r7, sp, #20
 8004892:	4605      	mov	r5, r0
 8004894:	7800      	ldrb	r0, [r0, #0]
 8004896:	e9cd 3700 	strd	r3, r7, [sp]
 800489a:	f10d 030f 	add.w	r3, sp, #15
 800489e:	460e      	mov	r6, r1
 80048a0:	f002 f8f6 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80048a4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80048a8:	b9b0      	cbnz	r0, 80048d8 <bsec_GasEstimator_setState+0x50>
 80048aa:	2401      	movs	r4, #1
 80048ac:	f105 0804 	add.w	r8, r5, #4
 80048b0:	b2e3      	uxtb	r3, r4
 80048b2:	3b01      	subs	r3, #1
 80048b4:	2b04      	cmp	r3, #4
 80048b6:	d82d      	bhi.n	8004914 <bsec_GasEstimator_setState+0x8c>
 80048b8:	e8df f003 	tbb	[pc, r3]
 80048bc:	11181f26 	.word	0x11181f26
 80048c0:	03          	.byte	0x03
 80048c1:	00          	.byte	0x00
 80048c2:	4639      	mov	r1, r7
 80048c4:	4630      	mov	r0, r6
 80048c6:	f7fe fd09 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80048ca:	ed85 0a0c 	vstr	s0, [r5, #48]	; 0x30
 80048ce:	3401      	adds	r4, #1
 80048d0:	2c07      	cmp	r4, #7
 80048d2:	d1ed      	bne.n	80048b0 <bsec_GasEstimator_setState+0x28>
 80048d4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80048d8:	b006      	add	sp, #24
 80048da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80048de:	4639      	mov	r1, r7
 80048e0:	4630      	mov	r0, r6
 80048e2:	f7fe fcfb 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80048e6:	ed85 0a0b 	vstr	s0, [r5, #44]	; 0x2c
 80048ea:	e7f0      	b.n	80048ce <bsec_GasEstimator_setState+0x46>
 80048ec:	4639      	mov	r1, r7
 80048ee:	4630      	mov	r0, r6
 80048f0:	f7fe fd3e 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 80048f4:	f885 0039 	strb.w	r0, [r5, #57]	; 0x39
 80048f8:	e7e9      	b.n	80048ce <bsec_GasEstimator_setState+0x46>
 80048fa:	4639      	mov	r1, r7
 80048fc:	4630      	mov	r0, r6
 80048fe:	f7fe fd37 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8004902:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
 8004906:	e7e2      	b.n	80048ce <bsec_GasEstimator_setState+0x46>
 8004908:	4642      	mov	r2, r8
 800490a:	4639      	mov	r1, r7
 800490c:	4630      	mov	r0, r6
 800490e:	f7fe fd9d 	bl	800344c <bsec_h_Entity_parseAndDeserialize>
 8004912:	e7dc      	b.n	80048ce <bsec_GasEstimator_setState+0x46>
 8004914:	4639      	mov	r1, r7
 8004916:	4630      	mov	r0, r6
 8004918:	f7fe fce0 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 800491c:	ed85 0a0d 	vstr	s0, [r5, #52]	; 0x34
 8004920:	e7d5      	b.n	80048ce <bsec_GasEstimator_setState+0x46>
 8004922:	bf00      	nop

08004924 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance>:
 8004924:	b510      	push	{r4, lr}
 8004926:	eb00 0481 	add.w	r4, r0, r1, lsl #2
 800492a:	edd4 7a03 	vldr	s15, [r4, #12]
 800492e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8004932:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004936:	ed2d 8b04 	vpush	{d8-d9}
 800493a:	eeb0 8a40 	vmov.f32	s16, s0
 800493e:	eef0 8a60 	vmov.f32	s17, s1
 8004942:	d123      	bne.n	800498c <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance+0x68>
 8004944:	ed94 0a01 	vldr	s0, [r4, #4]
 8004948:	eddf 0a16 	vldr	s1, [pc, #88]	; 80049a4 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance+0x80>
 800494c:	ee30 0a68 	vsub.f32	s0, s0, s17
 8004950:	f024 fe36 	bl	80295c0 <fmaxf>
 8004954:	edd4 7a03 	vldr	s15, [r4, #12]
 8004958:	eddf 0a12 	vldr	s1, [pc, #72]	; 80049a4 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance+0x80>
 800495c:	eeb0 9a40 	vmov.f32	s18, s0
 8004960:	ee38 0ae7 	vsub.f32	s0, s17, s15
 8004964:	f024 fe2c 	bl	80295c0 <fmaxf>
 8004968:	eef0 0a40 	vmov.f32	s1, s0
 800496c:	eeb0 0a49 	vmov.f32	s0, s18
 8004970:	f024 fe41 	bl	80295f6 <fminf>
 8004974:	ee30 0a00 	vadd.f32	s0, s0, s0
 8004978:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 800497c:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8004980:	ecbd 8b04 	vpop	{d8-d9}
 8004984:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8004988:	f024 be35 	b.w	80295f6 <fminf>
 800498c:	ed94 0a01 	vldr	s0, [r4, #4]
 8004990:	eef0 0a48 	vmov.f32	s1, s16
 8004994:	ee30 0a67 	vsub.f32	s0, s0, s15
 8004998:	f024 fe12 	bl	80295c0 <fmaxf>
 800499c:	eeb0 8a40 	vmov.f32	s16, s0
 80049a0:	e7d0      	b.n	8004944 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance+0x20>
 80049a2:	bf00      	nop
 80049a4:	00000000 	.word	0x00000000

080049a8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>:
 80049a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80049ac:	ed2d 8b04 	vpush	{d8-d9}
 80049b0:	eddf 7a63 	vldr	s15, [pc, #396]	; 8004b40 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x198>
 80049b4:	edd0 8a01 	vldr	s17, [r0, #4]
 80049b8:	f89d 9030 	ldrb.w	r9, [sp, #48]	; 0x30
 80049bc:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
 80049c0:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80049c4:	4606      	mov	r6, r0
 80049c6:	468a      	mov	sl, r1
 80049c8:	461c      	mov	r4, r3
 80049ca:	4615      	mov	r5, r2
 80049cc:	2a00      	cmp	r2, #0
 80049ce:	d156      	bne.n	8004a7e <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xd6>
 80049d0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80049d4:	edd3 7a03 	vldr	s15, [r3, #12]
 80049d8:	ed91 8a00 	vldr	s16, [r1]
 80049dc:	ee38 9aa7 	vadd.f32	s18, s17, s15
 80049e0:	8873      	ldrh	r3, [r6, #2]
 80049e2:	ed9f 6a58 	vldr	s12, [pc, #352]	; 8004b44 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x19c>
 80049e6:	eb06 0784 	add.w	r7, r6, r4, lsl #2
 80049ea:	ee07 3a10 	vmov	s14, r3
 80049ee:	edd7 6a07 	vldr	s13, [r7, #28]
 80049f2:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 80049f6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 80049fa:	eef4 6a67 	vcmp.f32	s13, s15
 80049fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a02:	eec7 9a06 	vdiv.f32	s19, s14, s12
 8004a06:	ee30 8a48 	vsub.f32	s16, s0, s16
 8004a0a:	d06b      	beq.n	8004ae4 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x13c>
 8004a0c:	eddf 7a4e 	vldr	s15, [pc, #312]	; 8004b48 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1a0>
 8004a10:	ee68 7aa7 	vmul.f32	s15, s17, s15
 8004a14:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8004a18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a1c:	ee77 8aa8 	vadd.f32	s17, s15, s17
 8004a20:	dd4e      	ble.n	8004ac0 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x118>
 8004a22:	2c01      	cmp	r4, #1
 8004a24:	bf06      	itte	eq
 8004a26:	eb06 0989 	addeq.w	r9, r6, r9, lsl #2
 8004a2a:	ed99 7a0b 	vldreq	s14, [r9, #44]	; 0x2c
 8004a2e:	ed9f 7a47 	vldrne	s14, [pc, #284]	; 8004b4c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1a4>
 8004a32:	f1b8 0f00 	cmp.w	r8, #0
 8004a36:	d031      	beq.n	8004a9c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xf4>
 8004a38:	edd6 7a01 	vldr	s15, [r6, #4]
 8004a3c:	eddf 6a44 	vldr	s13, [pc, #272]	; 8004b50 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1a8>
 8004a40:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004a44:	ee87 0a87 	vdiv.f32	s0, s15, s14
 8004a48:	ee20 0a29 	vmul.f32	s0, s0, s19
 8004a4c:	eeb4 8a40 	vcmp.f32	s16, s0
 8004a50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a54:	bfc8      	it	gt
 8004a56:	eeb0 8a40 	vmovgt.f32	s16, s0
 8004a5a:	edda 7a00 	vldr	s15, [sl]
 8004a5e:	ee38 8a27 	vadd.f32	s16, s16, s15
 8004a62:	eeb4 8ac9 	vcmpe.f32	s16, s18
 8004a66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004a6a:	bf58      	it	pl
 8004a6c:	eeb0 9a48 	vmovpl.f32	s18, s16
 8004a70:	b9f5      	cbnz	r5, 8004ab0 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x108>
 8004a72:	ed8a 9a00 	vstr	s18, [sl]
 8004a76:	ecbd 8b04 	vpop	{d8-d9}
 8004a7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004a7e:	ed91 8a00 	vldr	s16, [r1]
 8004a82:	eeb1 8a48 	vneg.f32	s16, s16
 8004a86:	ed81 8a00 	vstr	s16, [r1]
 8004a8a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8004a8e:	edd3 7a01 	vldr	s15, [r3, #4]
 8004a92:	eeb1 0a40 	vneg.f32	s0, s0
 8004a96:	ee38 9ae7 	vsub.f32	s18, s17, s15
 8004a9a:	e7a1      	b.n	80049e0 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x38>
 8004a9c:	eddf 7a2b 	vldr	s15, [pc, #172]	; 8004b4c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1a4>
 8004aa0:	eeb4 8a68 	vcmp.f32	s16, s17
 8004aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004aa8:	bfc8      	it	gt
 8004aaa:	eeb0 7a67 	vmovgt.f32	s14, s15
 8004aae:	e7c3      	b.n	8004a38 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x90>
 8004ab0:	eef1 7a49 	vneg.f32	s15, s18
 8004ab4:	ecbd 8b04 	vpop	{d8-d9}
 8004ab8:	edca 7a00 	vstr	s15, [sl]
 8004abc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004ac0:	f1b8 0f00 	cmp.w	r8, #0
 8004ac4:	d029      	beq.n	8004b1a <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x172>
 8004ac6:	edd7 7a35 	vldr	s15, [r7, #212]	; 0xd4
 8004aca:	eeb1 0a69 	vneg.f32	s0, s19
 8004ace:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8004ad2:	f024 ff19 	bl	8029908 <expf>
 8004ad6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8004ada:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8004ade:	ee28 8a00 	vmul.f32	s16, s16, s0
 8004ae2:	e7ba      	b.n	8004a5a <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xb2>
 8004ae4:	edd7 7a01 	vldr	s15, [r7, #4]
 8004ae8:	eddf 0a1a 	vldr	s1, [pc, #104]	; 8004b54 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1ac>
 8004aec:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8004af0:	f024 fd66 	bl	80295c0 <fmaxf>
 8004af4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004af8:	ee37 0a40 	vsub.f32	s0, s14, s0
 8004afc:	eef6 7a08 	vmov.f32	s15, #104	; 0x3f400000  0.750
 8004b00:	ee20 0a00 	vmul.f32	s0, s0, s0
 8004b04:	eddf 6a14 	vldr	s13, [pc, #80]	; 8004b58 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1b0>
 8004b08:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8004b5c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x1b4>
 8004b0c:	ee60 7a27 	vmul.f32	s15, s0, s15
 8004b10:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004b14:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004b18:	e77a      	b.n	8004a10 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x68>
 8004b1a:	eeb0 0a48 	vmov.f32	s0, s16
 8004b1e:	f024 fd05 	bl	802952c <fabsf>
 8004b22:	eeb4 0ae8 	vcmpe.f32	s0, s17
 8004b26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004b2a:	ddcc      	ble.n	8004ac6 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x11e>
 8004b2c:	2c01      	cmp	r4, #1
 8004b2e:	d1ca      	bne.n	8004ac6 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x11e>
 8004b30:	edd6 6a36 	vldr	s13, [r6, #216]	; 0xd8
 8004b34:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
 8004b38:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004b3c:	e7c5      	b.n	8004aca <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x122>
 8004b3e:	bf00      	nop
 8004b40:	3dc678c1 	.word	0x3dc678c1
 8004b44:	42c80000 	.word	0x42c80000
 8004b48:	3e99999a 	.word	0x3e99999a
 8004b4c:	44e10000 	.word	0x44e10000
 8004b50:	3ecbbecb 	.word	0x3ecbbecb
 8004b54:	00000000 	.word	0x00000000
 8004b58:	3e4ccccd 	.word	0x3e4ccccd
 8004b5c:	3dcccccd 	.word	0x3dcccccd

08004b60 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0>:
 8004b60:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 8004b64:	ed93 7a07 	vldr	s14, [r3, #28]
 8004b68:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 8004b6c:	eeb4 7a67 	vcmp.f32	s14, s15
 8004b70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004b74:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8004b78:	d12a      	bne.n	8004bd0 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0x70>
 8004b7a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004b7e:	ee77 0a60 	vsub.f32	s1, s14, s1
 8004b82:	eef6 7a08 	vmov.f32	s15, #104	; 0x3f400000  0.750
 8004b86:	ee60 0aa0 	vmul.f32	s1, s1, s1
 8004b8a:	eddf 6a1f 	vldr	s13, [pc, #124]	; 8004c08 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0xa8>
 8004b8e:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8004c0c <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0xac>
 8004b92:	ee60 7aa7 	vmul.f32	s15, s1, s15
 8004b96:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8004b9a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004b9e:	ee00 0a27 	vmla.f32	s0, s0, s15
 8004ba2:	edd3 6a03 	vldr	s13, [r3, #12]
 8004ba6:	ed93 7a01 	vldr	s14, [r3, #4]
 8004baa:	ee77 7a66 	vsub.f32	s15, s14, s13
 8004bae:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8004bb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004bb6:	dc04      	bgt.n	8004bc2 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0x62>
 8004bb8:	eef5 6a40 	vcmp.f32	s13, #0.0
 8004bbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004bc0:	d109      	bne.n	8004bd6 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0x76>
 8004bc2:	4402      	add	r2, r0
 8004bc4:	f890 30e0 	ldrb.w	r3, [r0, #224]	; 0xe0
 8004bc8:	7713      	strb	r3, [r2, #28]
 8004bca:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8004bce:	4770      	bx	lr
 8004bd0:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8004c10 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0xb0>
 8004bd4:	e7e3      	b.n	8004b9e <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0x3e>
 8004bd6:	b969      	cbnz	r1, 8004bf4 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0x94>
 8004bd8:	1883      	adds	r3, r0, r2
 8004bda:	7f1a      	ldrb	r2, [r3, #28]
 8004bdc:	2aff      	cmp	r2, #255	; 0xff
 8004bde:	d00f      	beq.n	8004c00 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0xa0>
 8004be0:	3201      	adds	r2, #1
 8004be2:	b2d2      	uxtb	r2, r2
 8004be4:	771a      	strb	r2, [r3, #28]
 8004be6:	f890 30e0 	ldrb.w	r3, [r0, #224]	; 0xe0
 8004bea:	4293      	cmp	r3, r2
 8004bec:	d908      	bls.n	8004c00 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0+0xa0>
 8004bee:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8004bf2:	4770      	bx	lr
 8004bf4:	4402      	add	r2, r0
 8004bf6:	2300      	movs	r3, #0
 8004bf8:	7713      	strb	r3, [r2, #28]
 8004bfa:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8004bfe:	4770      	bx	lr
 8004c00:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
 8004c04:	4770      	bx	lr
 8004c06:	bf00      	nop
 8004c08:	3e4ccccd 	.word	0x3e4ccccd
 8004c0c:	3dcccccd 	.word	0x3dcccccd
 8004c10:	3e99999a 	.word	0x3e99999a

08004c14 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker>:
 8004c14:	b4f0      	push	{r4, r5, r6, r7}
 8004c16:	4d3f      	ldr	r5, [pc, #252]	; (8004d14 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x100>)
 8004c18:	f8c0 50ec 	str.w	r5, [r0, #236]	; 0xec
 8004c1c:	250a      	movs	r5, #10
 8004c1e:	f8a0 50e2 	strh.w	r5, [r0, #226]	; 0xe2
 8004c22:	2503      	movs	r5, #3
 8004c24:	493c      	ldr	r1, [pc, #240]	; (8004d18 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x104>)
 8004c26:	4a3d      	ldr	r2, [pc, #244]	; (8004d1c <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x108>)
 8004c28:	f8a0 50e4 	strh.w	r5, [r0, #228]	; 0xe4
 8004c2c:	4d3c      	ldr	r5, [pc, #240]	; (8004d20 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x10c>)
 8004c2e:	4e3d      	ldr	r6, [pc, #244]	; (8004d24 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x110>)
 8004c30:	4c3d      	ldr	r4, [pc, #244]	; (8004d28 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x114>)
 8004c32:	f8c0 50e8 	str.w	r5, [r0, #232]	; 0xe8
 8004c36:	63c1      	str	r1, [r0, #60]	; 0x3c
 8004c38:	4d3c      	ldr	r5, [pc, #240]	; (8004d2c <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x118>)
 8004c3a:	493d      	ldr	r1, [pc, #244]	; (8004d30 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x11c>)
 8004c3c:	6402      	str	r2, [r0, #64]	; 0x40
 8004c3e:	4a3d      	ldr	r2, [pc, #244]	; (8004d34 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x120>)
 8004c40:	6442      	str	r2, [r0, #68]	; 0x44
 8004c42:	6486      	str	r6, [r0, #72]	; 0x48
 8004c44:	2200      	movs	r2, #0
 8004c46:	4e3c      	ldr	r6, [pc, #240]	; (8004d38 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x124>)
 8004c48:	6584      	str	r4, [r0, #88]	; 0x58
 8004c4a:	f8c0 5098 	str.w	r5, [r0, #152]	; 0x98
 8004c4e:	2401      	movs	r4, #1
 8004c50:	2500      	movs	r5, #0
 8004c52:	f8c0 109c 	str.w	r1, [r0, #156]	; 0x9c
 8004c56:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8004c5a:	7004      	strb	r4, [r0, #0]
 8004c5c:	6282      	str	r2, [r0, #40]	; 0x28
 8004c5e:	64c2      	str	r2, [r0, #76]	; 0x4c
 8004c60:	6502      	str	r2, [r0, #80]	; 0x50
 8004c62:	6542      	str	r2, [r0, #84]	; 0x54
 8004c64:	65c2      	str	r2, [r0, #92]	; 0x5c
 8004c66:	6602      	str	r2, [r0, #96]	; 0x60
 8004c68:	6682      	str	r2, [r0, #104]	; 0x68
 8004c6a:	6702      	str	r2, [r0, #112]	; 0x70
 8004c6c:	6742      	str	r2, [r0, #116]	; 0x74
 8004c6e:	67c2      	str	r2, [r0, #124]	; 0x7c
 8004c70:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
 8004c74:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
 8004c78:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90
 8004c7c:	8585      	strh	r5, [r0, #44]	; 0x2c
 8004c7e:	6641      	str	r1, [r0, #100]	; 0x64
 8004c80:	66c1      	str	r1, [r0, #108]	; 0x6c
 8004c82:	6781      	str	r1, [r0, #120]	; 0x78
 8004c84:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8004c88:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
 8004c8c:	f8c0 1094 	str.w	r1, [r0, #148]	; 0x94
 8004c90:	492a      	ldr	r1, [pc, #168]	; (8004d3c <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x128>)
 8004c92:	f8c0 60a0 	str.w	r6, [r0, #160]	; 0xa0
 8004c96:	4e2a      	ldr	r6, [pc, #168]	; (8004d40 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x12c>)
 8004c98:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
 8004c9c:	f8c0 60d8 	str.w	r6, [r0, #216]	; 0xd8
 8004ca0:	4c28      	ldr	r4, [pc, #160]	; (8004d44 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x130>)
 8004ca2:	f8c0 10dc 	str.w	r1, [r0, #220]	; 0xdc
 8004ca6:	2602      	movs	r6, #2
 8004ca8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004cac:	4f26      	ldr	r7, [pc, #152]	; (8004d48 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x134>)
 8004cae:	6202      	str	r2, [r0, #32]
 8004cb0:	6042      	str	r2, [r0, #4]
 8004cb2:	6082      	str	r2, [r0, #8]
 8004cb4:	60c2      	str	r2, [r0, #12]
 8004cb6:	6102      	str	r2, [r0, #16]
 8004cb8:	6142      	str	r2, [r0, #20]
 8004cba:	6185      	str	r5, [r0, #24]
 8004cbc:	6242      	str	r2, [r0, #36]	; 0x24
 8004cbe:	4d23      	ldr	r5, [pc, #140]	; (8004d4c <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x138>)
 8004cc0:	4a23      	ldr	r2, [pc, #140]	; (8004d50 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x13c>)
 8004cc2:	f8c0 40cc 	str.w	r4, [r0, #204]	; 0xcc
 8004cc6:	f880 60e0 	strb.w	r6, [r0, #224]	; 0xe0
 8004cca:	4c22      	ldr	r4, [pc, #136]	; (8004d54 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x140>)
 8004ccc:	8041      	strh	r1, [r0, #2]
 8004cce:	f240 2602 	movw	r6, #514	; 0x202
 8004cd2:	4921      	ldr	r1, [pc, #132]	; (8004d58 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x144>)
 8004cd4:	f8df c084 	ldr.w	ip, [pc, #132]	; 8004d5c <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x148>
 8004cd8:	f8c0 c0a4 	str.w	ip, [r0, #164]	; 0xa4
 8004cdc:	f8c0 70a8 	str.w	r7, [r0, #168]	; 0xa8
 8004ce0:	8386      	strh	r6, [r0, #28]
 8004ce2:	f8c0 10ac 	str.w	r1, [r0, #172]	; 0xac
 8004ce6:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
 8004cea:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
 8004cee:	f8c0 10c8 	str.w	r1, [r0, #200]	; 0xc8
 8004cf2:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
 8004cf6:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
 8004cfa:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
 8004cfe:	f8c0 20c4 	str.w	r2, [r0, #196]	; 0xc4
 8004d02:	f8c0 50d0 	str.w	r5, [r0, #208]	; 0xd0
 8004d06:	f8c0 50d4 	str.w	r5, [r0, #212]	; 0xd4
 8004d0a:	6304      	str	r4, [r0, #48]	; 0x30
 8004d0c:	6344      	str	r4, [r0, #52]	; 0x34
 8004d0e:	bcf0      	pop	{r4, r5, r6, r7}
 8004d10:	4770      	bx	lr
 8004d12:	bf00      	nop
 8004d14:	38d1b717 	.word	0x38d1b717
 8004d18:	bf004189 	.word	0xbf004189
 8004d1c:	becccccd 	.word	0xbecccccd
 8004d20:	40600000 	.word	0x40600000
 8004d24:	be947ae1 	.word	0xbe947ae1
 8004d28:	bdcccccd 	.word	0xbdcccccd
 8004d2c:	bc9d4952 	.word	0xbc9d4952
 8004d30:	3dcb295f 	.word	0x3dcb295f
 8004d34:	bf400000 	.word	0xbf400000
 8004d38:	3f6ce076 	.word	0x3f6ce076
 8004d3c:	4c773140 	.word	0x4c773140
 8004d40:	47a8c000 	.word	0x47a8c000
 8004d44:	640055d8 	.word	0x640055d8
 8004d48:	3f7c0ebf 	.word	0x3f7c0ebf
 8004d4c:	45610000 	.word	0x45610000
 8004d50:	42200000 	.word	0x42200000
 8004d54:	44e10000 	.word	0x44e10000
 8004d58:	41a00000 	.word	0x41a00000
 8004d5c:	3f7de69b 	.word	0x3f7de69b

08004d60 <bsec_GasHumidityBaselineTracker_configure>:
 8004d60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004d64:	b086      	sub	sp, #24
 8004d66:	ab04      	add	r3, sp, #16
 8004d68:	ae05      	add	r6, sp, #20
 8004d6a:	4604      	mov	r4, r0
 8004d6c:	7800      	ldrb	r0, [r0, #0]
 8004d6e:	e9cd 3600 	strd	r3, r6, [sp]
 8004d72:	f10d 030f 	add.w	r3, sp, #15
 8004d76:	460d      	mov	r5, r1
 8004d78:	f001 fe8a 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8004d7c:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8004d80:	b9e8      	cbnz	r0, 8004dbe <bsec_GasHumidityBaselineTracker_configure+0x5e>
 8004d82:	f04f 0a01 	mov.w	sl, #1
 8004d86:	f104 09e8 	add.w	r9, r4, #232	; 0xe8
 8004d8a:	f104 08ce 	add.w	r8, r4, #206	; 0xce
 8004d8e:	f104 07cc 	add.w	r7, r4, #204	; 0xcc
 8004d92:	fa5f f38a 	uxtb.w	r3, sl
 8004d96:	3b01      	subs	r3, #1
 8004d98:	2b05      	cmp	r3, #5
 8004d9a:	d835      	bhi.n	8004e08 <bsec_GasHumidityBaselineTracker_configure+0xa8>
 8004d9c:	e8df f003 	tbb	[pc, r3]
 8004da0:	181f262d 	.word	0x181f262d
 8004da4:	0312      	.short	0x0312
 8004da6:	4642      	mov	r2, r8
 8004da8:	4631      	mov	r1, r6
 8004daa:	4628      	mov	r0, r5
 8004dac:	f7fe fa5a 	bl	8003264 <bsec_d_Entity_parseAndDeserialize>
 8004db0:	f10a 0a01 	add.w	sl, sl, #1
 8004db4:	f1ba 0f08 	cmp.w	sl, #8
 8004db8:	d1eb      	bne.n	8004d92 <bsec_GasHumidityBaselineTracker_configure+0x32>
 8004dba:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8004dbe:	b006      	add	sp, #24
 8004dc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004dc4:	463a      	mov	r2, r7
 8004dc6:	4631      	mov	r1, r6
 8004dc8:	4628      	mov	r0, r5
 8004dca:	f7fe fce7 	bl	800379c <bsec_o_Entity_parseAndDeserialize>
 8004dce:	e7ef      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>
 8004dd0:	f104 02e2 	add.w	r2, r4, #226	; 0xe2
 8004dd4:	4631      	mov	r1, r6
 8004dd6:	4628      	mov	r0, r5
 8004dd8:	f7fe fca0 	bl	800371c <bsec_n_Entity_parseAndDeserialize>
 8004ddc:	e7e8      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>
 8004dde:	f104 023c 	add.w	r2, r4, #60	; 0x3c
 8004de2:	4631      	mov	r1, r6
 8004de4:	4628      	mov	r0, r5
 8004de6:	f7fe fc67 	bl	80036b8 <bsec_m_Entity_parseAndDeserialize>
 8004dea:	e7e1      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>
 8004dec:	f104 02d0 	add.w	r2, r4, #208	; 0xd0
 8004df0:	4631      	mov	r1, r6
 8004df2:	4628      	mov	r0, r5
 8004df4:	f7fe f98e 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8004df8:	e7da      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>
 8004dfa:	f104 02d8 	add.w	r2, r4, #216	; 0xd8
 8004dfe:	4631      	mov	r1, r6
 8004e00:	4628      	mov	r0, r5
 8004e02:	f7fe f987 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8004e06:	e7d3      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>
 8004e08:	464a      	mov	r2, r9
 8004e0a:	4631      	mov	r1, r6
 8004e0c:	4628      	mov	r0, r5
 8004e0e:	f7fe f981 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8004e12:	e7cd      	b.n	8004db0 <bsec_GasHumidityBaselineTracker_configure+0x50>

08004e14 <bsec_GasHumidityBaselineTracker_doStep>:
 8004e14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004e18:	ed9f 7aec 	vldr	s14, [pc, #944]	; 80051cc <bsec_GasHumidityBaselineTracker_doStep+0x3b8>
 8004e1c:	eddf 7aec 	vldr	s15, [pc, #944]	; 80051d0 <bsec_GasHumidityBaselineTracker_doStep+0x3bc>
 8004e20:	eddf 6aec 	vldr	s13, [pc, #944]	; 80051d4 <bsec_GasHumidityBaselineTracker_doStep+0x3c0>
 8004e24:	ed2d 8b0c 	vpush	{d8-d13}
 8004e28:	ee20 7a87 	vmul.f32	s14, s1, s14
 8004e2c:	ee70 7aa7 	vadd.f32	s15, s1, s15
 8004e30:	b088      	sub	sp, #32
 8004e32:	ed90 9a01 	vldr	s18, [r0, #4]
 8004e36:	f89d a070 	ldrb.w	sl, [sp, #112]	; 0x70
 8004e3a:	eeb0 8a40 	vmov.f32	s16, s0
 8004e3e:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8004e42:	e9dd 561d 	ldrd	r5, r6, [sp, #116]	; 0x74
 8004e46:	4604      	mov	r4, r0
 8004e48:	4689      	mov	r9, r1
 8004e4a:	4690      	mov	r8, r2
 8004e4c:	461f      	mov	r7, r3
 8004e4e:	ee29 9a26 	vmul.f32	s18, s18, s13
 8004e52:	eef0 8a60 	vmov.f32	s17, s1
 8004e56:	eef0 aa41 	vmov.f32	s21, s2
 8004e5a:	eeb0 ba61 	vmov.f32	s22, s3
 8004e5e:	f024 fd53 	bl	8029908 <expf>
 8004e62:	eddf 6add 	vldr	s13, [pc, #884]	; 80051d8 <bsec_GasHumidityBaselineTracker_doStep+0x3c4>
 8004e66:	ed9f 5add 	vldr	s10, [pc, #884]	; 80051dc <bsec_GasHumidityBaselineTracker_doStep+0x3c8>
 8004e6a:	ed9f 7add 	vldr	s14, [pc, #884]	; 80051e0 <bsec_GasHumidityBaselineTracker_doStep+0x3cc>
 8004e6e:	eddf 5add 	vldr	s11, [pc, #884]	; 80051e4 <bsec_GasHumidityBaselineTracker_doStep+0x3d0>
 8004e72:	ed9f 6add 	vldr	s12, [pc, #884]	; 80051e8 <bsec_GasHumidityBaselineTracker_doStep+0x3d4>
 8004e76:	ee6a 6aa6 	vmul.f32	s13, s21, s13
 8004e7a:	ee38 7a87 	vadd.f32	s14, s17, s14
 8004e7e:	eec6 7a85 	vdiv.f32	s15, s13, s10
 8004e82:	ee27 0a80 	vmul.f32	s0, s15, s0
 8004e86:	eec0 7a07 	vdiv.f32	s15, s0, s14
 8004e8a:	ee27 0aa5 	vmul.f32	s0, s15, s11
 8004e8e:	eeb4 0ac6 	vcmpe.f32	s0, s12
 8004e92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004e96:	f300 8205 	bgt.w	80052a4 <bsec_GasHumidityBaselineTracker_doStep+0x490>
 8004e9a:	8863      	ldrh	r3, [r4, #2]
 8004e9c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8004ea0:	eef8 9a00 	vmov.f32	s19, #128	; 0xc0000000 -2.0
 8004ea4:	f04f 020c 	mov.w	r2, #12
 8004ea8:	f000 8207 	beq.w	80052ba <bsec_GasHumidityBaselineTracker_doStep+0x4a6>
 8004eac:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 8004eb0:	f000 822b 	beq.w	800530a <bsec_GasHumidityBaselineTracker_doStep+0x4f6>
 8004eb4:	2b64      	cmp	r3, #100	; 0x64
 8004eb6:	f000 8214 	beq.w	80052e2 <bsec_GasHumidityBaselineTracker_doStep+0x4ce>
 8004eba:	f104 015c 	add.w	r1, r4, #92	; 0x5c
 8004ebe:	a805      	add	r0, sp, #20
 8004ec0:	ed94 ca0f 	vldr	s24, [r4, #60]	; 0x3c
 8004ec4:	edd4 ba13 	vldr	s23, [r4, #76]	; 0x4c
 8004ec8:	f027 f90a 	bl	802c0e0 <memcpy>
 8004ecc:	2208      	movs	r2, #8
 8004ece:	f104 0168 	add.w	r1, r4, #104	; 0x68
 8004ed2:	a803      	add	r0, sp, #12
 8004ed4:	f027 f904 	bl	802c0e0 <memcpy>
 8004ed8:	ed94 aa2b 	vldr	s20, [r4, #172]	; 0xac
 8004edc:	ed94 da2f 	vldr	s26, [r4, #188]	; 0xbc
 8004ee0:	ed9f 0aba 	vldr	s0, [pc, #744]	; 80051cc <bsec_GasHumidityBaselineTracker_doStep+0x3b8>
 8004ee4:	eddf 7aba 	vldr	s15, [pc, #744]	; 80051d0 <bsec_GasHumidityBaselineTracker_doStep+0x3bc>
 8004ee8:	eddf cabc 	vldr	s25, [pc, #752]	; 80051dc <bsec_GasHumidityBaselineTracker_doStep+0x3c8>
 8004eec:	ee7a 7a27 	vadd.f32	s15, s20, s15
 8004ef0:	ee2a 0a00 	vmul.f32	s0, s20, s0
 8004ef4:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8004ef8:	f024 fd06 	bl	8029908 <expf>
 8004efc:	ed9f 7ab6 	vldr	s14, [pc, #728]	; 80051d8 <bsec_GasHumidityBaselineTracker_doStep+0x3c4>
 8004f00:	eddf 7ab7 	vldr	s15, [pc, #732]	; 80051e0 <bsec_GasHumidityBaselineTracker_doStep+0x3cc>
 8004f04:	eddf 6ab7 	vldr	s13, [pc, #732]	; 80051e4 <bsec_GasHumidityBaselineTracker_doStep+0x3d0>
 8004f08:	ee2d da07 	vmul.f32	s26, s26, s14
 8004f0c:	ee7a 7a27 	vadd.f32	s15, s20, s15
 8004f10:	ee8d 7a2c 	vdiv.f32	s14, s26, s25
 8004f14:	ee27 7a00 	vmul.f32	s14, s14, s0
 8004f18:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8004f1c:	ee20 0a26 	vmul.f32	s0, s0, s13
 8004f20:	f024 fd66 	bl	80299f0 <log10f>
 8004f24:	edd4 0a02 	vldr	s1, [r4, #8]
 8004f28:	eef5 0a40 	vcmp.f32	s1, #0.0
 8004f2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004f30:	f040 818d 	bne.w	800524e <bsec_GasHumidityBaselineTracker_doStep+0x43a>
 8004f34:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8004f38:	ee68 baab 	vmul.f32	s23, s17, s23
 8004f3c:	ed9f 7aa7 	vldr	s14, [pc, #668]	; 80051dc <bsec_GasHumidityBaselineTracker_doStep+0x3c8>
 8004f40:	eecb 7a87 	vdiv.f32	s15, s23, s14
 8004f44:	ee69 9a8c 	vmul.f32	s19, s19, s24
 8004f48:	ee77 9aa9 	vadd.f32	s19, s15, s19
 8004f4c:	ee38 8a69 	vsub.f32	s16, s16, s19
 8004f50:	ee38 8a60 	vsub.f32	s16, s16, s1
 8004f54:	ee28 0a00 	vmul.f32	s0, s16, s0
 8004f58:	ee30 0a20 	vadd.f32	s0, s0, s1
 8004f5c:	ed86 0a00 	vstr	s0, [r6]
 8004f60:	f994 30cd 	ldrsb.w	r3, [r4, #205]	; 0xcd
 8004f64:	ee07 3a90 	vmov	s15, r3
 8004f68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004f6c:	eef4 8ae7 	vcmpe.f32	s17, s15
 8004f70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004f74:	f200 8123 	bhi.w	80051be <bsec_GasHumidityBaselineTracker_doStep+0x3aa>
 8004f78:	f994 30cc 	ldrsb.w	r3, [r4, #204]	; 0xcc
 8004f7c:	ee07 3a90 	vmov	s15, r3
 8004f80:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004f84:	eef4 8ae7 	vcmpe.f32	s17, s15
 8004f88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004f8c:	f2c0 8117 	blt.w	80051be <bsec_GasHumidityBaselineTracker_doStep+0x3aa>
 8004f90:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
 8004f94:	ee07 3a90 	vmov	s15, r3
 8004f98:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004f9c:	eef4 aae7 	vcmpe.f32	s21, s15
 8004fa0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004fa4:	f200 810b 	bhi.w	80051be <bsec_GasHumidityBaselineTracker_doStep+0x3aa>
 8004fa8:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
 8004fac:	ee07 3a90 	vmov	s15, r3
 8004fb0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004fb4:	eef4 aae7 	vcmpe.f32	s21, s15
 8004fb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004fbc:	f2c0 80ff 	blt.w	80051be <bsec_GasHumidityBaselineTracker_doStep+0x3aa>
 8004fc0:	f1b8 0f00 	cmp.w	r8, #0
 8004fc4:	f000 80fb 	beq.w	80051be <bsec_GasHumidityBaselineTracker_doStep+0x3aa>
 8004fc8:	f1ba 0f00 	cmp.w	sl, #0
 8004fcc:	f040 80bc 	bne.w	8005148 <bsec_GasHumidityBaselineTracker_doStep+0x334>
 8004fd0:	eeb5 ba40 	vcmp.f32	s22, #0.0
 8004fd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004fd8:	f040 81d8 	bne.w	800538c <bsec_GasHumidityBaselineTracker_doStep+0x578>
 8004fdc:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 8004fe0:	eef5 7a40 	vcmp.f32	s15, #0.0
 8004fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004fe8:	f040 81ef 	bne.w	80053ca <bsec_GasHumidityBaselineTracker_doStep+0x5b6>
 8004fec:	edd4 7a02 	vldr	s15, [r4, #8]
 8004ff0:	eef5 7a40 	vcmp.f32	s15, #0.0
 8004ff4:	edd4 7a04 	vldr	s15, [r4, #16]
 8004ff8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004ffc:	bf08      	it	eq
 8004ffe:	ed84 0a02 	vstreq	s0, [r4, #8]
 8005002:	eef5 7a40 	vcmp.f32	s15, #0.0
 8005006:	bf08      	it	eq
 8005008:	ed96 0a00 	vldreq	s0, [r6]
 800500c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005010:	d10c      	bne.n	800502c <bsec_GasHumidityBaselineTracker_doStep+0x218>
 8005012:	edd4 7a02 	vldr	s15, [r4, #8]
 8005016:	ee77 7ac9 	vsub.f32	s15, s15, s18
 800501a:	eef4 7ac0 	vcmpe.f32	s15, s0
 800501e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005022:	bfc4      	itt	gt
 8005024:	ed84 0a04 	vstrgt	s0, [r4, #16]
 8005028:	ed96 0a00 	vldrgt	s0, [r6]
 800502c:	9701      	str	r7, [sp, #4]
 800502e:	2302      	movs	r3, #2
 8005030:	9300      	str	r3, [sp, #0]
 8005032:	2200      	movs	r2, #0
 8005034:	2301      	movs	r3, #1
 8005036:	f104 0108 	add.w	r1, r4, #8
 800503a:	4620      	mov	r0, r4
 800503c:	f7ff fcb4 	bl	80049a8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
 8005040:	edd4 7a04 	vldr	s15, [r4, #16]
 8005044:	eef5 7a40 	vcmp.f32	s15, #0.0
 8005048:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800504c:	f040 8186 	bne.w	800535c <bsec_GasHumidityBaselineTracker_doStep+0x548>
 8005050:	edd4 7a03 	vldr	s15, [r4, #12]
 8005054:	eef5 7a40 	vcmp.f32	s15, #0.0
 8005058:	edd4 7a05 	vldr	s15, [r4, #20]
 800505c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005060:	bf04      	itt	eq
 8005062:	6833      	ldreq	r3, [r6, #0]
 8005064:	60e3      	streq	r3, [r4, #12]
 8005066:	eef5 7a40 	vcmp.f32	s15, #0.0
 800506a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800506e:	d10c      	bne.n	800508a <bsec_GasHumidityBaselineTracker_doStep+0x276>
 8005070:	edd4 7a03 	vldr	s15, [r4, #12]
 8005074:	ed96 0a00 	vldr	s0, [r6]
 8005078:	ee77 7ac9 	vsub.f32	s15, s15, s18
 800507c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005084:	d503      	bpl.n	800508e <bsec_GasHumidityBaselineTracker_doStep+0x27a>
 8005086:	ed84 0a05 	vstr	s0, [r4, #20]
 800508a:	ed96 0a00 	vldr	s0, [r6]
 800508e:	9701      	str	r7, [sp, #4]
 8005090:	f04f 0a02 	mov.w	sl, #2
 8005094:	f8cd a000 	str.w	sl, [sp]
 8005098:	4653      	mov	r3, sl
 800509a:	2200      	movs	r2, #0
 800509c:	f104 010c 	add.w	r1, r4, #12
 80050a0:	4620      	mov	r0, r4
 80050a2:	f7ff fc81 	bl	80049a8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
 80050a6:	edd4 7a05 	vldr	s15, [r4, #20]
 80050aa:	eef5 7a40 	vcmp.f32	s15, #0.0
 80050ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050b2:	f040 815f 	bne.w	8005374 <bsec_GasHumidityBaselineTracker_doStep+0x560>
 80050b6:	ed96 0a00 	vldr	s0, [r6]
 80050ba:	edd4 7a02 	vldr	s15, [r4, #8]
 80050be:	eef4 7ac0 	vcmpe.f32	s15, s0
 80050c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050c6:	d97e      	bls.n	80051c6 <bsec_GasHumidityBaselineTracker_doStep+0x3b2>
 80050c8:	edd4 7a04 	vldr	s15, [r4, #16]
 80050cc:	eef4 7ac0 	vcmpe.f32	s15, s0
 80050d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050d4:	bfac      	ite	ge
 80050d6:	f04f 0a01 	movge.w	sl, #1
 80050da:	f04f 0a00 	movlt.w	sl, #0
 80050de:	eef0 0a40 	vmov.f32	s1, s0
 80050e2:	2101      	movs	r1, #1
 80050e4:	eeb0 0a49 	vmov.f32	s0, s18
 80050e8:	4620      	mov	r0, r4
 80050ea:	f7ff fc1b 	bl	8004924 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance>
 80050ee:	f1b9 0f00 	cmp.w	r9, #0
 80050f2:	d07d      	beq.n	80051f0 <bsec_GasHumidityBaselineTracker_doStep+0x3dc>
 80050f4:	f1b8 0f00 	cmp.w	r8, #0
 80050f8:	d07a      	beq.n	80051f0 <bsec_GasHumidityBaselineTracker_doStep+0x3dc>
 80050fa:	eef0 0a40 	vmov.f32	s1, s0
 80050fe:	4651      	mov	r1, sl
 8005100:	2201      	movs	r2, #1
 8005102:	eeb0 0a49 	vmov.f32	s0, s18
 8005106:	4620      	mov	r0, r4
 8005108:	f7ff fd2a 	bl	8004b60 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0>
 800510c:	ed84 0a08 	vstr	s0, [r4, #32]
 8005110:	ed96 8a00 	vldr	s16, [r6]
 8005114:	edd4 7a03 	vldr	s15, [r4, #12]
 8005118:	eef4 7ac8 	vcmpe.f32	s15, s16
 800511c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005120:	f200 8107 	bhi.w	8005332 <bsec_GasHumidityBaselineTracker_doStep+0x51e>
 8005124:	eef0 0a48 	vmov.f32	s1, s16
 8005128:	2102      	movs	r1, #2
 800512a:	eeb0 0a49 	vmov.f32	s0, s18
 800512e:	f7ff fbf9 	bl	8004924 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance>
 8005132:	eef0 0a40 	vmov.f32	s1, s0
 8005136:	4641      	mov	r1, r8
 8005138:	2202      	movs	r2, #2
 800513a:	eeb0 0a49 	vmov.f32	s0, s18
 800513e:	4620      	mov	r0, r4
 8005140:	f7ff fd0e 	bl	8004b60 <bsec_GasHumidityBaselineTracker_determineAccuracyLevel.part.0>
 8005144:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8005148:	ed94 7a02 	vldr	s14, [r4, #8]
 800514c:	edd4 7a03 	vldr	s15, [r4, #12]
 8005150:	ed94 6a08 	vldr	s12, [r4, #32]
 8005154:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8005158:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800515c:	bf08      	it	eq
 800515e:	ed96 7a00 	vldreq	s14, [r6]
 8005162:	eef5 7a40 	vcmp.f32	s15, #0.0
 8005166:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800516a:	bf08      	it	eq
 800516c:	edd6 7a00 	vldreq	s15, [r6]
 8005170:	ed85 7a00 	vstr	s14, [r5]
 8005174:	edd4 6a04 	vldr	s13, [r4, #16]
 8005178:	ed85 6a04 	vstr	s12, [r5, #16]
 800517c:	eef5 6a40 	vcmp.f32	s13, #0.0
 8005180:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005184:	bf08      	it	eq
 8005186:	ee77 6a49 	vsubeq.f32	s13, s14, s18
 800518a:	edc5 7a01 	vstr	s15, [r5, #4]
 800518e:	edc5 6a02 	vstr	s13, [r5, #8]
 8005192:	ed94 7a05 	vldr	s14, [r4, #20]
 8005196:	eeb5 7a40 	vcmp.f32	s14, #0.0
 800519a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800519e:	bf08      	it	eq
 80051a0:	ee37 7ac9 	vsubeq.f32	s14, s15, s18
 80051a4:	ed85 7a03 	vstr	s14, [r5, #12]
 80051a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80051aa:	616b      	str	r3, [r5, #20]
 80051ac:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 80051b0:	2b01      	cmp	r3, #1
 80051b2:	d032      	beq.n	800521a <bsec_GasHumidityBaselineTracker_doStep+0x406>
 80051b4:	b008      	add	sp, #32
 80051b6:	ecbd 8b0c 	vpop	{d8-d13}
 80051ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80051be:	f1ba 0f00 	cmp.w	sl, #0
 80051c2:	d1c1      	bne.n	8005148 <bsec_GasHumidityBaselineTracker_doStep+0x334>
 80051c4:	e779      	b.n	80050ba <bsec_GasHumidityBaselineTracker_doStep+0x2a6>
 80051c6:	f04f 0a01 	mov.w	sl, #1
 80051ca:	e788      	b.n	80050de <bsec_GasHumidityBaselineTracker_doStep+0x2ca>
 80051cc:	418cf5c3 	.word	0x418cf5c3
 80051d0:	43731eb8 	.word	0x43731eb8
 80051d4:	3dc678c1 	.word	0x3dc678c1
 80051d8:	40c39581 	.word	0x40c39581
 80051dc:	42c80000 	.word	0x42c80000
 80051e0:	43889333 	.word	0x43889333
 80051e4:	4358b333 	.word	0x4358b333
 80051e8:	3c23d70a 	.word	0x3c23d70a
 80051ec:	00000000 	.word	0x00000000
 80051f0:	f894 30e0 	ldrb.w	r3, [r4, #224]	; 0xe0
 80051f4:	7723      	strb	r3, [r4, #28]
 80051f6:	2200      	movs	r2, #0
 80051f8:	6222      	str	r2, [r4, #32]
 80051fa:	edd6 0a00 	vldr	s1, [r6]
 80051fe:	2102      	movs	r1, #2
 8005200:	eeb0 0a49 	vmov.f32	s0, s18
 8005204:	4620      	mov	r0, r4
 8005206:	f7ff fb8d 	bl	8004924 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance>
 800520a:	ed1f 0a08 	vldr	s0, [pc, #-32]	; 80051ec <bsec_GasHumidityBaselineTracker_doStep+0x3d8>
 800520e:	f894 30e0 	ldrb.w	r3, [r4, #224]	; 0xe0
 8005212:	7763      	strb	r3, [r4, #29]
 8005214:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8005218:	e796      	b.n	8005148 <bsec_GasHumidityBaselineTracker_doStep+0x334>
 800521a:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 800521e:	eeb4 6a67 	vcmp.f32	s12, s15
 8005222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005226:	d10a      	bne.n	800523e <bsec_GasHumidityBaselineTracker_doStep+0x42a>
 8005228:	b14f      	cbz	r7, 800523e <bsec_GasHumidityBaselineTracker_doStep+0x42a>
 800522a:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 800522e:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8005232:	6323      	str	r3, [r4, #48]	; 0x30
 8005234:	2300      	movs	r3, #0
 8005236:	6362      	str	r2, [r4, #52]	; 0x34
 8005238:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
 800523c:	e7ba      	b.n	80051b4 <bsec_GasHumidityBaselineTracker_doStep+0x3a0>
 800523e:	4b6b      	ldr	r3, [pc, #428]	; (80053ec <bsec_GasHumidityBaselineTracker_doStep+0x5d8>)
 8005240:	6323      	str	r3, [r4, #48]	; 0x30
 8005242:	6363      	str	r3, [r4, #52]	; 0x34
 8005244:	b008      	add	sp, #32
 8005246:	ecbd 8b0c 	vpop	{d8-d13}
 800524a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800524e:	ee38 aaca 	vsub.f32	s20, s17, s20
 8005252:	ee79 7ac0 	vsub.f32	s15, s19, s0
 8005256:	ee8a 7a2c 	vdiv.f32	s14, s20, s25
 800525a:	ed9d 5a05 	vldr	s10, [sp, #20]
 800525e:	eddd 4a06 	vldr	s9, [sp, #24]
 8005262:	eddd 5a03 	vldr	s11, [sp, #12]
 8005266:	ed9d 6a04 	vldr	s12, [sp, #16]
 800526a:	eddd 6a07 	vldr	s13, [sp, #28]
 800526e:	ee27 0aa7 	vmul.f32	s0, s15, s15
 8005272:	ee67 7aa4 	vmul.f32	s15, s15, s9
 8005276:	ee20 0a05 	vmul.f32	s0, s0, s10
 800527a:	ee27 7a25 	vmul.f32	s14, s14, s11
 800527e:	ee70 7a27 	vadd.f32	s15, s0, s15
 8005282:	ee37 0a06 	vadd.f32	s0, s14, s12
 8005286:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800528a:	eef7 0a08 	vmov.f32	s1, #120	; 0x3fc00000  1.5
 800528e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8005292:	f024 f9b0 	bl	80295f6 <fminf>
 8005296:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
 800529a:	f024 f991 	bl	80295c0 <fmaxf>
 800529e:	edd4 0a02 	vldr	s1, [r4, #8]
 80052a2:	e649      	b.n	8004f38 <bsec_GasHumidityBaselineTracker_doStep+0x124>
 80052a4:	f024 fba4 	bl	80299f0 <log10f>
 80052a8:	8863      	ldrh	r3, [r4, #2]
 80052aa:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80052ae:	eef0 9a40 	vmov.f32	s19, s0
 80052b2:	f04f 020c 	mov.w	r2, #12
 80052b6:	f47f adf9 	bne.w	8004eac <bsec_GasHumidityBaselineTracker_doStep+0x98>
 80052ba:	f104 0184 	add.w	r1, r4, #132	; 0x84
 80052be:	a805      	add	r0, sp, #20
 80052c0:	ed94 ca11 	vldr	s24, [r4, #68]	; 0x44
 80052c4:	edd4 ba15 	vldr	s23, [r4, #84]	; 0x54
 80052c8:	f026 ff0a 	bl	802c0e0 <memcpy>
 80052cc:	2208      	movs	r2, #8
 80052ce:	f104 0190 	add.w	r1, r4, #144	; 0x90
 80052d2:	a803      	add	r0, sp, #12
 80052d4:	f026 ff04 	bl	802c0e0 <memcpy>
 80052d8:	ed94 aa2d 	vldr	s20, [r4, #180]	; 0xb4
 80052dc:	ed94 da31 	vldr	s26, [r4, #196]	; 0xc4
 80052e0:	e5fe      	b.n	8004ee0 <bsec_GasHumidityBaselineTracker_doStep+0xcc>
 80052e2:	f104 0198 	add.w	r1, r4, #152	; 0x98
 80052e6:	a805      	add	r0, sp, #20
 80052e8:	ed94 ca12 	vldr	s24, [r4, #72]	; 0x48
 80052ec:	edd4 ba16 	vldr	s23, [r4, #88]	; 0x58
 80052f0:	f026 fef6 	bl	802c0e0 <memcpy>
 80052f4:	2208      	movs	r2, #8
 80052f6:	f104 01a4 	add.w	r1, r4, #164	; 0xa4
 80052fa:	a803      	add	r0, sp, #12
 80052fc:	f026 fef0 	bl	802c0e0 <memcpy>
 8005300:	ed94 aa2e 	vldr	s20, [r4, #184]	; 0xb8
 8005304:	ed94 da32 	vldr	s26, [r4, #200]	; 0xc8
 8005308:	e5ea      	b.n	8004ee0 <bsec_GasHumidityBaselineTracker_doStep+0xcc>
 800530a:	f104 0170 	add.w	r1, r4, #112	; 0x70
 800530e:	a805      	add	r0, sp, #20
 8005310:	ed94 ca10 	vldr	s24, [r4, #64]	; 0x40
 8005314:	edd4 ba14 	vldr	s23, [r4, #80]	; 0x50
 8005318:	f026 fee2 	bl	802c0e0 <memcpy>
 800531c:	2208      	movs	r2, #8
 800531e:	f104 017c 	add.w	r1, r4, #124	; 0x7c
 8005322:	a803      	add	r0, sp, #12
 8005324:	f026 fedc 	bl	802c0e0 <memcpy>
 8005328:	ed94 aa2c 	vldr	s20, [r4, #176]	; 0xb0
 800532c:	ed94 da30 	vldr	s26, [r4, #192]	; 0xc0
 8005330:	e5d6      	b.n	8004ee0 <bsec_GasHumidityBaselineTracker_doStep+0xcc>
 8005332:	edd4 8a05 	vldr	s17, [r4, #20]
 8005336:	eef0 0a48 	vmov.f32	s1, s16
 800533a:	2102      	movs	r1, #2
 800533c:	eeb0 0a49 	vmov.f32	s0, s18
 8005340:	f7ff faf0 	bl	8004924 <bsec_GasHumidityBaselineTracker_getMinimumFilterDistance>
 8005344:	eef4 8ac8 	vcmpe.f32	s17, s16
 8005348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800534c:	bfac      	ite	ge
 800534e:	f04f 0801 	movge.w	r8, #1
 8005352:	f04f 0800 	movlt.w	r8, #0
 8005356:	eef0 0a40 	vmov.f32	s1, s0
 800535a:	e6ec      	b.n	8005136 <bsec_GasHumidityBaselineTracker_doStep+0x322>
 800535c:	2301      	movs	r3, #1
 800535e:	e9cd 3700 	strd	r3, r7, [sp]
 8005362:	461a      	mov	r2, r3
 8005364:	ed96 0a00 	vldr	s0, [r6]
 8005368:	f104 0110 	add.w	r1, r4, #16
 800536c:	4620      	mov	r0, r4
 800536e:	f7ff fb1b 	bl	80049a8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
 8005372:	e66d      	b.n	8005050 <bsec_GasHumidityBaselineTracker_doStep+0x23c>
 8005374:	2201      	movs	r2, #1
 8005376:	9701      	str	r7, [sp, #4]
 8005378:	9200      	str	r2, [sp, #0]
 800537a:	ed96 0a00 	vldr	s0, [r6]
 800537e:	4653      	mov	r3, sl
 8005380:	f104 0114 	add.w	r1, r4, #20
 8005384:	4620      	mov	r0, r4
 8005386:	f7ff fb0f 	bl	80049a8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
 800538a:	e694      	b.n	80050b6 <bsec_GasHumidityBaselineTracker_doStep+0x2a2>
 800538c:	eefd 7acb 	vcvt.s32.f32	s15, s22
 8005390:	edd4 8a0a 	vldr	s17, [r4, #40]	; 0x28
 8005394:	ee17 3a90 	vmov	r3, s15
 8005398:	eb04 0243 	add.w	r2, r4, r3, lsl #1
 800539c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80053a0:	f8b2 20e0 	ldrh.w	r2, [r2, #224]	; 0xe0
 80053a4:	ed93 0a39 	vldr	s0, [r3, #228]	; 0xe4
 80053a8:	ee08 2a10 	vmov	s16, r2
 80053ac:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 80053b0:	f024 faaa 	bl	8029908 <expf>
 80053b4:	ee38 8ac8 	vsub.f32	s16, s17, s16
 80053b8:	eec8 7a00 	vdiv.f32	s15, s16, s0
 80053bc:	ee78 8ae7 	vsub.f32	s17, s17, s15
 80053c0:	edc4 8a0a 	vstr	s17, [r4, #40]	; 0x28
 80053c4:	ed96 0a00 	vldr	s0, [r6]
 80053c8:	e677      	b.n	80050ba <bsec_GasHumidityBaselineTracker_doStep+0x2a6>
 80053ca:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 80053cc:	ed9f 0a08 	vldr	s0, [pc, #32]	; 80053f0 <bsec_GasHumidityBaselineTracker_doStep+0x5dc>
 80053d0:	ee00 3a90 	vmov	s1, r3
 80053d4:	eef8 0a60 	vcvt.f32.u32	s1, s1
 80053d8:	ee77 0ae0 	vsub.f32	s1, s15, s1
 80053dc:	f024 f8f0 	bl	80295c0 <fmaxf>
 80053e0:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
 80053e4:	ed96 0a00 	vldr	s0, [r6]
 80053e8:	e667      	b.n	80050ba <bsec_GasHumidityBaselineTracker_doStep+0x2a6>
 80053ea:	bf00      	nop
 80053ec:	44e10000 	.word	0x44e10000
 80053f0:	00000000 	.word	0x00000000

080053f4 <bsec_GasHumidityBaselineTracker_getConfiguration>:
 80053f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80053f8:	2407      	movs	r4, #7
 80053fa:	b084      	sub	sp, #16
 80053fc:	4606      	mov	r6, r0
 80053fe:	4690      	mov	r8, r2
 8005400:	7800      	ldrb	r0, [r0, #0]
 8005402:	f88d 4007 	strb.w	r4, [sp, #7]
 8005406:	eb0d 0204 	add.w	r2, sp, r4
 800540a:	460d      	mov	r5, r1
 800540c:	f001 fb6e 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8005410:	f89d 7007 	ldrb.w	r7, [sp, #7]
 8005414:	9003      	str	r0, [sp, #12]
 8005416:	b32f      	cbz	r7, 8005464 <bsec_GasHumidityBaselineTracker_getConfiguration+0x70>
 8005418:	2401      	movs	r4, #1
 800541a:	f106 0ae8 	add.w	sl, r6, #232	; 0xe8
 800541e:	f106 09ce 	add.w	r9, r6, #206	; 0xce
 8005422:	b2e3      	uxtb	r3, r4
 8005424:	3b01      	subs	r3, #1
 8005426:	2b06      	cmp	r3, #6
 8005428:	d80b      	bhi.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>
 800542a:	e8df f003 	tbb	[pc, r3]
 800542e:	2d35      	.short	0x2d35
 8005430:	104d3d45 	.word	0x104d3d45
 8005434:	04          	.byte	0x04
 8005435:	00          	.byte	0x00
 8005436:	ab03      	add	r3, sp, #12
 8005438:	4642      	mov	r2, r8
 800543a:	4629      	mov	r1, r5
 800543c:	4650      	mov	r0, sl
 800543e:	f7fd fe83 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 8005442:	42a7      	cmp	r7, r4
 8005444:	f104 0301 	add.w	r3, r4, #1
 8005448:	d00b      	beq.n	8005462 <bsec_GasHumidityBaselineTracker_getConfiguration+0x6e>
 800544a:	461c      	mov	r4, r3
 800544c:	e7e9      	b.n	8005422 <bsec_GasHumidityBaselineTracker_getConfiguration+0x2e>
 800544e:	ab03      	add	r3, sp, #12
 8005450:	4642      	mov	r2, r8
 8005452:	4629      	mov	r1, r5
 8005454:	4648      	mov	r0, r9
 8005456:	f7fd ff1b 	bl	8003290 <bsec_d_Entity_serializeAndAdd>
 800545a:	42a7      	cmp	r7, r4
 800545c:	f104 0301 	add.w	r3, r4, #1
 8005460:	d1f3      	bne.n	800544a <bsec_GasHumidityBaselineTracker_getConfiguration+0x56>
 8005462:	9803      	ldr	r0, [sp, #12]
 8005464:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005468:	2202      	movs	r2, #2
 800546a:	f10d 010a 	add.w	r1, sp, #10
 800546e:	a802      	add	r0, sp, #8
 8005470:	f026 fe36 	bl	802c0e0 <memcpy>
 8005474:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005478:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800547c:	9803      	ldr	r0, [sp, #12]
 800547e:	702a      	strb	r2, [r5, #0]
 8005480:	706b      	strb	r3, [r5, #1]
 8005482:	b004      	add	sp, #16
 8005484:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005488:	ab03      	add	r3, sp, #12
 800548a:	4642      	mov	r2, r8
 800548c:	4629      	mov	r1, r5
 800548e:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
 8005492:	f7fd fe59 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 8005496:	e7d4      	b.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>
 8005498:	ab03      	add	r3, sp, #12
 800549a:	4642      	mov	r2, r8
 800549c:	4629      	mov	r1, r5
 800549e:	f106 00d8 	add.w	r0, r6, #216	; 0xd8
 80054a2:	f7fd fe51 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 80054a6:	e7cc      	b.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>
 80054a8:	ab03      	add	r3, sp, #12
 80054aa:	4642      	mov	r2, r8
 80054ac:	4629      	mov	r1, r5
 80054ae:	f106 00e2 	add.w	r0, r6, #226	; 0xe2
 80054b2:	f7fe f891 	bl	80035d8 <bsec_k_Entity_serializeAndAdd>
 80054b6:	e7c4      	b.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>
 80054b8:	ab03      	add	r3, sp, #12
 80054ba:	4642      	mov	r2, r8
 80054bc:	4629      	mov	r1, r5
 80054be:	f106 003c 	add.w	r0, r6, #60	; 0x3c
 80054c2:	f7fe f843 	bl	800354c <bsec_j_Entity_serializeAndAdd>
 80054c6:	e7bc      	b.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>
 80054c8:	ab03      	add	r3, sp, #12
 80054ca:	4642      	mov	r2, r8
 80054cc:	4629      	mov	r1, r5
 80054ce:	f106 00cc 	add.w	r0, r6, #204	; 0xcc
 80054d2:	f7fe f8cb 	bl	800366c <bsec_l_Entity_serializeAndAdd>
 80054d6:	e7b4      	b.n	8005442 <bsec_GasHumidityBaselineTracker_getConfiguration+0x4e>

080054d8 <bsec_GasHumidityBaselineTracker_getState>:
 80054d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80054dc:	b084      	sub	sp, #16
 80054de:	4606      	mov	r6, r0
 80054e0:	4617      	mov	r7, r2
 80054e2:	7800      	ldrb	r0, [r0, #0]
 80054e4:	240d      	movs	r4, #13
 80054e6:	f10d 0207 	add.w	r2, sp, #7
 80054ea:	460d      	mov	r5, r1
 80054ec:	f88d 4007 	strb.w	r4, [sp, #7]
 80054f0:	f001 fafc 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 80054f4:	f89d 8007 	ldrb.w	r8, [sp, #7]
 80054f8:	9003      	str	r0, [sp, #12]
 80054fa:	f1b8 0f00 	cmp.w	r8, #0
 80054fe:	d029      	beq.n	8005554 <bsec_GasHumidityBaselineTracker_getState+0x7c>
 8005500:	2401      	movs	r4, #1
 8005502:	f106 0a30 	add.w	sl, r6, #48	; 0x30
 8005506:	f106 0920 	add.w	r9, r6, #32
 800550a:	b2e3      	uxtb	r3, r4
 800550c:	3b01      	subs	r3, #1
 800550e:	2b0c      	cmp	r3, #12
 8005510:	d80f      	bhi.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 8005512:	e8df f003 	tbb	[pc, r3]
 8005516:	666e      	.short	0x666e
 8005518:	575f767d 	.word	0x575f767d
 800551c:	39414850 	.word	0x39414850
 8005520:	1431      	.short	0x1431
 8005522:	07          	.byte	0x07
 8005523:	00          	.byte	0x00
 8005524:	f896 0038 	ldrb.w	r0, [r6, #56]	; 0x38
 8005528:	ab03      	add	r3, sp, #12
 800552a:	463a      	mov	r2, r7
 800552c:	4629      	mov	r1, r5
 800552e:	f7fd ff35 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 8005532:	45a0      	cmp	r8, r4
 8005534:	f104 0301 	add.w	r3, r4, #1
 8005538:	d00b      	beq.n	8005552 <bsec_GasHumidityBaselineTracker_getState+0x7a>
 800553a:	461c      	mov	r4, r3
 800553c:	e7e5      	b.n	800550a <bsec_GasHumidityBaselineTracker_getState+0x32>
 800553e:	ab03      	add	r3, sp, #12
 8005540:	463a      	mov	r2, r7
 8005542:	4629      	mov	r1, r5
 8005544:	4650      	mov	r0, sl
 8005546:	f7fd fdff 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 800554a:	45a0      	cmp	r8, r4
 800554c:	f104 0301 	add.w	r3, r4, #1
 8005550:	d1f3      	bne.n	800553a <bsec_GasHumidityBaselineTracker_getState+0x62>
 8005552:	9803      	ldr	r0, [sp, #12]
 8005554:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005558:	2202      	movs	r2, #2
 800555a:	f10d 010a 	add.w	r1, sp, #10
 800555e:	a802      	add	r0, sp, #8
 8005560:	f026 fdbe 	bl	802c0e0 <memcpy>
 8005564:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005568:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800556c:	9803      	ldr	r0, [sp, #12]
 800556e:	702a      	strb	r2, [r5, #0]
 8005570:	706b      	strb	r3, [r5, #1]
 8005572:	b004      	add	sp, #16
 8005574:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005578:	f896 00e0 	ldrb.w	r0, [r6, #224]	; 0xe0
 800557c:	ab03      	add	r3, sp, #12
 800557e:	463a      	mov	r2, r7
 8005580:	4629      	mov	r1, r5
 8005582:	f7fd ff0b 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 8005586:	e7d4      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 8005588:	ed96 0a01 	vldr	s0, [r6, #4]
 800558c:	aa03      	add	r2, sp, #12
 800558e:	4639      	mov	r1, r7
 8005590:	4628      	mov	r0, r5
 8005592:	f7fd fec1 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8005596:	e7cc      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 8005598:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 800559a:	ab03      	add	r3, sp, #12
 800559c:	463a      	mov	r2, r7
 800559e:	4629      	mov	r1, r5
 80055a0:	f7fd fe3e 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 80055a4:	e7c5      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055a6:	ed96 0a0a 	vldr	s0, [r6, #40]	; 0x28
 80055aa:	aa03      	add	r2, sp, #12
 80055ac:	4639      	mov	r1, r7
 80055ae:	4628      	mov	r0, r5
 80055b0:	f7fd feb2 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 80055b4:	e7bd      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055b6:	ab03      	add	r3, sp, #12
 80055b8:	463a      	mov	r2, r7
 80055ba:	4629      	mov	r1, r5
 80055bc:	4648      	mov	r0, r9
 80055be:	f7fd fdc3 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 80055c2:	e7b6      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055c4:	ab03      	add	r3, sp, #12
 80055c6:	463a      	mov	r2, r7
 80055c8:	4629      	mov	r1, r5
 80055ca:	f106 001c 	add.w	r0, r6, #28
 80055ce:	f7fd fe5f 	bl	8003290 <bsec_d_Entity_serializeAndAdd>
 80055d2:	e7ae      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055d4:	8870      	ldrh	r0, [r6, #2]
 80055d6:	ab03      	add	r3, sp, #12
 80055d8:	463a      	mov	r2, r7
 80055da:	4629      	mov	r1, r5
 80055dc:	f7fd fe20 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 80055e0:	e7a7      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055e2:	ab03      	add	r3, sp, #12
 80055e4:	463a      	mov	r2, r7
 80055e6:	4629      	mov	r1, r5
 80055e8:	f106 0010 	add.w	r0, r6, #16
 80055ec:	f7fd fdac 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 80055f0:	e79f      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 80055f2:	ab03      	add	r3, sp, #12
 80055f4:	463a      	mov	r2, r7
 80055f6:	4629      	mov	r1, r5
 80055f8:	f106 0008 	add.w	r0, r6, #8
 80055fc:	f7fd fda4 	bl	8003148 <bsec_b_Entity_serializeAndAdd>
 8005600:	e797      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 8005602:	8b70      	ldrh	r0, [r6, #26]
 8005604:	ab03      	add	r3, sp, #12
 8005606:	463a      	mov	r2, r7
 8005608:	4629      	mov	r1, r5
 800560a:	f7fd fe09 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 800560e:	e790      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 8005610:	8b30      	ldrh	r0, [r6, #24]
 8005612:	ab03      	add	r3, sp, #12
 8005614:	463a      	mov	r2, r7
 8005616:	4629      	mov	r1, r5
 8005618:	f7fd fe02 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 800561c:	e789      	b.n	8005532 <bsec_GasHumidityBaselineTracker_getState+0x5a>
 800561e:	bf00      	nop

08005620 <bsec_GasHumidityBaselineTracker_setState>:
 8005620:	b430      	push	{r4, r5}
 8005622:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005626:	2402      	movs	r4, #2
 8005628:	2300      	movs	r3, #0
 800562a:	4a0c      	ldr	r2, [pc, #48]	; (800565c <bsec_GasHumidityBaselineTracker_setState+0x3c>)
 800562c:	f880 40e0 	strb.w	r4, [r0, #224]	; 0xe0
 8005630:	f240 2502 	movw	r5, #514	; 0x202
 8005634:	2401      	movs	r4, #1
 8005636:	8041      	strh	r1, [r0, #2]
 8005638:	2100      	movs	r1, #0
 800563a:	8385      	strh	r5, [r0, #28]
 800563c:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
 8005640:	6283      	str	r3, [r0, #40]	; 0x28
 8005642:	bc30      	pop	{r4, r5}
 8005644:	6203      	str	r3, [r0, #32]
 8005646:	6043      	str	r3, [r0, #4]
 8005648:	6083      	str	r3, [r0, #8]
 800564a:	60c3      	str	r3, [r0, #12]
 800564c:	6103      	str	r3, [r0, #16]
 800564e:	6143      	str	r3, [r0, #20]
 8005650:	6243      	str	r3, [r0, #36]	; 0x24
 8005652:	8581      	strh	r1, [r0, #44]	; 0x2c
 8005654:	6181      	str	r1, [r0, #24]
 8005656:	6302      	str	r2, [r0, #48]	; 0x30
 8005658:	6342      	str	r2, [r0, #52]	; 0x34
 800565a:	4770      	bx	lr
 800565c:	44e10000 	.word	0x44e10000

08005660 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>:
 8005660:	b538      	push	{r3, r4, r5, lr}
 8005662:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005666:	4299      	cmp	r1, r3
 8005668:	d035      	beq.n	80056d6 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x76>
 800566a:	8843      	ldrh	r3, [r0, #2]
 800566c:	428b      	cmp	r3, r1
 800566e:	460c      	mov	r4, r1
 8005670:	4605      	mov	r5, r0
 8005672:	d030      	beq.n	80056d6 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x76>
 8005674:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
 8005678:	8041      	strh	r1, [r0, #2]
 800567a:	d02d      	beq.n	80056d8 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x78>
 800567c:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
 8005680:	4b2c      	ldr	r3, [pc, #176]	; (8005734 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xd4>)
 8005682:	d051      	beq.n	8005728 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xc8>
 8005684:	2964      	cmp	r1, #100	; 0x64
 8005686:	d04f      	beq.n	8005728 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xc8>
 8005688:	fba3 2301 	umull	r2, r3, r3, r1
 800568c:	095a      	lsrs	r2, r3, #5
 800568e:	2164      	movs	r1, #100	; 0x64
 8005690:	fb01 4212 	mls	r2, r1, r2, r4
 8005694:	b292      	uxth	r2, r2
 8005696:	095b      	lsrs	r3, r3, #5
 8005698:	2a31      	cmp	r2, #49	; 0x31
 800569a:	ed9f 0a27 	vldr	s0, [pc, #156]	; 8005738 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xd8>
 800569e:	bf88      	it	hi
 80056a0:	3301      	addhi	r3, #1
 80056a2:	85ab      	strh	r3, [r5, #44]	; 0x2c
 80056a4:	f024 f9a4 	bl	80299f0 <log10f>
 80056a8:	f023 ff40 	bl	802952c <fabsf>
 80056ac:	ed9f 7a23 	vldr	s14, [pc, #140]	; 800573c <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xdc>
 80056b0:	eec0 7a07 	vdiv.f32	s15, s0, s14
 80056b4:	edc5 7a01 	vstr	s15, [r5, #4]
 80056b8:	b9e4      	cbnz	r4, 80056f4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x94>
 80056ba:	ed9f 0a21 	vldr	s0, [pc, #132]	; 8005740 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xe0>
 80056be:	f024 fa65 	bl	8029b8c <sqrtf>
 80056c2:	ee30 0a00 	vadd.f32	s0, s0, s0
 80056c6:	f023 ff39 	bl	802953c <floorf>
 80056ca:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80056ce:	ee17 3a90 	vmov	r3, s15
 80056d2:	f885 30e0 	strb.w	r3, [r5, #224]	; 0xe0
 80056d6:	bd38      	pop	{r3, r4, r5, pc}
 80056d8:	2303      	movs	r3, #3
 80056da:	8583      	strh	r3, [r0, #44]	; 0x2c
 80056dc:	ed9f 0a19 	vldr	s0, [pc, #100]	; 8005744 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xe4>
 80056e0:	f024 f986 	bl	80299f0 <log10f>
 80056e4:	f023 ff22 	bl	802952c <fabsf>
 80056e8:	ed9f 7a14 	vldr	s14, [pc, #80]	; 800573c <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xdc>
 80056ec:	eec0 7a07 	vdiv.f32	s15, s0, s14
 80056f0:	edc5 7a01 	vstr	s15, [r5, #4]
 80056f4:	f247 5230 	movw	r2, #30000	; 0x7530
 80056f8:	fbb2 f3f4 	udiv	r3, r2, r4
 80056fc:	fb04 2213 	mls	r2, r4, r3, r2
 8005700:	b292      	uxth	r2, r2
 8005702:	b29b      	uxth	r3, r3
 8005704:	b15a      	cbz	r2, 800571e <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xbe>
 8005706:	f004 0101 	and.w	r1, r4, #1
 800570a:	eb01 0454 	add.w	r4, r1, r4, lsr #1
 800570e:	42a2      	cmp	r2, r4
 8005710:	db05      	blt.n	800571e <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xbe>
 8005712:	3301      	adds	r3, #1
 8005714:	ee00 3a10 	vmov	s0, r3
 8005718:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 800571c:	e7cf      	b.n	80056be <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x5e>
 800571e:	ee07 3a90 	vmov	s15, r3
 8005722:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8005726:	e7ca      	b.n	80056be <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x5e>
 8005728:	fba3 2304 	umull	r2, r3, r3, r4
 800572c:	ed9f 0a06 	vldr	s0, [pc, #24]	; 8005748 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xe8>
 8005730:	095b      	lsrs	r3, r3, #5
 8005732:	e7b6      	b.n	80056a2 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x42>
 8005734:	51eb851f 	.word	0x51eb851f
 8005738:	3f464c30 	.word	0x3f464c30
 800573c:	3e632c50 	.word	0x3e632c50
 8005740:	477fff00 	.word	0x477fff00
 8005744:	3f23d70a 	.word	0x3f23d70a
 8005748:	3f19999a 	.word	0x3f19999a

0800574c <bsec_b_GasHumidityBaselineTracker_setState>:
 800574c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005750:	b086      	sub	sp, #24
 8005752:	ab04      	add	r3, sp, #16
 8005754:	ae05      	add	r6, sp, #20
 8005756:	4604      	mov	r4, r0
 8005758:	7800      	ldrb	r0, [r0, #0]
 800575a:	e9cd 3600 	strd	r3, r6, [sp]
 800575e:	f10d 030f 	add.w	r3, sp, #15
 8005762:	460d      	mov	r5, r1
 8005764:	f001 f994 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8005768:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 800576c:	bb00      	cbnz	r0, 80057b0 <bsec_b_GasHumidityBaselineTracker_setState+0x64>
 800576e:	f04f 0a01 	mov.w	sl, #1
 8005772:	f104 0930 	add.w	r9, r4, #48	; 0x30
 8005776:	f104 0820 	add.w	r8, r4, #32
 800577a:	f104 071c 	add.w	r7, r4, #28
 800577e:	fa5f f38a 	uxtb.w	r3, sl
 8005782:	3b01      	subs	r3, #1
 8005784:	2b0b      	cmp	r3, #11
 8005786:	d85d      	bhi.n	8005844 <bsec_b_GasHumidityBaselineTracker_setState+0xf8>
 8005788:	e8df f003 	tbb	[pc, r3]
 800578c:	42484e55 	.word	0x42484e55
 8005790:	2230363c 	.word	0x2230363c
 8005794:	0615291c 	.word	0x0615291c
 8005798:	464a      	mov	r2, r9
 800579a:	4631      	mov	r1, r6
 800579c:	4628      	mov	r0, r5
 800579e:	f7fd fcb9 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 80057a2:	f10a 0a01 	add.w	sl, sl, #1
 80057a6:	f1ba 0f0e 	cmp.w	sl, #14
 80057aa:	d1e8      	bne.n	800577e <bsec_b_GasHumidityBaselineTracker_setState+0x32>
 80057ac:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80057b0:	b006      	add	sp, #24
 80057b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80057b6:	4631      	mov	r1, r6
 80057b8:	4628      	mov	r0, r5
 80057ba:	f7fd fdd9 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 80057be:	f884 00e0 	strb.w	r0, [r4, #224]	; 0xe0
 80057c2:	e7ee      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 80057c4:	4631      	mov	r1, r6
 80057c6:	4628      	mov	r0, r5
 80057c8:	f7fd fd12 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 80057cc:	85a0      	strh	r0, [r4, #44]	; 0x2c
 80057ce:	e7e8      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 80057d0:	4631      	mov	r1, r6
 80057d2:	4628      	mov	r0, r5
 80057d4:	f7fd fd82 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80057d8:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
 80057dc:	e7e1      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 80057de:	4631      	mov	r1, r6
 80057e0:	4628      	mov	r0, r5
 80057e2:	f7fd fd7b 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80057e6:	ed84 0a01 	vstr	s0, [r4, #4]
 80057ea:	e7da      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 80057ec:	4642      	mov	r2, r8
 80057ee:	4631      	mov	r1, r6
 80057f0:	4628      	mov	r0, r5
 80057f2:	f7fd fc8f 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 80057f6:	e7d4      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 80057f8:	463a      	mov	r2, r7
 80057fa:	4631      	mov	r1, r6
 80057fc:	4628      	mov	r0, r5
 80057fe:	f7fd fd31 	bl	8003264 <bsec_d_Entity_parseAndDeserialize>
 8005802:	e7ce      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005804:	4631      	mov	r1, r6
 8005806:	4628      	mov	r0, r5
 8005808:	f7fd fcf2 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 800580c:	8060      	strh	r0, [r4, #2]
 800580e:	e7c8      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005810:	4631      	mov	r1, r6
 8005812:	4628      	mov	r0, r5
 8005814:	f7fd fcec 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8005818:	8360      	strh	r0, [r4, #26]
 800581a:	e7c2      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 800581c:	4631      	mov	r1, r6
 800581e:	4628      	mov	r0, r5
 8005820:	f7fd fce6 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8005824:	8320      	strh	r0, [r4, #24]
 8005826:	e7bc      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005828:	f104 0210 	add.w	r2, r4, #16
 800582c:	4631      	mov	r1, r6
 800582e:	4628      	mov	r0, r5
 8005830:	f7fd fc70 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8005834:	e7b5      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005836:	f104 0208 	add.w	r2, r4, #8
 800583a:	4631      	mov	r1, r6
 800583c:	4628      	mov	r0, r5
 800583e:	f7fd fc69 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8005842:	e7ae      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005844:	4631      	mov	r1, r6
 8005846:	4628      	mov	r0, r5
 8005848:	f7fd fd92 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 800584c:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
 8005850:	e7a7      	b.n	80057a2 <bsec_b_GasHumidityBaselineTracker_setState+0x56>
 8005852:	bf00      	nop

08005854 <bsec_GasHumidityPreProcessor_GasHumidityPreProcessor>:
 8005854:	b510      	push	{r4, lr}
 8005856:	2303      	movs	r3, #3
 8005858:	4604      	mov	r4, r0
 800585a:	f800 3b04 	strb.w	r3, [r0], #4
 800585e:	f001 fe3f 	bl	80074e0 <bsec_ExpSmoothingBsec_ExpSmoothingBsec>
 8005862:	4620      	mov	r0, r4
 8005864:	f001 fdb4 	bl	80073d0 <bsec_Channel_reset>
 8005868:	4620      	mov	r0, r4
 800586a:	bd10      	pop	{r4, pc}

0800586c <bsec_GasHumidityPreProcessor_configure>:
 800586c:	b570      	push	{r4, r5, r6, lr}
 800586e:	b086      	sub	sp, #24
 8005870:	ab04      	add	r3, sp, #16
 8005872:	ae05      	add	r6, sp, #20
 8005874:	4604      	mov	r4, r0
 8005876:	7800      	ldrb	r0, [r0, #0]
 8005878:	e9cd 3600 	strd	r3, r6, [sp]
 800587c:	f10d 030f 	add.w	r3, sp, #15
 8005880:	460d      	mov	r5, r1
 8005882:	f001 f905 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8005886:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 800588a:	b108      	cbz	r0, 8005890 <bsec_GasHumidityPreProcessor_configure+0x24>
 800588c:	b006      	add	sp, #24
 800588e:	bd70      	pop	{r4, r5, r6, pc}
 8005890:	4628      	mov	r0, r5
 8005892:	f104 0220 	add.w	r2, r4, #32
 8005896:	4631      	mov	r1, r6
 8005898:	f7fd fbda 	bl	8003050 <bsec_Entity_parseAndDeserialize>
 800589c:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80058a0:	b006      	add	sp, #24
 80058a2:	bd70      	pop	{r4, r5, r6, pc}

080058a4 <bsec_GasHumidityPreProcessor_doStep>:
 80058a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058a6:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80058aa:	ed2d 8b04 	vpush	{d8-d9}
 80058ae:	edd0 9a04 	vldr	s19, [r0, #16]
 80058b2:	eeb4 0a67 	vcmp.f32	s0, s15
 80058b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80058ba:	eeb0 9a40 	vmov.f32	s18, s0
 80058be:	eef5 9a40 	vcmp.f32	s19, #0.0
 80058c2:	bf98      	it	ls
 80058c4:	eeb0 9a67 	vmovls.f32	s18, s15
 80058c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80058cc:	4604      	mov	r4, r0
 80058ce:	460f      	mov	r7, r1
 80058d0:	4616      	mov	r6, r2
 80058d2:	461d      	mov	r5, r3
 80058d4:	eef0 8a60 	vmov.f32	s17, s1
 80058d8:	eeb0 8a41 	vmov.f32	s16, s2
 80058dc:	d030      	beq.n	8005940 <bsec_GasHumidityPreProcessor_doStep+0x9c>
 80058de:	eeb0 0a49 	vmov.f32	s0, s18
 80058e2:	ed94 9a01 	vldr	s18, [r4, #4]
 80058e6:	f024 f883 	bl	80299f0 <log10f>
 80058ea:	edd4 7a04 	vldr	s15, [r4, #16]
 80058ee:	ee70 7a67 	vsub.f32	s15, s0, s15
 80058f2:	ee67 7a89 	vmul.f32	s15, s15, s18
 80058f6:	ee37 0aa9 	vadd.f32	s0, s15, s19
 80058fa:	ed87 0a00 	vstr	s0, [r7]
 80058fe:	edd4 7a05 	vldr	s15, [r4, #20]
 8005902:	edd4 0a02 	vldr	s1, [r4, #8]
 8005906:	ee78 8ae7 	vsub.f32	s17, s17, s15
 800590a:	ee68 8aa0 	vmul.f32	s17, s17, s1
 800590e:	ee78 8aa7 	vadd.f32	s17, s17, s15
 8005912:	edc6 8a00 	vstr	s17, [r6]
 8005916:	edd4 7a06 	vldr	s15, [r4, #24]
 800591a:	ed94 1a03 	vldr	s2, [r4, #12]
 800591e:	ee38 8a67 	vsub.f32	s16, s16, s15
 8005922:	ee28 8a01 	vmul.f32	s16, s16, s2
 8005926:	ee38 8a27 	vadd.f32	s16, s16, s15
 800592a:	ed85 8a00 	vstr	s16, [r5]
 800592e:	683b      	ldr	r3, [r7, #0]
 8005930:	6123      	str	r3, [r4, #16]
 8005932:	ecbd 8b04 	vpop	{d8-d9}
 8005936:	6833      	ldr	r3, [r6, #0]
 8005938:	6163      	str	r3, [r4, #20]
 800593a:	682b      	ldr	r3, [r5, #0]
 800593c:	61a3      	str	r3, [r4, #24]
 800593e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005940:	eeb0 0a49 	vmov.f32	s0, s18
 8005944:	f024 f854 	bl	80299f0 <log10f>
 8005948:	edc4 8a05 	vstr	s17, [r4, #20]
 800594c:	eef0 9a40 	vmov.f32	s19, s0
 8005950:	ed84 8a06 	vstr	s16, [r4, #24]
 8005954:	ed84 0a04 	vstr	s0, [r4, #16]
 8005958:	e7c1      	b.n	80058de <bsec_GasHumidityPreProcessor_doStep+0x3a>
 800595a:	bf00      	nop

0800595c <bsec_GasHumidityPreProcessor_getConfiguration>:
 800595c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005960:	b084      	sub	sp, #16
 8005962:	2501      	movs	r5, #1
 8005964:	4606      	mov	r6, r0
 8005966:	4690      	mov	r8, r2
 8005968:	7800      	ldrb	r0, [r0, #0]
 800596a:	f88d 5007 	strb.w	r5, [sp, #7]
 800596e:	f10d 0207 	add.w	r2, sp, #7
 8005972:	460f      	mov	r7, r1
 8005974:	f001 f8ba 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8005978:	f89d 5007 	ldrb.w	r5, [sp, #7]
 800597c:	9003      	str	r0, [sp, #12]
 800597e:	b135      	cbz	r5, 800598e <bsec_GasHumidityPreProcessor_getConfiguration+0x32>
 8005980:	3620      	adds	r6, #32
 8005982:	2400      	movs	r4, #0
 8005984:	b1ac      	cbz	r4, 80059b2 <bsec_GasHumidityPreProcessor_getConfiguration+0x56>
 8005986:	3401      	adds	r4, #1
 8005988:	42a5      	cmp	r5, r4
 800598a:	d1fb      	bne.n	8005984 <bsec_GasHumidityPreProcessor_getConfiguration+0x28>
 800598c:	9803      	ldr	r0, [sp, #12]
 800598e:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005992:	2202      	movs	r2, #2
 8005994:	f10d 010a 	add.w	r1, sp, #10
 8005998:	a802      	add	r0, sp, #8
 800599a:	f026 fba1 	bl	802c0e0 <memcpy>
 800599e:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80059a2:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80059a6:	9803      	ldr	r0, [sp, #12]
 80059a8:	703a      	strb	r2, [r7, #0]
 80059aa:	707b      	strb	r3, [r7, #1]
 80059ac:	b004      	add	sp, #16
 80059ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80059b2:	ab03      	add	r3, sp, #12
 80059b4:	4642      	mov	r2, r8
 80059b6:	4639      	mov	r1, r7
 80059b8:	4630      	mov	r0, r6
 80059ba:	f7fd fb65 	bl	8003088 <bsec_Entity_serializeAndAdd>
 80059be:	e7e2      	b.n	8005986 <bsec_GasHumidityPreProcessor_getConfiguration+0x2a>

080059c0 <bsec_GasHumidityPreProcessor_getState>:
 80059c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80059c4:	b084      	sub	sp, #16
 80059c6:	2501      	movs	r5, #1
 80059c8:	4606      	mov	r6, r0
 80059ca:	4690      	mov	r8, r2
 80059cc:	7800      	ldrb	r0, [r0, #0]
 80059ce:	f88d 5007 	strb.w	r5, [sp, #7]
 80059d2:	f10d 0207 	add.w	r2, sp, #7
 80059d6:	460f      	mov	r7, r1
 80059d8:	f001 f888 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 80059dc:	f89d 5007 	ldrb.w	r5, [sp, #7]
 80059e0:	9003      	str	r0, [sp, #12]
 80059e2:	b135      	cbz	r5, 80059f2 <bsec_GasHumidityPreProcessor_getState+0x32>
 80059e4:	3610      	adds	r6, #16
 80059e6:	2400      	movs	r4, #0
 80059e8:	b1ac      	cbz	r4, 8005a16 <bsec_GasHumidityPreProcessor_getState+0x56>
 80059ea:	3401      	adds	r4, #1
 80059ec:	42a5      	cmp	r5, r4
 80059ee:	d1fb      	bne.n	80059e8 <bsec_GasHumidityPreProcessor_getState+0x28>
 80059f0:	9803      	ldr	r0, [sp, #12]
 80059f2:	f8ad 000a 	strh.w	r0, [sp, #10]
 80059f6:	2202      	movs	r2, #2
 80059f8:	f10d 010a 	add.w	r1, sp, #10
 80059fc:	a802      	add	r0, sp, #8
 80059fe:	f026 fb6f 	bl	802c0e0 <memcpy>
 8005a02:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005a06:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005a0a:	9803      	ldr	r0, [sp, #12]
 8005a0c:	703a      	strb	r2, [r7, #0]
 8005a0e:	707b      	strb	r3, [r7, #1]
 8005a10:	b004      	add	sp, #16
 8005a12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005a16:	ab03      	add	r3, sp, #12
 8005a18:	4642      	mov	r2, r8
 8005a1a:	4639      	mov	r1, r7
 8005a1c:	4630      	mov	r0, r6
 8005a1e:	f7fd fb33 	bl	8003088 <bsec_Entity_serializeAndAdd>
 8005a22:	e7e2      	b.n	80059ea <bsec_GasHumidityPreProcessor_getState+0x2a>

08005a24 <bsec_GasHumidityPreProcessor_setState>:
 8005a24:	b570      	push	{r4, r5, r6, lr}
 8005a26:	b086      	sub	sp, #24
 8005a28:	ab04      	add	r3, sp, #16
 8005a2a:	ae05      	add	r6, sp, #20
 8005a2c:	4604      	mov	r4, r0
 8005a2e:	7800      	ldrb	r0, [r0, #0]
 8005a30:	e9cd 3600 	strd	r3, r6, [sp]
 8005a34:	f10d 030f 	add.w	r3, sp, #15
 8005a38:	460d      	mov	r5, r1
 8005a3a:	f001 f829 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8005a3e:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005a42:	b108      	cbz	r0, 8005a48 <bsec_GasHumidityPreProcessor_setState+0x24>
 8005a44:	b006      	add	sp, #24
 8005a46:	bd70      	pop	{r4, r5, r6, pc}
 8005a48:	4628      	mov	r0, r5
 8005a4a:	f104 0210 	add.w	r2, r4, #16
 8005a4e:	4631      	mov	r1, r6
 8005a50:	f7fd fafe 	bl	8003050 <bsec_Entity_parseAndDeserialize>
 8005a54:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005a58:	b006      	add	sp, #24
 8005a5a:	bd70      	pop	{r4, r5, r6, pc}

08005a5c <bsec_GasHumidityPreProcessor_updateInterfaceDependency>:
 8005a5c:	ee07 1a90 	vmov	s15, r1
 8005a60:	eddf 6a1e 	vldr	s13, [pc, #120]	; 8005adc <bsec_GasHumidityPreProcessor_updateInterfaceDependency+0x80>
 8005a64:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005a68:	4603      	mov	r3, r0
 8005a6a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005a6e:	b500      	push	{lr}
 8005a70:	b085      	sub	sp, #20
 8005a72:	3004      	adds	r0, #4
 8005a74:	a901      	add	r1, sp, #4
 8005a76:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8005a7a:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005a7e:	edd3 6a08 	vldr	s13, [r3, #32]
 8005a82:	edd3 5a09 	vldr	s11, [r3, #36]	; 0x24
 8005a86:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 8005a8a:	ee86 6a87 	vdiv.f32	s12, s13, s14
 8005a8e:	eec5 6a87 	vdiv.f32	s13, s11, s14
 8005a92:	eec7 5a87 	vdiv.f32	s11, s15, s14
 8005a96:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8005a9a:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8005a9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005aa2:	eef4 6ae7 	vcmpe.f32	s13, s15
 8005aa6:	bfc8      	it	gt
 8005aa8:	eeb0 6a67 	vmovgt.f32	s12, s15
 8005aac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ab0:	eef4 5ae7 	vcmpe.f32	s11, s15
 8005ab4:	bfc8      	it	gt
 8005ab6:	eef0 6a67 	vmovgt.f32	s13, s15
 8005aba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005abe:	bfd8      	it	le
 8005ac0:	eef0 7a65 	vmovle.f32	s15, s11
 8005ac4:	ed8d 6a01 	vstr	s12, [sp, #4]
 8005ac8:	edcd 6a02 	vstr	s13, [sp, #8]
 8005acc:	edcd 7a03 	vstr	s15, [sp, #12]
 8005ad0:	f001 fc9a 	bl	8007408 <bsec_ExpSmoothing_setCoeffFromBandwidth>
 8005ad4:	b005      	add	sp, #20
 8005ad6:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ada:	bf00      	nop
 8005adc:	42c80000 	.word	0x42c80000

08005ae0 <bsec_HumidityTemperatureCorrector_HumidityTemperatureCorrector>:
 8005ae0:	b510      	push	{r4, lr}
 8005ae2:	4604      	mov	r4, r0
 8005ae4:	f800 1b04 	strb.w	r1, [r0], #4
 8005ae8:	f001 fd0a 	bl	8007500 <bsec_b_ExpSmoothingBsec_ExpSmoothingBsec>
 8005aec:	4620      	mov	r0, r4
 8005aee:	f001 fc83 	bl	80073f8 <bsec_b_Channel_reset>
 8005af2:	4620      	mov	r0, r4
 8005af4:	bd10      	pop	{r4, pc}
 8005af6:	bf00      	nop

08005af8 <bsec_HumidityTemperatureCorrector_configure>:
 8005af8:	b570      	push	{r4, r5, r6, lr}
 8005afa:	b086      	sub	sp, #24
 8005afc:	ab04      	add	r3, sp, #16
 8005afe:	ae05      	add	r6, sp, #20
 8005b00:	4604      	mov	r4, r0
 8005b02:	7800      	ldrb	r0, [r0, #0]
 8005b04:	e9cd 3600 	strd	r3, r6, [sp]
 8005b08:	f10d 030f 	add.w	r3, sp, #15
 8005b0c:	460d      	mov	r5, r1
 8005b0e:	f000 ffbf 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8005b12:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005b16:	b108      	cbz	r0, 8005b1c <bsec_HumidityTemperatureCorrector_configure+0x24>
 8005b18:	b006      	add	sp, #24
 8005b1a:	bd70      	pop	{r4, r5, r6, pc}
 8005b1c:	4628      	mov	r0, r5
 8005b1e:	f104 0210 	add.w	r2, r4, #16
 8005b22:	4631      	mov	r1, r6
 8005b24:	f7fd faf6 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 8005b28:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005b2c:	b006      	add	sp, #24
 8005b2e:	bd70      	pop	{r4, r5, r6, pc}

08005b30 <bsec_HumidityTemperatureCorrector_doStep>:
 8005b30:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8005b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005b38:	b508      	push	{r3, lr}
 8005b3a:	d92d      	bls.n	8005b98 <bsec_HumidityTemperatureCorrector_doStep+0x68>
 8005b3c:	eddf 7a18 	vldr	s15, [pc, #96]	; 8005ba0 <bsec_HumidityTemperatureCorrector_doStep+0x70>
 8005b40:	eeb4 1a67 	vcmp.f32	s2, s15
 8005b44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005b48:	bfc8      	it	gt
 8005b4a:	eeb0 1a67 	vmovgt.f32	s2, s15
 8005b4e:	ed90 7a02 	vldr	s14, [r0, #8]
 8005b52:	ed90 6a01 	vldr	s12, [r0, #4]
 8005b56:	edd0 7a04 	vldr	s15, [r0, #16]
 8005b5a:	edd0 6a05 	vldr	s13, [r0, #20]
 8005b5e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8005b62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005b66:	bf08      	it	eq
 8005b68:	eeb0 7a40 	vmoveq.f32	s14, s0
 8005b6c:	ee30 0a47 	vsub.f32	s0, s0, s14
 8005b70:	ee61 7a27 	vmul.f32	s15, s2, s15
 8005b74:	ee20 0a06 	vmul.f32	s0, s0, s12
 8005b78:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005b7c:	ee30 0a07 	vadd.f32	s0, s0, s14
 8005b80:	ee37 1a81 	vadd.f32	s2, s15, s2
 8005b84:	ed80 0a02 	vstr	s0, [r0, #8]
 8005b88:	f001 f80e 	bl	8006ba8 <bsec_convertHumidity>
 8005b8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005b90:	eddf 0a03 	vldr	s1, [pc, #12]	; 8005ba0 <bsec_HumidityTemperatureCorrector_doStep+0x70>
 8005b94:	f023 bd2f 	b.w	80295f6 <fminf>
 8005b98:	ed9f 1a02 	vldr	s2, [pc, #8]	; 8005ba4 <bsec_HumidityTemperatureCorrector_doStep+0x74>
 8005b9c:	e7d7      	b.n	8005b4e <bsec_HumidityTemperatureCorrector_doStep+0x1e>
 8005b9e:	bf00      	nop
 8005ba0:	42c80000 	.word	0x42c80000
 8005ba4:	38d1b717 	.word	0x38d1b717

08005ba8 <bsec_HumidityTemperatureCorrector_getConfiguration>:
 8005ba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005bac:	b084      	sub	sp, #16
 8005bae:	2501      	movs	r5, #1
 8005bb0:	4606      	mov	r6, r0
 8005bb2:	4690      	mov	r8, r2
 8005bb4:	7800      	ldrb	r0, [r0, #0]
 8005bb6:	f88d 5007 	strb.w	r5, [sp, #7]
 8005bba:	f10d 0207 	add.w	r2, sp, #7
 8005bbe:	460f      	mov	r7, r1
 8005bc0:	f000 ff94 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8005bc4:	f89d 5007 	ldrb.w	r5, [sp, #7]
 8005bc8:	9003      	str	r0, [sp, #12]
 8005bca:	b135      	cbz	r5, 8005bda <bsec_HumidityTemperatureCorrector_getConfiguration+0x32>
 8005bcc:	3610      	adds	r6, #16
 8005bce:	2400      	movs	r4, #0
 8005bd0:	b1ac      	cbz	r4, 8005bfe <bsec_HumidityTemperatureCorrector_getConfiguration+0x56>
 8005bd2:	3401      	adds	r4, #1
 8005bd4:	42a5      	cmp	r5, r4
 8005bd6:	d1fb      	bne.n	8005bd0 <bsec_HumidityTemperatureCorrector_getConfiguration+0x28>
 8005bd8:	9803      	ldr	r0, [sp, #12]
 8005bda:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005bde:	2202      	movs	r2, #2
 8005be0:	f10d 010a 	add.w	r1, sp, #10
 8005be4:	a802      	add	r0, sp, #8
 8005be6:	f026 fa7b 	bl	802c0e0 <memcpy>
 8005bea:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005bee:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005bf2:	9803      	ldr	r0, [sp, #12]
 8005bf4:	703a      	strb	r2, [r7, #0]
 8005bf6:	707b      	strb	r3, [r7, #1]
 8005bf8:	b004      	add	sp, #16
 8005bfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005bfe:	ab03      	add	r3, sp, #12
 8005c00:	4642      	mov	r2, r8
 8005c02:	4639      	mov	r1, r7
 8005c04:	4630      	mov	r0, r6
 8005c06:	f7fd fda7 	bl	8003758 <bsec_n_Entity_serializeAndAdd>
 8005c0a:	e7e2      	b.n	8005bd2 <bsec_HumidityTemperatureCorrector_getConfiguration+0x2a>

08005c0c <bsec_HumidityTemperatureCorrector_getState>:
 8005c0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005c10:	b084      	sub	sp, #16
 8005c12:	4607      	mov	r7, r0
 8005c14:	4690      	mov	r8, r2
 8005c16:	7800      	ldrb	r0, [r0, #0]
 8005c18:	2401      	movs	r4, #1
 8005c1a:	f10d 0207 	add.w	r2, sp, #7
 8005c1e:	460e      	mov	r6, r1
 8005c20:	f88d 4007 	strb.w	r4, [sp, #7]
 8005c24:	f000 ff62 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8005c28:	f89d 5007 	ldrb.w	r5, [sp, #7]
 8005c2c:	9003      	str	r0, [sp, #12]
 8005c2e:	b12d      	cbz	r5, 8005c3c <bsec_HumidityTemperatureCorrector_getState+0x30>
 8005c30:	2400      	movs	r4, #0
 8005c32:	b1ac      	cbz	r4, 8005c60 <bsec_HumidityTemperatureCorrector_getState+0x54>
 8005c34:	3401      	adds	r4, #1
 8005c36:	42a5      	cmp	r5, r4
 8005c38:	d1fb      	bne.n	8005c32 <bsec_HumidityTemperatureCorrector_getState+0x26>
 8005c3a:	9803      	ldr	r0, [sp, #12]
 8005c3c:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005c40:	2202      	movs	r2, #2
 8005c42:	f10d 010a 	add.w	r1, sp, #10
 8005c46:	a802      	add	r0, sp, #8
 8005c48:	f026 fa4a 	bl	802c0e0 <memcpy>
 8005c4c:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005c50:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005c54:	9803      	ldr	r0, [sp, #12]
 8005c56:	7032      	strb	r2, [r6, #0]
 8005c58:	7073      	strb	r3, [r6, #1]
 8005c5a:	b004      	add	sp, #16
 8005c5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005c60:	ed97 0a02 	vldr	s0, [r7, #8]
 8005c64:	aa03      	add	r2, sp, #12
 8005c66:	4641      	mov	r1, r8
 8005c68:	4630      	mov	r0, r6
 8005c6a:	f7fd fb55 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8005c6e:	e7e1      	b.n	8005c34 <bsec_HumidityTemperatureCorrector_getState+0x28>

08005c70 <bsec_HumidityTemperatureCorrector_setState>:
 8005c70:	b570      	push	{r4, r5, r6, lr}
 8005c72:	b086      	sub	sp, #24
 8005c74:	ab04      	add	r3, sp, #16
 8005c76:	ae05      	add	r6, sp, #20
 8005c78:	4604      	mov	r4, r0
 8005c7a:	7800      	ldrb	r0, [r0, #0]
 8005c7c:	e9cd 3600 	strd	r3, r6, [sp]
 8005c80:	f10d 030f 	add.w	r3, sp, #15
 8005c84:	460d      	mov	r5, r1
 8005c86:	f000 ff03 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 8005c8a:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005c8e:	b108      	cbz	r0, 8005c94 <bsec_HumidityTemperatureCorrector_setState+0x24>
 8005c90:	b006      	add	sp, #24
 8005c92:	bd70      	pop	{r4, r5, r6, pc}
 8005c94:	4628      	mov	r0, r5
 8005c96:	4631      	mov	r1, r6
 8005c98:	f7fd fb20 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8005c9c:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8005ca0:	ed84 0a02 	vstr	s0, [r4, #8]
 8005ca4:	b006      	add	sp, #24
 8005ca6:	bd70      	pop	{r4, r5, r6, pc}

08005ca8 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>:
 8005ca8:	ee07 1a90 	vmov	s15, r1
 8005cac:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8005d24 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x7c>
 8005cb0:	ed9f 0a1d 	vldr	s0, [pc, #116]	; 8005d28 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x80>
 8005cb4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8005cb8:	b510      	push	{r4, lr}
 8005cba:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005cbe:	4604      	mov	r4, r0
 8005cc0:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8005cc4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8005cc8:	ed2d 8b02 	vpush	{d8}
 8005ccc:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8005cd0:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8005cd4:	f023 fc8f 	bl	80295f6 <fminf>
 8005cd8:	eddf 7a14 	vldr	s15, [pc, #80]	; 8005d2c <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x84>
 8005cdc:	eef0 8a40 	vmov.f32	s17, s0
 8005ce0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8005ce4:	f023 fce4 	bl	80296b0 <sinf>
 8005ce8:	ee20 8a00 	vmul.f32	s16, s0, s0
 8005cec:	ee28 0a08 	vmul.f32	s0, s16, s16
 8005cf0:	ee30 0a08 	vadd.f32	s0, s0, s16
 8005cf4:	f023 ff4a 	bl	8029b8c <sqrtf>
 8005cf8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8005cfc:	eef4 8a47 	vcmp.f32	s17, s14
 8005d00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005d04:	d008      	beq.n	8005d18 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x70>
 8005d06:	ee30 8a48 	vsub.f32	s16, s0, s16
 8005d0a:	ee38 8a08 	vadd.f32	s16, s16, s16
 8005d0e:	ed84 8a01 	vstr	s16, [r4, #4]
 8005d12:	ecbd 8b02 	vpop	{d8}
 8005d16:	bd10      	pop	{r4, pc}
 8005d18:	ecbd 8b02 	vpop	{d8}
 8005d1c:	ed84 7a01 	vstr	s14, [r4, #4]
 8005d20:	bd10      	pop	{r4, pc}
 8005d22:	bf00      	nop
 8005d24:	42c80000 	.word	0x42c80000
 8005d28:	3c50d499 	.word	0x3c50d499
 8005d2c:	3fc90fdb 	.word	0x3fc90fdb

08005d30 <bsec_IaqEstimator_IaqEstimator>:
 8005d30:	b430      	push	{r4, r5}
 8005d32:	4c13      	ldr	r4, [pc, #76]	; (8005d80 <bsec_IaqEstimator_IaqEstimator+0x50>)
 8005d34:	6304      	str	r4, [r0, #48]	; 0x30
 8005d36:	2402      	movs	r4, #2
 8005d38:	2500      	movs	r5, #0
 8005d3a:	7004      	strb	r4, [r0, #0]
 8005d3c:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
 8005d40:	7105      	strb	r5, [r0, #4]
 8005d42:	8044      	strh	r4, [r0, #2]
 8005d44:	2596      	movs	r5, #150	; 0x96
 8005d46:	2432      	movs	r4, #50	; 0x32
 8005d48:	80c5      	strh	r5, [r0, #6]
 8005d4a:	7204      	strb	r4, [r0, #8]
 8005d4c:	f04f 4581 	mov.w	r5, #1082130432	; 0x40800000
 8005d50:	4c0c      	ldr	r4, [pc, #48]	; (8005d84 <bsec_IaqEstimator_IaqEstimator+0x54>)
 8005d52:	6105      	str	r5, [r0, #16]
 8005d54:	6144      	str	r4, [r0, #20]
 8005d56:	f44f 75c8 	mov.w	r5, #400	; 0x190
 8005d5a:	4c0b      	ldr	r4, [pc, #44]	; (8005d88 <bsec_IaqEstimator_IaqEstimator+0x58>)
 8005d5c:	490b      	ldr	r1, [pc, #44]	; (8005d8c <bsec_IaqEstimator_IaqEstimator+0x5c>)
 8005d5e:	8305      	strh	r5, [r0, #24]
 8005d60:	2200      	movs	r2, #0
 8005d62:	f04f 557c 	mov.w	r5, #1056964608	; 0x3f000000
 8005d66:	61c4      	str	r4, [r0, #28]
 8005d68:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8005d6c:	6205      	str	r5, [r0, #32]
 8005d6e:	8484      	strh	r4, [r0, #36]	; 0x24
 8005d70:	60c2      	str	r2, [r0, #12]
 8005d72:	bc30      	pop	{r4, r5}
 8005d74:	6282      	str	r2, [r0, #40]	; 0x28
 8005d76:	62c2      	str	r2, [r0, #44]	; 0x2c
 8005d78:	6341      	str	r1, [r0, #52]	; 0x34
 8005d7a:	6381      	str	r1, [r0, #56]	; 0x38
 8005d7c:	4770      	bx	lr
 8005d7e:	bf00      	nop
 8005d80:	428551ec 	.word	0x428551ec
 8005d84:	41200000 	.word	0x41200000
 8005d88:	41700000 	.word	0x41700000
 8005d8c:	42480000 	.word	0x42480000

08005d90 <bsec_IaqEstimator_doStep>:
 8005d90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005d94:	edd1 7a02 	vldr	s15, [r1, #8]
 8005d98:	ed2d 8b06 	vpush	{d8-d10}
 8005d9c:	edd1 8a00 	vldr	s17, [r1]
 8005da0:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 8005da4:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8005da8:	ee78 8ac0 	vsub.f32	s17, s17, s0
 8005dac:	460d      	mov	r5, r1
 8005dae:	ee88 7aa7 	vdiv.f32	s14, s17, s15
 8005db2:	88c1      	ldrh	r1, [r0, #6]
 8005db4:	4604      	mov	r4, r0
 8005db6:	4617      	mov	r7, r2
 8005db8:	461e      	mov	r6, r3
 8005dba:	e9dd a90e 	ldrd	sl, r9, [sp, #56]	; 0x38
 8005dbe:	ee07 1a90 	vmov	s15, r1
 8005dc2:	7a01      	ldrb	r1, [r0, #8]
 8005dc4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005dc8:	eeb0 9a40 	vmov.f32	s18, s0
 8005dcc:	ee00 1a10 	vmov	s0, r1
 8005dd0:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005dd4:	8841      	ldrh	r1, [r0, #2]
 8005dd6:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8005dda:	ee08 1a10 	vmov	s16, r1
 8005dde:	eef0 9a60 	vmov.f32	s19, s1
 8005de2:	ee77 0a80 	vadd.f32	s1, s15, s0
 8005de6:	f023 fbeb 	bl	80295c0 <fmaxf>
 8005dea:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 8005dee:	eef0 0a40 	vmov.f32	s1, s0
 8005df2:	eeb0 0a48 	vmov.f32	s0, s16
 8005df6:	f023 fbfe 	bl	80295f6 <fminf>
 8005dfa:	7a23      	ldrb	r3, [r4, #8]
 8005dfc:	edd4 0a03 	vldr	s1, [r4, #12]
 8005e00:	ee07 3a90 	vmov	s15, r3
 8005e04:	ee68 0aa0 	vmul.f32	s1, s17, s1
 8005e08:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005e0c:	eeb0 aa40 	vmov.f32	s20, s0
 8005e10:	ee70 0aa7 	vadd.f32	s1, s1, s15
 8005e14:	eeb0 0a67 	vmov.f32	s0, s15
 8005e18:	f023 fbd2 	bl	80295c0 <fmaxf>
 8005e1c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8005e20:	eef4 9ae7 	vcmpe.f32	s19, s15
 8005e24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e28:	eeb0 8a40 	vmov.f32	s16, s0
 8005e2c:	d469      	bmi.n	8005f02 <bsec_IaqEstimator_doStep+0x172>
 8005e2e:	ed84 aa0d 	vstr	s20, [r4, #52]	; 0x34
 8005e32:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
 8005e36:	ed87 aa00 	vstr	s20, [r7]
 8005e3a:	692b      	ldr	r3, [r5, #16]
 8005e3c:	607b      	str	r3, [r7, #4]
 8005e3e:	ed86 8a00 	vstr	s16, [r6]
 8005e42:	692b      	ldr	r3, [r5, #16]
 8005e44:	6073      	str	r3, [r6, #4]
 8005e46:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8005e4a:	eef4 7ac8 	vcmpe.f32	s15, s16
 8005e4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e52:	db4c      	blt.n	8005eee <bsec_IaqEstimator_doStep+0x15e>
 8005e54:	8b23      	ldrh	r3, [r4, #24]
 8005e56:	edd4 0a04 	vldr	s1, [r4, #16]
 8005e5a:	ee00 3a10 	vmov	s0, r3
 8005e5e:	ee68 0a20 	vmul.f32	s1, s16, s1
 8005e62:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8005e66:	ee70 0a80 	vadd.f32	s1, s1, s0
 8005e6a:	f023 fba9 	bl	80295c0 <fmaxf>
 8005e6e:	ed8a 0a00 	vstr	s0, [sl]
 8005e72:	692a      	ldr	r2, [r5, #16]
 8005e74:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 8005e76:	f8ca 2004 	str.w	r2, [sl, #4]
 8005e7a:	ed94 0a0a 	vldr	s0, [r4, #40]	; 0x28
 8005e7e:	edd4 0a0b 	vldr	s1, [r4, #44]	; 0x2c
 8005e82:	ee28 8a00 	vmul.f32	s16, s16, s0
 8005e86:	ee07 3a90 	vmov	s15, r3
 8005e8a:	ee78 0a20 	vadd.f32	s1, s16, s1
 8005e8e:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8005e92:	eeb8 8a67 	vcvt.f32.u32	s16, s15
 8005e96:	f023 fde1 	bl	8029a5c <powf>
 8005e9a:	eef0 0a40 	vmov.f32	s1, s0
 8005e9e:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 8005f48 <bsec_IaqEstimator_doStep+0x1b8>
 8005ea2:	f023 fb8d 	bl	80295c0 <fmaxf>
 8005ea6:	eef0 0a40 	vmov.f32	s1, s0
 8005eaa:	eeb0 0a48 	vmov.f32	s0, s16
 8005eae:	f023 fba2 	bl	80295f6 <fminf>
 8005eb2:	ed89 0a00 	vstr	s0, [r9]
 8005eb6:	692b      	ldr	r3, [r5, #16]
 8005eb8:	f8c9 3004 	str.w	r3, [r9, #4]
 8005ebc:	edd5 7a01 	vldr	s15, [r5, #4]
 8005ec0:	ed95 7a03 	vldr	s14, [r5, #12]
 8005ec4:	eddf 0a21 	vldr	s1, [pc, #132]	; 8005f4c <bsec_IaqEstimator_doStep+0x1bc>
 8005ec8:	ee37 9ac9 	vsub.f32	s18, s15, s18
 8005ecc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8005ed0:	ee89 0a27 	vdiv.f32	s0, s18, s15
 8005ed4:	ee20 0a20 	vmul.f32	s0, s0, s1
 8005ed8:	f023 fb8d 	bl	80295f6 <fminf>
 8005edc:	ecbd 8b06 	vpop	{d8-d10}
 8005ee0:	ed88 0a00 	vstr	s0, [r8]
 8005ee4:	696b      	ldr	r3, [r5, #20]
 8005ee6:	f8c8 3004 	str.w	r3, [r8, #4]
 8005eea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005eee:	8b23      	ldrh	r3, [r4, #24]
 8005ef0:	edd4 0a05 	vldr	s1, [r4, #20]
 8005ef4:	ee00 3a10 	vmov	s0, r3
 8005ef8:	ee68 0a20 	vmul.f32	s1, s16, s1
 8005efc:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8005f00:	e7b3      	b.n	8005e6a <bsec_IaqEstimator_doStep+0xda>
 8005f02:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
 8005f06:	eeb4 0aca 	vcmpe.f32	s0, s20
 8005f0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f0e:	ee69 9aa9 	vmul.f32	s19, s19, s19
 8005f12:	d507      	bpl.n	8005f24 <bsec_IaqEstimator_doStep+0x194>
 8005f14:	ee77 7ae9 	vsub.f32	s15, s15, s19
 8005f18:	ee2a aa29 	vmul.f32	s20, s20, s19
 8005f1c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8005f20:	ee30 aa0a 	vadd.f32	s20, s0, s20
 8005f24:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 8005f28:	eeb4 0ac8 	vcmpe.f32	s0, s16
 8005f2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f30:	d581      	bpl.n	8005e36 <bsec_IaqEstimator_doStep+0xa6>
 8005f32:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 8005f36:	ee70 0ae9 	vsub.f32	s1, s1, s19
 8005f3a:	ee28 8a29 	vmul.f32	s16, s16, s19
 8005f3e:	ee60 0a80 	vmul.f32	s1, s1, s0
 8005f42:	ee30 8a88 	vadd.f32	s16, s1, s16
 8005f46:	e776      	b.n	8005e36 <bsec_IaqEstimator_doStep+0xa6>
 8005f48:	3dcccccd 	.word	0x3dcccccd
 8005f4c:	42c80000 	.word	0x42c80000

08005f50 <bsec_IaqEstimator_getConfiguration>:
 8005f50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005f54:	b085      	sub	sp, #20
 8005f56:	4606      	mov	r6, r0
 8005f58:	4617      	mov	r7, r2
 8005f5a:	7800      	ldrb	r0, [r0, #0]
 8005f5c:	2408      	movs	r4, #8
 8005f5e:	f10d 0207 	add.w	r2, sp, #7
 8005f62:	460d      	mov	r5, r1
 8005f64:	f88d 4007 	strb.w	r4, [sp, #7]
 8005f68:	f000 fdc0 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8005f6c:	f89d 8007 	ldrb.w	r8, [sp, #7]
 8005f70:	9003      	str	r0, [sp, #12]
 8005f72:	f1b8 0f00 	cmp.w	r8, #0
 8005f76:	d025      	beq.n	8005fc4 <bsec_IaqEstimator_getConfiguration+0x74>
 8005f78:	2401      	movs	r4, #1
 8005f7a:	f106 0910 	add.w	r9, r6, #16
 8005f7e:	b2e3      	uxtb	r3, r4
 8005f80:	3b01      	subs	r3, #1
 8005f82:	2b07      	cmp	r3, #7
 8005f84:	d80c      	bhi.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 8005f86:	e8df f003 	tbb	[pc, r3]
 8005f8a:	3d44      	.short	0x3d44
 8005f8c:	2f364b52 	.word	0x2f364b52
 8005f90:	0411      	.short	0x0411
 8005f92:	ed96 0a08 	vldr	s0, [r6, #32]
 8005f96:	aa03      	add	r2, sp, #12
 8005f98:	4639      	mov	r1, r7
 8005f9a:	4628      	mov	r0, r5
 8005f9c:	f7fd f9bc 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8005fa0:	45a0      	cmp	r8, r4
 8005fa2:	f104 0301 	add.w	r3, r4, #1
 8005fa6:	d00c      	beq.n	8005fc2 <bsec_IaqEstimator_getConfiguration+0x72>
 8005fa8:	461c      	mov	r4, r3
 8005faa:	e7e8      	b.n	8005f7e <bsec_IaqEstimator_getConfiguration+0x2e>
 8005fac:	ed96 0a07 	vldr	s0, [r6, #28]
 8005fb0:	aa03      	add	r2, sp, #12
 8005fb2:	4639      	mov	r1, r7
 8005fb4:	4628      	mov	r0, r5
 8005fb6:	f7fd f9af 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8005fba:	45a0      	cmp	r8, r4
 8005fbc:	f104 0301 	add.w	r3, r4, #1
 8005fc0:	d1f2      	bne.n	8005fa8 <bsec_IaqEstimator_getConfiguration+0x58>
 8005fc2:	9803      	ldr	r0, [sp, #12]
 8005fc4:	f8ad 000a 	strh.w	r0, [sp, #10]
 8005fc8:	2202      	movs	r2, #2
 8005fca:	f10d 010a 	add.w	r1, sp, #10
 8005fce:	a802      	add	r0, sp, #8
 8005fd0:	f026 f886 	bl	802c0e0 <memcpy>
 8005fd4:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8005fd8:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8005fdc:	9803      	ldr	r0, [sp, #12]
 8005fde:	702a      	strb	r2, [r5, #0]
 8005fe0:	706b      	strb	r3, [r5, #1]
 8005fe2:	b005      	add	sp, #20
 8005fe4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8005fe8:	8b30      	ldrh	r0, [r6, #24]
 8005fea:	ab03      	add	r3, sp, #12
 8005fec:	463a      	mov	r2, r7
 8005fee:	4629      	mov	r1, r5
 8005ff0:	f7fd f916 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 8005ff4:	e7d4      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 8005ff6:	ab03      	add	r3, sp, #12
 8005ff8:	463a      	mov	r2, r7
 8005ffa:	4629      	mov	r1, r5
 8005ffc:	4648      	mov	r0, r9
 8005ffe:	f7fd fbab 	bl	8003758 <bsec_n_Entity_serializeAndAdd>
 8006002:	e7cd      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 8006004:	8870      	ldrh	r0, [r6, #2]
 8006006:	ab03      	add	r3, sp, #12
 8006008:	463a      	mov	r2, r7
 800600a:	4629      	mov	r1, r5
 800600c:	f7fd f908 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 8006010:	e7c6      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 8006012:	7930      	ldrb	r0, [r6, #4]
 8006014:	ab03      	add	r3, sp, #12
 8006016:	463a      	mov	r2, r7
 8006018:	4629      	mov	r1, r5
 800601a:	f7fd f9bf 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800601e:	e7bf      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 8006020:	7a30      	ldrb	r0, [r6, #8]
 8006022:	ab03      	add	r3, sp, #12
 8006024:	463a      	mov	r2, r7
 8006026:	4629      	mov	r1, r5
 8006028:	f7fd f9b8 	bl	800339c <bsec_f_Entity_serializeAndAdd>
 800602c:	e7b8      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>
 800602e:	88f0      	ldrh	r0, [r6, #6]
 8006030:	ab03      	add	r3, sp, #12
 8006032:	463a      	mov	r2, r7
 8006034:	4629      	mov	r1, r5
 8006036:	f7fd f8f3 	bl	8003220 <bsec_c_Entity_serializeAndAdd>
 800603a:	e7b1      	b.n	8005fa0 <bsec_IaqEstimator_getConfiguration+0x50>

0800603c <bsec_IaqEstimator_getState>:
 800603c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006040:	b084      	sub	sp, #16
 8006042:	4680      	mov	r8, r0
 8006044:	4616      	mov	r6, r2
 8006046:	7800      	ldrb	r0, [r0, #0]
 8006048:	2402      	movs	r4, #2
 800604a:	f10d 0207 	add.w	r2, sp, #7
 800604e:	460d      	mov	r5, r1
 8006050:	f88d 4007 	strb.w	r4, [sp, #7]
 8006054:	f000 fd4a 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8006058:	f89d 7007 	ldrb.w	r7, [sp, #7]
 800605c:	9003      	str	r0, [sp, #12]
 800605e:	b1f7      	cbz	r7, 800609e <bsec_IaqEstimator_getState+0x62>
 8006060:	2401      	movs	r4, #1
 8006062:	e00d      	b.n	8006080 <bsec_IaqEstimator_getState+0x44>
 8006064:	2b02      	cmp	r3, #2
 8006066:	aa03      	add	r2, sp, #12
 8006068:	4631      	mov	r1, r6
 800606a:	4628      	mov	r0, r5
 800606c:	d103      	bne.n	8006076 <bsec_IaqEstimator_getState+0x3a>
 800606e:	ed98 0a0e 	vldr	s0, [r8, #56]	; 0x38
 8006072:	f7fd f951 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8006076:	42a7      	cmp	r7, r4
 8006078:	f104 0301 	add.w	r3, r4, #1
 800607c:	d00e      	beq.n	800609c <bsec_IaqEstimator_getState+0x60>
 800607e:	461c      	mov	r4, r3
 8006080:	b2e3      	uxtb	r3, r4
 8006082:	2b01      	cmp	r3, #1
 8006084:	d1ee      	bne.n	8006064 <bsec_IaqEstimator_getState+0x28>
 8006086:	ed98 0a0d 	vldr	s0, [r8, #52]	; 0x34
 800608a:	aa03      	add	r2, sp, #12
 800608c:	4631      	mov	r1, r6
 800608e:	4628      	mov	r0, r5
 8006090:	f7fd f942 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8006094:	42a7      	cmp	r7, r4
 8006096:	f104 0301 	add.w	r3, r4, #1
 800609a:	d1f0      	bne.n	800607e <bsec_IaqEstimator_getState+0x42>
 800609c:	9803      	ldr	r0, [sp, #12]
 800609e:	f8ad 000a 	strh.w	r0, [sp, #10]
 80060a2:	2202      	movs	r2, #2
 80060a4:	f10d 010a 	add.w	r1, sp, #10
 80060a8:	a802      	add	r0, sp, #8
 80060aa:	f026 f819 	bl	802c0e0 <memcpy>
 80060ae:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80060b2:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80060b6:	9803      	ldr	r0, [sp, #12]
 80060b8:	702a      	strb	r2, [r5, #0]
 80060ba:	706b      	strb	r3, [r5, #1]
 80060bc:	b004      	add	sp, #16
 80060be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80060c2:	bf00      	nop

080060c4 <bsec_IaqEstimator_setState>:
 80060c4:	b570      	push	{r4, r5, r6, lr}
 80060c6:	b086      	sub	sp, #24
 80060c8:	ab04      	add	r3, sp, #16
 80060ca:	ae05      	add	r6, sp, #20
 80060cc:	4604      	mov	r4, r0
 80060ce:	7800      	ldrb	r0, [r0, #0]
 80060d0:	e9cd 3600 	strd	r3, r6, [sp]
 80060d4:	f10d 030f 	add.w	r3, sp, #15
 80060d8:	460d      	mov	r5, r1
 80060da:	f000 fcd9 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80060de:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80060e2:	b108      	cbz	r0, 80060e8 <bsec_IaqEstimator_setState+0x24>
 80060e4:	b006      	add	sp, #24
 80060e6:	bd70      	pop	{r4, r5, r6, pc}
 80060e8:	4631      	mov	r1, r6
 80060ea:	4628      	mov	r0, r5
 80060ec:	f7fd f8f6 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80060f0:	4628      	mov	r0, r5
 80060f2:	4631      	mov	r1, r6
 80060f4:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
 80060f8:	f7fd f8f0 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80060fc:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8006100:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
 8006104:	b006      	add	sp, #24
 8006106:	bd70      	pop	{r4, r5, r6, pc}

08006108 <bsec_IaqEstimator_updateInterfaceDependency>:
 8006108:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800610c:	4299      	cmp	r1, r3
 800610e:	d045      	beq.n	800619c <bsec_IaqEstimator_updateInterfaceDependency+0x94>
 8006110:	b510      	push	{r4, lr}
 8006112:	88c3      	ldrh	r3, [r0, #6]
 8006114:	7a02      	ldrb	r2, [r0, #8]
 8006116:	4413      	add	r3, r2
 8006118:	ee07 3a90 	vmov	s15, r3
 800611c:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
 8006120:	ed2d 8b04 	vpush	{d8-d9}
 8006124:	4604      	mov	r4, r0
 8006126:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 800612a:	d038      	beq.n	800619e <bsec_IaqEstimator_updateInterfaceDependency+0x96>
 800612c:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
 8006130:	d031      	beq.n	8006196 <bsec_IaqEstimator_updateInterfaceDependency+0x8e>
 8006132:	eddf 9a1c 	vldr	s19, [pc, #112]	; 80061a4 <bsec_IaqEstimator_updateInterfaceDependency+0x9c>
 8006136:	eddf 7a1c 	vldr	s15, [pc, #112]	; 80061a8 <bsec_IaqEstimator_updateInterfaceDependency+0xa0>
 800613a:	2964      	cmp	r1, #100	; 0x64
 800613c:	bf08      	it	eq
 800613e:	eef0 9a67 	vmoveq.f32	s19, s15
 8006142:	ed94 0a07 	vldr	s0, [r4, #28]
 8006146:	f023 fc53 	bl	80299f0 <log10f>
 800614a:	7a23      	ldrb	r3, [r4, #8]
 800614c:	eef0 8a40 	vmov.f32	s17, s0
 8006150:	ee09 3a10 	vmov	s18, r3
 8006154:	ed94 0a08 	vldr	s0, [r4, #32]
 8006158:	f023 fc4a 	bl	80299f0 <log10f>
 800615c:	eeb8 9a49 	vcvt.f32.u32	s18, s18
 8006160:	ee78 7ac0 	vsub.f32	s15, s17, s0
 8006164:	ee38 9a49 	vsub.f32	s18, s16, s18
 8006168:	eeb0 0a69 	vmov.f32	s0, s19
 800616c:	eec7 9a89 	vdiv.f32	s19, s15, s18
 8006170:	f023 fc3e 	bl	80299f0 <log10f>
 8006174:	f023 f9da 	bl	802952c <fabsf>
 8006178:	eec9 7a00 	vdiv.f32	s15, s18, s0
 800617c:	ee28 8a29 	vmul.f32	s16, s16, s19
 8006180:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
 8006184:	ee38 8ac8 	vsub.f32	s16, s17, s16
 8006188:	edc4 7a03 	vstr	s15, [r4, #12]
 800618c:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
 8006190:	ecbd 8b04 	vpop	{d8-d9}
 8006194:	bd10      	pop	{r4, pc}
 8006196:	eddf 9a04 	vldr	s19, [pc, #16]	; 80061a8 <bsec_IaqEstimator_updateInterfaceDependency+0xa0>
 800619a:	e7d2      	b.n	8006142 <bsec_IaqEstimator_updateInterfaceDependency+0x3a>
 800619c:	4770      	bx	lr
 800619e:	eddf 9a03 	vldr	s19, [pc, #12]	; 80061ac <bsec_IaqEstimator_updateInterfaceDependency+0xa4>
 80061a2:	e7ce      	b.n	8006142 <bsec_IaqEstimator_updateInterfaceDependency+0x3a>
 80061a4:	3f464c30 	.word	0x3f464c30
 80061a8:	3f19999a 	.word	0x3f19999a
 80061ac:	3f23d70a 	.word	0x3f23d70a

080061b0 <bsec_b_IaqEstimator_configure>:
 80061b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80061b4:	b086      	sub	sp, #24
 80061b6:	ab04      	add	r3, sp, #16
 80061b8:	af05      	add	r7, sp, #20
 80061ba:	4605      	mov	r5, r0
 80061bc:	7800      	ldrb	r0, [r0, #0]
 80061be:	e9cd 3700 	strd	r3, r7, [sp]
 80061c2:	f10d 030f 	add.w	r3, sp, #15
 80061c6:	460e      	mov	r6, r1
 80061c8:	f000 fc62 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80061cc:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80061d0:	b9b8      	cbnz	r0, 8006202 <bsec_b_IaqEstimator_configure+0x52>
 80061d2:	2401      	movs	r4, #1
 80061d4:	f105 0810 	add.w	r8, r5, #16
 80061d8:	b2e3      	uxtb	r3, r4
 80061da:	3b01      	subs	r3, #1
 80061dc:	2b06      	cmp	r3, #6
 80061de:	d837      	bhi.n	8006250 <bsec_b_IaqEstimator_configure+0xa0>
 80061e0:	e8df f003 	tbb	[pc, r3]
 80061e4:	1e242a30 	.word	0x1e242a30
 80061e8:	1218      	.short	0x1218
 80061ea:	04          	.byte	0x04
 80061eb:	00          	.byte	0x00
 80061ec:	4639      	mov	r1, r7
 80061ee:	4630      	mov	r0, r6
 80061f0:	f7fd f874 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 80061f4:	ed85 0a07 	vstr	s0, [r5, #28]
 80061f8:	3401      	adds	r4, #1
 80061fa:	2c09      	cmp	r4, #9
 80061fc:	d1ec      	bne.n	80061d8 <bsec_b_IaqEstimator_configure+0x28>
 80061fe:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8006202:	b006      	add	sp, #24
 8006204:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006208:	4639      	mov	r1, r7
 800620a:	4630      	mov	r0, r6
 800620c:	f7fc fff0 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8006210:	8328      	strh	r0, [r5, #24]
 8006212:	e7f1      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 8006214:	4642      	mov	r2, r8
 8006216:	4639      	mov	r1, r7
 8006218:	4630      	mov	r0, r6
 800621a:	f7fc ff7b 	bl	8003114 <bsec_b_Entity_parseAndDeserialize>
 800621e:	e7eb      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 8006220:	4639      	mov	r1, r7
 8006222:	4630      	mov	r0, r6
 8006224:	f7fd f8a4 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 8006228:	7228      	strb	r0, [r5, #8]
 800622a:	e7e5      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 800622c:	4639      	mov	r1, r7
 800622e:	4630      	mov	r0, r6
 8006230:	f7fc ffde 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8006234:	80e8      	strh	r0, [r5, #6]
 8006236:	e7df      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 8006238:	4639      	mov	r1, r7
 800623a:	4630      	mov	r0, r6
 800623c:	f7fc ffd8 	bl	80031f0 <bsec_c_Entity_parseAndDeserialize>
 8006240:	8068      	strh	r0, [r5, #2]
 8006242:	e7d9      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 8006244:	4639      	mov	r1, r7
 8006246:	4630      	mov	r0, r6
 8006248:	f7fd f892 	bl	8003370 <bsec_f_Entity_parseAndDeserialize>
 800624c:	7128      	strb	r0, [r5, #4]
 800624e:	e7d3      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 8006250:	4639      	mov	r1, r7
 8006252:	4630      	mov	r0, r6
 8006254:	f7fd f842 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8006258:	ed85 0a08 	vstr	s0, [r5, #32]
 800625c:	e7cc      	b.n	80061f8 <bsec_b_IaqEstimator_configure+0x48>
 800625e:	bf00      	nop

08006260 <bsec_SensorHeatCompensator_SensorHeatCompensator>:
 8006260:	b430      	push	{r4, r5}
 8006262:	4916      	ldr	r1, [pc, #88]	; (80062bc <bsec_SensorHeatCompensator_SensorHeatCompensator+0x5c>)
 8006264:	4c16      	ldr	r4, [pc, #88]	; (80062c0 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x60>)
 8006266:	4d17      	ldr	r5, [pc, #92]	; (80062c4 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x64>)
 8006268:	6041      	str	r1, [r0, #4]
 800626a:	6144      	str	r4, [r0, #20]
 800626c:	2109      	movs	r1, #9
 800626e:	4c16      	ldr	r4, [pc, #88]	; (80062c8 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x68>)
 8006270:	4a16      	ldr	r2, [pc, #88]	; (80062cc <bsec_SensorHeatCompensator_SensorHeatCompensator+0x6c>)
 8006272:	7001      	strb	r1, [r0, #0]
 8006274:	6105      	str	r5, [r0, #16]
 8006276:	4916      	ldr	r1, [pc, #88]	; (80062d0 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x70>)
 8006278:	4d16      	ldr	r5, [pc, #88]	; (80062d4 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x74>)
 800627a:	6184      	str	r4, [r0, #24]
 800627c:	4c16      	ldr	r4, [pc, #88]	; (80062d8 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x78>)
 800627e:	6242      	str	r2, [r0, #36]	; 0x24
 8006280:	6281      	str	r1, [r0, #40]	; 0x28
 8006282:	4a16      	ldr	r2, [pc, #88]	; (80062dc <bsec_SensorHeatCompensator_SensorHeatCompensator+0x7c>)
 8006284:	4916      	ldr	r1, [pc, #88]	; (80062e0 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x80>)
 8006286:	62c5      	str	r5, [r0, #44]	; 0x2c
 8006288:	6384      	str	r4, [r0, #56]	; 0x38
 800628a:	4d16      	ldr	r5, [pc, #88]	; (80062e4 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x84>)
 800628c:	4c16      	ldr	r4, [pc, #88]	; (80062e8 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x88>)
 800628e:	63c2      	str	r2, [r0, #60]	; 0x3c
 8006290:	6401      	str	r1, [r0, #64]	; 0x40
 8006292:	2200      	movs	r2, #0
 8006294:	4915      	ldr	r1, [pc, #84]	; (80062ec <bsec_SensorHeatCompensator_SensorHeatCompensator+0x8c>)
 8006296:	64c5      	str	r5, [r0, #76]	; 0x4c
 8006298:	6504      	str	r4, [r0, #80]	; 0x50
 800629a:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 800629e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80062a2:	e9c0 4516 	strd	r4, r5, [r0, #88]	; 0x58
 80062a6:	6601      	str	r1, [r0, #96]	; 0x60
 80062a8:	bc30      	pop	{r4, r5}
 80062aa:	6082      	str	r2, [r0, #8]
 80062ac:	60c2      	str	r2, [r0, #12]
 80062ae:	61c2      	str	r2, [r0, #28]
 80062b0:	6202      	str	r2, [r0, #32]
 80062b2:	6302      	str	r2, [r0, #48]	; 0x30
 80062b4:	6342      	str	r2, [r0, #52]	; 0x34
 80062b6:	6442      	str	r2, [r0, #68]	; 0x44
 80062b8:	6482      	str	r2, [r0, #72]	; 0x48
 80062ba:	4770      	bx	lr
 80062bc:	3d96f007 	.word	0x3d96f007
 80062c0:	3fd78034 	.word	0x3fd78034
 80062c4:	3de17c1c 	.word	0x3de17c1c
 80062c8:	40a00000 	.word	0x40a00000
 80062cc:	3e0ccccd 	.word	0x3e0ccccd
 80062d0:	3e27d567 	.word	0x3e27d567
 80062d4:	c04c3fe6 	.word	0xc04c3fe6
 80062d8:	bf3ced91 	.word	0xbf3ced91
 80062dc:	3f403afb 	.word	0x3f403afb
 80062e0:	408350b1 	.word	0x408350b1
 80062e4:	3ee3fe5d 	.word	0x3ee3fe5d
 80062e8:	bf853c36 	.word	0xbf853c36
 80062ec:	40400000 	.word	0x40400000

080062f0 <bsec_SensorHeatCompensator_configure>:
 80062f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80062f4:	b086      	sub	sp, #24
 80062f6:	ab04      	add	r3, sp, #16
 80062f8:	ae05      	add	r6, sp, #20
 80062fa:	4604      	mov	r4, r0
 80062fc:	7800      	ldrb	r0, [r0, #0]
 80062fe:	e9cd 3600 	strd	r3, r6, [sp]
 8006302:	f10d 030f 	add.w	r3, sp, #15
 8006306:	460d      	mov	r5, r1
 8006308:	f000 fbc2 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 800630c:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8006310:	b9e0      	cbnz	r0, 800634c <bsec_SensorHeatCompensator_configure+0x5c>
 8006312:	f04f 0a01 	mov.w	sl, #1
 8006316:	f104 0940 	add.w	r9, r4, #64	; 0x40
 800631a:	f104 082c 	add.w	r8, r4, #44	; 0x2c
 800631e:	f104 0718 	add.w	r7, r4, #24
 8006322:	fa5f f38a 	uxtb.w	r3, sl
 8006326:	3b01      	subs	r3, #1
 8006328:	2b03      	cmp	r3, #3
 800632a:	d824      	bhi.n	8006376 <bsec_SensorHeatCompensator_configure+0x86>
 800632c:	e8df f003 	tbb	[pc, r3]
 8006330:	0211171d 	.word	0x0211171d
 8006334:	464a      	mov	r2, r9
 8006336:	4631      	mov	r1, r6
 8006338:	4628      	mov	r0, r5
 800633a:	f7fd fab5 	bl	80038a8 <bsec_q_Entity_parseAndDeserialize>
 800633e:	f10a 0a01 	add.w	sl, sl, #1
 8006342:	f1ba 0f06 	cmp.w	sl, #6
 8006346:	d1ec      	bne.n	8006322 <bsec_SensorHeatCompensator_configure+0x32>
 8006348:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 800634c:	b006      	add	sp, #24
 800634e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006352:	4642      	mov	r2, r8
 8006354:	4631      	mov	r1, r6
 8006356:	4628      	mov	r0, r5
 8006358:	f7fd faa6 	bl	80038a8 <bsec_q_Entity_parseAndDeserialize>
 800635c:	e7ef      	b.n	800633e <bsec_SensorHeatCompensator_configure+0x4e>
 800635e:	463a      	mov	r2, r7
 8006360:	4631      	mov	r1, r6
 8006362:	4628      	mov	r0, r5
 8006364:	f7fd faa0 	bl	80038a8 <bsec_q_Entity_parseAndDeserialize>
 8006368:	e7e9      	b.n	800633e <bsec_SensorHeatCompensator_configure+0x4e>
 800636a:	1d22      	adds	r2, r4, #4
 800636c:	4631      	mov	r1, r6
 800636e:	4628      	mov	r0, r5
 8006370:	f7fd fa9a 	bl	80038a8 <bsec_q_Entity_parseAndDeserialize>
 8006374:	e7e3      	b.n	800633e <bsec_SensorHeatCompensator_configure+0x4e>
 8006376:	4631      	mov	r1, r6
 8006378:	4628      	mov	r0, r5
 800637a:	f7fc ffaf 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 800637e:	ed84 0a18 	vstr	s0, [r4, #96]	; 0x60
 8006382:	e7dc      	b.n	800633e <bsec_SensorHeatCompensator_configure+0x4e>

08006384 <bsec_SensorHeatCompensator_doStep>:
 8006384:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006388:	ed2d 8b04 	vpush	{d8-d9}
 800638c:	b083      	sub	sp, #12
 800638e:	4605      	mov	r5, r0
 8006390:	f8bd 4040 	ldrh.w	r4, [sp, #64]	; 0x40
 8006394:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8006398:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
 800639c:	f5b4 6fe1 	cmp.w	r4, #1800	; 0x708
 80063a0:	4617      	mov	r7, r2
 80063a2:	461e      	mov	r6, r3
 80063a4:	eeb0 8a40 	vmov.f32	s16, s0
 80063a8:	eef0 8a60 	vmov.f32	s17, s1
 80063ac:	d06b      	beq.n	8006486 <bsec_SensorHeatCompensator_doStep+0x102>
 80063ae:	d928      	bls.n	8006402 <bsec_SensorHeatCompensator_doStep+0x7e>
 80063b0:	f241 7370 	movw	r3, #6000	; 0x1770
 80063b4:	429c      	cmp	r4, r3
 80063b6:	d02e      	beq.n	8006416 <bsec_SensorHeatCompensator_doStep+0x92>
 80063b8:	f247 5330 	movw	r3, #30000	; 0x7530
 80063bc:	429c      	cmp	r4, r3
 80063be:	bf08      	it	eq
 80063c0:	2401      	moveq	r4, #1
 80063c2:	d108      	bne.n	80063d6 <bsec_SensorHeatCompensator_doStep+0x52>
 80063c4:	e9d5 0116 	ldrd	r0, r1, [r5, #88]	; 0x58
 80063c8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80063cc:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80063d0:	f000 fc5c 	bl	8006c8c <bsec_isequal>
 80063d4:	b308      	cbz	r0, 800641a <bsec_SensorHeatCompensator_doStep+0x96>
 80063d6:	ed9f 9a30 	vldr	s18, [pc, #192]	; 8006498 <bsec_SensorHeatCompensator_doStep+0x114>
 80063da:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80063de:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80063e2:	4638      	mov	r0, r7
 80063e4:	4631      	mov	r1, r6
 80063e6:	f000 fc51 	bl	8006c8c <bsec_isequal>
 80063ea:	b908      	cbnz	r0, 80063f0 <bsec_SensorHeatCompensator_doStep+0x6c>
 80063ec:	e9c5 7616 	strd	r7, r6, [r5, #88]	; 0x58
 80063f0:	ee38 0a49 	vsub.f32	s0, s16, s18
 80063f4:	ee30 0a68 	vsub.f32	s0, s0, s17
 80063f8:	b003      	add	sp, #12
 80063fa:	ecbd 8b04 	vpop	{d8-d9}
 80063fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006402:	2c64      	cmp	r4, #100	; 0x64
 8006404:	d005      	beq.n	8006412 <bsec_SensorHeatCompensator_doStep+0x8e>
 8006406:	f5b4 7f96 	cmp.w	r4, #300	; 0x12c
 800640a:	bf08      	it	eq
 800640c:	2404      	moveq	r4, #4
 800640e:	d0d9      	beq.n	80063c4 <bsec_SensorHeatCompensator_doStep+0x40>
 8006410:	e7e1      	b.n	80063d6 <bsec_SensorHeatCompensator_doStep+0x52>
 8006412:	2405      	movs	r4, #5
 8006414:	e7d6      	b.n	80063c4 <bsec_SensorHeatCompensator_doStep+0x40>
 8006416:	2402      	movs	r4, #2
 8006418:	e7d4      	b.n	80063c4 <bsec_SensorHeatCompensator_doStep+0x40>
 800641a:	e9d5 0116 	ldrd	r0, r1, [r5, #88]	; 0x58
 800641e:	ebb8 0000 	subs.w	r0, r8, r0
 8006422:	eb69 0101 	sbc.w	r1, r9, r1
 8006426:	f001 fb39 	bl	8007a9c <__aeabi_l2d>
 800642a:	a319      	add	r3, pc, #100	; (adr r3, 8006490 <bsec_SensorHeatCompensator_doStep+0x10c>)
 800642c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006430:	f001 fc8c 	bl	8007d4c <__aeabi_ddiv>
 8006434:	460b      	mov	r3, r1
 8006436:	4602      	mov	r2, r0
 8006438:	e9cd 2300 	strd	r2, r3, [sp]
 800643c:	f001 fe54 	bl	80080e8 <__aeabi_d2f>
 8006440:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 8006444:	ee07 0a90 	vmov	s15, r0
 8006448:	e9dd 2300 	ldrd	r2, r3, [sp]
 800644c:	edd4 9a00 	vldr	s19, [r4]
 8006450:	ed94 7a05 	vldr	s14, [r4, #20]
 8006454:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
 8006458:	ee67 9aa9 	vmul.f32	s19, s15, s19
 800645c:	4610      	mov	r0, r2
 800645e:	4619      	mov	r1, r3
 8006460:	ee27 9a89 	vmul.f32	s18, s15, s18
 8006464:	ee79 9a87 	vadd.f32	s19, s19, s14
 8006468:	f001 fb46 	bl	8007af8 <__aeabi_dmul>
 800646c:	f001 fe3c 	bl	80080e8 <__aeabi_d2f>
 8006470:	ee07 0a90 	vmov	s15, r0
 8006474:	ed94 7a0f 	vldr	s14, [r4, #60]	; 0x3c
 8006478:	ee79 7a27 	vadd.f32	s15, s18, s15
 800647c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8006480:	ee89 9aa7 	vdiv.f32	s18, s19, s15
 8006484:	e7a9      	b.n	80063da <bsec_SensorHeatCompensator_doStep+0x56>
 8006486:	ed90 9a18 	vldr	s18, [r0, #96]	; 0x60
 800648a:	e7a6      	b.n	80063da <bsec_SensorHeatCompensator_doStep+0x56>
 800648c:	f3af 8000 	nop.w
 8006490:	00000000 	.word	0x00000000
 8006494:	41cdcd65 	.word	0x41cdcd65
 8006498:	00000000 	.word	0x00000000

0800649c <bsec_SensorHeatCompensator_getConfiguration>:
 800649c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80064a0:	b084      	sub	sp, #16
 80064a2:	4607      	mov	r7, r0
 80064a4:	4690      	mov	r8, r2
 80064a6:	7800      	ldrb	r0, [r0, #0]
 80064a8:	2405      	movs	r4, #5
 80064aa:	f10d 0207 	add.w	r2, sp, #7
 80064ae:	460d      	mov	r5, r1
 80064b0:	f88d 4007 	strb.w	r4, [sp, #7]
 80064b4:	f000 fb1a 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 80064b8:	f89d 6007 	ldrb.w	r6, [sp, #7]
 80064bc:	9003      	str	r0, [sp, #12]
 80064be:	b336      	cbz	r6, 800650e <bsec_SensorHeatCompensator_getConfiguration+0x72>
 80064c0:	2401      	movs	r4, #1
 80064c2:	f107 0a40 	add.w	sl, r7, #64	; 0x40
 80064c6:	f107 092c 	add.w	r9, r7, #44	; 0x2c
 80064ca:	b2e3      	uxtb	r3, r4
 80064cc:	3b01      	subs	r3, #1
 80064ce:	2b04      	cmp	r3, #4
 80064d0:	d80b      	bhi.n	80064ea <bsec_SensorHeatCompensator_getConfiguration+0x4e>
 80064d2:	e8df f003 	tbb	[pc, r3]
 80064d6:	103c      	.short	0x103c
 80064d8:	2e35      	.short	0x2e35
 80064da:	03          	.byte	0x03
 80064db:	00          	.byte	0x00
 80064dc:	ed97 0a18 	vldr	s0, [r7, #96]	; 0x60
 80064e0:	aa03      	add	r2, sp, #12
 80064e2:	4641      	mov	r1, r8
 80064e4:	4628      	mov	r0, r5
 80064e6:	f7fc ff17 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 80064ea:	42a6      	cmp	r6, r4
 80064ec:	f104 0301 	add.w	r3, r4, #1
 80064f0:	d00c      	beq.n	800650c <bsec_SensorHeatCompensator_getConfiguration+0x70>
 80064f2:	461c      	mov	r4, r3
 80064f4:	e7e9      	b.n	80064ca <bsec_SensorHeatCompensator_getConfiguration+0x2e>
 80064f6:	ab03      	add	r3, sp, #12
 80064f8:	4642      	mov	r2, r8
 80064fa:	4629      	mov	r1, r5
 80064fc:	f107 0018 	add.w	r0, r7, #24
 8006500:	f7fd f962 	bl	80037c8 <bsec_o_Entity_serializeAndAdd>
 8006504:	42a6      	cmp	r6, r4
 8006506:	f104 0301 	add.w	r3, r4, #1
 800650a:	d1f2      	bne.n	80064f2 <bsec_SensorHeatCompensator_getConfiguration+0x56>
 800650c:	9803      	ldr	r0, [sp, #12]
 800650e:	f8ad 000a 	strh.w	r0, [sp, #10]
 8006512:	2202      	movs	r2, #2
 8006514:	f10d 010a 	add.w	r1, sp, #10
 8006518:	a802      	add	r0, sp, #8
 800651a:	f025 fde1 	bl	802c0e0 <memcpy>
 800651e:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8006522:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8006526:	9803      	ldr	r0, [sp, #12]
 8006528:	702a      	strb	r2, [r5, #0]
 800652a:	706b      	strb	r3, [r5, #1]
 800652c:	b004      	add	sp, #16
 800652e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006532:	ab03      	add	r3, sp, #12
 8006534:	4642      	mov	r2, r8
 8006536:	4629      	mov	r1, r5
 8006538:	4650      	mov	r0, sl
 800653a:	f7fd f945 	bl	80037c8 <bsec_o_Entity_serializeAndAdd>
 800653e:	e7d4      	b.n	80064ea <bsec_SensorHeatCompensator_getConfiguration+0x4e>
 8006540:	ab03      	add	r3, sp, #12
 8006542:	4642      	mov	r2, r8
 8006544:	4629      	mov	r1, r5
 8006546:	4648      	mov	r0, r9
 8006548:	f7fd f93e 	bl	80037c8 <bsec_o_Entity_serializeAndAdd>
 800654c:	e7cd      	b.n	80064ea <bsec_SensorHeatCompensator_getConfiguration+0x4e>
 800654e:	ab03      	add	r3, sp, #12
 8006550:	4642      	mov	r2, r8
 8006552:	4629      	mov	r1, r5
 8006554:	1d38      	adds	r0, r7, #4
 8006556:	f7fd f937 	bl	80037c8 <bsec_o_Entity_serializeAndAdd>
 800655a:	e7c6      	b.n	80064ea <bsec_SensorHeatCompensator_getConfiguration+0x4e>

0800655c <bsec_SensorHeatCompensator_getState>:
 800655c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006560:	b087      	sub	sp, #28
 8006562:	4680      	mov	r8, r0
 8006564:	4691      	mov	r9, r2
 8006566:	7800      	ldrb	r0, [r0, #0]
 8006568:	2401      	movs	r4, #1
 800656a:	f10d 020f 	add.w	r2, sp, #15
 800656e:	460e      	mov	r6, r1
 8006570:	f88d 400f 	strb.w	r4, [sp, #15]
 8006574:	f000 faba 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 8006578:	f89d 500f 	ldrb.w	r5, [sp, #15]
 800657c:	9005      	str	r0, [sp, #20]
 800657e:	b135      	cbz	r5, 800658e <bsec_SensorHeatCompensator_getState+0x32>
 8006580:	2400      	movs	r4, #0
 8006582:	af05      	add	r7, sp, #20
 8006584:	b1ac      	cbz	r4, 80065b2 <bsec_SensorHeatCompensator_getState+0x56>
 8006586:	3401      	adds	r4, #1
 8006588:	42a5      	cmp	r5, r4
 800658a:	d1fb      	bne.n	8006584 <bsec_SensorHeatCompensator_getState+0x28>
 800658c:	9805      	ldr	r0, [sp, #20]
 800658e:	f8ad 0012 	strh.w	r0, [sp, #18]
 8006592:	2202      	movs	r2, #2
 8006594:	f10d 0112 	add.w	r1, sp, #18
 8006598:	a804      	add	r0, sp, #16
 800659a:	f025 fda1 	bl	802c0e0 <memcpy>
 800659e:	f89d 2010 	ldrb.w	r2, [sp, #16]
 80065a2:	f89d 3011 	ldrb.w	r3, [sp, #17]
 80065a6:	9805      	ldr	r0, [sp, #20]
 80065a8:	7032      	strb	r2, [r6, #0]
 80065aa:	7073      	strb	r3, [r6, #1]
 80065ac:	b007      	add	sp, #28
 80065ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80065b2:	9700      	str	r7, [sp, #0]
 80065b4:	e9d8 0116 	ldrd	r0, r1, [r8, #88]	; 0x58
 80065b8:	464b      	mov	r3, r9
 80065ba:	4632      	mov	r2, r6
 80065bc:	f7fc ff22 	bl	8003404 <bsec_g_Entity_serializeAndAdd>
 80065c0:	e7e1      	b.n	8006586 <bsec_SensorHeatCompensator_getState+0x2a>
 80065c2:	bf00      	nop

080065c4 <bsec_SensorHeatCompensator_setState>:
 80065c4:	b570      	push	{r4, r5, r6, lr}
 80065c6:	b086      	sub	sp, #24
 80065c8:	ab04      	add	r3, sp, #16
 80065ca:	ae05      	add	r6, sp, #20
 80065cc:	4604      	mov	r4, r0
 80065ce:	7800      	ldrb	r0, [r0, #0]
 80065d0:	e9cd 3600 	strd	r3, r6, [sp]
 80065d4:	f10d 030f 	add.w	r3, sp, #15
 80065d8:	460d      	mov	r5, r1
 80065da:	f000 fa59 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80065de:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80065e2:	b108      	cbz	r0, 80065e8 <bsec_SensorHeatCompensator_setState+0x24>
 80065e4:	b006      	add	sp, #24
 80065e6:	bd70      	pop	{r4, r5, r6, pc}
 80065e8:	4631      	mov	r1, r6
 80065ea:	4628      	mov	r0, r5
 80065ec:	f7fc feee 	bl	80033cc <bsec_g_Entity_parseAndDeserialize>
 80065f0:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
 80065f4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80065f8:	b006      	add	sp, #24
 80065fa:	bd70      	pop	{r4, r5, r6, pc}

080065fc <bsec_SensorStatusTracker_SensorStatusTracker>:
 80065fc:	b430      	push	{r4, r5}
 80065fe:	4c0a      	ldr	r4, [pc, #40]	; (8006628 <bsec_SensorStatusTracker_SensorStatusTracker+0x2c>)
 8006600:	61c4      	str	r4, [r0, #28]
 8006602:	2505      	movs	r5, #5
 8006604:	2464      	movs	r4, #100	; 0x64
 8006606:	2200      	movs	r2, #0
 8006608:	4908      	ldr	r1, [pc, #32]	; (800662c <bsec_SensorStatusTracker_SensorStatusTracker+0x30>)
 800660a:	7005      	strb	r5, [r0, #0]
 800660c:	6284      	str	r4, [r0, #40]	; 0x28
 800660e:	2500      	movs	r5, #0
 8006610:	2400      	movs	r4, #0
 8006612:	e9c0 4502 	strd	r4, r5, [r0, #8]
 8006616:	e9c0 4508 	strd	r4, r5, [r0, #32]
 800661a:	62c1      	str	r1, [r0, #44]	; 0x2c
 800661c:	bc30      	pop	{r4, r5}
 800661e:	6102      	str	r2, [r0, #16]
 8006620:	6142      	str	r2, [r0, #20]
 8006622:	6182      	str	r2, [r0, #24]
 8006624:	6302      	str	r2, [r0, #48]	; 0x30
 8006626:	4770      	bx	lr
 8006628:	538bb2c9 	.word	0x538bb2c9
 800662c:	561d2923 	.word	0x561d2923

08006630 <bsec_SensorStatusTracker_configure>:
 8006630:	b570      	push	{r4, r5, r6, lr}
 8006632:	b086      	sub	sp, #24
 8006634:	ab04      	add	r3, sp, #16
 8006636:	ae05      	add	r6, sp, #20
 8006638:	4604      	mov	r4, r0
 800663a:	7800      	ldrb	r0, [r0, #0]
 800663c:	e9cd 3600 	strd	r3, r6, [sp]
 8006640:	f10d 030f 	add.w	r3, sp, #15
 8006644:	460d      	mov	r5, r1
 8006646:	f000 fa23 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 800664a:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 800664e:	b108      	cbz	r0, 8006654 <bsec_SensorStatusTracker_configure+0x24>
 8006650:	b006      	add	sp, #24
 8006652:	bd70      	pop	{r4, r5, r6, pc}
 8006654:	4631      	mov	r1, r6
 8006656:	4628      	mov	r0, r5
 8006658:	f7fc fe40 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 800665c:	4631      	mov	r1, r6
 800665e:	ed84 0a06 	vstr	s0, [r4, #24]
 8006662:	4628      	mov	r0, r5
 8006664:	f7fd f8dc 	bl	8003820 <bsec_p_Entity_parseAndDeserialize>
 8006668:	4631      	mov	r1, r6
 800666a:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
 800666e:	4628      	mov	r0, r5
 8006670:	f7fc fe34 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8006674:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8006678:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
 800667c:	b006      	add	sp, #24
 800667e:	bd70      	pop	{r4, r5, r6, pc}

08006680 <bsec_SensorStatusTracker_doStep>:
 8006680:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006684:	4604      	mov	r4, r0
 8006686:	e9d0 0102 	ldrd	r0, r1, [r0, #8]
 800668a:	4616      	mov	r6, r2
 800668c:	461f      	mov	r7, r3
 800668e:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 8006692:	ebb6 0800 	subs.w	r8, r6, r0
 8006696:	eb67 0901 	sbc.w	r9, r7, r1
 800669a:	4542      	cmp	r2, r8
 800669c:	eb73 0309 	sbcs.w	r3, r3, r9
 80066a0:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80066a2:	db04      	blt.n	80066ae <bsec_SensorStatusTracker_doStep+0x2e>
 80066a4:	4286      	cmp	r6, r0
 80066a6:	eb77 0301 	sbcs.w	r3, r7, r1
 80066aa:	f280 8083 	bge.w	80067b4 <bsec_SensorStatusTracker_doStep+0x134>
 80066ae:	2300      	movs	r3, #0
 80066b0:	f04f 0900 	mov.w	r9, #0
 80066b4:	6123      	str	r3, [r4, #16]
 80066b6:	f884 902a 	strb.w	r9, [r4, #42]	; 0x2a
 80066ba:	e9c4 6702 	strd	r6, r7, [r4, #8]
 80066be:	f894 8029 	ldrb.w	r8, [r4, #41]	; 0x29
 80066c2:	f1b8 0f00 	cmp.w	r8, #0
 80066c6:	d11a      	bne.n	80066fe <bsec_SensorStatusTracker_doStep+0x7e>
 80066c8:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 80066cc:	1a30      	subs	r0, r6, r0
 80066ce:	eb67 0101 	sbc.w	r1, r7, r1
 80066d2:	f001 fe29 	bl	8008328 <__aeabi_l2f>
 80066d6:	edd4 7a05 	vldr	s15, [r4, #20]
 80066da:	ed94 7a06 	vldr	s14, [r4, #24]
 80066de:	ee06 0a90 	vmov	s13, r0
 80066e2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80066e6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80066ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80066ee:	bfa8      	it	ge
 80066f0:	f04f 0801 	movge.w	r8, #1
 80066f4:	edc4 7a05 	vstr	s15, [r4, #20]
 80066f8:	bfa8      	it	ge
 80066fa:	f884 8029 	strbge.w	r8, [r4, #41]	; 0x29
 80066fe:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 8006702:	b9cb      	cbnz	r3, 8006738 <bsec_SensorStatusTracker_doStep+0xb8>
 8006704:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8006708:	1a30      	subs	r0, r6, r0
 800670a:	eb67 0101 	sbc.w	r1, r7, r1
 800670e:	f001 fe0b 	bl	8008328 <__aeabi_l2f>
 8006712:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8006716:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 800671a:	ee06 0a90 	vmov	s13, r0
 800671e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8006722:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006726:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800672a:	bfa8      	it	ge
 800672c:	2301      	movge	r3, #1
 800672e:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
 8006732:	bfa8      	it	ge
 8006734:	f884 302b 	strbge.w	r3, [r4, #43]	; 0x2b
 8006738:	f1b9 0f00 	cmp.w	r9, #0
 800673c:	d119      	bne.n	8006772 <bsec_SensorStatusTracker_doStep+0xf2>
 800673e:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8006742:	1a30      	subs	r0, r6, r0
 8006744:	eb67 0101 	sbc.w	r1, r7, r1
 8006748:	f001 fdee 	bl	8008328 <__aeabi_l2f>
 800674c:	edd4 7a04 	vldr	s15, [r4, #16]
 8006750:	ed94 7a07 	vldr	s14, [r4, #28]
 8006754:	ee06 0a90 	vmov	s13, r0
 8006758:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800675c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006760:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006764:	bfa8      	it	ge
 8006766:	2301      	movge	r3, #1
 8006768:	edc4 7a04 	vstr	s15, [r4, #16]
 800676c:	bfa8      	it	ge
 800676e:	f884 302a 	strbge.w	r3, [r4, #42]	; 0x2a
 8006772:	2e01      	cmp	r6, #1
 8006774:	f177 0300 	sbcs.w	r3, r7, #0
 8006778:	9b08      	ldr	r3, [sp, #32]
 800677a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800677c:	bfbc      	itt	lt
 800677e:	2601      	movlt	r6, #1
 8006780:	2700      	movlt	r7, #0
 8006782:	e9c4 6702 	strd	r6, r7, [r4, #8]
 8006786:	f883 8000 	strb.w	r8, [r3]
 800678a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800678e:	702b      	strb	r3, [r5, #0]
 8006790:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 8006794:	7013      	strb	r3, [r2, #0]
 8006796:	782b      	ldrb	r3, [r5, #0]
 8006798:	b933      	cbnz	r3, 80067a8 <bsec_SensorStatusTracker_doStep+0x128>
 800679a:	edd4 7a07 	vldr	s15, [r4, #28]
 800679e:	eef5 7a40 	vcmp.f32	s15, #0.0
 80067a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80067a6:	d10c      	bne.n	80067c2 <bsec_SensorStatusTracker_doStep+0x142>
 80067a8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80067aa:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80067ae:	6013      	str	r3, [r2, #0]
 80067b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80067b4:	ea50 0301 	orrs.w	r3, r0, r1
 80067b8:	f894 902a 	ldrb.w	r9, [r4, #42]	; 0x2a
 80067bc:	f47f af7f 	bne.w	80066be <bsec_SensorStatusTracker_doStep+0x3e>
 80067c0:	e77b      	b.n	80066ba <bsec_SensorStatusTracker_doStep+0x3a>
 80067c2:	edd4 6a04 	vldr	s13, [r4, #16]
 80067c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80067c8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80067cc:	ed83 7a00 	vstr	s14, [r3]
 80067d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080067d4 <bsec_SensorStatusTracker_getConfiguration>:
 80067d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80067d8:	b084      	sub	sp, #16
 80067da:	4607      	mov	r7, r0
 80067dc:	4690      	mov	r8, r2
 80067de:	7800      	ldrb	r0, [r0, #0]
 80067e0:	2403      	movs	r4, #3
 80067e2:	f10d 0207 	add.w	r2, sp, #7
 80067e6:	460d      	mov	r5, r1
 80067e8:	f88d 4007 	strb.w	r4, [sp, #7]
 80067ec:	f000 f97e 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 80067f0:	f89d 6007 	ldrb.w	r6, [sp, #7]
 80067f4:	9003      	str	r0, [sp, #12]
 80067f6:	b1ce      	cbz	r6, 800682c <bsec_SensorStatusTracker_getConfiguration+0x58>
 80067f8:	2401      	movs	r4, #1
 80067fa:	e006      	b.n	800680a <bsec_SensorStatusTracker_getConfiguration+0x36>
 80067fc:	2b01      	cmp	r3, #1
 80067fe:	d02f      	beq.n	8006860 <bsec_SensorStatusTracker_getConfiguration+0x8c>
 8006800:	42a6      	cmp	r6, r4
 8006802:	f104 0301 	add.w	r3, r4, #1
 8006806:	d010      	beq.n	800682a <bsec_SensorStatusTracker_getConfiguration+0x56>
 8006808:	461c      	mov	r4, r3
 800680a:	b2e3      	uxtb	r3, r4
 800680c:	2b02      	cmp	r3, #2
 800680e:	d01f      	beq.n	8006850 <bsec_SensorStatusTracker_getConfiguration+0x7c>
 8006810:	2b03      	cmp	r3, #3
 8006812:	d1f3      	bne.n	80067fc <bsec_SensorStatusTracker_getConfiguration+0x28>
 8006814:	ed97 0a0b 	vldr	s0, [r7, #44]	; 0x2c
 8006818:	aa03      	add	r2, sp, #12
 800681a:	4641      	mov	r1, r8
 800681c:	4628      	mov	r0, r5
 800681e:	f7fc fd7b 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8006822:	42a6      	cmp	r6, r4
 8006824:	f104 0301 	add.w	r3, r4, #1
 8006828:	d1ee      	bne.n	8006808 <bsec_SensorStatusTracker_getConfiguration+0x34>
 800682a:	9803      	ldr	r0, [sp, #12]
 800682c:	f8ad 000a 	strh.w	r0, [sp, #10]
 8006830:	2202      	movs	r2, #2
 8006832:	f10d 010a 	add.w	r1, sp, #10
 8006836:	a802      	add	r0, sp, #8
 8006838:	f025 fc52 	bl	802c0e0 <memcpy>
 800683c:	f89d 2008 	ldrb.w	r2, [sp, #8]
 8006840:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8006844:	9803      	ldr	r0, [sp, #12]
 8006846:	702a      	strb	r2, [r5, #0]
 8006848:	706b      	strb	r3, [r5, #1]
 800684a:	b004      	add	sp, #16
 800684c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006850:	f997 0028 	ldrsb.w	r0, [r7, #40]	; 0x28
 8006854:	ab03      	add	r3, sp, #12
 8006856:	4642      	mov	r2, r8
 8006858:	4629      	mov	r1, r5
 800685a:	f7fc ff47 	bl	80036ec <bsec_m_Entity_serializeAndAdd>
 800685e:	e7cf      	b.n	8006800 <bsec_SensorStatusTracker_getConfiguration+0x2c>
 8006860:	ed97 0a06 	vldr	s0, [r7, #24]
 8006864:	aa03      	add	r2, sp, #12
 8006866:	4641      	mov	r1, r8
 8006868:	4628      	mov	r0, r5
 800686a:	f7fc fd55 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 800686e:	e7c7      	b.n	8006800 <bsec_SensorStatusTracker_getConfiguration+0x2c>

08006870 <bsec_SensorStatusTracker_getState>:
 8006870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006874:	b086      	sub	sp, #24
 8006876:	4606      	mov	r6, r0
 8006878:	4690      	mov	r8, r2
 800687a:	7800      	ldrb	r0, [r0, #0]
 800687c:	2407      	movs	r4, #7
 800687e:	f10d 020f 	add.w	r2, sp, #15
 8006882:	460d      	mov	r5, r1
 8006884:	f88d 400f 	strb.w	r4, [sp, #15]
 8006888:	f000 f930 	bl	8006aec <bsec_Serialization_prepareSerializationHeader>
 800688c:	f89d 700f 	ldrb.w	r7, [sp, #15]
 8006890:	9005      	str	r0, [sp, #20]
 8006892:	b31f      	cbz	r7, 80068dc <bsec_SensorStatusTracker_getState+0x6c>
 8006894:	2401      	movs	r4, #1
 8006896:	b2e3      	uxtb	r3, r4
 8006898:	3b01      	subs	r3, #1
 800689a:	2b06      	cmp	r3, #6
 800689c:	d80c      	bhi.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 800689e:	e8df f003 	tbb	[pc, r3]
 80068a2:	2f37      	.short	0x2f37
 80068a4:	11504048 	.word	0x11504048
 80068a8:	04          	.byte	0x04
 80068a9:	00          	.byte	0x00
 80068aa:	ed96 0a0c 	vldr	s0, [r6, #48]	; 0x30
 80068ae:	aa05      	add	r2, sp, #20
 80068b0:	4641      	mov	r1, r8
 80068b2:	4628      	mov	r0, r5
 80068b4:	f7fc fd30 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 80068b8:	42a7      	cmp	r7, r4
 80068ba:	f104 0301 	add.w	r3, r4, #1
 80068be:	d00c      	beq.n	80068da <bsec_SensorStatusTracker_getState+0x6a>
 80068c0:	461c      	mov	r4, r3
 80068c2:	e7e8      	b.n	8006896 <bsec_SensorStatusTracker_getState+0x26>
 80068c4:	ab05      	add	r3, sp, #20
 80068c6:	f896 002b 	ldrb.w	r0, [r6, #43]	; 0x2b
 80068ca:	4642      	mov	r2, r8
 80068cc:	4629      	mov	r1, r5
 80068ce:	f7fc fdd7 	bl	8003480 <bsec_h_Entity_serializeAndAdd>
 80068d2:	42a7      	cmp	r7, r4
 80068d4:	f104 0301 	add.w	r3, r4, #1
 80068d8:	d1f2      	bne.n	80068c0 <bsec_SensorStatusTracker_getState+0x50>
 80068da:	9805      	ldr	r0, [sp, #20]
 80068dc:	f8ad 0012 	strh.w	r0, [sp, #18]
 80068e0:	2202      	movs	r2, #2
 80068e2:	f10d 0112 	add.w	r1, sp, #18
 80068e6:	a804      	add	r0, sp, #16
 80068e8:	f025 fbfa 	bl	802c0e0 <memcpy>
 80068ec:	f89d 2010 	ldrb.w	r2, [sp, #16]
 80068f0:	f89d 3011 	ldrb.w	r3, [sp, #17]
 80068f4:	9805      	ldr	r0, [sp, #20]
 80068f6:	702a      	strb	r2, [r5, #0]
 80068f8:	706b      	strb	r3, [r5, #1]
 80068fa:	b006      	add	sp, #24
 80068fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006900:	ed96 0a05 	vldr	s0, [r6, #20]
 8006904:	aa05      	add	r2, sp, #20
 8006906:	4641      	mov	r1, r8
 8006908:	4628      	mov	r0, r5
 800690a:	f7fc fd05 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 800690e:	e7d3      	b.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 8006910:	ab05      	add	r3, sp, #20
 8006912:	9300      	str	r3, [sp, #0]
 8006914:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8006918:	4643      	mov	r3, r8
 800691a:	462a      	mov	r2, r5
 800691c:	f7fc fd72 	bl	8003404 <bsec_g_Entity_serializeAndAdd>
 8006920:	e7ca      	b.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 8006922:	f896 0029 	ldrb.w	r0, [r6, #41]	; 0x29
 8006926:	ab05      	add	r3, sp, #20
 8006928:	4642      	mov	r2, r8
 800692a:	4629      	mov	r1, r5
 800692c:	f7fc fda8 	bl	8003480 <bsec_h_Entity_serializeAndAdd>
 8006930:	e7c2      	b.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 8006932:	ed96 0a04 	vldr	s0, [r6, #16]
 8006936:	aa05      	add	r2, sp, #20
 8006938:	4641      	mov	r1, r8
 800693a:	4628      	mov	r0, r5
 800693c:	f7fc fcec 	bl	8003318 <bsec_e_Entity_serializeAndAdd>
 8006940:	e7ba      	b.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 8006942:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
 8006946:	ab05      	add	r3, sp, #20
 8006948:	4642      	mov	r2, r8
 800694a:	4629      	mov	r1, r5
 800694c:	f7fc fd98 	bl	8003480 <bsec_h_Entity_serializeAndAdd>
 8006950:	e7b2      	b.n	80068b8 <bsec_SensorStatusTracker_getState+0x48>
 8006952:	bf00      	nop

08006954 <bsec_SensorStatusTracker_updateInterfaceDependency>:
 8006954:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006958:	4299      	cmp	r1, r3
 800695a:	d020      	beq.n	800699e <bsec_SensorStatusTracker_updateInterfaceDependency+0x4a>
 800695c:	f990 2028 	ldrsb.w	r2, [r0, #40]	; 0x28
 8006960:	4b18      	ldr	r3, [pc, #96]	; (80069c4 <bsec_SensorStatusTracker_updateInterfaceDependency+0x70>)
 8006962:	fb01 f202 	mul.w	r2, r1, r2
 8006966:	eb02 0252 	add.w	r2, r2, r2, lsr #1
 800696a:	fba2 2303 	umull	r2, r3, r2, r3
 800696e:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
 8006972:	e9c0 2308 	strd	r2, r3, [r0, #32]
 8006976:	d01f      	beq.n	80069b8 <bsec_SensorStatusTracker_updateInterfaceDependency+0x64>
 8006978:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
 800697c:	d00a      	beq.n	8006994 <bsec_SensorStatusTracker_updateInterfaceDependency+0x40>
 800697e:	eddf 7a12 	vldr	s15, [pc, #72]	; 80069c8 <bsec_SensorStatusTracker_updateInterfaceDependency+0x74>
 8006982:	ed9f 7a12 	vldr	s14, [pc, #72]	; 80069cc <bsec_SensorStatusTracker_updateInterfaceDependency+0x78>
 8006986:	2964      	cmp	r1, #100	; 0x64
 8006988:	bf08      	it	eq
 800698a:	eef0 7a47 	vmoveq.f32	s15, s14
 800698e:	edc0 7a07 	vstr	s15, [r0, #28]
 8006992:	4770      	bx	lr
 8006994:	eddf 7a0e 	vldr	s15, [pc, #56]	; 80069d0 <bsec_SensorStatusTracker_updateInterfaceDependency+0x7c>
 8006998:	edc0 7a07 	vstr	s15, [r0, #28]
 800699c:	4770      	bx	lr
 800699e:	b410      	push	{r4}
 80069a0:	2100      	movs	r1, #0
 80069a2:	2400      	movs	r4, #0
 80069a4:	2200      	movs	r2, #0
 80069a6:	2300      	movs	r3, #0
 80069a8:	6104      	str	r4, [r0, #16]
 80069aa:	e9c0 2302 	strd	r2, r3, [r0, #8]
 80069ae:	f85d 4b04 	ldr.w	r4, [sp], #4
 80069b2:	f880 102a 	strb.w	r1, [r0, #42]	; 0x2a
 80069b6:	4770      	bx	lr
 80069b8:	eddf 7a04 	vldr	s15, [pc, #16]	; 80069cc <bsec_SensorStatusTracker_updateInterfaceDependency+0x78>
 80069bc:	edc0 7a07 	vstr	s15, [r0, #28]
 80069c0:	4770      	bx	lr
 80069c2:	bf00      	nop
 80069c4:	00989680 	.word	0x00989680
 80069c8:	538bb2c9 	.word	0x538bb2c9
 80069cc:	528bb2c9 	.word	0x528bb2c9
 80069d0:	515f8476 	.word	0x515f8476

080069d4 <bsec_b_SensorStatusTracker_setState>:
 80069d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80069d6:	b087      	sub	sp, #28
 80069d8:	ab04      	add	r3, sp, #16
 80069da:	af05      	add	r7, sp, #20
 80069dc:	4605      	mov	r5, r0
 80069de:	7800      	ldrb	r0, [r0, #0]
 80069e0:	e9cd 3700 	strd	r3, r7, [sp]
 80069e4:	f10d 030f 	add.w	r3, sp, #15
 80069e8:	460e      	mov	r6, r1
 80069ea:	f000 f851 	bl	8006a90 <bsec_Serialization_checkSerializationHeader>
 80069ee:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 80069f2:	b9c0      	cbnz	r0, 8006a26 <bsec_b_SensorStatusTracker_setState+0x52>
 80069f4:	2401      	movs	r4, #1
 80069f6:	b2e3      	uxtb	r3, r4
 80069f8:	3b01      	subs	r3, #1
 80069fa:	2b05      	cmp	r3, #5
 80069fc:	d840      	bhi.n	8006a80 <bsec_b_SensorStatusTracker_setState+0xac>
 80069fe:	e8df f003 	tbb	[pc, r3]
 8006a02:	3138      	.short	0x3138
 8006a04:	03141f2a 	.word	0x03141f2a
 8006a08:	9b05      	ldr	r3, [sp, #20]
 8006a0a:	5cf2      	ldrb	r2, [r6, r3]
 8006a0c:	3a00      	subs	r2, #0
 8006a0e:	f103 0301 	add.w	r3, r3, #1
 8006a12:	bf18      	it	ne
 8006a14:	2201      	movne	r2, #1
 8006a16:	f885 202b 	strb.w	r2, [r5, #43]	; 0x2b
 8006a1a:	9305      	str	r3, [sp, #20]
 8006a1c:	3401      	adds	r4, #1
 8006a1e:	2c08      	cmp	r4, #8
 8006a20:	d1e9      	bne.n	80069f6 <bsec_b_SensorStatusTracker_setState+0x22>
 8006a22:	f99d 000f 	ldrsb.w	r0, [sp, #15]
 8006a26:	b007      	add	sp, #28
 8006a28:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006a2a:	9b05      	ldr	r3, [sp, #20]
 8006a2c:	5cf2      	ldrb	r2, [r6, r3]
 8006a2e:	3a00      	subs	r2, #0
 8006a30:	f103 0301 	add.w	r3, r3, #1
 8006a34:	bf18      	it	ne
 8006a36:	2201      	movne	r2, #1
 8006a38:	f885 202a 	strb.w	r2, [r5, #42]	; 0x2a
 8006a3c:	9305      	str	r3, [sp, #20]
 8006a3e:	e7ed      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a40:	9b05      	ldr	r3, [sp, #20]
 8006a42:	5cf2      	ldrb	r2, [r6, r3]
 8006a44:	3a00      	subs	r2, #0
 8006a46:	f103 0301 	add.w	r3, r3, #1
 8006a4a:	bf18      	it	ne
 8006a4c:	2201      	movne	r2, #1
 8006a4e:	f885 2029 	strb.w	r2, [r5, #41]	; 0x29
 8006a52:	9305      	str	r3, [sp, #20]
 8006a54:	e7e2      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a56:	4639      	mov	r1, r7
 8006a58:	4630      	mov	r0, r6
 8006a5a:	f7fc fc3f 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8006a5e:	ed85 0a04 	vstr	s0, [r5, #16]
 8006a62:	e7db      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a64:	4639      	mov	r1, r7
 8006a66:	4630      	mov	r0, r6
 8006a68:	f7fc fc38 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8006a6c:	ed85 0a05 	vstr	s0, [r5, #20]
 8006a70:	e7d4      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a72:	4639      	mov	r1, r7
 8006a74:	4630      	mov	r0, r6
 8006a76:	f7fc fca9 	bl	80033cc <bsec_g_Entity_parseAndDeserialize>
 8006a7a:	e9c5 0102 	strd	r0, r1, [r5, #8]
 8006a7e:	e7cd      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a80:	4639      	mov	r1, r7
 8006a82:	4630      	mov	r0, r6
 8006a84:	f7fc fc2a 	bl	80032dc <bsec_e_Entity_parseAndDeserialize>
 8006a88:	ed85 0a0c 	vstr	s0, [r5, #48]	; 0x30
 8006a8c:	e7c6      	b.n	8006a1c <bsec_b_SensorStatusTracker_setState+0x48>
 8006a8e:	bf00      	nop

08006a90 <bsec_Serialization_checkSerializationHeader>:
 8006a90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006a94:	b082      	sub	sp, #8
 8006a96:	e9dd 7508 	ldrd	r7, r5, [sp, #32]
 8006a9a:	461c      	mov	r4, r3
 8006a9c:	2a03      	cmp	r2, #3
 8006a9e:	f04f 0300 	mov.w	r3, #0
 8006aa2:	602b      	str	r3, [r5, #0]
 8006aa4:	7023      	strb	r3, [r4, #0]
 8006aa6:	603b      	str	r3, [r7, #0]
 8006aa8:	d804      	bhi.n	8006ab4 <bsec_Serialization_checkSerializationHeader+0x24>
 8006aaa:	2398      	movs	r3, #152	; 0x98
 8006aac:	7023      	strb	r3, [r4, #0]
 8006aae:	b002      	add	sp, #8
 8006ab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006ab4:	2304      	movs	r3, #4
 8006ab6:	602b      	str	r3, [r5, #0]
 8006ab8:	780a      	ldrb	r2, [r1, #0]
 8006aba:	784b      	ldrb	r3, [r1, #1]
 8006abc:	f88d 2004 	strb.w	r2, [sp, #4]
 8006ac0:	4680      	mov	r8, r0
 8006ac2:	460e      	mov	r6, r1
 8006ac4:	2202      	movs	r2, #2
 8006ac6:	a901      	add	r1, sp, #4
 8006ac8:	f10d 0006 	add.w	r0, sp, #6
 8006acc:	f88d 3005 	strb.w	r3, [sp, #5]
 8006ad0:	f025 fb06 	bl	802c0e0 <memcpy>
 8006ad4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006ad8:	603b      	str	r3, [r7, #0]
 8006ada:	78b3      	ldrb	r3, [r6, #2]
 8006adc:	4543      	cmp	r3, r8
 8006ade:	bf1c      	itt	ne
 8006ae0:	239c      	movne	r3, #156	; 0x9c
 8006ae2:	7023      	strbne	r3, [r4, #0]
 8006ae4:	b002      	add	sp, #8
 8006ae6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006aea:	bf00      	nop

08006aec <bsec_Serialization_prepareSerializationHeader>:
 8006aec:	b410      	push	{r4}
 8006aee:	7814      	ldrb	r4, [r2, #0]
 8006af0:	b10c      	cbz	r4, 8006af6 <bsec_Serialization_prepareSerializationHeader+0xa>
 8006af2:	429c      	cmp	r4, r3
 8006af4:	d204      	bcs.n	8006b00 <bsec_Serialization_prepareSerializationHeader+0x14>
 8006af6:	2000      	movs	r0, #0
 8006af8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006afc:	7010      	strb	r0, [r2, #0]
 8006afe:	4770      	bx	lr
 8006b00:	7088      	strb	r0, [r1, #2]
 8006b02:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006b06:	2004      	movs	r0, #4
 8006b08:	4770      	bx	lr
 8006b0a:	bf00      	nop

08006b0c <bsec_any>:
 8006b0c:	f100 0334 	add.w	r3, r0, #52	; 0x34
 8006b10:	ecf0 7a01 	vldmia	r0!, {s15}
 8006b14:	eef5 7a40 	vcmp.f32	s15, #0.0
 8006b18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b1c:	d103      	bne.n	8006b26 <bsec_any+0x1a>
 8006b1e:	4298      	cmp	r0, r3
 8006b20:	d1f6      	bne.n	8006b10 <bsec_any+0x4>
 8006b22:	2000      	movs	r0, #0
 8006b24:	4770      	bx	lr
 8006b26:	2001      	movs	r0, #1
 8006b28:	4770      	bx	lr
 8006b2a:	bf00      	nop

08006b2c <bsec_rt_roundd>:
 8006b2c:	b538      	push	{r3, r4, r5, lr}
 8006b2e:	ec55 4b10 	vmov	r4, r5, d0
 8006b32:	f022 fc3d 	bl	80293b0 <fabs>
 8006b36:	4b19      	ldr	r3, [pc, #100]	; (8006b9c <bsec_rt_roundd+0x70>)
 8006b38:	ec51 0b10 	vmov	r0, r1, d0
 8006b3c:	2200      	movs	r2, #0
 8006b3e:	f001 fa4d 	bl	8007fdc <__aeabi_dcmplt>
 8006b42:	b178      	cbz	r0, 8006b64 <bsec_rt_roundd+0x38>
 8006b44:	4b16      	ldr	r3, [pc, #88]	; (8006ba0 <bsec_rt_roundd+0x74>)
 8006b46:	2200      	movs	r2, #0
 8006b48:	4620      	mov	r0, r4
 8006b4a:	4629      	mov	r1, r5
 8006b4c:	f001 fa5a 	bl	8008004 <__aeabi_dcmpge>
 8006b50:	b958      	cbnz	r0, 8006b6a <bsec_rt_roundd+0x3e>
 8006b52:	4b14      	ldr	r3, [pc, #80]	; (8006ba4 <bsec_rt_roundd+0x78>)
 8006b54:	2200      	movs	r2, #0
 8006b56:	4620      	mov	r0, r4
 8006b58:	4629      	mov	r1, r5
 8006b5a:	f001 fa5d 	bl	8008018 <__aeabi_dcmpgt>
 8006b5e:	b180      	cbz	r0, 8006b82 <bsec_rt_roundd+0x56>
 8006b60:	2400      	movs	r4, #0
 8006b62:	2500      	movs	r5, #0
 8006b64:	ec45 4b10 	vmov	d0, r4, r5
 8006b68:	bd38      	pop	{r3, r4, r5, pc}
 8006b6a:	4b0d      	ldr	r3, [pc, #52]	; (8006ba0 <bsec_rt_roundd+0x74>)
 8006b6c:	4620      	mov	r0, r4
 8006b6e:	4629      	mov	r1, r5
 8006b70:	2200      	movs	r2, #0
 8006b72:	f000 fe0b 	bl	800778c <__adddf3>
 8006b76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006b7a:	ec41 0b10 	vmov	d0, r0, r1
 8006b7e:	f022 bc23 	b.w	80293c8 <floor>
 8006b82:	4b07      	ldr	r3, [pc, #28]	; (8006ba0 <bsec_rt_roundd+0x74>)
 8006b84:	4620      	mov	r0, r4
 8006b86:	4629      	mov	r1, r5
 8006b88:	2200      	movs	r2, #0
 8006b8a:	f000 fdfd 	bl	8007788 <__aeabi_dsub>
 8006b8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006b92:	ec41 0b10 	vmov	d0, r0, r1
 8006b96:	f022 bb87 	b.w	80292a8 <ceil>
 8006b9a:	bf00      	nop
 8006b9c:	43300000 	.word	0x43300000
 8006ba0:	3fe00000 	.word	0x3fe00000
 8006ba4:	bfe00000 	.word	0xbfe00000

08006ba8 <bsec_convertHumidity>:
 8006ba8:	b508      	push	{r3, lr}
 8006baa:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8006bae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bb2:	ed2d 8b02 	vpush	{d8}
 8006bb6:	eef0 8a40 	vmov.f32	s17, s0
 8006bba:	eeb0 8a60 	vmov.f32	s16, s1
 8006bbe:	d439      	bmi.n	8006c34 <bsec_convertHumidity+0x8c>
 8006bc0:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8006c3c <bsec_convertHumidity+0x94>
 8006bc4:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8006bc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bcc:	dc2f      	bgt.n	8006c2e <bsec_convertHumidity+0x86>
 8006bce:	ee81 0a27 	vdiv.f32	s0, s2, s15
 8006bd2:	f022 fed7 	bl	8029984 <logf>
 8006bd6:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8006c40 <bsec_convertHumidity+0x98>
 8006bda:	eddf 7a1a 	vldr	s15, [pc, #104]	; 8006c44 <bsec_convertHumidity+0x9c>
 8006bde:	ee28 6aa7 	vmul.f32	s12, s17, s15
 8006be2:	ee78 8aa6 	vadd.f32	s17, s17, s13
 8006be6:	ee68 5a27 	vmul.f32	s11, s16, s15
 8006bea:	ee86 7a28 	vdiv.f32	s14, s12, s17
 8006bee:	ee38 8a26 	vadd.f32	s16, s16, s13
 8006bf2:	ee37 0a00 	vadd.f32	s0, s14, s0
 8006bf6:	ee85 6a88 	vdiv.f32	s12, s11, s16
 8006bfa:	ee60 5a26 	vmul.f32	s11, s0, s13
 8006bfe:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8006c02:	ee85 7a80 	vdiv.f32	s14, s11, s0
 8006c06:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006c0a:	ee37 7a26 	vadd.f32	s14, s14, s13
 8006c0e:	ee87 0a87 	vdiv.f32	s0, s15, s14
 8006c12:	ee30 0a46 	vsub.f32	s0, s0, s12
 8006c16:	f022 fe77 	bl	8029908 <expf>
 8006c1a:	ecbd 8b02 	vpop	{d8}
 8006c1e:	eddf 0a07 	vldr	s1, [pc, #28]	; 8006c3c <bsec_convertHumidity+0x94>
 8006c22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006c26:	ee20 0a20 	vmul.f32	s0, s0, s1
 8006c2a:	f022 bce4 	b.w	80295f6 <fminf>
 8006c2e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8006c32:	e7ce      	b.n	8006bd2 <bsec_convertHumidity+0x2a>
 8006c34:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8006c48 <bsec_convertHumidity+0xa0>
 8006c38:	e7cb      	b.n	8006bd2 <bsec_convertHumidity+0x2a>
 8006c3a:	bf00      	nop
 8006c3c:	42c80000 	.word	0x42c80000
 8006c40:	43731eb8 	.word	0x43731eb8
 8006c44:	418cf5c3 	.word	0x418cf5c3
 8006c48:	00000000 	.word	0x00000000

08006c4c <bsec_crcCcitt2>:
 8006c4c:	2900      	cmp	r1, #0
 8006c4e:	dd17      	ble.n	8006c80 <bsec_crcCcitt2+0x34>
 8006c50:	b430      	push	{r4, r5}
 8006c52:	3801      	subs	r0, #1
 8006c54:	4d0c      	ldr	r5, [pc, #48]	; (8006c88 <bsec_crcCcitt2+0x3c>)
 8006c56:	1844      	adds	r4, r0, r1
 8006c58:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006c5c:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 8006c60:	404b      	eors	r3, r1
 8006c62:	b2d9      	uxtb	r1, r3
 8006c64:	4284      	cmp	r4, r0
 8006c66:	f835 1011 	ldrh.w	r1, [r5, r1, lsl #1]
 8006c6a:	ea81 2313 	eor.w	r3, r1, r3, lsr #8
 8006c6e:	d1f5      	bne.n	8006c5c <bsec_crcCcitt2+0x10>
 8006c70:	43db      	mvns	r3, r3
 8006c72:	b2d9      	uxtb	r1, r3
 8006c74:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8006c78:	bc30      	pop	{r4, r5}
 8006c7a:	7011      	strb	r1, [r2, #0]
 8006c7c:	7053      	strb	r3, [r2, #1]
 8006c7e:	4770      	bx	lr
 8006c80:	2300      	movs	r3, #0
 8006c82:	7013      	strb	r3, [r2, #0]
 8006c84:	7053      	strb	r3, [r2, #1]
 8006c86:	4770      	bx	lr
 8006c88:	0802d6f0 	.word	0x0802d6f0

08006c8c <bsec_isequal>:
 8006c8c:	4299      	cmp	r1, r3
 8006c8e:	bf06      	itte	eq
 8006c90:	4290      	cmpeq	r0, r2
 8006c92:	2001      	moveq	r0, #1
 8006c94:	2000      	movne	r0, #0
 8006c96:	4770      	bx	lr

08006c98 <bsec_polyfit>:
 8006c98:	b570      	push	{r4, r5, r6, lr}
 8006c9a:	b090      	sub	sp, #64	; 0x40
 8006c9c:	6803      	ldr	r3, [r0, #0]
 8006c9e:	6846      	ldr	r6, [r0, #4]
 8006ca0:	930c      	str	r3, [sp, #48]	; 0x30
 8006ca2:	460d      	mov	r5, r1
 8006ca4:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8006ca8:	4614      	mov	r4, r2
 8006caa:	a902      	add	r1, sp, #8
 8006cac:	aa04      	add	r2, sp, #16
 8006cae:	a80c      	add	r0, sp, #48	; 0x30
 8006cb0:	930e      	str	r3, [sp, #56]	; 0x38
 8006cb2:	930f      	str	r3, [sp, #60]	; 0x3c
 8006cb4:	960d      	str	r6, [sp, #52]	; 0x34
 8006cb6:	f000 f881 	bl	8006dbc <bsec_xgeqp3>
 8006cba:	2602      	movs	r6, #2
 8006cbc:	4629      	mov	r1, r5
 8006cbe:	a808      	add	r0, sp, #32
 8006cc0:	ad06      	add	r5, sp, #24
 8006cc2:	2210      	movs	r2, #16
 8006cc4:	f025 fa0c 	bl	802c0e0 <memcpy>
 8006cc8:	ab08      	add	r3, sp, #32
 8006cca:	aa04      	add	r2, sp, #16
 8006ccc:	a902      	add	r1, sp, #8
 8006cce:	a80c      	add	r0, sp, #48	; 0x30
 8006cd0:	e9cd 6500 	strd	r6, r5, [sp]
 8006cd4:	f000 f808 	bl	8006ce8 <bsec_LSQFromQR>
 8006cd8:	4620      	mov	r0, r4
 8006cda:	4629      	mov	r1, r5
 8006cdc:	2208      	movs	r2, #8
 8006cde:	f025 f9ff 	bl	802c0e0 <memcpy>
 8006ce2:	b010      	add	sp, #64	; 0x40
 8006ce4:	bd70      	pop	{r4, r5, r6, pc}
 8006ce6:	bf00      	nop

08006ce8 <bsec_LSQFromQR>:
 8006ce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006cec:	b083      	sub	sp, #12
 8006cee:	2500      	movs	r5, #0
 8006cf0:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 8006cf4:	469a      	mov	sl, r3
 8006cf6:	460b      	mov	r3, r1
 8006cf8:	4693      	mov	fp, r2
 8006cfa:	f8c8 5000 	str.w	r5, [r8]
 8006cfe:	461a      	mov	r2, r3
 8006d00:	4651      	mov	r1, sl
 8006d02:	f8c8 5004 	str.w	r5, [r8, #4]
 8006d06:	f8cd b004 	str.w	fp, [sp, #4]
 8006d0a:	4606      	mov	r6, r0
 8006d0c:	f000 f868 	bl	8006de0 <bsec_xunormqr>
 8006d10:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006d12:	2b00      	cmp	r3, #0
 8006d14:	dd4e      	ble.n	8006db4 <bsec_LSQFromQR+0xcc>
 8006d16:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006d18:	f1ab 0704 	sub.w	r7, fp, #4
 8006d1c:	eb0a 09c3 	add.w	r9, sl, r3, lsl #3
 8006d20:	46bb      	mov	fp, r7
 8006d22:	f06f 4540 	mvn.w	r5, #3221225472	; 0xc0000000
 8006d26:	f85b 4f04 	ldr.w	r4, [fp, #4]!
 8006d2a:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 8006d2e:	f001 f9db 	bl	80080e8 <__aeabi_d2f>
 8006d32:	442c      	add	r4, r5
 8006d34:	eb08 0484 	add.w	r4, r8, r4, lsl #2
 8006d38:	45d1      	cmp	r9, sl
 8006d3a:	6020      	str	r0, [r4, #0]
 8006d3c:	d1f3      	bne.n	8006d26 <bsec_LSQFromQR+0x3e>
 8006d3e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006d40:	195a      	adds	r2, r3, r5
 8006d42:	eb03 0e43 	add.w	lr, r3, r3, lsl #1
 8006d46:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
 8006d4a:	9b01      	ldr	r3, [sp, #4]
 8006d4c:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
 8006d50:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8006d54:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8006d58:	f06f 4040 	mvn.w	r0, #3221225472	; 0xc0000000
 8006d5c:	f852 5904 	ldr.w	r5, [r2], #-4
 8006d60:	ed5e 7a03 	vldr	s15, [lr, #-12]
 8006d64:	3d01      	subs	r5, #1
 8006d66:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 8006d6a:	ed95 7a00 	vldr	s14, [r5]
 8006d6e:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8006d72:	edc5 6a00 	vstr	s13, [r5]
 8006d76:	f1bc 0f00 	cmp.w	ip, #0
 8006d7a:	d01b      	beq.n	8006db4 <bsec_LSQFromQR+0xcc>
 8006d7c:	eb06 048c 	add.w	r4, r6, ip, lsl #2
 8006d80:	4639      	mov	r1, r7
 8006d82:	e001      	b.n	8006d88 <bsec_LSQFromQR+0xa0>
 8006d84:	edd5 6a00 	vldr	s13, [r5]
 8006d88:	f851 3f04 	ldr.w	r3, [r1, #4]!
 8006d8c:	ecb4 7a01 	vldmia	r4!, {s14}
 8006d90:	4403      	add	r3, r0
 8006d92:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8006d96:	edd3 7a00 	vldr	s15, [r3]
 8006d9a:	ee27 7a26 	vmul.f32	s14, s14, s13
 8006d9e:	428a      	cmp	r2, r1
 8006da0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8006da4:	edc3 7a00 	vstr	s15, [r3]
 8006da8:	d1ec      	bne.n	8006d84 <bsec_LSQFromQR+0x9c>
 8006daa:	f1ae 0e0c 	sub.w	lr, lr, #12
 8006dae:	f1ac 0c02 	sub.w	ip, ip, #2
 8006db2:	e7d3      	b.n	8006d5c <bsec_LSQFromQR+0x74>
 8006db4:	b003      	add	sp, #12
 8006db6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006dba:	bf00      	nop

08006dbc <bsec_xgeqp3>:
 8006dbc:	b530      	push	{r4, r5, lr}
 8006dbe:	460c      	mov	r4, r1
 8006dc0:	b083      	sub	sp, #12
 8006dc2:	2302      	movs	r3, #2
 8006dc4:	2500      	movs	r5, #0
 8006dc6:	2101      	movs	r1, #1
 8006dc8:	9201      	str	r2, [sp, #4]
 8006dca:	9400      	str	r4, [sp, #0]
 8006dcc:	6011      	str	r1, [r2, #0]
 8006dce:	6025      	str	r5, [r4, #0]
 8006dd0:	6053      	str	r3, [r2, #4]
 8006dd2:	6065      	str	r5, [r4, #4]
 8006dd4:	461a      	mov	r2, r3
 8006dd6:	f000 f85d 	bl	8006e94 <bsec_qrpf>
 8006dda:	b003      	add	sp, #12
 8006ddc:	bd30      	pop	{r4, r5, pc}
 8006dde:	bf00      	nop

08006de0 <bsec_xunormqr>:
 8006de0:	b570      	push	{r4, r5, r6, lr}
 8006de2:	ed2d 8b04 	vpush	{d8-d9}
 8006de6:	ed92 8a00 	vldr	s16, [r2]
 8006dea:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8006dee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006df2:	4615      	mov	r5, r2
 8006df4:	460c      	mov	r4, r1
 8006df6:	d01a      	beq.n	8006e2e <bsec_xunormqr+0x4e>
 8006df8:	4606      	mov	r6, r0
 8006dfa:	e9d1 0100 	ldrd	r0, r1, [r1]
 8006dfe:	f001 f973 	bl	80080e8 <__aeabi_d2f>
 8006e02:	4603      	mov	r3, r0
 8006e04:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8006e08:	ee09 3a10 	vmov	s18, r3
 8006e0c:	f001 f96c 	bl	80080e8 <__aeabi_d2f>
 8006e10:	edd6 9a01 	vldr	s19, [r6, #4]
 8006e14:	ee08 0a90 	vmov	s17, r0
 8006e18:	ee69 7aa8 	vmul.f32	s15, s19, s17
 8006e1c:	ee77 7a89 	vadd.f32	s15, s15, s18
 8006e20:	ee28 8a27 	vmul.f32	s16, s16, s15
 8006e24:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8006e28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e2c:	d11e      	bne.n	8006e6c <bsec_xunormqr+0x8c>
 8006e2e:	ed95 8a01 	vldr	s16, [r5, #4]
 8006e32:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8006e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e3a:	d014      	beq.n	8006e66 <bsec_xunormqr+0x86>
 8006e3c:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8006e40:	f001 f952 	bl	80080e8 <__aeabi_d2f>
 8006e44:	ee07 0a90 	vmov	s15, r0
 8006e48:	ee28 8a27 	vmul.f32	s16, s16, s15
 8006e4c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8006e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e54:	d007      	beq.n	8006e66 <bsec_xunormqr+0x86>
 8006e56:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8006e5a:	ee17 0a90 	vmov	r0, s15
 8006e5e:	f000 fdf3 	bl	8007a48 <__aeabi_f2d>
 8006e62:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8006e66:	ecbd 8b04 	vpop	{d8-d9}
 8006e6a:	bd70      	pop	{r4, r5, r6, pc}
 8006e6c:	ee79 7a48 	vsub.f32	s15, s18, s16
 8006e70:	ee28 8a29 	vmul.f32	s16, s16, s19
 8006e74:	ee17 0a90 	vmov	r0, s15
 8006e78:	f000 fde6 	bl	8007a48 <__aeabi_f2d>
 8006e7c:	ee78 7ac8 	vsub.f32	s15, s17, s16
 8006e80:	e9c4 0100 	strd	r0, r1, [r4]
 8006e84:	ee17 0a90 	vmov	r0, s15
 8006e88:	f000 fdde 	bl	8007a48 <__aeabi_f2d>
 8006e8c:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8006e90:	e7cd      	b.n	8006e2e <bsec_xunormqr+0x4e>
 8006e92:	bf00      	nop

08006e94 <bsec_qrpf>:
 8006e94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006e98:	ed2d 8b04 	vpush	{d8-d9}
 8006e9c:	461d      	mov	r5, r3
 8006e9e:	b093      	sub	sp, #76	; 0x4c
 8006ea0:	42aa      	cmp	r2, r5
 8006ea2:	f04f 0400 	mov.w	r4, #0
 8006ea6:	4613      	mov	r3, r2
 8006ea8:	bfa8      	it	ge
 8006eaa:	462b      	movge	r3, r5
 8006eac:	2d00      	cmp	r5, #0
 8006eae:	940c      	str	r4, [sp, #48]	; 0x30
 8006eb0:	4617      	mov	r7, r2
 8006eb2:	4680      	mov	r8, r0
 8006eb4:	468b      	mov	fp, r1
 8006eb6:	9305      	str	r3, [sp, #20]
 8006eb8:	940e      	str	r4, [sp, #56]	; 0x38
 8006eba:	9410      	str	r4, [sp, #64]	; 0x40
 8006ebc:	940d      	str	r4, [sp, #52]	; 0x34
 8006ebe:	940f      	str	r4, [sp, #60]	; 0x3c
 8006ec0:	9411      	str	r4, [sp, #68]	; 0x44
 8006ec2:	dd14      	ble.n	8006eee <bsec_qrpf+0x5a>
 8006ec4:	468a      	mov	sl, r1
 8006ec6:	f10d 0938 	add.w	r9, sp, #56	; 0x38
 8006eca:	ac10      	add	r4, sp, #64	; 0x40
 8006ecc:	eb01 0645 	add.w	r6, r1, r5, lsl #1
 8006ed0:	4652      	mov	r2, sl
 8006ed2:	4641      	mov	r1, r8
 8006ed4:	4638      	mov	r0, r7
 8006ed6:	f000 fbe1 	bl	800769c <bsec_xnrm2>
 8006eda:	f10a 0a02 	add.w	sl, sl, #2
 8006ede:	45b2      	cmp	sl, r6
 8006ee0:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
 8006ee4:	eca9 0a01 	vstmia	r9!, {s0}
 8006ee8:	eca4 0a01 	vstmia	r4!, {s0}
 8006eec:	d1f0      	bne.n	8006ed0 <bsec_qrpf+0x3c>
 8006eee:	9b05      	ldr	r3, [sp, #20]
 8006ef0:	2b00      	cmp	r3, #0
 8006ef2:	dd6a      	ble.n	8006fca <bsec_qrpf+0x136>
 8006ef4:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8006ef6:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 80070e0 <bsec_qrpf+0x24c>
 8006efa:	eddf 8a7a 	vldr	s17, [pc, #488]	; 80070e4 <bsec_qrpf+0x250>
 8006efe:	f8cd b018 	str.w	fp, [sp, #24]
 8006f02:	eb08 038b 	add.w	r3, r8, fp, lsl #2
 8006f06:	f04f 0a00 	mov.w	sl, #0
 8006f0a:	ee09 8a10 	vmov	s18, r8
 8006f0e:	e9cd 2b03 	strd	r2, fp, [sp, #12]
 8006f12:	9308      	str	r3, [sp, #32]
 8006f14:	4654      	mov	r4, sl
 8006f16:	469b      	mov	fp, r3
 8006f18:	9b06      	ldr	r3, [sp, #24]
 8006f1a:	46a1      	mov	r9, r4
 8006f1c:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 8006f20:	1b39      	subs	r1, r7, r4
 8006f22:	f104 0802 	add.w	r8, r4, #2
 8006f26:	3401      	adds	r4, #1
 8006f28:	9107      	str	r1, [sp, #28]
 8006f2a:	4622      	mov	r2, r4
 8006f2c:	eba5 0009 	sub.w	r0, r5, r9
 8006f30:	a90e      	add	r1, sp, #56	; 0x38
 8006f32:	9309      	str	r3, [sp, #36]	; 0x24
 8006f34:	f000 faf0 	bl	8007518 <bsec_ixamax>
 8006f38:	4448      	add	r0, r9
 8006f3a:	1e46      	subs	r6, r0, #1
 8006f3c:	454e      	cmp	r6, r9
 8006f3e:	d021      	beq.n	8006f84 <bsec_qrpf+0xf0>
 8006f40:	9a06      	ldr	r2, [sp, #24]
 8006f42:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006f44:	eb02 0246 	add.w	r2, r2, r6, lsl #1
 8006f48:	ee19 1a10 	vmov	r1, s18
 8006f4c:	4638      	mov	r0, r7
 8006f4e:	f000 fbf7 	bl	8007740 <bsec_xswap>
 8006f52:	ab0e      	add	r3, sp, #56	; 0x38
 8006f54:	4453      	add	r3, sl
 8006f56:	9821      	ldr	r0, [sp, #132]	; 0x84
 8006f58:	681a      	ldr	r2, [r3, #0]
 8006f5a:	9921      	ldr	r1, [sp, #132]	; 0x84
 8006f5c:	ab12      	add	r3, sp, #72	; 0x48
 8006f5e:	4453      	add	r3, sl
 8006f60:	f851 1026 	ldr.w	r1, [r1, r6, lsl #2]
 8006f64:	f853 cc08 	ldr.w	ip, [r3, #-8]
 8006f68:	f850 300a 	ldr.w	r3, [r0, sl]
 8006f6c:	f840 3026 	str.w	r3, [r0, r6, lsl #2]
 8006f70:	a812      	add	r0, sp, #72	; 0x48
 8006f72:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8006f76:	9821      	ldr	r0, [sp, #132]	; 0x84
 8006f78:	f846 2c10 	str.w	r2, [r6, #-16]
 8006f7c:	f840 100a 	str.w	r1, [r0, sl]
 8006f80:	f846 cc08 	str.w	ip, [r6, #-8]
 8006f84:	42bc      	cmp	r4, r7
 8006f86:	db2f      	blt.n	8006fe8 <bsec_qrpf+0x154>
 8006f88:	9b03      	ldr	r3, [sp, #12]
 8006f8a:	42ac      	cmp	r4, r5
 8006f8c:	ed83 8a00 	vstr	s16, [r3]
 8006f90:	db3d      	blt.n	800700e <bsec_qrpf+0x17a>
 8006f92:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
 8006f96:	9b08      	ldr	r3, [sp, #32]
 8006f98:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
 8006f9c:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 8006fa0:	2300      	movs	r3, #0
 8006fa2:	45a8      	cmp	r8, r5
 8006fa4:	f04f 0803 	mov.w	r8, #3
 8006fa8:	dd14      	ble.n	8006fd4 <bsec_qrpf+0x140>
 8006faa:	b10b      	cbz	r3, 8006fb0 <bsec_qrpf+0x11c>
 8006fac:	ed8d 7a0b 	vstr	s14, [sp, #44]	; 0x2c
 8006fb0:	9b03      	ldr	r3, [sp, #12]
 8006fb2:	3304      	adds	r3, #4
 8006fb4:	9303      	str	r3, [sp, #12]
 8006fb6:	9b04      	ldr	r3, [sp, #16]
 8006fb8:	3303      	adds	r3, #3
 8006fba:	9304      	str	r3, [sp, #16]
 8006fbc:	9b05      	ldr	r3, [sp, #20]
 8006fbe:	429c      	cmp	r4, r3
 8006fc0:	f10b 0b0c 	add.w	fp, fp, #12
 8006fc4:	f10a 0a04 	add.w	sl, sl, #4
 8006fc8:	d1a6      	bne.n	8006f18 <bsec_qrpf+0x84>
 8006fca:	b013      	add	sp, #76	; 0x4c
 8006fcc:	ecbd 8b04 	vpop	{d8-d9}
 8006fd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006fd4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8006fd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006fdc:	f04f 0301 	mov.w	r3, #1
 8006fe0:	d132      	bne.n	8007048 <bsec_qrpf+0x1b4>
 8006fe2:	eeb0 7a67 	vmov.f32	s14, s15
 8006fe6:	e7dc      	b.n	8006fa2 <bsec_qrpf+0x10e>
 8006fe8:	9b04      	ldr	r3, [sp, #16]
 8006fea:	f85b 6c04 	ldr.w	r6, [fp, #-4]
 8006fee:	9807      	ldr	r0, [sp, #28]
 8006ff0:	960b      	str	r6, [sp, #44]	; 0x2c
 8006ff2:	ee19 2a10 	vmov	r2, s18
 8006ff6:	3301      	adds	r3, #1
 8006ff8:	a90b      	add	r1, sp, #44	; 0x2c
 8006ffa:	f000 f91b 	bl	8007234 <bsec_xzlarfg>
 8006ffe:	9a03      	ldr	r2, [sp, #12]
 8007000:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007002:	ed82 0a00 	vstr	s0, [r2]
 8007006:	42ac      	cmp	r4, r5
 8007008:	f84b 3c04 	str.w	r3, [fp, #-4]
 800700c:	dac1      	bge.n	8006f92 <bsec_qrpf+0xfe>
 800700e:	9904      	ldr	r1, [sp, #16]
 8007010:	f85b 6c04 	ldr.w	r6, [fp, #-4]
 8007014:	9807      	ldr	r0, [sp, #28]
 8007016:	960b      	str	r6, [sp, #44]	; 0x2c
 8007018:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800701c:	f84b 3c04 	str.w	r3, [fp, #-4]
 8007020:	9b03      	ldr	r3, [sp, #12]
 8007022:	f101 0c02 	add.w	ip, r1, #2
 8007026:	aa0c      	add	r2, sp, #48	; 0x30
 8007028:	ed93 0a00 	vldr	s0, [r3]
 800702c:	9201      	str	r2, [sp, #4]
 800702e:	ee19 3a10 	vmov	r3, s18
 8007032:	460a      	mov	r2, r1
 8007034:	f8cd c000 	str.w	ip, [sp]
 8007038:	1b29      	subs	r1, r5, r4
 800703a:	f000 f855 	bl	80070e8 <bsec_xzlarf>
 800703e:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
 8007042:	ed0b 7a01 	vstr	s14, [fp, #-4]
 8007046:	e7a6      	b.n	8006f96 <bsec_qrpf+0x102>
 8007048:	ed96 0a00 	vldr	s0, [r6]
 800704c:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
 8007050:	f022 fa6c 	bl	802952c <fabsf>
 8007054:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
 8007058:	eddd 6a11 	vldr	s13, [sp, #68]	; 0x44
 800705c:	eec0 7a07 	vdiv.f32	s15, s0, s14
 8007060:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8007064:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8007068:	ee30 0a67 	vsub.f32	s0, s0, s15
 800706c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8007070:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007074:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007078:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800707c:	bf48      	it	mi
 800707e:	eeb0 0a48 	vmovmi.f32	s0, s16
 8007082:	ee67 7a80 	vmul.f32	s15, s15, s0
 8007086:	eef4 7ae8 	vcmpe.f32	s15, s17
 800708a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800708e:	d81d      	bhi.n	80070cc <bsec_qrpf+0x238>
 8007090:	42bc      	cmp	r4, r7
 8007092:	db08      	blt.n	80070a6 <bsec_qrpf+0x212>
 8007094:	ed8d 8a0f 	vstr	s16, [sp, #60]	; 0x3c
 8007098:	ed8d 8a11 	vstr	s16, [sp, #68]	; 0x44
 800709c:	eef0 7a48 	vmov.f32	s15, s16
 80070a0:	f04f 0803 	mov.w	r8, #3
 80070a4:	e77c      	b.n	8006fa0 <bsec_qrpf+0x10c>
 80070a6:	9b06      	ldr	r3, [sp, #24]
 80070a8:	1c9a      	adds	r2, r3, #2
 80070aa:	ee19 1a10 	vmov	r1, s18
 80070ae:	4422      	add	r2, r4
 80070b0:	1b38      	subs	r0, r7, r4
 80070b2:	f000 faf3 	bl	800769c <bsec_xnrm2>
 80070b6:	eef0 7a40 	vmov.f32	s15, s0
 80070ba:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
 80070be:	ed8d 0a0f 	vstr	s0, [sp, #60]	; 0x3c
 80070c2:	ed8d 0a11 	vstr	s0, [sp, #68]	; 0x44
 80070c6:	eeb0 7a40 	vmov.f32	s14, s0
 80070ca:	e7e9      	b.n	80070a0 <bsec_qrpf+0x20c>
 80070cc:	f022 fd5e 	bl	8029b8c <sqrtf>
 80070d0:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
 80070d4:	ee60 7a07 	vmul.f32	s15, s0, s14
 80070d8:	edcd 7a0f 	vstr	s15, [sp, #60]	; 0x3c
 80070dc:	e7e0      	b.n	80070a0 <bsec_qrpf+0x20c>
 80070de:	bf00      	nop
 80070e0:	00000000 	.word	0x00000000
 80070e4:	39b504f3 	.word	0x39b504f3

080070e8 <bsec_xzlarf>:
 80070e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80070ec:	ed2d 8b02 	vpush	{d8}
 80070f0:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80070f4:	b087      	sub	sp, #28
 80070f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80070fa:	e9dd a912 	ldrd	sl, r9, [sp, #72]	; 0x48
 80070fe:	d03f      	beq.n	8007180 <bsec_xzlarf+0x98>
 8007100:	2800      	cmp	r0, #0
 8007102:	461f      	mov	r7, r3
 8007104:	eeb0 8a40 	vmov.f32	s16, s0
 8007108:	4683      	mov	fp, r0
 800710a:	4690      	mov	r8, r2
 800710c:	eb00 0302 	add.w	r3, r0, r2
 8007110:	dd0f      	ble.n	8007132 <bsec_xzlarf+0x4a>
 8007112:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007116:	3b01      	subs	r3, #1
 8007118:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800711c:	e002      	b.n	8007124 <bsec_xzlarf+0x3c>
 800711e:	f1bb 0b01 	subs.w	fp, fp, #1
 8007122:	d006      	beq.n	8007132 <bsec_xzlarf+0x4a>
 8007124:	ed73 7a01 	vldmdb	r3!, {s15}
 8007128:	eef5 7a40 	vcmp.f32	s15, #0.0
 800712c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007130:	d0f5      	beq.n	800711e <bsec_xzlarf+0x36>
 8007132:	1e4e      	subs	r6, r1, #1
 8007134:	eb0a 0646 	add.w	r6, sl, r6, lsl #1
 8007138:	eb07 0c8a 	add.w	ip, r7, sl, lsl #2
 800713c:	2900      	cmp	r1, #0
 800713e:	eb06 040b 	add.w	r4, r6, fp
 8007142:	f1ac 0c04 	sub.w	ip, ip, #4
 8007146:	dd18      	ble.n	800717a <bsec_xzlarf+0x92>
 8007148:	42a6      	cmp	r6, r4
 800714a:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
 800714e:	4635      	mov	r5, r6
 8007150:	da0c      	bge.n	800716c <bsec_xzlarf+0x84>
 8007152:	eb0c 03c2 	add.w	r3, ip, r2, lsl #3
 8007156:	ecf3 7a01 	vldmia	r3!, {s15}
 800715a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800715e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007162:	f105 0501 	add.w	r5, r5, #1
 8007166:	d108      	bne.n	800717a <bsec_xzlarf+0x92>
 8007168:	42a5      	cmp	r5, r4
 800716a:	d1f4      	bne.n	8007156 <bsec_xzlarf+0x6e>
 800716c:	4611      	mov	r1, r2
 800716e:	2900      	cmp	r1, #0
 8007170:	f1a6 0602 	sub.w	r6, r6, #2
 8007174:	f1a4 0402 	sub.w	r4, r4, #2
 8007178:	dce6      	bgt.n	8007148 <bsec_xzlarf+0x60>
 800717a:	f1bb 0f00 	cmp.w	fp, #0
 800717e:	dc04      	bgt.n	800718a <bsec_xzlarf+0xa2>
 8007180:	b007      	add	sp, #28
 8007182:	ecbd 8b02 	vpop	{d8}
 8007186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800718a:	4653      	mov	r3, sl
 800718c:	463a      	mov	r2, r7
 800718e:	4658      	mov	r0, fp
 8007190:	e9cd 8901 	strd	r8, r9, [sp, #4]
 8007194:	9700      	str	r7, [sp, #0]
 8007196:	9105      	str	r1, [sp, #20]
 8007198:	f000 f9f6 	bl	8007588 <bsec_xgemv>
 800719c:	9905      	ldr	r1, [sp, #20]
 800719e:	464b      	mov	r3, r9
 80071a0:	4642      	mov	r2, r8
 80071a2:	eeb1 0a48 	vneg.f32	s0, s16
 80071a6:	4658      	mov	r0, fp
 80071a8:	e9cd 7a12 	strd	r7, sl, [sp, #72]	; 0x48
 80071ac:	b007      	add	sp, #28
 80071ae:	ecbd 8b02 	vpop	{d8}
 80071b2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80071b6:	f000 ba2d 	b.w	8007614 <bsec_xgerc>
 80071ba:	bf00      	nop

080071bc <bsec_rt_hypotf>:
 80071bc:	b508      	push	{r3, lr}
 80071be:	ed2d 8b02 	vpush	{d8}
 80071c2:	eef0 8a60 	vmov.f32	s17, s1
 80071c6:	f022 f9b1 	bl	802952c <fabsf>
 80071ca:	eeb0 8a40 	vmov.f32	s16, s0
 80071ce:	eeb0 0a68 	vmov.f32	s0, s17
 80071d2:	f022 f9ab 	bl	802952c <fabsf>
 80071d6:	eeb4 8ac0 	vcmpe.f32	s16, s0
 80071da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80071de:	eef0 8a40 	vmov.f32	s17, s0
 80071e2:	d416      	bmi.n	8007212 <bsec_rt_hypotf+0x56>
 80071e4:	dc06      	bgt.n	80071f4 <bsec_rt_hypotf+0x38>
 80071e6:	ed9f 0a12 	vldr	s0, [pc, #72]	; 8007230 <bsec_rt_hypotf+0x74>
 80071ea:	ee28 0a00 	vmul.f32	s0, s16, s0
 80071ee:	ecbd 8b02 	vpop	{d8}
 80071f2:	bd08      	pop	{r3, pc}
 80071f4:	eec0 7a08 	vdiv.f32	s15, s0, s16
 80071f8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80071fc:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8007200:	ee37 0a80 	vadd.f32	s0, s15, s0
 8007204:	f022 fcc2 	bl	8029b8c <sqrtf>
 8007208:	ee20 0a08 	vmul.f32	s0, s0, s16
 800720c:	ecbd 8b02 	vpop	{d8}
 8007210:	bd08      	pop	{r3, pc}
 8007212:	eec8 7a00 	vdiv.f32	s15, s16, s0
 8007216:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 800721a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800721e:	ee37 0a80 	vadd.f32	s0, s15, s0
 8007222:	f022 fcb3 	bl	8029b8c <sqrtf>
 8007226:	ee20 0a28 	vmul.f32	s0, s0, s17
 800722a:	ecbd 8b02 	vpop	{d8}
 800722e:	bd08      	pop	{r3, pc}
 8007230:	3fb504f3 	.word	0x3fb504f3

08007234 <bsec_xzlarfg>:
 8007234:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007238:	ed2d 8b04 	vpush	{d8-d9}
 800723c:	1e05      	subs	r5, r0, #0
 800723e:	b083      	sub	sp, #12
 8007240:	dc06      	bgt.n	8007250 <bsec_xzlarfg+0x1c>
 8007242:	ed9f 0a60 	vldr	s0, [pc, #384]	; 80073c4 <bsec_xzlarfg+0x190>
 8007246:	b003      	add	sp, #12
 8007248:	ecbd 8b04 	vpop	{d8-d9}
 800724c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007250:	4614      	mov	r4, r2
 8007252:	f105 39ff 	add.w	r9, r5, #4294967295	; 0xffffffff
 8007256:	460e      	mov	r6, r1
 8007258:	4648      	mov	r0, r9
 800725a:	461a      	mov	r2, r3
 800725c:	4621      	mov	r1, r4
 800725e:	461f      	mov	r7, r3
 8007260:	f000 fa1c 	bl	800769c <bsec_xnrm2>
 8007264:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8007268:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800726c:	d0e9      	beq.n	8007242 <bsec_xzlarfg+0xe>
 800726e:	eef0 0a40 	vmov.f32	s1, s0
 8007272:	ed96 0a00 	vldr	s0, [r6]
 8007276:	ed9f 9a54 	vldr	s18, [pc, #336]	; 80073c8 <bsec_xzlarfg+0x194>
 800727a:	f7ff ff9f 	bl	80071bc <bsec_rt_hypotf>
 800727e:	edd6 7a00 	vldr	s15, [r6]
 8007282:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8007286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800728a:	eef0 8a40 	vmov.f32	s17, s0
 800728e:	bfa8      	it	ge
 8007290:	eef1 8a40 	vnegge.f32	s17, s0
 8007294:	eeb0 0a68 	vmov.f32	s0, s17
 8007298:	f022 f948 	bl	802952c <fabsf>
 800729c:	eeb4 0ac9 	vcmpe.f32	s0, s18
 80072a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80072a4:	d56a      	bpl.n	800737c <bsec_xzlarfg+0x148>
 80072a6:	f107 4b80 	add.w	fp, r7, #1073741824	; 0x40000000
 80072aa:	19e8      	adds	r0, r5, r7
 80072ac:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 80072b0:	f1a4 0508 	sub.w	r5, r4, #8
 80072b4:	ed9f 8a45 	vldr	s16, [pc, #276]	; 80073cc <bsec_xzlarfg+0x198>
 80072b8:	eb04 0b8b 	add.w	fp, r4, fp, lsl #2
 80072bc:	f1a0 0a02 	sub.w	sl, r0, #2
 80072c0:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 80072c4:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 80072c8:	4557      	cmp	r7, sl
 80072ca:	f8cd 8004 	str.w	r8, [sp, #4]
 80072ce:	f108 0801 	add.w	r8, r8, #1
 80072d2:	dc08      	bgt.n	80072e6 <bsec_xzlarfg+0xb2>
 80072d4:	4658      	mov	r0, fp
 80072d6:	edd0 7a00 	vldr	s15, [r0]
 80072da:	ee67 7a88 	vmul.f32	s15, s15, s16
 80072de:	ece0 7a01 	vstmia	r0!, {s15}
 80072e2:	42a8      	cmp	r0, r5
 80072e4:	d1f7      	bne.n	80072d6 <bsec_xzlarfg+0xa2>
 80072e6:	edd6 7a00 	vldr	s15, [r6]
 80072ea:	ee68 8a88 	vmul.f32	s17, s17, s16
 80072ee:	ee67 7a88 	vmul.f32	s15, s15, s16
 80072f2:	eeb0 0a68 	vmov.f32	s0, s17
 80072f6:	edc6 7a00 	vstr	s15, [r6]
 80072fa:	f022 f917 	bl	802952c <fabsf>
 80072fe:	eeb4 0ac9 	vcmpe.f32	s0, s18
 8007302:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007306:	dbdf      	blt.n	80072c8 <bsec_xzlarfg+0x94>
 8007308:	4621      	mov	r1, r4
 800730a:	4648      	mov	r0, r9
 800730c:	463a      	mov	r2, r7
 800730e:	ed96 8a00 	vldr	s16, [r6]
 8007312:	f000 f9c3 	bl	800769c <bsec_xnrm2>
 8007316:	eef0 0a40 	vmov.f32	s1, s0
 800731a:	eeb0 0a48 	vmov.f32	s0, s16
 800731e:	f7ff ff4d 	bl	80071bc <bsec_rt_hypotf>
 8007322:	edd6 7a00 	vldr	s15, [r6]
 8007326:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800732a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800732e:	eeb0 7a40 	vmov.f32	s14, s0
 8007332:	bfa8      	it	ge
 8007334:	eeb1 7a40 	vnegge.f32	s14, s0
 8007338:	ee37 6a67 	vsub.f32	s12, s14, s15
 800733c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8007340:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8007344:	4557      	cmp	r7, sl
 8007346:	eec5 6aa7 	vdiv.f32	s13, s11, s15
 800734a:	ee86 0a07 	vdiv.f32	s0, s12, s14
 800734e:	dc07      	bgt.n	8007360 <bsec_xzlarfg+0x12c>
 8007350:	eddb 7a00 	vldr	s15, [fp]
 8007354:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8007358:	eceb 7a01 	vstmia	fp!, {s15}
 800735c:	45ab      	cmp	fp, r5
 800735e:	d1f7      	bne.n	8007350 <bsec_xzlarfg+0x11c>
 8007360:	9b01      	ldr	r3, [sp, #4]
 8007362:	eddf 7a19 	vldr	s15, [pc, #100]	; 80073c8 <bsec_xzlarfg+0x194>
 8007366:	f103 0802 	add.w	r8, r3, #2
 800736a:	2300      	movs	r3, #0
 800736c:	3301      	adds	r3, #1
 800736e:	4543      	cmp	r3, r8
 8007370:	ee27 7a27 	vmul.f32	s14, s14, s15
 8007374:	d1fa      	bne.n	800736c <bsec_xzlarfg+0x138>
 8007376:	ed86 7a00 	vstr	s14, [r6]
 800737a:	e764      	b.n	8007246 <bsec_xzlarfg+0x12>
 800737c:	edd6 7a00 	vldr	s15, [r6]
 8007380:	19e8      	adds	r0, r5, r7
 8007382:	ee78 6ae7 	vsub.f32	s13, s17, s15
 8007386:	1e83      	subs	r3, r0, #2
 8007388:	ee77 7ae8 	vsub.f32	s15, s15, s17
 800738c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8007390:	429f      	cmp	r7, r3
 8007392:	ee86 7a27 	vdiv.f32	s14, s12, s15
 8007396:	ee86 0aa8 	vdiv.f32	s0, s13, s17
 800739a:	dc10      	bgt.n	80073be <bsec_xzlarfg+0x18a>
 800739c:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80073a0:	f1a4 0308 	sub.w	r3, r4, #8
 80073a4:	3f01      	subs	r7, #1
 80073a6:	eb04 0487 	add.w	r4, r4, r7, lsl #2
 80073aa:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80073ae:	edd4 7a00 	vldr	s15, [r4]
 80073b2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80073b6:	ece4 7a01 	vstmia	r4!, {s15}
 80073ba:	4284      	cmp	r4, r0
 80073bc:	d1f7      	bne.n	80073ae <bsec_xzlarfg+0x17a>
 80073be:	edc6 8a00 	vstr	s17, [r6]
 80073c2:	e740      	b.n	8007246 <bsec_xzlarfg+0x12>
 80073c4:	00000000 	.word	0x00000000
 80073c8:	0c000000 	.word	0x0c000000
 80073cc:	73000000 	.word	0x73000000

080073d0 <bsec_Channel_reset>:
 80073d0:	7f03      	ldrb	r3, [r0, #28]
 80073d2:	4a07      	ldr	r2, [pc, #28]	; (80073f0 <bsec_Channel_reset+0x20>)
 80073d4:	4907      	ldr	r1, [pc, #28]	; (80073f4 <bsec_Channel_reset+0x24>)
 80073d6:	6201      	str	r1, [r0, #32]
 80073d8:	6242      	str	r2, [r0, #36]	; 0x24
 80073da:	6282      	str	r2, [r0, #40]	; 0x28
 80073dc:	b13b      	cbz	r3, 80073ee <bsec_Channel_reset+0x1e>
 80073de:	2200      	movs	r2, #0
 80073e0:	2b01      	cmp	r3, #1
 80073e2:	6102      	str	r2, [r0, #16]
 80073e4:	d003      	beq.n	80073ee <bsec_Channel_reset+0x1e>
 80073e6:	2b02      	cmp	r3, #2
 80073e8:	6142      	str	r2, [r0, #20]
 80073ea:	bf18      	it	ne
 80073ec:	6182      	strne	r2, [r0, #24]
 80073ee:	4770      	bx	lr
 80073f0:	3b23d70a 	.word	0x3b23d70a
 80073f4:	3ca3d70a 	.word	0x3ca3d70a

080073f8 <bsec_b_Channel_reset>:
 80073f8:	7b02      	ldrb	r2, [r0, #12]
 80073fa:	2300      	movs	r3, #0
 80073fc:	6103      	str	r3, [r0, #16]
 80073fe:	6143      	str	r3, [r0, #20]
 8007400:	b102      	cbz	r2, 8007404 <bsec_b_Channel_reset+0xc>
 8007402:	6083      	str	r3, [r0, #8]
 8007404:	4770      	bx	lr
 8007406:	bf00      	nop

08007408 <bsec_ExpSmoothing_setCoeffFromBandwidth>:
 8007408:	b538      	push	{r3, r4, r5, lr}
 800740a:	ed91 0a00 	vldr	s0, [r1]
 800740e:	ed2d 8b04 	vpush	{d8-d9}
 8007412:	ed9f 9a32 	vldr	s18, [pc, #200]	; 80074dc <bsec_ExpSmoothing_setCoeffFromBandwidth+0xd4>
 8007416:	ee20 0a09 	vmul.f32	s0, s0, s18
 800741a:	4604      	mov	r4, r0
 800741c:	460d      	mov	r5, r1
 800741e:	f022 f947 	bl	80296b0 <sinf>
 8007422:	ee20 8a00 	vmul.f32	s16, s0, s0
 8007426:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 800742a:	ee28 0a08 	vmul.f32	s0, s16, s16
 800742e:	ee30 0a08 	vadd.f32	s0, s0, s16
 8007432:	f022 fbab 	bl	8029b8c <sqrtf>
 8007436:	ee30 0a48 	vsub.f32	s0, s0, s16
 800743a:	ee30 0a00 	vadd.f32	s0, s0, s0
 800743e:	ed84 0a00 	vstr	s0, [r4]
 8007442:	edd5 7a00 	vldr	s15, [r5]
 8007446:	eef4 7a68 	vcmp.f32	s15, s17
 800744a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800744e:	bf08      	it	eq
 8007450:	eeb0 0a68 	vmoveq.f32	s0, s17
 8007454:	ed84 0a00 	vstr	s0, [r4]
 8007458:	ed95 0a01 	vldr	s0, [r5, #4]
 800745c:	ee20 0a09 	vmul.f32	s0, s0, s18
 8007460:	f022 f926 	bl	80296b0 <sinf>
 8007464:	ee20 8a00 	vmul.f32	s16, s0, s0
 8007468:	ee28 0a08 	vmul.f32	s0, s16, s16
 800746c:	ee30 0a08 	vadd.f32	s0, s0, s16
 8007470:	f022 fb8c 	bl	8029b8c <sqrtf>
 8007474:	ee30 0a48 	vsub.f32	s0, s0, s16
 8007478:	ee30 0a00 	vadd.f32	s0, s0, s0
 800747c:	ed84 0a01 	vstr	s0, [r4, #4]
 8007480:	edd5 7a01 	vldr	s15, [r5, #4]
 8007484:	eef4 7a68 	vcmp.f32	s15, s17
 8007488:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800748c:	bf08      	it	eq
 800748e:	eeb0 0a68 	vmoveq.f32	s0, s17
 8007492:	ed84 0a01 	vstr	s0, [r4, #4]
 8007496:	ed95 0a02 	vldr	s0, [r5, #8]
 800749a:	ee20 0a09 	vmul.f32	s0, s0, s18
 800749e:	f022 f907 	bl	80296b0 <sinf>
 80074a2:	ee20 8a00 	vmul.f32	s16, s0, s0
 80074a6:	ee28 0a08 	vmul.f32	s0, s16, s16
 80074aa:	ee30 0a08 	vadd.f32	s0, s0, s16
 80074ae:	f022 fb6d 	bl	8029b8c <sqrtf>
 80074b2:	ee30 0a48 	vsub.f32	s0, s0, s16
 80074b6:	ee30 0a00 	vadd.f32	s0, s0, s0
 80074ba:	ed84 0a02 	vstr	s0, [r4, #8]
 80074be:	edd5 7a02 	vldr	s15, [r5, #8]
 80074c2:	eef4 7a68 	vcmp.f32	s15, s17
 80074c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80074ca:	bf08      	it	eq
 80074cc:	eeb0 0a68 	vmoveq.f32	s0, s17
 80074d0:	ecbd 8b04 	vpop	{d8-d9}
 80074d4:	ed84 0a02 	vstr	s0, [r4, #8]
 80074d8:	bd38      	pop	{r3, r4, r5, pc}
 80074da:	bf00      	nop
 80074dc:	3fc90fdb 	.word	0x3fc90fdb

080074e0 <bsec_ExpSmoothingBsec_ExpSmoothingBsec>:
 80074e0:	2200      	movs	r2, #0
 80074e2:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80074e6:	b410      	push	{r4}
 80074e8:	2403      	movs	r4, #3
 80074ea:	7604      	strb	r4, [r0, #24]
 80074ec:	6001      	str	r1, [r0, #0]
 80074ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 80074f2:	6041      	str	r1, [r0, #4]
 80074f4:	6081      	str	r1, [r0, #8]
 80074f6:	60c2      	str	r2, [r0, #12]
 80074f8:	6102      	str	r2, [r0, #16]
 80074fa:	6142      	str	r2, [r0, #20]
 80074fc:	4770      	bx	lr
 80074fe:	bf00      	nop

08007500 <bsec_b_ExpSmoothingBsec_ExpSmoothingBsec>:
 8007500:	b410      	push	{r4}
 8007502:	2401      	movs	r4, #1
 8007504:	2200      	movs	r2, #0
 8007506:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800750a:	7204      	strb	r4, [r0, #8]
 800750c:	6001      	str	r1, [r0, #0]
 800750e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007512:	6042      	str	r2, [r0, #4]
 8007514:	4770      	bx	lr
 8007516:	bf00      	nop

08007518 <bsec_ixamax>:
 8007518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800751a:	1e06      	subs	r6, r0, #0
 800751c:	ed2d 8b02 	vpush	{d8}
 8007520:	dd2c      	ble.n	800757c <bsec_ixamax+0x64>
 8007522:	2e01      	cmp	r6, #1
 8007524:	d104      	bne.n	8007530 <bsec_ixamax+0x18>
 8007526:	ecbd 8b02 	vpop	{d8}
 800752a:	4637      	mov	r7, r6
 800752c:	4638      	mov	r0, r7
 800752e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007530:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8007534:	3a01      	subs	r2, #1
 8007536:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 800753a:	ed93 0a00 	vldr	s0, [r3]
 800753e:	0095      	lsls	r5, r2, #2
 8007540:	460c      	mov	r4, r1
 8007542:	f021 fff3 	bl	802952c <fabsf>
 8007546:	1d2a      	adds	r2, r5, #4
 8007548:	eeb0 8a40 	vmov.f32	s16, s0
 800754c:	4414      	add	r4, r2
 800754e:	2502      	movs	r5, #2
 8007550:	2701      	movs	r7, #1
 8007552:	ecb4 0a01 	vldmia	r4!, {s0}
 8007556:	f021 ffe9 	bl	802952c <fabsf>
 800755a:	eeb4 0ac8 	vcmpe.f32	s0, s16
 800755e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007562:	bfc8      	it	gt
 8007564:	462f      	movgt	r7, r5
 8007566:	f105 0501 	add.w	r5, r5, #1
 800756a:	bfc8      	it	gt
 800756c:	eeb0 8a40 	vmovgt.f32	s16, s0
 8007570:	42ae      	cmp	r6, r5
 8007572:	daee      	bge.n	8007552 <bsec_ixamax+0x3a>
 8007574:	ecbd 8b02 	vpop	{d8}
 8007578:	4638      	mov	r0, r7
 800757a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800757c:	ecbd 8b02 	vpop	{d8}
 8007580:	2700      	movs	r7, #0
 8007582:	4638      	mov	r0, r7
 8007584:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007586:	bf00      	nop

08007588 <bsec_xgemv>:
 8007588:	2800      	cmp	r0, #0
 800758a:	d040      	beq.n	800760e <bsec_xgemv+0x86>
 800758c:	2900      	cmp	r1, #0
 800758e:	d03e      	beq.n	800760e <bsec_xgemv+0x86>
 8007590:	b4f0      	push	{r4, r5, r6, r7}
 8007592:	dd07      	ble.n	80075a4 <bsec_xgemv+0x1c>
 8007594:	9c06      	ldr	r4, [sp, #24]
 8007596:	2600      	movs	r6, #0
 8007598:	eb04 0581 	add.w	r5, r4, r1, lsl #2
 800759c:	f844 6b04 	str.w	r6, [r4], #4
 80075a0:	42ac      	cmp	r4, r5
 80075a2:	d1fb      	bne.n	800759c <bsec_xgemv+0x14>
 80075a4:	3901      	subs	r1, #1
 80075a6:	eb03 0541 	add.w	r5, r3, r1, lsl #1
 80075aa:	42ab      	cmp	r3, r5
 80075ac:	dc2d      	bgt.n	800760a <bsec_xgemv+0x82>
 80075ae:	9905      	ldr	r1, [sp, #20]
 80075b0:	3a04      	subs	r2, #4
 80075b2:	18c4      	adds	r4, r0, r3
 80075b4:	f101 4780 	add.w	r7, r1, #1073741824	; 0x40000000
 80075b8:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 80075bc:	9a04      	ldr	r2, [sp, #16]
 80075be:	ebc0 7c80 	rsb	ip, r0, r0, lsl #30
 80075c2:	3f01      	subs	r7, #1
 80075c4:	1e46      	subs	r6, r0, #1
 80075c6:	9806      	ldr	r0, [sp, #24]
 80075c8:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 80075cc:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80075d0:	18f2      	adds	r2, r6, r3
 80075d2:	4293      	cmp	r3, r2
 80075d4:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8007610 <bsec_xgemv+0x88>
 80075d8:	dc0c      	bgt.n	80075f4 <bsec_xgemv+0x6c>
 80075da:	eb04 020c 	add.w	r2, r4, ip
 80075de:	4639      	mov	r1, r7
 80075e0:	ecf2 7a01 	vldmia	r2!, {s15}
 80075e4:	ecf1 6a01 	vldmia	r1!, {s13}
 80075e8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80075ec:	4294      	cmp	r4, r2
 80075ee:	ee37 7a27 	vadd.f32	s14, s14, s15
 80075f2:	d1f5      	bne.n	80075e0 <bsec_xgemv+0x58>
 80075f4:	edd0 7a00 	vldr	s15, [r0]
 80075f8:	3302      	adds	r3, #2
 80075fa:	ee37 7a87 	vadd.f32	s14, s15, s14
 80075fe:	429d      	cmp	r5, r3
 8007600:	f104 0408 	add.w	r4, r4, #8
 8007604:	eca0 7a01 	vstmia	r0!, {s14}
 8007608:	dae2      	bge.n	80075d0 <bsec_xgemv+0x48>
 800760a:	bcf0      	pop	{r4, r5, r6, r7}
 800760c:	4770      	bx	lr
 800760e:	4770      	bx	lr
 8007610:	00000000 	.word	0x00000000

08007614 <bsec_xgerc>:
 8007614:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8007618:	b5f0      	push	{r4, r5, r6, r7, lr}
 800761a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800761e:	9e06      	ldr	r6, [sp, #24]
 8007620:	d03b      	beq.n	800769a <bsec_xgerc+0x86>
 8007622:	2900      	cmp	r1, #0
 8007624:	dd39      	ble.n	800769a <bsec_xgerc+0x86>
 8007626:	f102 4480 	add.w	r4, r2, #1073741824	; 0x40000000
 800762a:	9a05      	ldr	r2, [sp, #20]
 800762c:	9d05      	ldr	r5, [sp, #20]
 800762e:	3c01      	subs	r4, #1
 8007630:	eb06 0e00 	add.w	lr, r6, r0
 8007634:	3a04      	subs	r2, #4
 8007636:	ebc0 7c80 	rsb	ip, r0, r0, lsl #30
 800763a:	eb05 0784 	add.w	r7, r5, r4, lsl #2
 800763e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8007642:	eb03 0581 	add.w	r5, r3, r1, lsl #2
 8007646:	eb02 018e 	add.w	r1, r2, lr, lsl #2
 800764a:	e005      	b.n	8007658 <bsec_xgerc+0x44>
 800764c:	42ab      	cmp	r3, r5
 800764e:	f106 0602 	add.w	r6, r6, #2
 8007652:	f101 0108 	add.w	r1, r1, #8
 8007656:	d020      	beq.n	800769a <bsec_xgerc+0x86>
 8007658:	ecb3 7a01 	vldmia	r3!, {s14}
 800765c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8007660:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007664:	d0f2      	beq.n	800764c <bsec_xgerc+0x38>
 8007666:	1832      	adds	r2, r6, r0
 8007668:	4296      	cmp	r6, r2
 800766a:	ee27 7a00 	vmul.f32	s14, s14, s0
 800766e:	daed      	bge.n	800764c <bsec_xgerc+0x38>
 8007670:	eb01 020c 	add.w	r2, r1, ip
 8007674:	463c      	mov	r4, r7
 8007676:	ecf4 7a01 	vldmia	r4!, {s15}
 800767a:	edd2 6a00 	vldr	s13, [r2]
 800767e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8007682:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8007686:	ece2 7a01 	vstmia	r2!, {s15}
 800768a:	4291      	cmp	r1, r2
 800768c:	d1f3      	bne.n	8007676 <bsec_xgerc+0x62>
 800768e:	42ab      	cmp	r3, r5
 8007690:	f106 0602 	add.w	r6, r6, #2
 8007694:	f101 0108 	add.w	r1, r1, #8
 8007698:	d1de      	bne.n	8007658 <bsec_xgerc+0x44>
 800769a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800769c <bsec_xnrm2>:
 800769c:	2800      	cmp	r0, #0
 800769e:	dd3d      	ble.n	800771c <bsec_xnrm2+0x80>
 80076a0:	2801      	cmp	r0, #1
 80076a2:	d03e      	beq.n	8007722 <bsec_xnrm2+0x86>
 80076a4:	b538      	push	{r3, r4, r5, lr}
 80076a6:	4410      	add	r0, r2
 80076a8:	1e43      	subs	r3, r0, #1
 80076aa:	429a      	cmp	r2, r3
 80076ac:	ed2d 8b04 	vpush	{d8-d9}
 80076b0:	dc3d      	bgt.n	800772e <bsec_xnrm2+0x92>
 80076b2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80076b6:	3a01      	subs	r2, #1
 80076b8:	1f0d      	subs	r5, r1, #4
 80076ba:	eddf 8a1f 	vldr	s17, [pc, #124]	; 8007738 <bsec_xnrm2+0x9c>
 80076be:	ed9f 8a1f 	vldr	s16, [pc, #124]	; 800773c <bsec_xnrm2+0xa0>
 80076c2:	eb01 0482 	add.w	r4, r1, r2, lsl #2
 80076c6:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 80076ca:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 80076ce:	e00b      	b.n	80076e8 <bsec_xnrm2+0x4c>
 80076d0:	eec8 7a80 	vdiv.f32	s15, s17, s0
 80076d4:	42ac      	cmp	r4, r5
 80076d6:	eef0 8a40 	vmov.f32	s17, s0
 80076da:	ee27 8a88 	vmul.f32	s16, s15, s16
 80076de:	ee28 8a27 	vmul.f32	s16, s16, s15
 80076e2:	ee38 8a09 	vadd.f32	s16, s16, s18
 80076e6:	d010      	beq.n	800770a <bsec_xnrm2+0x6e>
 80076e8:	ecb4 0a01 	vldmia	r4!, {s0}
 80076ec:	f021 ff1e 	bl	802952c <fabsf>
 80076f0:	eeb4 0ae8 	vcmpe.f32	s0, s17
 80076f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80076f8:	dcea      	bgt.n	80076d0 <bsec_xnrm2+0x34>
 80076fa:	eec0 7a28 	vdiv.f32	s15, s0, s17
 80076fe:	42ac      	cmp	r4, r5
 8007700:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8007704:	ee38 8a27 	vadd.f32	s16, s16, s15
 8007708:	d1ee      	bne.n	80076e8 <bsec_xnrm2+0x4c>
 800770a:	eeb0 0a48 	vmov.f32	s0, s16
 800770e:	f022 fa3d 	bl	8029b8c <sqrtf>
 8007712:	ee20 0a28 	vmul.f32	s0, s0, s17
 8007716:	ecbd 8b04 	vpop	{d8-d9}
 800771a:	bd38      	pop	{r3, r4, r5, pc}
 800771c:	ed9f 0a07 	vldr	s0, [pc, #28]	; 800773c <bsec_xnrm2+0xa0>
 8007720:	4770      	bx	lr
 8007722:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8007726:	ed11 0a01 	vldr	s0, [r1, #-4]
 800772a:	f021 beff 	b.w	802952c <fabsf>
 800772e:	eddf 8a02 	vldr	s17, [pc, #8]	; 8007738 <bsec_xnrm2+0x9c>
 8007732:	ed9f 8a02 	vldr	s16, [pc, #8]	; 800773c <bsec_xnrm2+0xa0>
 8007736:	e7e8      	b.n	800770a <bsec_xnrm2+0x6e>
 8007738:	14800000 	.word	0x14800000
 800773c:	00000000 	.word	0x00000000

08007740 <bsec_xswap>:
 8007740:	2800      	cmp	r0, #0
 8007742:	dd14      	ble.n	800776e <bsec_xswap+0x2e>
 8007744:	b430      	push	{r4, r5}
 8007746:	3b01      	subs	r3, #1
 8007748:	1815      	adds	r5, r2, r0
 800774a:	1e54      	subs	r4, r2, #1
 800774c:	1f08      	subs	r0, r1, #4
 800774e:	eb01 0284 	add.w	r2, r1, r4, lsl #2
 8007752:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8007756:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 800775a:	6818      	ldr	r0, [r3, #0]
 800775c:	6811      	ldr	r1, [r2, #0]
 800775e:	f842 0b04 	str.w	r0, [r2], #4
 8007762:	42a2      	cmp	r2, r4
 8007764:	f843 1b04 	str.w	r1, [r3], #4
 8007768:	d1f7      	bne.n	800775a <bsec_xswap+0x1a>
 800776a:	bc30      	pop	{r4, r5}
 800776c:	4770      	bx	lr
 800776e:	4770      	bx	lr

08007770 <strlen>:
 8007770:	4603      	mov	r3, r0
 8007772:	f813 2b01 	ldrb.w	r2, [r3], #1
 8007776:	2a00      	cmp	r2, #0
 8007778:	d1fb      	bne.n	8007772 <strlen+0x2>
 800777a:	1a18      	subs	r0, r3, r0
 800777c:	3801      	subs	r0, #1
 800777e:	4770      	bx	lr

08007780 <__aeabi_drsub>:
 8007780:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8007784:	e002      	b.n	800778c <__adddf3>
 8007786:	bf00      	nop

08007788 <__aeabi_dsub>:
 8007788:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800778c <__adddf3>:
 800778c:	b530      	push	{r4, r5, lr}
 800778e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8007792:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8007796:	ea94 0f05 	teq	r4, r5
 800779a:	bf08      	it	eq
 800779c:	ea90 0f02 	teqeq	r0, r2
 80077a0:	bf1f      	itttt	ne
 80077a2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80077a6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80077aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80077ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80077b2:	f000 80e2 	beq.w	800797a <__adddf3+0x1ee>
 80077b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80077ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80077be:	bfb8      	it	lt
 80077c0:	426d      	neglt	r5, r5
 80077c2:	dd0c      	ble.n	80077de <__adddf3+0x52>
 80077c4:	442c      	add	r4, r5
 80077c6:	ea80 0202 	eor.w	r2, r0, r2
 80077ca:	ea81 0303 	eor.w	r3, r1, r3
 80077ce:	ea82 0000 	eor.w	r0, r2, r0
 80077d2:	ea83 0101 	eor.w	r1, r3, r1
 80077d6:	ea80 0202 	eor.w	r2, r0, r2
 80077da:	ea81 0303 	eor.w	r3, r1, r3
 80077de:	2d36      	cmp	r5, #54	; 0x36
 80077e0:	bf88      	it	hi
 80077e2:	bd30      	pophi	{r4, r5, pc}
 80077e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80077e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80077ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80077f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80077f4:	d002      	beq.n	80077fc <__adddf3+0x70>
 80077f6:	4240      	negs	r0, r0
 80077f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80077fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8007800:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007804:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8007808:	d002      	beq.n	8007810 <__adddf3+0x84>
 800780a:	4252      	negs	r2, r2
 800780c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007810:	ea94 0f05 	teq	r4, r5
 8007814:	f000 80a7 	beq.w	8007966 <__adddf3+0x1da>
 8007818:	f1a4 0401 	sub.w	r4, r4, #1
 800781c:	f1d5 0e20 	rsbs	lr, r5, #32
 8007820:	db0d      	blt.n	800783e <__adddf3+0xb2>
 8007822:	fa02 fc0e 	lsl.w	ip, r2, lr
 8007826:	fa22 f205 	lsr.w	r2, r2, r5
 800782a:	1880      	adds	r0, r0, r2
 800782c:	f141 0100 	adc.w	r1, r1, #0
 8007830:	fa03 f20e 	lsl.w	r2, r3, lr
 8007834:	1880      	adds	r0, r0, r2
 8007836:	fa43 f305 	asr.w	r3, r3, r5
 800783a:	4159      	adcs	r1, r3
 800783c:	e00e      	b.n	800785c <__adddf3+0xd0>
 800783e:	f1a5 0520 	sub.w	r5, r5, #32
 8007842:	f10e 0e20 	add.w	lr, lr, #32
 8007846:	2a01      	cmp	r2, #1
 8007848:	fa03 fc0e 	lsl.w	ip, r3, lr
 800784c:	bf28      	it	cs
 800784e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8007852:	fa43 f305 	asr.w	r3, r3, r5
 8007856:	18c0      	adds	r0, r0, r3
 8007858:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800785c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007860:	d507      	bpl.n	8007872 <__adddf3+0xe6>
 8007862:	f04f 0e00 	mov.w	lr, #0
 8007866:	f1dc 0c00 	rsbs	ip, ip, #0
 800786a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800786e:	eb6e 0101 	sbc.w	r1, lr, r1
 8007872:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8007876:	d31b      	bcc.n	80078b0 <__adddf3+0x124>
 8007878:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800787c:	d30c      	bcc.n	8007898 <__adddf3+0x10c>
 800787e:	0849      	lsrs	r1, r1, #1
 8007880:	ea5f 0030 	movs.w	r0, r0, rrx
 8007884:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8007888:	f104 0401 	add.w	r4, r4, #1
 800788c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8007890:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8007894:	f080 809a 	bcs.w	80079cc <__adddf3+0x240>
 8007898:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800789c:	bf08      	it	eq
 800789e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80078a2:	f150 0000 	adcs.w	r0, r0, #0
 80078a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80078aa:	ea41 0105 	orr.w	r1, r1, r5
 80078ae:	bd30      	pop	{r4, r5, pc}
 80078b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80078b4:	4140      	adcs	r0, r0
 80078b6:	eb41 0101 	adc.w	r1, r1, r1
 80078ba:	3c01      	subs	r4, #1
 80078bc:	bf28      	it	cs
 80078be:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80078c2:	d2e9      	bcs.n	8007898 <__adddf3+0x10c>
 80078c4:	f091 0f00 	teq	r1, #0
 80078c8:	bf04      	itt	eq
 80078ca:	4601      	moveq	r1, r0
 80078cc:	2000      	moveq	r0, #0
 80078ce:	fab1 f381 	clz	r3, r1
 80078d2:	bf08      	it	eq
 80078d4:	3320      	addeq	r3, #32
 80078d6:	f1a3 030b 	sub.w	r3, r3, #11
 80078da:	f1b3 0220 	subs.w	r2, r3, #32
 80078de:	da0c      	bge.n	80078fa <__adddf3+0x16e>
 80078e0:	320c      	adds	r2, #12
 80078e2:	dd08      	ble.n	80078f6 <__adddf3+0x16a>
 80078e4:	f102 0c14 	add.w	ip, r2, #20
 80078e8:	f1c2 020c 	rsb	r2, r2, #12
 80078ec:	fa01 f00c 	lsl.w	r0, r1, ip
 80078f0:	fa21 f102 	lsr.w	r1, r1, r2
 80078f4:	e00c      	b.n	8007910 <__adddf3+0x184>
 80078f6:	f102 0214 	add.w	r2, r2, #20
 80078fa:	bfd8      	it	le
 80078fc:	f1c2 0c20 	rsble	ip, r2, #32
 8007900:	fa01 f102 	lsl.w	r1, r1, r2
 8007904:	fa20 fc0c 	lsr.w	ip, r0, ip
 8007908:	bfdc      	itt	le
 800790a:	ea41 010c 	orrle.w	r1, r1, ip
 800790e:	4090      	lslle	r0, r2
 8007910:	1ae4      	subs	r4, r4, r3
 8007912:	bfa2      	ittt	ge
 8007914:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8007918:	4329      	orrge	r1, r5
 800791a:	bd30      	popge	{r4, r5, pc}
 800791c:	ea6f 0404 	mvn.w	r4, r4
 8007920:	3c1f      	subs	r4, #31
 8007922:	da1c      	bge.n	800795e <__adddf3+0x1d2>
 8007924:	340c      	adds	r4, #12
 8007926:	dc0e      	bgt.n	8007946 <__adddf3+0x1ba>
 8007928:	f104 0414 	add.w	r4, r4, #20
 800792c:	f1c4 0220 	rsb	r2, r4, #32
 8007930:	fa20 f004 	lsr.w	r0, r0, r4
 8007934:	fa01 f302 	lsl.w	r3, r1, r2
 8007938:	ea40 0003 	orr.w	r0, r0, r3
 800793c:	fa21 f304 	lsr.w	r3, r1, r4
 8007940:	ea45 0103 	orr.w	r1, r5, r3
 8007944:	bd30      	pop	{r4, r5, pc}
 8007946:	f1c4 040c 	rsb	r4, r4, #12
 800794a:	f1c4 0220 	rsb	r2, r4, #32
 800794e:	fa20 f002 	lsr.w	r0, r0, r2
 8007952:	fa01 f304 	lsl.w	r3, r1, r4
 8007956:	ea40 0003 	orr.w	r0, r0, r3
 800795a:	4629      	mov	r1, r5
 800795c:	bd30      	pop	{r4, r5, pc}
 800795e:	fa21 f004 	lsr.w	r0, r1, r4
 8007962:	4629      	mov	r1, r5
 8007964:	bd30      	pop	{r4, r5, pc}
 8007966:	f094 0f00 	teq	r4, #0
 800796a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800796e:	bf06      	itte	eq
 8007970:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8007974:	3401      	addeq	r4, #1
 8007976:	3d01      	subne	r5, #1
 8007978:	e74e      	b.n	8007818 <__adddf3+0x8c>
 800797a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800797e:	bf18      	it	ne
 8007980:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8007984:	d029      	beq.n	80079da <__adddf3+0x24e>
 8007986:	ea94 0f05 	teq	r4, r5
 800798a:	bf08      	it	eq
 800798c:	ea90 0f02 	teqeq	r0, r2
 8007990:	d005      	beq.n	800799e <__adddf3+0x212>
 8007992:	ea54 0c00 	orrs.w	ip, r4, r0
 8007996:	bf04      	itt	eq
 8007998:	4619      	moveq	r1, r3
 800799a:	4610      	moveq	r0, r2
 800799c:	bd30      	pop	{r4, r5, pc}
 800799e:	ea91 0f03 	teq	r1, r3
 80079a2:	bf1e      	ittt	ne
 80079a4:	2100      	movne	r1, #0
 80079a6:	2000      	movne	r0, #0
 80079a8:	bd30      	popne	{r4, r5, pc}
 80079aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80079ae:	d105      	bne.n	80079bc <__adddf3+0x230>
 80079b0:	0040      	lsls	r0, r0, #1
 80079b2:	4149      	adcs	r1, r1
 80079b4:	bf28      	it	cs
 80079b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80079ba:	bd30      	pop	{r4, r5, pc}
 80079bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80079c0:	bf3c      	itt	cc
 80079c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80079c6:	bd30      	popcc	{r4, r5, pc}
 80079c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80079cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80079d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80079d4:	f04f 0000 	mov.w	r0, #0
 80079d8:	bd30      	pop	{r4, r5, pc}
 80079da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80079de:	bf1a      	itte	ne
 80079e0:	4619      	movne	r1, r3
 80079e2:	4610      	movne	r0, r2
 80079e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80079e8:	bf1c      	itt	ne
 80079ea:	460b      	movne	r3, r1
 80079ec:	4602      	movne	r2, r0
 80079ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80079f2:	bf06      	itte	eq
 80079f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80079f8:	ea91 0f03 	teqeq	r1, r3
 80079fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8007a00:	bd30      	pop	{r4, r5, pc}
 8007a02:	bf00      	nop

08007a04 <__aeabi_ui2d>:
 8007a04:	f090 0f00 	teq	r0, #0
 8007a08:	bf04      	itt	eq
 8007a0a:	2100      	moveq	r1, #0
 8007a0c:	4770      	bxeq	lr
 8007a0e:	b530      	push	{r4, r5, lr}
 8007a10:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007a14:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007a18:	f04f 0500 	mov.w	r5, #0
 8007a1c:	f04f 0100 	mov.w	r1, #0
 8007a20:	e750      	b.n	80078c4 <__adddf3+0x138>
 8007a22:	bf00      	nop

08007a24 <__aeabi_i2d>:
 8007a24:	f090 0f00 	teq	r0, #0
 8007a28:	bf04      	itt	eq
 8007a2a:	2100      	moveq	r1, #0
 8007a2c:	4770      	bxeq	lr
 8007a2e:	b530      	push	{r4, r5, lr}
 8007a30:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007a34:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007a38:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8007a3c:	bf48      	it	mi
 8007a3e:	4240      	negmi	r0, r0
 8007a40:	f04f 0100 	mov.w	r1, #0
 8007a44:	e73e      	b.n	80078c4 <__adddf3+0x138>
 8007a46:	bf00      	nop

08007a48 <__aeabi_f2d>:
 8007a48:	0042      	lsls	r2, r0, #1
 8007a4a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8007a4e:	ea4f 0131 	mov.w	r1, r1, rrx
 8007a52:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8007a56:	bf1f      	itttt	ne
 8007a58:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8007a5c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8007a60:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8007a64:	4770      	bxne	lr
 8007a66:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8007a6a:	bf08      	it	eq
 8007a6c:	4770      	bxeq	lr
 8007a6e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8007a72:	bf04      	itt	eq
 8007a74:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8007a78:	4770      	bxeq	lr
 8007a7a:	b530      	push	{r4, r5, lr}
 8007a7c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8007a80:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007a84:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007a88:	e71c      	b.n	80078c4 <__adddf3+0x138>
 8007a8a:	bf00      	nop

08007a8c <__aeabi_ul2d>:
 8007a8c:	ea50 0201 	orrs.w	r2, r0, r1
 8007a90:	bf08      	it	eq
 8007a92:	4770      	bxeq	lr
 8007a94:	b530      	push	{r4, r5, lr}
 8007a96:	f04f 0500 	mov.w	r5, #0
 8007a9a:	e00a      	b.n	8007ab2 <__aeabi_l2d+0x16>

08007a9c <__aeabi_l2d>:
 8007a9c:	ea50 0201 	orrs.w	r2, r0, r1
 8007aa0:	bf08      	it	eq
 8007aa2:	4770      	bxeq	lr
 8007aa4:	b530      	push	{r4, r5, lr}
 8007aa6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8007aaa:	d502      	bpl.n	8007ab2 <__aeabi_l2d+0x16>
 8007aac:	4240      	negs	r0, r0
 8007aae:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007ab2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007ab6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007aba:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8007abe:	f43f aed8 	beq.w	8007872 <__adddf3+0xe6>
 8007ac2:	f04f 0203 	mov.w	r2, #3
 8007ac6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8007aca:	bf18      	it	ne
 8007acc:	3203      	addne	r2, #3
 8007ace:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8007ad2:	bf18      	it	ne
 8007ad4:	3203      	addne	r2, #3
 8007ad6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8007ada:	f1c2 0320 	rsb	r3, r2, #32
 8007ade:	fa00 fc03 	lsl.w	ip, r0, r3
 8007ae2:	fa20 f002 	lsr.w	r0, r0, r2
 8007ae6:	fa01 fe03 	lsl.w	lr, r1, r3
 8007aea:	ea40 000e 	orr.w	r0, r0, lr
 8007aee:	fa21 f102 	lsr.w	r1, r1, r2
 8007af2:	4414      	add	r4, r2
 8007af4:	e6bd      	b.n	8007872 <__adddf3+0xe6>
 8007af6:	bf00      	nop

08007af8 <__aeabi_dmul>:
 8007af8:	b570      	push	{r4, r5, r6, lr}
 8007afa:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007afe:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007b02:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8007b06:	bf1d      	ittte	ne
 8007b08:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8007b0c:	ea94 0f0c 	teqne	r4, ip
 8007b10:	ea95 0f0c 	teqne	r5, ip
 8007b14:	f000 f8de 	bleq	8007cd4 <__aeabi_dmul+0x1dc>
 8007b18:	442c      	add	r4, r5
 8007b1a:	ea81 0603 	eor.w	r6, r1, r3
 8007b1e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8007b22:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8007b26:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8007b2a:	bf18      	it	ne
 8007b2c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8007b30:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007b34:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8007b38:	d038      	beq.n	8007bac <__aeabi_dmul+0xb4>
 8007b3a:	fba0 ce02 	umull	ip, lr, r0, r2
 8007b3e:	f04f 0500 	mov.w	r5, #0
 8007b42:	fbe1 e502 	umlal	lr, r5, r1, r2
 8007b46:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8007b4a:	fbe0 e503 	umlal	lr, r5, r0, r3
 8007b4e:	f04f 0600 	mov.w	r6, #0
 8007b52:	fbe1 5603 	umlal	r5, r6, r1, r3
 8007b56:	f09c 0f00 	teq	ip, #0
 8007b5a:	bf18      	it	ne
 8007b5c:	f04e 0e01 	orrne.w	lr, lr, #1
 8007b60:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8007b64:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8007b68:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8007b6c:	d204      	bcs.n	8007b78 <__aeabi_dmul+0x80>
 8007b6e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8007b72:	416d      	adcs	r5, r5
 8007b74:	eb46 0606 	adc.w	r6, r6, r6
 8007b78:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8007b7c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8007b80:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8007b84:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8007b88:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8007b8c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8007b90:	bf88      	it	hi
 8007b92:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8007b96:	d81e      	bhi.n	8007bd6 <__aeabi_dmul+0xde>
 8007b98:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8007b9c:	bf08      	it	eq
 8007b9e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8007ba2:	f150 0000 	adcs.w	r0, r0, #0
 8007ba6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007baa:	bd70      	pop	{r4, r5, r6, pc}
 8007bac:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8007bb0:	ea46 0101 	orr.w	r1, r6, r1
 8007bb4:	ea40 0002 	orr.w	r0, r0, r2
 8007bb8:	ea81 0103 	eor.w	r1, r1, r3
 8007bbc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8007bc0:	bfc2      	ittt	gt
 8007bc2:	ebd4 050c 	rsbsgt	r5, r4, ip
 8007bc6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8007bca:	bd70      	popgt	{r4, r5, r6, pc}
 8007bcc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007bd0:	f04f 0e00 	mov.w	lr, #0
 8007bd4:	3c01      	subs	r4, #1
 8007bd6:	f300 80ab 	bgt.w	8007d30 <__aeabi_dmul+0x238>
 8007bda:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8007bde:	bfde      	ittt	le
 8007be0:	2000      	movle	r0, #0
 8007be2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8007be6:	bd70      	pople	{r4, r5, r6, pc}
 8007be8:	f1c4 0400 	rsb	r4, r4, #0
 8007bec:	3c20      	subs	r4, #32
 8007bee:	da35      	bge.n	8007c5c <__aeabi_dmul+0x164>
 8007bf0:	340c      	adds	r4, #12
 8007bf2:	dc1b      	bgt.n	8007c2c <__aeabi_dmul+0x134>
 8007bf4:	f104 0414 	add.w	r4, r4, #20
 8007bf8:	f1c4 0520 	rsb	r5, r4, #32
 8007bfc:	fa00 f305 	lsl.w	r3, r0, r5
 8007c00:	fa20 f004 	lsr.w	r0, r0, r4
 8007c04:	fa01 f205 	lsl.w	r2, r1, r5
 8007c08:	ea40 0002 	orr.w	r0, r0, r2
 8007c0c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8007c10:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007c14:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8007c18:	fa21 f604 	lsr.w	r6, r1, r4
 8007c1c:	eb42 0106 	adc.w	r1, r2, r6
 8007c20:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007c24:	bf08      	it	eq
 8007c26:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007c2a:	bd70      	pop	{r4, r5, r6, pc}
 8007c2c:	f1c4 040c 	rsb	r4, r4, #12
 8007c30:	f1c4 0520 	rsb	r5, r4, #32
 8007c34:	fa00 f304 	lsl.w	r3, r0, r4
 8007c38:	fa20 f005 	lsr.w	r0, r0, r5
 8007c3c:	fa01 f204 	lsl.w	r2, r1, r4
 8007c40:	ea40 0002 	orr.w	r0, r0, r2
 8007c44:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007c48:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8007c4c:	f141 0100 	adc.w	r1, r1, #0
 8007c50:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007c54:	bf08      	it	eq
 8007c56:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007c5a:	bd70      	pop	{r4, r5, r6, pc}
 8007c5c:	f1c4 0520 	rsb	r5, r4, #32
 8007c60:	fa00 f205 	lsl.w	r2, r0, r5
 8007c64:	ea4e 0e02 	orr.w	lr, lr, r2
 8007c68:	fa20 f304 	lsr.w	r3, r0, r4
 8007c6c:	fa01 f205 	lsl.w	r2, r1, r5
 8007c70:	ea43 0302 	orr.w	r3, r3, r2
 8007c74:	fa21 f004 	lsr.w	r0, r1, r4
 8007c78:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007c7c:	fa21 f204 	lsr.w	r2, r1, r4
 8007c80:	ea20 0002 	bic.w	r0, r0, r2
 8007c84:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8007c88:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007c8c:	bf08      	it	eq
 8007c8e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007c92:	bd70      	pop	{r4, r5, r6, pc}
 8007c94:	f094 0f00 	teq	r4, #0
 8007c98:	d10f      	bne.n	8007cba <__aeabi_dmul+0x1c2>
 8007c9a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8007c9e:	0040      	lsls	r0, r0, #1
 8007ca0:	eb41 0101 	adc.w	r1, r1, r1
 8007ca4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007ca8:	bf08      	it	eq
 8007caa:	3c01      	subeq	r4, #1
 8007cac:	d0f7      	beq.n	8007c9e <__aeabi_dmul+0x1a6>
 8007cae:	ea41 0106 	orr.w	r1, r1, r6
 8007cb2:	f095 0f00 	teq	r5, #0
 8007cb6:	bf18      	it	ne
 8007cb8:	4770      	bxne	lr
 8007cba:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8007cbe:	0052      	lsls	r2, r2, #1
 8007cc0:	eb43 0303 	adc.w	r3, r3, r3
 8007cc4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8007cc8:	bf08      	it	eq
 8007cca:	3d01      	subeq	r5, #1
 8007ccc:	d0f7      	beq.n	8007cbe <__aeabi_dmul+0x1c6>
 8007cce:	ea43 0306 	orr.w	r3, r3, r6
 8007cd2:	4770      	bx	lr
 8007cd4:	ea94 0f0c 	teq	r4, ip
 8007cd8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8007cdc:	bf18      	it	ne
 8007cde:	ea95 0f0c 	teqne	r5, ip
 8007ce2:	d00c      	beq.n	8007cfe <__aeabi_dmul+0x206>
 8007ce4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007ce8:	bf18      	it	ne
 8007cea:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007cee:	d1d1      	bne.n	8007c94 <__aeabi_dmul+0x19c>
 8007cf0:	ea81 0103 	eor.w	r1, r1, r3
 8007cf4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007cf8:	f04f 0000 	mov.w	r0, #0
 8007cfc:	bd70      	pop	{r4, r5, r6, pc}
 8007cfe:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007d02:	bf06      	itte	eq
 8007d04:	4610      	moveq	r0, r2
 8007d06:	4619      	moveq	r1, r3
 8007d08:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007d0c:	d019      	beq.n	8007d42 <__aeabi_dmul+0x24a>
 8007d0e:	ea94 0f0c 	teq	r4, ip
 8007d12:	d102      	bne.n	8007d1a <__aeabi_dmul+0x222>
 8007d14:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8007d18:	d113      	bne.n	8007d42 <__aeabi_dmul+0x24a>
 8007d1a:	ea95 0f0c 	teq	r5, ip
 8007d1e:	d105      	bne.n	8007d2c <__aeabi_dmul+0x234>
 8007d20:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8007d24:	bf1c      	itt	ne
 8007d26:	4610      	movne	r0, r2
 8007d28:	4619      	movne	r1, r3
 8007d2a:	d10a      	bne.n	8007d42 <__aeabi_dmul+0x24a>
 8007d2c:	ea81 0103 	eor.w	r1, r1, r3
 8007d30:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007d34:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007d38:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8007d3c:	f04f 0000 	mov.w	r0, #0
 8007d40:	bd70      	pop	{r4, r5, r6, pc}
 8007d42:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007d46:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8007d4a:	bd70      	pop	{r4, r5, r6, pc}

08007d4c <__aeabi_ddiv>:
 8007d4c:	b570      	push	{r4, r5, r6, lr}
 8007d4e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007d52:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007d56:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8007d5a:	bf1d      	ittte	ne
 8007d5c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8007d60:	ea94 0f0c 	teqne	r4, ip
 8007d64:	ea95 0f0c 	teqne	r5, ip
 8007d68:	f000 f8a7 	bleq	8007eba <__aeabi_ddiv+0x16e>
 8007d6c:	eba4 0405 	sub.w	r4, r4, r5
 8007d70:	ea81 0e03 	eor.w	lr, r1, r3
 8007d74:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007d78:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8007d7c:	f000 8088 	beq.w	8007e90 <__aeabi_ddiv+0x144>
 8007d80:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007d84:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8007d88:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8007d8c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8007d90:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8007d94:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8007d98:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8007d9c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8007da0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8007da4:	429d      	cmp	r5, r3
 8007da6:	bf08      	it	eq
 8007da8:	4296      	cmpeq	r6, r2
 8007daa:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8007dae:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8007db2:	d202      	bcs.n	8007dba <__aeabi_ddiv+0x6e>
 8007db4:	085b      	lsrs	r3, r3, #1
 8007db6:	ea4f 0232 	mov.w	r2, r2, rrx
 8007dba:	1ab6      	subs	r6, r6, r2
 8007dbc:	eb65 0503 	sbc.w	r5, r5, r3
 8007dc0:	085b      	lsrs	r3, r3, #1
 8007dc2:	ea4f 0232 	mov.w	r2, r2, rrx
 8007dc6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8007dca:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8007dce:	ebb6 0e02 	subs.w	lr, r6, r2
 8007dd2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007dd6:	bf22      	ittt	cs
 8007dd8:	1ab6      	subcs	r6, r6, r2
 8007dda:	4675      	movcs	r5, lr
 8007ddc:	ea40 000c 	orrcs.w	r0, r0, ip
 8007de0:	085b      	lsrs	r3, r3, #1
 8007de2:	ea4f 0232 	mov.w	r2, r2, rrx
 8007de6:	ebb6 0e02 	subs.w	lr, r6, r2
 8007dea:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007dee:	bf22      	ittt	cs
 8007df0:	1ab6      	subcs	r6, r6, r2
 8007df2:	4675      	movcs	r5, lr
 8007df4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8007df8:	085b      	lsrs	r3, r3, #1
 8007dfa:	ea4f 0232 	mov.w	r2, r2, rrx
 8007dfe:	ebb6 0e02 	subs.w	lr, r6, r2
 8007e02:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007e06:	bf22      	ittt	cs
 8007e08:	1ab6      	subcs	r6, r6, r2
 8007e0a:	4675      	movcs	r5, lr
 8007e0c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8007e10:	085b      	lsrs	r3, r3, #1
 8007e12:	ea4f 0232 	mov.w	r2, r2, rrx
 8007e16:	ebb6 0e02 	subs.w	lr, r6, r2
 8007e1a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007e1e:	bf22      	ittt	cs
 8007e20:	1ab6      	subcs	r6, r6, r2
 8007e22:	4675      	movcs	r5, lr
 8007e24:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8007e28:	ea55 0e06 	orrs.w	lr, r5, r6
 8007e2c:	d018      	beq.n	8007e60 <__aeabi_ddiv+0x114>
 8007e2e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8007e32:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8007e36:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8007e3a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007e3e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8007e42:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8007e46:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8007e4a:	d1c0      	bne.n	8007dce <__aeabi_ddiv+0x82>
 8007e4c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007e50:	d10b      	bne.n	8007e6a <__aeabi_ddiv+0x11e>
 8007e52:	ea41 0100 	orr.w	r1, r1, r0
 8007e56:	f04f 0000 	mov.w	r0, #0
 8007e5a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8007e5e:	e7b6      	b.n	8007dce <__aeabi_ddiv+0x82>
 8007e60:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007e64:	bf04      	itt	eq
 8007e66:	4301      	orreq	r1, r0
 8007e68:	2000      	moveq	r0, #0
 8007e6a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8007e6e:	bf88      	it	hi
 8007e70:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8007e74:	f63f aeaf 	bhi.w	8007bd6 <__aeabi_dmul+0xde>
 8007e78:	ebb5 0c03 	subs.w	ip, r5, r3
 8007e7c:	bf04      	itt	eq
 8007e7e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8007e82:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8007e86:	f150 0000 	adcs.w	r0, r0, #0
 8007e8a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007e8e:	bd70      	pop	{r4, r5, r6, pc}
 8007e90:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8007e94:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8007e98:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8007e9c:	bfc2      	ittt	gt
 8007e9e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8007ea2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8007ea6:	bd70      	popgt	{r4, r5, r6, pc}
 8007ea8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007eac:	f04f 0e00 	mov.w	lr, #0
 8007eb0:	3c01      	subs	r4, #1
 8007eb2:	e690      	b.n	8007bd6 <__aeabi_dmul+0xde>
 8007eb4:	ea45 0e06 	orr.w	lr, r5, r6
 8007eb8:	e68d      	b.n	8007bd6 <__aeabi_dmul+0xde>
 8007eba:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8007ebe:	ea94 0f0c 	teq	r4, ip
 8007ec2:	bf08      	it	eq
 8007ec4:	ea95 0f0c 	teqeq	r5, ip
 8007ec8:	f43f af3b 	beq.w	8007d42 <__aeabi_dmul+0x24a>
 8007ecc:	ea94 0f0c 	teq	r4, ip
 8007ed0:	d10a      	bne.n	8007ee8 <__aeabi_ddiv+0x19c>
 8007ed2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8007ed6:	f47f af34 	bne.w	8007d42 <__aeabi_dmul+0x24a>
 8007eda:	ea95 0f0c 	teq	r5, ip
 8007ede:	f47f af25 	bne.w	8007d2c <__aeabi_dmul+0x234>
 8007ee2:	4610      	mov	r0, r2
 8007ee4:	4619      	mov	r1, r3
 8007ee6:	e72c      	b.n	8007d42 <__aeabi_dmul+0x24a>
 8007ee8:	ea95 0f0c 	teq	r5, ip
 8007eec:	d106      	bne.n	8007efc <__aeabi_ddiv+0x1b0>
 8007eee:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007ef2:	f43f aefd 	beq.w	8007cf0 <__aeabi_dmul+0x1f8>
 8007ef6:	4610      	mov	r0, r2
 8007ef8:	4619      	mov	r1, r3
 8007efa:	e722      	b.n	8007d42 <__aeabi_dmul+0x24a>
 8007efc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007f00:	bf18      	it	ne
 8007f02:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007f06:	f47f aec5 	bne.w	8007c94 <__aeabi_dmul+0x19c>
 8007f0a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8007f0e:	f47f af0d 	bne.w	8007d2c <__aeabi_dmul+0x234>
 8007f12:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8007f16:	f47f aeeb 	bne.w	8007cf0 <__aeabi_dmul+0x1f8>
 8007f1a:	e712      	b.n	8007d42 <__aeabi_dmul+0x24a>

08007f1c <__gedf2>:
 8007f1c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8007f20:	e006      	b.n	8007f30 <__cmpdf2+0x4>
 8007f22:	bf00      	nop

08007f24 <__ledf2>:
 8007f24:	f04f 0c01 	mov.w	ip, #1
 8007f28:	e002      	b.n	8007f30 <__cmpdf2+0x4>
 8007f2a:	bf00      	nop

08007f2c <__cmpdf2>:
 8007f2c:	f04f 0c01 	mov.w	ip, #1
 8007f30:	f84d cd04 	str.w	ip, [sp, #-4]!
 8007f34:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007f38:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007f3c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007f40:	bf18      	it	ne
 8007f42:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8007f46:	d01b      	beq.n	8007f80 <__cmpdf2+0x54>
 8007f48:	b001      	add	sp, #4
 8007f4a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8007f4e:	bf0c      	ite	eq
 8007f50:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8007f54:	ea91 0f03 	teqne	r1, r3
 8007f58:	bf02      	ittt	eq
 8007f5a:	ea90 0f02 	teqeq	r0, r2
 8007f5e:	2000      	moveq	r0, #0
 8007f60:	4770      	bxeq	lr
 8007f62:	f110 0f00 	cmn.w	r0, #0
 8007f66:	ea91 0f03 	teq	r1, r3
 8007f6a:	bf58      	it	pl
 8007f6c:	4299      	cmppl	r1, r3
 8007f6e:	bf08      	it	eq
 8007f70:	4290      	cmpeq	r0, r2
 8007f72:	bf2c      	ite	cs
 8007f74:	17d8      	asrcs	r0, r3, #31
 8007f76:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8007f7a:	f040 0001 	orr.w	r0, r0, #1
 8007f7e:	4770      	bx	lr
 8007f80:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007f84:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007f88:	d102      	bne.n	8007f90 <__cmpdf2+0x64>
 8007f8a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8007f8e:	d107      	bne.n	8007fa0 <__cmpdf2+0x74>
 8007f90:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007f94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007f98:	d1d6      	bne.n	8007f48 <__cmpdf2+0x1c>
 8007f9a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8007f9e:	d0d3      	beq.n	8007f48 <__cmpdf2+0x1c>
 8007fa0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8007fa4:	4770      	bx	lr
 8007fa6:	bf00      	nop

08007fa8 <__aeabi_cdrcmple>:
 8007fa8:	4684      	mov	ip, r0
 8007faa:	4610      	mov	r0, r2
 8007fac:	4662      	mov	r2, ip
 8007fae:	468c      	mov	ip, r1
 8007fb0:	4619      	mov	r1, r3
 8007fb2:	4663      	mov	r3, ip
 8007fb4:	e000      	b.n	8007fb8 <__aeabi_cdcmpeq>
 8007fb6:	bf00      	nop

08007fb8 <__aeabi_cdcmpeq>:
 8007fb8:	b501      	push	{r0, lr}
 8007fba:	f7ff ffb7 	bl	8007f2c <__cmpdf2>
 8007fbe:	2800      	cmp	r0, #0
 8007fc0:	bf48      	it	mi
 8007fc2:	f110 0f00 	cmnmi.w	r0, #0
 8007fc6:	bd01      	pop	{r0, pc}

08007fc8 <__aeabi_dcmpeq>:
 8007fc8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007fcc:	f7ff fff4 	bl	8007fb8 <__aeabi_cdcmpeq>
 8007fd0:	bf0c      	ite	eq
 8007fd2:	2001      	moveq	r0, #1
 8007fd4:	2000      	movne	r0, #0
 8007fd6:	f85d fb08 	ldr.w	pc, [sp], #8
 8007fda:	bf00      	nop

08007fdc <__aeabi_dcmplt>:
 8007fdc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007fe0:	f7ff ffea 	bl	8007fb8 <__aeabi_cdcmpeq>
 8007fe4:	bf34      	ite	cc
 8007fe6:	2001      	movcc	r0, #1
 8007fe8:	2000      	movcs	r0, #0
 8007fea:	f85d fb08 	ldr.w	pc, [sp], #8
 8007fee:	bf00      	nop

08007ff0 <__aeabi_dcmple>:
 8007ff0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007ff4:	f7ff ffe0 	bl	8007fb8 <__aeabi_cdcmpeq>
 8007ff8:	bf94      	ite	ls
 8007ffa:	2001      	movls	r0, #1
 8007ffc:	2000      	movhi	r0, #0
 8007ffe:	f85d fb08 	ldr.w	pc, [sp], #8
 8008002:	bf00      	nop

08008004 <__aeabi_dcmpge>:
 8008004:	f84d ed08 	str.w	lr, [sp, #-8]!
 8008008:	f7ff ffce 	bl	8007fa8 <__aeabi_cdrcmple>
 800800c:	bf94      	ite	ls
 800800e:	2001      	movls	r0, #1
 8008010:	2000      	movhi	r0, #0
 8008012:	f85d fb08 	ldr.w	pc, [sp], #8
 8008016:	bf00      	nop

08008018 <__aeabi_dcmpgt>:
 8008018:	f84d ed08 	str.w	lr, [sp, #-8]!
 800801c:	f7ff ffc4 	bl	8007fa8 <__aeabi_cdrcmple>
 8008020:	bf34      	ite	cc
 8008022:	2001      	movcc	r0, #1
 8008024:	2000      	movcs	r0, #0
 8008026:	f85d fb08 	ldr.w	pc, [sp], #8
 800802a:	bf00      	nop

0800802c <__aeabi_dcmpun>:
 800802c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8008030:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8008034:	d102      	bne.n	800803c <__aeabi_dcmpun+0x10>
 8008036:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800803a:	d10a      	bne.n	8008052 <__aeabi_dcmpun+0x26>
 800803c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8008040:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8008044:	d102      	bne.n	800804c <__aeabi_dcmpun+0x20>
 8008046:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800804a:	d102      	bne.n	8008052 <__aeabi_dcmpun+0x26>
 800804c:	f04f 0000 	mov.w	r0, #0
 8008050:	4770      	bx	lr
 8008052:	f04f 0001 	mov.w	r0, #1
 8008056:	4770      	bx	lr

08008058 <__aeabi_d2iz>:
 8008058:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800805c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8008060:	d215      	bcs.n	800808e <__aeabi_d2iz+0x36>
 8008062:	d511      	bpl.n	8008088 <__aeabi_d2iz+0x30>
 8008064:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8008068:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800806c:	d912      	bls.n	8008094 <__aeabi_d2iz+0x3c>
 800806e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8008072:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8008076:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800807a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800807e:	fa23 f002 	lsr.w	r0, r3, r2
 8008082:	bf18      	it	ne
 8008084:	4240      	negne	r0, r0
 8008086:	4770      	bx	lr
 8008088:	f04f 0000 	mov.w	r0, #0
 800808c:	4770      	bx	lr
 800808e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8008092:	d105      	bne.n	80080a0 <__aeabi_d2iz+0x48>
 8008094:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8008098:	bf08      	it	eq
 800809a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800809e:	4770      	bx	lr
 80080a0:	f04f 0000 	mov.w	r0, #0
 80080a4:	4770      	bx	lr
 80080a6:	bf00      	nop

080080a8 <__aeabi_d2uiz>:
 80080a8:	004a      	lsls	r2, r1, #1
 80080aa:	d211      	bcs.n	80080d0 <__aeabi_d2uiz+0x28>
 80080ac:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80080b0:	d211      	bcs.n	80080d6 <__aeabi_d2uiz+0x2e>
 80080b2:	d50d      	bpl.n	80080d0 <__aeabi_d2uiz+0x28>
 80080b4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80080b8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80080bc:	d40e      	bmi.n	80080dc <__aeabi_d2uiz+0x34>
 80080be:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80080c2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80080c6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80080ca:	fa23 f002 	lsr.w	r0, r3, r2
 80080ce:	4770      	bx	lr
 80080d0:	f04f 0000 	mov.w	r0, #0
 80080d4:	4770      	bx	lr
 80080d6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80080da:	d102      	bne.n	80080e2 <__aeabi_d2uiz+0x3a>
 80080dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80080e0:	4770      	bx	lr
 80080e2:	f04f 0000 	mov.w	r0, #0
 80080e6:	4770      	bx	lr

080080e8 <__aeabi_d2f>:
 80080e8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80080ec:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80080f0:	bf24      	itt	cs
 80080f2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80080f6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80080fa:	d90d      	bls.n	8008118 <__aeabi_d2f+0x30>
 80080fc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8008100:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8008104:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8008108:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 800810c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8008110:	bf08      	it	eq
 8008112:	f020 0001 	biceq.w	r0, r0, #1
 8008116:	4770      	bx	lr
 8008118:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 800811c:	d121      	bne.n	8008162 <__aeabi_d2f+0x7a>
 800811e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8008122:	bfbc      	itt	lt
 8008124:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8008128:	4770      	bxlt	lr
 800812a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800812e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8008132:	f1c2 0218 	rsb	r2, r2, #24
 8008136:	f1c2 0c20 	rsb	ip, r2, #32
 800813a:	fa10 f30c 	lsls.w	r3, r0, ip
 800813e:	fa20 f002 	lsr.w	r0, r0, r2
 8008142:	bf18      	it	ne
 8008144:	f040 0001 	orrne.w	r0, r0, #1
 8008148:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800814c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8008150:	fa03 fc0c 	lsl.w	ip, r3, ip
 8008154:	ea40 000c 	orr.w	r0, r0, ip
 8008158:	fa23 f302 	lsr.w	r3, r3, r2
 800815c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8008160:	e7cc      	b.n	80080fc <__aeabi_d2f+0x14>
 8008162:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8008166:	d107      	bne.n	8008178 <__aeabi_d2f+0x90>
 8008168:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800816c:	bf1e      	ittt	ne
 800816e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8008172:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8008176:	4770      	bxne	lr
 8008178:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 800817c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8008180:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8008184:	4770      	bx	lr
 8008186:	bf00      	nop

08008188 <__aeabi_frsub>:
 8008188:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 800818c:	e002      	b.n	8008194 <__addsf3>
 800818e:	bf00      	nop

08008190 <__aeabi_fsub>:
 8008190:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08008194 <__addsf3>:
 8008194:	0042      	lsls	r2, r0, #1
 8008196:	bf1f      	itttt	ne
 8008198:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 800819c:	ea92 0f03 	teqne	r2, r3
 80081a0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80081a4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80081a8:	d06a      	beq.n	8008280 <__addsf3+0xec>
 80081aa:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80081ae:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80081b2:	bfc1      	itttt	gt
 80081b4:	18d2      	addgt	r2, r2, r3
 80081b6:	4041      	eorgt	r1, r0
 80081b8:	4048      	eorgt	r0, r1
 80081ba:	4041      	eorgt	r1, r0
 80081bc:	bfb8      	it	lt
 80081be:	425b      	neglt	r3, r3
 80081c0:	2b19      	cmp	r3, #25
 80081c2:	bf88      	it	hi
 80081c4:	4770      	bxhi	lr
 80081c6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80081ca:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80081ce:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80081d2:	bf18      	it	ne
 80081d4:	4240      	negne	r0, r0
 80081d6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80081da:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80081de:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80081e2:	bf18      	it	ne
 80081e4:	4249      	negne	r1, r1
 80081e6:	ea92 0f03 	teq	r2, r3
 80081ea:	d03f      	beq.n	800826c <__addsf3+0xd8>
 80081ec:	f1a2 0201 	sub.w	r2, r2, #1
 80081f0:	fa41 fc03 	asr.w	ip, r1, r3
 80081f4:	eb10 000c 	adds.w	r0, r0, ip
 80081f8:	f1c3 0320 	rsb	r3, r3, #32
 80081fc:	fa01 f103 	lsl.w	r1, r1, r3
 8008200:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8008204:	d502      	bpl.n	800820c <__addsf3+0x78>
 8008206:	4249      	negs	r1, r1
 8008208:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800820c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8008210:	d313      	bcc.n	800823a <__addsf3+0xa6>
 8008212:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8008216:	d306      	bcc.n	8008226 <__addsf3+0x92>
 8008218:	0840      	lsrs	r0, r0, #1
 800821a:	ea4f 0131 	mov.w	r1, r1, rrx
 800821e:	f102 0201 	add.w	r2, r2, #1
 8008222:	2afe      	cmp	r2, #254	; 0xfe
 8008224:	d251      	bcs.n	80082ca <__addsf3+0x136>
 8008226:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800822a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800822e:	bf08      	it	eq
 8008230:	f020 0001 	biceq.w	r0, r0, #1
 8008234:	ea40 0003 	orr.w	r0, r0, r3
 8008238:	4770      	bx	lr
 800823a:	0049      	lsls	r1, r1, #1
 800823c:	eb40 0000 	adc.w	r0, r0, r0
 8008240:	3a01      	subs	r2, #1
 8008242:	bf28      	it	cs
 8008244:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8008248:	d2ed      	bcs.n	8008226 <__addsf3+0x92>
 800824a:	fab0 fc80 	clz	ip, r0
 800824e:	f1ac 0c08 	sub.w	ip, ip, #8
 8008252:	ebb2 020c 	subs.w	r2, r2, ip
 8008256:	fa00 f00c 	lsl.w	r0, r0, ip
 800825a:	bfaa      	itet	ge
 800825c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8008260:	4252      	neglt	r2, r2
 8008262:	4318      	orrge	r0, r3
 8008264:	bfbc      	itt	lt
 8008266:	40d0      	lsrlt	r0, r2
 8008268:	4318      	orrlt	r0, r3
 800826a:	4770      	bx	lr
 800826c:	f092 0f00 	teq	r2, #0
 8008270:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8008274:	bf06      	itte	eq
 8008276:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 800827a:	3201      	addeq	r2, #1
 800827c:	3b01      	subne	r3, #1
 800827e:	e7b5      	b.n	80081ec <__addsf3+0x58>
 8008280:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8008284:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8008288:	bf18      	it	ne
 800828a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800828e:	d021      	beq.n	80082d4 <__addsf3+0x140>
 8008290:	ea92 0f03 	teq	r2, r3
 8008294:	d004      	beq.n	80082a0 <__addsf3+0x10c>
 8008296:	f092 0f00 	teq	r2, #0
 800829a:	bf08      	it	eq
 800829c:	4608      	moveq	r0, r1
 800829e:	4770      	bx	lr
 80082a0:	ea90 0f01 	teq	r0, r1
 80082a4:	bf1c      	itt	ne
 80082a6:	2000      	movne	r0, #0
 80082a8:	4770      	bxne	lr
 80082aa:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80082ae:	d104      	bne.n	80082ba <__addsf3+0x126>
 80082b0:	0040      	lsls	r0, r0, #1
 80082b2:	bf28      	it	cs
 80082b4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80082b8:	4770      	bx	lr
 80082ba:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80082be:	bf3c      	itt	cc
 80082c0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80082c4:	4770      	bxcc	lr
 80082c6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80082ca:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80082ce:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80082d2:	4770      	bx	lr
 80082d4:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80082d8:	bf16      	itet	ne
 80082da:	4608      	movne	r0, r1
 80082dc:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80082e0:	4601      	movne	r1, r0
 80082e2:	0242      	lsls	r2, r0, #9
 80082e4:	bf06      	itte	eq
 80082e6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80082ea:	ea90 0f01 	teqeq	r0, r1
 80082ee:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80082f2:	4770      	bx	lr

080082f4 <__aeabi_ui2f>:
 80082f4:	f04f 0300 	mov.w	r3, #0
 80082f8:	e004      	b.n	8008304 <__aeabi_i2f+0x8>
 80082fa:	bf00      	nop

080082fc <__aeabi_i2f>:
 80082fc:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8008300:	bf48      	it	mi
 8008302:	4240      	negmi	r0, r0
 8008304:	ea5f 0c00 	movs.w	ip, r0
 8008308:	bf08      	it	eq
 800830a:	4770      	bxeq	lr
 800830c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8008310:	4601      	mov	r1, r0
 8008312:	f04f 0000 	mov.w	r0, #0
 8008316:	e01c      	b.n	8008352 <__aeabi_l2f+0x2a>

08008318 <__aeabi_ul2f>:
 8008318:	ea50 0201 	orrs.w	r2, r0, r1
 800831c:	bf08      	it	eq
 800831e:	4770      	bxeq	lr
 8008320:	f04f 0300 	mov.w	r3, #0
 8008324:	e00a      	b.n	800833c <__aeabi_l2f+0x14>
 8008326:	bf00      	nop

08008328 <__aeabi_l2f>:
 8008328:	ea50 0201 	orrs.w	r2, r0, r1
 800832c:	bf08      	it	eq
 800832e:	4770      	bxeq	lr
 8008330:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8008334:	d502      	bpl.n	800833c <__aeabi_l2f+0x14>
 8008336:	4240      	negs	r0, r0
 8008338:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800833c:	ea5f 0c01 	movs.w	ip, r1
 8008340:	bf02      	ittt	eq
 8008342:	4684      	moveq	ip, r0
 8008344:	4601      	moveq	r1, r0
 8008346:	2000      	moveq	r0, #0
 8008348:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 800834c:	bf08      	it	eq
 800834e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8008352:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8008356:	fabc f28c 	clz	r2, ip
 800835a:	3a08      	subs	r2, #8
 800835c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8008360:	db10      	blt.n	8008384 <__aeabi_l2f+0x5c>
 8008362:	fa01 fc02 	lsl.w	ip, r1, r2
 8008366:	4463      	add	r3, ip
 8008368:	fa00 fc02 	lsl.w	ip, r0, r2
 800836c:	f1c2 0220 	rsb	r2, r2, #32
 8008370:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8008374:	fa20 f202 	lsr.w	r2, r0, r2
 8008378:	eb43 0002 	adc.w	r0, r3, r2
 800837c:	bf08      	it	eq
 800837e:	f020 0001 	biceq.w	r0, r0, #1
 8008382:	4770      	bx	lr
 8008384:	f102 0220 	add.w	r2, r2, #32
 8008388:	fa01 fc02 	lsl.w	ip, r1, r2
 800838c:	f1c2 0220 	rsb	r2, r2, #32
 8008390:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8008394:	fa21 f202 	lsr.w	r2, r1, r2
 8008398:	eb43 0002 	adc.w	r0, r3, r2
 800839c:	bf08      	it	eq
 800839e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80083a2:	4770      	bx	lr

080083a4 <__aeabi_ldivmod>:
 80083a4:	b97b      	cbnz	r3, 80083c6 <__aeabi_ldivmod+0x22>
 80083a6:	b972      	cbnz	r2, 80083c6 <__aeabi_ldivmod+0x22>
 80083a8:	2900      	cmp	r1, #0
 80083aa:	bfbe      	ittt	lt
 80083ac:	2000      	movlt	r0, #0
 80083ae:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80083b2:	e006      	blt.n	80083c2 <__aeabi_ldivmod+0x1e>
 80083b4:	bf08      	it	eq
 80083b6:	2800      	cmpeq	r0, #0
 80083b8:	bf1c      	itt	ne
 80083ba:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 80083be:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80083c2:	f000 b9ef 	b.w	80087a4 <__aeabi_idiv0>
 80083c6:	f1ad 0c08 	sub.w	ip, sp, #8
 80083ca:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80083ce:	2900      	cmp	r1, #0
 80083d0:	db09      	blt.n	80083e6 <__aeabi_ldivmod+0x42>
 80083d2:	2b00      	cmp	r3, #0
 80083d4:	db1a      	blt.n	800840c <__aeabi_ldivmod+0x68>
 80083d6:	f000 f883 	bl	80084e0 <__udivmoddi4>
 80083da:	f8dd e004 	ldr.w	lr, [sp, #4]
 80083de:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80083e2:	b004      	add	sp, #16
 80083e4:	4770      	bx	lr
 80083e6:	4240      	negs	r0, r0
 80083e8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80083ec:	2b00      	cmp	r3, #0
 80083ee:	db1b      	blt.n	8008428 <__aeabi_ldivmod+0x84>
 80083f0:	f000 f876 	bl	80084e0 <__udivmoddi4>
 80083f4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80083f8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80083fc:	b004      	add	sp, #16
 80083fe:	4240      	negs	r0, r0
 8008400:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8008404:	4252      	negs	r2, r2
 8008406:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800840a:	4770      	bx	lr
 800840c:	4252      	negs	r2, r2
 800840e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8008412:	f000 f865 	bl	80084e0 <__udivmoddi4>
 8008416:	f8dd e004 	ldr.w	lr, [sp, #4]
 800841a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800841e:	b004      	add	sp, #16
 8008420:	4240      	negs	r0, r0
 8008422:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8008426:	4770      	bx	lr
 8008428:	4252      	negs	r2, r2
 800842a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800842e:	f000 f857 	bl	80084e0 <__udivmoddi4>
 8008432:	f8dd e004 	ldr.w	lr, [sp, #4]
 8008436:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800843a:	b004      	add	sp, #16
 800843c:	4252      	negs	r2, r2
 800843e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8008442:	4770      	bx	lr

08008444 <__aeabi_uldivmod>:
 8008444:	b953      	cbnz	r3, 800845c <__aeabi_uldivmod+0x18>
 8008446:	b94a      	cbnz	r2, 800845c <__aeabi_uldivmod+0x18>
 8008448:	2900      	cmp	r1, #0
 800844a:	bf08      	it	eq
 800844c:	2800      	cmpeq	r0, #0
 800844e:	bf1c      	itt	ne
 8008450:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8008454:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8008458:	f000 b9a4 	b.w	80087a4 <__aeabi_idiv0>
 800845c:	f1ad 0c08 	sub.w	ip, sp, #8
 8008460:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8008464:	f000 f83c 	bl	80084e0 <__udivmoddi4>
 8008468:	f8dd e004 	ldr.w	lr, [sp, #4]
 800846c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008470:	b004      	add	sp, #16
 8008472:	4770      	bx	lr

08008474 <__aeabi_d2lz>:
 8008474:	b538      	push	{r3, r4, r5, lr}
 8008476:	2200      	movs	r2, #0
 8008478:	2300      	movs	r3, #0
 800847a:	4604      	mov	r4, r0
 800847c:	460d      	mov	r5, r1
 800847e:	f7ff fdad 	bl	8007fdc <__aeabi_dcmplt>
 8008482:	b928      	cbnz	r0, 8008490 <__aeabi_d2lz+0x1c>
 8008484:	4620      	mov	r0, r4
 8008486:	4629      	mov	r1, r5
 8008488:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800848c:	f000 b80a 	b.w	80084a4 <__aeabi_d2ulz>
 8008490:	4620      	mov	r0, r4
 8008492:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 8008496:	f000 f805 	bl	80084a4 <__aeabi_d2ulz>
 800849a:	4240      	negs	r0, r0
 800849c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80084a0:	bd38      	pop	{r3, r4, r5, pc}
 80084a2:	bf00      	nop

080084a4 <__aeabi_d2ulz>:
 80084a4:	b5d0      	push	{r4, r6, r7, lr}
 80084a6:	4b0c      	ldr	r3, [pc, #48]	; (80084d8 <__aeabi_d2ulz+0x34>)
 80084a8:	2200      	movs	r2, #0
 80084aa:	4606      	mov	r6, r0
 80084ac:	460f      	mov	r7, r1
 80084ae:	f7ff fb23 	bl	8007af8 <__aeabi_dmul>
 80084b2:	f7ff fdf9 	bl	80080a8 <__aeabi_d2uiz>
 80084b6:	4604      	mov	r4, r0
 80084b8:	f7ff faa4 	bl	8007a04 <__aeabi_ui2d>
 80084bc:	4b07      	ldr	r3, [pc, #28]	; (80084dc <__aeabi_d2ulz+0x38>)
 80084be:	2200      	movs	r2, #0
 80084c0:	f7ff fb1a 	bl	8007af8 <__aeabi_dmul>
 80084c4:	4602      	mov	r2, r0
 80084c6:	460b      	mov	r3, r1
 80084c8:	4630      	mov	r0, r6
 80084ca:	4639      	mov	r1, r7
 80084cc:	f7ff f95c 	bl	8007788 <__aeabi_dsub>
 80084d0:	f7ff fdea 	bl	80080a8 <__aeabi_d2uiz>
 80084d4:	4621      	mov	r1, r4
 80084d6:	bdd0      	pop	{r4, r6, r7, pc}
 80084d8:	3df00000 	.word	0x3df00000
 80084dc:	41f00000 	.word	0x41f00000

080084e0 <__udivmoddi4>:
 80084e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80084e4:	9d08      	ldr	r5, [sp, #32]
 80084e6:	4604      	mov	r4, r0
 80084e8:	468c      	mov	ip, r1
 80084ea:	2b00      	cmp	r3, #0
 80084ec:	f040 8083 	bne.w	80085f6 <__udivmoddi4+0x116>
 80084f0:	428a      	cmp	r2, r1
 80084f2:	4617      	mov	r7, r2
 80084f4:	d947      	bls.n	8008586 <__udivmoddi4+0xa6>
 80084f6:	fab2 f282 	clz	r2, r2
 80084fa:	b142      	cbz	r2, 800850e <__udivmoddi4+0x2e>
 80084fc:	f1c2 0020 	rsb	r0, r2, #32
 8008500:	fa24 f000 	lsr.w	r0, r4, r0
 8008504:	4091      	lsls	r1, r2
 8008506:	4097      	lsls	r7, r2
 8008508:	ea40 0c01 	orr.w	ip, r0, r1
 800850c:	4094      	lsls	r4, r2
 800850e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8008512:	0c23      	lsrs	r3, r4, #16
 8008514:	fbbc f6f8 	udiv	r6, ip, r8
 8008518:	fa1f fe87 	uxth.w	lr, r7
 800851c:	fb08 c116 	mls	r1, r8, r6, ip
 8008520:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8008524:	fb06 f10e 	mul.w	r1, r6, lr
 8008528:	4299      	cmp	r1, r3
 800852a:	d909      	bls.n	8008540 <__udivmoddi4+0x60>
 800852c:	18fb      	adds	r3, r7, r3
 800852e:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
 8008532:	f080 8119 	bcs.w	8008768 <__udivmoddi4+0x288>
 8008536:	4299      	cmp	r1, r3
 8008538:	f240 8116 	bls.w	8008768 <__udivmoddi4+0x288>
 800853c:	3e02      	subs	r6, #2
 800853e:	443b      	add	r3, r7
 8008540:	1a5b      	subs	r3, r3, r1
 8008542:	b2a4      	uxth	r4, r4
 8008544:	fbb3 f0f8 	udiv	r0, r3, r8
 8008548:	fb08 3310 	mls	r3, r8, r0, r3
 800854c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8008550:	fb00 fe0e 	mul.w	lr, r0, lr
 8008554:	45a6      	cmp	lr, r4
 8008556:	d909      	bls.n	800856c <__udivmoddi4+0x8c>
 8008558:	193c      	adds	r4, r7, r4
 800855a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800855e:	f080 8105 	bcs.w	800876c <__udivmoddi4+0x28c>
 8008562:	45a6      	cmp	lr, r4
 8008564:	f240 8102 	bls.w	800876c <__udivmoddi4+0x28c>
 8008568:	3802      	subs	r0, #2
 800856a:	443c      	add	r4, r7
 800856c:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8008570:	eba4 040e 	sub.w	r4, r4, lr
 8008574:	2600      	movs	r6, #0
 8008576:	b11d      	cbz	r5, 8008580 <__udivmoddi4+0xa0>
 8008578:	40d4      	lsrs	r4, r2
 800857a:	2300      	movs	r3, #0
 800857c:	e9c5 4300 	strd	r4, r3, [r5]
 8008580:	4631      	mov	r1, r6
 8008582:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008586:	b902      	cbnz	r2, 800858a <__udivmoddi4+0xaa>
 8008588:	deff      	udf	#255	; 0xff
 800858a:	fab2 f282 	clz	r2, r2
 800858e:	2a00      	cmp	r2, #0
 8008590:	d150      	bne.n	8008634 <__udivmoddi4+0x154>
 8008592:	1bcb      	subs	r3, r1, r7
 8008594:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008598:	fa1f f887 	uxth.w	r8, r7
 800859c:	2601      	movs	r6, #1
 800859e:	fbb3 fcfe 	udiv	ip, r3, lr
 80085a2:	0c21      	lsrs	r1, r4, #16
 80085a4:	fb0e 331c 	mls	r3, lr, ip, r3
 80085a8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80085ac:	fb08 f30c 	mul.w	r3, r8, ip
 80085b0:	428b      	cmp	r3, r1
 80085b2:	d907      	bls.n	80085c4 <__udivmoddi4+0xe4>
 80085b4:	1879      	adds	r1, r7, r1
 80085b6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80085ba:	d202      	bcs.n	80085c2 <__udivmoddi4+0xe2>
 80085bc:	428b      	cmp	r3, r1
 80085be:	f200 80e9 	bhi.w	8008794 <__udivmoddi4+0x2b4>
 80085c2:	4684      	mov	ip, r0
 80085c4:	1ac9      	subs	r1, r1, r3
 80085c6:	b2a3      	uxth	r3, r4
 80085c8:	fbb1 f0fe 	udiv	r0, r1, lr
 80085cc:	fb0e 1110 	mls	r1, lr, r0, r1
 80085d0:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 80085d4:	fb08 f800 	mul.w	r8, r8, r0
 80085d8:	45a0      	cmp	r8, r4
 80085da:	d907      	bls.n	80085ec <__udivmoddi4+0x10c>
 80085dc:	193c      	adds	r4, r7, r4
 80085de:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80085e2:	d202      	bcs.n	80085ea <__udivmoddi4+0x10a>
 80085e4:	45a0      	cmp	r8, r4
 80085e6:	f200 80d9 	bhi.w	800879c <__udivmoddi4+0x2bc>
 80085ea:	4618      	mov	r0, r3
 80085ec:	eba4 0408 	sub.w	r4, r4, r8
 80085f0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80085f4:	e7bf      	b.n	8008576 <__udivmoddi4+0x96>
 80085f6:	428b      	cmp	r3, r1
 80085f8:	d909      	bls.n	800860e <__udivmoddi4+0x12e>
 80085fa:	2d00      	cmp	r5, #0
 80085fc:	f000 80b1 	beq.w	8008762 <__udivmoddi4+0x282>
 8008600:	2600      	movs	r6, #0
 8008602:	e9c5 0100 	strd	r0, r1, [r5]
 8008606:	4630      	mov	r0, r6
 8008608:	4631      	mov	r1, r6
 800860a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800860e:	fab3 f683 	clz	r6, r3
 8008612:	2e00      	cmp	r6, #0
 8008614:	d14a      	bne.n	80086ac <__udivmoddi4+0x1cc>
 8008616:	428b      	cmp	r3, r1
 8008618:	d302      	bcc.n	8008620 <__udivmoddi4+0x140>
 800861a:	4282      	cmp	r2, r0
 800861c:	f200 80b8 	bhi.w	8008790 <__udivmoddi4+0x2b0>
 8008620:	1a84      	subs	r4, r0, r2
 8008622:	eb61 0103 	sbc.w	r1, r1, r3
 8008626:	2001      	movs	r0, #1
 8008628:	468c      	mov	ip, r1
 800862a:	2d00      	cmp	r5, #0
 800862c:	d0a8      	beq.n	8008580 <__udivmoddi4+0xa0>
 800862e:	e9c5 4c00 	strd	r4, ip, [r5]
 8008632:	e7a5      	b.n	8008580 <__udivmoddi4+0xa0>
 8008634:	f1c2 0320 	rsb	r3, r2, #32
 8008638:	fa20 f603 	lsr.w	r6, r0, r3
 800863c:	4097      	lsls	r7, r2
 800863e:	fa01 f002 	lsl.w	r0, r1, r2
 8008642:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8008646:	40d9      	lsrs	r1, r3
 8008648:	4330      	orrs	r0, r6
 800864a:	0c03      	lsrs	r3, r0, #16
 800864c:	fbb1 f6fe 	udiv	r6, r1, lr
 8008650:	fa1f f887 	uxth.w	r8, r7
 8008654:	fb0e 1116 	mls	r1, lr, r6, r1
 8008658:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800865c:	fb06 f108 	mul.w	r1, r6, r8
 8008660:	4299      	cmp	r1, r3
 8008662:	fa04 f402 	lsl.w	r4, r4, r2
 8008666:	d909      	bls.n	800867c <__udivmoddi4+0x19c>
 8008668:	18fb      	adds	r3, r7, r3
 800866a:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
 800866e:	f080 808d 	bcs.w	800878c <__udivmoddi4+0x2ac>
 8008672:	4299      	cmp	r1, r3
 8008674:	f240 808a 	bls.w	800878c <__udivmoddi4+0x2ac>
 8008678:	3e02      	subs	r6, #2
 800867a:	443b      	add	r3, r7
 800867c:	1a5b      	subs	r3, r3, r1
 800867e:	b281      	uxth	r1, r0
 8008680:	fbb3 f0fe 	udiv	r0, r3, lr
 8008684:	fb0e 3310 	mls	r3, lr, r0, r3
 8008688:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800868c:	fb00 f308 	mul.w	r3, r0, r8
 8008690:	428b      	cmp	r3, r1
 8008692:	d907      	bls.n	80086a4 <__udivmoddi4+0x1c4>
 8008694:	1879      	adds	r1, r7, r1
 8008696:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 800869a:	d273      	bcs.n	8008784 <__udivmoddi4+0x2a4>
 800869c:	428b      	cmp	r3, r1
 800869e:	d971      	bls.n	8008784 <__udivmoddi4+0x2a4>
 80086a0:	3802      	subs	r0, #2
 80086a2:	4439      	add	r1, r7
 80086a4:	1acb      	subs	r3, r1, r3
 80086a6:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 80086aa:	e778      	b.n	800859e <__udivmoddi4+0xbe>
 80086ac:	f1c6 0c20 	rsb	ip, r6, #32
 80086b0:	fa03 f406 	lsl.w	r4, r3, r6
 80086b4:	fa22 f30c 	lsr.w	r3, r2, ip
 80086b8:	431c      	orrs	r4, r3
 80086ba:	fa20 f70c 	lsr.w	r7, r0, ip
 80086be:	fa01 f306 	lsl.w	r3, r1, r6
 80086c2:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 80086c6:	fa21 f10c 	lsr.w	r1, r1, ip
 80086ca:	431f      	orrs	r7, r3
 80086cc:	0c3b      	lsrs	r3, r7, #16
 80086ce:	fbb1 f9fe 	udiv	r9, r1, lr
 80086d2:	fa1f f884 	uxth.w	r8, r4
 80086d6:	fb0e 1119 	mls	r1, lr, r9, r1
 80086da:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80086de:	fb09 fa08 	mul.w	sl, r9, r8
 80086e2:	458a      	cmp	sl, r1
 80086e4:	fa02 f206 	lsl.w	r2, r2, r6
 80086e8:	fa00 f306 	lsl.w	r3, r0, r6
 80086ec:	d908      	bls.n	8008700 <__udivmoddi4+0x220>
 80086ee:	1861      	adds	r1, r4, r1
 80086f0:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80086f4:	d248      	bcs.n	8008788 <__udivmoddi4+0x2a8>
 80086f6:	458a      	cmp	sl, r1
 80086f8:	d946      	bls.n	8008788 <__udivmoddi4+0x2a8>
 80086fa:	f1a9 0902 	sub.w	r9, r9, #2
 80086fe:	4421      	add	r1, r4
 8008700:	eba1 010a 	sub.w	r1, r1, sl
 8008704:	b2bf      	uxth	r7, r7
 8008706:	fbb1 f0fe 	udiv	r0, r1, lr
 800870a:	fb0e 1110 	mls	r1, lr, r0, r1
 800870e:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8008712:	fb00 f808 	mul.w	r8, r0, r8
 8008716:	45b8      	cmp	r8, r7
 8008718:	d907      	bls.n	800872a <__udivmoddi4+0x24a>
 800871a:	19e7      	adds	r7, r4, r7
 800871c:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 8008720:	d22e      	bcs.n	8008780 <__udivmoddi4+0x2a0>
 8008722:	45b8      	cmp	r8, r7
 8008724:	d92c      	bls.n	8008780 <__udivmoddi4+0x2a0>
 8008726:	3802      	subs	r0, #2
 8008728:	4427      	add	r7, r4
 800872a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800872e:	eba7 0708 	sub.w	r7, r7, r8
 8008732:	fba0 8902 	umull	r8, r9, r0, r2
 8008736:	454f      	cmp	r7, r9
 8008738:	46c6      	mov	lr, r8
 800873a:	4649      	mov	r1, r9
 800873c:	d31a      	bcc.n	8008774 <__udivmoddi4+0x294>
 800873e:	d017      	beq.n	8008770 <__udivmoddi4+0x290>
 8008740:	b15d      	cbz	r5, 800875a <__udivmoddi4+0x27a>
 8008742:	ebb3 020e 	subs.w	r2, r3, lr
 8008746:	eb67 0701 	sbc.w	r7, r7, r1
 800874a:	fa07 fc0c 	lsl.w	ip, r7, ip
 800874e:	40f2      	lsrs	r2, r6
 8008750:	ea4c 0202 	orr.w	r2, ip, r2
 8008754:	40f7      	lsrs	r7, r6
 8008756:	e9c5 2700 	strd	r2, r7, [r5]
 800875a:	2600      	movs	r6, #0
 800875c:	4631      	mov	r1, r6
 800875e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008762:	462e      	mov	r6, r5
 8008764:	4628      	mov	r0, r5
 8008766:	e70b      	b.n	8008580 <__udivmoddi4+0xa0>
 8008768:	4606      	mov	r6, r0
 800876a:	e6e9      	b.n	8008540 <__udivmoddi4+0x60>
 800876c:	4618      	mov	r0, r3
 800876e:	e6fd      	b.n	800856c <__udivmoddi4+0x8c>
 8008770:	4543      	cmp	r3, r8
 8008772:	d2e5      	bcs.n	8008740 <__udivmoddi4+0x260>
 8008774:	ebb8 0e02 	subs.w	lr, r8, r2
 8008778:	eb69 0104 	sbc.w	r1, r9, r4
 800877c:	3801      	subs	r0, #1
 800877e:	e7df      	b.n	8008740 <__udivmoddi4+0x260>
 8008780:	4608      	mov	r0, r1
 8008782:	e7d2      	b.n	800872a <__udivmoddi4+0x24a>
 8008784:	4660      	mov	r0, ip
 8008786:	e78d      	b.n	80086a4 <__udivmoddi4+0x1c4>
 8008788:	4681      	mov	r9, r0
 800878a:	e7b9      	b.n	8008700 <__udivmoddi4+0x220>
 800878c:	4666      	mov	r6, ip
 800878e:	e775      	b.n	800867c <__udivmoddi4+0x19c>
 8008790:	4630      	mov	r0, r6
 8008792:	e74a      	b.n	800862a <__udivmoddi4+0x14a>
 8008794:	f1ac 0c02 	sub.w	ip, ip, #2
 8008798:	4439      	add	r1, r7
 800879a:	e713      	b.n	80085c4 <__udivmoddi4+0xe4>
 800879c:	3802      	subs	r0, #2
 800879e:	443c      	add	r4, r7
 80087a0:	e724      	b.n	80085ec <__udivmoddi4+0x10c>
 80087a2:	bf00      	nop

080087a4 <__aeabi_idiv0>:
 80087a4:	4770      	bx	lr
 80087a6:	bf00      	nop

080087a8 <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
 80087a8:	b480      	push	{r7}
 80087aa:	b085      	sub	sp, #20
 80087ac:	af00      	add	r7, sp, #0
 80087ae:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 80087b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80087b4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80087b6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80087ba:	687b      	ldr	r3, [r7, #4]
 80087bc:	4313      	orrs	r3, r2
 80087be:	64cb      	str	r3, [r1, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80087c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80087c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80087c6:	687b      	ldr	r3, [r7, #4]
 80087c8:	4013      	ands	r3, r2
 80087ca:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80087cc:	68fb      	ldr	r3, [r7, #12]
}
 80087ce:	bf00      	nop
 80087d0:	3714      	adds	r7, #20
 80087d2:	46bd      	mov	sp, r7
 80087d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087d8:	4770      	bx	lr
	...

080087dc <MX_ADC1_Init>:
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 80087dc:	b580      	push	{r7, lr}
 80087de:	b086      	sub	sp, #24
 80087e0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 80087e2:	463b      	mov	r3, r7
 80087e4:	2200      	movs	r2, #0
 80087e6:	601a      	str	r2, [r3, #0]
 80087e8:	605a      	str	r2, [r3, #4]
 80087ea:	609a      	str	r2, [r3, #8]
 80087ec:	60da      	str	r2, [r3, #12]
 80087ee:	611a      	str	r2, [r3, #16]
 80087f0:	615a      	str	r2, [r3, #20]
  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Common config
  */
  hadc1.Instance = ADC1;
 80087f2:	4b2a      	ldr	r3, [pc, #168]	; (800889c <MX_ADC1_Init+0xc0>)
 80087f4:	4a2a      	ldr	r2, [pc, #168]	; (80088a0 <MX_ADC1_Init+0xc4>)
 80087f6:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV32;
 80087f8:	4b28      	ldr	r3, [pc, #160]	; (800889c <MX_ADC1_Init+0xc0>)
 80087fa:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80087fe:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_8B;
 8008800:	4b26      	ldr	r3, [pc, #152]	; (800889c <MX_ADC1_Init+0xc0>)
 8008802:	2210      	movs	r2, #16
 8008804:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8008806:	4b25      	ldr	r3, [pc, #148]	; (800889c <MX_ADC1_Init+0xc0>)
 8008808:	2200      	movs	r2, #0
 800880a:	60da      	str	r2, [r3, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 800880c:	4b23      	ldr	r3, [pc, #140]	; (800889c <MX_ADC1_Init+0xc0>)
 800880e:	2200      	movs	r2, #0
 8008810:	611a      	str	r2, [r3, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8008812:	4b22      	ldr	r3, [pc, #136]	; (800889c <MX_ADC1_Init+0xc0>)
 8008814:	2204      	movs	r2, #4
 8008816:	615a      	str	r2, [r3, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8008818:	4b20      	ldr	r3, [pc, #128]	; (800889c <MX_ADC1_Init+0xc0>)
 800881a:	2200      	movs	r2, #0
 800881c:	761a      	strb	r2, [r3, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 800881e:	4b1f      	ldr	r3, [pc, #124]	; (800889c <MX_ADC1_Init+0xc0>)
 8008820:	2200      	movs	r2, #0
 8008822:	765a      	strb	r2, [r3, #25]
  hadc1.Init.NbrOfConversion = 1;
 8008824:	4b1d      	ldr	r3, [pc, #116]	; (800889c <MX_ADC1_Init+0xc0>)
 8008826:	2201      	movs	r2, #1
 8008828:	61da      	str	r2, [r3, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 800882a:	4b1c      	ldr	r3, [pc, #112]	; (800889c <MX_ADC1_Init+0xc0>)
 800882c:	2200      	movs	r2, #0
 800882e:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T2_TRGO;
 8008832:	4b1a      	ldr	r3, [pc, #104]	; (800889c <MX_ADC1_Init+0xc0>)
 8008834:	f44f 62d8 	mov.w	r2, #1728	; 0x6c0
 8008838:	629a      	str	r2, [r3, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 800883a:	4b18      	ldr	r3, [pc, #96]	; (800889c <MX_ADC1_Init+0xc0>)
 800883c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8008840:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = ENABLE;
 8008842:	4b16      	ldr	r3, [pc, #88]	; (800889c <MX_ADC1_Init+0xc0>)
 8008844:	2201      	movs	r2, #1
 8008846:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 800884a:	4b14      	ldr	r3, [pc, #80]	; (800889c <MX_ADC1_Init+0xc0>)
 800884c:	2200      	movs	r2, #0
 800884e:	635a      	str	r2, [r3, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8008850:	4b12      	ldr	r3, [pc, #72]	; (800889c <MX_ADC1_Init+0xc0>)
 8008852:	2200      	movs	r2, #0
 8008854:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8008858:	4810      	ldr	r0, [pc, #64]	; (800889c <MX_ADC1_Init+0xc0>)
 800885a:	f004 fac5 	bl	800cde8 <HAL_ADC_Init>
 800885e:	4603      	mov	r3, r0
 8008860:	2b00      	cmp	r3, #0
 8008862:	d001      	beq.n	8008868 <MX_ADC1_Init+0x8c>
  {
    Error_Handler();
 8008864:	f002 fb42 	bl	800aeec <Error_Handler>
  }
  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_6;
 8008868:	4b0e      	ldr	r3, [pc, #56]	; (80088a4 <MX_ADC1_Init+0xc8>)
 800886a:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800886c:	2306      	movs	r3, #6
 800886e:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_247CYCLES_5;
 8008870:	2306      	movs	r3, #6
 8008872:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8008874:	237f      	movs	r3, #127	; 0x7f
 8008876:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8008878:	2304      	movs	r3, #4
 800887a:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 800887c:	2300      	movs	r3, #0
 800887e:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8008880:	463b      	mov	r3, r7
 8008882:	4619      	mov	r1, r3
 8008884:	4805      	ldr	r0, [pc, #20]	; (800889c <MX_ADC1_Init+0xc0>)
 8008886:	f004 fbfb 	bl	800d080 <HAL_ADC_ConfigChannel>
 800888a:	4603      	mov	r3, r0
 800888c:	2b00      	cmp	r3, #0
 800888e:	d001      	beq.n	8008894 <MX_ADC1_Init+0xb8>
  {
    Error_Handler();
 8008890:	f002 fb2c 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8008894:	bf00      	nop
 8008896:	3718      	adds	r7, #24
 8008898:	46bd      	mov	sp, r7
 800889a:	bd80      	pop	{r7, pc}
 800889c:	20011e8c 	.word	0x20011e8c
 80088a0:	50040000 	.word	0x50040000
 80088a4:	19200040 	.word	0x19200040

080088a8 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 80088a8:	b580      	push	{r7, lr}
 80088aa:	b088      	sub	sp, #32
 80088ac:	af00      	add	r7, sp, #0
 80088ae:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80088b0:	f107 030c 	add.w	r3, r7, #12
 80088b4:	2200      	movs	r2, #0
 80088b6:	601a      	str	r2, [r3, #0]
 80088b8:	605a      	str	r2, [r3, #4]
 80088ba:	609a      	str	r2, [r3, #8]
 80088bc:	60da      	str	r2, [r3, #12]
 80088be:	611a      	str	r2, [r3, #16]
  if(adcHandle->Instance==ADC1)
 80088c0:	687b      	ldr	r3, [r7, #4]
 80088c2:	681b      	ldr	r3, [r3, #0]
 80088c4:	4a21      	ldr	r2, [pc, #132]	; (800894c <HAL_ADC_MspInit+0xa4>)
 80088c6:	4293      	cmp	r3, r2
 80088c8:	d13c      	bne.n	8008944 <HAL_ADC_MspInit+0x9c>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 80088ca:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80088ce:	f7ff ff6b 	bl	80087a8 <LL_AHB2_GRP1_EnableClock>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80088d2:	2001      	movs	r0, #1
 80088d4:	f7ff ff68 	bl	80087a8 <LL_AHB2_GRP1_EnableClock>
    /**ADC1 GPIO Configuration
    PA1     ------> ADC1_IN6
    */
    GPIO_InitStruct.Pin = BLINK_SIG_Pin;
 80088d8:	2302      	movs	r3, #2
 80088da:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80088dc:	2303      	movs	r3, #3
 80088de:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80088e0:	2300      	movs	r3, #0
 80088e2:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(BLINK_SIG_GPIO_Port, &GPIO_InitStruct);
 80088e4:	f107 030c 	add.w	r3, r7, #12
 80088e8:	4619      	mov	r1, r3
 80088ea:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80088ee:	f005 fab3 	bl	800de58 <HAL_GPIO_Init>

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA1_Channel1;
 80088f2:	4b17      	ldr	r3, [pc, #92]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 80088f4:	4a17      	ldr	r2, [pc, #92]	; (8008954 <HAL_ADC_MspInit+0xac>)
 80088f6:	601a      	str	r2, [r3, #0]
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 80088f8:	4b15      	ldr	r3, [pc, #84]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 80088fa:	2205      	movs	r2, #5
 80088fc:	605a      	str	r2, [r3, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80088fe:	4b14      	ldr	r3, [pc, #80]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008900:	2200      	movs	r2, #0
 8008902:	609a      	str	r2, [r3, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8008904:	4b12      	ldr	r3, [pc, #72]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008906:	2200      	movs	r2, #0
 8008908:	60da      	str	r2, [r3, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 800890a:	4b11      	ldr	r3, [pc, #68]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 800890c:	2280      	movs	r2, #128	; 0x80
 800890e:	611a      	str	r2, [r3, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8008910:	4b0f      	ldr	r3, [pc, #60]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008912:	2200      	movs	r2, #0
 8008914:	615a      	str	r2, [r3, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8008916:	4b0e      	ldr	r3, [pc, #56]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008918:	2200      	movs	r2, #0
 800891a:	619a      	str	r2, [r3, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 800891c:	4b0c      	ldr	r3, [pc, #48]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 800891e:	2220      	movs	r2, #32
 8008920:	61da      	str	r2, [r3, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 8008922:	4b0b      	ldr	r3, [pc, #44]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008924:	2200      	movs	r2, #0
 8008926:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8008928:	4809      	ldr	r0, [pc, #36]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 800892a:	f005 f8d9 	bl	800dae0 <HAL_DMA_Init>
 800892e:	4603      	mov	r3, r0
 8008930:	2b00      	cmp	r3, #0
 8008932:	d001      	beq.n	8008938 <HAL_ADC_MspInit+0x90>
    {
      Error_Handler();
 8008934:	f002 fada 	bl	800aeec <Error_Handler>
    }

    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 8008938:	687b      	ldr	r3, [r7, #4]
 800893a:	4a05      	ldr	r2, [pc, #20]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 800893c:	64da      	str	r2, [r3, #76]	; 0x4c
 800893e:	4a04      	ldr	r2, [pc, #16]	; (8008950 <HAL_ADC_MspInit+0xa8>)
 8008940:	687b      	ldr	r3, [r7, #4]
 8008942:	6293      	str	r3, [r2, #40]	; 0x28

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8008944:	bf00      	nop
 8008946:	3720      	adds	r7, #32
 8008948:	46bd      	mov	sp, r7
 800894a:	bd80      	pop	{r7, pc}
 800894c:	50040000 	.word	0x50040000
 8008950:	20011ef0 	.word	0x20011ef0
 8008954:	40020008 	.word	0x40020008

08008958 <APPD_EnableCPU2>:
/* USER CODE END APPD_Init */
  return;
}

void APPD_EnableCPU2( void )
{
 8008958:	b5b0      	push	{r4, r5, r7, lr}
 800895a:	b088      	sub	sp, #32
 800895c:	af00      	add	r7, sp, #0
/* USER CODE BEGIN APPD_EnableCPU2 */
  SHCI_C2_DEBUG_Init_Cmd_Packet_t DebugCmdPacket =
 800895e:	4b0b      	ldr	r3, [pc, #44]	; (800898c <APPD_EnableCPU2+0x34>)
 8008960:	1d3c      	adds	r4, r7, #4
 8008962:	461d      	mov	r5, r3
 8008964:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008966:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008968:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800896c:	c403      	stmia	r4!, {r0, r1}
 800896e:	8022      	strh	r2, [r4, #0]
 8008970:	3402      	adds	r4, #2
 8008972:	0c13      	lsrs	r3, r2, #16
 8008974:	7023      	strb	r3, [r4, #0]
    NBR_OF_TRACES_CONFIG_PARAMETERS,
    NBR_OF_GENERAL_CONFIG_PARAMETERS}
  };

  /**< Traces channel initialization */
  TL_TRACES_Init( );
 8008976:	f013 f9cb 	bl	801bd10 <TL_TRACES_Init>

  /** GPIO DEBUG Initialization */
  SHCI_C2_DEBUG_Init( &DebugCmdPacket  );
 800897a:	1d3b      	adds	r3, r7, #4
 800897c:	4618      	mov	r0, r3
 800897e:	f012 fc66 	bl	801b24e <SHCI_C2_DEBUG_Init>

/* USER CODE END APPD_EnableCPU2 */
  return;
 8008982:	bf00      	nop
}
 8008984:	3720      	adds	r7, #32
 8008986:	46bd      	mov	sp, r7
 8008988:	bdb0      	pop	{r4, r5, r7, pc}
 800898a:	bf00      	nop
 800898c:	0802c438 	.word	0x0802c438

08008990 <LL_C2_PWR_SetPowerMode>:
  *
  *         (*) Not available on devices STM32WB15xx, STM32WB10xx
  * @retval None
  */
__STATIC_INLINE void LL_C2_PWR_SetPowerMode(uint32_t LowPowerMode)
{
 8008990:	b480      	push	{r7}
 8008992:	b083      	sub	sp, #12
 8008994:	af00      	add	r7, sp, #0
 8008996:	6078      	str	r0, [r7, #4]
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, LowPowerMode);
 8008998:	4b07      	ldr	r3, [pc, #28]	; (80089b8 <LL_C2_PWR_SetPowerMode+0x28>)
 800899a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800899e:	f023 0207 	bic.w	r2, r3, #7
 80089a2:	4905      	ldr	r1, [pc, #20]	; (80089b8 <LL_C2_PWR_SetPowerMode+0x28>)
 80089a4:	687b      	ldr	r3, [r7, #4]
 80089a6:	4313      	orrs	r3, r2
 80089a8:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 80089ac:	bf00      	nop
 80089ae:	370c      	adds	r7, #12
 80089b0:	46bd      	mov	sp, r7
 80089b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089b6:	4770      	bx	lr
 80089b8:	58000400 	.word	0x58000400

080089bc <LL_EXTI_EnableIT_32_63>:
  *         @arg @ref LL_EXTI_LINE_ALL_32_63
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
 80089bc:	b480      	push	{r7}
 80089be:	b083      	sub	sp, #12
 80089c0:	af00      	add	r7, sp, #0
 80089c2:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR2, ExtiLine);
 80089c4:	4b06      	ldr	r3, [pc, #24]	; (80089e0 <LL_EXTI_EnableIT_32_63+0x24>)
 80089c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80089ca:	4905      	ldr	r1, [pc, #20]	; (80089e0 <LL_EXTI_EnableIT_32_63+0x24>)
 80089cc:	687b      	ldr	r3, [r7, #4]
 80089ce:	4313      	orrs	r3, r2
 80089d0:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 80089d4:	bf00      	nop
 80089d6:	370c      	adds	r7, #12
 80089d8:	46bd      	mov	sp, r7
 80089da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089de:	4770      	bx	lr
 80089e0:	58000800 	.word	0x58000800

080089e4 <LL_RCC_HSE_SetCapacitorTuning>:
  * @rmtoll HSECR        HSETUNE       LL_RCC_HSE_SetCapacitorTuning
  * @param  Value Between Min_Data = 0 and Max_Data = 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SetCapacitorTuning(uint32_t Value)
{
 80089e4:	b480      	push	{r7}
 80089e6:	b083      	sub	sp, #12
 80089e8:	af00      	add	r7, sp, #0
 80089ea:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->HSECR, HSE_CONTROL_UNLOCK_KEY);
 80089ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80089f0:	4a0a      	ldr	r2, [pc, #40]	; (8008a1c <LL_RCC_HSE_SetCapacitorTuning+0x38>)
 80089f2:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  MODIFY_REG(RCC->HSECR, RCC_HSECR_HSETUNE, Value << RCC_HSECR_HSETUNE_Pos);
 80089f6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80089fa:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80089fe:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 8008a02:	687b      	ldr	r3, [r7, #4]
 8008a04:	021b      	lsls	r3, r3, #8
 8008a06:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8008a0a:	4313      	orrs	r3, r2
 8008a0c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
}
 8008a10:	bf00      	nop
 8008a12:	370c      	adds	r7, #12
 8008a14:	46bd      	mov	sp, r7
 8008a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a1a:	4770      	bx	lr
 8008a1c:	cafecafe 	.word	0xcafecafe

08008a20 <LL_RCC_SetClkAfterWakeFromStop>:
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_MSI
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
{
 8008a20:	b480      	push	{r7}
 8008a22:	b083      	sub	sp, #12
 8008a24:	af00      	add	r7, sp, #0
 8008a26:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8008a28:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008a2c:	689b      	ldr	r3, [r3, #8]
 8008a2e:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8008a32:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8008a36:	687b      	ldr	r3, [r7, #4]
 8008a38:	4313      	orrs	r3, r2
 8008a3a:	608b      	str	r3, [r1, #8]
}
 8008a3c:	bf00      	nop
 8008a3e:	370c      	adds	r7, #12
 8008a40:	46bd      	mov	sp, r7
 8008a42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a46:	4770      	bx	lr

08008a48 <LL_RCC_ForceBackupDomainReset>:
  * @brief  Force the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ForceBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ForceBackupDomainReset(void)
{
 8008a48:	b480      	push	{r7}
 8008a4a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8008a4c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008a50:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008a54:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8008a58:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008a5c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8008a60:	bf00      	nop
 8008a62:	46bd      	mov	sp, r7
 8008a64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a68:	4770      	bx	lr

08008a6a <LL_RCC_ReleaseBackupDomainReset>:
  * @brief  Release the Backup domain reset
  * @rmtoll BDCR         BDRST         LL_RCC_ReleaseBackupDomainReset
  * @retval None
  */
__STATIC_INLINE void LL_RCC_ReleaseBackupDomainReset(void)
{
 8008a6a:	b480      	push	{r7}
 8008a6c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8008a6e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008a72:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008a76:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8008a7a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008a7e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8008a82:	bf00      	nop
 8008a84:	46bd      	mov	sp, r7
 8008a86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008a8a:	4770      	bx	lr

08008a8c <LL_RCC_IsActiveFlag_PINRST>:
  * @brief  Check if RCC flag Pin reset is set or not.
  * @rmtoll CSR          PINRSTF       LL_RCC_IsActiveFlag_PINRST
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PINRST(void)
{
 8008a8c:	b480      	push	{r7}
 8008a8e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_PINRSTF) == (RCC_CSR_PINRSTF)) ? 1UL : 0UL);
 8008a90:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008a94:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008a98:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8008a9c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8008aa0:	d101      	bne.n	8008aa6 <LL_RCC_IsActiveFlag_PINRST+0x1a>
 8008aa2:	2301      	movs	r3, #1
 8008aa4:	e000      	b.n	8008aa8 <LL_RCC_IsActiveFlag_PINRST+0x1c>
 8008aa6:	2300      	movs	r3, #0
}
 8008aa8:	4618      	mov	r0, r3
 8008aaa:	46bd      	mov	sp, r7
 8008aac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ab0:	4770      	bx	lr

08008ab2 <LL_RCC_IsActiveFlag_SFTRST>:
  * @brief  Check if RCC flag Software reset is set or not.
  * @rmtoll CSR          SFTRSTF       LL_RCC_IsActiveFlag_SFTRST
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SFTRST(void)
{
 8008ab2:	b480      	push	{r7}
 8008ab4:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_SFTRSTF) == (RCC_CSR_SFTRSTF)) ? 1UL : 0UL);
 8008ab6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008aba:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008abe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008ac2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8008ac6:	d101      	bne.n	8008acc <LL_RCC_IsActiveFlag_SFTRST+0x1a>
 8008ac8:	2301      	movs	r3, #1
 8008aca:	e000      	b.n	8008ace <LL_RCC_IsActiveFlag_SFTRST+0x1c>
 8008acc:	2300      	movs	r3, #0
}
 8008ace:	4618      	mov	r0, r3
 8008ad0:	46bd      	mov	sp, r7
 8008ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ad6:	4770      	bx	lr

08008ad8 <LL_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_AHB3_GRP1_PERIPH_FLASH
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 8008ad8:	b480      	push	{r7}
 8008ada:	b085      	sub	sp, #20
 8008adc:	af00      	add	r7, sp, #0
 8008ade:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB3ENR, Periphs);
 8008ae0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008ae4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008ae6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8008aea:	687b      	ldr	r3, [r7, #4]
 8008aec:	4313      	orrs	r3, r2
 8008aee:	650b      	str	r3, [r1, #80]	; 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 8008af0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8008af4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008af6:	687b      	ldr	r3, [r7, #4]
 8008af8:	4013      	ands	r3, r2
 8008afa:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8008afc:	68fb      	ldr	r3, [r7, #12]
}
 8008afe:	bf00      	nop
 8008b00:	3714      	adds	r7, #20
 8008b02:	46bd      	mov	sp, r7
 8008b04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b08:	4770      	bx	lr
	...

08008b0c <LL_DBGMCU_GetRevisionID>:
  * @note   This field indicates the revision of the device.
  * @rmtoll DBGMCU_IDCODE REV_ID        LL_DBGMCU_GetRevisionID
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
  */
__STATIC_INLINE uint32_t LL_DBGMCU_GetRevisionID(void)
{
 8008b0c:	b480      	push	{r7}
 8008b0e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(DBGMCU->IDCODE, DBGMCU_IDCODE_REV_ID) >> DBGMCU_IDCODE_REV_ID_Pos);
 8008b10:	4b04      	ldr	r3, [pc, #16]	; (8008b24 <LL_DBGMCU_GetRevisionID+0x18>)
 8008b12:	681b      	ldr	r3, [r3, #0]
 8008b14:	0c1b      	lsrs	r3, r3, #16
 8008b16:	b29b      	uxth	r3, r3
}
 8008b18:	4618      	mov	r0, r3
 8008b1a:	46bd      	mov	sp, r7
 8008b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b20:	4770      	bx	lr
 8008b22:	bf00      	nop
 8008b24:	e0042000 	.word	0xe0042000

08008b28 <LL_C1_IPCC_DisableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008b28:	b480      	push	{r7}
 8008b2a:	b083      	sub	sp, #12
 8008b2c:	af00      	add	r7, sp, #0
 8008b2e:	6078      	str	r0, [r7, #4]
 8008b30:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8008b32:	687b      	ldr	r3, [r7, #4]
 8008b34:	685a      	ldr	r2, [r3, #4]
 8008b36:	683b      	ldr	r3, [r7, #0]
 8008b38:	041b      	lsls	r3, r3, #16
 8008b3a:	431a      	orrs	r2, r3
 8008b3c:	687b      	ldr	r3, [r7, #4]
 8008b3e:	605a      	str	r2, [r3, #4]
}
 8008b40:	bf00      	nop
 8008b42:	370c      	adds	r7, #12
 8008b44:	46bd      	mov	sp, r7
 8008b46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b4a:	4770      	bx	lr

08008b4c <LL_C1_IPCC_DisableReceiveChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008b4c:	b480      	push	{r7}
 8008b4e:	b083      	sub	sp, #12
 8008b50:	af00      	add	r7, sp, #0
 8008b52:	6078      	str	r0, [r7, #4]
 8008b54:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel);
 8008b56:	687b      	ldr	r3, [r7, #4]
 8008b58:	685a      	ldr	r2, [r3, #4]
 8008b5a:	683b      	ldr	r3, [r7, #0]
 8008b5c:	431a      	orrs	r2, r3
 8008b5e:	687b      	ldr	r3, [r7, #4]
 8008b60:	605a      	str	r2, [r3, #4]
}
 8008b62:	bf00      	nop
 8008b64:	370c      	adds	r7, #12
 8008b66:	46bd      	mov	sp, r7
 8008b68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b6c:	4770      	bx	lr

08008b6e <LL_C2_IPCC_DisableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008b6e:	b480      	push	{r7}
 8008b70:	b083      	sub	sp, #12
 8008b72:	af00      	add	r7, sp, #0
 8008b74:	6078      	str	r0, [r7, #4]
 8008b76:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C2MR, Channel << (IPCC_C2MR_CH1FM_Pos));
 8008b78:	687b      	ldr	r3, [r7, #4]
 8008b7a:	695a      	ldr	r2, [r3, #20]
 8008b7c:	683b      	ldr	r3, [r7, #0]
 8008b7e:	041b      	lsls	r3, r3, #16
 8008b80:	431a      	orrs	r2, r3
 8008b82:	687b      	ldr	r3, [r7, #4]
 8008b84:	615a      	str	r2, [r3, #20]
}
 8008b86:	bf00      	nop
 8008b88:	370c      	adds	r7, #12
 8008b8a:	46bd      	mov	sp, r7
 8008b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b90:	4770      	bx	lr

08008b92 <LL_C2_IPCC_DisableReceiveChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_DisableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008b92:	b480      	push	{r7}
 8008b94:	b083      	sub	sp, #12
 8008b96:	af00      	add	r7, sp, #0
 8008b98:	6078      	str	r0, [r7, #4]
 8008b9a:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C2MR, Channel);
 8008b9c:	687b      	ldr	r3, [r7, #4]
 8008b9e:	695a      	ldr	r2, [r3, #20]
 8008ba0:	683b      	ldr	r3, [r7, #0]
 8008ba2:	431a      	orrs	r2, r3
 8008ba4:	687b      	ldr	r3, [r7, #4]
 8008ba6:	615a      	str	r2, [r3, #20]
}
 8008ba8:	bf00      	nop
 8008baa:	370c      	adds	r7, #12
 8008bac:	46bd      	mov	sp, r7
 8008bae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bb2:	4770      	bx	lr

08008bb4 <LL_C1_IPCC_ClearFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_ClearFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008bb4:	b480      	push	{r7}
 8008bb6:	b083      	sub	sp, #12
 8008bb8:	af00      	add	r7, sp, #0
 8008bba:	6078      	str	r0, [r7, #4]
 8008bbc:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel);
 8008bbe:	687b      	ldr	r3, [r7, #4]
 8008bc0:	683a      	ldr	r2, [r7, #0]
 8008bc2:	609a      	str	r2, [r3, #8]
}
 8008bc4:	bf00      	nop
 8008bc6:	370c      	adds	r7, #12
 8008bc8:	46bd      	mov	sp, r7
 8008bca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bce:	4770      	bx	lr

08008bd0 <LL_C2_IPCC_ClearFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C2_IPCC_ClearFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8008bd0:	b480      	push	{r7}
 8008bd2:	b083      	sub	sp, #12
 8008bd4:	af00      	add	r7, sp, #0
 8008bd6:	6078      	str	r0, [r7, #4]
 8008bd8:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C2SCR, Channel);
 8008bda:	687b      	ldr	r3, [r7, #4]
 8008bdc:	683a      	ldr	r2, [r7, #0]
 8008bde:	619a      	str	r2, [r3, #24]
}
 8008be0:	bf00      	nop
 8008be2:	370c      	adds	r7, #12
 8008be4:	46bd      	mov	sp, r7
 8008be6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008bea:	4770      	bx	lr

08008bec <LL_LPM_EnableSleep>:
  * @brief  Processor uses sleep as its low power mode
  * @rmtoll SCB_SCR      SLEEPDEEP     LL_LPM_EnableSleep
  * @retval None
  */
__STATIC_INLINE void LL_LPM_EnableSleep(void)
{
 8008bec:	b480      	push	{r7}
 8008bee:	af00      	add	r7, sp, #0
  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8008bf0:	4b05      	ldr	r3, [pc, #20]	; (8008c08 <LL_LPM_EnableSleep+0x1c>)
 8008bf2:	691b      	ldr	r3, [r3, #16]
 8008bf4:	4a04      	ldr	r2, [pc, #16]	; (8008c08 <LL_LPM_EnableSleep+0x1c>)
 8008bf6:	f023 0304 	bic.w	r3, r3, #4
 8008bfa:	6113      	str	r3, [r2, #16]
}
 8008bfc:	bf00      	nop
 8008bfe:	46bd      	mov	sp, r7
 8008c00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c04:	4770      	bx	lr
 8008c06:	bf00      	nop
 8008c08:	e000ed00 	.word	0xe000ed00

08008c0c <LL_RTC_EnableWriteProtection>:
  * @rmtoll WPR          KEY           LL_RTC_EnableWriteProtection
  * @param  RTCx RTC Instance
  * @retval None
  */
__STATIC_INLINE void LL_RTC_EnableWriteProtection(RTC_TypeDef *RTCx)
{
 8008c0c:	b480      	push	{r7}
 8008c0e:	b083      	sub	sp, #12
 8008c10:	af00      	add	r7, sp, #0
 8008c12:	6078      	str	r0, [r7, #4]
  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_DISABLE);
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	22ff      	movs	r2, #255	; 0xff
 8008c18:	625a      	str	r2, [r3, #36]	; 0x24
}
 8008c1a:	bf00      	nop
 8008c1c:	370c      	adds	r7, #12
 8008c1e:	46bd      	mov	sp, r7
 8008c20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c24:	4770      	bx	lr

08008c26 <LL_RTC_DisableWriteProtection>:
  * @rmtoll WPR          KEY           LL_RTC_DisableWriteProtection
  * @param  RTCx RTC Instance
  * @retval None
  */
__STATIC_INLINE void LL_RTC_DisableWriteProtection(RTC_TypeDef *RTCx)
{
 8008c26:	b480      	push	{r7}
 8008c28:	b083      	sub	sp, #12
 8008c2a:	af00      	add	r7, sp, #0
 8008c2c:	6078      	str	r0, [r7, #4]
  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_1);
 8008c2e:	687b      	ldr	r3, [r7, #4]
 8008c30:	22ca      	movs	r2, #202	; 0xca
 8008c32:	625a      	str	r2, [r3, #36]	; 0x24
  WRITE_REG(RTCx->WPR, RTC_WRITE_PROTECTION_ENABLE_2);
 8008c34:	687b      	ldr	r3, [r7, #4]
 8008c36:	2253      	movs	r2, #83	; 0x53
 8008c38:	625a      	str	r2, [r3, #36]	; 0x24
}
 8008c3a:	bf00      	nop
 8008c3c:	370c      	adds	r7, #12
 8008c3e:	46bd      	mov	sp, r7
 8008c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c44:	4770      	bx	lr

08008c46 <LL_RTC_WAKEUP_SetClock>:
  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE
  *         @arg @ref LL_RTC_WAKEUPCLOCK_CKSPRE_WUT
  * @retval None
  */
__STATIC_INLINE void LL_RTC_WAKEUP_SetClock(RTC_TypeDef *RTCx, uint32_t WakeupClock)
{
 8008c46:	b480      	push	{r7}
 8008c48:	b083      	sub	sp, #12
 8008c4a:	af00      	add	r7, sp, #0
 8008c4c:	6078      	str	r0, [r7, #4]
 8008c4e:	6039      	str	r1, [r7, #0]
  MODIFY_REG(RTCx->CR, RTC_CR_WUCKSEL, WakeupClock);
 8008c50:	687b      	ldr	r3, [r7, #4]
 8008c52:	689b      	ldr	r3, [r3, #8]
 8008c54:	f023 0207 	bic.w	r2, r3, #7
 8008c58:	683b      	ldr	r3, [r7, #0]
 8008c5a:	431a      	orrs	r2, r3
 8008c5c:	687b      	ldr	r3, [r7, #4]
 8008c5e:	609a      	str	r2, [r3, #8]
}
 8008c60:	bf00      	nop
 8008c62:	370c      	adds	r7, #12
 8008c64:	46bd      	mov	sp, r7
 8008c66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c6a:	4770      	bx	lr

08008c6c <MX_APPE_Config>:

/* USER CODE END PFP */

/* Functions Definition ------------------------------------------------------*/
void MX_APPE_Config( void )
{
 8008c6c:	b580      	push	{r7, lr}
 8008c6e:	af00      	add	r7, sp, #0
  /**
   * The OPTVERR flag is wrongly set at power on
   * It shall be cleared before using any HAL_FLASH_xxx() api
   */
  __HAL_FLASH_CLEAR_FLAG( FLASH_FLAG_OPTVERR );
 8008c70:	4b04      	ldr	r3, [pc, #16]	; (8008c84 <MX_APPE_Config+0x18>)
 8008c72:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8008c76:	611a      	str	r2, [r3, #16]

  /**
   * Reset some configurations so that the system behave in the same way
   * when either out of nReset or Power On
   */
  Reset_Device( );
 8008c78:	f000 f824 	bl	8008cc4 <Reset_Device>

  /* Configure HSE Tuning */
  Config_HSE();
 8008c7c:	f000 f864 	bl	8008d48 <Config_HSE>

  return;
 8008c80:	bf00      	nop
}
 8008c82:	bd80      	pop	{r7, pc}
 8008c84:	58004000 	.word	0x58004000

08008c88 <MX_APPE_Init>:

void MX_APPE_Init( void )
{
 8008c88:	b580      	push	{r7, lr}
 8008c8a:	af00      	add	r7, sp, #0
  System_Init( );       /**< System initialization */
 8008c8c:	f000 f870 	bl	8008d70 <System_Init>

  SystemPower_Config(); /**< Configure the system Power Mode */
 8008c90:	f000 f888 	bl	8008da4 <SystemPower_Config>

  HW_TS_Init(hw_ts_InitMode_Full, &hrtc); /**< Initialize the TimerServer */
 8008c94:	4903      	ldr	r1, [pc, #12]	; (8008ca4 <MX_APPE_Init+0x1c>)
 8008c96:	2000      	movs	r0, #0
 8008c98:	f001 f96c 	bl	8009f74 <HW_TS_Init>

/* USER CODE BEGIN APPE_Init_1 */

/* USER CODE END APPE_Init_1 */
  appe_Tl_Init();	/* Initialize all transport layers */
 8008c9c:	f000 f890 	bl	8008dc0 <appe_Tl_Init>
   * This system event is received with APPE_SysUserEvtRx()
   */
/* USER CODE BEGIN APPE_Init_2 */

/* USER CODE END APPE_Init_2 */
   return;
 8008ca0:	bf00      	nop
}
 8008ca2:	bd80      	pop	{r7, pc}
 8008ca4:	20012070 	.word	0x20012070

08008ca8 <Init_Smps>:

void Init_Smps( void )
{
 8008ca8:	b480      	push	{r7}
 8008caa:	af00      	add	r7, sp, #0
  LL_PWR_SMPS_SetStartupCurrent(LL_PWR_SMPS_STARTUP_CURRENT_80MA);
  LL_PWR_SMPS_SetOutputVoltageLevel(LL_PWR_SMPS_OUTPUT_VOLTAGE_1V40);
  LL_PWR_SMPS_Enable();
#endif

  return;
 8008cac:	bf00      	nop
}
 8008cae:	46bd      	mov	sp, r7
 8008cb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cb4:	4770      	bx	lr

08008cb6 <Init_Exti>:

void Init_Exti( void )
{
 8008cb6:	b580      	push	{r7, lr}
 8008cb8:	af00      	add	r7, sp, #0
  /* Enable IPCC(36), HSEM(38) wakeup interrupts on CPU1 */
  LL_EXTI_EnableIT_32_63( LL_EXTI_LINE_36 & LL_EXTI_LINE_38 );
 8008cba:	2000      	movs	r0, #0
 8008cbc:	f7ff fe7e 	bl	80089bc <LL_EXTI_EnableIT_32_63>

  return;
 8008cc0:	bf00      	nop
}
 8008cc2:	bd80      	pop	{r7, pc}

08008cc4 <Reset_Device>:
 *
 * LOCAL FUNCTIONS
 *
 *************************************************************/
static void Reset_Device( void )
{
 8008cc4:	b580      	push	{r7, lr}
 8008cc6:	af00      	add	r7, sp, #0
#if ( CFG_HW_RESET_BY_FW == 1 )
  Reset_BackupDomain();
 8008cc8:	f000 f804 	bl	8008cd4 <Reset_BackupDomain>

  Reset_IPCC();
 8008ccc:	f000 f81a 	bl	8008d04 <Reset_IPCC>
#endif /* CFG_HW_RESET_BY_FW */

  return;
 8008cd0:	bf00      	nop
}
 8008cd2:	bd80      	pop	{r7, pc}

08008cd4 <Reset_BackupDomain>:

#if ( CFG_HW_RESET_BY_FW == 1 )
static void Reset_BackupDomain( void )
{
 8008cd4:	b580      	push	{r7, lr}
 8008cd6:	af00      	add	r7, sp, #0
  if ((LL_RCC_IsActiveFlag_PINRST() != FALSE) && (LL_RCC_IsActiveFlag_SFTRST() == FALSE))
 8008cd8:	f7ff fed8 	bl	8008a8c <LL_RCC_IsActiveFlag_PINRST>
 8008cdc:	4603      	mov	r3, r0
 8008cde:	2b00      	cmp	r3, #0
 8008ce0:	d00d      	beq.n	8008cfe <Reset_BackupDomain+0x2a>
 8008ce2:	f7ff fee6 	bl	8008ab2 <LL_RCC_IsActiveFlag_SFTRST>
 8008ce6:	4603      	mov	r3, r0
 8008ce8:	2b00      	cmp	r3, #0
 8008cea:	d108      	bne.n	8008cfe <Reset_BackupDomain+0x2a>
  {
    HAL_PWR_EnableBkUpAccess(); /**< Enable access to the RTC registers */
 8008cec:	f008 f862 	bl	8010db4 <HAL_PWR_EnableBkUpAccess>

    /**
     *  Write twice the value to flush the APB-AHB bridge
     *  This bit shall be written in the register before writing the next one
     */
    HAL_PWR_EnableBkUpAccess();
 8008cf0:	f008 f860 	bl	8010db4 <HAL_PWR_EnableBkUpAccess>

    __HAL_RCC_BACKUPRESET_FORCE();
 8008cf4:	f7ff fea8 	bl	8008a48 <LL_RCC_ForceBackupDomainReset>
    __HAL_RCC_BACKUPRESET_RELEASE();
 8008cf8:	f7ff feb7 	bl	8008a6a <LL_RCC_ReleaseBackupDomainReset>
  }

  return;
 8008cfc:	bf00      	nop
 8008cfe:	bf00      	nop
}
 8008d00:	bd80      	pop	{r7, pc}
	...

08008d04 <Reset_IPCC>:

static void Reset_IPCC( void )
{
 8008d04:	b580      	push	{r7, lr}
 8008d06:	af00      	add	r7, sp, #0
  LL_AHB3_GRP1_EnableClock(LL_AHB3_GRP1_PERIPH_IPCC);
 8008d08:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8008d0c:	f7ff fee4 	bl	8008ad8 <LL_AHB3_GRP1_EnableClock>

  LL_C1_IPCC_ClearFlag_CHx(
 8008d10:	213f      	movs	r1, #63	; 0x3f
 8008d12:	480c      	ldr	r0, [pc, #48]	; (8008d44 <Reset_IPCC+0x40>)
 8008d14:	f7ff ff4e 	bl	8008bb4 <LL_C1_IPCC_ClearFlag_CHx>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_ClearFlag_CHx(
 8008d18:	213f      	movs	r1, #63	; 0x3f
 8008d1a:	480a      	ldr	r0, [pc, #40]	; (8008d44 <Reset_IPCC+0x40>)
 8008d1c:	f7ff ff58 	bl	8008bd0 <LL_C2_IPCC_ClearFlag_CHx>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C1_IPCC_DisableTransmitChannel(
 8008d20:	213f      	movs	r1, #63	; 0x3f
 8008d22:	4808      	ldr	r0, [pc, #32]	; (8008d44 <Reset_IPCC+0x40>)
 8008d24:	f7ff ff00 	bl	8008b28 <LL_C1_IPCC_DisableTransmitChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_DisableTransmitChannel(
 8008d28:	213f      	movs	r1, #63	; 0x3f
 8008d2a:	4806      	ldr	r0, [pc, #24]	; (8008d44 <Reset_IPCC+0x40>)
 8008d2c:	f7ff ff1f 	bl	8008b6e <LL_C2_IPCC_DisableTransmitChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C1_IPCC_DisableReceiveChannel(
 8008d30:	213f      	movs	r1, #63	; 0x3f
 8008d32:	4804      	ldr	r0, [pc, #16]	; (8008d44 <Reset_IPCC+0x40>)
 8008d34:	f7ff ff0a 	bl	8008b4c <LL_C1_IPCC_DisableReceiveChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  LL_C2_IPCC_DisableReceiveChannel(
 8008d38:	213f      	movs	r1, #63	; 0x3f
 8008d3a:	4802      	ldr	r0, [pc, #8]	; (8008d44 <Reset_IPCC+0x40>)
 8008d3c:	f7ff ff29 	bl	8008b92 <LL_C2_IPCC_DisableReceiveChannel>
      IPCC,
      LL_IPCC_CHANNEL_1 | LL_IPCC_CHANNEL_2 | LL_IPCC_CHANNEL_3 | LL_IPCC_CHANNEL_4
      | LL_IPCC_CHANNEL_5 | LL_IPCC_CHANNEL_6);

  return;
 8008d40:	bf00      	nop
}
 8008d42:	bd80      	pop	{r7, pc}
 8008d44:	58000c00 	.word	0x58000c00

08008d48 <Config_HSE>:
#endif /* CFG_HW_RESET_BY_FW */

static void Config_HSE(void)
{
 8008d48:	b580      	push	{r7, lr}
 8008d4a:	b082      	sub	sp, #8
 8008d4c:	af00      	add	r7, sp, #0
    OTP_ID0_t * p_otp;

  /**
   * Read HSE_Tuning from OTP
   */
  p_otp = (OTP_ID0_t *) OTP_Read(0);
 8008d4e:	2000      	movs	r0, #0
 8008d50:	f013 f86a 	bl	801be28 <OTP_Read>
 8008d54:	6078      	str	r0, [r7, #4]
  if (p_otp)
 8008d56:	687b      	ldr	r3, [r7, #4]
 8008d58:	2b00      	cmp	r3, #0
 8008d5a:	d005      	beq.n	8008d68 <Config_HSE+0x20>
  {
    LL_RCC_HSE_SetCapacitorTuning(p_otp->hse_tuning);
 8008d5c:	687b      	ldr	r3, [r7, #4]
 8008d5e:	799b      	ldrb	r3, [r3, #6]
 8008d60:	4618      	mov	r0, r3
 8008d62:	f7ff fe3f 	bl	80089e4 <LL_RCC_HSE_SetCapacitorTuning>
  }

  return;
 8008d66:	bf00      	nop
 8008d68:	bf00      	nop
}
 8008d6a:	3708      	adds	r7, #8
 8008d6c:	46bd      	mov	sp, r7
 8008d6e:	bd80      	pop	{r7, pc}

08008d70 <System_Init>:

static void System_Init( void )
{
 8008d70:	b580      	push	{r7, lr}
 8008d72:	af00      	add	r7, sp, #0
  Init_Smps( );
 8008d74:	f7ff ff98 	bl	8008ca8 <Init_Smps>

  Init_Exti( );
 8008d78:	f7ff ff9d 	bl	8008cb6 <Init_Exti>

  Init_Rtc( );
 8008d7c:	f000 f802 	bl	8008d84 <Init_Rtc>

  return;
 8008d80:	bf00      	nop
}
 8008d82:	bd80      	pop	{r7, pc}

08008d84 <Init_Rtc>:

static void Init_Rtc( void )
{
 8008d84:	b580      	push	{r7, lr}
 8008d86:	af00      	add	r7, sp, #0
  /* Disable RTC registers write protection */
  LL_RTC_DisableWriteProtection(RTC);
 8008d88:	4805      	ldr	r0, [pc, #20]	; (8008da0 <Init_Rtc+0x1c>)
 8008d8a:	f7ff ff4c 	bl	8008c26 <LL_RTC_DisableWriteProtection>

  LL_RTC_WAKEUP_SetClock(RTC, CFG_RTC_WUCKSEL_DIVIDER);
 8008d8e:	2100      	movs	r1, #0
 8008d90:	4803      	ldr	r0, [pc, #12]	; (8008da0 <Init_Rtc+0x1c>)
 8008d92:	f7ff ff58 	bl	8008c46 <LL_RTC_WAKEUP_SetClock>

  /* Enable RTC registers write protection */
  LL_RTC_EnableWriteProtection(RTC);
 8008d96:	4802      	ldr	r0, [pc, #8]	; (8008da0 <Init_Rtc+0x1c>)
 8008d98:	f7ff ff38 	bl	8008c0c <LL_RTC_EnableWriteProtection>

  return;
 8008d9c:	bf00      	nop
}
 8008d9e:	bd80      	pop	{r7, pc}
 8008da0:	40002800 	.word	0x40002800

08008da4 <SystemPower_Config>:
 *
 * @param  None
 * @retval None
 */
static void SystemPower_Config(void)
{
 8008da4:	b580      	push	{r7, lr}
 8008da6:	af00      	add	r7, sp, #0
  /**
   * Select HSI as system clock source after Wake Up from Stop mode
   */
  LL_RCC_SetClkAfterWakeFromStop(LL_RCC_STOP_WAKEUPCLOCK_HSI);
 8008da8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8008dac:	f7ff fe38 	bl	8008a20 <LL_RCC_SetClkAfterWakeFromStop>

  /* Initialize low power manager */
  UTIL_LPM_Init();
 8008db0:	f020 fa06 	bl	80291c0 <UTIL_LPM_Init>
  /* Initialize the CPU2 reset value before starting CPU2 with C2BOOT */
  LL_C2_PWR_SetPowerMode(LL_PWR_MODE_SHUTDOWN);
 8008db4:	2004      	movs	r0, #4
 8008db6:	f7ff fdeb 	bl	8008990 <LL_C2_PWR_SetPowerMode>
   *  Enable USB power
   */
  HAL_PWREx_EnableVddUSB();
#endif

  return;
 8008dba:	bf00      	nop
}
 8008dbc:	bd80      	pop	{r7, pc}
	...

08008dc0 <appe_Tl_Init>:

static void appe_Tl_Init( void )
{
 8008dc0:	b580      	push	{r7, lr}
 8008dc2:	b088      	sub	sp, #32
 8008dc4:	af00      	add	r7, sp, #0
  TL_MM_Config_t tl_mm_config;
  SHCI_TL_HciInitConf_t SHci_Tl_Init_Conf;
  /**< Reference table initialization */
  TL_Init();
 8008dc6:	f012 fded 	bl	801b9a4 <TL_Init>

  MtxShciId = osMutexNew( NULL );
 8008dca:	2000      	movs	r0, #0
 8008dcc:	f019 fe1c 	bl	8022a08 <osMutexNew>
 8008dd0:	4603      	mov	r3, r0
 8008dd2:	4a17      	ldr	r2, [pc, #92]	; (8008e30 <appe_Tl_Init+0x70>)
 8008dd4:	6013      	str	r3, [r2, #0]
  SemShciId = osSemaphoreNew( 1, 0, NULL ); /*< Create the semaphore and make it busy at initialization */
 8008dd6:	2200      	movs	r2, #0
 8008dd8:	2100      	movs	r1, #0
 8008dda:	2001      	movs	r0, #1
 8008ddc:	f019 ff22 	bl	8022c24 <osSemaphoreNew>
 8008de0:	4603      	mov	r3, r0
 8008de2:	4a14      	ldr	r2, [pc, #80]	; (8008e34 <appe_Tl_Init+0x74>)
 8008de4:	6013      	str	r3, [r2, #0]

  /** FreeRTOS system task creation */
  ShciUserEvtProcessId = osThreadNew(ShciUserEvtProcess, NULL, &ShciUserEvtProcess_attr);
 8008de6:	4a14      	ldr	r2, [pc, #80]	; (8008e38 <appe_Tl_Init+0x78>)
 8008de8:	2100      	movs	r1, #0
 8008dea:	4814      	ldr	r0, [pc, #80]	; (8008e3c <appe_Tl_Init+0x7c>)
 8008dec:	f019 fb9c 	bl	8022528 <osThreadNew>
 8008df0:	4603      	mov	r3, r0
 8008df2:	4a13      	ldr	r2, [pc, #76]	; (8008e40 <appe_Tl_Init+0x80>)
 8008df4:	6013      	str	r3, [r2, #0]

  /**< System channel initialization */
  SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&SystemCmdBuffer;
 8008df6:	4b13      	ldr	r3, [pc, #76]	; (8008e44 <appe_Tl_Init+0x84>)
 8008df8:	603b      	str	r3, [r7, #0]
  SHci_Tl_Init_Conf.StatusNotCallBack = APPE_SysStatusNot;
 8008dfa:	4b13      	ldr	r3, [pc, #76]	; (8008e48 <appe_Tl_Init+0x88>)
 8008dfc:	607b      	str	r3, [r7, #4]
  shci_init(APPE_SysUserEvtRx, (void*) &SHci_Tl_Init_Conf);
 8008dfe:	463b      	mov	r3, r7
 8008e00:	4619      	mov	r1, r3
 8008e02:	4812      	ldr	r0, [pc, #72]	; (8008e4c <appe_Tl_Init+0x8c>)
 8008e04:	f012 fc94 	bl	801b730 <shci_init>

  /**< Memory Manager channel initialization */
  tl_mm_config.p_BleSpareEvtBuffer = BleSpareEvtBuffer;
 8008e08:	4b11      	ldr	r3, [pc, #68]	; (8008e50 <appe_Tl_Init+0x90>)
 8008e0a:	60bb      	str	r3, [r7, #8]
  tl_mm_config.p_SystemSpareEvtBuffer = SystemSpareEvtBuffer;
 8008e0c:	4b11      	ldr	r3, [pc, #68]	; (8008e54 <appe_Tl_Init+0x94>)
 8008e0e:	60fb      	str	r3, [r7, #12]
  tl_mm_config.p_AsynchEvtPool = EvtPool;
 8008e10:	4b11      	ldr	r3, [pc, #68]	; (8008e58 <appe_Tl_Init+0x98>)
 8008e12:	613b      	str	r3, [r7, #16]
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
 8008e14:	f240 533c 	movw	r3, #1340	; 0x53c
 8008e18:	617b      	str	r3, [r7, #20]
  TL_MM_Init( &tl_mm_config );
 8008e1a:	f107 0308 	add.w	r3, r7, #8
 8008e1e:	4618      	mov	r0, r3
 8008e20:	f012 ff02 	bl	801bc28 <TL_MM_Init>

  TL_Enable();
 8008e24:	f012 fdb8 	bl	801b998 <TL_Enable>

  return;
 8008e28:	bf00      	nop
}
 8008e2a:	3720      	adds	r7, #32
 8008e2c:	46bd      	mov	sp, r7
 8008e2e:	bd80      	pop	{r7, pc}
 8008e30:	20011f50 	.word	0x20011f50
 8008e34:	20011f58 	.word	0x20011f58
 8008e38:	0802c84c 	.word	0x0802c84c
 8008e3c:	08008fa3 	.word	0x08008fa3
 8008e40:	20011f54 	.word	0x20011f54
 8008e44:	20030724 	.word	0x20030724
 8008e48:	08008e5d 	.word	0x08008e5d
 8008e4c:	08008e9d 	.word	0x08008e9d
 8008e50:	2003093c 	.word	0x2003093c
 8008e54:	20030830 	.word	0x20030830
 8008e58:	200301e8 	.word	0x200301e8

08008e5c <APPE_SysStatusNot>:

static void APPE_SysStatusNot( SHCI_TL_CmdStatus_t status )
{
 8008e5c:	b580      	push	{r7, lr}
 8008e5e:	b082      	sub	sp, #8
 8008e60:	af00      	add	r7, sp, #0
 8008e62:	4603      	mov	r3, r0
 8008e64:	71fb      	strb	r3, [r7, #7]
  switch (status)
 8008e66:	79fb      	ldrb	r3, [r7, #7]
 8008e68:	2b00      	cmp	r3, #0
 8008e6a:	d002      	beq.n	8008e72 <APPE_SysStatusNot+0x16>
 8008e6c:	2b01      	cmp	r3, #1
 8008e6e:	d008      	beq.n	8008e82 <APPE_SysStatusNot+0x26>
    case SHCI_TL_CmdAvailable:
      osMutexRelease( MtxShciId );
      break;

    default:
      break;
 8008e70:	e00d      	b.n	8008e8e <APPE_SysStatusNot+0x32>
      osMutexAcquire( MtxShciId, osWaitForever );
 8008e72:	4b09      	ldr	r3, [pc, #36]	; (8008e98 <APPE_SysStatusNot+0x3c>)
 8008e74:	681b      	ldr	r3, [r3, #0]
 8008e76:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008e7a:	4618      	mov	r0, r3
 8008e7c:	f019 fe4a 	bl	8022b14 <osMutexAcquire>
      break;
 8008e80:	e005      	b.n	8008e8e <APPE_SysStatusNot+0x32>
      osMutexRelease( MtxShciId );
 8008e82:	4b05      	ldr	r3, [pc, #20]	; (8008e98 <APPE_SysStatusNot+0x3c>)
 8008e84:	681b      	ldr	r3, [r3, #0]
 8008e86:	4618      	mov	r0, r3
 8008e88:	f019 fe8f 	bl	8022baa <osMutexRelease>
      break;
 8008e8c:	bf00      	nop
  }
  return;
 8008e8e:	bf00      	nop
}
 8008e90:	3708      	adds	r7, #8
 8008e92:	46bd      	mov	sp, r7
 8008e94:	bd80      	pop	{r7, pc}
 8008e96:	bf00      	nop
 8008e98:	20011f50 	.word	0x20011f50

08008e9c <APPE_SysUserEvtRx>:
 * The buffer shall not be released
 * ( eg ((tSHCI_UserEvtRxParam*)pPayload)->status shall be set to SHCI_TL_UserEventFlow_Disable )
 * When the status is not filled, the buffer is released by default
 */
static void APPE_SysUserEvtRx( void * pPayload )
{
 8008e9c:	b580      	push	{r7, lr}
 8008e9e:	b088      	sub	sp, #32
 8008ea0:	af00      	add	r7, sp, #0
 8008ea2:	6078      	str	r0, [r7, #4]
  TL_AsynchEvt_t *p_sys_event;
  WirelessFwInfo_t WirelessInfo;

  p_sys_event = (TL_AsynchEvt_t*)(((tSHCI_UserEvtRxParam*)pPayload)->pckt->evtserial.evt.payload);
 8008ea4:	687b      	ldr	r3, [r7, #4]
 8008ea6:	685b      	ldr	r3, [r3, #4]
 8008ea8:	330b      	adds	r3, #11
 8008eaa:	61fb      	str	r3, [r7, #28]

  /* Read the firmware version of both the wireless firmware and the FUS */
  SHCI_GetWirelessFwInfo( &WirelessInfo );
 8008eac:	f107 030c 	add.w	r3, r7, #12
 8008eb0:	4618      	mov	r0, r3
 8008eb2:	f012 f9f9 	bl	801b2a8 <SHCI_GetWirelessFwInfo>
  APP_DBG_MSG("Wireless Firmware version %d.%d.%d\n", WirelessInfo.VersionMajor, WirelessInfo.VersionMinor, WirelessInfo.VersionSub);
  APP_DBG_MSG("Wireless Firmware build %d\n", WirelessInfo.VersionReleaseType);
  APP_DBG_MSG("FUS version %d.%d.%d\n\n", WirelessInfo.FusVersionMajor, WirelessInfo.FusVersionMinor, WirelessInfo.FusVersionSub);

  switch(p_sys_event->subevtcode)
 8008eb6:	69fb      	ldr	r3, [r7, #28]
 8008eb8:	881b      	ldrh	r3, [r3, #0]
 8008eba:	b29b      	uxth	r3, r3
 8008ebc:	f5a3 4312 	sub.w	r3, r3, #37376	; 0x9200
 8008ec0:	2b07      	cmp	r3, #7
 8008ec2:	d81b      	bhi.n	8008efc <APPE_SysUserEvtRx+0x60>
 8008ec4:	a201      	add	r2, pc, #4	; (adr r2, 8008ecc <APPE_SysUserEvtRx+0x30>)
 8008ec6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008eca:	bf00      	nop
 8008ecc:	08008eed 	.word	0x08008eed
 8008ed0:	08008ef5 	.word	0x08008ef5
 8008ed4:	08008efd 	.word	0x08008efd
 8008ed8:	08008efd 	.word	0x08008efd
 8008edc:	08008efd 	.word	0x08008efd
 8008ee0:	08008efd 	.word	0x08008efd
 8008ee4:	08008efd 	.word	0x08008efd
 8008ee8:	08008efd 	.word	0x08008efd
  {
  case SHCI_SUB_EVT_CODE_READY:
    APPE_SysEvtReadyProcessing(pPayload);
 8008eec:	6878      	ldr	r0, [r7, #4]
 8008eee:	f000 f81c 	bl	8008f2a <APPE_SysEvtReadyProcessing>
    break;
 8008ef2:	e004      	b.n	8008efe <APPE_SysUserEvtRx+0x62>

  case SHCI_SUB_EVT_ERROR_NOTIF:
    APPE_SysEvtError(pPayload);
 8008ef4:	6878      	ldr	r0, [r7, #4]
 8008ef6:	f000 f807 	bl	8008f08 <APPE_SysEvtError>
    break;
 8008efa:	e000      	b.n	8008efe <APPE_SysUserEvtRx+0x62>
  case SHCI_SUB_EVT_NVM_END_ERASE:
    APP_DBG_MSG("SHCI_SUB_EVT_NVM_END_ERASE\n");
    break;

  default:
    break;
 8008efc:	bf00      	nop
  }

  return;
 8008efe:	bf00      	nop
}
 8008f00:	3720      	adds	r7, #32
 8008f02:	46bd      	mov	sp, r7
 8008f04:	bd80      	pop	{r7, pc}
 8008f06:	bf00      	nop

08008f08 <APPE_SysEvtError>:
 * @param  ErrorCode  : errorCode detected by the M0 firmware
 *
 * @retval None
 */
static void APPE_SysEvtError( void * pPayload)
{
 8008f08:	b480      	push	{r7}
 8008f0a:	b085      	sub	sp, #20
 8008f0c:	af00      	add	r7, sp, #0
 8008f0e:	6078      	str	r0, [r7, #4]
  TL_AsynchEvt_t *p_sys_event;
  SCHI_SystemErrCode_t *p_sys_error_code;

  p_sys_event = (TL_AsynchEvt_t*)(((tSHCI_UserEvtRxParam*)pPayload)->pckt->evtserial.evt.payload);
 8008f10:	687b      	ldr	r3, [r7, #4]
 8008f12:	685b      	ldr	r3, [r3, #4]
 8008f14:	330b      	adds	r3, #11
 8008f16:	60fb      	str	r3, [r7, #12]
  p_sys_error_code = (SCHI_SystemErrCode_t*) p_sys_event->payload;
 8008f18:	68fb      	ldr	r3, [r7, #12]
 8008f1a:	3302      	adds	r3, #2
 8008f1c:	60bb      	str	r3, [r7, #8]
  }
  else
  {
    APP_DBG_MSG("SHCI_SUB_EVT_ERROR_NOTIF WITH REASON - BLE ERROR \n");
  }
  return;
 8008f1e:	bf00      	nop
}
 8008f20:	3714      	adds	r7, #20
 8008f22:	46bd      	mov	sp, r7
 8008f24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f28:	4770      	bx	lr

08008f2a <APPE_SysEvtReadyProcessing>:

static void APPE_SysEvtReadyProcessing( void * pPayload )
{
 8008f2a:	b580      	push	{r7, lr}
 8008f2c:	b08a      	sub	sp, #40	; 0x28
 8008f2e:	af00      	add	r7, sp, #0
 8008f30:	6078      	str	r0, [r7, #4]
  TL_AsynchEvt_t *p_sys_event;
  SHCI_C2_Ready_Evt_t *p_sys_ready_event;

  SHCI_C2_CONFIG_Cmd_Param_t config_param = {0};
 8008f32:	f107 030c 	add.w	r3, r7, #12
 8008f36:	2200      	movs	r2, #0
 8008f38:	601a      	str	r2, [r3, #0]
 8008f3a:	605a      	str	r2, [r3, #4]
 8008f3c:	609a      	str	r2, [r3, #8]
 8008f3e:	819a      	strh	r2, [r3, #12]
  uint32_t RevisionID=0;
 8008f40:	2300      	movs	r3, #0
 8008f42:	627b      	str	r3, [r7, #36]	; 0x24

  p_sys_event = (TL_AsynchEvt_t*)(((tSHCI_UserEvtRxParam*)pPayload)->pckt->evtserial.evt.payload);
 8008f44:	687b      	ldr	r3, [r7, #4]
 8008f46:	685b      	ldr	r3, [r3, #4]
 8008f48:	330b      	adds	r3, #11
 8008f4a:	623b      	str	r3, [r7, #32]
  p_sys_ready_event = (SHCI_C2_Ready_Evt_t*) p_sys_event->payload;
 8008f4c:	6a3b      	ldr	r3, [r7, #32]
 8008f4e:	3302      	adds	r3, #2
 8008f50:	61fb      	str	r3, [r7, #28]

  if(p_sys_ready_event->sysevt_ready_rsp == WIRELESS_FW_RUNNING)
 8008f52:	69fb      	ldr	r3, [r7, #28]
 8008f54:	781b      	ldrb	r3, [r3, #0]
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	d117      	bne.n	8008f8a <APPE_SysEvtReadyProcessing+0x60>
    * The wireless firmware is running on the CPU2
    */
    APP_DBG_MSG("SHCI_SUB_EVT_CODE_READY - WIRELESS_FW_RUNNING \n");

    /* Traces channel initialization */
    APPD_EnableCPU2( );
 8008f5a:	f7ff fcfd 	bl	8008958 <APPD_EnableCPU2>

    /* Enable all events Notification */
    config_param.PayloadCmdSize = SHCI_C2_CONFIG_PAYLOAD_CMD_SIZE;
 8008f5e:	230d      	movs	r3, #13
 8008f60:	733b      	strb	r3, [r7, #12]
    config_param.EvtMask1 = SHCI_C2_CONFIG_EVTMASK1_BIT0_ERROR_NOTIF_ENABLE
 8008f62:	237f      	movs	r3, #127	; 0x7f
 8008f64:	73bb      	strb	r3, [r7, #14]
    * @brief  Return the device revision identifier
    * @note   This field indicates the revision of the device.
    * @rmtoll DBGMCU_IDCODE REV_ID        LL_DBGMCU_GetRevisionID
    * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
    */
    RevisionID = LL_DBGMCU_GetRevisionID();
 8008f66:	f7ff fdd1 	bl	8008b0c <LL_DBGMCU_GetRevisionID>
 8008f6a:	6278      	str	r0, [r7, #36]	; 0x24

    APP_DBG_MSG("DBGMCU_GetRevisionID= %lx \n\n", RevisionID);

    config_param.RevisionID = RevisionID;
 8008f6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008f6e:	b29b      	uxth	r3, r3
 8008f70:	833b      	strh	r3, [r7, #24]
    (void)SHCI_C2_Config(&config_param);
 8008f72:	f107 030c 	add.w	r3, r7, #12
 8008f76:	4618      	mov	r0, r3
 8008f78:	f012 f980 	bl	801b27c <SHCI_C2_Config>

    APP_BLE_Init( );
 8008f7c:	f01e fbcc 	bl	8027718 <APP_BLE_Init>
    UTIL_LPM_SetOffMode(1U << CFG_LPM_APP, UTIL_LPM_ENABLE);
 8008f80:	2100      	movs	r1, #0
 8008f82:	2001      	movs	r0, #1
 8008f84:	f020 f92e 	bl	80291e4 <UTIL_LPM_SetOffMode>
  else
  {
    APP_DBG_MSG("SHCI_SUB_EVT_CODE_READY - UNEXPECTED CASE \n");
  }

  return;
 8008f88:	e007      	b.n	8008f9a <APPE_SysEvtReadyProcessing+0x70>
  else if (p_sys_ready_event->sysevt_ready_rsp == FUS_FW_RUNNING)
 8008f8a:	69fb      	ldr	r3, [r7, #28]
 8008f8c:	781b      	ldrb	r3, [r3, #0]
 8008f8e:	2b01      	cmp	r3, #1
 8008f90:	d103      	bne.n	8008f9a <APPE_SysEvtReadyProcessing+0x70>
    ((tSHCI_UserEvtRxParam*)pPayload)->status = SHCI_TL_UserEventFlow_Disable;
 8008f92:	687b      	ldr	r3, [r7, #4]
 8008f94:	2200      	movs	r2, #0
 8008f96:	701a      	strb	r2, [r3, #0]
  return;
 8008f98:	bf00      	nop
 8008f9a:	bf00      	nop
}
 8008f9c:	3728      	adds	r7, #40	; 0x28
 8008f9e:	46bd      	mov	sp, r7
 8008fa0:	bd80      	pop	{r7, pc}

08008fa2 <ShciUserEvtProcess>:
 *
 * FREERTOS WRAPPER FUNCTIONS
 *
*************************************************************/
static void ShciUserEvtProcess(void *argument)
{
 8008fa2:	b580      	push	{r7, lr}
 8008fa4:	b082      	sub	sp, #8
 8008fa6:	af00      	add	r7, sp, #0
 8008fa8:	6078      	str	r0, [r7, #4]
  for(;;)
  {
    /* USER CODE BEGIN SHCI_USER_EVT_PROCESS_1 */

    /* USER CODE END SHCI_USER_EVT_PROCESS_1 */
     osThreadFlagsWait(1, osFlagsWaitAny, osWaitForever);
 8008faa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008fae:	2100      	movs	r1, #0
 8008fb0:	2001      	movs	r0, #1
 8008fb2:	f019 fb99 	bl	80226e8 <osThreadFlagsWait>
     shci_user_evt_proc();
 8008fb6:	f012 fbd7 	bl	801b768 <shci_user_evt_proc>
     osThreadFlagsWait(1, osFlagsWaitAny, osWaitForever);
 8008fba:	e7f6      	b.n	8008faa <ShciUserEvtProcess+0x8>

08008fbc <HAL_Delay>:
 *
 * WRAP FUNCTIONS
 *
 *************************************************************/
void HAL_Delay(uint32_t Delay)
{
 8008fbc:	b580      	push	{r7, lr}
 8008fbe:	b084      	sub	sp, #16
 8008fc0:	af00      	add	r7, sp, #0
 8008fc2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8008fc4:	f003 fd60 	bl	800ca88 <HAL_GetTick>
 8008fc8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8008fca:	687b      	ldr	r3, [r7, #4]
 8008fcc:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8008fce:	68fb      	ldr	r3, [r7, #12]
 8008fd0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008fd4:	d00a      	beq.n	8008fec <HAL_Delay+0x30>
  {
    wait += HAL_GetTickFreq();
 8008fd6:	f003 fd6f 	bl	800cab8 <HAL_GetTickFreq>
 8008fda:	4603      	mov	r3, r0
 8008fdc:	461a      	mov	r2, r3
 8008fde:	68fb      	ldr	r3, [r7, #12]
 8008fe0:	4413      	add	r3, r2
 8008fe2:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8008fe4:	e002      	b.n	8008fec <HAL_Delay+0x30>
  {
    /************************************************************************************
     * ENTER SLEEP MODE
     ***********************************************************************************/
    LL_LPM_EnableSleep( ); /**< Clear SLEEPDEEP bit of Cortex System Control Register */
 8008fe6:	f7ff fe01 	bl	8008bec <LL_LPM_EnableSleep>
     */
  #if defined ( __CC_ARM)
    __force_stores();
  #endif

    __WFI( );
 8008fea:	bf30      	wfi
  while ((HAL_GetTick() - tickstart) < wait)
 8008fec:	f003 fd4c 	bl	800ca88 <HAL_GetTick>
 8008ff0:	4602      	mov	r2, r0
 8008ff2:	68bb      	ldr	r3, [r7, #8]
 8008ff4:	1ad3      	subs	r3, r2, r3
 8008ff6:	68fa      	ldr	r2, [r7, #12]
 8008ff8:	429a      	cmp	r2, r3
 8008ffa:	d8f4      	bhi.n	8008fe6 <HAL_Delay+0x2a>
  }
}
 8008ffc:	bf00      	nop
 8008ffe:	bf00      	nop
 8009000:	3710      	adds	r7, #16
 8009002:	46bd      	mov	sp, r7
 8009004:	bd80      	pop	{r7, pc}
	...

08009008 <shci_notify_asynch_evt>:

void shci_notify_asynch_evt(void* pdata)
{
 8009008:	b580      	push	{r7, lr}
 800900a:	b082      	sub	sp, #8
 800900c:	af00      	add	r7, sp, #0
 800900e:	6078      	str	r0, [r7, #4]
  UNUSED(pdata);
  osThreadFlagsSet( ShciUserEvtProcessId, 1 );
 8009010:	4b04      	ldr	r3, [pc, #16]	; (8009024 <shci_notify_asynch_evt+0x1c>)
 8009012:	681b      	ldr	r3, [r3, #0]
 8009014:	2101      	movs	r1, #1
 8009016:	4618      	mov	r0, r3
 8009018:	f019 fb18 	bl	802264c <osThreadFlagsSet>
  return;
 800901c:	bf00      	nop
}
 800901e:	3708      	adds	r7, #8
 8009020:	46bd      	mov	sp, r7
 8009022:	bd80      	pop	{r7, pc}
 8009024:	20011f54 	.word	0x20011f54

08009028 <shci_cmd_resp_release>:

void shci_cmd_resp_release(uint32_t flag)
{
 8009028:	b580      	push	{r7, lr}
 800902a:	b082      	sub	sp, #8
 800902c:	af00      	add	r7, sp, #0
 800902e:	6078      	str	r0, [r7, #4]
  UNUSED(flag);
  osSemaphoreRelease( SemShciId );
 8009030:	4b04      	ldr	r3, [pc, #16]	; (8009044 <shci_cmd_resp_release+0x1c>)
 8009032:	681b      	ldr	r3, [r3, #0]
 8009034:	4618      	mov	r0, r3
 8009036:	f019 fed1 	bl	8022ddc <osSemaphoreRelease>
  return;
 800903a:	bf00      	nop
}
 800903c:	3708      	adds	r7, #8
 800903e:	46bd      	mov	sp, r7
 8009040:	bd80      	pop	{r7, pc}
 8009042:	bf00      	nop
 8009044:	20011f58 	.word	0x20011f58

08009048 <shci_cmd_resp_wait>:

void shci_cmd_resp_wait(uint32_t timeout)
{
 8009048:	b580      	push	{r7, lr}
 800904a:	b082      	sub	sp, #8
 800904c:	af00      	add	r7, sp, #0
 800904e:	6078      	str	r0, [r7, #4]
  UNUSED(timeout);
  osSemaphoreAcquire( SemShciId, osWaitForever );
 8009050:	4b05      	ldr	r3, [pc, #20]	; (8009068 <shci_cmd_resp_wait+0x20>)
 8009052:	681b      	ldr	r3, [r3, #0]
 8009054:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009058:	4618      	mov	r0, r3
 800905a:	f019 fe6d 	bl	8022d38 <osSemaphoreAcquire>
  return;
 800905e:	bf00      	nop
}
 8009060:	3708      	adds	r7, #8
 8009062:	46bd      	mov	sp, r7
 8009064:	bd80      	pop	{r7, pc}
 8009066:	bf00      	nop
 8009068:	20011f58 	.word	0x20011f58

0800906c <_Z16MX_FREERTOS_Initv>:
/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
 800906c:	b580      	push	{r7, lr}
 800906e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */
  /* Create the mutex(es) */
  /* creation of messageI2C1_Lock */
  messageI2C1_LockHandle = osMutexNew(&messageI2C1_Lock_attributes);
 8009070:	4817      	ldr	r0, [pc, #92]	; (80090d0 <_Z16MX_FREERTOS_Initv+0x64>)
 8009072:	f019 fcc9 	bl	8022a08 <osMutexNew>
 8009076:	4603      	mov	r3, r0
 8009078:	4a16      	ldr	r2, [pc, #88]	; (80090d4 <_Z16MX_FREERTOS_Initv+0x68>)
 800907a:	6013      	str	r3, [r2, #0]
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
	/* creation of lightsSimpleQueue */
	lightsComplexQueueHandle = osMessageQueueNew(3, sizeof(union ColorComplex),
 800907c:	4a16      	ldr	r2, [pc, #88]	; (80090d8 <_Z16MX_FREERTOS_Initv+0x6c>)
 800907e:	2112      	movs	r1, #18
 8009080:	2003      	movs	r0, #3
 8009082:	f019 feef 	bl	8022e64 <osMessageQueueNew>
 8009086:	4603      	mov	r3, r0
 8009088:	4a14      	ldr	r2, [pc, #80]	; (80090dc <_Z16MX_FREERTOS_Initv+0x70>)
 800908a:	6013      	str	r3, [r2, #0]
			&lightsComplexQueue_attributes);
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of defaultTask */
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
 800908c:	4a14      	ldr	r2, [pc, #80]	; (80090e0 <_Z16MX_FREERTOS_Initv+0x74>)
 800908e:	2100      	movs	r1, #0
 8009090:	4814      	ldr	r0, [pc, #80]	; (80090e4 <_Z16MX_FREERTOS_Initv+0x78>)
 8009092:	f019 fa49 	bl	8022528 <osThreadNew>
 8009096:	4603      	mov	r3, r0
 8009098:	4a13      	ldr	r2, [pc, #76]	; (80090e8 <_Z16MX_FREERTOS_Initv+0x7c>)
 800909a:	6013      	str	r3, [r2, #0]

  /* creation of frontLightsThre */
  frontLightsThreHandle = osThreadNew(ThreadFrontLightsComplexTask, NULL, &frontLightsThre_attributes);
 800909c:	4a13      	ldr	r2, [pc, #76]	; (80090ec <_Z16MX_FREERTOS_Initv+0x80>)
 800909e:	2100      	movs	r1, #0
 80090a0:	4813      	ldr	r0, [pc, #76]	; (80090f0 <_Z16MX_FREERTOS_Initv+0x84>)
 80090a2:	f019 fa41 	bl	8022528 <osThreadNew>
 80090a6:	4603      	mov	r3, r0
 80090a8:	4a12      	ldr	r2, [pc, #72]	; (80090f4 <_Z16MX_FREERTOS_Initv+0x88>)
 80090aa:	6013      	str	r3, [r2, #0]
  /* creation of thermopileTask */
//  thermopileTaskHandle = osThreadNew(Thermopile_Task, NULL, &thermopileTask_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
	packet_QueueHandle = osMessageQueueNew(MAX_PACKET_QUEUE_SIZE, sizeof(SensorPacket *),
 80090ac:	4a12      	ldr	r2, [pc, #72]	; (80090f8 <_Z16MX_FREERTOS_Initv+0x8c>)
 80090ae:	2104      	movs	r1, #4
 80090b0:	200a      	movs	r0, #10
 80090b2:	f019 fed7 	bl	8022e64 <osMessageQueueNew>
 80090b6:	4603      	mov	r3, r0
 80090b8:	4a10      	ldr	r2, [pc, #64]	; (80090fc <_Z16MX_FREERTOS_Initv+0x90>)
 80090ba:	6013      	str	r3, [r2, #0]
			&packetQueue_attributes);

	packetAvail_QueueHandle = osMessageQueueNew(MAX_PACKET_QUEUE_SIZE, sizeof(SensorPacket *),
 80090bc:	4a10      	ldr	r2, [pc, #64]	; (8009100 <_Z16MX_FREERTOS_Initv+0x94>)
 80090be:	2104      	movs	r1, #4
 80090c0:	200a      	movs	r0, #10
 80090c2:	f019 fecf 	bl	8022e64 <osMessageQueueNew>
 80090c6:	4603      	mov	r3, r0
 80090c8:	4a0e      	ldr	r2, [pc, #56]	; (8009104 <_Z16MX_FREERTOS_Initv+0x98>)
 80090ca:	6013      	str	r3, [r2, #0]

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

}
 80090cc:	bf00      	nop
 80090ce:	bd80      	pop	{r7, pc}
 80090d0:	0802c9cc 	.word	0x0802c9cc
 80090d4:	200003dc 	.word	0x200003dc
 80090d8:	0802c870 	.word	0x0802c870
 80090dc:	200003b4 	.word	0x200003b4
 80090e0:	0802c93c 	.word	0x0802c93c
 80090e4:	08009109 	.word	0x08009109
 80090e8:	200003cc 	.word	0x200003cc
 80090ec:	0802c960 	.word	0x0802c960
 80090f0:	0800a925 	.word	0x0800a925
 80090f4:	200003d0 	.word	0x200003d0
 80090f8:	0802c9dc 	.word	0x0802c9dc
 80090fc:	200003e4 	.word	0x200003e4
 8009100:	0802c9f4 	.word	0x0802c9f4
 8009104:	200003e8 	.word	0x200003e8

08009108 <_Z16StartDefaultTaskPv>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
 8009108:	b580      	push	{r7, lr}
 800910a:	b082      	sub	sp, #8
 800910c:	af00      	add	r7, sp, #0
 800910e:	6078      	str	r0, [r7, #4]
  {
//	osDelay(1000);
	while(1){
//		ledStartupSequence();
//		osDelay(5000);
		osDelay(1);
 8009110:	2001      	movs	r0, #1
 8009112:	f019 fb6a 	bl	80227ea <osDelay>
 8009116:	e7fb      	b.n	8009110 <_Z16StartDefaultTaskPv+0x8>

08009118 <startThreads>:
/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */
#ifdef __cplusplus
extern "C" {
#endif
void startThreads(){
 8009118:	b580      	push	{r7, lr}
 800911a:	af00      	add	r7, sp, #0


	senderTaskHandle = osThreadNew(senderThread, NULL, &senderTask_attributes);
 800911c:	4a1c      	ldr	r2, [pc, #112]	; (8009190 <startThreads+0x78>)
 800911e:	2100      	movs	r1, #0
 8009120:	481c      	ldr	r0, [pc, #112]	; (8009194 <startThreads+0x7c>)
 8009122:	f019 fa01 	bl	8022528 <osThreadNew>
 8009126:	4603      	mov	r3, r0
 8009128:	4a1b      	ldr	r2, [pc, #108]	; (8009198 <startThreads+0x80>)
 800912a:	6013      	str	r3, [r2, #0]

//	/* start sensor subsystem threads */
//	blinkTaskHandle = osThreadNew(BlinkTask, NULL, &blinkTask_attributes);
//
//	/* creation of thermopileTask */
	thermopileTaskHandle = osThreadNew(Thermopile_Task, NULL, &thermopileTask_attributes);
 800912c:	4a1b      	ldr	r2, [pc, #108]	; (800919c <startThreads+0x84>)
 800912e:	2100      	movs	r1, #0
 8009130:	481b      	ldr	r0, [pc, #108]	; (80091a0 <startThreads+0x88>)
 8009132:	f019 f9f9 	bl	8022528 <osThreadNew>
 8009136:	4603      	mov	r3, r0
 8009138:	4a1a      	ldr	r2, [pc, #104]	; (80091a4 <startThreads+0x8c>)
 800913a:	6013      	str	r3, [r2, #0]
	shtTaskHandle = osThreadNew(ShtTask, NULL, &shtTask_attributes);
 800913c:	4a1a      	ldr	r2, [pc, #104]	; (80091a8 <startThreads+0x90>)
 800913e:	2100      	movs	r1, #0
 8009140:	481a      	ldr	r0, [pc, #104]	; (80091ac <startThreads+0x94>)
 8009142:	f019 f9f1 	bl	8022528 <osThreadNew>
 8009146:	4603      	mov	r3, r0
 8009148:	4a19      	ldr	r2, [pc, #100]	; (80091b0 <startThreads+0x98>)
 800914a:	6013      	str	r3, [r2, #0]
	sgpTaskHandle = osThreadNew(SgpTask, NULL, &sgpTask_attributes);
 800914c:	4a19      	ldr	r2, [pc, #100]	; (80091b4 <startThreads+0x9c>)
 800914e:	2100      	movs	r1, #0
 8009150:	4819      	ldr	r0, [pc, #100]	; (80091b8 <startThreads+0xa0>)
 8009152:	f019 f9e9 	bl	8022528 <osThreadNew>
 8009156:	4603      	mov	r3, r0
 8009158:	4a18      	ldr	r2, [pc, #96]	; (80091bc <startThreads+0xa4>)
 800915a:	6013      	str	r3, [r2, #0]
	specTaskHandle = osThreadNew(Spec_Task, NULL, &specTask_attributes);
 800915c:	4a18      	ldr	r2, [pc, #96]	; (80091c0 <startThreads+0xa8>)
 800915e:	2100      	movs	r1, #0
 8009160:	4818      	ldr	r0, [pc, #96]	; (80091c4 <startThreads+0xac>)
 8009162:	f019 f9e1 	bl	8022528 <osThreadNew>
 8009166:	4603      	mov	r3, r0
 8009168:	4a17      	ldr	r2, [pc, #92]	; (80091c8 <startThreads+0xb0>)
 800916a:	6013      	str	r3, [r2, #0]
	luxTaskHandle = osThreadNew(LuxTask, NULL, &luxTask_attributes);
 800916c:	4a17      	ldr	r2, [pc, #92]	; (80091cc <startThreads+0xb4>)
 800916e:	2100      	movs	r1, #0
 8009170:	4817      	ldr	r0, [pc, #92]	; (80091d0 <startThreads+0xb8>)
 8009172:	f019 f9d9 	bl	8022528 <osThreadNew>
 8009176:	4603      	mov	r3, r0
 8009178:	4a16      	ldr	r2, [pc, #88]	; (80091d4 <startThreads+0xbc>)
 800917a:	6013      	str	r3, [r2, #0]
	bmeTaskHandle = osThreadNew(BME_Task, NULL, &bmeTask_attributes);
 800917c:	4a16      	ldr	r2, [pc, #88]	; (80091d8 <startThreads+0xc0>)
 800917e:	2100      	movs	r1, #0
 8009180:	4816      	ldr	r0, [pc, #88]	; (80091dc <startThreads+0xc4>)
 8009182:	f019 f9d1 	bl	8022528 <osThreadNew>
 8009186:	4603      	mov	r3, r0
 8009188:	4a15      	ldr	r2, [pc, #84]	; (80091e0 <startThreads+0xc8>)
 800918a:	6013      	str	r3, [r2, #0]
//	  /* creation of frontLightsThre */
//	  frontLightsThreHandle = osThreadNew(ThreadFrontLightsComplexTask, NULL, &frontLightsThre_attributes);
	//


}
 800918c:	bf00      	nop
 800918e:	bd80      	pop	{r7, pc}
 8009190:	0802c9a8 	.word	0x0802c9a8
 8009194:	0800af55 	.word	0x0800af55
 8009198:	200003d8 	.word	0x200003d8
 800919c:	0802c984 	.word	0x0802c984
 80091a0:	0800c2a9 	.word	0x0800c2a9
 80091a4:	200003d4 	.word	0x200003d4
 80091a8:	0802c8d0 	.word	0x0802c8d0
 80091ac:	0800b7bd 	.word	0x0800b7bd
 80091b0:	200003c0 	.word	0x200003c0
 80091b4:	0802c918 	.word	0x0802c918
 80091b8:	0800b2f9 	.word	0x0800b2f9
 80091bc:	200003c8 	.word	0x200003c8
 80091c0:	0802c888 	.word	0x0802c888
 80091c4:	0800ba31 	.word	0x0800ba31
 80091c8:	200003b8 	.word	0x200003b8
 80091cc:	0802c8ac 	.word	0x0802c8ac
 80091d0:	0800aaad 	.word	0x0800aaad
 80091d4:	200003bc 	.word	0x200003bc
 80091d8:	0802c8f4 	.word	0x0802c8f4
 80091dc:	080091f9 	.word	0x080091f9
 80091e0:	200003c4 	.word	0x200003c4

080091e4 <HAL_TIM_PWM_PulseFinishedCallback>:
	blink_ptr = blink_buffer;
	osThreadFlagsSet(blinkTaskHandle, 0x00000004U);

}

void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim) {
 80091e4:	b480      	push	{r7}
 80091e6:	b083      	sub	sp, #12
 80091e8:	af00      	add	r7, sp, #0
 80091ea:	6078      	str	r0, [r7, #4]
//	}
//	pwm_tracker++;

//	low_adc_sample = 1;
//	HAL_ADC_Start(&hadc1);
}
 80091ec:	bf00      	nop
 80091ee:	370c      	adds	r7, #12
 80091f0:	46bd      	mov	sp, r7
 80091f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091f6:	4770      	bx	lr

080091f8 <BME_Task>:

uint8_t bmeConfig[BSEC_MAX_PROPERTY_BLOB_SIZE];
uint8_t bmeState[BSEC_MAX_STATE_BLOB_SIZE];


void BME_Task(void *argument) {
 80091f8:	b5b0      	push	{r4, r5, r7, lr}
 80091fa:	b08a      	sub	sp, #40	; 0x28
 80091fc:	af00      	add	r7, sp, #0
 80091fe:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 8009200:	2300      	movs	r3, #0
 8009202:	617b      	str	r3, [r7, #20]
	uint32_t flags = 0;
 8009204:	2300      	movs	r3, #0
 8009206:	613b      	str	r3, [r7, #16]


	uint32_t timeSinceLastStateSave = 0;
 8009208:	2300      	movs	r3, #0
 800920a:	627b      	str	r3, [r7, #36]	; 0x24

	osDelay(500);
 800920c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8009210:	f019 faeb 	bl	80227ea <osDelay>

	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 8009214:	4b7e      	ldr	r3, [pc, #504]	; (8009410 <BME_Task+0x218>)
 8009216:	681b      	ldr	r3, [r3, #0]
 8009218:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800921c:	4618      	mov	r0, r3
 800921e:	f019 fd8b 	bl	8022d38 <osSemaphoreAcquire>
	while (!bme.begin(BME68X_DEFAULT_ADDRESS, &hi2c1, false)) {
 8009222:	2300      	movs	r3, #0
 8009224:	4a7b      	ldr	r2, [pc, #492]	; (8009414 <BME_Task+0x21c>)
 8009226:	2176      	movs	r1, #118	; 0x76
 8009228:	487b      	ldr	r0, [pc, #492]	; (8009418 <BME_Task+0x220>)
 800922a:	f013 fbe7 	bl	801c9fc <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb>
 800922e:	4603      	mov	r3, r0
 8009230:	f083 0301 	eor.w	r3, r3, #1
 8009234:	b2db      	uxtb	r3, r3
 8009236:	2b00      	cmp	r3, #0
 8009238:	d003      	beq.n	8009242 <BME_Task+0x4a>
		osDelay(100);
 800923a:	2064      	movs	r0, #100	; 0x64
 800923c:	f019 fad5 	bl	80227ea <osDelay>
	while (!bme.begin(BME68X_DEFAULT_ADDRESS, &hi2c1, false)) {
 8009240:	e7ef      	b.n	8009222 <BME_Task+0x2a>
			;
	}


	recoverBME_StateConfig();
 8009242:	f000 f921 	bl	8009488 <recoverBME_StateConfig>

	osSemaphoreRelease(messageI2C1_LockHandle);
 8009246:	4b72      	ldr	r3, [pc, #456]	; (8009410 <BME_Task+0x218>)
 8009248:	681b      	ldr	r3, [r3, #0]
 800924a:	4618      	mov	r0, r3
 800924c:	f019 fdc6 	bl	8022ddc <osSemaphoreRelease>

	bme.bsecSubscribe();
 8009250:	4871      	ldr	r0, [pc, #452]	; (8009418 <BME_Task+0x220>)
 8009252:	f013 fc69 	bl	801cb28 <_ZN15Adafruit_BME68013bsecSubscribeEv>
//	bme.setHumidityOversampling(BME680_OS_2X);
//	bme.setPressureOversampling(BME680_OS_4X);
//	bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
//	bme.setGasHeater(320, 150); // 320*C for 150 ms

	header.reserved[0] = BME_SAMPLE_PERIOD_MS;
 8009256:	4b71      	ldr	r3, [pc, #452]	; (800941c <BME_Task+0x224>)
 8009258:	f640 32b8 	movw	r2, #3000	; 0xbb8
 800925c:	611a      	str	r2, [r3, #16]

	uint16_t bmeIdx = 0;
 800925e:	2300      	movs	r3, #0
 8009260:	847b      	strh	r3, [r7, #34]	; 0x22
	uint32_t bmeID = 0;
 8009262:	2300      	movs	r3, #0
 8009264:	61fb      	str	r3, [r7, #28]
//			timeRemaining = floor((bme.bmeConf.next_call/1000000.0) - HAL_GetTick());
//			if(timeRemaining > BME_WAIT_TOL){
//				osDelay( (timeRemaining - BME_WAIT_TOL) );
//			}

			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 8009266:	4b6a      	ldr	r3, [pc, #424]	; (8009410 <BME_Task+0x218>)
 8009268:	681b      	ldr	r3, [r3, #0]
 800926a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800926e:	4618      	mov	r0, r3
 8009270:	f019 fd62 	bl	8022d38 <osSemaphoreAcquire>
//			taskENTER_CRITICAL();
			while(!bme.bsecRun()){
 8009274:	4868      	ldr	r0, [pc, #416]	; (8009418 <BME_Task+0x220>)
 8009276:	f013 fe8d 	bl	801cf94 <_ZN15Adafruit_BME6807bsecRunEv>
 800927a:	4603      	mov	r3, r0
 800927c:	f083 0301 	eor.w	r3, r3, #1
 8009280:	b2db      	uxtb	r3, r3
 8009282:	2b00      	cmp	r3, #0
 8009284:	d051      	beq.n	800932a <BME_Task+0x132>
//				taskEXIT_CRITICAL();

				timeRemaining = floor((bme.bmeConf.next_call/1000000.0) - HAL_GetTick());
 8009286:	4b64      	ldr	r3, [pc, #400]	; (8009418 <BME_Task+0x220>)
 8009288:	e9d3 231e 	ldrd	r2, r3, [r3, #120]	; 0x78
 800928c:	4610      	mov	r0, r2
 800928e:	4619      	mov	r1, r3
 8009290:	f7fe fc04 	bl	8007a9c <__aeabi_l2d>
 8009294:	a35c      	add	r3, pc, #368	; (adr r3, 8009408 <BME_Task+0x210>)
 8009296:	e9d3 2300 	ldrd	r2, r3, [r3]
 800929a:	f7fe fd57 	bl	8007d4c <__aeabi_ddiv>
 800929e:	4602      	mov	r2, r0
 80092a0:	460b      	mov	r3, r1
 80092a2:	4614      	mov	r4, r2
 80092a4:	461d      	mov	r5, r3
 80092a6:	f003 fbef 	bl	800ca88 <HAL_GetTick>
 80092aa:	4603      	mov	r3, r0
 80092ac:	4618      	mov	r0, r3
 80092ae:	f7fe fba9 	bl	8007a04 <__aeabi_ui2d>
 80092b2:	4602      	mov	r2, r0
 80092b4:	460b      	mov	r3, r1
 80092b6:	4620      	mov	r0, r4
 80092b8:	4629      	mov	r1, r5
 80092ba:	f7fe fa65 	bl	8007788 <__aeabi_dsub>
 80092be:	4602      	mov	r2, r0
 80092c0:	460b      	mov	r3, r1
 80092c2:	ec43 2b17 	vmov	d7, r2, r3
 80092c6:	eeb0 0a47 	vmov.f32	s0, s14
 80092ca:	eef0 0a67 	vmov.f32	s1, s15
 80092ce:	f020 f87b 	bl	80293c8 <floor>
 80092d2:	ec53 2b10 	vmov	r2, r3, d0
 80092d6:	4610      	mov	r0, r2
 80092d8:	4619      	mov	r1, r3
 80092da:	f7ff f8cb 	bl	8008474 <__aeabi_d2lz>
 80092de:	4602      	mov	r2, r0
 80092e0:	460b      	mov	r3, r1
 80092e2:	e9c7 2302 	strd	r2, r3, [r7, #8]
				if(timeRemaining > BME_WAIT_TOL){
 80092e6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80092ea:	2a0b      	cmp	r2, #11
 80092ec:	f173 0300 	sbcs.w	r3, r3, #0
 80092f0:	db11      	blt.n	8009316 <BME_Task+0x11e>
					osSemaphoreRelease(messageI2C1_LockHandle);
 80092f2:	4b47      	ldr	r3, [pc, #284]	; (8009410 <BME_Task+0x218>)
 80092f4:	681b      	ldr	r3, [r3, #0]
 80092f6:	4618      	mov	r0, r3
 80092f8:	f019 fd70 	bl	8022ddc <osSemaphoreRelease>
					osDelay( (timeRemaining-BME_WAIT_TOL) );
 80092fc:	68bb      	ldr	r3, [r7, #8]
 80092fe:	3b0a      	subs	r3, #10
 8009300:	4618      	mov	r0, r3
 8009302:	f019 fa72 	bl	80227ea <osDelay>
					osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 8009306:	4b42      	ldr	r3, [pc, #264]	; (8009410 <BME_Task+0x218>)
 8009308:	681b      	ldr	r3, [r3, #0]
 800930a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800930e:	4618      	mov	r0, r3
 8009310:	f019 fd12 	bl	8022d38 <osSemaphoreAcquire>
 8009314:	e7ae      	b.n	8009274 <BME_Task+0x7c>
				}else if(timeRemaining > 1){
 8009316:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800931a:	2a02      	cmp	r2, #2
 800931c:	f173 0300 	sbcs.w	r3, r3, #0
 8009320:	dba8      	blt.n	8009274 <BME_Task+0x7c>
					osDelay(1);
 8009322:	2001      	movs	r0, #1
 8009324:	f019 fa61 	bl	80227ea <osDelay>
			while(!bme.bsecRun()){
 8009328:	e7a4      	b.n	8009274 <BME_Task+0x7c>
				}

//				taskENTER_CRITICAL();
			}
			osSemaphoreRelease(messageI2C1_LockHandle);
 800932a:	4b39      	ldr	r3, [pc, #228]	; (8009410 <BME_Task+0x218>)
 800932c:	681b      	ldr	r3, [r3, #0]
 800932e:	4618      	mov	r0, r3
 8009330:	f019 fd54 	bl	8022ddc <osSemaphoreRelease>
//			taskEXIT_CRITICAL();

			for(int i = 0; i<bme.outputs.nOutputs; i++){
 8009334:	2300      	movs	r3, #0
 8009336:	61bb      	str	r3, [r7, #24]
 8009338:	4b37      	ldr	r3, [pc, #220]	; (8009418 <BME_Task+0x220>)
 800933a:	f893 3158 	ldrb.w	r3, [r3, #344]	; 0x158
 800933e:	461a      	mov	r2, r3
 8009340:	69bb      	ldr	r3, [r7, #24]
 8009342:	4293      	cmp	r3, r2
 8009344:	da12      	bge.n	800936c <BME_Task+0x174>
				memcpy(&bmeData[bmeIdx++], &bme.outputs.output[i], sizeof(bsecData));
 8009346:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8009348:	1c5a      	adds	r2, r3, #1
 800934a:	847a      	strh	r2, [r7, #34]	; 0x22
 800934c:	011b      	lsls	r3, r3, #4
 800934e:	4a34      	ldr	r2, [pc, #208]	; (8009420 <BME_Task+0x228>)
 8009350:	1898      	adds	r0, r3, r2
 8009352:	69bb      	ldr	r3, [r7, #24]
 8009354:	011b      	lsls	r3, r3, #4
 8009356:	33b8      	adds	r3, #184	; 0xb8
 8009358:	4a2f      	ldr	r2, [pc, #188]	; (8009418 <BME_Task+0x220>)
 800935a:	4413      	add	r3, r2
 800935c:	2210      	movs	r2, #16
 800935e:	4619      	mov	r1, r3
 8009360:	f022 febe 	bl	802c0e0 <memcpy>
			for(int i = 0; i<bme.outputs.nOutputs; i++){
 8009364:	69bb      	ldr	r3, [r7, #24]
 8009366:	3301      	adds	r3, #1
 8009368:	61bb      	str	r3, [r7, #24]
 800936a:	e7e5      	b.n	8009338 <BME_Task+0x140>
//
//			bmeIdx++;
//			if (bmeIdx >= (MAX_BME_SAMPLES_PACKET - BSEC_NUMBER_OUTPUTS) ) {
			if (1) {

				header.packetType = BME;
 800936c:	4b2b      	ldr	r3, [pc, #172]	; (800941c <BME_Task+0x224>)
 800936e:	2204      	movs	r2, #4
 8009370:	701a      	strb	r2, [r3, #0]
				header.packetID = bmeID;
 8009372:	69fb      	ldr	r3, [r7, #28]
 8009374:	b29a      	uxth	r2, r3
 8009376:	4b29      	ldr	r3, [pc, #164]	; (800941c <BME_Task+0x224>)
 8009378:	805a      	strh	r2, [r3, #2]
				header.msFromStart = HAL_GetTick();
 800937a:	f003 fb85 	bl	800ca88 <HAL_GetTick>
 800937e:	4603      	mov	r3, r0
 8009380:	4a26      	ldr	r2, [pc, #152]	; (800941c <BME_Task+0x224>)
 8009382:	6053      	str	r3, [r2, #4]
				header.payloadLength = bmeIdx * sizeof(bsecData);
 8009384:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8009386:	011b      	lsls	r3, r3, #4
 8009388:	4a24      	ldr	r2, [pc, #144]	; (800941c <BME_Task+0x224>)
 800938a:	60d3      	str	r3, [r2, #12]
				packet = grabPacket();
 800938c:	f001 fdb4 	bl	800aef8 <grabPacket>
 8009390:	6178      	str	r0, [r7, #20]
				if (packet != NULL) {
 8009392:	697b      	ldr	r3, [r7, #20]
 8009394:	2b00      	cmp	r3, #0
 8009396:	d010      	beq.n	80093ba <BME_Task+0x1c2>
					memcpy(&(packet->header), &header, sizeof(PacketHeader));
 8009398:	697b      	ldr	r3, [r7, #20]
 800939a:	2224      	movs	r2, #36	; 0x24
 800939c:	491f      	ldr	r1, [pc, #124]	; (800941c <BME_Task+0x224>)
 800939e:	4618      	mov	r0, r3
 80093a0:	f022 fe9e 	bl	802c0e0 <memcpy>
					memcpy(packet->payload, bmeData, header.payloadLength);
 80093a4:	697b      	ldr	r3, [r7, #20]
 80093a6:	3324      	adds	r3, #36	; 0x24
 80093a8:	4a1c      	ldr	r2, [pc, #112]	; (800941c <BME_Task+0x224>)
 80093aa:	68d2      	ldr	r2, [r2, #12]
 80093ac:	491c      	ldr	r1, [pc, #112]	; (8009420 <BME_Task+0x228>)
 80093ae:	4618      	mov	r0, r3
 80093b0:	f022 fe96 	bl	802c0e0 <memcpy>
					queueUpPacket(packet);
 80093b4:	6978      	ldr	r0, [r7, #20]
 80093b6:	f001 fdbb 	bl	800af30 <queueUpPacket>
				}
				bmeID++;
 80093ba:	69fb      	ldr	r3, [r7, #28]
 80093bc:	3301      	adds	r3, #1
 80093be:	61fb      	str	r3, [r7, #28]
				bmeIdx = 0;
 80093c0:	2300      	movs	r3, #0
 80093c2:	847b      	strh	r3, [r7, #34]	; 0x22

			}

			if( (HAL_GetTick() - timeSinceLastStateSave) >= BME_SAVE_STATE_PERIOD_MS){
 80093c4:	f003 fb60 	bl	800ca88 <HAL_GetTick>
 80093c8:	4602      	mov	r2, r0
 80093ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80093cc:	1ad3      	subs	r3, r2, r3
 80093ce:	4a15      	ldr	r2, [pc, #84]	; (8009424 <BME_Task+0x22c>)
 80093d0:	4293      	cmp	r3, r2
 80093d2:	bf2c      	ite	cs
 80093d4:	2301      	movcs	r3, #1
 80093d6:	2300      	movcc	r3, #0
 80093d8:	b2db      	uxtb	r3, r3
 80093da:	2b00      	cmp	r3, #0
 80093dc:	d004      	beq.n	80093e8 <BME_Task+0x1f0>
				saveBME_StateConfig();
 80093de:	f000 f825 	bl	800942c <saveBME_StateConfig>
				timeSinceLastStateSave = HAL_GetTick();
 80093e2:	f003 fb51 	bl	800ca88 <HAL_GetTick>
 80093e6:	6278      	str	r0, [r7, #36]	; 0x24
			}

		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 80093e8:	693b      	ldr	r3, [r7, #16]
 80093ea:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80093ee:	2b00      	cmp	r3, #0
 80093f0:	f43f af39 	beq.w	8009266 <BME_Task+0x6e>
			osTimerDelete (periodicBMETimer_id);
 80093f4:	4b0c      	ldr	r3, [pc, #48]	; (8009428 <BME_Task+0x230>)
 80093f6:	681b      	ldr	r3, [r3, #0]
 80093f8:	4618      	mov	r0, r3
 80093fa:	f019 fad1 	bl	80229a0 <osTimerDelete>
			break;
 80093fe:	bf00      	nop
		}
	}
}
 8009400:	bf00      	nop
 8009402:	3728      	adds	r7, #40	; 0x28
 8009404:	46bd      	mov	sp, r7
 8009406:	bdb0      	pop	{r4, r5, r7, pc}
 8009408:	00000000 	.word	0x00000000
 800940c:	412e8480 	.word	0x412e8480
 8009410:	200003dc 	.word	0x200003dc
 8009414:	20011fa8 	.word	0x20011fa8
 8009418:	200005e8 	.word	0x200005e8
 800941c:	200005c0 	.word	0x200005c0
 8009420:	200003f0 	.word	0x200003f0
 8009424:	006ddd00 	.word	0x006ddd00
 8009428:	200005e4 	.word	0x200005e4

0800942c <saveBME_StateConfig>:

void saveBME_StateConfig(){
 800942c:	b580      	push	{r7, lr}
 800942e:	b082      	sub	sp, #8
 8009430:	af00      	add	r7, sp, #0
	uint32_t bsecReturnLen;

	bme.bsecGetConfig(bmeConfig, &bsecReturnLen);
 8009432:	1d3b      	adds	r3, r7, #4
 8009434:	461a      	mov	r2, r3
 8009436:	4911      	ldr	r1, [pc, #68]	; (800947c <saveBME_StateConfig+0x50>)
 8009438:	4811      	ldr	r0, [pc, #68]	; (8009480 <saveBME_StateConfig+0x54>)
 800943a:	f013 fd1f 	bl	801ce7c <_ZN15Adafruit_BME68013bsecGetConfigEPhPm>
	bme.bsecGetState(bmeState, &bsecReturnLen);
 800943e:	1d3b      	adds	r3, r7, #4
 8009440:	461a      	mov	r2, r3
 8009442:	4910      	ldr	r1, [pc, #64]	; (8009484 <saveBME_StateConfig+0x58>)
 8009444:	480e      	ldr	r0, [pc, #56]	; (8009480 <saveBME_StateConfig+0x54>)
 8009446:	f013 fd3d 	bl	801cec4 <_ZN15Adafruit_BME68012bsecGetStateEPhPm>

	taskENTER_CRITICAL();
 800944a:	f01c ff53 	bl	80262f4 <vPortEnterCritical>
	extMemWriteData(BME_CONFIG_ADDR, bmeConfig, BME_CONFIG_SIZE);
 800944e:	f640 02ed 	movw	r2, #2285	; 0x8ed
 8009452:	490a      	ldr	r1, [pc, #40]	; (800947c <saveBME_StateConfig+0x50>)
 8009454:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009458:	f000 f920 	bl	800969c <extMemWriteData>
	taskEXIT_CRITICAL();
 800945c:	f01c ff7a 	bl	8026354 <vPortExitCritical>
	taskENTER_CRITICAL();
 8009460:	f01c ff48 	bl	80262f4 <vPortEnterCritical>
	extMemWriteData(BME_STATE_ADDR, bmeState, BME_STATE_SIZE);
 8009464:	22d5      	movs	r2, #213	; 0xd5
 8009466:	4907      	ldr	r1, [pc, #28]	; (8009484 <saveBME_StateConfig+0x58>)
 8009468:	f640 40d5 	movw	r0, #3285	; 0xcd5
 800946c:	f000 f916 	bl	800969c <extMemWriteData>
	taskEXIT_CRITICAL();
 8009470:	f01c ff70 	bl	8026354 <vPortExitCritical>
}
 8009474:	bf00      	nop
 8009476:	3708      	adds	r7, #8
 8009478:	46bd      	mov	sp, r7
 800947a:	bd80      	pop	{r7, pc}
 800947c:	200007d8 	.word	0x200007d8
 8009480:	200005e8 	.word	0x200005e8
 8009484:	200010c8 	.word	0x200010c8

08009488 <recoverBME_StateConfig>:

void recoverBME_StateConfig(){
 8009488:	b580      	push	{r7, lr}
 800948a:	b082      	sub	sp, #8
 800948c:	af00      	add	r7, sp, #0
	uint8_t conditionedSystem = 0;
 800948e:	2300      	movs	r3, #0
 8009490:	71fb      	strb	r3, [r7, #7]
	extMemGetData(BME_FIRST_RUN_ADDR, &conditionedSystem, BME_FIRST_RUN_SIZE);
 8009492:	1dfb      	adds	r3, r7, #7
 8009494:	2201      	movs	r2, #1
 8009496:	4619      	mov	r1, r3
 8009498:	f640 50aa 	movw	r0, #3498	; 0xdaa
 800949c:	f000 f8b6 	bl	800960c <extMemGetData>

	if(conditionedSystem == 0){
 80094a0:	79fb      	ldrb	r3, [r7, #7]
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d10f      	bne.n	80094c6 <recoverBME_StateConfig+0x3e>
		bme.bsecSetConfig(bsec_config_selectivity);
 80094a6:	4914      	ldr	r1, [pc, #80]	; (80094f8 <recoverBME_StateConfig+0x70>)
 80094a8:	4814      	ldr	r0, [pc, #80]	; (80094fc <recoverBME_StateConfig+0x74>)
 80094aa:	f013 fd2f 	bl	801cf0c <_ZN15Adafruit_BME68013bsecSetConfigEPKh>
		saveBME_StateConfig();
 80094ae:	f7ff ffbd 	bl	800942c <saveBME_StateConfig>
		conditionedSystem = 1;
 80094b2:	2301      	movs	r3, #1
 80094b4:	71fb      	strb	r3, [r7, #7]
		extMemWriteData(BME_FIRST_RUN_ADDR, &conditionedSystem, BME_FIRST_RUN_SIZE);
 80094b6:	1dfb      	adds	r3, r7, #7
 80094b8:	2201      	movs	r2, #1
 80094ba:	4619      	mov	r1, r3
 80094bc:	f640 50aa 	movw	r0, #3498	; 0xdaa
 80094c0:	f000 f8ec 	bl	800969c <extMemWriteData>

		bme.bsecSetConfig(bmeConfig);
		bme.bsecSetState(bmeState);
	}

}
 80094c4:	e014      	b.n	80094f0 <recoverBME_StateConfig+0x68>
		extMemGetData(BME_CONFIG_ADDR, bmeConfig, BME_CONFIG_SIZE);
 80094c6:	f640 02ed 	movw	r2, #2285	; 0x8ed
 80094ca:	490d      	ldr	r1, [pc, #52]	; (8009500 <recoverBME_StateConfig+0x78>)
 80094cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80094d0:	f000 f89c 	bl	800960c <extMemGetData>
		extMemGetData(BME_STATE_ADDR, bmeState, BME_STATE_SIZE);
 80094d4:	22d5      	movs	r2, #213	; 0xd5
 80094d6:	490b      	ldr	r1, [pc, #44]	; (8009504 <recoverBME_StateConfig+0x7c>)
 80094d8:	f640 40d5 	movw	r0, #3285	; 0xcd5
 80094dc:	f000 f896 	bl	800960c <extMemGetData>
		bme.bsecSetConfig(bmeConfig);
 80094e0:	4907      	ldr	r1, [pc, #28]	; (8009500 <recoverBME_StateConfig+0x78>)
 80094e2:	4806      	ldr	r0, [pc, #24]	; (80094fc <recoverBME_StateConfig+0x74>)
 80094e4:	f013 fd12 	bl	801cf0c <_ZN15Adafruit_BME68013bsecSetConfigEPKh>
		bme.bsecSetState(bmeState);
 80094e8:	4906      	ldr	r1, [pc, #24]	; (8009504 <recoverBME_StateConfig+0x7c>)
 80094ea:	4804      	ldr	r0, [pc, #16]	; (80094fc <recoverBME_StateConfig+0x74>)
 80094ec:	f013 fd34 	bl	801cf58 <_ZN15Adafruit_BME68012bsecSetStateEPKh>
}
 80094f0:	bf00      	nop
 80094f2:	3708      	adds	r7, #8
 80094f4:	46bd      	mov	sp, r7
 80094f6:	bd80      	pop	{r7, pc}
 80094f8:	0802cbe4 	.word	0x0802cbe4
 80094fc:	200005e8 	.word	0x200005e8
 8009500:	200007d8 	.word	0x200007d8
 8009504:	200010c8 	.word	0x200010c8

08009508 <_Z41__static_initialization_and_destruction_0ii>:

static void triggerBMESample(void *argument) {
	osThreadFlagsSet(bmeTaskHandle, GRAB_SAMPLE_BIT);
}
 8009508:	b580      	push	{r7, lr}
 800950a:	b082      	sub	sp, #8
 800950c:	af00      	add	r7, sp, #0
 800950e:	6078      	str	r0, [r7, #4]
 8009510:	6039      	str	r1, [r7, #0]
 8009512:	687b      	ldr	r3, [r7, #4]
 8009514:	2b01      	cmp	r3, #1
 8009516:	d107      	bne.n	8009528 <_Z41__static_initialization_and_destruction_0ii+0x20>
 8009518:	683b      	ldr	r3, [r7, #0]
 800951a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800951e:	4293      	cmp	r3, r2
 8009520:	d102      	bne.n	8009528 <_Z41__static_initialization_and_destruction_0ii+0x20>
Adafruit_BME680 bme;
 8009522:	4803      	ldr	r0, [pc, #12]	; (8009530 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 8009524:	f013 fa4e 	bl	801c9c4 <_ZN15Adafruit_BME680C1Ev>
}
 8009528:	bf00      	nop
 800952a:	3708      	adds	r7, #8
 800952c:	46bd      	mov	sp, r7
 800952e:	bd80      	pop	{r7, pc}
 8009530:	200005e8 	.word	0x200005e8

08009534 <_GLOBAL__sub_I_periodicBMETimer_id>:
 8009534:	b580      	push	{r7, lr}
 8009536:	af00      	add	r7, sp, #0
 8009538:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800953c:	2001      	movs	r0, #1
 800953e:	f7ff ffe3 	bl	8009508 <_Z41__static_initialization_and_destruction_0ii>
 8009542:	bd80      	pop	{r7, pc}

08009544 <LL_AHB1_GRP1_EnableClock>:
{
 8009544:	b480      	push	{r7}
 8009546:	b085      	sub	sp, #20
 8009548:	af00      	add	r7, sp, #0
 800954a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 800954c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009550:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8009552:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8009556:	687b      	ldr	r3, [r7, #4]
 8009558:	4313      	orrs	r3, r2
 800955a:	648b      	str	r3, [r1, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800955c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009560:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8009562:	687b      	ldr	r3, [r7, #4]
 8009564:	4013      	ands	r3, r2
 8009566:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8009568:	68fb      	ldr	r3, [r7, #12]
}
 800956a:	bf00      	nop
 800956c:	3714      	adds	r7, #20
 800956e:	46bd      	mov	sp, r7
 8009570:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009574:	4770      	bx	lr

08009576 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8009576:	b580      	push	{r7, lr}
 8009578:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 800957a:	2004      	movs	r0, #4
 800957c:	f7ff ffe2 	bl	8009544 <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8009580:	2001      	movs	r0, #1
 8009582:	f7ff ffdf 	bl	8009544 <LL_AHB1_GRP1_EnableClock>

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8009586:	2200      	movs	r2, #0
 8009588:	2105      	movs	r1, #5
 800958a:	200b      	movs	r0, #11
 800958c:	f004 fa56 	bl	800da3c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8009590:	200b      	movs	r0, #11
 8009592:	f004 fa6d 	bl	800da70 <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
 8009596:	2200      	movs	r2, #0
 8009598:	2105      	movs	r1, #5
 800959a:	200c      	movs	r0, #12
 800959c:	f004 fa4e 	bl	800da3c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 80095a0:	200c      	movs	r0, #12
 80095a2:	f004 fa65 	bl	800da70 <HAL_NVIC_EnableIRQ>

}
 80095a6:	bf00      	nop
 80095a8:	bd80      	pop	{r7, pc}
	...

080095ac <_Z22extMemWriteEnableLatchb>:

#define SPI_HAN &hspi1

uint8_t header[4];

bool extMemWriteEnableLatch(bool state){
 80095ac:	b580      	push	{r7, lr}
 80095ae:	b084      	sub	sp, #16
 80095b0:	af00      	add	r7, sp, #0
 80095b2:	4603      	mov	r3, r0
 80095b4:	71fb      	strb	r3, [r7, #7]
	uint8_t dataTX;
	extMemChipSelectPin(true);
 80095b6:	2001      	movs	r0, #1
 80095b8:	f000 f8ba 	bl	8009730 <extMemChipSelectPin>
	if(state){
 80095bc:	79fb      	ldrb	r3, [r7, #7]
 80095be:	2b00      	cmp	r3, #0
 80095c0:	d009      	beq.n	80095d6 <_Z22extMemWriteEnableLatchb+0x2a>
		dataTX = WREN;
 80095c2:	2306      	movs	r3, #6
 80095c4:	73fb      	strb	r3, [r7, #15]
		HAL_SPI_Transmit(SPI_HAN, &dataTX, 1, 10);
 80095c6:	f107 010f 	add.w	r1, r7, #15
 80095ca:	230a      	movs	r3, #10
 80095cc:	2201      	movs	r2, #1
 80095ce:	480a      	ldr	r0, [pc, #40]	; (80095f8 <_Z22extMemWriteEnableLatchb+0x4c>)
 80095d0:	f00a fe9b 	bl	801430a <HAL_SPI_Transmit>
 80095d4:	e008      	b.n	80095e8 <_Z22extMemWriteEnableLatchb+0x3c>
	}else{
		dataTX = WRDI;
 80095d6:	2304      	movs	r3, #4
 80095d8:	73fb      	strb	r3, [r7, #15]
		HAL_SPI_Transmit(SPI_HAN, &dataTX, 1, 10);
 80095da:	f107 010f 	add.w	r1, r7, #15
 80095de:	230a      	movs	r3, #10
 80095e0:	2201      	movs	r2, #1
 80095e2:	4805      	ldr	r0, [pc, #20]	; (80095f8 <_Z22extMemWriteEnableLatchb+0x4c>)
 80095e4:	f00a fe91 	bl	801430a <HAL_SPI_Transmit>
	}
	extMemChipSelectPin(false);
 80095e8:	2000      	movs	r0, #0
 80095ea:	f000 f8a1 	bl	8009730 <extMemChipSelectPin>
	return true;
 80095ee:	2301      	movs	r3, #1
}
 80095f0:	4618      	mov	r0, r3
 80095f2:	3710      	adds	r7, #16
 80095f4:	46bd      	mov	sp, r7
 80095f6:	bd80      	pop	{r7, pc}
 80095f8:	200121f0 	.word	0x200121f0

080095fc <extMemInit>:


bool extMemInit(){
 80095fc:	b580      	push	{r7, lr}
 80095fe:	af00      	add	r7, sp, #0
	extMemWriteEnableLatch(true);
 8009600:	2001      	movs	r0, #1
 8009602:	f7ff ffd3 	bl	80095ac <_Z22extMemWriteEnableLatchb>
	return true;
 8009606:	2301      	movs	r3, #1
}
 8009608:	4618      	mov	r0, r3
 800960a:	bd80      	pop	{r7, pc}

0800960c <extMemGetData>:
	dataTX[1] = dataRX[1] | WRSR_WriteEnable;
	HAL_SPI_Transmit(SPI_HAN, dataTX, 2, 10);
	return true;
}

bool extMemGetData(uint32_t addr, uint8_t* data, uint16_t size){
 800960c:	b580      	push	{r7, lr}
 800960e:	b084      	sub	sp, #16
 8009610:	af00      	add	r7, sp, #0
 8009612:	60f8      	str	r0, [r7, #12]
 8009614:	60b9      	str	r1, [r7, #8]
 8009616:	4613      	mov	r3, r2
 8009618:	80fb      	strh	r3, [r7, #6]

	extMemChipSelectPin(true);
 800961a:	2001      	movs	r0, #1
 800961c:	f000 f888 	bl	8009730 <extMemChipSelectPin>

	header[0] = READ;
 8009620:	4b1c      	ldr	r3, [pc, #112]	; (8009694 <extMemGetData+0x88>)
 8009622:	2203      	movs	r2, #3
 8009624:	701a      	strb	r2, [r3, #0]
	header[1] = (addr >> 16) & 0xFF;
 8009626:	68fb      	ldr	r3, [r7, #12]
 8009628:	0c1b      	lsrs	r3, r3, #16
 800962a:	b2da      	uxtb	r2, r3
 800962c:	4b19      	ldr	r3, [pc, #100]	; (8009694 <extMemGetData+0x88>)
 800962e:	705a      	strb	r2, [r3, #1]
	header[2] = (addr >> 8) & 0xFF;
 8009630:	68fb      	ldr	r3, [r7, #12]
 8009632:	0a1b      	lsrs	r3, r3, #8
 8009634:	b2da      	uxtb	r2, r3
 8009636:	4b17      	ldr	r3, [pc, #92]	; (8009694 <extMemGetData+0x88>)
 8009638:	709a      	strb	r2, [r3, #2]
	header[3] = (addr) & 0xFF;
 800963a:	68fb      	ldr	r3, [r7, #12]
 800963c:	b2da      	uxtb	r2, r3
 800963e:	4b15      	ldr	r3, [pc, #84]	; (8009694 <extMemGetData+0x88>)
 8009640:	70da      	strb	r2, [r3, #3]
//		return false;
//	};
//	if(HAL_OK != HAL_SPI_Transmit(SPI_HAN, address, 3, 10)){
//		return false;
//	};
	if(HAL_OK != HAL_SPI_Transmit(SPI_HAN, header, 4, 10)){
 8009642:	230a      	movs	r3, #10
 8009644:	2204      	movs	r2, #4
 8009646:	4913      	ldr	r1, [pc, #76]	; (8009694 <extMemGetData+0x88>)
 8009648:	4813      	ldr	r0, [pc, #76]	; (8009698 <extMemGetData+0x8c>)
 800964a:	f00a fe5e 	bl	801430a <HAL_SPI_Transmit>
 800964e:	4603      	mov	r3, r0
 8009650:	2b00      	cmp	r3, #0
 8009652:	bf14      	ite	ne
 8009654:	2301      	movne	r3, #1
 8009656:	2300      	moveq	r3, #0
 8009658:	b2db      	uxtb	r3, r3
 800965a:	2b00      	cmp	r3, #0
 800965c:	d001      	beq.n	8009662 <extMemGetData+0x56>
		return false;
 800965e:	2300      	movs	r3, #0
 8009660:	e013      	b.n	800968a <extMemGetData+0x7e>
	};
	if(HAL_OK != HAL_SPI_Receive(SPI_HAN, data, size, 100)){
 8009662:	88fa      	ldrh	r2, [r7, #6]
 8009664:	2364      	movs	r3, #100	; 0x64
 8009666:	68b9      	ldr	r1, [r7, #8]
 8009668:	480b      	ldr	r0, [pc, #44]	; (8009698 <extMemGetData+0x8c>)
 800966a:	f00a ffbc 	bl	80145e6 <HAL_SPI_Receive>
 800966e:	4603      	mov	r3, r0
 8009670:	2b00      	cmp	r3, #0
 8009672:	bf14      	ite	ne
 8009674:	2301      	movne	r3, #1
 8009676:	2300      	moveq	r3, #0
 8009678:	b2db      	uxtb	r3, r3
 800967a:	2b00      	cmp	r3, #0
 800967c:	d001      	beq.n	8009682 <extMemGetData+0x76>
		return false;
 800967e:	2300      	movs	r3, #0
 8009680:	e003      	b.n	800968a <extMemGetData+0x7e>
	};
	extMemChipSelectPin(false);
 8009682:	2000      	movs	r0, #0
 8009684:	f000 f854 	bl	8009730 <extMemChipSelectPin>

	return true;
 8009688:	2301      	movs	r3, #1
}
 800968a:	4618      	mov	r0, r3
 800968c:	3710      	adds	r7, #16
 800968e:	46bd      	mov	sp, r7
 8009690:	bd80      	pop	{r7, pc}
 8009692:	bf00      	nop
 8009694:	200011a0 	.word	0x200011a0
 8009698:	200121f0 	.word	0x200121f0

0800969c <extMemWriteData>:

bool extMemWriteData(uint32_t addr, uint8_t* data, uint16_t size){
 800969c:	b580      	push	{r7, lr}
 800969e:	b084      	sub	sp, #16
 80096a0:	af00      	add	r7, sp, #0
 80096a2:	60f8      	str	r0, [r7, #12]
 80096a4:	60b9      	str	r1, [r7, #8]
 80096a6:	4613      	mov	r3, r2
 80096a8:	80fb      	strh	r3, [r7, #6]
	HAL_StatusTypeDef state;

	extMemWriteEnableLatch(true);
 80096aa:	2001      	movs	r0, #1
 80096ac:	f7ff ff7e 	bl	80095ac <_Z22extMemWriteEnableLatchb>

	extMemChipSelectPin(true);
 80096b0:	2001      	movs	r0, #1
 80096b2:	f000 f83d 	bl	8009730 <extMemChipSelectPin>
//	uint8_t address[3];
//	address[0] = (addr >> 16) & 0xFF;
//	address[1] = (addr >> 8) & 0xFF;
//	address[2] = (addr) & 0xFF;

	header[0] = WRITE;
 80096b6:	4b1c      	ldr	r3, [pc, #112]	; (8009728 <extMemWriteData+0x8c>)
 80096b8:	2202      	movs	r2, #2
 80096ba:	701a      	strb	r2, [r3, #0]
	header[1] = (addr >> 16) & 0xFF;
 80096bc:	68fb      	ldr	r3, [r7, #12]
 80096be:	0c1b      	lsrs	r3, r3, #16
 80096c0:	b2da      	uxtb	r2, r3
 80096c2:	4b19      	ldr	r3, [pc, #100]	; (8009728 <extMemWriteData+0x8c>)
 80096c4:	705a      	strb	r2, [r3, #1]
	header[2] = (addr >> 8) & 0xFF;
 80096c6:	68fb      	ldr	r3, [r7, #12]
 80096c8:	0a1b      	lsrs	r3, r3, #8
 80096ca:	b2da      	uxtb	r2, r3
 80096cc:	4b16      	ldr	r3, [pc, #88]	; (8009728 <extMemWriteData+0x8c>)
 80096ce:	709a      	strb	r2, [r3, #2]
	header[3] = (addr) & 0xFF;
 80096d0:	68fb      	ldr	r3, [r7, #12]
 80096d2:	b2da      	uxtb	r2, r3
 80096d4:	4b14      	ldr	r3, [pc, #80]	; (8009728 <extMemWriteData+0x8c>)
 80096d6:	70da      	strb	r2, [r3, #3]
//		return false;
//	};
//	if(HAL_OK != HAL_SPI_Transmit(SPI_HAN, address, 3, 10)){
//		return false;
//	};
	if(HAL_OK != HAL_SPI_Transmit(SPI_HAN, header, 4, 10)){
 80096d8:	230a      	movs	r3, #10
 80096da:	2204      	movs	r2, #4
 80096dc:	4912      	ldr	r1, [pc, #72]	; (8009728 <extMemWriteData+0x8c>)
 80096de:	4813      	ldr	r0, [pc, #76]	; (800972c <extMemWriteData+0x90>)
 80096e0:	f00a fe13 	bl	801430a <HAL_SPI_Transmit>
 80096e4:	4603      	mov	r3, r0
 80096e6:	2b00      	cmp	r3, #0
 80096e8:	bf14      	ite	ne
 80096ea:	2301      	movne	r3, #1
 80096ec:	2300      	moveq	r3, #0
 80096ee:	b2db      	uxtb	r3, r3
 80096f0:	2b00      	cmp	r3, #0
 80096f2:	d001      	beq.n	80096f8 <extMemWriteData+0x5c>
		return false;
 80096f4:	2300      	movs	r3, #0
 80096f6:	e013      	b.n	8009720 <extMemWriteData+0x84>
	};
	if(HAL_OK != HAL_SPI_Transmit(SPI_HAN, data, size, 100)){
 80096f8:	88fa      	ldrh	r2, [r7, #6]
 80096fa:	2364      	movs	r3, #100	; 0x64
 80096fc:	68b9      	ldr	r1, [r7, #8]
 80096fe:	480b      	ldr	r0, [pc, #44]	; (800972c <extMemWriteData+0x90>)
 8009700:	f00a fe03 	bl	801430a <HAL_SPI_Transmit>
 8009704:	4603      	mov	r3, r0
 8009706:	2b00      	cmp	r3, #0
 8009708:	bf14      	ite	ne
 800970a:	2301      	movne	r3, #1
 800970c:	2300      	moveq	r3, #0
 800970e:	b2db      	uxtb	r3, r3
 8009710:	2b00      	cmp	r3, #0
 8009712:	d001      	beq.n	8009718 <extMemWriteData+0x7c>
		return false;
 8009714:	2300      	movs	r3, #0
 8009716:	e003      	b.n	8009720 <extMemWriteData+0x84>
	};
	extMemChipSelectPin(false);
 8009718:	2000      	movs	r0, #0
 800971a:	f000 f809 	bl	8009730 <extMemChipSelectPin>

	return true;
 800971e:	2301      	movs	r3, #1
}
 8009720:	4618      	mov	r0, r3
 8009722:	3710      	adds	r7, #16
 8009724:	46bd      	mov	sp, r7
 8009726:	bd80      	pop	{r7, pc}
 8009728:	200011a0 	.word	0x200011a0
 800972c:	200121f0 	.word	0x200121f0

08009730 <extMemChipSelectPin>:

bool extMemChipSelectPin(bool state){
 8009730:	b580      	push	{r7, lr}
 8009732:	b082      	sub	sp, #8
 8009734:	af00      	add	r7, sp, #0
 8009736:	4603      	mov	r3, r0
 8009738:	71fb      	strb	r3, [r7, #7]
	if(state){
 800973a:	79fb      	ldrb	r3, [r7, #7]
 800973c:	2b00      	cmp	r3, #0
 800973e:	d007      	beq.n	8009750 <extMemChipSelectPin+0x20>
		HAL_GPIO_WritePin(MEM_CS_GPIO_Port, MEM_CS_Pin, GPIO_PIN_RESET);
 8009740:	2200      	movs	r2, #0
 8009742:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009746:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800974a:	f004 fcf5 	bl	800e138 <HAL_GPIO_WritePin>
 800974e:	e006      	b.n	800975e <extMemChipSelectPin+0x2e>
	}else{
		HAL_GPIO_WritePin(MEM_CS_GPIO_Port, MEM_CS_Pin, GPIO_PIN_SET);
 8009750:	2201      	movs	r2, #1
 8009752:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009756:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800975a:	f004 fced 	bl	800e138 <HAL_GPIO_WritePin>
	}
}
 800975e:	bf00      	nop
 8009760:	4618      	mov	r0, r3
 8009762:	3708      	adds	r7, #8
 8009764:	46bd      	mov	sp, r7
 8009766:	bd80      	pop	{r7, pc}

08009768 <LL_AHB2_GRP1_EnableClock>:
{
 8009768:	b480      	push	{r7}
 800976a:	b085      	sub	sp, #20
 800976c:	af00      	add	r7, sp, #0
 800976e:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8009770:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009774:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009776:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800977a:	687b      	ldr	r3, [r7, #4]
 800977c:	4313      	orrs	r3, r2
 800977e:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8009780:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8009784:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009786:	687b      	ldr	r3, [r7, #4]
 8009788:	4013      	ands	r3, r2
 800978a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800978c:	68fb      	ldr	r3, [r7, #12]
}
 800978e:	bf00      	nop
 8009790:	3714      	adds	r7, #20
 8009792:	46bd      	mov	sp, r7
 8009794:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009798:	4770      	bx	lr
	...

0800979c <MX_GPIO_Init>:

/** Configure pins
     PA1   ------> SharedAnalog_PA1
*/
void MX_GPIO_Init(void)
{
 800979c:	b580      	push	{r7, lr}
 800979e:	b086      	sub	sp, #24
 80097a0:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80097a2:	1d3b      	adds	r3, r7, #4
 80097a4:	2200      	movs	r2, #0
 80097a6:	601a      	str	r2, [r3, #0]
 80097a8:	605a      	str	r2, [r3, #4]
 80097aa:	609a      	str	r2, [r3, #8]
 80097ac:	60da      	str	r2, [r3, #12]
 80097ae:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80097b0:	2001      	movs	r0, #1
 80097b2:	f7ff ffd9 	bl	8009768 <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80097b6:	2004      	movs	r0, #4
 80097b8:	f7ff ffd6 	bl	8009768 <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80097bc:	2002      	movs	r0, #2
 80097be:	f7ff ffd3 	bl	8009768 <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80097c2:	2008      	movs	r0, #8
 80097c4:	f7ff ffd0 	bl	8009768 <LL_AHB2_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MEM_WP_GPIO_Port, MEM_WP_Pin, GPIO_PIN_RESET);
 80097c8:	2200      	movs	r2, #0
 80097ca:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80097ce:	483b      	ldr	r0, [pc, #236]	; (80098bc <MX_GPIO_Init+0x120>)
 80097d0:	f004 fcb2 	bl	800e138 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(MEM_CS_GPIO_Port, MEM_CS_Pin, GPIO_PIN_RESET);
 80097d4:	2200      	movs	r2, #0
 80097d6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80097da:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80097de:	f004 fcab 	bl	800e138 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(IMU_CS_GPIO_Port, IMU_CS_Pin, GPIO_PIN_SET);
 80097e2:	2201      	movs	r2, #1
 80097e4:	2101      	movs	r1, #1
 80097e6:	4836      	ldr	r0, [pc, #216]	; (80098c0 <MX_GPIO_Init+0x124>)
 80097e8:	f004 fca6 	bl	800e138 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = BLINK_SIG_Pin;
 80097ec:	2302      	movs	r3, #2
 80097ee:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80097f0:	2303      	movs	r3, #3
 80097f2:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80097f4:	2300      	movs	r3, #0
 80097f6:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(BLINK_SIG_GPIO_Port, &GPIO_InitStruct);
 80097f8:	1d3b      	adds	r3, r7, #4
 80097fa:	4619      	mov	r1, r3
 80097fc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009800:	f004 fb2a 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = MEM_WP_Pin;
 8009804:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009808:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800980a:	2301      	movs	r3, #1
 800980c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800980e:	2300      	movs	r3, #0
 8009810:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009812:	2300      	movs	r3, #0
 8009814:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(MEM_WP_GPIO_Port, &GPIO_InitStruct);
 8009816:	1d3b      	adds	r3, r7, #4
 8009818:	4619      	mov	r1, r3
 800981a:	4828      	ldr	r0, [pc, #160]	; (80098bc <MX_GPIO_Init+0x120>)
 800981c:	f004 fb1c 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = MEM_CS_Pin;
 8009820:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8009824:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009826:	2301      	movs	r3, #1
 8009828:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800982a:	2300      	movs	r3, #0
 800982c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800982e:	2300      	movs	r3, #0
 8009830:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(MEM_CS_GPIO_Port, &GPIO_InitStruct);
 8009832:	1d3b      	adds	r3, r7, #4
 8009834:	4619      	mov	r1, r3
 8009836:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800983a:	f004 fb0d 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_CS_Pin;
 800983e:	2301      	movs	r3, #1
 8009840:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 8009842:	2311      	movs	r3, #17
 8009844:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009846:	2300      	movs	r3, #0
 8009848:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800984a:	2300      	movs	r3, #0
 800984c:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(IMU_CS_GPIO_Port, &GPIO_InitStruct);
 800984e:	1d3b      	adds	r3, r7, #4
 8009850:	4619      	mov	r1, r3
 8009852:	481b      	ldr	r0, [pc, #108]	; (80098c0 <MX_GPIO_Init+0x124>)
 8009854:	f004 fb00 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = IMU_INT_Pin;
 8009858:	2304      	movs	r3, #4
 800985a:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800985c:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 8009860:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009862:	2300      	movs	r3, #0
 8009864:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(IMU_INT_GPIO_Port, &GPIO_InitStruct);
 8009866:	1d3b      	adds	r3, r7, #4
 8009868:	4619      	mov	r1, r3
 800986a:	4816      	ldr	r0, [pc, #88]	; (80098c4 <MX_GPIO_Init+0x128>)
 800986c:	f004 faf4 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PA9_Pin;
 8009870:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009874:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009876:	2300      	movs	r3, #0
 8009878:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800987a:	2300      	movs	r3, #0
 800987c:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(PA9_GPIO_Port, &GPIO_InitStruct);
 800987e:	1d3b      	adds	r3, r7, #4
 8009880:	4619      	mov	r1, r3
 8009882:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009886:	f004 fae7 	bl	800de58 <HAL_GPIO_Init>

  /*Configure GPIO pins : PDPin PDPin */
  GPIO_InitStruct.Pin = PD4_Pin|PD9_Pin;
 800988a:	f44f 7304 	mov.w	r3, #528	; 0x210
 800988e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009890:	2300      	movs	r3, #0
 8009892:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009894:	2300      	movs	r3, #0
 8009896:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8009898:	1d3b      	adds	r3, r7, #4
 800989a:	4619      	mov	r1, r3
 800989c:	4808      	ldr	r0, [pc, #32]	; (80098c0 <MX_GPIO_Init+0x124>)
 800989e:	f004 fadb 	bl	800de58 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI2_IRQn, 5, 0);
 80098a2:	2200      	movs	r2, #0
 80098a4:	2105      	movs	r1, #5
 80098a6:	2008      	movs	r0, #8
 80098a8:	f004 f8c8 	bl	800da3c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI2_IRQn);
 80098ac:	2008      	movs	r0, #8
 80098ae:	f004 f8df 	bl	800da70 <HAL_NVIC_EnableIRQ>

}
 80098b2:	bf00      	nop
 80098b4:	3718      	adds	r7, #24
 80098b6:	46bd      	mov	sp, r7
 80098b8:	bd80      	pop	{r7, pc}
 80098ba:	bf00      	nop
 80098bc:	48000800 	.word	0x48000800
 80098c0:	48000c00 	.word	0x48000c00
 80098c4:	48000400 	.word	0x48000400

080098c8 <LL_EXTI_EnableIT_0_31>:
{
 80098c8:	b480      	push	{r7}
 80098ca:	b083      	sub	sp, #12
 80098cc:	af00      	add	r7, sp, #0
 80098ce:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
 80098d0:	4b06      	ldr	r3, [pc, #24]	; (80098ec <LL_EXTI_EnableIT_0_31+0x24>)
 80098d2:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80098d6:	4905      	ldr	r1, [pc, #20]	; (80098ec <LL_EXTI_EnableIT_0_31+0x24>)
 80098d8:	687b      	ldr	r3, [r7, #4]
 80098da:	4313      	orrs	r3, r2
 80098dc:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 80098e0:	bf00      	nop
 80098e2:	370c      	adds	r7, #12
 80098e4:	46bd      	mov	sp, r7
 80098e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80098ea:	4770      	bx	lr
 80098ec:	58000800 	.word	0x58000800

080098f0 <LL_EXTI_EnableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
{
 80098f0:	b480      	push	{r7}
 80098f2:	b083      	sub	sp, #12
 80098f4:	af00      	add	r7, sp, #0
 80098f6:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR1, ExtiLine);
 80098f8:	4b05      	ldr	r3, [pc, #20]	; (8009910 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 80098fa:	681a      	ldr	r2, [r3, #0]
 80098fc:	4904      	ldr	r1, [pc, #16]	; (8009910 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	4313      	orrs	r3, r2
 8009902:	600b      	str	r3, [r1, #0]

}
 8009904:	bf00      	nop
 8009906:	370c      	adds	r7, #12
 8009908:	46bd      	mov	sp, r7
 800990a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800990e:	4770      	bx	lr
 8009910:	58000800 	.word	0x58000800

08009914 <ReadRtcSsrValue>:
 *         reliability of the value
 * @param  None
 * @retval SSR value read
 */
static uint32_t ReadRtcSsrValue(void)
{
 8009914:	b480      	push	{r7}
 8009916:	b083      	sub	sp, #12
 8009918:	af00      	add	r7, sp, #0
  uint32_t first_read;
  uint32_t second_read;

  first_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 800991a:	4b0d      	ldr	r3, [pc, #52]	; (8009950 <ReadRtcSsrValue+0x3c>)
 800991c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800991e:	b29b      	uxth	r3, r3
 8009920:	607b      	str	r3, [r7, #4]

  second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 8009922:	4b0b      	ldr	r3, [pc, #44]	; (8009950 <ReadRtcSsrValue+0x3c>)
 8009924:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009926:	b29b      	uxth	r3, r3
 8009928:	603b      	str	r3, [r7, #0]

  while(first_read != second_read)
 800992a:	e005      	b.n	8009938 <ReadRtcSsrValue+0x24>
  {
    first_read = second_read;
 800992c:	683b      	ldr	r3, [r7, #0]
 800992e:	607b      	str	r3, [r7, #4]

    second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 8009930:	4b07      	ldr	r3, [pc, #28]	; (8009950 <ReadRtcSsrValue+0x3c>)
 8009932:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009934:	b29b      	uxth	r3, r3
 8009936:	603b      	str	r3, [r7, #0]
  while(first_read != second_read)
 8009938:	687a      	ldr	r2, [r7, #4]
 800993a:	683b      	ldr	r3, [r7, #0]
 800993c:	429a      	cmp	r2, r3
 800993e:	d1f5      	bne.n	800992c <ReadRtcSsrValue+0x18>
  }

  return second_read;
 8009940:	683b      	ldr	r3, [r7, #0]
}
 8009942:	4618      	mov	r0, r3
 8009944:	370c      	adds	r7, #12
 8009946:	46bd      	mov	sp, r7
 8009948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800994c:	4770      	bx	lr
 800994e:	bf00      	nop
 8009950:	40002800 	.word	0x40002800

08009954 <LinkTimerAfter>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked after
 * @retval None
 */
static void LinkTimerAfter(uint8_t TimerID, uint8_t RefTimerID)
{
 8009954:	b480      	push	{r7}
 8009956:	b085      	sub	sp, #20
 8009958:	af00      	add	r7, sp, #0
 800995a:	4603      	mov	r3, r0
 800995c:	460a      	mov	r2, r1
 800995e:	71fb      	strb	r3, [r7, #7]
 8009960:	4613      	mov	r3, r2
 8009962:	71bb      	strb	r3, [r7, #6]
  uint8_t next_id;

  next_id = aTimerContext[RefTimerID].NextID;
 8009964:	79ba      	ldrb	r2, [r7, #6]
 8009966:	491d      	ldr	r1, [pc, #116]	; (80099dc <LinkTimerAfter+0x88>)
 8009968:	4613      	mov	r3, r2
 800996a:	005b      	lsls	r3, r3, #1
 800996c:	4413      	add	r3, r2
 800996e:	00db      	lsls	r3, r3, #3
 8009970:	440b      	add	r3, r1
 8009972:	3315      	adds	r3, #21
 8009974:	781b      	ldrb	r3, [r3, #0]
 8009976:	73fb      	strb	r3, [r7, #15]

  if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8009978:	7bfb      	ldrb	r3, [r7, #15]
 800997a:	2b06      	cmp	r3, #6
 800997c:	d009      	beq.n	8009992 <LinkTimerAfter+0x3e>
  {
    aTimerContext[next_id].PreviousID = TimerID;
 800997e:	7bfa      	ldrb	r2, [r7, #15]
 8009980:	4916      	ldr	r1, [pc, #88]	; (80099dc <LinkTimerAfter+0x88>)
 8009982:	4613      	mov	r3, r2
 8009984:	005b      	lsls	r3, r3, #1
 8009986:	4413      	add	r3, r2
 8009988:	00db      	lsls	r3, r3, #3
 800998a:	440b      	add	r3, r1
 800998c:	3314      	adds	r3, #20
 800998e:	79fa      	ldrb	r2, [r7, #7]
 8009990:	701a      	strb	r2, [r3, #0]
  }
  aTimerContext[TimerID].NextID = next_id;
 8009992:	79fa      	ldrb	r2, [r7, #7]
 8009994:	4911      	ldr	r1, [pc, #68]	; (80099dc <LinkTimerAfter+0x88>)
 8009996:	4613      	mov	r3, r2
 8009998:	005b      	lsls	r3, r3, #1
 800999a:	4413      	add	r3, r2
 800999c:	00db      	lsls	r3, r3, #3
 800999e:	440b      	add	r3, r1
 80099a0:	3315      	adds	r3, #21
 80099a2:	7bfa      	ldrb	r2, [r7, #15]
 80099a4:	701a      	strb	r2, [r3, #0]
  aTimerContext[TimerID].PreviousID = RefTimerID ;
 80099a6:	79fa      	ldrb	r2, [r7, #7]
 80099a8:	490c      	ldr	r1, [pc, #48]	; (80099dc <LinkTimerAfter+0x88>)
 80099aa:	4613      	mov	r3, r2
 80099ac:	005b      	lsls	r3, r3, #1
 80099ae:	4413      	add	r3, r2
 80099b0:	00db      	lsls	r3, r3, #3
 80099b2:	440b      	add	r3, r1
 80099b4:	3314      	adds	r3, #20
 80099b6:	79ba      	ldrb	r2, [r7, #6]
 80099b8:	701a      	strb	r2, [r3, #0]
  aTimerContext[RefTimerID].NextID = TimerID;
 80099ba:	79ba      	ldrb	r2, [r7, #6]
 80099bc:	4907      	ldr	r1, [pc, #28]	; (80099dc <LinkTimerAfter+0x88>)
 80099be:	4613      	mov	r3, r2
 80099c0:	005b      	lsls	r3, r3, #1
 80099c2:	4413      	add	r3, r2
 80099c4:	00db      	lsls	r3, r3, #3
 80099c6:	440b      	add	r3, r1
 80099c8:	3315      	adds	r3, #21
 80099ca:	79fa      	ldrb	r2, [r7, #7]
 80099cc:	701a      	strb	r2, [r3, #0]

  return;
 80099ce:	bf00      	nop
}
 80099d0:	3714      	adds	r7, #20
 80099d2:	46bd      	mov	sp, r7
 80099d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099d8:	4770      	bx	lr
 80099da:	bf00      	nop
 80099dc:	20000218 	.word	0x20000218

080099e0 <LinkTimerBefore>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked before
 * @retval None
 */
static void LinkTimerBefore(uint8_t TimerID, uint8_t RefTimerID)
{
 80099e0:	b480      	push	{r7}
 80099e2:	b085      	sub	sp, #20
 80099e4:	af00      	add	r7, sp, #0
 80099e6:	4603      	mov	r3, r0
 80099e8:	460a      	mov	r2, r1
 80099ea:	71fb      	strb	r3, [r7, #7]
 80099ec:	4613      	mov	r3, r2
 80099ee:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;

  if(RefTimerID != CurrentRunningTimerID)
 80099f0:	4b29      	ldr	r3, [pc, #164]	; (8009a98 <LinkTimerBefore+0xb8>)
 80099f2:	781b      	ldrb	r3, [r3, #0]
 80099f4:	b2db      	uxtb	r3, r3
 80099f6:	79ba      	ldrb	r2, [r7, #6]
 80099f8:	429a      	cmp	r2, r3
 80099fa:	d032      	beq.n	8009a62 <LinkTimerBefore+0x82>
  {
    previous_id = aTimerContext[RefTimerID].PreviousID;
 80099fc:	79ba      	ldrb	r2, [r7, #6]
 80099fe:	4927      	ldr	r1, [pc, #156]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a00:	4613      	mov	r3, r2
 8009a02:	005b      	lsls	r3, r3, #1
 8009a04:	4413      	add	r3, r2
 8009a06:	00db      	lsls	r3, r3, #3
 8009a08:	440b      	add	r3, r1
 8009a0a:	3314      	adds	r3, #20
 8009a0c:	781b      	ldrb	r3, [r3, #0]
 8009a0e:	73fb      	strb	r3, [r7, #15]

    aTimerContext[previous_id].NextID = TimerID;
 8009a10:	7bfa      	ldrb	r2, [r7, #15]
 8009a12:	4922      	ldr	r1, [pc, #136]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a14:	4613      	mov	r3, r2
 8009a16:	005b      	lsls	r3, r3, #1
 8009a18:	4413      	add	r3, r2
 8009a1a:	00db      	lsls	r3, r3, #3
 8009a1c:	440b      	add	r3, r1
 8009a1e:	3315      	adds	r3, #21
 8009a20:	79fa      	ldrb	r2, [r7, #7]
 8009a22:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].NextID = RefTimerID;
 8009a24:	79fa      	ldrb	r2, [r7, #7]
 8009a26:	491d      	ldr	r1, [pc, #116]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a28:	4613      	mov	r3, r2
 8009a2a:	005b      	lsls	r3, r3, #1
 8009a2c:	4413      	add	r3, r2
 8009a2e:	00db      	lsls	r3, r3, #3
 8009a30:	440b      	add	r3, r1
 8009a32:	3315      	adds	r3, #21
 8009a34:	79ba      	ldrb	r2, [r7, #6]
 8009a36:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].PreviousID = previous_id ;
 8009a38:	79fa      	ldrb	r2, [r7, #7]
 8009a3a:	4918      	ldr	r1, [pc, #96]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a3c:	4613      	mov	r3, r2
 8009a3e:	005b      	lsls	r3, r3, #1
 8009a40:	4413      	add	r3, r2
 8009a42:	00db      	lsls	r3, r3, #3
 8009a44:	440b      	add	r3, r1
 8009a46:	3314      	adds	r3, #20
 8009a48:	7bfa      	ldrb	r2, [r7, #15]
 8009a4a:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 8009a4c:	79ba      	ldrb	r2, [r7, #6]
 8009a4e:	4913      	ldr	r1, [pc, #76]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a50:	4613      	mov	r3, r2
 8009a52:	005b      	lsls	r3, r3, #1
 8009a54:	4413      	add	r3, r2
 8009a56:	00db      	lsls	r3, r3, #3
 8009a58:	440b      	add	r3, r1
 8009a5a:	3314      	adds	r3, #20
 8009a5c:	79fa      	ldrb	r2, [r7, #7]
 8009a5e:	701a      	strb	r2, [r3, #0]
  {
    aTimerContext[TimerID].NextID = RefTimerID;
    aTimerContext[RefTimerID].PreviousID = TimerID;
  }

  return;
 8009a60:	e014      	b.n	8009a8c <LinkTimerBefore+0xac>
    aTimerContext[TimerID].NextID = RefTimerID;
 8009a62:	79fa      	ldrb	r2, [r7, #7]
 8009a64:	490d      	ldr	r1, [pc, #52]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a66:	4613      	mov	r3, r2
 8009a68:	005b      	lsls	r3, r3, #1
 8009a6a:	4413      	add	r3, r2
 8009a6c:	00db      	lsls	r3, r3, #3
 8009a6e:	440b      	add	r3, r1
 8009a70:	3315      	adds	r3, #21
 8009a72:	79ba      	ldrb	r2, [r7, #6]
 8009a74:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 8009a76:	79ba      	ldrb	r2, [r7, #6]
 8009a78:	4908      	ldr	r1, [pc, #32]	; (8009a9c <LinkTimerBefore+0xbc>)
 8009a7a:	4613      	mov	r3, r2
 8009a7c:	005b      	lsls	r3, r3, #1
 8009a7e:	4413      	add	r3, r2
 8009a80:	00db      	lsls	r3, r3, #3
 8009a82:	440b      	add	r3, r1
 8009a84:	3314      	adds	r3, #20
 8009a86:	79fa      	ldrb	r2, [r7, #7]
 8009a88:	701a      	strb	r2, [r3, #0]
  return;
 8009a8a:	bf00      	nop
}
 8009a8c:	3714      	adds	r7, #20
 8009a8e:	46bd      	mov	sp, r7
 8009a90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a94:	4770      	bx	lr
 8009a96:	bf00      	nop
 8009a98:	200002a8 	.word	0x200002a8
 8009a9c:	20000218 	.word	0x20000218

08009aa0 <linkTimer>:
 * @brief  Insert a Timer in the list
 * @param  TimerID:   The ID of the Timer
 * @retval None
 */
static uint16_t linkTimer(uint8_t TimerID)
{
 8009aa0:	b580      	push	{r7, lr}
 8009aa2:	b084      	sub	sp, #16
 8009aa4:	af00      	add	r7, sp, #0
 8009aa6:	4603      	mov	r3, r0
 8009aa8:	71fb      	strb	r3, [r7, #7]
  uint32_t time_left;
  uint16_t time_elapsed;
  uint8_t timer_id_lookup;
  uint8_t next_id;

  if(CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8009aaa:	4b4e      	ldr	r3, [pc, #312]	; (8009be4 <linkTimer+0x144>)
 8009aac:	781b      	ldrb	r3, [r3, #0]
 8009aae:	b2db      	uxtb	r3, r3
 8009ab0:	2b06      	cmp	r3, #6
 8009ab2:	d118      	bne.n	8009ae6 <linkTimer+0x46>
  {
    /**
     * No timer in the list
     */
    PreviousRunningTimerID = CurrentRunningTimerID;
 8009ab4:	4b4b      	ldr	r3, [pc, #300]	; (8009be4 <linkTimer+0x144>)
 8009ab6:	781b      	ldrb	r3, [r3, #0]
 8009ab8:	b2da      	uxtb	r2, r3
 8009aba:	4b4b      	ldr	r3, [pc, #300]	; (8009be8 <linkTimer+0x148>)
 8009abc:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = TimerID;
 8009abe:	4a49      	ldr	r2, [pc, #292]	; (8009be4 <linkTimer+0x144>)
 8009ac0:	79fb      	ldrb	r3, [r7, #7]
 8009ac2:	7013      	strb	r3, [r2, #0]
    aTimerContext[TimerID].NextID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;
 8009ac4:	79fa      	ldrb	r2, [r7, #7]
 8009ac6:	4949      	ldr	r1, [pc, #292]	; (8009bec <linkTimer+0x14c>)
 8009ac8:	4613      	mov	r3, r2
 8009aca:	005b      	lsls	r3, r3, #1
 8009acc:	4413      	add	r3, r2
 8009ace:	00db      	lsls	r3, r3, #3
 8009ad0:	440b      	add	r3, r1
 8009ad2:	3315      	adds	r3, #21
 8009ad4:	2206      	movs	r2, #6
 8009ad6:	701a      	strb	r2, [r3, #0]

    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 8009ad8:	4b45      	ldr	r3, [pc, #276]	; (8009bf0 <linkTimer+0x150>)
 8009ada:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009ade:	601a      	str	r2, [r3, #0]
    time_elapsed = 0;
 8009ae0:	2300      	movs	r3, #0
 8009ae2:	81fb      	strh	r3, [r7, #14]
 8009ae4:	e078      	b.n	8009bd8 <linkTimer+0x138>
  }
  else
  {
    time_elapsed = ReturnTimeElapsed();
 8009ae6:	f000 f909 	bl	8009cfc <ReturnTimeElapsed>
 8009aea:	4603      	mov	r3, r0
 8009aec:	81fb      	strh	r3, [r7, #14]

    /**
     * update count of the timer to be linked
     */
    aTimerContext[TimerID].CountLeft += time_elapsed;
 8009aee:	79fa      	ldrb	r2, [r7, #7]
 8009af0:	493e      	ldr	r1, [pc, #248]	; (8009bec <linkTimer+0x14c>)
 8009af2:	4613      	mov	r3, r2
 8009af4:	005b      	lsls	r3, r3, #1
 8009af6:	4413      	add	r3, r2
 8009af8:	00db      	lsls	r3, r3, #3
 8009afa:	440b      	add	r3, r1
 8009afc:	3308      	adds	r3, #8
 8009afe:	6819      	ldr	r1, [r3, #0]
 8009b00:	89fb      	ldrh	r3, [r7, #14]
 8009b02:	79fa      	ldrb	r2, [r7, #7]
 8009b04:	4419      	add	r1, r3
 8009b06:	4839      	ldr	r0, [pc, #228]	; (8009bec <linkTimer+0x14c>)
 8009b08:	4613      	mov	r3, r2
 8009b0a:	005b      	lsls	r3, r3, #1
 8009b0c:	4413      	add	r3, r2
 8009b0e:	00db      	lsls	r3, r3, #3
 8009b10:	4403      	add	r3, r0
 8009b12:	3308      	adds	r3, #8
 8009b14:	6019      	str	r1, [r3, #0]
    time_left = aTimerContext[TimerID].CountLeft;
 8009b16:	79fa      	ldrb	r2, [r7, #7]
 8009b18:	4934      	ldr	r1, [pc, #208]	; (8009bec <linkTimer+0x14c>)
 8009b1a:	4613      	mov	r3, r2
 8009b1c:	005b      	lsls	r3, r3, #1
 8009b1e:	4413      	add	r3, r2
 8009b20:	00db      	lsls	r3, r3, #3
 8009b22:	440b      	add	r3, r1
 8009b24:	3308      	adds	r3, #8
 8009b26:	681b      	ldr	r3, [r3, #0]
 8009b28:	60bb      	str	r3, [r7, #8]

    /**
     * Search for index where the new timer shall be linked
     */
    if(aTimerContext[CurrentRunningTimerID].CountLeft <= time_left)
 8009b2a:	4b2e      	ldr	r3, [pc, #184]	; (8009be4 <linkTimer+0x144>)
 8009b2c:	781b      	ldrb	r3, [r3, #0]
 8009b2e:	b2db      	uxtb	r3, r3
 8009b30:	4619      	mov	r1, r3
 8009b32:	4a2e      	ldr	r2, [pc, #184]	; (8009bec <linkTimer+0x14c>)
 8009b34:	460b      	mov	r3, r1
 8009b36:	005b      	lsls	r3, r3, #1
 8009b38:	440b      	add	r3, r1
 8009b3a:	00db      	lsls	r3, r3, #3
 8009b3c:	4413      	add	r3, r2
 8009b3e:	3308      	adds	r3, #8
 8009b40:	681b      	ldr	r3, [r3, #0]
 8009b42:	68ba      	ldr	r2, [r7, #8]
 8009b44:	429a      	cmp	r2, r3
 8009b46:	d337      	bcc.n	8009bb8 <linkTimer+0x118>
    {
      /**
       * Search for the ID after the first one
       */
      timer_id_lookup = CurrentRunningTimerID;
 8009b48:	4b26      	ldr	r3, [pc, #152]	; (8009be4 <linkTimer+0x144>)
 8009b4a:	781b      	ldrb	r3, [r3, #0]
 8009b4c:	737b      	strb	r3, [r7, #13]
      next_id = aTimerContext[timer_id_lookup].NextID;
 8009b4e:	7b7a      	ldrb	r2, [r7, #13]
 8009b50:	4926      	ldr	r1, [pc, #152]	; (8009bec <linkTimer+0x14c>)
 8009b52:	4613      	mov	r3, r2
 8009b54:	005b      	lsls	r3, r3, #1
 8009b56:	4413      	add	r3, r2
 8009b58:	00db      	lsls	r3, r3, #3
 8009b5a:	440b      	add	r3, r1
 8009b5c:	3315      	adds	r3, #21
 8009b5e:	781b      	ldrb	r3, [r3, #0]
 8009b60:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 8009b62:	e013      	b.n	8009b8c <linkTimer+0xec>
      {
        timer_id_lookup = aTimerContext[timer_id_lookup].NextID;
 8009b64:	7b7a      	ldrb	r2, [r7, #13]
 8009b66:	4921      	ldr	r1, [pc, #132]	; (8009bec <linkTimer+0x14c>)
 8009b68:	4613      	mov	r3, r2
 8009b6a:	005b      	lsls	r3, r3, #1
 8009b6c:	4413      	add	r3, r2
 8009b6e:	00db      	lsls	r3, r3, #3
 8009b70:	440b      	add	r3, r1
 8009b72:	3315      	adds	r3, #21
 8009b74:	781b      	ldrb	r3, [r3, #0]
 8009b76:	737b      	strb	r3, [r7, #13]
        next_id = aTimerContext[timer_id_lookup].NextID;
 8009b78:	7b7a      	ldrb	r2, [r7, #13]
 8009b7a:	491c      	ldr	r1, [pc, #112]	; (8009bec <linkTimer+0x14c>)
 8009b7c:	4613      	mov	r3, r2
 8009b7e:	005b      	lsls	r3, r3, #1
 8009b80:	4413      	add	r3, r2
 8009b82:	00db      	lsls	r3, r3, #3
 8009b84:	440b      	add	r3, r1
 8009b86:	3315      	adds	r3, #21
 8009b88:	781b      	ldrb	r3, [r3, #0]
 8009b8a:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 8009b8c:	7b3b      	ldrb	r3, [r7, #12]
 8009b8e:	2b06      	cmp	r3, #6
 8009b90:	d00b      	beq.n	8009baa <linkTimer+0x10a>
 8009b92:	7b3a      	ldrb	r2, [r7, #12]
 8009b94:	4915      	ldr	r1, [pc, #84]	; (8009bec <linkTimer+0x14c>)
 8009b96:	4613      	mov	r3, r2
 8009b98:	005b      	lsls	r3, r3, #1
 8009b9a:	4413      	add	r3, r2
 8009b9c:	00db      	lsls	r3, r3, #3
 8009b9e:	440b      	add	r3, r1
 8009ba0:	3308      	adds	r3, #8
 8009ba2:	681b      	ldr	r3, [r3, #0]
 8009ba4:	68ba      	ldr	r2, [r7, #8]
 8009ba6:	429a      	cmp	r2, r3
 8009ba8:	d2dc      	bcs.n	8009b64 <linkTimer+0xc4>
      }

      /**
       * Link after the ID
       */
      LinkTimerAfter(TimerID, timer_id_lookup);
 8009baa:	7b7a      	ldrb	r2, [r7, #13]
 8009bac:	79fb      	ldrb	r3, [r7, #7]
 8009bae:	4611      	mov	r1, r2
 8009bb0:	4618      	mov	r0, r3
 8009bb2:	f7ff fecf 	bl	8009954 <LinkTimerAfter>
 8009bb6:	e00f      	b.n	8009bd8 <linkTimer+0x138>
    else
    {
      /**
       * Link before the first ID
       */
      LinkTimerBefore(TimerID, CurrentRunningTimerID);
 8009bb8:	4b0a      	ldr	r3, [pc, #40]	; (8009be4 <linkTimer+0x144>)
 8009bba:	781b      	ldrb	r3, [r3, #0]
 8009bbc:	b2da      	uxtb	r2, r3
 8009bbe:	79fb      	ldrb	r3, [r7, #7]
 8009bc0:	4611      	mov	r1, r2
 8009bc2:	4618      	mov	r0, r3
 8009bc4:	f7ff ff0c 	bl	80099e0 <LinkTimerBefore>
      PreviousRunningTimerID = CurrentRunningTimerID;
 8009bc8:	4b06      	ldr	r3, [pc, #24]	; (8009be4 <linkTimer+0x144>)
 8009bca:	781b      	ldrb	r3, [r3, #0]
 8009bcc:	b2da      	uxtb	r2, r3
 8009bce:	4b06      	ldr	r3, [pc, #24]	; (8009be8 <linkTimer+0x148>)
 8009bd0:	701a      	strb	r2, [r3, #0]
      CurrentRunningTimerID = TimerID;
 8009bd2:	4a04      	ldr	r2, [pc, #16]	; (8009be4 <linkTimer+0x144>)
 8009bd4:	79fb      	ldrb	r3, [r7, #7]
 8009bd6:	7013      	strb	r3, [r2, #0]
    }
  }

  return time_elapsed;
 8009bd8:	89fb      	ldrh	r3, [r7, #14]
}
 8009bda:	4618      	mov	r0, r3
 8009bdc:	3710      	adds	r7, #16
 8009bde:	46bd      	mov	sp, r7
 8009be0:	bd80      	pop	{r7, pc}
 8009be2:	bf00      	nop
 8009be4:	200002a8 	.word	0x200002a8
 8009be8:	200002a9 	.word	0x200002a9
 8009bec:	20000218 	.word	0x20000218
 8009bf0:	200002ac 	.word	0x200002ac

08009bf4 <UnlinkTimer>:
 * @param  TimerID:   The ID of the Timer
 * @param  RequestReadSSR: Request to read the SSR register or not
 * @retval None
 */
static void UnlinkTimer(uint8_t TimerID, RequestReadSSR_t RequestReadSSR)
{
 8009bf4:	b480      	push	{r7}
 8009bf6:	b085      	sub	sp, #20
 8009bf8:	af00      	add	r7, sp, #0
 8009bfa:	4603      	mov	r3, r0
 8009bfc:	460a      	mov	r2, r1
 8009bfe:	71fb      	strb	r3, [r7, #7]
 8009c00:	4613      	mov	r3, r2
 8009c02:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;
  uint8_t next_id;

  if(TimerID == CurrentRunningTimerID)
 8009c04:	4b39      	ldr	r3, [pc, #228]	; (8009cec <UnlinkTimer+0xf8>)
 8009c06:	781b      	ldrb	r3, [r3, #0]
 8009c08:	b2db      	uxtb	r3, r3
 8009c0a:	79fa      	ldrb	r2, [r7, #7]
 8009c0c:	429a      	cmp	r2, r3
 8009c0e:	d111      	bne.n	8009c34 <UnlinkTimer+0x40>
  {
    PreviousRunningTimerID = CurrentRunningTimerID;
 8009c10:	4b36      	ldr	r3, [pc, #216]	; (8009cec <UnlinkTimer+0xf8>)
 8009c12:	781b      	ldrb	r3, [r3, #0]
 8009c14:	b2da      	uxtb	r2, r3
 8009c16:	4b36      	ldr	r3, [pc, #216]	; (8009cf0 <UnlinkTimer+0xfc>)
 8009c18:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = aTimerContext[TimerID].NextID;
 8009c1a:	79fa      	ldrb	r2, [r7, #7]
 8009c1c:	4935      	ldr	r1, [pc, #212]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c1e:	4613      	mov	r3, r2
 8009c20:	005b      	lsls	r3, r3, #1
 8009c22:	4413      	add	r3, r2
 8009c24:	00db      	lsls	r3, r3, #3
 8009c26:	440b      	add	r3, r1
 8009c28:	3315      	adds	r3, #21
 8009c2a:	781b      	ldrb	r3, [r3, #0]
 8009c2c:	b2da      	uxtb	r2, r3
 8009c2e:	4b2f      	ldr	r3, [pc, #188]	; (8009cec <UnlinkTimer+0xf8>)
 8009c30:	701a      	strb	r2, [r3, #0]
 8009c32:	e03e      	b.n	8009cb2 <UnlinkTimer+0xbe>
  }
  else
  {
    previous_id = aTimerContext[TimerID].PreviousID;
 8009c34:	79fa      	ldrb	r2, [r7, #7]
 8009c36:	492f      	ldr	r1, [pc, #188]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c38:	4613      	mov	r3, r2
 8009c3a:	005b      	lsls	r3, r3, #1
 8009c3c:	4413      	add	r3, r2
 8009c3e:	00db      	lsls	r3, r3, #3
 8009c40:	440b      	add	r3, r1
 8009c42:	3314      	adds	r3, #20
 8009c44:	781b      	ldrb	r3, [r3, #0]
 8009c46:	73fb      	strb	r3, [r7, #15]
    next_id = aTimerContext[TimerID].NextID;
 8009c48:	79fa      	ldrb	r2, [r7, #7]
 8009c4a:	492a      	ldr	r1, [pc, #168]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c4c:	4613      	mov	r3, r2
 8009c4e:	005b      	lsls	r3, r3, #1
 8009c50:	4413      	add	r3, r2
 8009c52:	00db      	lsls	r3, r3, #3
 8009c54:	440b      	add	r3, r1
 8009c56:	3315      	adds	r3, #21
 8009c58:	781b      	ldrb	r3, [r3, #0]
 8009c5a:	73bb      	strb	r3, [r7, #14]

    aTimerContext[previous_id].NextID = aTimerContext[TimerID].NextID;
 8009c5c:	79f9      	ldrb	r1, [r7, #7]
 8009c5e:	7bfa      	ldrb	r2, [r7, #15]
 8009c60:	4824      	ldr	r0, [pc, #144]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c62:	460b      	mov	r3, r1
 8009c64:	005b      	lsls	r3, r3, #1
 8009c66:	440b      	add	r3, r1
 8009c68:	00db      	lsls	r3, r3, #3
 8009c6a:	4403      	add	r3, r0
 8009c6c:	3315      	adds	r3, #21
 8009c6e:	781b      	ldrb	r3, [r3, #0]
 8009c70:	b2d8      	uxtb	r0, r3
 8009c72:	4920      	ldr	r1, [pc, #128]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c74:	4613      	mov	r3, r2
 8009c76:	005b      	lsls	r3, r3, #1
 8009c78:	4413      	add	r3, r2
 8009c7a:	00db      	lsls	r3, r3, #3
 8009c7c:	440b      	add	r3, r1
 8009c7e:	3315      	adds	r3, #21
 8009c80:	4602      	mov	r2, r0
 8009c82:	701a      	strb	r2, [r3, #0]
    if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8009c84:	7bbb      	ldrb	r3, [r7, #14]
 8009c86:	2b06      	cmp	r3, #6
 8009c88:	d013      	beq.n	8009cb2 <UnlinkTimer+0xbe>
    {
      aTimerContext[next_id].PreviousID = aTimerContext[TimerID].PreviousID;
 8009c8a:	79f9      	ldrb	r1, [r7, #7]
 8009c8c:	7bba      	ldrb	r2, [r7, #14]
 8009c8e:	4819      	ldr	r0, [pc, #100]	; (8009cf4 <UnlinkTimer+0x100>)
 8009c90:	460b      	mov	r3, r1
 8009c92:	005b      	lsls	r3, r3, #1
 8009c94:	440b      	add	r3, r1
 8009c96:	00db      	lsls	r3, r3, #3
 8009c98:	4403      	add	r3, r0
 8009c9a:	3314      	adds	r3, #20
 8009c9c:	781b      	ldrb	r3, [r3, #0]
 8009c9e:	b2d8      	uxtb	r0, r3
 8009ca0:	4914      	ldr	r1, [pc, #80]	; (8009cf4 <UnlinkTimer+0x100>)
 8009ca2:	4613      	mov	r3, r2
 8009ca4:	005b      	lsls	r3, r3, #1
 8009ca6:	4413      	add	r3, r2
 8009ca8:	00db      	lsls	r3, r3, #3
 8009caa:	440b      	add	r3, r1
 8009cac:	3314      	adds	r3, #20
 8009cae:	4602      	mov	r2, r0
 8009cb0:	701a      	strb	r2, [r3, #0]
  }

  /**
   * Timer is out of the list
   */
  aTimerContext[TimerID].TimerIDStatus = TimerID_Created;
 8009cb2:	79fa      	ldrb	r2, [r7, #7]
 8009cb4:	490f      	ldr	r1, [pc, #60]	; (8009cf4 <UnlinkTimer+0x100>)
 8009cb6:	4613      	mov	r3, r2
 8009cb8:	005b      	lsls	r3, r3, #1
 8009cba:	4413      	add	r3, r2
 8009cbc:	00db      	lsls	r3, r3, #3
 8009cbe:	440b      	add	r3, r1
 8009cc0:	330c      	adds	r3, #12
 8009cc2:	2201      	movs	r2, #1
 8009cc4:	701a      	strb	r2, [r3, #0]

  if((CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (RequestReadSSR == SSR_Read_Requested))
 8009cc6:	4b09      	ldr	r3, [pc, #36]	; (8009cec <UnlinkTimer+0xf8>)
 8009cc8:	781b      	ldrb	r3, [r3, #0]
 8009cca:	b2db      	uxtb	r3, r3
 8009ccc:	2b06      	cmp	r3, #6
 8009cce:	d107      	bne.n	8009ce0 <UnlinkTimer+0xec>
 8009cd0:	79bb      	ldrb	r3, [r7, #6]
 8009cd2:	2b00      	cmp	r3, #0
 8009cd4:	d104      	bne.n	8009ce0 <UnlinkTimer+0xec>
  {
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 8009cd6:	4b08      	ldr	r3, [pc, #32]	; (8009cf8 <UnlinkTimer+0x104>)
 8009cd8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8009cdc:	601a      	str	r2, [r3, #0]
  }

  return;
 8009cde:	bf00      	nop
 8009ce0:	bf00      	nop
}
 8009ce2:	3714      	adds	r7, #20
 8009ce4:	46bd      	mov	sp, r7
 8009ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cea:	4770      	bx	lr
 8009cec:	200002a8 	.word	0x200002a8
 8009cf0:	200002a9 	.word	0x200002a9
 8009cf4:	20000218 	.word	0x20000218
 8009cf8:	200002ac 	.word	0x200002ac

08009cfc <ReturnTimeElapsed>:
 *        since the time the timer has been started
 * @param  None
 * @retval Time expired in Ticks
 */
static uint16_t ReturnTimeElapsed(void)
{
 8009cfc:	b580      	push	{r7, lr}
 8009cfe:	b082      	sub	sp, #8
 8009d00:	af00      	add	r7, sp, #0
  uint32_t  return_value;
  uint32_t  wrap_counter;

  if(SSRValueOnLastSetup != SSR_FORBIDDEN_VALUE)
 8009d02:	4b1a      	ldr	r3, [pc, #104]	; (8009d6c <ReturnTimeElapsed+0x70>)
 8009d04:	681b      	ldr	r3, [r3, #0]
 8009d06:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009d0a:	d026      	beq.n	8009d5a <ReturnTimeElapsed+0x5e>
  {
    return_value = ReadRtcSsrValue(); /**< Read SSR register first */
 8009d0c:	f7ff fe02 	bl	8009914 <ReadRtcSsrValue>
 8009d10:	6078      	str	r0, [r7, #4]

    if (SSRValueOnLastSetup >= return_value)
 8009d12:	4b16      	ldr	r3, [pc, #88]	; (8009d6c <ReturnTimeElapsed+0x70>)
 8009d14:	681b      	ldr	r3, [r3, #0]
 8009d16:	687a      	ldr	r2, [r7, #4]
 8009d18:	429a      	cmp	r2, r3
 8009d1a:	d805      	bhi.n	8009d28 <ReturnTimeElapsed+0x2c>
    {
      return_value = SSRValueOnLastSetup - return_value;
 8009d1c:	4b13      	ldr	r3, [pc, #76]	; (8009d6c <ReturnTimeElapsed+0x70>)
 8009d1e:	681a      	ldr	r2, [r3, #0]
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	1ad3      	subs	r3, r2, r3
 8009d24:	607b      	str	r3, [r7, #4]
 8009d26:	e00a      	b.n	8009d3e <ReturnTimeElapsed+0x42>
    }
    else
    {
      wrap_counter = SynchPrescalerUserConfig - return_value;
 8009d28:	4b11      	ldr	r3, [pc, #68]	; (8009d70 <ReturnTimeElapsed+0x74>)
 8009d2a:	881b      	ldrh	r3, [r3, #0]
 8009d2c:	461a      	mov	r2, r3
 8009d2e:	687b      	ldr	r3, [r7, #4]
 8009d30:	1ad3      	subs	r3, r2, r3
 8009d32:	603b      	str	r3, [r7, #0]
      return_value = SSRValueOnLastSetup + wrap_counter;
 8009d34:	4b0d      	ldr	r3, [pc, #52]	; (8009d6c <ReturnTimeElapsed+0x70>)
 8009d36:	681b      	ldr	r3, [r3, #0]
 8009d38:	683a      	ldr	r2, [r7, #0]
 8009d3a:	4413      	add	r3, r2
 8009d3c:	607b      	str	r3, [r7, #4]

    /**
     * At this stage, ReturnValue holds the number of ticks counted by SSR
     * Need to translate in number of ticks counted by the Wakeuptimer
     */
    return_value = return_value*AsynchPrescalerUserConfig;
 8009d3e:	4b0d      	ldr	r3, [pc, #52]	; (8009d74 <ReturnTimeElapsed+0x78>)
 8009d40:	781b      	ldrb	r3, [r3, #0]
 8009d42:	461a      	mov	r2, r3
 8009d44:	687b      	ldr	r3, [r7, #4]
 8009d46:	fb02 f303 	mul.w	r3, r2, r3
 8009d4a:	607b      	str	r3, [r7, #4]
    return_value = return_value >> WakeupTimerDivider;
 8009d4c:	4b0a      	ldr	r3, [pc, #40]	; (8009d78 <ReturnTimeElapsed+0x7c>)
 8009d4e:	781b      	ldrb	r3, [r3, #0]
 8009d50:	461a      	mov	r2, r3
 8009d52:	687b      	ldr	r3, [r7, #4]
 8009d54:	40d3      	lsrs	r3, r2
 8009d56:	607b      	str	r3, [r7, #4]
 8009d58:	e001      	b.n	8009d5e <ReturnTimeElapsed+0x62>
  }
  else
  {
    return_value = 0;
 8009d5a:	2300      	movs	r3, #0
 8009d5c:	607b      	str	r3, [r7, #4]
  }

  return (uint16_t)return_value;
 8009d5e:	687b      	ldr	r3, [r7, #4]
 8009d60:	b29b      	uxth	r3, r3
}
 8009d62:	4618      	mov	r0, r3
 8009d64:	3708      	adds	r7, #8
 8009d66:	46bd      	mov	sp, r7
 8009d68:	bd80      	pop	{r7, pc}
 8009d6a:	bf00      	nop
 8009d6c:	200002ac 	.word	0x200002ac
 8009d70:	200011aa 	.word	0x200011aa
 8009d74:	200011a9 	.word	0x200011a9
 8009d78:	200011a8 	.word	0x200011a8

08009d7c <RestartWakeupCounter>:
 *    It assumes all condition are met to be allowed to write the wakeup counter
 * @param  Value: Value to be written in the counter
 * @retval None
 */
static void RestartWakeupCounter(uint16_t Value)
{
 8009d7c:	b580      	push	{r7, lr}
 8009d7e:	b082      	sub	sp, #8
 8009d80:	af00      	add	r7, sp, #0
 8009d82:	4603      	mov	r3, r0
 8009d84:	80fb      	strh	r3, [r7, #6]
   * The wakeuptimer has been disabled in the calling function to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   *  __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);
   */

  if(Value == 0)
 8009d86:	88fb      	ldrh	r3, [r7, #6]
 8009d88:	2b00      	cmp	r3, #0
 8009d8a:	d108      	bne.n	8009d9e <RestartWakeupCounter+0x22>
  {
    SSRValueOnLastSetup = ReadRtcSsrValue();
 8009d8c:	f7ff fdc2 	bl	8009914 <ReadRtcSsrValue>
 8009d90:	4603      	mov	r3, r0
 8009d92:	4a24      	ldr	r2, [pc, #144]	; (8009e24 <RestartWakeupCounter+0xa8>)
 8009d94:	6013      	str	r3, [r2, #0]

    /**
     * Simulate that the Timer expired
     */
    HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 8009d96:	2003      	movs	r0, #3
 8009d98:	f003 fe86 	bl	800daa8 <HAL_NVIC_SetPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE(phrtc);    /**<  Enable the Wakeup Timer */

    HW_TS_RTC_CountUpdated_AppNot();
  }

  return ;
 8009d9c:	e03e      	b.n	8009e1c <RestartWakeupCounter+0xa0>
    if((Value > 1) ||(WakeupTimerDivider != 1))
 8009d9e:	88fb      	ldrh	r3, [r7, #6]
 8009da0:	2b01      	cmp	r3, #1
 8009da2:	d803      	bhi.n	8009dac <RestartWakeupCounter+0x30>
 8009da4:	4b20      	ldr	r3, [pc, #128]	; (8009e28 <RestartWakeupCounter+0xac>)
 8009da6:	781b      	ldrb	r3, [r3, #0]
 8009da8:	2b01      	cmp	r3, #1
 8009daa:	d002      	beq.n	8009db2 <RestartWakeupCounter+0x36>
      Value -= 1;
 8009dac:	88fb      	ldrh	r3, [r7, #6]
 8009dae:	3b01      	subs	r3, #1
 8009db0:	80fb      	strh	r3, [r7, #6]
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == RESET);
 8009db2:	bf00      	nop
 8009db4:	4b1d      	ldr	r3, [pc, #116]	; (8009e2c <RestartWakeupCounter+0xb0>)
 8009db6:	681b      	ldr	r3, [r3, #0]
 8009db8:	681b      	ldr	r3, [r3, #0]
 8009dba:	68db      	ldr	r3, [r3, #12]
 8009dbc:	f003 0304 	and.w	r3, r3, #4
 8009dc0:	2b00      	cmp	r3, #0
 8009dc2:	d0f7      	beq.n	8009db4 <RestartWakeupCounter+0x38>
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 8009dc4:	4b19      	ldr	r3, [pc, #100]	; (8009e2c <RestartWakeupCounter+0xb0>)
 8009dc6:	681b      	ldr	r3, [r3, #0]
 8009dc8:	681b      	ldr	r3, [r3, #0]
 8009dca:	68db      	ldr	r3, [r3, #12]
 8009dcc:	b2da      	uxtb	r2, r3
 8009dce:	4b17      	ldr	r3, [pc, #92]	; (8009e2c <RestartWakeupCounter+0xb0>)
 8009dd0:	681b      	ldr	r3, [r3, #0]
 8009dd2:	681b      	ldr	r3, [r3, #0]
 8009dd4:	f462 6290 	orn	r2, r2, #1152	; 0x480
 8009dd8:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 8009dda:	4b15      	ldr	r3, [pc, #84]	; (8009e30 <RestartWakeupCounter+0xb4>)
 8009ddc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8009de0:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 8009de2:	2003      	movs	r0, #3
 8009de4:	f003 fe6e 	bl	800dac4 <HAL_NVIC_ClearPendingIRQ>
    MODIFY_REG(RTC->WUTR, RTC_WUTR_WUT, Value);
 8009de8:	4b12      	ldr	r3, [pc, #72]	; (8009e34 <RestartWakeupCounter+0xb8>)
 8009dea:	695b      	ldr	r3, [r3, #20]
 8009dec:	0c1b      	lsrs	r3, r3, #16
 8009dee:	041b      	lsls	r3, r3, #16
 8009df0:	88fa      	ldrh	r2, [r7, #6]
 8009df2:	4910      	ldr	r1, [pc, #64]	; (8009e34 <RestartWakeupCounter+0xb8>)
 8009df4:	4313      	orrs	r3, r2
 8009df6:	614b      	str	r3, [r1, #20]
    SSRValueOnLastSetup = ReadRtcSsrValue();
 8009df8:	f7ff fd8c 	bl	8009914 <ReadRtcSsrValue>
 8009dfc:	4603      	mov	r3, r0
 8009dfe:	4a09      	ldr	r2, [pc, #36]	; (8009e24 <RestartWakeupCounter+0xa8>)
 8009e00:	6013      	str	r3, [r2, #0]
    __HAL_RTC_WAKEUPTIMER_ENABLE(phrtc);    /**<  Enable the Wakeup Timer */
 8009e02:	4b0a      	ldr	r3, [pc, #40]	; (8009e2c <RestartWakeupCounter+0xb0>)
 8009e04:	681b      	ldr	r3, [r3, #0]
 8009e06:	681b      	ldr	r3, [r3, #0]
 8009e08:	689a      	ldr	r2, [r3, #8]
 8009e0a:	4b08      	ldr	r3, [pc, #32]	; (8009e2c <RestartWakeupCounter+0xb0>)
 8009e0c:	681b      	ldr	r3, [r3, #0]
 8009e0e:	681b      	ldr	r3, [r3, #0]
 8009e10:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8009e14:	609a      	str	r2, [r3, #8]
    HW_TS_RTC_CountUpdated_AppNot();
 8009e16:	f3af 8000 	nop.w
  return ;
 8009e1a:	bf00      	nop
}
 8009e1c:	3708      	adds	r7, #8
 8009e1e:	46bd      	mov	sp, r7
 8009e20:	bd80      	pop	{r7, pc}
 8009e22:	bf00      	nop
 8009e24:	200002ac 	.word	0x200002ac
 8009e28:	200011a8 	.word	0x200011a8
 8009e2c:	200011a4 	.word	0x200011a4
 8009e30:	58000800 	.word	0x58000800
 8009e34:	40002800 	.word	0x40002800

08009e38 <RescheduleTimerList>:
 *    2) Setup the wakeuptimer
 * @param  None
 * @retval None
 */
static void RescheduleTimerList(void)
{
 8009e38:	b580      	push	{r7, lr}
 8009e3a:	b084      	sub	sp, #16
 8009e3c:	af00      	add	r7, sp, #0

  /**
   * The wakeuptimer is disabled now to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   */
  if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 8009e3e:	4b47      	ldr	r3, [pc, #284]	; (8009f5c <RescheduleTimerList+0x124>)
 8009e40:	689b      	ldr	r3, [r3, #8]
 8009e42:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009e46:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009e4a:	d108      	bne.n	8009e5e <RescheduleTimerList+0x26>
  {
    /**
     * Wait for the flag to be back to 0 when the wakeup timer is enabled
     */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == SET);
 8009e4c:	bf00      	nop
 8009e4e:	4b44      	ldr	r3, [pc, #272]	; (8009f60 <RescheduleTimerList+0x128>)
 8009e50:	681b      	ldr	r3, [r3, #0]
 8009e52:	681b      	ldr	r3, [r3, #0]
 8009e54:	68db      	ldr	r3, [r3, #12]
 8009e56:	f003 0304 	and.w	r3, r3, #4
 8009e5a:	2b00      	cmp	r3, #0
 8009e5c:	d1f7      	bne.n	8009e4e <RescheduleTimerList+0x16>
  }
  __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);   /**<  Disable the Wakeup Timer */
 8009e5e:	4b40      	ldr	r3, [pc, #256]	; (8009f60 <RescheduleTimerList+0x128>)
 8009e60:	681b      	ldr	r3, [r3, #0]
 8009e62:	681b      	ldr	r3, [r3, #0]
 8009e64:	689a      	ldr	r2, [r3, #8]
 8009e66:	4b3e      	ldr	r3, [pc, #248]	; (8009f60 <RescheduleTimerList+0x128>)
 8009e68:	681b      	ldr	r3, [r3, #0]
 8009e6a:	681b      	ldr	r3, [r3, #0]
 8009e6c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009e70:	609a      	str	r2, [r3, #8]

  localTimerID = CurrentRunningTimerID;
 8009e72:	4b3c      	ldr	r3, [pc, #240]	; (8009f64 <RescheduleTimerList+0x12c>)
 8009e74:	781b      	ldrb	r3, [r3, #0]
 8009e76:	73fb      	strb	r3, [r7, #15]

  /**
   * Calculate what will be the value to write in the wakeuptimer
   */
  timecountleft = aTimerContext[localTimerID].CountLeft;
 8009e78:	7bfa      	ldrb	r2, [r7, #15]
 8009e7a:	493b      	ldr	r1, [pc, #236]	; (8009f68 <RescheduleTimerList+0x130>)
 8009e7c:	4613      	mov	r3, r2
 8009e7e:	005b      	lsls	r3, r3, #1
 8009e80:	4413      	add	r3, r2
 8009e82:	00db      	lsls	r3, r3, #3
 8009e84:	440b      	add	r3, r1
 8009e86:	3308      	adds	r3, #8
 8009e88:	681b      	ldr	r3, [r3, #0]
 8009e8a:	60bb      	str	r3, [r7, #8]

  /**
   * Read how much has been counted
   */
  time_elapsed = ReturnTimeElapsed();
 8009e8c:	f7ff ff36 	bl	8009cfc <ReturnTimeElapsed>
 8009e90:	4603      	mov	r3, r0
 8009e92:	80fb      	strh	r3, [r7, #6]

  if(timecountleft < time_elapsed )
 8009e94:	88fb      	ldrh	r3, [r7, #6]
 8009e96:	68ba      	ldr	r2, [r7, #8]
 8009e98:	429a      	cmp	r2, r3
 8009e9a:	d205      	bcs.n	8009ea8 <RescheduleTimerList+0x70>
  {
    /**
     * There is no tick left to count
     */
    wakeup_timer_value = 0;
 8009e9c:	2300      	movs	r3, #0
 8009e9e:	81bb      	strh	r3, [r7, #12]
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 8009ea0:	4b32      	ldr	r3, [pc, #200]	; (8009f6c <RescheduleTimerList+0x134>)
 8009ea2:	2201      	movs	r2, #1
 8009ea4:	701a      	strb	r2, [r3, #0]
 8009ea6:	e04d      	b.n	8009f44 <RescheduleTimerList+0x10c>
  }
  else
  {
    if(timecountleft > (time_elapsed + MaxWakeupTimerSetup))
 8009ea8:	88fb      	ldrh	r3, [r7, #6]
 8009eaa:	4a31      	ldr	r2, [pc, #196]	; (8009f70 <RescheduleTimerList+0x138>)
 8009eac:	8812      	ldrh	r2, [r2, #0]
 8009eae:	b292      	uxth	r2, r2
 8009eb0:	4413      	add	r3, r2
 8009eb2:	461a      	mov	r2, r3
 8009eb4:	68bb      	ldr	r3, [r7, #8]
 8009eb6:	4293      	cmp	r3, r2
 8009eb8:	d906      	bls.n	8009ec8 <RescheduleTimerList+0x90>
    {
      /**
       * The number of tick left is greater than the Wakeuptimer maximum value
       */
      wakeup_timer_value = MaxWakeupTimerSetup;
 8009eba:	4b2d      	ldr	r3, [pc, #180]	; (8009f70 <RescheduleTimerList+0x138>)
 8009ebc:	881b      	ldrh	r3, [r3, #0]
 8009ebe:	81bb      	strh	r3, [r7, #12]

      WakeupTimerLimitation = WakeupTimerValue_Overpassed;
 8009ec0:	4b2a      	ldr	r3, [pc, #168]	; (8009f6c <RescheduleTimerList+0x134>)
 8009ec2:	2200      	movs	r2, #0
 8009ec4:	701a      	strb	r2, [r3, #0]
 8009ec6:	e03d      	b.n	8009f44 <RescheduleTimerList+0x10c>
    }
    else
    {
      wakeup_timer_value = timecountleft - time_elapsed;
 8009ec8:	68bb      	ldr	r3, [r7, #8]
 8009eca:	b29a      	uxth	r2, r3
 8009ecc:	88fb      	ldrh	r3, [r7, #6]
 8009ece:	1ad3      	subs	r3, r2, r3
 8009ed0:	81bb      	strh	r3, [r7, #12]
      WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 8009ed2:	4b26      	ldr	r3, [pc, #152]	; (8009f6c <RescheduleTimerList+0x134>)
 8009ed4:	2201      	movs	r2, #1
 8009ed6:	701a      	strb	r2, [r3, #0]
  }

  /**
   * update ticks left to be counted for each timer
   */
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8009ed8:	e034      	b.n	8009f44 <RescheduleTimerList+0x10c>
  {
    if (aTimerContext[localTimerID].CountLeft < time_elapsed)
 8009eda:	7bfa      	ldrb	r2, [r7, #15]
 8009edc:	4922      	ldr	r1, [pc, #136]	; (8009f68 <RescheduleTimerList+0x130>)
 8009ede:	4613      	mov	r3, r2
 8009ee0:	005b      	lsls	r3, r3, #1
 8009ee2:	4413      	add	r3, r2
 8009ee4:	00db      	lsls	r3, r3, #3
 8009ee6:	440b      	add	r3, r1
 8009ee8:	3308      	adds	r3, #8
 8009eea:	681a      	ldr	r2, [r3, #0]
 8009eec:	88fb      	ldrh	r3, [r7, #6]
 8009eee:	429a      	cmp	r2, r3
 8009ef0:	d20a      	bcs.n	8009f08 <RescheduleTimerList+0xd0>
    {
      aTimerContext[localTimerID].CountLeft = 0;
 8009ef2:	7bfa      	ldrb	r2, [r7, #15]
 8009ef4:	491c      	ldr	r1, [pc, #112]	; (8009f68 <RescheduleTimerList+0x130>)
 8009ef6:	4613      	mov	r3, r2
 8009ef8:	005b      	lsls	r3, r3, #1
 8009efa:	4413      	add	r3, r2
 8009efc:	00db      	lsls	r3, r3, #3
 8009efe:	440b      	add	r3, r1
 8009f00:	3308      	adds	r3, #8
 8009f02:	2200      	movs	r2, #0
 8009f04:	601a      	str	r2, [r3, #0]
 8009f06:	e013      	b.n	8009f30 <RescheduleTimerList+0xf8>
    }
    else
    {
      aTimerContext[localTimerID].CountLeft -= time_elapsed;
 8009f08:	7bfa      	ldrb	r2, [r7, #15]
 8009f0a:	4917      	ldr	r1, [pc, #92]	; (8009f68 <RescheduleTimerList+0x130>)
 8009f0c:	4613      	mov	r3, r2
 8009f0e:	005b      	lsls	r3, r3, #1
 8009f10:	4413      	add	r3, r2
 8009f12:	00db      	lsls	r3, r3, #3
 8009f14:	440b      	add	r3, r1
 8009f16:	3308      	adds	r3, #8
 8009f18:	6819      	ldr	r1, [r3, #0]
 8009f1a:	88fb      	ldrh	r3, [r7, #6]
 8009f1c:	7bfa      	ldrb	r2, [r7, #15]
 8009f1e:	1ac9      	subs	r1, r1, r3
 8009f20:	4811      	ldr	r0, [pc, #68]	; (8009f68 <RescheduleTimerList+0x130>)
 8009f22:	4613      	mov	r3, r2
 8009f24:	005b      	lsls	r3, r3, #1
 8009f26:	4413      	add	r3, r2
 8009f28:	00db      	lsls	r3, r3, #3
 8009f2a:	4403      	add	r3, r0
 8009f2c:	3308      	adds	r3, #8
 8009f2e:	6019      	str	r1, [r3, #0]
    }
    localTimerID = aTimerContext[localTimerID].NextID;
 8009f30:	7bfa      	ldrb	r2, [r7, #15]
 8009f32:	490d      	ldr	r1, [pc, #52]	; (8009f68 <RescheduleTimerList+0x130>)
 8009f34:	4613      	mov	r3, r2
 8009f36:	005b      	lsls	r3, r3, #1
 8009f38:	4413      	add	r3, r2
 8009f3a:	00db      	lsls	r3, r3, #3
 8009f3c:	440b      	add	r3, r1
 8009f3e:	3315      	adds	r3, #21
 8009f40:	781b      	ldrb	r3, [r3, #0]
 8009f42:	73fb      	strb	r3, [r7, #15]
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 8009f44:	7bfb      	ldrb	r3, [r7, #15]
 8009f46:	2b06      	cmp	r3, #6
 8009f48:	d1c7      	bne.n	8009eda <RescheduleTimerList+0xa2>
  }

  /**
   * Write next count
   */
  RestartWakeupCounter(wakeup_timer_value);
 8009f4a:	89bb      	ldrh	r3, [r7, #12]
 8009f4c:	4618      	mov	r0, r3
 8009f4e:	f7ff ff15 	bl	8009d7c <RestartWakeupCounter>

  return ;
 8009f52:	bf00      	nop
}
 8009f54:	3710      	adds	r7, #16
 8009f56:	46bd      	mov	sp, r7
 8009f58:	bd80      	pop	{r7, pc}
 8009f5a:	bf00      	nop
 8009f5c:	40002800 	.word	0x40002800
 8009f60:	200011a4 	.word	0x200011a4
 8009f64:	200002a8 	.word	0x200002a8
 8009f68:	20000218 	.word	0x20000218
 8009f6c:	200002b0 	.word	0x200002b0
 8009f70:	200011ac 	.word	0x200011ac

08009f74 <HW_TS_Init>:

  return;
}

void HW_TS_Init(HW_TS_InitMode_t TimerInitMode, RTC_HandleTypeDef *hrtc)
{
 8009f74:	b580      	push	{r7, lr}
 8009f76:	b088      	sub	sp, #32
 8009f78:	af00      	add	r7, sp, #0
 8009f7a:	4603      	mov	r3, r0
 8009f7c:	6039      	str	r1, [r7, #0]
 8009f7e:	71fb      	strb	r3, [r7, #7]
  uint32_t localmaxwakeuptimersetup;

  /**
   * Get RTC handler
   */
  phrtc = hrtc;
 8009f80:	4a64      	ldr	r2, [pc, #400]	; (800a114 <HW_TS_Init+0x1a0>)
 8009f82:	683b      	ldr	r3, [r7, #0]
 8009f84:	6013      	str	r3, [r2, #0]

 /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 8009f86:	4b63      	ldr	r3, [pc, #396]	; (800a114 <HW_TS_Init+0x1a0>)
 8009f88:	681b      	ldr	r3, [r3, #0]
 8009f8a:	681b      	ldr	r3, [r3, #0]
 8009f8c:	22ca      	movs	r2, #202	; 0xca
 8009f8e:	625a      	str	r2, [r3, #36]	; 0x24
 8009f90:	4b60      	ldr	r3, [pc, #384]	; (800a114 <HW_TS_Init+0x1a0>)
 8009f92:	681b      	ldr	r3, [r3, #0]
 8009f94:	681b      	ldr	r3, [r3, #0]
 8009f96:	2253      	movs	r2, #83	; 0x53
 8009f98:	625a      	str	r2, [r3, #36]	; 0x24

  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8009f9a:	4b5f      	ldr	r3, [pc, #380]	; (800a118 <HW_TS_Init+0x1a4>)
 8009f9c:	689b      	ldr	r3, [r3, #8]
 8009f9e:	4a5e      	ldr	r2, [pc, #376]	; (800a118 <HW_TS_Init+0x1a4>)
 8009fa0:	f043 0320 	orr.w	r3, r3, #32
 8009fa4:	6093      	str	r3, [r2, #8]

  /**
   * Readout the user config
   */
  WakeupTimerDivider = (4 - ((uint32_t)(READ_BIT(RTC->CR, RTC_CR_WUCKSEL))));
 8009fa6:	4b5c      	ldr	r3, [pc, #368]	; (800a118 <HW_TS_Init+0x1a4>)
 8009fa8:	689b      	ldr	r3, [r3, #8]
 8009faa:	b2db      	uxtb	r3, r3
 8009fac:	f003 0307 	and.w	r3, r3, #7
 8009fb0:	b2db      	uxtb	r3, r3
 8009fb2:	f1c3 0304 	rsb	r3, r3, #4
 8009fb6:	b2da      	uxtb	r2, r3
 8009fb8:	4b58      	ldr	r3, [pc, #352]	; (800a11c <HW_TS_Init+0x1a8>)
 8009fba:	701a      	strb	r2, [r3, #0]

  AsynchPrescalerUserConfig = (uint8_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_A) >> (uint32_t)POSITION_VAL(RTC_PRER_PREDIV_A)) + 1;
 8009fbc:	4b56      	ldr	r3, [pc, #344]	; (800a118 <HW_TS_Init+0x1a4>)
 8009fbe:	691b      	ldr	r3, [r3, #16]
 8009fc0:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8009fc4:	f44f 02fe 	mov.w	r2, #8323072	; 0x7f0000
 8009fc8:	613a      	str	r2, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8009fca:	693a      	ldr	r2, [r7, #16]
 8009fcc:	fa92 f2a2 	rbit	r2, r2
 8009fd0:	60fa      	str	r2, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8009fd2:	68fa      	ldr	r2, [r7, #12]
 8009fd4:	617a      	str	r2, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8009fd6:	697a      	ldr	r2, [r7, #20]
 8009fd8:	2a00      	cmp	r2, #0
 8009fda:	d101      	bne.n	8009fe0 <HW_TS_Init+0x6c>
  {
    return 32U;
 8009fdc:	2220      	movs	r2, #32
 8009fde:	e003      	b.n	8009fe8 <HW_TS_Init+0x74>
  }
  return __builtin_clz(value);
 8009fe0:	697a      	ldr	r2, [r7, #20]
 8009fe2:	fab2 f282 	clz	r2, r2
 8009fe6:	b2d2      	uxtb	r2, r2
 8009fe8:	40d3      	lsrs	r3, r2
 8009fea:	b2db      	uxtb	r3, r3
 8009fec:	3301      	adds	r3, #1
 8009fee:	b2da      	uxtb	r2, r3
 8009ff0:	4b4b      	ldr	r3, [pc, #300]	; (800a120 <HW_TS_Init+0x1ac>)
 8009ff2:	701a      	strb	r2, [r3, #0]

  SynchPrescalerUserConfig = (uint16_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_S)) + 1;
 8009ff4:	4b48      	ldr	r3, [pc, #288]	; (800a118 <HW_TS_Init+0x1a4>)
 8009ff6:	691b      	ldr	r3, [r3, #16]
 8009ff8:	b29b      	uxth	r3, r3
 8009ffa:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8009ffe:	b29b      	uxth	r3, r3
 800a000:	3301      	adds	r3, #1
 800a002:	b29a      	uxth	r2, r3
 800a004:	4b47      	ldr	r3, [pc, #284]	; (800a124 <HW_TS_Init+0x1b0>)
 800a006:	801a      	strh	r2, [r3, #0]

  /**
   *  Margin is taken to avoid wrong calculation when the wrap around is there and some
   *  application interrupts may have delayed the reading
   */
  localmaxwakeuptimersetup = ((((SynchPrescalerUserConfig - 1)*AsynchPrescalerUserConfig) - CFG_HW_TS_RTC_HANDLER_MAX_DELAY) >> WakeupTimerDivider);
 800a008:	4b46      	ldr	r3, [pc, #280]	; (800a124 <HW_TS_Init+0x1b0>)
 800a00a:	881b      	ldrh	r3, [r3, #0]
 800a00c:	3b01      	subs	r3, #1
 800a00e:	4a44      	ldr	r2, [pc, #272]	; (800a120 <HW_TS_Init+0x1ac>)
 800a010:	7812      	ldrb	r2, [r2, #0]
 800a012:	fb02 f303 	mul.w	r3, r2, r3
 800a016:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800a01a:	4a40      	ldr	r2, [pc, #256]	; (800a11c <HW_TS_Init+0x1a8>)
 800a01c:	7812      	ldrb	r2, [r2, #0]
 800a01e:	40d3      	lsrs	r3, r2
 800a020:	61bb      	str	r3, [r7, #24]

  if(localmaxwakeuptimersetup >= 0xFFFF)
 800a022:	69bb      	ldr	r3, [r7, #24]
 800a024:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800a028:	4293      	cmp	r3, r2
 800a02a:	d904      	bls.n	800a036 <HW_TS_Init+0xc2>
  {
    MaxWakeupTimerSetup = 0xFFFF;
 800a02c:	4b3e      	ldr	r3, [pc, #248]	; (800a128 <HW_TS_Init+0x1b4>)
 800a02e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a032:	801a      	strh	r2, [r3, #0]
 800a034:	e003      	b.n	800a03e <HW_TS_Init+0xca>
  }
  else
  {
    MaxWakeupTimerSetup = (uint16_t)localmaxwakeuptimersetup;
 800a036:	69bb      	ldr	r3, [r7, #24]
 800a038:	b29a      	uxth	r2, r3
 800a03a:	4b3b      	ldr	r3, [pc, #236]	; (800a128 <HW_TS_Init+0x1b4>)
 800a03c:	801a      	strh	r2, [r3, #0]
  }

  /**
   * Configure EXTI module
   */
  LL_EXTI_EnableRisingTrig_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800a03e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800a042:	f7ff fc55 	bl	80098f0 <LL_EXTI_EnableRisingTrig_0_31>
  LL_EXTI_EnableIT_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800a046:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800a04a:	f7ff fc3d 	bl	80098c8 <LL_EXTI_EnableIT_0_31>

  if(TimerInitMode == hw_ts_InitMode_Full)
 800a04e:	79fb      	ldrb	r3, [r7, #7]
 800a050:	2b00      	cmp	r3, #0
 800a052:	d143      	bne.n	800a0dc <HW_TS_Init+0x168>
  {
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 800a054:	4b35      	ldr	r3, [pc, #212]	; (800a12c <HW_TS_Init+0x1b8>)
 800a056:	2201      	movs	r2, #1
 800a058:	701a      	strb	r2, [r3, #0]
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 800a05a:	4b35      	ldr	r3, [pc, #212]	; (800a130 <HW_TS_Init+0x1bc>)
 800a05c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a060:	601a      	str	r2, [r3, #0]

    /**
     * Initialize the timer server
     */
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 800a062:	2300      	movs	r3, #0
 800a064:	77fb      	strb	r3, [r7, #31]
 800a066:	e00c      	b.n	800a082 <HW_TS_Init+0x10e>
    {
      aTimerContext[loop].TimerIDStatus = TimerID_Free;
 800a068:	7ffa      	ldrb	r2, [r7, #31]
 800a06a:	4932      	ldr	r1, [pc, #200]	; (800a134 <HW_TS_Init+0x1c0>)
 800a06c:	4613      	mov	r3, r2
 800a06e:	005b      	lsls	r3, r3, #1
 800a070:	4413      	add	r3, r2
 800a072:	00db      	lsls	r3, r3, #3
 800a074:	440b      	add	r3, r1
 800a076:	330c      	adds	r3, #12
 800a078:	2200      	movs	r2, #0
 800a07a:	701a      	strb	r2, [r3, #0]
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 800a07c:	7ffb      	ldrb	r3, [r7, #31]
 800a07e:	3301      	adds	r3, #1
 800a080:	77fb      	strb	r3, [r7, #31]
 800a082:	7ffb      	ldrb	r3, [r7, #31]
 800a084:	2b05      	cmp	r3, #5
 800a086:	d9ef      	bls.n	800a068 <HW_TS_Init+0xf4>
    }

    CurrentRunningTimerID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;   /**<  Set ID to non valid value */
 800a088:	4b2b      	ldr	r3, [pc, #172]	; (800a138 <HW_TS_Init+0x1c4>)
 800a08a:	2206      	movs	r2, #6
 800a08c:	701a      	strb	r2, [r3, #0]

    __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);                       /**<  Disable the Wakeup Timer */
 800a08e:	4b21      	ldr	r3, [pc, #132]	; (800a114 <HW_TS_Init+0x1a0>)
 800a090:	681b      	ldr	r3, [r3, #0]
 800a092:	681b      	ldr	r3, [r3, #0]
 800a094:	689a      	ldr	r2, [r3, #8]
 800a096:	4b1f      	ldr	r3, [pc, #124]	; (800a114 <HW_TS_Init+0x1a0>)
 800a098:	681b      	ldr	r3, [r3, #0]
 800a09a:	681b      	ldr	r3, [r3, #0]
 800a09c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a0a0:	609a      	str	r2, [r3, #8]
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);     /**<  Clear flag in RTC module */
 800a0a2:	4b1c      	ldr	r3, [pc, #112]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0a4:	681b      	ldr	r3, [r3, #0]
 800a0a6:	681b      	ldr	r3, [r3, #0]
 800a0a8:	68db      	ldr	r3, [r3, #12]
 800a0aa:	b2da      	uxtb	r2, r3
 800a0ac:	4b19      	ldr	r3, [pc, #100]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0ae:	681b      	ldr	r3, [r3, #0]
 800a0b0:	681b      	ldr	r3, [r3, #0]
 800a0b2:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800a0b6:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module  */
 800a0b8:	4b20      	ldr	r3, [pc, #128]	; (800a13c <HW_TS_Init+0x1c8>)
 800a0ba:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800a0be:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);       /**<  Clear pending bit in NVIC  */
 800a0c0:	2003      	movs	r0, #3
 800a0c2:	f003 fcff 	bl	800dac4 <HAL_NVIC_ClearPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE_IT(phrtc, RTC_IT_WUT);         /**<  Enable interrupt in RTC module  */
 800a0c6:	4b13      	ldr	r3, [pc, #76]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0c8:	681b      	ldr	r3, [r3, #0]
 800a0ca:	681b      	ldr	r3, [r3, #0]
 800a0cc:	689a      	ldr	r2, [r3, #8]
 800a0ce:	4b11      	ldr	r3, [pc, #68]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0d0:	681b      	ldr	r3, [r3, #0]
 800a0d2:	681b      	ldr	r3, [r3, #0]
 800a0d4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a0d8:	609a      	str	r2, [r3, #8]
 800a0da:	e00a      	b.n	800a0f2 <HW_TS_Init+0x17e>
  }
  else
  {
    if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTF) != RESET)
 800a0dc:	4b0d      	ldr	r3, [pc, #52]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0de:	681b      	ldr	r3, [r3, #0]
 800a0e0:	681b      	ldr	r3, [r3, #0]
 800a0e2:	68db      	ldr	r3, [r3, #12]
 800a0e4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a0e8:	2b00      	cmp	r3, #0
 800a0ea:	d002      	beq.n	800a0f2 <HW_TS_Init+0x17e>
    {
      /**
       * Simulate that the Timer expired
       */
      HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 800a0ec:	2003      	movs	r0, #3
 800a0ee:	f003 fcdb 	bl	800daa8 <HAL_NVIC_SetPendingIRQ>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800a0f2:	4b08      	ldr	r3, [pc, #32]	; (800a114 <HW_TS_Init+0x1a0>)
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	681b      	ldr	r3, [r3, #0]
 800a0f8:	22ff      	movs	r2, #255	; 0xff
 800a0fa:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_SetPriority(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO);   /**<  Set NVIC priority */
 800a0fc:	2200      	movs	r2, #0
 800a0fe:	2106      	movs	r1, #6
 800a100:	2003      	movs	r0, #3
 800a102:	f003 fc9b 	bl	800da3c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800a106:	2003      	movs	r0, #3
 800a108:	f003 fcb2 	bl	800da70 <HAL_NVIC_EnableIRQ>

  return;
 800a10c:	bf00      	nop
}
 800a10e:	3720      	adds	r7, #32
 800a110:	46bd      	mov	sp, r7
 800a112:	bd80      	pop	{r7, pc}
 800a114:	200011a4 	.word	0x200011a4
 800a118:	40002800 	.word	0x40002800
 800a11c:	200011a8 	.word	0x200011a8
 800a120:	200011a9 	.word	0x200011a9
 800a124:	200011aa 	.word	0x200011aa
 800a128:	200011ac 	.word	0x200011ac
 800a12c:	200002b0 	.word	0x200002b0
 800a130:	200002ac 	.word	0x200002ac
 800a134:	20000218 	.word	0x20000218
 800a138:	200002a8 	.word	0x200002a8
 800a13c:	58000800 	.word	0x58000800

0800a140 <HW_TS_Create>:

HW_TS_ReturnStatus_t HW_TS_Create(uint32_t TimerProcessID, uint8_t *pTimerId, HW_TS_Mode_t TimerMode, HW_TS_pTimerCb_t pftimeout_handler)
{
 800a140:	b480      	push	{r7}
 800a142:	b08b      	sub	sp, #44	; 0x2c
 800a144:	af00      	add	r7, sp, #0
 800a146:	60f8      	str	r0, [r7, #12]
 800a148:	60b9      	str	r1, [r7, #8]
 800a14a:	603b      	str	r3, [r7, #0]
 800a14c:	4613      	mov	r3, r2
 800a14e:	71fb      	strb	r3, [r7, #7]
  HW_TS_ReturnStatus_t localreturnstatus;
  uint8_t loop = 0;
 800a150:	2300      	movs	r3, #0
 800a152:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800a156:	f3ef 8310 	mrs	r3, PRIMASK
 800a15a:	61fb      	str	r3, [r7, #28]
  return(result);
 800a15c:	69fb      	ldr	r3, [r7, #28]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800a15e:	623b      	str	r3, [r7, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 800a160:	b672      	cpsid	i
}
 800a162:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  while((loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[loop].TimerIDStatus != TimerID_Free))
 800a164:	e004      	b.n	800a170 <HW_TS_Create+0x30>
  {
    loop++;
 800a166:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800a16a:	3301      	adds	r3, #1
 800a16c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  while((loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[loop].TimerIDStatus != TimerID_Free))
 800a170:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800a174:	2b05      	cmp	r3, #5
 800a176:	d80c      	bhi.n	800a192 <HW_TS_Create+0x52>
 800a178:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a17c:	492c      	ldr	r1, [pc, #176]	; (800a230 <HW_TS_Create+0xf0>)
 800a17e:	4613      	mov	r3, r2
 800a180:	005b      	lsls	r3, r3, #1
 800a182:	4413      	add	r3, r2
 800a184:	00db      	lsls	r3, r3, #3
 800a186:	440b      	add	r3, r1
 800a188:	330c      	adds	r3, #12
 800a18a:	781b      	ldrb	r3, [r3, #0]
 800a18c:	b2db      	uxtb	r3, r3
 800a18e:	2b00      	cmp	r3, #0
 800a190:	d1e9      	bne.n	800a166 <HW_TS_Create+0x26>
  }

  if(loop != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800a192:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800a196:	2b06      	cmp	r3, #6
 800a198:	d038      	beq.n	800a20c <HW_TS_Create+0xcc>
  {
    aTimerContext[loop].TimerIDStatus = TimerID_Created;
 800a19a:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a19e:	4924      	ldr	r1, [pc, #144]	; (800a230 <HW_TS_Create+0xf0>)
 800a1a0:	4613      	mov	r3, r2
 800a1a2:	005b      	lsls	r3, r3, #1
 800a1a4:	4413      	add	r3, r2
 800a1a6:	00db      	lsls	r3, r3, #3
 800a1a8:	440b      	add	r3, r1
 800a1aa:	330c      	adds	r3, #12
 800a1ac:	2201      	movs	r2, #1
 800a1ae:	701a      	strb	r2, [r3, #0]
 800a1b0:	6a3b      	ldr	r3, [r7, #32]
 800a1b2:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800a1b4:	69bb      	ldr	r3, [r7, #24]
 800a1b6:	f383 8810 	msr	PRIMASK, r3
}
 800a1ba:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
    __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

    aTimerContext[loop].TimerProcessID = TimerProcessID;
 800a1bc:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a1c0:	491b      	ldr	r1, [pc, #108]	; (800a230 <HW_TS_Create+0xf0>)
 800a1c2:	4613      	mov	r3, r2
 800a1c4:	005b      	lsls	r3, r3, #1
 800a1c6:	4413      	add	r3, r2
 800a1c8:	00db      	lsls	r3, r3, #3
 800a1ca:	440b      	add	r3, r1
 800a1cc:	3310      	adds	r3, #16
 800a1ce:	68fa      	ldr	r2, [r7, #12]
 800a1d0:	601a      	str	r2, [r3, #0]
    aTimerContext[loop].TimerMode = TimerMode;
 800a1d2:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a1d6:	4916      	ldr	r1, [pc, #88]	; (800a230 <HW_TS_Create+0xf0>)
 800a1d8:	4613      	mov	r3, r2
 800a1da:	005b      	lsls	r3, r3, #1
 800a1dc:	4413      	add	r3, r2
 800a1de:	00db      	lsls	r3, r3, #3
 800a1e0:	440b      	add	r3, r1
 800a1e2:	330d      	adds	r3, #13
 800a1e4:	79fa      	ldrb	r2, [r7, #7]
 800a1e6:	701a      	strb	r2, [r3, #0]
    aTimerContext[loop].pTimerCallBack = pftimeout_handler;
 800a1e8:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a1ec:	4910      	ldr	r1, [pc, #64]	; (800a230 <HW_TS_Create+0xf0>)
 800a1ee:	4613      	mov	r3, r2
 800a1f0:	005b      	lsls	r3, r3, #1
 800a1f2:	4413      	add	r3, r2
 800a1f4:	00db      	lsls	r3, r3, #3
 800a1f6:	440b      	add	r3, r1
 800a1f8:	683a      	ldr	r2, [r7, #0]
 800a1fa:	601a      	str	r2, [r3, #0]
    *pTimerId = loop;
 800a1fc:	68bb      	ldr	r3, [r7, #8]
 800a1fe:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800a202:	701a      	strb	r2, [r3, #0]

    localreturnstatus = hw_ts_Successful;
 800a204:	2300      	movs	r3, #0
 800a206:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 800a20a:	e008      	b.n	800a21e <HW_TS_Create+0xde>
 800a20c:	6a3b      	ldr	r3, [r7, #32]
 800a20e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800a210:	697b      	ldr	r3, [r7, #20]
 800a212:	f383 8810 	msr	PRIMASK, r3
}
 800a216:	bf00      	nop
  {
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
    __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

    localreturnstatus = hw_ts_Failed;
 800a218:	2301      	movs	r3, #1
 800a21a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  return(localreturnstatus);
 800a21e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800a222:	4618      	mov	r0, r3
 800a224:	372c      	adds	r7, #44	; 0x2c
 800a226:	46bd      	mov	sp, r7
 800a228:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a22c:	4770      	bx	lr
 800a22e:	bf00      	nop
 800a230:	20000218 	.word	0x20000218

0800a234 <HW_TS_Stop>:

  return;
}

void HW_TS_Stop(uint8_t timer_id)
{
 800a234:	b580      	push	{r7, lr}
 800a236:	b086      	sub	sp, #24
 800a238:	af00      	add	r7, sp, #0
 800a23a:	4603      	mov	r3, r0
 800a23c:	71fb      	strb	r3, [r7, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800a23e:	f3ef 8310 	mrs	r3, PRIMASK
 800a242:	60fb      	str	r3, [r7, #12]
  return(result);
 800a244:	68fb      	ldr	r3, [r7, #12]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800a246:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800a248:	b672      	cpsid	i
}
 800a24a:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 800a24c:	2003      	movs	r0, #3
 800a24e:	f003 fc1d 	bl	800da8c <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800a252:	4b38      	ldr	r3, [pc, #224]	; (800a334 <HW_TS_Stop+0x100>)
 800a254:	681b      	ldr	r3, [r3, #0]
 800a256:	681b      	ldr	r3, [r3, #0]
 800a258:	22ca      	movs	r2, #202	; 0xca
 800a25a:	625a      	str	r2, [r3, #36]	; 0x24
 800a25c:	4b35      	ldr	r3, [pc, #212]	; (800a334 <HW_TS_Stop+0x100>)
 800a25e:	681b      	ldr	r3, [r3, #0]
 800a260:	681b      	ldr	r3, [r3, #0]
 800a262:	2253      	movs	r2, #83	; 0x53
 800a264:	625a      	str	r2, [r3, #36]	; 0x24

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 800a266:	79fa      	ldrb	r2, [r7, #7]
 800a268:	4933      	ldr	r1, [pc, #204]	; (800a338 <HW_TS_Stop+0x104>)
 800a26a:	4613      	mov	r3, r2
 800a26c:	005b      	lsls	r3, r3, #1
 800a26e:	4413      	add	r3, r2
 800a270:	00db      	lsls	r3, r3, #3
 800a272:	440b      	add	r3, r1
 800a274:	330c      	adds	r3, #12
 800a276:	781b      	ldrb	r3, [r3, #0]
 800a278:	b2db      	uxtb	r3, r3
 800a27a:	2b02      	cmp	r3, #2
 800a27c:	d148      	bne.n	800a310 <HW_TS_Stop+0xdc>
  {
    UnlinkTimer(timer_id, SSR_Read_Requested);
 800a27e:	79fb      	ldrb	r3, [r7, #7]
 800a280:	2100      	movs	r1, #0
 800a282:	4618      	mov	r0, r3
 800a284:	f7ff fcb6 	bl	8009bf4 <UnlinkTimer>
    localcurrentrunningtimerid = CurrentRunningTimerID;
 800a288:	4b2c      	ldr	r3, [pc, #176]	; (800a33c <HW_TS_Stop+0x108>)
 800a28a:	781b      	ldrb	r3, [r3, #0]
 800a28c:	74fb      	strb	r3, [r7, #19]

    if(localcurrentrunningtimerid == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800a28e:	7cfb      	ldrb	r3, [r7, #19]
 800a290:	2b06      	cmp	r3, #6
 800a292:	d135      	bne.n	800a300 <HW_TS_Stop+0xcc>
       */

      /**
       * Disable the timer
       */
      if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 800a294:	4b2a      	ldr	r3, [pc, #168]	; (800a340 <HW_TS_Stop+0x10c>)
 800a296:	689b      	ldr	r3, [r3, #8]
 800a298:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800a29c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a2a0:	d108      	bne.n	800a2b4 <HW_TS_Stop+0x80>
      {
        /**
         * Wait for the flag to be back to 0 when the wakeup timer is enabled
         */
        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == SET);
 800a2a2:	bf00      	nop
 800a2a4:	4b23      	ldr	r3, [pc, #140]	; (800a334 <HW_TS_Stop+0x100>)
 800a2a6:	681b      	ldr	r3, [r3, #0]
 800a2a8:	681b      	ldr	r3, [r3, #0]
 800a2aa:	68db      	ldr	r3, [r3, #12]
 800a2ac:	f003 0304 	and.w	r3, r3, #4
 800a2b0:	2b00      	cmp	r3, #0
 800a2b2:	d1f7      	bne.n	800a2a4 <HW_TS_Stop+0x70>
      }
      __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);   /**<  Disable the Wakeup Timer */
 800a2b4:	4b1f      	ldr	r3, [pc, #124]	; (800a334 <HW_TS_Stop+0x100>)
 800a2b6:	681b      	ldr	r3, [r3, #0]
 800a2b8:	681b      	ldr	r3, [r3, #0]
 800a2ba:	689a      	ldr	r2, [r3, #8]
 800a2bc:	4b1d      	ldr	r3, [pc, #116]	; (800a334 <HW_TS_Stop+0x100>)
 800a2be:	681b      	ldr	r3, [r3, #0]
 800a2c0:	681b      	ldr	r3, [r3, #0]
 800a2c2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a2c6:	609a      	str	r2, [r3, #8]

      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == RESET);
 800a2c8:	bf00      	nop
 800a2ca:	4b1a      	ldr	r3, [pc, #104]	; (800a334 <HW_TS_Stop+0x100>)
 800a2cc:	681b      	ldr	r3, [r3, #0]
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	68db      	ldr	r3, [r3, #12]
 800a2d2:	f003 0304 	and.w	r3, r3, #4
 800a2d6:	2b00      	cmp	r3, #0
 800a2d8:	d0f7      	beq.n	800a2ca <HW_TS_Stop+0x96>
       * It takes 2 RTCCLK between the time the WUTE bit is disabled and the
       * time the timer is disabled. The WUTWF bit somehow guarantee the system is stable
       * Otherwise, when the timer is periodic with 1 Tick, it may generate an extra interrupt in between
       * due to the autoreload feature
       */
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 800a2da:	4b16      	ldr	r3, [pc, #88]	; (800a334 <HW_TS_Stop+0x100>)
 800a2dc:	681b      	ldr	r3, [r3, #0]
 800a2de:	681b      	ldr	r3, [r3, #0]
 800a2e0:	68db      	ldr	r3, [r3, #12]
 800a2e2:	b2da      	uxtb	r2, r3
 800a2e4:	4b13      	ldr	r3, [pc, #76]	; (800a334 <HW_TS_Stop+0x100>)
 800a2e6:	681b      	ldr	r3, [r3, #0]
 800a2e8:	681b      	ldr	r3, [r3, #0]
 800a2ea:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800a2ee:	60da      	str	r2, [r3, #12]
      __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 800a2f0:	4b14      	ldr	r3, [pc, #80]	; (800a344 <HW_TS_Stop+0x110>)
 800a2f2:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800a2f6:	60da      	str	r2, [r3, #12]
      HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 800a2f8:	2003      	movs	r0, #3
 800a2fa:	f003 fbe3 	bl	800dac4 <HAL_NVIC_ClearPendingIRQ>
 800a2fe:	e007      	b.n	800a310 <HW_TS_Stop+0xdc>
    }
    else if(PreviousRunningTimerID != localcurrentrunningtimerid)
 800a300:	4b11      	ldr	r3, [pc, #68]	; (800a348 <HW_TS_Stop+0x114>)
 800a302:	781b      	ldrb	r3, [r3, #0]
 800a304:	b2db      	uxtb	r3, r3
 800a306:	7cfa      	ldrb	r2, [r7, #19]
 800a308:	429a      	cmp	r2, r3
 800a30a:	d001      	beq.n	800a310 <HW_TS_Stop+0xdc>
    {
      RescheduleTimerList();
 800a30c:	f7ff fd94 	bl	8009e38 <RescheduleTimerList>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800a310:	4b08      	ldr	r3, [pc, #32]	; (800a334 <HW_TS_Stop+0x100>)
 800a312:	681b      	ldr	r3, [r3, #0]
 800a314:	681b      	ldr	r3, [r3, #0]
 800a316:	22ff      	movs	r2, #255	; 0xff
 800a318:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800a31a:	2003      	movs	r0, #3
 800a31c:	f003 fba8 	bl	800da70 <HAL_NVIC_EnableIRQ>
 800a320:	697b      	ldr	r3, [r7, #20]
 800a322:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800a324:	68bb      	ldr	r3, [r7, #8]
 800a326:	f383 8810 	msr	PRIMASK, r3
}
 800a32a:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 800a32c:	bf00      	nop
}
 800a32e:	3718      	adds	r7, #24
 800a330:	46bd      	mov	sp, r7
 800a332:	bd80      	pop	{r7, pc}
 800a334:	200011a4 	.word	0x200011a4
 800a338:	20000218 	.word	0x20000218
 800a33c:	200002a8 	.word	0x200002a8
 800a340:	40002800 	.word	0x40002800
 800a344:	58000800 	.word	0x58000800
 800a348:	200002a9 	.word	0x200002a9

0800a34c <HW_TS_Start>:

void HW_TS_Start(uint8_t timer_id, uint32_t timeout_ticks)
{
 800a34c:	b580      	push	{r7, lr}
 800a34e:	b086      	sub	sp, #24
 800a350:	af00      	add	r7, sp, #0
 800a352:	4603      	mov	r3, r0
 800a354:	6039      	str	r1, [r7, #0]
 800a356:	71fb      	strb	r3, [r7, #7]

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 800a358:	79fa      	ldrb	r2, [r7, #7]
 800a35a:	493c      	ldr	r1, [pc, #240]	; (800a44c <HW_TS_Start+0x100>)
 800a35c:	4613      	mov	r3, r2
 800a35e:	005b      	lsls	r3, r3, #1
 800a360:	4413      	add	r3, r2
 800a362:	00db      	lsls	r3, r3, #3
 800a364:	440b      	add	r3, r1
 800a366:	330c      	adds	r3, #12
 800a368:	781b      	ldrb	r3, [r3, #0]
 800a36a:	b2db      	uxtb	r3, r3
 800a36c:	2b02      	cmp	r3, #2
 800a36e:	d103      	bne.n	800a378 <HW_TS_Start+0x2c>
  {
    HW_TS_Stop( timer_id );
 800a370:	79fb      	ldrb	r3, [r7, #7]
 800a372:	4618      	mov	r0, r3
 800a374:	f7ff ff5e 	bl	800a234 <HW_TS_Stop>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800a378:	f3ef 8310 	mrs	r3, PRIMASK
 800a37c:	60fb      	str	r3, [r7, #12]
  return(result);
 800a37e:	68fb      	ldr	r3, [r7, #12]
  }

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800a380:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800a382:	b672      	cpsid	i
}
 800a384:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 800a386:	2003      	movs	r0, #3
 800a388:	f003 fb80 	bl	800da8c <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800a38c:	4b30      	ldr	r3, [pc, #192]	; (800a450 <HW_TS_Start+0x104>)
 800a38e:	681b      	ldr	r3, [r3, #0]
 800a390:	681b      	ldr	r3, [r3, #0]
 800a392:	22ca      	movs	r2, #202	; 0xca
 800a394:	625a      	str	r2, [r3, #36]	; 0x24
 800a396:	4b2e      	ldr	r3, [pc, #184]	; (800a450 <HW_TS_Start+0x104>)
 800a398:	681b      	ldr	r3, [r3, #0]
 800a39a:	681b      	ldr	r3, [r3, #0]
 800a39c:	2253      	movs	r2, #83	; 0x53
 800a39e:	625a      	str	r2, [r3, #36]	; 0x24

  aTimerContext[timer_id].TimerIDStatus = TimerID_Running;
 800a3a0:	79fa      	ldrb	r2, [r7, #7]
 800a3a2:	492a      	ldr	r1, [pc, #168]	; (800a44c <HW_TS_Start+0x100>)
 800a3a4:	4613      	mov	r3, r2
 800a3a6:	005b      	lsls	r3, r3, #1
 800a3a8:	4413      	add	r3, r2
 800a3aa:	00db      	lsls	r3, r3, #3
 800a3ac:	440b      	add	r3, r1
 800a3ae:	330c      	adds	r3, #12
 800a3b0:	2202      	movs	r2, #2
 800a3b2:	701a      	strb	r2, [r3, #0]

  aTimerContext[timer_id].CountLeft = timeout_ticks;
 800a3b4:	79fa      	ldrb	r2, [r7, #7]
 800a3b6:	4925      	ldr	r1, [pc, #148]	; (800a44c <HW_TS_Start+0x100>)
 800a3b8:	4613      	mov	r3, r2
 800a3ba:	005b      	lsls	r3, r3, #1
 800a3bc:	4413      	add	r3, r2
 800a3be:	00db      	lsls	r3, r3, #3
 800a3c0:	440b      	add	r3, r1
 800a3c2:	3308      	adds	r3, #8
 800a3c4:	683a      	ldr	r2, [r7, #0]
 800a3c6:	601a      	str	r2, [r3, #0]
  aTimerContext[timer_id].CounterInit = timeout_ticks;
 800a3c8:	79fa      	ldrb	r2, [r7, #7]
 800a3ca:	4920      	ldr	r1, [pc, #128]	; (800a44c <HW_TS_Start+0x100>)
 800a3cc:	4613      	mov	r3, r2
 800a3ce:	005b      	lsls	r3, r3, #1
 800a3d0:	4413      	add	r3, r2
 800a3d2:	00db      	lsls	r3, r3, #3
 800a3d4:	440b      	add	r3, r1
 800a3d6:	3304      	adds	r3, #4
 800a3d8:	683a      	ldr	r2, [r7, #0]
 800a3da:	601a      	str	r2, [r3, #0]

  time_elapsed =  linkTimer(timer_id);
 800a3dc:	79fb      	ldrb	r3, [r7, #7]
 800a3de:	4618      	mov	r0, r3
 800a3e0:	f7ff fb5e 	bl	8009aa0 <linkTimer>
 800a3e4:	4603      	mov	r3, r0
 800a3e6:	827b      	strh	r3, [r7, #18]

  localcurrentrunningtimerid = CurrentRunningTimerID;
 800a3e8:	4b1a      	ldr	r3, [pc, #104]	; (800a454 <HW_TS_Start+0x108>)
 800a3ea:	781b      	ldrb	r3, [r3, #0]
 800a3ec:	747b      	strb	r3, [r7, #17]

  if(PreviousRunningTimerID != localcurrentrunningtimerid)
 800a3ee:	4b1a      	ldr	r3, [pc, #104]	; (800a458 <HW_TS_Start+0x10c>)
 800a3f0:	781b      	ldrb	r3, [r3, #0]
 800a3f2:	b2db      	uxtb	r3, r3
 800a3f4:	7c7a      	ldrb	r2, [r7, #17]
 800a3f6:	429a      	cmp	r2, r3
 800a3f8:	d002      	beq.n	800a400 <HW_TS_Start+0xb4>
  {
    RescheduleTimerList();
 800a3fa:	f7ff fd1d 	bl	8009e38 <RescheduleTimerList>
 800a3fe:	e013      	b.n	800a428 <HW_TS_Start+0xdc>
  }
  else
  {
    aTimerContext[timer_id].CountLeft -= time_elapsed;
 800a400:	79fa      	ldrb	r2, [r7, #7]
 800a402:	4912      	ldr	r1, [pc, #72]	; (800a44c <HW_TS_Start+0x100>)
 800a404:	4613      	mov	r3, r2
 800a406:	005b      	lsls	r3, r3, #1
 800a408:	4413      	add	r3, r2
 800a40a:	00db      	lsls	r3, r3, #3
 800a40c:	440b      	add	r3, r1
 800a40e:	3308      	adds	r3, #8
 800a410:	6819      	ldr	r1, [r3, #0]
 800a412:	8a7b      	ldrh	r3, [r7, #18]
 800a414:	79fa      	ldrb	r2, [r7, #7]
 800a416:	1ac9      	subs	r1, r1, r3
 800a418:	480c      	ldr	r0, [pc, #48]	; (800a44c <HW_TS_Start+0x100>)
 800a41a:	4613      	mov	r3, r2
 800a41c:	005b      	lsls	r3, r3, #1
 800a41e:	4413      	add	r3, r2
 800a420:	00db      	lsls	r3, r3, #3
 800a422:	4403      	add	r3, r0
 800a424:	3308      	adds	r3, #8
 800a426:	6019      	str	r1, [r3, #0]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800a428:	4b09      	ldr	r3, [pc, #36]	; (800a450 <HW_TS_Start+0x104>)
 800a42a:	681b      	ldr	r3, [r3, #0]
 800a42c:	681b      	ldr	r3, [r3, #0]
 800a42e:	22ff      	movs	r2, #255	; 0xff
 800a430:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800a432:	2003      	movs	r0, #3
 800a434:	f003 fb1c 	bl	800da70 <HAL_NVIC_EnableIRQ>
 800a438:	697b      	ldr	r3, [r7, #20]
 800a43a:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800a43c:	68bb      	ldr	r3, [r7, #8]
 800a43e:	f383 8810 	msr	PRIMASK, r3
}
 800a442:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 800a444:	bf00      	nop
}
 800a446:	3718      	adds	r7, #24
 800a448:	46bd      	mov	sp, r7
 800a44a:	bd80      	pop	{r7, pc}
 800a44c:	20000218 	.word	0x20000218
 800a450:	200011a4 	.word	0x200011a4
 800a454:	200002a8 	.word	0x200002a8
 800a458:	200002a9 	.word	0x200002a9

0800a45c <LL_AHB2_GRP1_EnableClock>:
{
 800a45c:	b480      	push	{r7}
 800a45e:	b085      	sub	sp, #20
 800a460:	af00      	add	r7, sp, #0
 800a462:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800a464:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a468:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800a46a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800a46e:	687b      	ldr	r3, [r7, #4]
 800a470:	4313      	orrs	r3, r2
 800a472:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800a474:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a478:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800a47a:	687b      	ldr	r3, [r7, #4]
 800a47c:	4013      	ands	r3, r2
 800a47e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800a480:	68fb      	ldr	r3, [r7, #12]
}
 800a482:	bf00      	nop
 800a484:	3714      	adds	r7, #20
 800a486:	46bd      	mov	sp, r7
 800a488:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a48c:	4770      	bx	lr

0800a48e <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 800a48e:	b480      	push	{r7}
 800a490:	b085      	sub	sp, #20
 800a492:	af00      	add	r7, sp, #0
 800a494:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 800a496:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a49a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a49c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800a4a0:	687b      	ldr	r3, [r7, #4]
 800a4a2:	4313      	orrs	r3, r2
 800a4a4:	658b      	str	r3, [r1, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800a4a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a4aa:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a4ac:	687b      	ldr	r3, [r7, #4]
 800a4ae:	4013      	ands	r3, r2
 800a4b0:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800a4b2:	68fb      	ldr	r3, [r7, #12]
}
 800a4b4:	bf00      	nop
 800a4b6:	3714      	adds	r7, #20
 800a4b8:	46bd      	mov	sp, r7
 800a4ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4be:	4770      	bx	lr

0800a4c0 <MX_I2C1_Init>:
I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c3;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 800a4c0:	b580      	push	{r7, lr}
 800a4c2:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 800a4c4:	4b1b      	ldr	r3, [pc, #108]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4c6:	4a1c      	ldr	r2, [pc, #112]	; (800a538 <MX_I2C1_Init+0x78>)
 800a4c8:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x10707DBC;
 800a4ca:	4b1a      	ldr	r3, [pc, #104]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4cc:	4a1b      	ldr	r2, [pc, #108]	; (800a53c <MX_I2C1_Init+0x7c>)
 800a4ce:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 800a4d0:	4b18      	ldr	r3, [pc, #96]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4d2:	2200      	movs	r2, #0
 800a4d4:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a4d6:	4b17      	ldr	r3, [pc, #92]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4d8:	2201      	movs	r2, #1
 800a4da:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800a4dc:	4b15      	ldr	r3, [pc, #84]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4de:	2200      	movs	r2, #0
 800a4e0:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800a4e2:	4b14      	ldr	r3, [pc, #80]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4e4:	2200      	movs	r2, #0
 800a4e6:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800a4e8:	4b12      	ldr	r3, [pc, #72]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4ea:	2200      	movs	r2, #0
 800a4ec:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800a4ee:	4b11      	ldr	r3, [pc, #68]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4f0:	2200      	movs	r2, #0
 800a4f2:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800a4f4:	4b0f      	ldr	r3, [pc, #60]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4f6:	2200      	movs	r2, #0
 800a4f8:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 800a4fa:	480e      	ldr	r0, [pc, #56]	; (800a534 <MX_I2C1_Init+0x74>)
 800a4fc:	f003 fe70 	bl	800e1e0 <HAL_I2C_Init>
 800a500:	4603      	mov	r3, r0
 800a502:	2b00      	cmp	r3, #0
 800a504:	d001      	beq.n	800a50a <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 800a506:	f000 fcf1 	bl	800aeec <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800a50a:	2100      	movs	r1, #0
 800a50c:	4809      	ldr	r0, [pc, #36]	; (800a534 <MX_I2C1_Init+0x74>)
 800a50e:	f004 fdff 	bl	800f110 <HAL_I2CEx_ConfigAnalogFilter>
 800a512:	4603      	mov	r3, r0
 800a514:	2b00      	cmp	r3, #0
 800a516:	d001      	beq.n	800a51c <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 800a518:	f000 fce8 	bl	800aeec <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 800a51c:	2100      	movs	r1, #0
 800a51e:	4805      	ldr	r0, [pc, #20]	; (800a534 <MX_I2C1_Init+0x74>)
 800a520:	f004 fe41 	bl	800f1a6 <HAL_I2CEx_ConfigDigitalFilter>
 800a524:	4603      	mov	r3, r0
 800a526:	2b00      	cmp	r3, #0
 800a528:	d001      	beq.n	800a52e <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 800a52a:	f000 fcdf 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 800a52e:	bf00      	nop
 800a530:	bd80      	pop	{r7, pc}
 800a532:	bf00      	nop
 800a534:	20011fa8 	.word	0x20011fa8
 800a538:	40005400 	.word	0x40005400
 800a53c:	10707dbc 	.word	0x10707dbc

0800a540 <MX_I2C3_Init>:
/* I2C3 init function */
void MX_I2C3_Init(void)
{
 800a540:	b580      	push	{r7, lr}
 800a542:	af00      	add	r7, sp, #0
  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
 800a544:	4b1b      	ldr	r3, [pc, #108]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a546:	4a1c      	ldr	r2, [pc, #112]	; (800a5b8 <MX_I2C3_Init+0x78>)
 800a548:	601a      	str	r2, [r3, #0]
  hi2c3.Init.Timing = 0x10707DBC;
 800a54a:	4b1a      	ldr	r3, [pc, #104]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a54c:	4a1b      	ldr	r2, [pc, #108]	; (800a5bc <MX_I2C3_Init+0x7c>)
 800a54e:	605a      	str	r2, [r3, #4]
  hi2c3.Init.OwnAddress1 = 0;
 800a550:	4b18      	ldr	r3, [pc, #96]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a552:	2200      	movs	r2, #0
 800a554:	609a      	str	r2, [r3, #8]
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a556:	4b17      	ldr	r3, [pc, #92]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a558:	2201      	movs	r2, #1
 800a55a:	60da      	str	r2, [r3, #12]
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800a55c:	4b15      	ldr	r3, [pc, #84]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a55e:	2200      	movs	r2, #0
 800a560:	611a      	str	r2, [r3, #16]
  hi2c3.Init.OwnAddress2 = 0;
 800a562:	4b14      	ldr	r3, [pc, #80]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a564:	2200      	movs	r2, #0
 800a566:	615a      	str	r2, [r3, #20]
  hi2c3.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800a568:	4b12      	ldr	r3, [pc, #72]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a56a:	2200      	movs	r2, #0
 800a56c:	619a      	str	r2, [r3, #24]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800a56e:	4b11      	ldr	r3, [pc, #68]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a570:	2200      	movs	r2, #0
 800a572:	61da      	str	r2, [r3, #28]
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800a574:	4b0f      	ldr	r3, [pc, #60]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a576:	2200      	movs	r2, #0
 800a578:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 800a57a:	480e      	ldr	r0, [pc, #56]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a57c:	f003 fe30 	bl	800e1e0 <HAL_I2C_Init>
 800a580:	4603      	mov	r3, r0
 800a582:	2b00      	cmp	r3, #0
 800a584:	d001      	beq.n	800a58a <MX_I2C3_Init+0x4a>
  {
    Error_Handler();
 800a586:	f000 fcb1 	bl	800aeec <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800a58a:	2100      	movs	r1, #0
 800a58c:	4809      	ldr	r0, [pc, #36]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a58e:	f004 fdbf 	bl	800f110 <HAL_I2CEx_ConfigAnalogFilter>
 800a592:	4603      	mov	r3, r0
 800a594:	2b00      	cmp	r3, #0
 800a596:	d001      	beq.n	800a59c <MX_I2C3_Init+0x5c>
  {
    Error_Handler();
 800a598:	f000 fca8 	bl	800aeec <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 800a59c:	2100      	movs	r1, #0
 800a59e:	4805      	ldr	r0, [pc, #20]	; (800a5b4 <MX_I2C3_Init+0x74>)
 800a5a0:	f004 fe01 	bl	800f1a6 <HAL_I2CEx_ConfigDigitalFilter>
 800a5a4:	4603      	mov	r3, r0
 800a5a6:	2b00      	cmp	r3, #0
 800a5a8:	d001      	beq.n	800a5ae <MX_I2C3_Init+0x6e>
  {
    Error_Handler();
 800a5aa:	f000 fc9f 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}
 800a5ae:	bf00      	nop
 800a5b0:	bd80      	pop	{r7, pc}
 800a5b2:	bf00      	nop
 800a5b4:	20011f5c 	.word	0x20011f5c
 800a5b8:	40005c00 	.word	0x40005c00
 800a5bc:	10707dbc 	.word	0x10707dbc

0800a5c0 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 800a5c0:	b580      	push	{r7, lr}
 800a5c2:	b09c      	sub	sp, #112	; 0x70
 800a5c4:	af00      	add	r7, sp, #0
 800a5c6:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a5c8:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800a5cc:	2200      	movs	r2, #0
 800a5ce:	601a      	str	r2, [r3, #0]
 800a5d0:	605a      	str	r2, [r3, #4]
 800a5d2:	609a      	str	r2, [r3, #8]
 800a5d4:	60da      	str	r2, [r3, #12]
 800a5d6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800a5d8:	f107 030c 	add.w	r3, r7, #12
 800a5dc:	2250      	movs	r2, #80	; 0x50
 800a5de:	2100      	movs	r1, #0
 800a5e0:	4618      	mov	r0, r3
 800a5e2:	f021 fd8b 	bl	802c0fc <memset>
  if(i2cHandle->Instance==I2C1)
 800a5e6:	687b      	ldr	r3, [r7, #4]
 800a5e8:	681b      	ldr	r3, [r3, #0]
 800a5ea:	4a3f      	ldr	r2, [pc, #252]	; (800a6e8 <HAL_I2C_MspInit+0x128>)
 800a5ec:	4293      	cmp	r3, r2
 800a5ee:	d12f      	bne.n	800a650 <HAL_I2C_MspInit+0x90>
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 800a5f0:	2304      	movs	r3, #4
 800a5f2:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 800a5f4:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800a5f8:	62fb      	str	r3, [r7, #44]	; 0x2c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a5fa:	f107 030c 	add.w	r3, r7, #12
 800a5fe:	4618      	mov	r0, r3
 800a600:	f008 f96e 	bl	80128e0 <HAL_RCCEx_PeriphCLKConfig>
 800a604:	4603      	mov	r3, r0
 800a606:	2b00      	cmp	r3, #0
 800a608:	d001      	beq.n	800a60e <HAL_I2C_MspInit+0x4e>
    {
      Error_Handler();
 800a60a:	f000 fc6f 	bl	800aeec <Error_Handler>
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800a60e:	2002      	movs	r0, #2
 800a610:	f7ff ff24 	bl	800a45c <LL_AHB2_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PB9     ------> I2C1_SDA
    PB6     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_6;
 800a614:	f44f 7310 	mov.w	r3, #576	; 0x240
 800a618:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800a61a:	2312      	movs	r3, #18
 800a61c:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800a61e:	2301      	movs	r3, #1
 800a620:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a622:	2302      	movs	r3, #2
 800a624:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 800a626:	2304      	movs	r3, #4
 800a628:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a62a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800a62e:	4619      	mov	r1, r3
 800a630:	482e      	ldr	r0, [pc, #184]	; (800a6ec <HAL_I2C_MspInit+0x12c>)
 800a632:	f003 fc11 	bl	800de58 <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800a636:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800a63a:	f7ff ff28 	bl	800a48e <LL_APB1_GRP1_EnableClock>

    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
 800a63e:	2200      	movs	r2, #0
 800a640:	2105      	movs	r1, #5
 800a642:	201e      	movs	r0, #30
 800a644:	f003 f9fa 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 800a648:	201e      	movs	r0, #30
 800a64a:	f003 fa11 	bl	800da70 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_EnableIRQ(I2C3_EV_IRQn);
  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }
}
 800a64e:	e046      	b.n	800a6de <HAL_I2C_MspInit+0x11e>
  else if(i2cHandle->Instance==I2C3)
 800a650:	687b      	ldr	r3, [r7, #4]
 800a652:	681b      	ldr	r3, [r3, #0]
 800a654:	4a26      	ldr	r2, [pc, #152]	; (800a6f0 <HAL_I2C_MspInit+0x130>)
 800a656:	4293      	cmp	r3, r2
 800a658:	d141      	bne.n	800a6de <HAL_I2C_MspInit+0x11e>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C3;
 800a65a:	2308      	movs	r3, #8
 800a65c:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
 800a65e:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 800a662:	633b      	str	r3, [r7, #48]	; 0x30
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a664:	f107 030c 	add.w	r3, r7, #12
 800a668:	4618      	mov	r0, r3
 800a66a:	f008 f939 	bl	80128e0 <HAL_RCCEx_PeriphCLKConfig>
 800a66e:	4603      	mov	r3, r0
 800a670:	2b00      	cmp	r3, #0
 800a672:	d001      	beq.n	800a678 <HAL_I2C_MspInit+0xb8>
      Error_Handler();
 800a674:	f000 fc3a 	bl	800aeec <Error_Handler>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800a678:	2004      	movs	r0, #4
 800a67a:	f7ff feef 	bl	800a45c <LL_AHB2_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800a67e:	2001      	movs	r0, #1
 800a680:	f7ff feec 	bl	800a45c <LL_AHB2_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 800a684:	2302      	movs	r3, #2
 800a686:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800a688:	2312      	movs	r3, #18
 800a68a:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800a68c:	2301      	movs	r3, #1
 800a68e:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a690:	2302      	movs	r3, #2
 800a692:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 800a694:	2304      	movs	r3, #4
 800a696:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a698:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800a69c:	4619      	mov	r1, r3
 800a69e:	4815      	ldr	r0, [pc, #84]	; (800a6f4 <HAL_I2C_MspInit+0x134>)
 800a6a0:	f003 fbda 	bl	800de58 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_7;
 800a6a4:	2380      	movs	r3, #128	; 0x80
 800a6a6:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800a6a8:	2312      	movs	r3, #18
 800a6aa:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800a6ac:	2301      	movs	r3, #1
 800a6ae:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a6b0:	2302      	movs	r3, #2
 800a6b2:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 800a6b4:	2304      	movs	r3, #4
 800a6b6:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a6b8:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800a6bc:	4619      	mov	r1, r3
 800a6be:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800a6c2:	f003 fbc9 	bl	800de58 <HAL_GPIO_Init>
    __HAL_RCC_I2C3_CLK_ENABLE();
 800a6c6:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 800a6ca:	f7ff fee0 	bl	800a48e <LL_APB1_GRP1_EnableClock>
    HAL_NVIC_SetPriority(I2C3_EV_IRQn, 5, 0);
 800a6ce:	2200      	movs	r2, #0
 800a6d0:	2105      	movs	r1, #5
 800a6d2:	2020      	movs	r0, #32
 800a6d4:	f003 f9b2 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C3_EV_IRQn);
 800a6d8:	2020      	movs	r0, #32
 800a6da:	f003 f9c9 	bl	800da70 <HAL_NVIC_EnableIRQ>
}
 800a6de:	bf00      	nop
 800a6e0:	3770      	adds	r7, #112	; 0x70
 800a6e2:	46bd      	mov	sp, r7
 800a6e4:	bd80      	pop	{r7, pc}
 800a6e6:	bf00      	nop
 800a6e8:	40005400 	.word	0x40005400
 800a6ec:	48000400 	.word	0x48000400
 800a6f0:	40005c00 	.word	0x40005c00
 800a6f4:	48000800 	.word	0x48000800

0800a6f8 <_ZN17Adafruit_ICM20948D1Ev>:
 *            the ST ICM2948 9-DoF Accelerometer, gyro, and magnetometer
 */
class Adafruit_ICM20948: public Adafruit_ICM20X {
public:
	Adafruit_ICM20948();
	~Adafruit_ICM20948() {
 800a6f8:	b580      	push	{r7, lr}
 800a6fa:	b082      	sub	sp, #8
 800a6fc:	af00      	add	r7, sp, #0
 800a6fe:	6078      	str	r0, [r7, #4]
 800a700:	4a05      	ldr	r2, [pc, #20]	; (800a718 <_ZN17Adafruit_ICM20948D1Ev+0x20>)
 800a702:	687b      	ldr	r3, [r7, #4]
 800a704:	601a      	str	r2, [r3, #0]
 800a706:	687b      	ldr	r3, [r7, #4]
 800a708:	4618      	mov	r0, r3
 800a70a:	f015 fd81 	bl	8020210 <_ZN15Adafruit_ICM20XD1Ev>
	}
 800a70e:	687b      	ldr	r3, [r7, #4]
 800a710:	4618      	mov	r0, r3
 800a712:	3708      	adds	r7, #8
 800a714:	46bd      	mov	sp, r7
 800a716:	bd80      	pop	{r7, pc}
 800a718:	0802cb40 	.word	0x0802cb40

0800a71c <HAL_GPIO_EXTI_Callback>:

static void triggerIMUSample(void *argument) {
	osThreadFlagsSet(imuTaskHandle, GRAB_SAMPLE_BIT);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
 800a71c:	b480      	push	{r7}
 800a71e:	b083      	sub	sp, #12
 800a720:	af00      	add	r7, sp, #0
 800a722:	4603      	mov	r3, r0
 800a724:	80fb      	strh	r3, [r7, #6]
//	if(GPIO_Pin == IMU_INT_Pin) triggerIMUSample(NULL);
}
 800a726:	bf00      	nop
 800a728:	370c      	adds	r7, #12
 800a72a:	46bd      	mov	sp, r7
 800a72c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a730:	4770      	bx	lr
	...

0800a734 <_Z41__static_initialization_and_destruction_0ii>:
 800a734:	b580      	push	{r7, lr}
 800a736:	b082      	sub	sp, #8
 800a738:	af00      	add	r7, sp, #0
 800a73a:	6078      	str	r0, [r7, #4]
 800a73c:	6039      	str	r1, [r7, #0]
 800a73e:	687b      	ldr	r3, [r7, #4]
 800a740:	2b01      	cmp	r3, #1
 800a742:	d107      	bne.n	800a754 <_Z41__static_initialization_and_destruction_0ii+0x20>
 800a744:	683b      	ldr	r3, [r7, #0]
 800a746:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a74a:	4293      	cmp	r3, r2
 800a74c:	d102      	bne.n	800a754 <_Z41__static_initialization_and_destruction_0ii+0x20>
Adafruit_ICM20948 imu;
 800a74e:	4809      	ldr	r0, [pc, #36]	; (800a774 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800a750:	f015 fb72 	bl	801fe38 <_ZN17Adafruit_ICM20948C1Ev>
 800a754:	687b      	ldr	r3, [r7, #4]
 800a756:	2b00      	cmp	r3, #0
 800a758:	d107      	bne.n	800a76a <_Z41__static_initialization_and_destruction_0ii+0x36>
 800a75a:	683b      	ldr	r3, [r7, #0]
 800a75c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800a760:	4293      	cmp	r3, r2
 800a762:	d102      	bne.n	800a76a <_Z41__static_initialization_and_destruction_0ii+0x36>
 800a764:	4803      	ldr	r0, [pc, #12]	; (800a774 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800a766:	f7ff ffc7 	bl	800a6f8 <_ZN17Adafruit_ICM20948D1Ev>
}
 800a76a:	bf00      	nop
 800a76c:	3708      	adds	r7, #8
 800a76e:	46bd      	mov	sp, r7
 800a770:	bd80      	pop	{r7, pc}
 800a772:	bf00      	nop
 800a774:	200011b0 	.word	0x200011b0

0800a778 <_GLOBAL__sub_I_periodicIMUTimer_id>:
 800a778:	b580      	push	{r7, lr}
 800a77a:	af00      	add	r7, sp, #0
 800a77c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800a780:	2001      	movs	r0, #1
 800a782:	f7ff ffd7 	bl	800a734 <_Z41__static_initialization_and_destruction_0ii>
 800a786:	bd80      	pop	{r7, pc}

0800a788 <_GLOBAL__sub_D_periodicIMUTimer_id>:
 800a788:	b580      	push	{r7, lr}
 800a78a:	af00      	add	r7, sp, #0
 800a78c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800a790:	2000      	movs	r0, #0
 800a792:	f7ff ffcf 	bl	800a734 <_Z41__static_initialization_and_destruction_0ii>
 800a796:	bd80      	pop	{r7, pc}

0800a798 <LL_AHB3_GRP1_EnableClock>:
{
 800a798:	b480      	push	{r7}
 800a79a:	b085      	sub	sp, #20
 800a79c:	af00      	add	r7, sp, #0
 800a79e:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 800a7a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a7a4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a7a6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800a7aa:	687b      	ldr	r3, [r7, #4]
 800a7ac:	4313      	orrs	r3, r2
 800a7ae:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800a7b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800a7b4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a7b6:	687b      	ldr	r3, [r7, #4]
 800a7b8:	4013      	ands	r3, r2
 800a7ba:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800a7bc:	68fb      	ldr	r3, [r7, #12]
}
 800a7be:	bf00      	nop
 800a7c0:	3714      	adds	r7, #20
 800a7c2:	46bd      	mov	sp, r7
 800a7c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a7c8:	4770      	bx	lr
	...

0800a7cc <MX_IPCC_Init>:

IPCC_HandleTypeDef hipcc;

/* IPCC init function */
void MX_IPCC_Init(void)
{
 800a7cc:	b580      	push	{r7, lr}
 800a7ce:	af00      	add	r7, sp, #0
  /* USER CODE END IPCC_Init 0 */

  /* USER CODE BEGIN IPCC_Init 1 */

  /* USER CODE END IPCC_Init 1 */
  hipcc.Instance = IPCC;
 800a7d0:	4b06      	ldr	r3, [pc, #24]	; (800a7ec <MX_IPCC_Init+0x20>)
 800a7d2:	4a07      	ldr	r2, [pc, #28]	; (800a7f0 <MX_IPCC_Init+0x24>)
 800a7d4:	601a      	str	r2, [r3, #0]
  if (HAL_IPCC_Init(&hipcc) != HAL_OK)
 800a7d6:	4805      	ldr	r0, [pc, #20]	; (800a7ec <MX_IPCC_Init+0x20>)
 800a7d8:	f004 fd32 	bl	800f240 <HAL_IPCC_Init>
 800a7dc:	4603      	mov	r3, r0
 800a7de:	2b00      	cmp	r3, #0
 800a7e0:	d001      	beq.n	800a7e6 <MX_IPCC_Init+0x1a>
  {
    Error_Handler();
 800a7e2:	f000 fb83 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN IPCC_Init 2 */

  /* USER CODE END IPCC_Init 2 */

}
 800a7e6:	bf00      	nop
 800a7e8:	bd80      	pop	{r7, pc}
 800a7ea:	bf00      	nop
 800a7ec:	20011ff4 	.word	0x20011ff4
 800a7f0:	58000c00 	.word	0x58000c00

0800a7f4 <HAL_IPCC_MspInit>:

void HAL_IPCC_MspInit(IPCC_HandleTypeDef* ipccHandle)
{
 800a7f4:	b580      	push	{r7, lr}
 800a7f6:	b082      	sub	sp, #8
 800a7f8:	af00      	add	r7, sp, #0
 800a7fa:	6078      	str	r0, [r7, #4]

  if(ipccHandle->Instance==IPCC)
 800a7fc:	687b      	ldr	r3, [r7, #4]
 800a7fe:	681b      	ldr	r3, [r3, #0]
 800a800:	4a0d      	ldr	r2, [pc, #52]	; (800a838 <HAL_IPCC_MspInit+0x44>)
 800a802:	4293      	cmp	r3, r2
 800a804:	d113      	bne.n	800a82e <HAL_IPCC_MspInit+0x3a>
  {
  /* USER CODE BEGIN IPCC_MspInit 0 */

  /* USER CODE END IPCC_MspInit 0 */
    /* IPCC clock enable */
    __HAL_RCC_IPCC_CLK_ENABLE();
 800a806:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800a80a:	f7ff ffc5 	bl	800a798 <LL_AHB3_GRP1_EnableClock>

    /* IPCC interrupt Init */
    HAL_NVIC_SetPriority(IPCC_C1_RX_IRQn, 5, 0);
 800a80e:	2200      	movs	r2, #0
 800a810:	2105      	movs	r1, #5
 800a812:	202c      	movs	r0, #44	; 0x2c
 800a814:	f003 f912 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 800a818:	202c      	movs	r0, #44	; 0x2c
 800a81a:	f003 f929 	bl	800da70 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(IPCC_C1_TX_IRQn, 5, 0);
 800a81e:	2200      	movs	r2, #0
 800a820:	2105      	movs	r1, #5
 800a822:	202d      	movs	r0, #45	; 0x2d
 800a824:	f003 f90a 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 800a828:	202d      	movs	r0, #45	; 0x2d
 800a82a:	f003 f921 	bl	800da70 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN IPCC_MspInit 1 */

  /* USER CODE END IPCC_MspInit 1 */
  }
}
 800a82e:	bf00      	nop
 800a830:	3708      	adds	r7, #8
 800a832:	46bd      	mov	sp, r7
 800a834:	bd80      	pop	{r7, pc}
 800a836:	bf00      	nop
 800a838:	58000c00 	.word	0x58000c00

0800a83c <setup_LP5523>:
		LOG_EN, LOG_EN, LOG_EN, LOG_EN };
uint8_t deviceAddress;
uint8_t led_PWM[9] = { 0 };
uint8_t packet;

void setup_LP5523(uint8_t ADDR) {
 800a83c:	b580      	push	{r7, lr}
 800a83e:	b086      	sub	sp, #24
 800a840:	af04      	add	r7, sp, #16
 800a842:	4603      	mov	r3, r0
 800a844:	71fb      	strb	r3, [r7, #7]

#ifndef DONGLE_CODE
	deviceAddress = ADDR << 1;
 800a846:	79fb      	ldrb	r3, [r7, #7]
 800a848:	005b      	lsls	r3, r3, #1
 800a84a:	b2da      	uxtb	r2, r3
 800a84c:	4b2e      	ldr	r3, [pc, #184]	; (800a908 <setup_LP5523+0xcc>)
 800a84e:	701a      	strb	r2, [r3, #0]

	// enable chip
	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800a850:	4b2e      	ldr	r3, [pc, #184]	; (800a90c <setup_LP5523+0xd0>)
 800a852:	681b      	ldr	r3, [r3, #0]
 800a854:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a858:	4618      	mov	r0, r3
 800a85a:	f018 fa6d 	bl	8022d38 <osSemaphoreAcquire>
	packet = LP5525_CHIP_EN;
 800a85e:	4b2c      	ldr	r3, [pc, #176]	; (800a910 <setup_LP5523+0xd4>)
 800a860:	2240      	movs	r2, #64	; 0x40
 800a862:	701a      	strb	r2, [r3, #0]
//	while(HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_EN_CNTRL1_REG, 1, &packet, 1, I2C_TIMEOUT) != HAL_OK);
	HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_EN_CNTRL1_REG,
 800a864:	4b28      	ldr	r3, [pc, #160]	; (800a908 <setup_LP5523+0xcc>)
 800a866:	781b      	ldrb	r3, [r3, #0]
 800a868:	b299      	uxth	r1, r3
 800a86a:	230a      	movs	r3, #10
 800a86c:	9302      	str	r3, [sp, #8]
 800a86e:	2301      	movs	r3, #1
 800a870:	9301      	str	r3, [sp, #4]
 800a872:	4b27      	ldr	r3, [pc, #156]	; (800a910 <setup_LP5523+0xd4>)
 800a874:	9300      	str	r3, [sp, #0]
 800a876:	2301      	movs	r3, #1
 800a878:	2200      	movs	r2, #0
 800a87a:	4826      	ldr	r0, [pc, #152]	; (800a914 <setup_LP5523+0xd8>)
 800a87c:	f003 ff2a 	bl	800e6d4 <HAL_I2C_Mem_Write>
			1, &packet, 1, I2C_TIMEOUT);

	// put charge-pump in auto-mode, serial auto increment, internal clock
	packet = CP_MODE_AUTO | EN_AUTO_INC | INT_CLK_EN;
 800a880:	4b23      	ldr	r3, [pc, #140]	; (800a910 <setup_LP5523+0xd4>)
 800a882:	224f      	movs	r2, #79	; 0x4f
 800a884:	701a      	strb	r2, [r3, #0]
//	while(HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_MISC_REG, 1, &packet, 1, I2C_TIMEOUT) != HAL_OK);
	HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_MISC_REG, 1,
 800a886:	4b20      	ldr	r3, [pc, #128]	; (800a908 <setup_LP5523+0xcc>)
 800a888:	781b      	ldrb	r3, [r3, #0]
 800a88a:	b299      	uxth	r1, r3
 800a88c:	230a      	movs	r3, #10
 800a88e:	9302      	str	r3, [sp, #8]
 800a890:	2301      	movs	r3, #1
 800a892:	9301      	str	r3, [sp, #4]
 800a894:	4b1e      	ldr	r3, [pc, #120]	; (800a910 <setup_LP5523+0xd4>)
 800a896:	9300      	str	r3, [sp, #0]
 800a898:	2301      	movs	r3, #1
 800a89a:	2236      	movs	r2, #54	; 0x36
 800a89c:	481d      	ldr	r0, [pc, #116]	; (800a914 <setup_LP5523+0xd8>)
 800a89e:	f003 ff19 	bl	800e6d4 <HAL_I2C_Mem_Write>
			&packet, 1, I2C_TIMEOUT);

	// set PWM level (0 to 255)
//	while(HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_D1_PWM_REG, 1, led_PWM, 9, I2C_TIMEOUT) != HAL_OK);
	HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_D1_PWM_REG, 1,
 800a8a2:	4b19      	ldr	r3, [pc, #100]	; (800a908 <setup_LP5523+0xcc>)
 800a8a4:	781b      	ldrb	r3, [r3, #0]
 800a8a6:	b299      	uxth	r1, r3
 800a8a8:	230a      	movs	r3, #10
 800a8aa:	9302      	str	r3, [sp, #8]
 800a8ac:	2309      	movs	r3, #9
 800a8ae:	9301      	str	r3, [sp, #4]
 800a8b0:	4b19      	ldr	r3, [pc, #100]	; (800a918 <setup_LP5523+0xdc>)
 800a8b2:	9300      	str	r3, [sp, #0]
 800a8b4:	2301      	movs	r3, #1
 800a8b6:	2216      	movs	r2, #22
 800a8b8:	4816      	ldr	r0, [pc, #88]	; (800a914 <setup_LP5523+0xd8>)
 800a8ba:	f003 ff0b 	bl	800e6d4 <HAL_I2C_Mem_Write>
			led_PWM, 9, I2C_TIMEOUT);

	// set current control (0 to 25.5 mA) - step size is 100uA
//	while(HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_D1_CURRENT_CTRL_REG, 1, led_current, 9, I2C_TIMEOUT) != HAL_OK);
	HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress,
 800a8be:	4b12      	ldr	r3, [pc, #72]	; (800a908 <setup_LP5523+0xcc>)
 800a8c0:	781b      	ldrb	r3, [r3, #0]
 800a8c2:	b299      	uxth	r1, r3
 800a8c4:	230a      	movs	r3, #10
 800a8c6:	9302      	str	r3, [sp, #8]
 800a8c8:	2309      	movs	r3, #9
 800a8ca:	9301      	str	r3, [sp, #4]
 800a8cc:	4b13      	ldr	r3, [pc, #76]	; (800a91c <setup_LP5523+0xe0>)
 800a8ce:	9300      	str	r3, [sp, #0]
 800a8d0:	2301      	movs	r3, #1
 800a8d2:	2226      	movs	r2, #38	; 0x26
 800a8d4:	480f      	ldr	r0, [pc, #60]	; (800a914 <setup_LP5523+0xd8>)
 800a8d6:	f003 fefd 	bl	800e6d4 <HAL_I2C_Mem_Write>
			LIS3DH_D1_CURRENT_CTRL_REG, 1, led_current, 9, I2C_TIMEOUT);

	// enable logarithmic dimming
//	packet = LOG_EN;
//	while(HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_D1_CNTRL_REG, 1, packet_array, 9, I2C_TIMEOUT) != HAL_OK);
	HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, deviceAddress, LIS3DH_D1_CNTRL_REG, 1,
 800a8da:	4b0b      	ldr	r3, [pc, #44]	; (800a908 <setup_LP5523+0xcc>)
 800a8dc:	781b      	ldrb	r3, [r3, #0]
 800a8de:	b299      	uxth	r1, r3
 800a8e0:	230a      	movs	r3, #10
 800a8e2:	9302      	str	r3, [sp, #8]
 800a8e4:	2309      	movs	r3, #9
 800a8e6:	9301      	str	r3, [sp, #4]
 800a8e8:	4b0d      	ldr	r3, [pc, #52]	; (800a920 <setup_LP5523+0xe4>)
 800a8ea:	9300      	str	r3, [sp, #0]
 800a8ec:	2301      	movs	r3, #1
 800a8ee:	2206      	movs	r2, #6
 800a8f0:	4808      	ldr	r0, [pc, #32]	; (800a914 <setup_LP5523+0xd8>)
 800a8f2:	f003 feef 	bl	800e6d4 <HAL_I2C_Mem_Write>
			packet_array, 9, I2C_TIMEOUT);

	osSemaphoreRelease(messageI2C1_LockHandle);
 800a8f6:	4b05      	ldr	r3, [pc, #20]	; (800a90c <setup_LP5523+0xd0>)
 800a8f8:	681b      	ldr	r3, [r3, #0]
 800a8fa:	4618      	mov	r0, r3
 800a8fc:	f018 fa6e 	bl	8022ddc <osSemaphoreRelease>
#else
	BSP_LED_Init(LED_BLUE);
	BSP_LED_Init(LED_GREEN);
	BSP_LED_Init(LED_RED);
#endif
}
 800a900:	bf00      	nop
 800a902:	3708      	adds	r7, #8
 800a904:	46bd      	mov	sp, r7
 800a906:	bd80      	pop	{r7, pc}
 800a908:	20012046 	.word	0x20012046
 800a90c:	200003dc 	.word	0x200003dc
 800a910:	20012030 	.word	0x20012030
 800a914:	20011fa8 	.word	0x20011fa8
 800a918:	20001238 	.word	0x20001238
 800a91c:	20000004 	.word	0x20000004
 800a920:	0802ca20 	.word	0x0802ca20

0800a924 <ThreadFrontLightsComplexTask>:
	    	}
#endif
}

union ColorComplex receivedColors;
void ThreadFrontLightsComplexTask(void *argument){
 800a924:	b580      	push	{r7, lr}
 800a926:	b088      	sub	sp, #32
 800a928:	af04      	add	r7, sp, #16
 800a92a:	6078      	str	r0, [r7, #4]

	osDelay(500);
 800a92c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800a930:	f017 ff5b 	bl	80227ea <osDelay>

	setup_LP5523(LIS3DH_LEFT_ADDRESS);
 800a934:	2034      	movs	r0, #52	; 0x34
 800a936:	f7ff ff81 	bl	800a83c <setup_LP5523>
	setup_LP5523(LIS3DH_RIGHT_ADDRESS);
 800a93a:	2035      	movs	r0, #53	; 0x35
 800a93c:	f7ff ff7e 	bl	800a83c <setup_LP5523>

	HAL_StatusTypeDef state = 0;
 800a940:	2300      	movs	r3, #0
 800a942:	73fb      	strb	r3, [r7, #15]



	while (1) {
		osMessageQueueGet(lightsComplexQueueHandle, &receivedColors,
 800a944:	4b1f      	ldr	r3, [pc, #124]	; (800a9c4 <ThreadFrontLightsComplexTask+0xa0>)
 800a946:	6818      	ldr	r0, [r3, #0]
 800a948:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a94c:	2200      	movs	r2, #0
 800a94e:	491e      	ldr	r1, [pc, #120]	; (800a9c8 <ThreadFrontLightsComplexTask+0xa4>)
 800a950:	f018 fb5c 	bl	802300c <osMessageQueueGet>
						0U, osWaitForever);
		memcpy(led_left_PWM, &receivedColors, 9);
 800a954:	4b1d      	ldr	r3, [pc, #116]	; (800a9cc <ThreadFrontLightsComplexTask+0xa8>)
 800a956:	4a1c      	ldr	r2, [pc, #112]	; (800a9c8 <ThreadFrontLightsComplexTask+0xa4>)
 800a958:	6810      	ldr	r0, [r2, #0]
 800a95a:	6851      	ldr	r1, [r2, #4]
 800a95c:	c303      	stmia	r3!, {r0, r1}
 800a95e:	7a12      	ldrb	r2, [r2, #8]
 800a960:	701a      	strb	r2, [r3, #0]
		memcpy(led_right_PWM, &(receivedColors.color[9]), 9);
 800a962:	4b1b      	ldr	r3, [pc, #108]	; (800a9d0 <ThreadFrontLightsComplexTask+0xac>)
 800a964:	4a18      	ldr	r2, [pc, #96]	; (800a9c8 <ThreadFrontLightsComplexTask+0xa4>)
 800a966:	3209      	adds	r2, #9
 800a968:	6810      	ldr	r0, [r2, #0]
 800a96a:	6851      	ldr	r1, [r2, #4]
 800a96c:	c303      	stmia	r3!, {r0, r1}
 800a96e:	7a12      	ldrb	r2, [r2, #8]
 800a970:	701a      	strb	r2, [r3, #0]
	#ifndef DONGLE_CODE
		osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800a972:	4b18      	ldr	r3, [pc, #96]	; (800a9d4 <ThreadFrontLightsComplexTask+0xb0>)
 800a974:	681b      	ldr	r3, [r3, #0]
 800a976:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a97a:	4618      	mov	r0, r3
 800a97c:	f018 f9dc 	bl	8022d38 <osSemaphoreAcquire>

//		HAL_I2C_Mem_Write_DMA(I2C_HANDLE_TYPEDEF, LIS3DH_LEFT_ADDRESS << 1,
//				LIS3DH_D1_PWM_REG, 1, led_left_PWM, 9);
		state = HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, LIS3DH_LEFT_ADDRESS << 1,
 800a980:	2305      	movs	r3, #5
 800a982:	9302      	str	r3, [sp, #8]
 800a984:	2309      	movs	r3, #9
 800a986:	9301      	str	r3, [sp, #4]
 800a988:	4b10      	ldr	r3, [pc, #64]	; (800a9cc <ThreadFrontLightsComplexTask+0xa8>)
 800a98a:	9300      	str	r3, [sp, #0]
 800a98c:	2301      	movs	r3, #1
 800a98e:	2216      	movs	r2, #22
 800a990:	2168      	movs	r1, #104	; 0x68
 800a992:	4811      	ldr	r0, [pc, #68]	; (800a9d8 <ThreadFrontLightsComplexTask+0xb4>)
 800a994:	f003 fe9e 	bl	800e6d4 <HAL_I2C_Mem_Write>
 800a998:	4603      	mov	r3, r0
 800a99a:	73fb      	strb	r3, [r7, #15]
////			if(counter > 1000){
////				HAL_I2C_Master_Abort_IT(I2C_HANDLE_TYPEDEF, LIS3DH_LEFT_ADDRESS << 1);
////			}
//		}

		state = HAL_I2C_Mem_Write(I2C_HANDLE_TYPEDEF, LIS3DH_RIGHT_ADDRESS << 1,
 800a99c:	2305      	movs	r3, #5
 800a99e:	9302      	str	r3, [sp, #8]
 800a9a0:	2309      	movs	r3, #9
 800a9a2:	9301      	str	r3, [sp, #4]
 800a9a4:	4b0a      	ldr	r3, [pc, #40]	; (800a9d0 <ThreadFrontLightsComplexTask+0xac>)
 800a9a6:	9300      	str	r3, [sp, #0]
 800a9a8:	2301      	movs	r3, #1
 800a9aa:	2216      	movs	r2, #22
 800a9ac:	216a      	movs	r1, #106	; 0x6a
 800a9ae:	480a      	ldr	r0, [pc, #40]	; (800a9d8 <ThreadFrontLightsComplexTask+0xb4>)
 800a9b0:	f003 fe90 	bl	800e6d4 <HAL_I2C_Mem_Write>
 800a9b4:	4603      	mov	r3, r0
 800a9b6:	73fb      	strb	r3, [r7, #15]
//			if(counter > 1000){
//				HAL_I2C_Master_Abort_IT(I2C_HANDLE_TYPEDEF, LIS3DH_LEFT_ADDRESS << 1);
//			}
//		}

		osSemaphoreRelease(messageI2C1_LockHandle);
 800a9b8:	4b06      	ldr	r3, [pc, #24]	; (800a9d4 <ThreadFrontLightsComplexTask+0xb0>)
 800a9ba:	681b      	ldr	r3, [r3, #0]
 800a9bc:	4618      	mov	r0, r3
 800a9be:	f018 fa0d 	bl	8022ddc <osSemaphoreRelease>
		osMessageQueueGet(lightsComplexQueueHandle, &receivedColors,
 800a9c2:	e7bf      	b.n	800a944 <ThreadFrontLightsComplexTask+0x20>
 800a9c4:	200003b4 	.word	0x200003b4
 800a9c8:	20012034 	.word	0x20012034
 800a9cc:	20001220 	.word	0x20001220
 800a9d0:	2000122c 	.word	0x2000122c
 800a9d4:	200003dc 	.word	0x200003dc
 800a9d8:	20011fa8 	.word	0x20011fa8

0800a9dc <ledDisconnectNotification>:
//	FrontLightsSet(&receivedColor);

	ledDisconnectNotification();
}

void ledDisconnectNotification(void){
 800a9dc:	b580      	push	{r7, lr}
 800a9de:	af00      	add	r7, sp, #0
	resetColor(&receivedColor);
 800a9e0:	480d      	ldr	r0, [pc, #52]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800a9e2:	f000 f84d 	bl	800aa80 <resetColor>

	receivedColor.colors_indiv.left_side_g = 0;
 800a9e6:	4b0c      	ldr	r3, [pc, #48]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800a9e8:	2200      	movs	r2, #0
 800a9ea:	715a      	strb	r2, [r3, #5]
	receivedColor.colors_indiv.right_side_g = 0;
 800a9ec:	4b0a      	ldr	r3, [pc, #40]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800a9ee:	2200      	movs	r2, #0
 800a9f0:	739a      	strb	r2, [r3, #14]
	receivedColor.colors_indiv.left_side_b = 50;
 800a9f2:	4b09      	ldr	r3, [pc, #36]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800a9f4:	2232      	movs	r2, #50	; 0x32
 800a9f6:	711a      	strb	r2, [r3, #4]
	receivedColor.colors_indiv.right_side_b = 50;
 800a9f8:	4b07      	ldr	r3, [pc, #28]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800a9fa:	2232      	movs	r2, #50	; 0x32
 800a9fc:	735a      	strb	r2, [r3, #13]
	osMessageQueuePut(lightsComplexQueueHandle, &receivedColor, 0, 0);
 800a9fe:	4b07      	ldr	r3, [pc, #28]	; (800aa1c <ledDisconnectNotification+0x40>)
 800aa00:	6818      	ldr	r0, [r3, #0]
 800aa02:	2300      	movs	r3, #0
 800aa04:	2200      	movs	r2, #0
 800aa06:	4904      	ldr	r1, [pc, #16]	; (800aa18 <ledDisconnectNotification+0x3c>)
 800aa08:	f018 faa0 	bl	8022f4c <osMessageQueuePut>
	osDelay(10);
 800aa0c:	200a      	movs	r0, #10
 800aa0e:	f017 feec 	bl	80227ea <osDelay>
//	FrontLightsSet(&receivedColor);
}
 800aa12:	bf00      	nop
 800aa14:	bd80      	pop	{r7, pc}
 800aa16:	bf00      	nop
 800aa18:	20012048 	.word	0x20012048
 800aa1c:	200003b4 	.word	0x200003b4

0800aa20 <ledConnectNotification>:

void ledConnectNotification(void){
 800aa20:	b580      	push	{r7, lr}
 800aa22:	af00      	add	r7, sp, #0
	resetColor(&receivedColor);
 800aa24:	4814      	ldr	r0, [pc, #80]	; (800aa78 <ledConnectNotification+0x58>)
 800aa26:	f000 f82b 	bl	800aa80 <resetColor>

	receivedColor.colors_indiv.left_side_b = 0;
 800aa2a:	4b13      	ldr	r3, [pc, #76]	; (800aa78 <ledConnectNotification+0x58>)
 800aa2c:	2200      	movs	r2, #0
 800aa2e:	711a      	strb	r2, [r3, #4]
	receivedColor.colors_indiv.right_side_b = 0;
 800aa30:	4b11      	ldr	r3, [pc, #68]	; (800aa78 <ledConnectNotification+0x58>)
 800aa32:	2200      	movs	r2, #0
 800aa34:	735a      	strb	r2, [r3, #13]
	receivedColor.colors_indiv.left_side_g = 80;
 800aa36:	4b10      	ldr	r3, [pc, #64]	; (800aa78 <ledConnectNotification+0x58>)
 800aa38:	2250      	movs	r2, #80	; 0x50
 800aa3a:	715a      	strb	r2, [r3, #5]
	receivedColor.colors_indiv.right_side_g = 80;
 800aa3c:	4b0e      	ldr	r3, [pc, #56]	; (800aa78 <ledConnectNotification+0x58>)
 800aa3e:	2250      	movs	r2, #80	; 0x50
 800aa40:	739a      	strb	r2, [r3, #14]
	osMessageQueuePut(lightsComplexQueueHandle, &receivedColor, 0, 0);
 800aa42:	4b0e      	ldr	r3, [pc, #56]	; (800aa7c <ledConnectNotification+0x5c>)
 800aa44:	6818      	ldr	r0, [r3, #0]
 800aa46:	2300      	movs	r3, #0
 800aa48:	2200      	movs	r2, #0
 800aa4a:	490b      	ldr	r1, [pc, #44]	; (800aa78 <ledConnectNotification+0x58>)
 800aa4c:	f018 fa7e 	bl	8022f4c <osMessageQueuePut>
//	FrontLightsSet(&receivedColor);
	osDelay(1000);
 800aa50:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800aa54:	f017 fec9 	bl	80227ea <osDelay>
	receivedColor.colors_indiv.left_side_g = 0;
 800aa58:	4b07      	ldr	r3, [pc, #28]	; (800aa78 <ledConnectNotification+0x58>)
 800aa5a:	2200      	movs	r2, #0
 800aa5c:	715a      	strb	r2, [r3, #5]
	receivedColor.colors_indiv.right_side_g = 0;
 800aa5e:	4b06      	ldr	r3, [pc, #24]	; (800aa78 <ledConnectNotification+0x58>)
 800aa60:	2200      	movs	r2, #0
 800aa62:	739a      	strb	r2, [r3, #14]
	osMessageQueuePut(lightsComplexQueueHandle, &receivedColor, 0, 0);
 800aa64:	4b05      	ldr	r3, [pc, #20]	; (800aa7c <ledConnectNotification+0x5c>)
 800aa66:	6818      	ldr	r0, [r3, #0]
 800aa68:	2300      	movs	r3, #0
 800aa6a:	2200      	movs	r2, #0
 800aa6c:	4902      	ldr	r1, [pc, #8]	; (800aa78 <ledConnectNotification+0x58>)
 800aa6e:	f018 fa6d 	bl	8022f4c <osMessageQueuePut>
//	FrontLightsSet(&receivedColor);
}
 800aa72:	bf00      	nop
 800aa74:	bd80      	pop	{r7, pc}
 800aa76:	bf00      	nop
 800aa78:	20012048 	.word	0x20012048
 800aa7c:	200003b4 	.word	0x200003b4

0800aa80 <resetColor>:
	receivedColor.colors_indiv.left_front_r = 255;
	receivedColor.colors_indiv.right_front_r = 255;
	osMessageQueuePut(lightsComplexQueueHandle, &receivedColor, 0, 0);
}

void resetColor(union ColorComplex * colorComplex){
 800aa80:	b4b0      	push	{r4, r5, r7}
 800aa82:	b083      	sub	sp, #12
 800aa84:	af00      	add	r7, sp, #0
 800aa86:	6078      	str	r0, [r7, #4]
	memcpy(colorComplex,&EmptyColorComplex,sizeof(union ColorComplex));;
 800aa88:	687b      	ldr	r3, [r7, #4]
 800aa8a:	4a07      	ldr	r2, [pc, #28]	; (800aaa8 <resetColor+0x28>)
 800aa8c:	461d      	mov	r5, r3
 800aa8e:	4614      	mov	r4, r2
 800aa90:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800aa92:	6028      	str	r0, [r5, #0]
 800aa94:	6069      	str	r1, [r5, #4]
 800aa96:	60aa      	str	r2, [r5, #8]
 800aa98:	60eb      	str	r3, [r5, #12]
 800aa9a:	8823      	ldrh	r3, [r4, #0]
 800aa9c:	822b      	strh	r3, [r5, #16]
}
 800aa9e:	bf00      	nop
 800aaa0:	370c      	adds	r7, #12
 800aaa2:	46bd      	mov	sp, r7
 800aaa4:	bcb0      	pop	{r4, r5, r7}
 800aaa6:	4770      	bx	lr
 800aaa8:	0802ca0c 	.word	0x0802ca0c

0800aaac <LuxTask>:
//osThreadId_t specTaskHandle;
osTimerId_t periodicLuxTimer_id;

TSL2772 luxSensor;

void LuxTask(void *argument) {
 800aaac:	b590      	push	{r4, r7, lr}
 800aaae:	b089      	sub	sp, #36	; 0x24
 800aab0:	af00      	add	r7, sp, #0
 800aab2:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 800aab4:	2300      	movs	r3, #0
 800aab6:	617b      	str	r3, [r7, #20]
	uint32_t flags;
	uint32_t timeLeftForSample = 0;
 800aab8:	2300      	movs	r3, #0
 800aaba:	613b      	str	r3, [r7, #16]

	osSemaphoreAcquire(messageI2C3_LockHandle, osWaitForever);
 800aabc:	4b56      	ldr	r3, [pc, #344]	; (800ac18 <LuxTask+0x16c>)
 800aabe:	681b      	ldr	r3, [r3, #0]
 800aac0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800aac4:	4618      	mov	r0, r3
 800aac6:	f018 f937 	bl	8022d38 <osSemaphoreAcquire>
	if (!luxSensor.begin(TSL2772_I2CADDR, &hi2c3)) {
 800aaca:	4a54      	ldr	r2, [pc, #336]	; (800ac1c <LuxTask+0x170>)
 800aacc:	2139      	movs	r1, #57	; 0x39
 800aace:	4854      	ldr	r0, [pc, #336]	; (800ac20 <LuxTask+0x174>)
 800aad0:	f016 ffc5 	bl	8021a5e <_ZN7TSL27725beginEhP19__I2C_HandleTypeDef>
 800aad4:	4603      	mov	r3, r0
 800aad6:	f083 0301 	eor.w	r3, r3, #1
 800aada:	b2db      	uxtb	r3, r3
 800aadc:	2b00      	cmp	r3, #0
 800aade:	d002      	beq.n	800aae6 <LuxTask+0x3a>
		osDelay(100);
 800aae0:	2064      	movs	r0, #100	; 0x64
 800aae2:	f017 fe82 	bl	80227ea <osDelay>
	}
	luxSensor.powerOn(true);
 800aae6:	2101      	movs	r1, #1
 800aae8:	484d      	ldr	r0, [pc, #308]	; (800ac20 <LuxTask+0x174>)
 800aaea:	f017 f815 	bl	8021b18 <_ZN7TSL27727powerOnEb>

	luxSensor.setATIME(TSL2722_INTEGRATIONTIME_101MS);
 800aaee:	21db      	movs	r1, #219	; 0xdb
 800aaf0:	484b      	ldr	r0, [pc, #300]	; (800ac20 <LuxTask+0x174>)
 800aaf2:	f017 f833 	bl	8021b5c <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t>
	luxSensor.setAGAIN(TSL2722_GAIN_8X);
 800aaf6:	2101      	movs	r1, #1
 800aaf8:	4849      	ldr	r0, [pc, #292]	; (800ac20 <LuxTask+0x174>)
 800aafa:	f017 f879 	bl	8021bf0 <_ZN7TSL27728setAGAINE13tsl2591Gain_t>

	luxSensor.enableALS(true);
 800aafe:	2101      	movs	r1, #1
 800ab00:	4847      	ldr	r0, [pc, #284]	; (800ac20 <LuxTask+0x174>)
 800ab02:	f016 ffe8 	bl	8021ad6 <_ZN7TSL27729enableALSEb>

	header.payloadLength = MAX_LUX_SAMPLES_PACKET * sizeof(luxSample);
 800ab06:	4b47      	ldr	r3, [pc, #284]	; (800ac24 <LuxTask+0x178>)
 800ab08:	2208      	movs	r2, #8
 800ab0a:	60da      	str	r2, [r3, #12]
	header.reserved[0] = (uint8_t) TSL2722_INTEGRATIONTIME_101MS;
 800ab0c:	4b45      	ldr	r3, [pc, #276]	; (800ac24 <LuxTask+0x178>)
 800ab0e:	22db      	movs	r2, #219	; 0xdb
 800ab10:	611a      	str	r2, [r3, #16]
	header.reserved[1] = (uint8_t) TSL2722_GAIN_8X;
 800ab12:	4b44      	ldr	r3, [pc, #272]	; (800ac24 <LuxTask+0x178>)
 800ab14:	2201      	movs	r2, #1
 800ab16:	615a      	str	r2, [r3, #20]

	uint16_t luxIdx = 0;
 800ab18:	2300      	movs	r3, #0
 800ab1a:	83fb      	strh	r3, [r7, #30]
	uint32_t luxID = 0;
 800ab1c:	2300      	movs	r3, #0
 800ab1e:	61bb      	str	r3, [r7, #24]

	uint32_t luxSample;

	osSemaphoreRelease(messageI2C3_LockHandle);
 800ab20:	4b3d      	ldr	r3, [pc, #244]	; (800ac18 <LuxTask+0x16c>)
 800ab22:	681b      	ldr	r3, [r3, #0]
 800ab24:	4618      	mov	r0, r3
 800ab26:	f018 f959 	bl	8022ddc <osSemaphoreRelease>
	periodicLuxTimer_id = osTimerNew(triggerLuxSample, osTimerPeriodic,
 800ab2a:	2300      	movs	r3, #0
 800ab2c:	2200      	movs	r2, #0
 800ab2e:	2101      	movs	r1, #1
 800ab30:	483d      	ldr	r0, [pc, #244]	; (800ac28 <LuxTask+0x17c>)
 800ab32:	f017 fe8b 	bl	802284c <osTimerNew>
 800ab36:	4603      	mov	r3, r0
 800ab38:	4a3c      	ldr	r2, [pc, #240]	; (800ac2c <LuxTask+0x180>)
 800ab3a:	6013      	str	r3, [r2, #0]
			NULL, NULL);
	osTimerStart(periodicLuxTimer_id, LUX_SAMPLE_SYS_PERIOD_MS);
 800ab3c:	4b3b      	ldr	r3, [pc, #236]	; (800ac2c <LuxTask+0x180>)
 800ab3e:	681b      	ldr	r3, [r3, #0]
 800ab40:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800ab44:	4618      	mov	r0, r3
 800ab46:	f017 fefd 	bl	8022944 <osTimerStart>

	while (1) {
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800ab4a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ab4e:	2100      	movs	r1, #0
 800ab50:	f44f 7040 	mov.w	r0, #768	; 0x300
 800ab54:	f017 fdc8 	bl	80226e8 <osThreadFlagsWait>
 800ab58:	60f8      	str	r0, [r7, #12]
		osFlagsWaitAny, osWaitForever);

		if ((flags & GRAB_SAMPLE_BIT) == GRAB_SAMPLE_BIT) {
 800ab5a:	68fb      	ldr	r3, [r7, #12]
 800ab5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ab60:	2b00      	cmp	r3, #0
 800ab62:	d049      	beq.n	800abf8 <LuxTask+0x14c>
//			timeLeftForSample = HAL_GetTick() - timeLeftForSample;
//			if(timeLeftForSample < LUX_SAMPLE_SYS_PERIOD_MS){
//				osDelay(timeLeftForSample);
//			}

			osSemaphoreAcquire(messageI2C3_LockHandle, osWaitForever);
 800ab64:	4b2c      	ldr	r3, [pc, #176]	; (800ac18 <LuxTask+0x16c>)
 800ab66:	681b      	ldr	r3, [r3, #0]
 800ab68:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800ab6c:	4618      	mov	r0, r3
 800ab6e:	f018 f8e3 	bl	8022d38 <osSemaphoreAcquire>
			luxData[luxIdx].lux = luxSensor.getLux();
 800ab72:	8bfc      	ldrh	r4, [r7, #30]
 800ab74:	482a      	ldr	r0, [pc, #168]	; (800ac20 <LuxTask+0x174>)
 800ab76:	f017 f89f 	bl	8021cb8 <_ZN7TSL27726getLuxEv>
 800ab7a:	4603      	mov	r3, r0
 800ab7c:	4a2c      	ldr	r2, [pc, #176]	; (800ac30 <LuxTask+0x184>)
 800ab7e:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
			luxData[luxIdx].timestamp = HAL_GetTick();
 800ab82:	8bfc      	ldrh	r4, [r7, #30]
 800ab84:	f001 ff80 	bl	800ca88 <HAL_GetTick>
 800ab88:	4602      	mov	r2, r0
 800ab8a:	4929      	ldr	r1, [pc, #164]	; (800ac30 <LuxTask+0x184>)
 800ab8c:	00e3      	lsls	r3, r4, #3
 800ab8e:	440b      	add	r3, r1
 800ab90:	605a      	str	r2, [r3, #4]
			osSemaphoreRelease(messageI2C3_LockHandle);
 800ab92:	4b21      	ldr	r3, [pc, #132]	; (800ac18 <LuxTask+0x16c>)
 800ab94:	681b      	ldr	r3, [r3, #0]
 800ab96:	4618      	mov	r0, r3
 800ab98:	f018 f920 	bl	8022ddc <osSemaphoreRelease>

			luxIdx++;
 800ab9c:	8bfb      	ldrh	r3, [r7, #30]
 800ab9e:	3301      	adds	r3, #1
 800aba0:	83fb      	strh	r3, [r7, #30]

			if (luxIdx >= MAX_LUX_SAMPLES_PACKET) {
 800aba2:	8bfb      	ldrh	r3, [r7, #30]
 800aba4:	2b00      	cmp	r3, #0
 800aba6:	d027      	beq.n	800abf8 <LuxTask+0x14c>
				header.packetType = LUX;
 800aba8:	4b1e      	ldr	r3, [pc, #120]	; (800ac24 <LuxTask+0x178>)
 800abaa:	2208      	movs	r2, #8
 800abac:	701a      	strb	r2, [r3, #0]
				header.packetID = luxID;
 800abae:	69bb      	ldr	r3, [r7, #24]
 800abb0:	b29a      	uxth	r2, r3
 800abb2:	4b1c      	ldr	r3, [pc, #112]	; (800ac24 <LuxTask+0x178>)
 800abb4:	805a      	strh	r2, [r3, #2]
				header.msFromStart = HAL_GetTick();
 800abb6:	f001 ff67 	bl	800ca88 <HAL_GetTick>
 800abba:	4603      	mov	r3, r0
 800abbc:	4a19      	ldr	r2, [pc, #100]	; (800ac24 <LuxTask+0x178>)
 800abbe:	6053      	str	r3, [r2, #4]
				packet = grabPacket();
 800abc0:	f000 f99a 	bl	800aef8 <grabPacket>
 800abc4:	6178      	str	r0, [r7, #20]
				if (packet != NULL) {
 800abc6:	697b      	ldr	r3, [r7, #20]
 800abc8:	2b00      	cmp	r3, #0
 800abca:	d010      	beq.n	800abee <LuxTask+0x142>
					memcpy(&(packet->header), &header, sizeof(PacketHeader));
 800abcc:	697b      	ldr	r3, [r7, #20]
 800abce:	2224      	movs	r2, #36	; 0x24
 800abd0:	4914      	ldr	r1, [pc, #80]	; (800ac24 <LuxTask+0x178>)
 800abd2:	4618      	mov	r0, r3
 800abd4:	f021 fa84 	bl	802c0e0 <memcpy>
					memcpy(packet->payload, luxData, header.payloadLength);
 800abd8:	697b      	ldr	r3, [r7, #20]
 800abda:	3324      	adds	r3, #36	; 0x24
 800abdc:	4a11      	ldr	r2, [pc, #68]	; (800ac24 <LuxTask+0x178>)
 800abde:	68d2      	ldr	r2, [r2, #12]
 800abe0:	4913      	ldr	r1, [pc, #76]	; (800ac30 <LuxTask+0x184>)
 800abe2:	4618      	mov	r0, r3
 800abe4:	f021 fa7c 	bl	802c0e0 <memcpy>
					queueUpPacket(packet);
 800abe8:	6978      	ldr	r0, [r7, #20]
 800abea:	f000 f9a1 	bl	800af30 <queueUpPacket>
				}
				luxID++;
 800abee:	69bb      	ldr	r3, [r7, #24]
 800abf0:	3301      	adds	r3, #1
 800abf2:	61bb      	str	r3, [r7, #24]
				luxIdx = 0;
 800abf4:	2300      	movs	r3, #0
 800abf6:	83fb      	strh	r3, [r7, #30]
			}

//			timeLeftForSample = HAL_GetTick();
		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 800abf8:	68fb      	ldr	r3, [r7, #12]
 800abfa:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800abfe:	2b00      	cmp	r3, #0
 800ac00:	d0a3      	beq.n	800ab4a <LuxTask+0x9e>
			osTimerDelete(periodicLuxTimer_id);
 800ac02:	4b0a      	ldr	r3, [pc, #40]	; (800ac2c <LuxTask+0x180>)
 800ac04:	681b      	ldr	r3, [r3, #0]
 800ac06:	4618      	mov	r0, r3
 800ac08:	f017 feca 	bl	80229a0 <osTimerDelete>
			break;
 800ac0c:	bf00      	nop
		}
	}
}
 800ac0e:	bf00      	nop
 800ac10:	3724      	adds	r7, #36	; 0x24
 800ac12:	46bd      	mov	sp, r7
 800ac14:	bd90      	pop	{r4, r7, pc}
 800ac16:	bf00      	nop
 800ac18:	200003e0 	.word	0x200003e0
 800ac1c:	20011f5c 	.word	0x20011f5c
 800ac20:	20001274 	.word	0x20001274
 800ac24:	2000124c 	.word	0x2000124c
 800ac28:	0800ac35 	.word	0x0800ac35
 800ac2c:	20001270 	.word	0x20001270
 800ac30:	20001244 	.word	0x20001244

0800ac34 <_ZL16triggerLuxSamplePv>:

static void triggerLuxSample(void *argument) {
 800ac34:	b580      	push	{r7, lr}
 800ac36:	b082      	sub	sp, #8
 800ac38:	af00      	add	r7, sp, #0
 800ac3a:	6078      	str	r0, [r7, #4]
	osThreadFlagsSet(luxTaskHandle, GRAB_SAMPLE_BIT);
 800ac3c:	4b05      	ldr	r3, [pc, #20]	; (800ac54 <_ZL16triggerLuxSamplePv+0x20>)
 800ac3e:	681b      	ldr	r3, [r3, #0]
 800ac40:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ac44:	4618      	mov	r0, r3
 800ac46:	f017 fd01 	bl	802264c <osThreadFlagsSet>
}
 800ac4a:	bf00      	nop
 800ac4c:	3708      	adds	r7, #8
 800ac4e:	46bd      	mov	sp, r7
 800ac50:	bd80      	pop	{r7, pc}
 800ac52:	bf00      	nop
 800ac54:	200003bc 	.word	0x200003bc

0800ac58 <_Z41__static_initialization_and_destruction_0ii>:
 800ac58:	b580      	push	{r7, lr}
 800ac5a:	b082      	sub	sp, #8
 800ac5c:	af00      	add	r7, sp, #0
 800ac5e:	6078      	str	r0, [r7, #4]
 800ac60:	6039      	str	r1, [r7, #0]
 800ac62:	687b      	ldr	r3, [r7, #4]
 800ac64:	2b01      	cmp	r3, #1
 800ac66:	d107      	bne.n	800ac78 <_Z41__static_initialization_and_destruction_0ii+0x20>
 800ac68:	683b      	ldr	r3, [r7, #0]
 800ac6a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ac6e:	4293      	cmp	r3, r2
 800ac70:	d102      	bne.n	800ac78 <_Z41__static_initialization_and_destruction_0ii+0x20>
TSL2772 luxSensor;
 800ac72:	4809      	ldr	r0, [pc, #36]	; (800ac98 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800ac74:	f016 fec8 	bl	8021a08 <_ZN7TSL2772C1Ev>
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	2b00      	cmp	r3, #0
 800ac7c:	d107      	bne.n	800ac8e <_Z41__static_initialization_and_destruction_0ii+0x36>
 800ac7e:	683b      	ldr	r3, [r7, #0]
 800ac80:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ac84:	4293      	cmp	r3, r2
 800ac86:	d102      	bne.n	800ac8e <_Z41__static_initialization_and_destruction_0ii+0x36>
 800ac88:	4803      	ldr	r0, [pc, #12]	; (800ac98 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800ac8a:	f016 fedd 	bl	8021a48 <_ZN7TSL2772D1Ev>
}
 800ac8e:	bf00      	nop
 800ac90:	3708      	adds	r7, #8
 800ac92:	46bd      	mov	sp, r7
 800ac94:	bd80      	pop	{r7, pc}
 800ac96:	bf00      	nop
 800ac98:	20001274 	.word	0x20001274

0800ac9c <_GLOBAL__sub_I_periodicLuxTimer_id>:
 800ac9c:	b580      	push	{r7, lr}
 800ac9e:	af00      	add	r7, sp, #0
 800aca0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800aca4:	2001      	movs	r0, #1
 800aca6:	f7ff ffd7 	bl	800ac58 <_Z41__static_initialization_and_destruction_0ii>
 800acaa:	bd80      	pop	{r7, pc}

0800acac <_GLOBAL__sub_D_periodicLuxTimer_id>:
 800acac:	b580      	push	{r7, lr}
 800acae:	af00      	add	r7, sp, #0
 800acb0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800acb4:	2000      	movs	r0, #0
 800acb6:	f7ff ffcf 	bl	800ac58 <_Z41__static_initialization_and_destruction_0ii>
 800acba:	bd80      	pop	{r7, pc}

0800acbc <LL_RCC_LSE_SetDriveCapability>:
{
 800acbc:	b480      	push	{r7}
 800acbe:	b083      	sub	sp, #12
 800acc0:	af00      	add	r7, sp, #0
 800acc2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 800acc4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800acc8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800accc:	f023 0218 	bic.w	r2, r3, #24
 800acd0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800acd4:	687b      	ldr	r3, [r7, #4]
 800acd6:	4313      	orrs	r3, r2
 800acd8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 800acdc:	bf00      	nop
 800acde:	370c      	adds	r7, #12
 800ace0:	46bd      	mov	sp, r7
 800ace2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ace6:	4770      	bx	lr

0800ace8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800ace8:	b580      	push	{r7, lr}
 800acea:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800acec:	f001 fe98 	bl	800ca20 <HAL_Init>
  /* Config code for STM32_WPAN (HSE Tuning must be done before system clock configuration) */
  MX_APPE_Config();
 800acf0:	f7fd ffbc 	bl	8008c6c <MX_APPE_Config>

  /* USER CODE BEGIN Init */
  HAL_Delay(500);
 800acf4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800acf8:	f7fe f960 	bl	8008fbc <HAL_Delay>

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800acfc:	f000 f82a 	bl	800ad54 <SystemClock_Config>

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
 800ad00:	f000 f8a6 	bl	800ae50 <_Z24PeriphCommonClock_Configv>

  /* IPCC initialisation */
   MX_IPCC_Init();
 800ad04:	f7ff fd62 	bl	800a7cc <MX_IPCC_Init>
  MX_DMA_Init();
  MX_TIM2_Init();
  MX_USB_Device_Init();
  /* USER CODE BEGIN 2 */
#endif
  MX_GPIO_Init();
 800ad08:	f7fe fd48 	bl	800979c <MX_GPIO_Init>
  MX_DMA_Init();
 800ad0c:	f7fe fc33 	bl	8009576 <MX_DMA_Init>
  MX_ADC1_Init();
 800ad10:	f7fd fd64 	bl	80087dc <MX_ADC1_Init>
  MX_I2C1_Init();
 800ad14:	f7ff fbd4 	bl	800a4c0 <MX_I2C1_Init>
  MX_I2C3_Init();
 800ad18:	f7ff fc12 	bl	800a540 <MX_I2C3_Init>
  MX_RF_Init();
 800ad1c:	f000 f994 	bl	800b048 <MX_RF_Init>
  MX_RTC_Init();
 800ad20:	f000 f9c4 	bl	800b0ac <MX_RTC_Init>
  MX_SAI1_Init();
 800ad24:	f000 fa32 	bl	800b18c <MX_SAI1_Init>
  MX_SPI1_Init();
 800ad28:	f001 f812 	bl	800bd50 <MX_SPI1_Init>
  MX_SPI2_Init();
 800ad2c:	f001 f84e 	bl	800bdcc <MX_SPI2_Init>
  MX_TIM16_Init();
 800ad30:	f001 fd6c 	bl	800c80c <MX_TIM16_Init>
  MX_TIM2_Init();
 800ad34:	f001 fcf6 	bl	800c724 <MX_TIM2_Init>
  MX_USB_Device_Init();
 800ad38:	f01d fd16 	bl	8028768 <MX_USB_Device_Init>
  MX_APPE_Init();
 800ad3c:	f7fd ffa4 	bl	8008c88 <MX_APPE_Init>

  extMemInit();
 800ad40:	f7fe fc5c 	bl	80095fc <extMemInit>
//  HAL_SAI_Receive(&hsai_BlockA1, data, 500, 100);
//  while(1);
  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();  /* Call init function for freertos objects (in freertos.c) */
 800ad44:	f017 fba6 	bl	8022494 <osKernelInitialize>
  MX_FREERTOS_Init();
 800ad48:	f7fe f990 	bl	800906c <_Z16MX_FREERTOS_Initv>
  /* Start scheduler */
  osKernelStart();
 800ad4c:	f017 fbc6 	bl	80224dc <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
	while (1) {
 800ad50:	e7fe      	b.n	800ad50 <main+0x68>
	...

0800ad54 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800ad54:	b580      	push	{r7, lr}
 800ad56:	b09a      	sub	sp, #104	; 0x68
 800ad58:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800ad5a:	f107 0320 	add.w	r3, r7, #32
 800ad5e:	2248      	movs	r2, #72	; 0x48
 800ad60:	2100      	movs	r1, #0
 800ad62:	4618      	mov	r0, r3
 800ad64:	f021 f9ca 	bl	802c0fc <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800ad68:	1d3b      	adds	r3, r7, #4
 800ad6a:	2200      	movs	r2, #0
 800ad6c:	601a      	str	r2, [r3, #0]
 800ad6e:	605a      	str	r2, [r3, #4]
 800ad70:	609a      	str	r2, [r3, #8]
 800ad72:	60da      	str	r2, [r3, #12]
 800ad74:	611a      	str	r2, [r3, #16]
 800ad76:	615a      	str	r2, [r3, #20]
 800ad78:	619a      	str	r2, [r3, #24]

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 800ad7a:	f006 f81b 	bl	8010db4 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 800ad7e:	2000      	movs	r0, #0
 800ad80:	f7ff ff9c 	bl	800acbc <LL_RCC_LSE_SetDriveCapability>
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800ad84:	4b31      	ldr	r3, [pc, #196]	; (800ae4c <SystemClock_Config+0xf8>)
 800ad86:	681b      	ldr	r3, [r3, #0]
 800ad88:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 800ad8c:	4a2f      	ldr	r2, [pc, #188]	; (800ae4c <SystemClock_Config+0xf8>)
 800ad8e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ad92:	6013      	str	r3, [r2, #0]
 800ad94:	4b2d      	ldr	r3, [pc, #180]	; (800ae4c <SystemClock_Config+0xf8>)
 800ad96:	681b      	ldr	r3, [r3, #0]
 800ad98:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 800ad9c:	603b      	str	r3, [r7, #0]
 800ad9e:	683b      	ldr	r3, [r7, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE
 800ada0:	2327      	movs	r3, #39	; 0x27
 800ada2:	623b      	str	r3, [r7, #32]
                              |RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800ada4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800ada8:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800adaa:	2301      	movs	r3, #1
 800adac:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800adae:	f44f 7380 	mov.w	r3, #256	; 0x100
 800adb2:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800adb4:	2301      	movs	r3, #1
 800adb6:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800adb8:	2340      	movs	r3, #64	; 0x40
 800adba:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 800adbc:	2300      	movs	r3, #0
 800adbe:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_8;
 800adc0:	2380      	movs	r3, #128	; 0x80
 800adc2:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800adc4:	2302      	movs	r3, #2
 800adc6:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 800adc8:	2301      	movs	r3, #1
 800adca:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV2;
 800adcc:	2310      	movs	r3, #16
 800adce:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLN = 32;
 800add0:	2320      	movs	r3, #32
 800add2:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800add4:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800add8:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV4;
 800adda:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800adde:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 800ade0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800ade4:	663b      	str	r3, [r7, #96]	; 0x60
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800ade6:	f107 0320 	add.w	r3, r7, #32
 800adea:	4618      	mov	r0, r3
 800adec:	f006 fb92 	bl	8011514 <HAL_RCC_OscConfig>
 800adf0:	4603      	mov	r3, r0
 800adf2:	2b00      	cmp	r3, #0
 800adf4:	bf14      	ite	ne
 800adf6:	2301      	movne	r3, #1
 800adf8:	2300      	moveq	r3, #0
 800adfa:	b2db      	uxtb	r3, r3
 800adfc:	2b00      	cmp	r3, #0
 800adfe:	d001      	beq.n	800ae04 <SystemClock_Config+0xb0>
  {
    Error_Handler();
 800ae00:	f000 f874 	bl	800aeec <Error_Handler>
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
 800ae04:	236f      	movs	r3, #111	; 0x6f
 800ae06:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800ae08:	2303      	movs	r3, #3
 800ae0a:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800ae0c:	2300      	movs	r3, #0
 800ae0e:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800ae10:	2300      	movs	r3, #0
 800ae12:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800ae14:	2300      	movs	r3, #0
 800ae16:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV2;
 800ae18:	2380      	movs	r3, #128	; 0x80
 800ae1a:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;
 800ae1c:	2300      	movs	r3, #0
 800ae1e:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 800ae20:	1d3b      	adds	r3, r7, #4
 800ae22:	2103      	movs	r1, #3
 800ae24:	4618      	mov	r0, r3
 800ae26:	f006 ff01 	bl	8011c2c <HAL_RCC_ClockConfig>
 800ae2a:	4603      	mov	r3, r0
 800ae2c:	2b00      	cmp	r3, #0
 800ae2e:	bf14      	ite	ne
 800ae30:	2301      	movne	r3, #1
 800ae32:	2300      	moveq	r3, #0
 800ae34:	b2db      	uxtb	r3, r3
 800ae36:	2b00      	cmp	r3, #0
 800ae38:	d001      	beq.n	800ae3e <SystemClock_Config+0xea>
  {
    Error_Handler();
 800ae3a:	f000 f857 	bl	800aeec <Error_Handler>
  }
  /** Enable MSI Auto calibration
  */
  HAL_RCCEx_EnableMSIPLLMode();
 800ae3e:	f008 fadc 	bl	80133fa <HAL_RCCEx_EnableMSIPLLMode>
}
 800ae42:	bf00      	nop
 800ae44:	3768      	adds	r7, #104	; 0x68
 800ae46:	46bd      	mov	sp, r7
 800ae48:	bd80      	pop	{r7, pc}
 800ae4a:	bf00      	nop
 800ae4c:	58000400 	.word	0x58000400

0800ae50 <_Z24PeriphCommonClock_Configv>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
 800ae50:	b580      	push	{r7, lr}
 800ae52:	b094      	sub	sp, #80	; 0x50
 800ae54:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800ae56:	463b      	mov	r3, r7
 800ae58:	2250      	movs	r2, #80	; 0x50
 800ae5a:	2100      	movs	r1, #0
 800ae5c:	4618      	mov	r0, r3
 800ae5e:	f021 f94d 	bl	802c0fc <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_RFWAKEUP
 800ae62:	f44f 5355 	mov.w	r3, #13632	; 0x3540
 800ae66:	603b      	str	r3, [r7, #0]
                              |RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_USB
                              |RCC_PERIPHCLK_ADC;
  PeriphClkInitStruct.PLLSAI1.PLLN = 12;
 800ae68:	230c      	movs	r3, #12
 800ae6a:	607b      	str	r3, [r7, #4]
  PeriphClkInitStruct.PLLSAI1.PLLP = RCC_PLLP_DIV2;
 800ae6c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800ae70:	60bb      	str	r3, [r7, #8]
  PeriphClkInitStruct.PLLSAI1.PLLQ = RCC_PLLQ_DIV2;
 800ae72:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800ae76:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLLSAI1.PLLR = RCC_PLLR_DIV2;
 800ae78:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800ae7c:	613b      	str	r3, [r7, #16]
  PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK|RCC_PLLSAI1_USBCLK
 800ae7e:	4b11      	ldr	r3, [pc, #68]	; (800aec4 <_Z24PeriphCommonClock_Configv+0x74>)
 800ae80:	617b      	str	r3, [r7, #20]
                              |RCC_PLLSAI1_ADCCLK;
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
 800ae82:	2300      	movs	r3, #0
 800ae84:	633b      	str	r3, [r7, #48]	; 0x30
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 800ae86:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 800ae8a:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 800ae8c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800ae90:	63fb      	str	r3, [r7, #60]	; 0x3c
  PeriphClkInitStruct.RFWakeUpClockSelection = RCC_RFWKPCLKSOURCE_LSE;
 800ae92:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800ae96:	647b      	str	r3, [r7, #68]	; 0x44
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSI;
 800ae98:	2300      	movs	r3, #0
 800ae9a:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE1;
 800ae9c:	2310      	movs	r3, #16
 800ae9e:	64fb      	str	r3, [r7, #76]	; 0x4c

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800aea0:	463b      	mov	r3, r7
 800aea2:	4618      	mov	r0, r3
 800aea4:	f007 fd1c 	bl	80128e0 <HAL_RCCEx_PeriphCLKConfig>
 800aea8:	4603      	mov	r3, r0
 800aeaa:	2b00      	cmp	r3, #0
 800aeac:	bf14      	ite	ne
 800aeae:	2301      	movne	r3, #1
 800aeb0:	2300      	moveq	r3, #0
 800aeb2:	b2db      	uxtb	r3, r3
 800aeb4:	2b00      	cmp	r3, #0
 800aeb6:	d001      	beq.n	800aebc <_Z24PeriphCommonClock_Configv+0x6c>
  {
    Error_Handler();
 800aeb8:	f000 f818 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
}
 800aebc:	bf00      	nop
 800aebe:	3750      	adds	r7, #80	; 0x50
 800aec0:	46bd      	mov	sp, r7
 800aec2:	bd80      	pop	{r7, pc}
 800aec4:	11010000 	.word	0x11010000

0800aec8 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800aec8:	b580      	push	{r7, lr}
 800aeca:	b082      	sub	sp, #8
 800aecc:	af00      	add	r7, sp, #0
 800aece:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 800aed0:	687b      	ldr	r3, [r7, #4]
 800aed2:	681b      	ldr	r3, [r3, #0]
 800aed4:	4a04      	ldr	r2, [pc, #16]	; (800aee8 <HAL_TIM_PeriodElapsedCallback+0x20>)
 800aed6:	4293      	cmp	r3, r2
 800aed8:	d101      	bne.n	800aede <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 800aeda:	f001 fdc1 	bl	800ca60 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800aede:	bf00      	nop
 800aee0:	3708      	adds	r7, #8
 800aee2:	46bd      	mov	sp, r7
 800aee4:	bd80      	pop	{r7, pc}
 800aee6:	bf00      	nop
 800aee8:	40012c00 	.word	0x40012c00

0800aeec <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800aeec:	b480      	push	{r7}
 800aeee:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800aef0:	b672      	cpsid	i
}
 800aef2:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
 800aef4:	e7fe      	b.n	800aef4 <Error_Handler+0x8>
	...

0800aef8 <grabPacket>:

static SensorPacket packets[MAX_PACKET_QUEUE_SIZE];

static SensorPacket *packetPtr[MAX_PACKET_QUEUE_SIZE];

SensorPacket* grabPacket(void) {
 800aef8:	b580      	push	{r7, lr}
 800aefa:	b082      	sub	sp, #8
 800aefc:	af00      	add	r7, sp, #0
	SensorPacket *packet;
	// grab available memory for packet creation
	if (osOK != osMessageQueueGet(packetAvail_QueueHandle, &packet, 0U, 0)) {
 800aefe:	4b0b      	ldr	r3, [pc, #44]	; (800af2c <grabPacket+0x34>)
 800af00:	6818      	ldr	r0, [r3, #0]
 800af02:	1d39      	adds	r1, r7, #4
 800af04:	2300      	movs	r3, #0
 800af06:	2200      	movs	r2, #0
 800af08:	f018 f880 	bl	802300c <osMessageQueueGet>
 800af0c:	4603      	mov	r3, r0
 800af0e:	2b00      	cmp	r3, #0
 800af10:	bf14      	ite	ne
 800af12:	2301      	movne	r3, #1
 800af14:	2300      	moveq	r3, #0
 800af16:	b2db      	uxtb	r3, r3
 800af18:	2b00      	cmp	r3, #0
 800af1a:	d001      	beq.n	800af20 <grabPacket+0x28>
		return NULL;
 800af1c:	2300      	movs	r3, #0
 800af1e:	e000      	b.n	800af22 <grabPacket+0x2a>
	}
	return packet;
 800af20:	687b      	ldr	r3, [r7, #4]
}
 800af22:	4618      	mov	r0, r3
 800af24:	3708      	adds	r7, #8
 800af26:	46bd      	mov	sp, r7
 800af28:	bd80      	pop	{r7, pc}
 800af2a:	bf00      	nop
 800af2c:	200003e8 	.word	0x200003e8

0800af30 <queueUpPacket>:

void queueUpPacket(SensorPacket *packet) {
 800af30:	b580      	push	{r7, lr}
 800af32:	b082      	sub	sp, #8
 800af34:	af00      	add	r7, sp, #0
 800af36:	6078      	str	r0, [r7, #4]
	// put into queue
	osMessageQueuePut(packet_QueueHandle, &packet, 0U, 0);
 800af38:	4b05      	ldr	r3, [pc, #20]	; (800af50 <queueUpPacket+0x20>)
 800af3a:	6818      	ldr	r0, [r3, #0]
 800af3c:	1d39      	adds	r1, r7, #4
 800af3e:	2300      	movs	r3, #0
 800af40:	2200      	movs	r2, #0
 800af42:	f018 f803 	bl	8022f4c <osMessageQueuePut>
}
 800af46:	bf00      	nop
 800af48:	3708      	adds	r7, #8
 800af4a:	46bd      	mov	sp, r7
 800af4c:	bd80      	pop	{r7, pc}
 800af4e:	bf00      	nop
 800af50:	200003e4 	.word	0x200003e4

0800af54 <senderThread>:

SensorPacket *packetToSend;
void senderThread(void *argument) {
 800af54:	b580      	push	{r7, lr}
 800af56:	b084      	sub	sp, #16
 800af58:	af00      	add	r7, sp, #0
 800af5a:	6078      	str	r0, [r7, #4]
	uint8_t retry;

	for (int i = 0; i < MAX_PACKET_QUEUE_SIZE; i++) {
 800af5c:	2300      	movs	r3, #0
 800af5e:	60bb      	str	r3, [r7, #8]
 800af60:	68bb      	ldr	r3, [r7, #8]
 800af62:	2b09      	cmp	r3, #9
 800af64:	dc11      	bgt.n	800af8a <senderThread+0x36>
		packetToSend = &packets[i];
 800af66:	68bb      	ldr	r3, [r7, #8]
 800af68:	025b      	lsls	r3, r3, #9
 800af6a:	4a1f      	ldr	r2, [pc, #124]	; (800afe8 <senderThread+0x94>)
 800af6c:	4413      	add	r3, r2
 800af6e:	4a1f      	ldr	r2, [pc, #124]	; (800afec <senderThread+0x98>)
 800af70:	6013      	str	r3, [r2, #0]
		osMessageQueuePut(packetAvail_QueueHandle, &packetToSend, 0U,
 800af72:	4b1f      	ldr	r3, [pc, #124]	; (800aff0 <senderThread+0x9c>)
 800af74:	6818      	ldr	r0, [r3, #0]
 800af76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800af7a:	2200      	movs	r2, #0
 800af7c:	491b      	ldr	r1, [pc, #108]	; (800afec <senderThread+0x98>)
 800af7e:	f017 ffe5 	bl	8022f4c <osMessageQueuePut>
	for (int i = 0; i < MAX_PACKET_QUEUE_SIZE; i++) {
 800af82:	68bb      	ldr	r3, [r7, #8]
 800af84:	3301      	adds	r3, #1
 800af86:	60bb      	str	r3, [r7, #8]
 800af88:	e7ea      	b.n	800af60 <senderThread+0xc>
				osWaitForever);
	}

	while (1) {
		osMessageQueueGet(packet_QueueHandle, &packetToSend, 0U, osWaitForever);
 800af8a:	4b1a      	ldr	r3, [pc, #104]	; (800aff4 <senderThread+0xa0>)
 800af8c:	6818      	ldr	r0, [r3, #0]
 800af8e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800af92:	2200      	movs	r2, #0
 800af94:	4915      	ldr	r1, [pc, #84]	; (800afec <senderThread+0x98>)
 800af96:	f018 f839 	bl	802300c <osMessageQueueGet>

		retry = 0;
 800af9a:	2300      	movs	r3, #0
 800af9c:	73fb      	strb	r3, [r7, #15]
		while (PACKET_SEND_SUCCESS != sendPacket_BLE(packetToSend)) {
 800af9e:	4b13      	ldr	r3, [pc, #76]	; (800afec <senderThread+0x98>)
 800afa0:	681b      	ldr	r3, [r3, #0]
 800afa2:	4618      	mov	r0, r3
 800afa4:	f000 f828 	bl	800aff8 <sendPacket_BLE>
 800afa8:	4603      	mov	r3, r0
 800afaa:	2b00      	cmp	r3, #0
 800afac:	bf14      	ite	ne
 800afae:	2301      	movne	r3, #1
 800afb0:	2300      	moveq	r3, #0
 800afb2:	b2db      	uxtb	r3, r3
 800afb4:	2b00      	cmp	r3, #0
 800afb6:	d007      	beq.n	800afc8 <senderThread+0x74>
			if (retry >= MAX_BLE_RETRIES) {
 800afb8:	7bfb      	ldrb	r3, [r7, #15]
 800afba:	2b03      	cmp	r3, #3
 800afbc:	d803      	bhi.n	800afc6 <senderThread+0x72>
				break;
			}
			retry++;
 800afbe:	7bfb      	ldrb	r3, [r7, #15]
 800afc0:	3301      	adds	r3, #1
 800afc2:	73fb      	strb	r3, [r7, #15]
		while (PACKET_SEND_SUCCESS != sendPacket_BLE(packetToSend)) {
 800afc4:	e7eb      	b.n	800af9e <senderThread+0x4a>
				break;
 800afc6:	bf00      	nop
//			osDelay(5);
		};

		// return memory back to pool
		osMessageQueuePut(packetAvail_QueueHandle, &packetToSend, 0U,
 800afc8:	4b09      	ldr	r3, [pc, #36]	; (800aff0 <senderThread+0x9c>)
 800afca:	6818      	ldr	r0, [r3, #0]
 800afcc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800afd0:	2200      	movs	r2, #0
 800afd2:	4906      	ldr	r1, [pc, #24]	; (800afec <senderThread+0x98>)
 800afd4:	f017 ffba 	bl	8022f4c <osMessageQueuePut>
				osWaitForever);

//		osDelay(100);
		osDelay(10 - retry*2); // artificial delay to allow for the connected device to handle the latest sent packet
 800afd8:	7bfb      	ldrb	r3, [r7, #15]
 800afda:	f1c3 0305 	rsb	r3, r3, #5
 800afde:	005b      	lsls	r3, r3, #1
 800afe0:	4618      	mov	r0, r3
 800afe2:	f017 fc02 	bl	80227ea <osDelay>
		osMessageQueueGet(packet_QueueHandle, &packetToSend, 0U, osWaitForever);
 800afe6:	e7d0      	b.n	800af8a <senderThread+0x36>
 800afe8:	2000128c 	.word	0x2000128c
 800afec:	2000268c 	.word	0x2000268c
 800aff0:	200003e8 	.word	0x200003e8
 800aff4:	200003e4 	.word	0x200003e4

0800aff8 <sendPacket_BLE>:
	}
}

static DTS_App_Context_t DataTransferServerContext;
uint8_t sendPacket_BLE(SensorPacket *packet) {
 800aff8:	b580      	push	{r7, lr}
 800affa:	b084      	sub	sp, #16
 800affc:	af00      	add	r7, sp, #0
 800affe:	6078      	str	r0, [r7, #4]

	if ((packet->header.payloadLength) > MAX_PAYLOAD_SIZE) {
 800b000:	687b      	ldr	r3, [r7, #4]
 800b002:	68db      	ldr	r3, [r3, #12]
 800b004:	f5b3 7fee 	cmp.w	r3, #476	; 0x1dc
 800b008:	d901      	bls.n	800b00e <sendPacket_BLE+0x16>
		return PACKET_LENGTH_EXCEEDED;
 800b00a:	2301      	movs	r3, #1
 800b00c:	e016      	b.n	800b03c <sendPacket_BLE+0x44>
	}

	tBleStatus status = BLE_STATUS_INVALID_PARAMS;
 800b00e:	2392      	movs	r3, #146	; 0x92
 800b010:	73fb      	strb	r3, [r7, #15]
//	crc_result = APP_BLE_ComputeCRC8((uint8_t*) Notification_Data_Buffer,
//			(DATA_NOTIFICATION_MAX_PACKET_SIZE - 1));
//	Notification_Data_Buffer[DATA_NOTIFICATION_MAX_PACKET_SIZE - 1] =
//			crc_result;

	DataTransferServerContext.TxData.pPayload = (uint8_t*) packet;
 800b012:	4a0c      	ldr	r2, [pc, #48]	; (800b044 <sendPacket_BLE+0x4c>)
 800b014:	687b      	ldr	r3, [r7, #4]
 800b016:	6013      	str	r3, [r2, #0]
	DataTransferServerContext.TxData.Length = packet->header.payloadLength
 800b018:	687b      	ldr	r3, [r7, #4]
 800b01a:	68db      	ldr	r3, [r3, #12]
			+ sizeof(PacketHeader); //Att_Mtu_Exchanged-10;
 800b01c:	3324      	adds	r3, #36	; 0x24
	DataTransferServerContext.TxData.Length = packet->header.payloadLength
 800b01e:	4a09      	ldr	r2, [pc, #36]	; (800b044 <sendPacket_BLE+0x4c>)
 800b020:	60d3      	str	r3, [r2, #12]
//		status = Generic_STM_UpdateChar(PPG_CHAR_UUID_DEF,
//	(uint8_t*) &DataTransferServerContext.TxData);
//	}

	//COMMENTED BELOW ON 9/20/2022 BUT NEED TO FIX
	status = DTS_STM_UpdateChar(DATA_TRANSFER_TX_CHAR_UUID,
 800b022:	4908      	ldr	r1, [pc, #32]	; (800b044 <sendPacket_BLE+0x4c>)
 800b024:	f64f 6081 	movw	r0, #65153	; 0xfe81
 800b028:	f01d f91a 	bl	8028260 <DTS_STM_UpdateChar>
 800b02c:	4603      	mov	r3, r0
 800b02e:	73fb      	strb	r3, [r7, #15]
			(uint8_t*) &DataTransferServerContext.TxData);

	if (status == BLE_STATUS_SUCCESS) {
 800b030:	7bfb      	ldrb	r3, [r7, #15]
 800b032:	2b00      	cmp	r3, #0
 800b034:	d101      	bne.n	800b03a <sendPacket_BLE+0x42>
		return PACKET_SEND_SUCCESS;
 800b036:	2300      	movs	r3, #0
 800b038:	e000      	b.n	800b03c <sendPacket_BLE+0x44>
	} else {
		return PACKET_UNDEFINED_ERR;
 800b03a:	230a      	movs	r3, #10
	}
}
 800b03c:	4618      	mov	r0, r3
 800b03e:	3710      	adds	r7, #16
 800b040:	46bd      	mov	sp, r7
 800b042:	bd80      	pop	{r7, pc}
 800b044:	20002690 	.word	0x20002690

0800b048 <MX_RF_Init>:

/* USER CODE END 0 */

/* RF init function */
void MX_RF_Init(void)
{
 800b048:	b480      	push	{r7}
 800b04a:	af00      	add	r7, sp, #0
  /* USER CODE END RF_Init 1 */
  /* USER CODE BEGIN RF_Init 2 */

  /* USER CODE END RF_Init 2 */

}
 800b04c:	bf00      	nop
 800b04e:	46bd      	mov	sp, r7
 800b050:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b054:	4770      	bx	lr

0800b056 <LL_RCC_EnableRTC>:
{
 800b056:	b480      	push	{r7}
 800b058:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 800b05a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b05e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800b062:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800b066:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800b06a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800b06e:	bf00      	nop
 800b070:	46bd      	mov	sp, r7
 800b072:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b076:	4770      	bx	lr

0800b078 <LL_APB1_GRP1_EnableClock>:
{
 800b078:	b480      	push	{r7}
 800b07a:	b085      	sub	sp, #20
 800b07c:	af00      	add	r7, sp, #0
 800b07e:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 800b080:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b084:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800b086:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800b08a:	687b      	ldr	r3, [r7, #4]
 800b08c:	4313      	orrs	r3, r2
 800b08e:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800b090:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b094:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800b096:	687b      	ldr	r3, [r7, #4]
 800b098:	4013      	ands	r3, r2
 800b09a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800b09c:	68fb      	ldr	r3, [r7, #12]
}
 800b09e:	bf00      	nop
 800b0a0:	3714      	adds	r7, #20
 800b0a2:	46bd      	mov	sp, r7
 800b0a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0a8:	4770      	bx	lr
	...

0800b0ac <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 800b0ac:	b580      	push	{r7, lr}
 800b0ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 800b0b0:	4b11      	ldr	r3, [pc, #68]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0b2:	4a12      	ldr	r2, [pc, #72]	; (800b0fc <MX_RTC_Init+0x50>)
 800b0b4:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800b0b6:	4b10      	ldr	r3, [pc, #64]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0b8:	2200      	movs	r2, #0
 800b0ba:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = CFG_RTC_ASYNCH_PRESCALER;
 800b0bc:	4b0e      	ldr	r3, [pc, #56]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0be:	220f      	movs	r2, #15
 800b0c0:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = CFG_RTC_SYNCH_PRESCALER;
 800b0c2:	4b0d      	ldr	r3, [pc, #52]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0c4:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800b0c8:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800b0ca:	4b0b      	ldr	r3, [pc, #44]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0cc:	2200      	movs	r2, #0
 800b0ce:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800b0d0:	4b09      	ldr	r3, [pc, #36]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0d2:	2200      	movs	r2, #0
 800b0d4:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800b0d6:	4b08      	ldr	r3, [pc, #32]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0d8:	2200      	movs	r2, #0
 800b0da:	61da      	str	r2, [r3, #28]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 800b0dc:	4b06      	ldr	r3, [pc, #24]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0de:	2200      	movs	r2, #0
 800b0e0:	615a      	str	r2, [r3, #20]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 800b0e2:	4805      	ldr	r0, [pc, #20]	; (800b0f8 <MX_RTC_Init+0x4c>)
 800b0e4:	f008 fc4e 	bl	8013984 <HAL_RTC_Init>
 800b0e8:	4603      	mov	r3, r0
 800b0ea:	2b00      	cmp	r3, #0
 800b0ec:	d001      	beq.n	800b0f2 <MX_RTC_Init+0x46>
  {
    Error_Handler();
 800b0ee:	f7ff fefd 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 800b0f2:	bf00      	nop
 800b0f4:	bd80      	pop	{r7, pc}
 800b0f6:	bf00      	nop
 800b0f8:	20012070 	.word	0x20012070
 800b0fc:	40002800 	.word	0x40002800

0800b100 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 800b100:	b580      	push	{r7, lr}
 800b102:	b096      	sub	sp, #88	; 0x58
 800b104:	af00      	add	r7, sp, #0
 800b106:	6078      	str	r0, [r7, #4]

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800b108:	f107 0308 	add.w	r3, r7, #8
 800b10c:	2250      	movs	r2, #80	; 0x50
 800b10e:	2100      	movs	r1, #0
 800b110:	4618      	mov	r0, r3
 800b112:	f020 fff3 	bl	802c0fc <memset>
  if(rtcHandle->Instance==RTC)
 800b116:	687b      	ldr	r3, [r7, #4]
 800b118:	681b      	ldr	r3, [r3, #0]
 800b11a:	4a0e      	ldr	r2, [pc, #56]	; (800b154 <HAL_RTC_MspInit+0x54>)
 800b11c:	4293      	cmp	r3, r2
 800b11e:	d115      	bne.n	800b14c <HAL_RTC_MspInit+0x4c>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800b120:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b124:	60bb      	str	r3, [r7, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800b126:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b12a:	64bb      	str	r3, [r7, #72]	; 0x48
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800b12c:	f107 0308 	add.w	r3, r7, #8
 800b130:	4618      	mov	r0, r3
 800b132:	f007 fbd5 	bl	80128e0 <HAL_RCCEx_PeriphCLKConfig>
 800b136:	4603      	mov	r3, r0
 800b138:	2b00      	cmp	r3, #0
 800b13a:	d001      	beq.n	800b140 <HAL_RTC_MspInit+0x40>
    {
      Error_Handler();
 800b13c:	f7ff fed6 	bl	800aeec <Error_Handler>
    }

    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
 800b140:	f7ff ff89 	bl	800b056 <LL_RCC_EnableRTC>
    __HAL_RCC_RTCAPB_CLK_ENABLE();
 800b144:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800b148:	f7ff ff96 	bl	800b078 <LL_APB1_GRP1_EnableClock>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 800b14c:	bf00      	nop
 800b14e:	3758      	adds	r7, #88	; 0x58
 800b150:	46bd      	mov	sp, r7
 800b152:	bd80      	pop	{r7, pc}
 800b154:	40002800 	.word	0x40002800

0800b158 <LL_APB2_GRP1_EnableClock>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
 800b158:	b480      	push	{r7}
 800b15a:	b085      	sub	sp, #20
 800b15c:	af00      	add	r7, sp, #0
 800b15e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800b160:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b164:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800b166:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800b16a:	687b      	ldr	r3, [r7, #4]
 800b16c:	4313      	orrs	r3, r2
 800b16e:	660b      	str	r3, [r1, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800b170:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b174:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800b176:	687b      	ldr	r3, [r7, #4]
 800b178:	4013      	ands	r3, r2
 800b17a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800b17c:	68fb      	ldr	r3, [r7, #12]
}
 800b17e:	bf00      	nop
 800b180:	3714      	adds	r7, #20
 800b182:	46bd      	mov	sp, r7
 800b184:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b188:	4770      	bx	lr
	...

0800b18c <MX_SAI1_Init>:
SAI_HandleTypeDef hsai_BlockA1;
DMA_HandleTypeDef hdma_sai1_a;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
 800b18c:	b580      	push	{r7, lr}
 800b18e:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SAI1_Init 1 */

  /* USER CODE END SAI1_Init 1 */

  hsai_BlockA1.Instance = SAI1_Block_A;
 800b190:	4b19      	ldr	r3, [pc, #100]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b192:	4a1a      	ldr	r2, [pc, #104]	; (800b1fc <MX_SAI1_Init+0x70>)
 800b194:	601a      	str	r2, [r3, #0]
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
 800b196:	4b18      	ldr	r3, [pc, #96]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b198:	2200      	movs	r2, #0
 800b19a:	605a      	str	r2, [r3, #4]
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
 800b19c:	4b16      	ldr	r3, [pc, #88]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b19e:	2200      	movs	r2, #0
 800b1a0:	609a      	str	r2, [r3, #8]
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 800b1a2:	4b15      	ldr	r3, [pc, #84]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1a4:	2200      	movs	r2, #0
 800b1a6:	615a      	str	r2, [r3, #20]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 800b1a8:	4b13      	ldr	r3, [pc, #76]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1aa:	2200      	movs	r2, #0
 800b1ac:	619a      	str	r2, [r3, #24]
  hsai_BlockA1.Init.MckOverSampling = SAI_MCK_OVERSAMPLING_DISABLE;
 800b1ae:	4b12      	ldr	r3, [pc, #72]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1b0:	2200      	movs	r2, #0
 800b1b2:	629a      	str	r2, [r3, #40]	; 0x28
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_HF;
 800b1b4:	4b10      	ldr	r3, [pc, #64]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1b6:	2202      	movs	r2, #2
 800b1b8:	61da      	str	r2, [r3, #28]
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 800b1ba:	4b0f      	ldr	r3, [pc, #60]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1bc:	f64b 3280 	movw	r2, #48000	; 0xbb80
 800b1c0:	621a      	str	r2, [r3, #32]
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 800b1c2:	4b0d      	ldr	r3, [pc, #52]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1c4:	2200      	movs	r2, #0
 800b1c6:	60da      	str	r2, [r3, #12]
  hsai_BlockA1.Init.MonoStereoMode = SAI_MONOMODE;
 800b1c8:	4b0b      	ldr	r3, [pc, #44]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1ca:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800b1ce:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
 800b1d0:	4b09      	ldr	r3, [pc, #36]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1d2:	2200      	movs	r2, #0
 800b1d4:	631a      	str	r2, [r3, #48]	; 0x30
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 800b1d6:	4b08      	ldr	r3, [pc, #32]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1d8:	2200      	movs	r2, #0
 800b1da:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 800b1dc:	2302      	movs	r3, #2
 800b1de:	2202      	movs	r2, #2
 800b1e0:	2100      	movs	r1, #0
 800b1e2:	4805      	ldr	r0, [pc, #20]	; (800b1f8 <MX_SAI1_Init+0x6c>)
 800b1e4:	f008 fcbc 	bl	8013b60 <HAL_SAI_InitProtocol>
 800b1e8:	4603      	mov	r3, r0
 800b1ea:	2b00      	cmp	r3, #0
 800b1ec:	d001      	beq.n	800b1f2 <MX_SAI1_Init+0x66>
  {
    Error_Handler();
 800b1ee:	f7ff fe7d 	bl	800aeec <Error_Handler>

  /* USER CODE BEGIN SAI1_Init 2 */

  /* USER CODE END SAI1_Init 2 */

}
 800b1f2:	bf00      	nop
 800b1f4:	bd80      	pop	{r7, pc}
 800b1f6:	bf00      	nop
 800b1f8:	200120f4 	.word	0x200120f4
 800b1fc:	40015404 	.word	0x40015404

0800b200 <HAL_SAI_MspInit>:
static uint32_t SAI1_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* saiHandle)
{
 800b200:	b580      	push	{r7, lr}
 800b202:	b088      	sub	sp, #32
 800b204:	af00      	add	r7, sp, #0
 800b206:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(saiHandle->Instance==SAI1_Block_A)
 800b208:	687b      	ldr	r3, [r7, #4]
 800b20a:	681b      	ldr	r3, [r3, #0]
 800b20c:	4a33      	ldr	r2, [pc, #204]	; (800b2dc <HAL_SAI_MspInit+0xdc>)
 800b20e:	4293      	cmp	r3, r2
 800b210:	d160      	bne.n	800b2d4 <HAL_SAI_MspInit+0xd4>
    {
    /* SAI1 clock enable */
    if (SAI1_client == 0)
 800b212:	4b33      	ldr	r3, [pc, #204]	; (800b2e0 <HAL_SAI_MspInit+0xe0>)
 800b214:	681b      	ldr	r3, [r3, #0]
 800b216:	2b00      	cmp	r3, #0
 800b218:	d103      	bne.n	800b222 <HAL_SAI_MspInit+0x22>
    {
       __HAL_RCC_SAI1_CLK_ENABLE();
 800b21a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800b21e:	f7ff ff9b 	bl	800b158 <LL_APB2_GRP1_EnableClock>
    }
    SAI1_client ++;
 800b222:	4b2f      	ldr	r3, [pc, #188]	; (800b2e0 <HAL_SAI_MspInit+0xe0>)
 800b224:	681b      	ldr	r3, [r3, #0]
 800b226:	3301      	adds	r3, #1
 800b228:	4a2d      	ldr	r2, [pc, #180]	; (800b2e0 <HAL_SAI_MspInit+0xe0>)
 800b22a:	6013      	str	r3, [r2, #0]
    /**SAI1_A_Block_A GPIO Configuration
    PC3     ------> SAI1_SD_A
    PB13     ------> SAI1_SCK_A
    PB12     ------> SAI1_FS_A
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 800b22c:	2308      	movs	r3, #8
 800b22e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800b230:	2302      	movs	r3, #2
 800b232:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800b234:	2300      	movs	r3, #0
 800b236:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800b238:	2300      	movs	r3, #0
 800b23a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF13_SAI1;
 800b23c:	230d      	movs	r3, #13
 800b23e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800b240:	f107 030c 	add.w	r3, r7, #12
 800b244:	4619      	mov	r1, r3
 800b246:	4827      	ldr	r0, [pc, #156]	; (800b2e4 <HAL_SAI_MspInit+0xe4>)
 800b248:	f002 fe06 	bl	800de58 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_12;
 800b24c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800b250:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800b252:	2302      	movs	r3, #2
 800b254:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800b256:	2300      	movs	r3, #0
 800b258:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800b25a:	2300      	movs	r3, #0
 800b25c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF13_SAI1;
 800b25e:	230d      	movs	r3, #13
 800b260:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800b262:	f107 030c 	add.w	r3, r7, #12
 800b266:	4619      	mov	r1, r3
 800b268:	481f      	ldr	r0, [pc, #124]	; (800b2e8 <HAL_SAI_MspInit+0xe8>)
 800b26a:	f002 fdf5 	bl	800de58 <HAL_GPIO_Init>

    /* Peripheral DMA init*/

    hdma_sai1_a.Instance = DMA1_Channel2;
 800b26e:	4b1f      	ldr	r3, [pc, #124]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b270:	4a1f      	ldr	r2, [pc, #124]	; (800b2f0 <HAL_SAI_MspInit+0xf0>)
 800b272:	601a      	str	r2, [r3, #0]
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
 800b274:	4b1d      	ldr	r3, [pc, #116]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b276:	2212      	movs	r2, #18
 800b278:	605a      	str	r2, [r3, #4]
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800b27a:	4b1c      	ldr	r3, [pc, #112]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b27c:	2210      	movs	r2, #16
 800b27e:	609a      	str	r2, [r3, #8]
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
 800b280:	4b1a      	ldr	r3, [pc, #104]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b282:	2200      	movs	r2, #0
 800b284:	60da      	str	r2, [r3, #12]
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
 800b286:	4b19      	ldr	r3, [pc, #100]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b288:	2280      	movs	r2, #128	; 0x80
 800b28a:	611a      	str	r2, [r3, #16]
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800b28c:	4b17      	ldr	r3, [pc, #92]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b28e:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b292:	615a      	str	r2, [r3, #20]
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800b294:	4b15      	ldr	r3, [pc, #84]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b296:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800b29a:	619a      	str	r2, [r3, #24]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 800b29c:	4b13      	ldr	r3, [pc, #76]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b29e:	2220      	movs	r2, #32
 800b2a0:	61da      	str	r2, [r3, #28]
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_LOW;
 800b2a2:	4b12      	ldr	r3, [pc, #72]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2a4:	2200      	movs	r2, #0
 800b2a6:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 800b2a8:	4810      	ldr	r0, [pc, #64]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2aa:	f002 fc19 	bl	800dae0 <HAL_DMA_Init>
 800b2ae:	4603      	mov	r3, r0
 800b2b0:	2b00      	cmp	r3, #0
 800b2b2:	d001      	beq.n	800b2b8 <HAL_SAI_MspInit+0xb8>
    {
      Error_Handler();
 800b2b4:	f7ff fe1a 	bl	800aeec <Error_Handler>
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(saiHandle,hdmarx,hdma_sai1_a);
 800b2b8:	687b      	ldr	r3, [r7, #4]
 800b2ba:	4a0c      	ldr	r2, [pc, #48]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2bc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 800b2c0:	4a0a      	ldr	r2, [pc, #40]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2c2:	687b      	ldr	r3, [r7, #4]
 800b2c4:	6293      	str	r3, [r2, #40]	; 0x28
    __HAL_LINKDMA(saiHandle,hdmatx,hdma_sai1_a);
 800b2c6:	687b      	ldr	r3, [r7, #4]
 800b2c8:	4a08      	ldr	r2, [pc, #32]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2ca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 800b2ce:	4a07      	ldr	r2, [pc, #28]	; (800b2ec <HAL_SAI_MspInit+0xec>)
 800b2d0:	687b      	ldr	r3, [r7, #4]
 800b2d2:	6293      	str	r3, [r2, #40]	; 0x28
    }
}
 800b2d4:	bf00      	nop
 800b2d6:	3720      	adds	r7, #32
 800b2d8:	46bd      	mov	sp, r7
 800b2da:	bd80      	pop	{r7, pc}
 800b2dc:	40015404 	.word	0x40015404
 800b2e0:	200026a4 	.word	0x200026a4
 800b2e4:	48000800 	.word	0x48000800
 800b2e8:	48000400 	.word	0x48000400
 800b2ec:	20012094 	.word	0x20012094
 800b2f0:	4002001c 	.word	0x4002001c
 800b2f4:	00000000 	.word	0x00000000

0800b2f8 <SgpTask>:
GasIndexAlgorithmParams paramsNox;
GasIndexAlgorithmParams paramsVoc;



void SgpTask(void *argument) {
 800b2f8:	b590      	push	{r4, r7, lr}
 800b2fa:	b091      	sub	sp, #68	; 0x44
 800b2fc:	af02      	add	r7, sp, #8
 800b2fe:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 800b300:	2300      	movs	r3, #0
 800b302:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t flags;
	uint32_t timeLeftForSample = 0;
 800b304:	2300      	movs	r3, #0
 800b306:	637b      	str	r3, [r7, #52]	; 0x34
	uint16_t error;

    uint16_t defaultRh = 0x8000;
 800b308:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b30c:	847b      	strh	r3, [r7, #34]	; 0x22
    uint16_t defaultT = 0x6666;
 800b30e:	f246 6366 	movw	r3, #26214	; 0x6666
 800b312:	843b      	strh	r3, [r7, #32]

    uint16_t _Rh = 0;
 800b314:	2300      	movs	r3, #0
 800b316:	83fb      	strh	r3, [r7, #30]
	uint16_t _T = 0;
 800b318:	2300      	movs	r3, #0
 800b31a:	83bb      	strh	r3, [r7, #28]

	int32_t voc_index_value, nox_index_value;


    GasIndexAlgorithm_init(&paramsVoc, (int32_t) GasIndexAlgorithm_ALGORITHM_TYPE_VOC);
 800b31c:	2100      	movs	r1, #0
 800b31e:	48b6      	ldr	r0, [pc, #728]	; (800b5f8 <SgpTask+0x300>)
 800b320:	f01b fb58 	bl	80269d4 <GasIndexAlgorithm_init>
    GasIndexAlgorithm_init(&paramsNox, (int32_t) GasIndexAlgorithm_ALGORITHM_TYPE_NOX);
 800b324:	2101      	movs	r1, #1
 800b326:	48b5      	ldr	r0, [pc, #724]	; (800b5fc <SgpTask+0x304>)
 800b328:	f01b fb54 	bl	80269d4 <GasIndexAlgorithm_init>

	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b32c:	4bb4      	ldr	r3, [pc, #720]	; (800b600 <SgpTask+0x308>)
 800b32e:	681b      	ldr	r3, [r3, #0]
 800b330:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b334:	4618      	mov	r0, r3
 800b336:	f017 fcff 	bl	8022d38 <osSemaphoreAcquire>
	if (!sgp41.begin(&hi2c1)) {
 800b33a:	49b2      	ldr	r1, [pc, #712]	; (800b604 <SgpTask+0x30c>)
 800b33c:	48b2      	ldr	r0, [pc, #712]	; (800b608 <SgpTask+0x310>)
 800b33e:	f015 ff8f 	bl	8021260 <_ZN17SensirionI2CSgp415beginEP19__I2C_HandleTypeDef>
 800b342:	4603      	mov	r3, r0
 800b344:	f083 0301 	eor.w	r3, r3, #1
 800b348:	b2db      	uxtb	r3, r3
 800b34a:	2b00      	cmp	r3, #0
 800b34c:	d002      	beq.n	800b354 <SgpTask+0x5c>
		osDelay(100);
 800b34e:	2064      	movs	r0, #100	; 0x64
 800b350:	f017 fa4b 	bl	80227ea <osDelay>
	}

    uint16_t serialNumber[3];
    uint8_t serialNumberSize = 3;
 800b354:	2303      	movs	r3, #3
 800b356:	76fb      	strb	r3, [r7, #27]
    error = sgp41.getSerialNumber(serialNumber, serialNumberSize);
 800b358:	7efa      	ldrb	r2, [r7, #27]
 800b35a:	f107 030c 	add.w	r3, r7, #12
 800b35e:	4619      	mov	r1, r3
 800b360:	48a9      	ldr	r0, [pc, #676]	; (800b608 <SgpTask+0x310>)
 800b362:	f016 f8b8 	bl	80214d6 <_ZN17SensirionI2CSgp4115getSerialNumberEPth>
 800b366:	4603      	mov	r3, r0
 800b368:	867b      	strh	r3, [r7, #50]	; 0x32
    while (error) {
 800b36a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800b36c:	2b00      	cmp	r3, #0
 800b36e:	d018      	beq.n	800b3a2 <SgpTask+0xaa>
    	osSemaphoreRelease(messageI2C1_LockHandle);
 800b370:	4ba3      	ldr	r3, [pc, #652]	; (800b600 <SgpTask+0x308>)
 800b372:	681b      	ldr	r3, [r3, #0]
 800b374:	4618      	mov	r0, r3
 800b376:	f017 fd31 	bl	8022ddc <osSemaphoreRelease>
		osDelay(10);
 800b37a:	200a      	movs	r0, #10
 800b37c:	f017 fa35 	bl	80227ea <osDelay>
		osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b380:	4b9f      	ldr	r3, [pc, #636]	; (800b600 <SgpTask+0x308>)
 800b382:	681b      	ldr	r3, [r3, #0]
 800b384:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b388:	4618      	mov	r0, r3
 800b38a:	f017 fcd5 	bl	8022d38 <osSemaphoreAcquire>
		error = sgp41.getSerialNumber(serialNumber, serialNumberSize);
 800b38e:	7efa      	ldrb	r2, [r7, #27]
 800b390:	f107 030c 	add.w	r3, r7, #12
 800b394:	4619      	mov	r1, r3
 800b396:	489c      	ldr	r0, [pc, #624]	; (800b608 <SgpTask+0x310>)
 800b398:	f016 f89d 	bl	80214d6 <_ZN17SensirionI2CSgp4115getSerialNumberEPth>
 800b39c:	4603      	mov	r3, r0
 800b39e:	867b      	strh	r3, [r7, #50]	; 0x32
    while (error) {
 800b3a0:	e7e3      	b.n	800b36a <SgpTask+0x72>
    }

    uint16_t testResult;
    error = sgp41.executeSelfTest(testResult);
 800b3a2:	f107 030a 	add.w	r3, r7, #10
 800b3a6:	4619      	mov	r1, r3
 800b3a8:	4897      	ldr	r0, [pc, #604]	; (800b608 <SgpTask+0x310>)
 800b3aa:	f016 f848 	bl	802143e <_ZN17SensirionI2CSgp4115executeSelfTestERt>
 800b3ae:	4603      	mov	r3, r0
 800b3b0:	867b      	strh	r3, [r7, #50]	; 0x32
    while(error) {
 800b3b2:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800b3b4:	2b00      	cmp	r3, #0
 800b3b6:	d017      	beq.n	800b3e8 <SgpTask+0xf0>
    	osSemaphoreRelease(messageI2C1_LockHandle);
 800b3b8:	4b91      	ldr	r3, [pc, #580]	; (800b600 <SgpTask+0x308>)
 800b3ba:	681b      	ldr	r3, [r3, #0]
 800b3bc:	4618      	mov	r0, r3
 800b3be:	f017 fd0d 	bl	8022ddc <osSemaphoreRelease>
      	osDelay(10);
 800b3c2:	200a      	movs	r0, #10
 800b3c4:	f017 fa11 	bl	80227ea <osDelay>
		osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b3c8:	4b8d      	ldr	r3, [pc, #564]	; (800b600 <SgpTask+0x308>)
 800b3ca:	681b      	ldr	r3, [r3, #0]
 800b3cc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b3d0:	4618      	mov	r0, r3
 800b3d2:	f017 fcb1 	bl	8022d38 <osSemaphoreAcquire>
        error = sgp41.executeSelfTest(testResult);
 800b3d6:	f107 030a 	add.w	r3, r7, #10
 800b3da:	4619      	mov	r1, r3
 800b3dc:	488a      	ldr	r0, [pc, #552]	; (800b608 <SgpTask+0x310>)
 800b3de:	f016 f82e 	bl	802143e <_ZN17SensirionI2CSgp4115executeSelfTestERt>
 800b3e2:	4603      	mov	r3, r0
 800b3e4:	867b      	strh	r3, [r7, #50]	; 0x32
    while(error) {
 800b3e6:	e7e4      	b.n	800b3b2 <SgpTask+0xba>
      }
    if(testResult != 0xD400){
 800b3e8:	897b      	ldrh	r3, [r7, #10]
 800b3ea:	f5b3 4f54 	cmp.w	r3, #54272	; 0xd400
 800b3ee:	d009      	beq.n	800b404 <SgpTask+0x10c>
    	osSemaphoreRelease(messageI2C1_LockHandle);
 800b3f0:	4b83      	ldr	r3, [pc, #524]	; (800b600 <SgpTask+0x308>)
 800b3f2:	681b      	ldr	r3, [r3, #0]
 800b3f4:	4618      	mov	r0, r3
 800b3f6:	f017 fcf1 	bl	8022ddc <osSemaphoreRelease>
    	while(1){
    		osDelay(10000); // TODO: terminate thread instead
 800b3fa:	f242 7010 	movw	r0, #10000	; 0x2710
 800b3fe:	f017 f9f4 	bl	80227ea <osDelay>
 800b402:	e7fa      	b.n	800b3fa <SgpTask+0x102>
    	}
    }

	header.payloadLength = MAX_SGP_SAMPLES_PACKET * sizeof(sgpSample);
 800b404:	4b81      	ldr	r3, [pc, #516]	; (800b60c <SgpTask+0x314>)
 800b406:	2210      	movs	r2, #16
 800b408:	60da      	str	r2, [r3, #12]

	uint16_t sgpIdx = 0;
 800b40a:	2300      	movs	r3, #0
 800b40c:	863b      	strh	r3, [r7, #48]	; 0x30
	uint32_t sgpID = 0;
 800b40e:	2300      	movs	r3, #0
 800b410:	62fb      	str	r3, [r7, #44]	; 0x2c

	uint32_t sgpSample;

	// time in seconds needed for NOx conditioning
	uint16_t conditioning_s = 10;
 800b412:	230a      	movs	r3, #10
 800b414:	857b      	strh	r3, [r7, #42]	; 0x2a

	osSemaphoreRelease(messageI2C1_LockHandle);
 800b416:	4b7a      	ldr	r3, [pc, #488]	; (800b600 <SgpTask+0x308>)
 800b418:	681b      	ldr	r3, [r3, #0]
 800b41a:	4618      	mov	r0, r3
 800b41c:	f017 fcde 	bl	8022ddc <osSemaphoreRelease>
	periodicSgpTimer_id = osTimerNew(triggerSgpSample, osTimerPeriodic,
 800b420:	2300      	movs	r3, #0
 800b422:	2200      	movs	r2, #0
 800b424:	2101      	movs	r1, #1
 800b426:	487a      	ldr	r0, [pc, #488]	; (800b610 <SgpTask+0x318>)
 800b428:	f017 fa10 	bl	802284c <osTimerNew>
 800b42c:	4603      	mov	r3, r0
 800b42e:	4a79      	ldr	r2, [pc, #484]	; (800b614 <SgpTask+0x31c>)
 800b430:	6013      	str	r3, [r2, #0]
			NULL, NULL);
	osTimerStart(periodicSgpTimer_id, SGP_SAMPLE_SYS_PERIOD_MS);
 800b432:	4b78      	ldr	r3, [pc, #480]	; (800b614 <SgpTask+0x31c>)
 800b434:	681b      	ldr	r3, [r3, #0]
 800b436:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800b43a:	4618      	mov	r0, r3
 800b43c:	f017 fa82 	bl	8022944 <osTimerStart>


	while (1) {
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800b440:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b444:	2100      	movs	r1, #0
 800b446:	f44f 7040 	mov.w	r0, #768	; 0x300
 800b44a:	f017 f94d 	bl	80226e8 <osThreadFlagsWait>
 800b44e:	6178      	str	r0, [r7, #20]
		osFlagsWaitAny, osWaitForever);

		if ((flags & GRAB_SAMPLE_BIT) == GRAB_SAMPLE_BIT) {
 800b450:	697b      	ldr	r3, [r7, #20]
 800b452:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b456:	2b00      	cmp	r3, #0
 800b458:	f000 8160 	beq.w	800b71c <SgpTask+0x424>

			timeLeftForSample = HAL_GetTick() - timeLeftForSample;
 800b45c:	f001 fb14 	bl	800ca88 <HAL_GetTick>
 800b460:	4602      	mov	r2, r0
 800b462:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b464:	1ad3      	subs	r3, r2, r3
 800b466:	637b      	str	r3, [r7, #52]	; 0x34
			if(timeLeftForSample < SGP_SAMPLE_SYS_PERIOD_MS){
 800b468:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b46a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800b46e:	d202      	bcs.n	800b476 <SgpTask+0x17e>
				osDelay(timeLeftForSample);
 800b470:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800b472:	f017 f9ba 	bl	80227ea <osDelay>
			}

			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b476:	4b62      	ldr	r3, [pc, #392]	; (800b600 <SgpTask+0x308>)
 800b478:	681b      	ldr	r3, [r3, #0]
 800b47a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b47e:	4618      	mov	r0, r3
 800b480:	f017 fc5a 	bl	8022d38 <osSemaphoreAcquire>


			if (conditioning_s > 0) {
 800b484:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800b486:	2b00      	cmp	r3, #0
 800b488:	d05c      	beq.n	800b544 <SgpTask+0x24c>
				// During NOx conditioning (10s) SRAW NOx will remain 0
				if(shtTemp != -1 && shtHum != -1){
 800b48a:	4b63      	ldr	r3, [pc, #396]	; (800b618 <SgpTask+0x320>)
 800b48c:	edd3 7a00 	vldr	s15, [r3]
 800b490:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 800b494:	eef4 7a47 	vcmp.f32	s15, s14
 800b498:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b49c:	d03f      	beq.n	800b51e <SgpTask+0x226>
 800b49e:	4b5f      	ldr	r3, [pc, #380]	; (800b61c <SgpTask+0x324>)
 800b4a0:	edd3 7a00 	vldr	s15, [r3]
 800b4a4:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 800b4a8:	eef4 7a47 	vcmp.f32	s15, s14
 800b4ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4b0:	d035      	beq.n	800b51e <SgpTask+0x226>
					_Rh = (65535.0 / 100) * shtHum;
 800b4b2:	4b5a      	ldr	r3, [pc, #360]	; (800b61c <SgpTask+0x324>)
 800b4b4:	681b      	ldr	r3, [r3, #0]
 800b4b6:	4618      	mov	r0, r3
 800b4b8:	f7fc fac6 	bl	8007a48 <__aeabi_f2d>
 800b4bc:	a34a      	add	r3, pc, #296	; (adr r3, 800b5e8 <SgpTask+0x2f0>)
 800b4be:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b4c2:	f7fc fb19 	bl	8007af8 <__aeabi_dmul>
 800b4c6:	4602      	mov	r2, r0
 800b4c8:	460b      	mov	r3, r1
 800b4ca:	4610      	mov	r0, r2
 800b4cc:	4619      	mov	r1, r3
 800b4ce:	f7fc fdeb 	bl	80080a8 <__aeabi_d2uiz>
 800b4d2:	4603      	mov	r3, r0
 800b4d4:	83fb      	strh	r3, [r7, #30]
					_T = (65535.0 / 175) * (shtTemp+45);
 800b4d6:	4b50      	ldr	r3, [pc, #320]	; (800b618 <SgpTask+0x320>)
 800b4d8:	edd3 7a00 	vldr	s15, [r3]
 800b4dc:	ed9f 7a50 	vldr	s14, [pc, #320]	; 800b620 <SgpTask+0x328>
 800b4e0:	ee77 7a87 	vadd.f32	s15, s15, s14
 800b4e4:	ee17 0a90 	vmov	r0, s15
 800b4e8:	f7fc faae 	bl	8007a48 <__aeabi_f2d>
 800b4ec:	a340      	add	r3, pc, #256	; (adr r3, 800b5f0 <SgpTask+0x2f8>)
 800b4ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b4f2:	f7fc fb01 	bl	8007af8 <__aeabi_dmul>
 800b4f6:	4602      	mov	r2, r0
 800b4f8:	460b      	mov	r3, r1
 800b4fa:	4610      	mov	r0, r2
 800b4fc:	4619      	mov	r1, r3
 800b4fe:	f7fc fdd3 	bl	80080a8 <__aeabi_d2uiz>
 800b502:	4603      	mov	r3, r0
 800b504:	83bb      	strh	r3, [r7, #28]
					error = sgp41.executeConditioning(_Rh, _T, sgpData[sgpIdx].srawVoc);
 800b506:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b508:	011b      	lsls	r3, r3, #4
 800b50a:	4a46      	ldr	r2, [pc, #280]	; (800b624 <SgpTask+0x32c>)
 800b50c:	4413      	add	r3, r2
 800b50e:	8bba      	ldrh	r2, [r7, #28]
 800b510:	8bf9      	ldrh	r1, [r7, #30]
 800b512:	483d      	ldr	r0, [pc, #244]	; (800b608 <SgpTask+0x310>)
 800b514:	f015 feb6 	bl	8021284 <_ZN17SensirionI2CSgp4119executeConditioningEttRt>
 800b518:	4603      	mov	r3, r0
 800b51a:	867b      	strh	r3, [r7, #50]	; 0x32
 800b51c:	e00a      	b.n	800b534 <SgpTask+0x23c>
				}else{
					error = sgp41.executeConditioning(defaultRh, defaultT, sgpData[sgpIdx].srawVoc);
 800b51e:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b520:	011b      	lsls	r3, r3, #4
 800b522:	4a40      	ldr	r2, [pc, #256]	; (800b624 <SgpTask+0x32c>)
 800b524:	4413      	add	r3, r2
 800b526:	8c3a      	ldrh	r2, [r7, #32]
 800b528:	8c79      	ldrh	r1, [r7, #34]	; 0x22
 800b52a:	4837      	ldr	r0, [pc, #220]	; (800b608 <SgpTask+0x310>)
 800b52c:	f015 feaa 	bl	8021284 <_ZN17SensirionI2CSgp4119executeConditioningEttRt>
 800b530:	4603      	mov	r3, r0
 800b532:	867b      	strh	r3, [r7, #50]	; 0x32
				}
				sgpData[sgpIdx].srawNox = 0;
 800b534:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b536:	4a3b      	ldr	r2, [pc, #236]	; (800b624 <SgpTask+0x32c>)
 800b538:	011b      	lsls	r3, r3, #4
 800b53a:	4413      	add	r3, r2
 800b53c:	3302      	adds	r3, #2
 800b53e:	2200      	movs	r2, #0
 800b540:	801a      	strh	r2, [r3, #0]
 800b542:	e083      	b.n	800b64c <SgpTask+0x354>
			} else {
				// Read Measurement
				if(shtTemp != -1 && shtHum != -1){
 800b544:	4b34      	ldr	r3, [pc, #208]	; (800b618 <SgpTask+0x320>)
 800b546:	edd3 7a00 	vldr	s15, [r3]
 800b54a:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 800b54e:	eef4 7a47 	vcmp.f32	s15, s14
 800b552:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b556:	d067      	beq.n	800b628 <SgpTask+0x330>
 800b558:	4b30      	ldr	r3, [pc, #192]	; (800b61c <SgpTask+0x324>)
 800b55a:	edd3 7a00 	vldr	s15, [r3]
 800b55e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 800b562:	eef4 7a47 	vcmp.f32	s15, s14
 800b566:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b56a:	d05d      	beq.n	800b628 <SgpTask+0x330>
					_Rh = (65535.0 / 100) * shtHum;
 800b56c:	4b2b      	ldr	r3, [pc, #172]	; (800b61c <SgpTask+0x324>)
 800b56e:	681b      	ldr	r3, [r3, #0]
 800b570:	4618      	mov	r0, r3
 800b572:	f7fc fa69 	bl	8007a48 <__aeabi_f2d>
 800b576:	a31c      	add	r3, pc, #112	; (adr r3, 800b5e8 <SgpTask+0x2f0>)
 800b578:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b57c:	f7fc fabc 	bl	8007af8 <__aeabi_dmul>
 800b580:	4602      	mov	r2, r0
 800b582:	460b      	mov	r3, r1
 800b584:	4610      	mov	r0, r2
 800b586:	4619      	mov	r1, r3
 800b588:	f7fc fd8e 	bl	80080a8 <__aeabi_d2uiz>
 800b58c:	4603      	mov	r3, r0
 800b58e:	83fb      	strh	r3, [r7, #30]
					_T = (65535.0 / 175) * (shtTemp+45);
 800b590:	4b21      	ldr	r3, [pc, #132]	; (800b618 <SgpTask+0x320>)
 800b592:	edd3 7a00 	vldr	s15, [r3]
 800b596:	ed9f 7a22 	vldr	s14, [pc, #136]	; 800b620 <SgpTask+0x328>
 800b59a:	ee77 7a87 	vadd.f32	s15, s15, s14
 800b59e:	ee17 0a90 	vmov	r0, s15
 800b5a2:	f7fc fa51 	bl	8007a48 <__aeabi_f2d>
 800b5a6:	a312      	add	r3, pc, #72	; (adr r3, 800b5f0 <SgpTask+0x2f8>)
 800b5a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b5ac:	f7fc faa4 	bl	8007af8 <__aeabi_dmul>
 800b5b0:	4602      	mov	r2, r0
 800b5b2:	460b      	mov	r3, r1
 800b5b4:	4610      	mov	r0, r2
 800b5b6:	4619      	mov	r1, r3
 800b5b8:	f7fc fd76 	bl	80080a8 <__aeabi_d2uiz>
 800b5bc:	4603      	mov	r3, r0
 800b5be:	83bb      	strh	r3, [r7, #28]
					error = sgp41.measureRawSignals(_Rh, _T, sgpData[sgpIdx].srawVoc, sgpData[sgpIdx].srawNox);
 800b5c0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b5c2:	011b      	lsls	r3, r3, #4
 800b5c4:	4a17      	ldr	r2, [pc, #92]	; (800b624 <SgpTask+0x32c>)
 800b5c6:	1898      	adds	r0, r3, r2
 800b5c8:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b5ca:	011b      	lsls	r3, r3, #4
 800b5cc:	4a15      	ldr	r2, [pc, #84]	; (800b624 <SgpTask+0x32c>)
 800b5ce:	4413      	add	r3, r2
 800b5d0:	3302      	adds	r3, #2
 800b5d2:	8bba      	ldrh	r2, [r7, #28]
 800b5d4:	8bf9      	ldrh	r1, [r7, #30]
 800b5d6:	9300      	str	r3, [sp, #0]
 800b5d8:	4603      	mov	r3, r0
 800b5da:	480b      	ldr	r0, [pc, #44]	; (800b608 <SgpTask+0x310>)
 800b5dc:	f015 febb 	bl	8021356 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_>
 800b5e0:	4603      	mov	r3, r0
 800b5e2:	867b      	strh	r3, [r7, #50]	; 0x32
 800b5e4:	e032      	b.n	800b64c <SgpTask+0x354>
 800b5e6:	bf00      	nop
 800b5e8:	cccccccd 	.word	0xcccccccd
 800b5ec:	40847acc 	.word	0x40847acc
 800b5f0:	7c57c57c 	.word	0x7c57c57c
 800b5f4:	407767c5 	.word	0x407767c5
 800b5f8:	2000278c 	.word	0x2000278c
 800b5fc:	200026e8 	.word	0x200026e8
 800b600:	200003dc 	.word	0x200003dc
 800b604:	20011fa8 	.word	0x20011fa8
 800b608:	200026e0 	.word	0x200026e0
 800b60c:	200026b8 	.word	0x200026b8
 800b610:	0800b75d 	.word	0x0800b75d
 800b614:	200026dc 	.word	0x200026dc
 800b618:	20002884 	.word	0x20002884
 800b61c:	20002888 	.word	0x20002888
 800b620:	42340000 	.word	0x42340000
 800b624:	200026a8 	.word	0x200026a8
				}else{
					error = sgp41.measureRawSignals(defaultRh, defaultT, sgpData[sgpIdx].srawVoc, sgpData[sgpIdx].srawNox);
 800b628:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b62a:	011b      	lsls	r3, r3, #4
 800b62c:	4a44      	ldr	r2, [pc, #272]	; (800b740 <SgpTask+0x448>)
 800b62e:	1898      	adds	r0, r3, r2
 800b630:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b632:	011b      	lsls	r3, r3, #4
 800b634:	4a42      	ldr	r2, [pc, #264]	; (800b740 <SgpTask+0x448>)
 800b636:	4413      	add	r3, r2
 800b638:	3302      	adds	r3, #2
 800b63a:	8c3a      	ldrh	r2, [r7, #32]
 800b63c:	8c79      	ldrh	r1, [r7, #34]	; 0x22
 800b63e:	9300      	str	r3, [sp, #0]
 800b640:	4603      	mov	r3, r0
 800b642:	4840      	ldr	r0, [pc, #256]	; (800b744 <SgpTask+0x44c>)
 800b644:	f015 fe87 	bl	8021356 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_>
 800b648:	4603      	mov	r3, r0
 800b64a:	867b      	strh	r3, [r7, #50]	; 0x32
				}
			}
			osSemaphoreRelease(messageI2C1_LockHandle);
 800b64c:	4b3e      	ldr	r3, [pc, #248]	; (800b748 <SgpTask+0x450>)
 800b64e:	681b      	ldr	r3, [r3, #0]
 800b650:	4618      	mov	r0, r3
 800b652:	f017 fbc3 	bl	8022ddc <osSemaphoreRelease>

			if(error){
 800b656:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800b658:	2b00      	cmp	r3, #0
 800b65a:	d16b      	bne.n	800b734 <SgpTask+0x43c>
				continue;
			}

			if (conditioning_s > 0)	{
 800b65c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800b65e:	2b00      	cmp	r3, #0
 800b660:	d003      	beq.n	800b66a <SgpTask+0x372>
		        conditioning_s--;
 800b662:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800b664:	3b01      	subs	r3, #1
 800b666:	857b      	strh	r3, [r7, #42]	; 0x2a
 800b668:	e01e      	b.n	800b6a8 <SgpTask+0x3b0>
			}else{
				GasIndexAlgorithm_process(&paramsNox, sgpData[sgpIdx].srawNox, &sgpData[sgpIdx].nox_index_value);
 800b66a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b66c:	4a34      	ldr	r2, [pc, #208]	; (800b740 <SgpTask+0x448>)
 800b66e:	011b      	lsls	r3, r3, #4
 800b670:	4413      	add	r3, r2
 800b672:	3302      	adds	r3, #2
 800b674:	881b      	ldrh	r3, [r3, #0]
 800b676:	4619      	mov	r1, r3
 800b678:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b67a:	011b      	lsls	r3, r3, #4
 800b67c:	3308      	adds	r3, #8
 800b67e:	4a30      	ldr	r2, [pc, #192]	; (800b740 <SgpTask+0x448>)
 800b680:	4413      	add	r3, r2
 800b682:	461a      	mov	r2, r3
 800b684:	4831      	ldr	r0, [pc, #196]	; (800b74c <SgpTask+0x454>)
 800b686:	f01b fa0f 	bl	8026aa8 <GasIndexAlgorithm_process>
				GasIndexAlgorithm_process(&paramsVoc, sgpData[sgpIdx].srawVoc, &sgpData[sgpIdx].voc_index_value);
 800b68a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b68c:	4a2c      	ldr	r2, [pc, #176]	; (800b740 <SgpTask+0x448>)
 800b68e:	011b      	lsls	r3, r3, #4
 800b690:	4413      	add	r3, r2
 800b692:	881b      	ldrh	r3, [r3, #0]
 800b694:	4619      	mov	r1, r3
 800b696:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b698:	011b      	lsls	r3, r3, #4
 800b69a:	4a29      	ldr	r2, [pc, #164]	; (800b740 <SgpTask+0x448>)
 800b69c:	4413      	add	r3, r2
 800b69e:	3304      	adds	r3, #4
 800b6a0:	461a      	mov	r2, r3
 800b6a2:	482b      	ldr	r0, [pc, #172]	; (800b750 <SgpTask+0x458>)
 800b6a4:	f01b fa00 	bl	8026aa8 <GasIndexAlgorithm_process>
			}

			sgpData[sgpIdx].timestamp = HAL_GetTick();
 800b6a8:	8e3c      	ldrh	r4, [r7, #48]	; 0x30
 800b6aa:	f001 f9ed 	bl	800ca88 <HAL_GetTick>
 800b6ae:	4602      	mov	r2, r0
 800b6b0:	4923      	ldr	r1, [pc, #140]	; (800b740 <SgpTask+0x448>)
 800b6b2:	0123      	lsls	r3, r4, #4
 800b6b4:	440b      	add	r3, r1
 800b6b6:	330c      	adds	r3, #12
 800b6b8:	601a      	str	r2, [r3, #0]

			sgpIdx++;
 800b6ba:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b6bc:	3301      	adds	r3, #1
 800b6be:	863b      	strh	r3, [r7, #48]	; 0x30

			if (sgpIdx >= MAX_SGP_SAMPLES_PACKET) {
 800b6c0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800b6c2:	2b00      	cmp	r3, #0
 800b6c4:	d027      	beq.n	800b716 <SgpTask+0x41e>
				header.packetType = SGP;
 800b6c6:	4b23      	ldr	r3, [pc, #140]	; (800b754 <SgpTask+0x45c>)
 800b6c8:	220c      	movs	r2, #12
 800b6ca:	701a      	strb	r2, [r3, #0]
				header.packetID = sgpID;
 800b6cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b6ce:	b29a      	uxth	r2, r3
 800b6d0:	4b20      	ldr	r3, [pc, #128]	; (800b754 <SgpTask+0x45c>)
 800b6d2:	805a      	strh	r2, [r3, #2]
				header.msFromStart = HAL_GetTick();
 800b6d4:	f001 f9d8 	bl	800ca88 <HAL_GetTick>
 800b6d8:	4603      	mov	r3, r0
 800b6da:	4a1e      	ldr	r2, [pc, #120]	; (800b754 <SgpTask+0x45c>)
 800b6dc:	6053      	str	r3, [r2, #4]
				packet = grabPacket();
 800b6de:	f7ff fc0b 	bl	800aef8 <grabPacket>
 800b6e2:	6278      	str	r0, [r7, #36]	; 0x24
				if (packet != NULL) {
 800b6e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6e6:	2b00      	cmp	r3, #0
 800b6e8:	d010      	beq.n	800b70c <SgpTask+0x414>
					memcpy(&(packet->header), &header, sizeof(PacketHeader));
 800b6ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6ec:	2224      	movs	r2, #36	; 0x24
 800b6ee:	4919      	ldr	r1, [pc, #100]	; (800b754 <SgpTask+0x45c>)
 800b6f0:	4618      	mov	r0, r3
 800b6f2:	f020 fcf5 	bl	802c0e0 <memcpy>
					memcpy(packet->payload, sgpData, header.payloadLength);
 800b6f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6f8:	3324      	adds	r3, #36	; 0x24
 800b6fa:	4a16      	ldr	r2, [pc, #88]	; (800b754 <SgpTask+0x45c>)
 800b6fc:	68d2      	ldr	r2, [r2, #12]
 800b6fe:	4910      	ldr	r1, [pc, #64]	; (800b740 <SgpTask+0x448>)
 800b700:	4618      	mov	r0, r3
 800b702:	f020 fced 	bl	802c0e0 <memcpy>
					queueUpPacket(packet);
 800b706:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800b708:	f7ff fc12 	bl	800af30 <queueUpPacket>
				}
				sgpID++;
 800b70c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b70e:	3301      	adds	r3, #1
 800b710:	62fb      	str	r3, [r7, #44]	; 0x2c
				sgpIdx = 0;
 800b712:	2300      	movs	r3, #0
 800b714:	863b      	strh	r3, [r7, #48]	; 0x30
			}

			timeLeftForSample = HAL_GetTick();
 800b716:	f001 f9b7 	bl	800ca88 <HAL_GetTick>
 800b71a:	6378      	str	r0, [r7, #52]	; 0x34
		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 800b71c:	697b      	ldr	r3, [r7, #20]
 800b71e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800b722:	2b00      	cmp	r3, #0
 800b724:	f43f ae8c 	beq.w	800b440 <SgpTask+0x148>
			osTimerDelete(periodicSgpTimer_id);
 800b728:	4b0b      	ldr	r3, [pc, #44]	; (800b758 <SgpTask+0x460>)
 800b72a:	681b      	ldr	r3, [r3, #0]
 800b72c:	4618      	mov	r0, r3
 800b72e:	f017 f937 	bl	80229a0 <osTimerDelete>
			break;
 800b732:	e001      	b.n	800b738 <SgpTask+0x440>
				continue;
 800b734:	bf00      	nop
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800b736:	e683      	b.n	800b440 <SgpTask+0x148>
		}
	}
}
 800b738:	bf00      	nop
 800b73a:	373c      	adds	r7, #60	; 0x3c
 800b73c:	46bd      	mov	sp, r7
 800b73e:	bd90      	pop	{r4, r7, pc}
 800b740:	200026a8 	.word	0x200026a8
 800b744:	200026e0 	.word	0x200026e0
 800b748:	200003dc 	.word	0x200003dc
 800b74c:	200026e8 	.word	0x200026e8
 800b750:	2000278c 	.word	0x2000278c
 800b754:	200026b8 	.word	0x200026b8
 800b758:	200026dc 	.word	0x200026dc

0800b75c <_ZL16triggerSgpSamplePv>:

static void triggerSgpSample(void *argument) {
 800b75c:	b580      	push	{r7, lr}
 800b75e:	b082      	sub	sp, #8
 800b760:	af00      	add	r7, sp, #0
 800b762:	6078      	str	r0, [r7, #4]
	osThreadFlagsSet(sgpTaskHandle, GRAB_SAMPLE_BIT);
 800b764:	4b05      	ldr	r3, [pc, #20]	; (800b77c <_ZL16triggerSgpSamplePv+0x20>)
 800b766:	681b      	ldr	r3, [r3, #0]
 800b768:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b76c:	4618      	mov	r0, r3
 800b76e:	f016 ff6d 	bl	802264c <osThreadFlagsSet>
}
 800b772:	bf00      	nop
 800b774:	3708      	adds	r7, #8
 800b776:	46bd      	mov	sp, r7
 800b778:	bd80      	pop	{r7, pc}
 800b77a:	bf00      	nop
 800b77c:	200003c8 	.word	0x200003c8

0800b780 <_Z41__static_initialization_and_destruction_0ii>:
 800b780:	b580      	push	{r7, lr}
 800b782:	b082      	sub	sp, #8
 800b784:	af00      	add	r7, sp, #0
 800b786:	6078      	str	r0, [r7, #4]
 800b788:	6039      	str	r1, [r7, #0]
 800b78a:	687b      	ldr	r3, [r7, #4]
 800b78c:	2b01      	cmp	r3, #1
 800b78e:	d107      	bne.n	800b7a0 <_Z41__static_initialization_and_destruction_0ii+0x20>
 800b790:	683b      	ldr	r3, [r7, #0]
 800b792:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b796:	4293      	cmp	r3, r2
 800b798:	d102      	bne.n	800b7a0 <_Z41__static_initialization_and_destruction_0ii+0x20>
SensirionI2CSgp41 sgp41;
 800b79a:	4803      	ldr	r0, [pc, #12]	; (800b7a8 <_Z41__static_initialization_and_destruction_0ii+0x28>)
 800b79c:	f015 fd4f 	bl	802123e <_ZN17SensirionI2CSgp41C1Ev>
}
 800b7a0:	bf00      	nop
 800b7a2:	3708      	adds	r7, #8
 800b7a4:	46bd      	mov	sp, r7
 800b7a6:	bd80      	pop	{r7, pc}
 800b7a8:	200026e0 	.word	0x200026e0

0800b7ac <_GLOBAL__sub_I_periodicSgpTimer_id>:
 800b7ac:	b580      	push	{r7, lr}
 800b7ae:	af00      	add	r7, sp, #0
 800b7b0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800b7b4:	2001      	movs	r0, #1
 800b7b6:	f7ff ffe3 	bl	800b780 <_Z41__static_initialization_and_destruction_0ii>
 800b7ba:	bd80      	pop	{r7, pc}

0800b7bc <ShtTask>:

Adafruit_SHT4x sht4 = Adafruit_SHT4x();

float shtTemp, shtHum;

void ShtTask(void *argument) {
 800b7bc:	b590      	push	{r4, r7, lr}
 800b7be:	b089      	sub	sp, #36	; 0x24
 800b7c0:	af00      	add	r7, sp, #0
 800b7c2:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 800b7c4:	2300      	movs	r3, #0
 800b7c6:	617b      	str	r3, [r7, #20]
	uint32_t flags;
	uint32_t timeLeftForSample = 0;
 800b7c8:	2300      	movs	r3, #0
 800b7ca:	613b      	str	r3, [r7, #16]

	shtTemp = -1;
 800b7cc:	4b6c      	ldr	r3, [pc, #432]	; (800b980 <ShtTask+0x1c4>)
 800b7ce:	4a6d      	ldr	r2, [pc, #436]	; (800b984 <ShtTask+0x1c8>)
 800b7d0:	601a      	str	r2, [r3, #0]
	shtHum = -1;
 800b7d2:	4b6d      	ldr	r3, [pc, #436]	; (800b988 <ShtTask+0x1cc>)
 800b7d4:	4a6b      	ldr	r2, [pc, #428]	; (800b984 <ShtTask+0x1c8>)
 800b7d6:	601a      	str	r2, [r3, #0]

	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b7d8:	4b6c      	ldr	r3, [pc, #432]	; (800b98c <ShtTask+0x1d0>)
 800b7da:	681b      	ldr	r3, [r3, #0]
 800b7dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b7e0:	4618      	mov	r0, r3
 800b7e2:	f017 faa9 	bl	8022d38 <osSemaphoreAcquire>
	if (!sht4.begin(&hi2c1)) {
 800b7e6:	496a      	ldr	r1, [pc, #424]	; (800b990 <ShtTask+0x1d4>)
 800b7e8:	486a      	ldr	r0, [pc, #424]	; (800b994 <ShtTask+0x1d8>)
 800b7ea:	f015 ff43 	bl	8021674 <_ZN14Adafruit_SHT4x5beginEP19__I2C_HandleTypeDef>
 800b7ee:	4603      	mov	r3, r0
 800b7f0:	f083 0301 	eor.w	r3, r3, #1
 800b7f4:	b2db      	uxtb	r3, r3
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d002      	beq.n	800b800 <ShtTask+0x44>
		osDelay(100);
 800b7fa:	2064      	movs	r0, #100	; 0x64
 800b7fc:	f016 fff5 	bl	80227ea <osDelay>
	}

	sht4.setPrecision(SHT4X_HIGH_PRECISION);
 800b800:	2100      	movs	r1, #0
 800b802:	4864      	ldr	r0, [pc, #400]	; (800b994 <ShtTask+0x1d8>)
 800b804:	f015 ff6e 	bl	80216e4 <_ZN14Adafruit_SHT4x12setPrecisionE17sht4x_precision_t>
	sht4.setHeater(SHT4X_NO_HEATER);
 800b808:	2100      	movs	r1, #0
 800b80a:	4862      	ldr	r0, [pc, #392]	; (800b994 <ShtTask+0x1d8>)
 800b80c:	f015 ff79 	bl	8021702 <_ZN14Adafruit_SHT4x9setHeaterE14sht4x_heater_t>

	header.payloadLength = MAX_SHT_SAMPLES_PACKET * sizeof(shtSample);
 800b810:	4b61      	ldr	r3, [pc, #388]	; (800b998 <ShtTask+0x1dc>)
 800b812:	220c      	movs	r2, #12
 800b814:	60da      	str	r2, [r3, #12]
	header.reserved[0] = (uint8_t) SHT4X_HIGH_PRECISION;
 800b816:	4b60      	ldr	r3, [pc, #384]	; (800b998 <ShtTask+0x1dc>)
 800b818:	2200      	movs	r2, #0
 800b81a:	611a      	str	r2, [r3, #16]
	header.reserved[1] = (uint8_t) SHT4X_NO_HEATER;
 800b81c:	4b5e      	ldr	r3, [pc, #376]	; (800b998 <ShtTask+0x1dc>)
 800b81e:	2200      	movs	r2, #0
 800b820:	615a      	str	r2, [r3, #20]

	uint16_t shtIdx = 0;
 800b822:	2300      	movs	r3, #0
 800b824:	83fb      	strh	r3, [r7, #30]
	uint32_t shtID = 0;
 800b826:	2300      	movs	r3, #0
 800b828:	61bb      	str	r3, [r7, #24]


	uint32_t shtSample;

	osSemaphoreRelease(messageI2C1_LockHandle);
 800b82a:	4b58      	ldr	r3, [pc, #352]	; (800b98c <ShtTask+0x1d0>)
 800b82c:	681b      	ldr	r3, [r3, #0]
 800b82e:	4618      	mov	r0, r3
 800b830:	f017 fad4 	bl	8022ddc <osSemaphoreRelease>
	periodicShtTimer_id = osTimerNew(triggerShtSample, osTimerPeriodic,
 800b834:	2300      	movs	r3, #0
 800b836:	2200      	movs	r2, #0
 800b838:	2101      	movs	r1, #1
 800b83a:	4858      	ldr	r0, [pc, #352]	; (800b99c <ShtTask+0x1e0>)
 800b83c:	f017 f806 	bl	802284c <osTimerNew>
 800b840:	4603      	mov	r3, r0
 800b842:	4a57      	ldr	r2, [pc, #348]	; (800b9a0 <ShtTask+0x1e4>)
 800b844:	6013      	str	r3, [r2, #0]
			NULL, NULL);
	osTimerStart(periodicShtTimer_id, SHT_SAMPLE_SYS_PERIOD_MS);
 800b846:	4b56      	ldr	r3, [pc, #344]	; (800b9a0 <ShtTask+0x1e4>)
 800b848:	681b      	ldr	r3, [r3, #0]
 800b84a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800b84e:	4618      	mov	r0, r3
 800b850:	f017 f878 	bl	8022944 <osTimerStart>


	while (1) {
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800b854:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b858:	2100      	movs	r1, #0
 800b85a:	f44f 7040 	mov.w	r0, #768	; 0x300
 800b85e:	f016 ff43 	bl	80226e8 <osThreadFlagsWait>
 800b862:	60f8      	str	r0, [r7, #12]
		osFlagsWaitAny, osWaitForever);

		if ((flags & GRAB_SAMPLE_BIT) == GRAB_SAMPLE_BIT) {
 800b864:	68fb      	ldr	r3, [r7, #12]
 800b866:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b86a:	2b00      	cmp	r3, #0
 800b86c:	d075      	beq.n	800b95a <ShtTask+0x19e>
//			timeLeftForSample = HAL_GetTick() - timeLeftForSample;
//			if(timeLeftForSample < SHT_SAMPLE_SYS_PERIOD_MS){
//				osDelay(timeLeftForSample);
//			}

			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800b86e:	4b47      	ldr	r3, [pc, #284]	; (800b98c <ShtTask+0x1d0>)
 800b870:	681b      	ldr	r3, [r3, #0]
 800b872:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b876:	4618      	mov	r0, r3
 800b878:	f017 fa5e 	bl	8022d38 <osSemaphoreAcquire>
			if(sht4.getEvent()){
 800b87c:	4845      	ldr	r0, [pc, #276]	; (800b994 <ShtTask+0x1d8>)
 800b87e:	f015 ff4f 	bl	8021720 <_ZN14Adafruit_SHT4x8getEventEv>
 800b882:	4603      	mov	r3, r0
 800b884:	2b00      	cmp	r3, #0
 800b886:	d074      	beq.n	800b972 <ShtTask+0x1b6>
				shtData[shtIdx].temp = sht4._temperature;
 800b888:	8bfa      	ldrh	r2, [r7, #30]
 800b88a:	4b42      	ldr	r3, [pc, #264]	; (800b994 <ShtTask+0x1d8>)
 800b88c:	6819      	ldr	r1, [r3, #0]
 800b88e:	4845      	ldr	r0, [pc, #276]	; (800b9a4 <ShtTask+0x1e8>)
 800b890:	4613      	mov	r3, r2
 800b892:	005b      	lsls	r3, r3, #1
 800b894:	4413      	add	r3, r2
 800b896:	009b      	lsls	r3, r3, #2
 800b898:	4403      	add	r3, r0
 800b89a:	6019      	str	r1, [r3, #0]
				shtData[shtIdx].hum = sht4._humidity;
 800b89c:	8bfa      	ldrh	r2, [r7, #30]
 800b89e:	4b3d      	ldr	r3, [pc, #244]	; (800b994 <ShtTask+0x1d8>)
 800b8a0:	6859      	ldr	r1, [r3, #4]
 800b8a2:	4840      	ldr	r0, [pc, #256]	; (800b9a4 <ShtTask+0x1e8>)
 800b8a4:	4613      	mov	r3, r2
 800b8a6:	005b      	lsls	r3, r3, #1
 800b8a8:	4413      	add	r3, r2
 800b8aa:	009b      	lsls	r3, r3, #2
 800b8ac:	4403      	add	r3, r0
 800b8ae:	3304      	adds	r3, #4
 800b8b0:	6019      	str	r1, [r3, #0]
				shtData[shtIdx].timestamp = HAL_GetTick();
 800b8b2:	8bfc      	ldrh	r4, [r7, #30]
 800b8b4:	f001 f8e8 	bl	800ca88 <HAL_GetTick>
 800b8b8:	4602      	mov	r2, r0
 800b8ba:	493a      	ldr	r1, [pc, #232]	; (800b9a4 <ShtTask+0x1e8>)
 800b8bc:	4623      	mov	r3, r4
 800b8be:	005b      	lsls	r3, r3, #1
 800b8c0:	4423      	add	r3, r4
 800b8c2:	009b      	lsls	r3, r3, #2
 800b8c4:	440b      	add	r3, r1
 800b8c6:	3308      	adds	r3, #8
 800b8c8:	601a      	str	r2, [r3, #0]

				shtTemp = shtData[shtIdx].temp;
 800b8ca:	8bfa      	ldrh	r2, [r7, #30]
 800b8cc:	4935      	ldr	r1, [pc, #212]	; (800b9a4 <ShtTask+0x1e8>)
 800b8ce:	4613      	mov	r3, r2
 800b8d0:	005b      	lsls	r3, r3, #1
 800b8d2:	4413      	add	r3, r2
 800b8d4:	009b      	lsls	r3, r3, #2
 800b8d6:	440b      	add	r3, r1
 800b8d8:	681b      	ldr	r3, [r3, #0]
 800b8da:	4a29      	ldr	r2, [pc, #164]	; (800b980 <ShtTask+0x1c4>)
 800b8dc:	6013      	str	r3, [r2, #0]
				shtHum = shtData[shtIdx].hum;
 800b8de:	8bfa      	ldrh	r2, [r7, #30]
 800b8e0:	4930      	ldr	r1, [pc, #192]	; (800b9a4 <ShtTask+0x1e8>)
 800b8e2:	4613      	mov	r3, r2
 800b8e4:	005b      	lsls	r3, r3, #1
 800b8e6:	4413      	add	r3, r2
 800b8e8:	009b      	lsls	r3, r3, #2
 800b8ea:	440b      	add	r3, r1
 800b8ec:	3304      	adds	r3, #4
 800b8ee:	681b      	ldr	r3, [r3, #0]
 800b8f0:	4a25      	ldr	r2, [pc, #148]	; (800b988 <ShtTask+0x1cc>)
 800b8f2:	6013      	str	r3, [r2, #0]
			}else{
				continue;
			}

			osSemaphoreRelease(messageI2C1_LockHandle);
 800b8f4:	4b25      	ldr	r3, [pc, #148]	; (800b98c <ShtTask+0x1d0>)
 800b8f6:	681b      	ldr	r3, [r3, #0]
 800b8f8:	4618      	mov	r0, r3
 800b8fa:	f017 fa6f 	bl	8022ddc <osSemaphoreRelease>

			shtIdx++;
 800b8fe:	8bfb      	ldrh	r3, [r7, #30]
 800b900:	3301      	adds	r3, #1
 800b902:	83fb      	strh	r3, [r7, #30]

			if (shtIdx >= MAX_SHT_SAMPLES_PACKET) {
 800b904:	8bfb      	ldrh	r3, [r7, #30]
 800b906:	2b00      	cmp	r3, #0
 800b908:	d027      	beq.n	800b95a <ShtTask+0x19e>
				header.packetType = SHT;
 800b90a:	4b23      	ldr	r3, [pc, #140]	; (800b998 <ShtTask+0x1dc>)
 800b90c:	220b      	movs	r2, #11
 800b90e:	701a      	strb	r2, [r3, #0]
				header.packetID = shtID;
 800b910:	69bb      	ldr	r3, [r7, #24]
 800b912:	b29a      	uxth	r2, r3
 800b914:	4b20      	ldr	r3, [pc, #128]	; (800b998 <ShtTask+0x1dc>)
 800b916:	805a      	strh	r2, [r3, #2]
				header.msFromStart = HAL_GetTick();
 800b918:	f001 f8b6 	bl	800ca88 <HAL_GetTick>
 800b91c:	4603      	mov	r3, r0
 800b91e:	4a1e      	ldr	r2, [pc, #120]	; (800b998 <ShtTask+0x1dc>)
 800b920:	6053      	str	r3, [r2, #4]
				packet = grabPacket();
 800b922:	f7ff fae9 	bl	800aef8 <grabPacket>
 800b926:	6178      	str	r0, [r7, #20]
				if (packet != NULL) {
 800b928:	697b      	ldr	r3, [r7, #20]
 800b92a:	2b00      	cmp	r3, #0
 800b92c:	d010      	beq.n	800b950 <ShtTask+0x194>
					memcpy(&(packet->header), &header, sizeof(PacketHeader));
 800b92e:	697b      	ldr	r3, [r7, #20]
 800b930:	2224      	movs	r2, #36	; 0x24
 800b932:	4919      	ldr	r1, [pc, #100]	; (800b998 <ShtTask+0x1dc>)
 800b934:	4618      	mov	r0, r3
 800b936:	f020 fbd3 	bl	802c0e0 <memcpy>
					memcpy(packet->payload, shtData, header.payloadLength);
 800b93a:	697b      	ldr	r3, [r7, #20]
 800b93c:	3324      	adds	r3, #36	; 0x24
 800b93e:	4a16      	ldr	r2, [pc, #88]	; (800b998 <ShtTask+0x1dc>)
 800b940:	68d2      	ldr	r2, [r2, #12]
 800b942:	4918      	ldr	r1, [pc, #96]	; (800b9a4 <ShtTask+0x1e8>)
 800b944:	4618      	mov	r0, r3
 800b946:	f020 fbcb 	bl	802c0e0 <memcpy>
					queueUpPacket(packet);
 800b94a:	6978      	ldr	r0, [r7, #20]
 800b94c:	f7ff faf0 	bl	800af30 <queueUpPacket>
				}
				shtID++;
 800b950:	69bb      	ldr	r3, [r7, #24]
 800b952:	3301      	adds	r3, #1
 800b954:	61bb      	str	r3, [r7, #24]
				shtIdx = 0;
 800b956:	2300      	movs	r3, #0
 800b958:	83fb      	strh	r3, [r7, #30]
			}

//			timeLeftForSample = HAL_GetTick();
		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 800b95a:	68fb      	ldr	r3, [r7, #12]
 800b95c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800b960:	2b00      	cmp	r3, #0
 800b962:	f43f af77 	beq.w	800b854 <ShtTask+0x98>
			osTimerDelete(periodicShtTimer_id);
 800b966:	4b0e      	ldr	r3, [pc, #56]	; (800b9a0 <ShtTask+0x1e4>)
 800b968:	681b      	ldr	r3, [r3, #0]
 800b96a:	4618      	mov	r0, r3
 800b96c:	f017 f818 	bl	80229a0 <osTimerDelete>
			break;
 800b970:	e001      	b.n	800b976 <ShtTask+0x1ba>
				continue;
 800b972:	bf00      	nop
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800b974:	e76e      	b.n	800b854 <ShtTask+0x98>
		}
	}
}
 800b976:	bf00      	nop
 800b978:	3724      	adds	r7, #36	; 0x24
 800b97a:	46bd      	mov	sp, r7
 800b97c:	bd90      	pop	{r4, r7, pc}
 800b97e:	bf00      	nop
 800b980:	20002884 	.word	0x20002884
 800b984:	bf800000 	.word	0xbf800000
 800b988:	20002888 	.word	0x20002888
 800b98c:	200003dc 	.word	0x200003dc
 800b990:	20011fa8 	.word	0x20011fa8
 800b994:	20002864 	.word	0x20002864
 800b998:	2000283c 	.word	0x2000283c
 800b99c:	0800b9a9 	.word	0x0800b9a9
 800b9a0:	20002860 	.word	0x20002860
 800b9a4:	20002830 	.word	0x20002830

0800b9a8 <_ZL16triggerShtSamplePv>:

static void triggerShtSample(void *argument) {
 800b9a8:	b580      	push	{r7, lr}
 800b9aa:	b082      	sub	sp, #8
 800b9ac:	af00      	add	r7, sp, #0
 800b9ae:	6078      	str	r0, [r7, #4]
	osThreadFlagsSet(shtTaskHandle, GRAB_SAMPLE_BIT);
 800b9b0:	4b05      	ldr	r3, [pc, #20]	; (800b9c8 <_ZL16triggerShtSamplePv+0x20>)
 800b9b2:	681b      	ldr	r3, [r3, #0]
 800b9b4:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b9b8:	4618      	mov	r0, r3
 800b9ba:	f016 fe47 	bl	802264c <osThreadFlagsSet>
}
 800b9be:	bf00      	nop
 800b9c0:	3708      	adds	r7, #8
 800b9c2:	46bd      	mov	sp, r7
 800b9c4:	bd80      	pop	{r7, pc}
 800b9c6:	bf00      	nop
 800b9c8:	200003c0 	.word	0x200003c0

0800b9cc <_Z41__static_initialization_and_destruction_0ii>:
 800b9cc:	b580      	push	{r7, lr}
 800b9ce:	b082      	sub	sp, #8
 800b9d0:	af00      	add	r7, sp, #0
 800b9d2:	6078      	str	r0, [r7, #4]
 800b9d4:	6039      	str	r1, [r7, #0]
 800b9d6:	687b      	ldr	r3, [r7, #4]
 800b9d8:	2b01      	cmp	r3, #1
 800b9da:	d107      	bne.n	800b9ec <_Z41__static_initialization_and_destruction_0ii+0x20>
 800b9dc:	683b      	ldr	r3, [r7, #0]
 800b9de:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b9e2:	4293      	cmp	r3, r2
 800b9e4:	d102      	bne.n	800b9ec <_Z41__static_initialization_and_destruction_0ii+0x20>
Adafruit_SHT4x sht4 = Adafruit_SHT4x();
 800b9e6:	4809      	ldr	r0, [pc, #36]	; (800ba0c <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800b9e8:	f015 fe04 	bl	80215f4 <_ZN14Adafruit_SHT4xC1Ev>
 800b9ec:	687b      	ldr	r3, [r7, #4]
 800b9ee:	2b00      	cmp	r3, #0
 800b9f0:	d107      	bne.n	800ba02 <_Z41__static_initialization_and_destruction_0ii+0x36>
 800b9f2:	683b      	ldr	r3, [r7, #0]
 800b9f4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b9f8:	4293      	cmp	r3, r2
 800b9fa:	d102      	bne.n	800ba02 <_Z41__static_initialization_and_destruction_0ii+0x36>
 800b9fc:	4803      	ldr	r0, [pc, #12]	; (800ba0c <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800b9fe:	f015 fe16 	bl	802162e <_ZN14Adafruit_SHT4xD1Ev>
}
 800ba02:	bf00      	nop
 800ba04:	3708      	adds	r7, #8
 800ba06:	46bd      	mov	sp, r7
 800ba08:	bd80      	pop	{r7, pc}
 800ba0a:	bf00      	nop
 800ba0c:	20002864 	.word	0x20002864

0800ba10 <_GLOBAL__sub_I_periodicShtTimer_id>:
 800ba10:	b580      	push	{r7, lr}
 800ba12:	af00      	add	r7, sp, #0
 800ba14:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ba18:	2001      	movs	r0, #1
 800ba1a:	f7ff ffd7 	bl	800b9cc <_Z41__static_initialization_and_destruction_0ii>
 800ba1e:	bd80      	pop	{r7, pc}

0800ba20 <_GLOBAL__sub_D_periodicShtTimer_id>:
 800ba20:	b580      	push	{r7, lr}
 800ba22:	af00      	add	r7, sp, #0
 800ba24:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800ba28:	2000      	movs	r0, #0
 800ba2a:	f7ff ffcf 	bl	800b9cc <_Z41__static_initialization_and_destruction_0ii>
 800ba2e:	bd80      	pop	{r7, pc}

0800ba30 <Spec_Task>:
//osThreadId_t specTaskHandle;
osTimerId_t periodicSpecTimer_id;

Adafruit_AS7341 specSensor;

void Spec_Task(void *argument) {
 800ba30:	b590      	push	{r4, r7, lr}
 800ba32:	b089      	sub	sp, #36	; 0x24
 800ba34:	af00      	add	r7, sp, #0
 800ba36:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 800ba38:	2300      	movs	r3, #0
 800ba3a:	617b      	str	r3, [r7, #20]
	uint32_t flags;
	uint32_t timeLeftForSample = 0;
 800ba3c:	2300      	movs	r3, #0
 800ba3e:	613b      	str	r3, [r7, #16]

	osDelay(500);
 800ba40:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ba44:	f016 fed1 	bl	80227ea <osDelay>

	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800ba48:	4b72      	ldr	r3, [pc, #456]	; (800bc14 <Spec_Task+0x1e4>)
 800ba4a:	681b      	ldr	r3, [r3, #0]
 800ba4c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800ba50:	4618      	mov	r0, r3
 800ba52:	f017 f971 	bl	8022d38 <osSemaphoreAcquire>
	if (!specSensor.begin(SPEC_ADDR, &hi2c1, 0)) {
 800ba56:	2300      	movs	r3, #0
 800ba58:	4a6f      	ldr	r2, [pc, #444]	; (800bc18 <Spec_Task+0x1e8>)
 800ba5a:	2139      	movs	r1, #57	; 0x39
 800ba5c:	486f      	ldr	r0, [pc, #444]	; (800bc1c <Spec_Task+0x1ec>)
 800ba5e:	f010 faf3 	bl	801c048 <_ZN15Adafruit_AS73415beginEhP19__I2C_HandleTypeDefl>
 800ba62:	4603      	mov	r3, r0
 800ba64:	f083 0301 	eor.w	r3, r3, #1
 800ba68:	b2db      	uxtb	r3, r3
 800ba6a:	2b00      	cmp	r3, #0
 800ba6c:	d002      	beq.n	800ba74 <Spec_Task+0x44>
		osDelay(100);
 800ba6e:	2064      	movs	r0, #100	; 0x64
 800ba70:	f016 febb 	bl	80227ea <osDelay>
	}
	specSensor.setATIME(100);
 800ba74:	2164      	movs	r1, #100	; 0x64
 800ba76:	4869      	ldr	r0, [pc, #420]	; (800bc1c <Spec_Task+0x1ec>)
 800ba78:	f010 fde3 	bl	801c642 <_ZN15Adafruit_AS73418setATIMEEh>
	specSensor.setASTEP(999);
 800ba7c:	f240 31e7 	movw	r1, #999	; 0x3e7
 800ba80:	4866      	ldr	r0, [pc, #408]	; (800bc1c <Spec_Task+0x1ec>)
 800ba82:	f010 fdef 	bl	801c664 <_ZN15Adafruit_AS73418setASTEPEt>
	specSensor.setGain(AS7341_GAIN_256X);
 800ba86:	2109      	movs	r1, #9
 800ba88:	4864      	ldr	r0, [pc, #400]	; (800bc1c <Spec_Task+0x1ec>)
 800ba8a:	f010 fdfc 	bl	801c686 <_ZN15Adafruit_AS73417setGainE13as7341_gain_t>

	header.payloadLength = MAX_SPEC_SAMPLES_PACKET * sizeof(specSamplePkt);
 800ba8e:	4b64      	ldr	r3, [pc, #400]	; (800bc20 <Spec_Task+0x1f0>)
 800ba90:	2220      	movs	r2, #32
 800ba92:	60da      	str	r2, [r3, #12]
	header.reserved[0] = SPEC_SAMPLE_SYS_PERIOD_MS;
 800ba94:	4b62      	ldr	r3, [pc, #392]	; (800bc20 <Spec_Task+0x1f0>)
 800ba96:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 800ba9a:	611a      	str	r2, [r3, #16]
	header.reserved[1] = SEND_SPEC_EVERY_X_S;
 800ba9c:	4b60      	ldr	r3, [pc, #384]	; (800bc20 <Spec_Task+0x1f0>)
 800ba9e:	2205      	movs	r2, #5
 800baa0:	615a      	str	r2, [r3, #20]

	uint16_t specIdx = 0;
 800baa2:	2300      	movs	r3, #0
 800baa4:	83fb      	strh	r3, [r7, #30]
	uint32_t specID = 0;
 800baa6:	2300      	movs	r3, #0
 800baa8:	61bb      	str	r3, [r7, #24]

	specSensor.startReading();
 800baaa:	485c      	ldr	r0, [pc, #368]	; (800bc1c <Spec_Task+0x1ec>)
 800baac:	f010 fb13 	bl	801c0d6 <_ZN15Adafruit_AS734112startReadingEv>
	osSemaphoreRelease(messageI2C1_LockHandle);
 800bab0:	4b58      	ldr	r3, [pc, #352]	; (800bc14 <Spec_Task+0x1e4>)
 800bab2:	681b      	ldr	r3, [r3, #0]
 800bab4:	4618      	mov	r0, r3
 800bab6:	f017 f991 	bl	8022ddc <osSemaphoreRelease>
	periodicSpecTimer_id = osTimerNew(triggerSpectrometerSample, osTimerPeriodic,
 800baba:	2300      	movs	r3, #0
 800babc:	2200      	movs	r2, #0
 800babe:	2101      	movs	r1, #1
 800bac0:	4858      	ldr	r0, [pc, #352]	; (800bc24 <Spec_Task+0x1f4>)
 800bac2:	f016 fec3 	bl	802284c <osTimerNew>
 800bac6:	4603      	mov	r3, r0
 800bac8:	4a57      	ldr	r2, [pc, #348]	; (800bc28 <Spec_Task+0x1f8>)
 800baca:	6013      	str	r3, [r2, #0]
			NULL, NULL);
	osTimerStart(periodicSpecTimer_id, SPEC_SAMPLE_SYS_PERIOD_MS);
 800bacc:	4b56      	ldr	r3, [pc, #344]	; (800bc28 <Spec_Task+0x1f8>)
 800bace:	681b      	ldr	r3, [r3, #0]
 800bad0:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 800bad4:	4618      	mov	r0, r3
 800bad6:	f016 ff35 	bl	8022944 <osTimerStart>

	while (1) {
		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800bada:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800bade:	2100      	movs	r1, #0
 800bae0:	f44f 7040 	mov.w	r0, #768	; 0x300
 800bae4:	f016 fe00 	bl	80226e8 <osThreadFlagsWait>
 800bae8:	60f8      	str	r0, [r7, #12]
		osFlagsWaitAny, osWaitForever);

		if ((flags & GRAB_SAMPLE_BIT) == GRAB_SAMPLE_BIT) {
 800baea:	68fb      	ldr	r3, [r7, #12]
 800baec:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800baf0:	2b00      	cmp	r3, #0
 800baf2:	d07e      	beq.n	800bbf2 <Spec_Task+0x1c2>
//			timeLeftForSample = HAL_GetTick() - timeLeftForSample;
//			if(timeLeftForSample < SPEC_SAMPLE_PERIOD_MS){
//				osDelay(timeLeftForSample);
//			}

			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800baf4:	4b47      	ldr	r3, [pc, #284]	; (800bc14 <Spec_Task+0x1e4>)
 800baf6:	681b      	ldr	r3, [r3, #0]
 800baf8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800bafc:	4618      	mov	r0, r3
 800bafe:	f017 f91b 	bl	8022d38 <osSemaphoreAcquire>
			while (!specSensor.checkReadingProgress()) {
 800bb02:	4846      	ldr	r0, [pc, #280]	; (800bc1c <Spec_Task+0x1ec>)
 800bb04:	f010 faf7 	bl	801c0f6 <_ZN15Adafruit_AS734120checkReadingProgressEv>
 800bb08:	4603      	mov	r3, r0
 800bb0a:	f083 0301 	eor.w	r3, r3, #1
 800bb0e:	b2db      	uxtb	r3, r3
 800bb10:	2b00      	cmp	r3, #0
 800bb12:	d00f      	beq.n	800bb34 <Spec_Task+0x104>
				osSemaphoreRelease(messageI2C1_LockHandle);
 800bb14:	4b3f      	ldr	r3, [pc, #252]	; (800bc14 <Spec_Task+0x1e4>)
 800bb16:	681b      	ldr	r3, [r3, #0]
 800bb18:	4618      	mov	r0, r3
 800bb1a:	f017 f95f 	bl	8022ddc <osSemaphoreRelease>
				osDelay(5);
 800bb1e:	2005      	movs	r0, #5
 800bb20:	f016 fe63 	bl	80227ea <osDelay>
				osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800bb24:	4b3b      	ldr	r3, [pc, #236]	; (800bc14 <Spec_Task+0x1e4>)
 800bb26:	681b      	ldr	r3, [r3, #0]
 800bb28:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800bb2c:	4618      	mov	r0, r3
 800bb2e:	f017 f903 	bl	8022d38 <osSemaphoreAcquire>
			while (!specSensor.checkReadingProgress()) {
 800bb32:	e7e6      	b.n	800bb02 <Spec_Task+0xd2>
			}

			specData[specIdx].timestamp = HAL_GetTick();
 800bb34:	8bfc      	ldrh	r4, [r7, #30]
 800bb36:	f000 ffa7 	bl	800ca88 <HAL_GetTick>
 800bb3a:	4602      	mov	r2, r0
 800bb3c:	493b      	ldr	r1, [pc, #236]	; (800bc2c <Spec_Task+0x1fc>)
 800bb3e:	0163      	lsls	r3, r4, #5
 800bb40:	440b      	add	r3, r1
 800bb42:	331c      	adds	r3, #28
 800bb44:	601a      	str	r2, [r3, #0]

			specSensor.getAllChannels(specData[specIdx].data.s_array);
 800bb46:	8bfb      	ldrh	r3, [r7, #30]
 800bb48:	015b      	lsls	r3, r3, #5
 800bb4a:	4a38      	ldr	r2, [pc, #224]	; (800bc2c <Spec_Task+0x1fc>)
 800bb4c:	4413      	add	r3, r2
 800bb4e:	4619      	mov	r1, r3
 800bb50:	4832      	ldr	r0, [pc, #200]	; (800bc1c <Spec_Task+0x1ec>)
 800bb52:	f010 fb2f 	bl	801c1b4 <_ZN15Adafruit_AS734114getAllChannelsEPt>

			specData[specIdx].data.s.flicker = specSensor.detectFlickerHz();
 800bb56:	8bfc      	ldrh	r4, [r7, #30]
 800bb58:	4830      	ldr	r0, [pc, #192]	; (800bc1c <Spec_Task+0x1ec>)
 800bb5a:	f010 fda5 	bl	801c6a8 <_ZN15Adafruit_AS734115detectFlickerHzEv>
 800bb5e:	4603      	mov	r3, r0
 800bb60:	4619      	mov	r1, r3
 800bb62:	4a32      	ldr	r2, [pc, #200]	; (800bc2c <Spec_Task+0x1fc>)
 800bb64:	0163      	lsls	r3, r4, #5
 800bb66:	4413      	add	r3, r2
 800bb68:	3318      	adds	r3, #24
 800bb6a:	460a      	mov	r2, r1
 800bb6c:	801a      	strh	r2, [r3, #0]

			osSemaphoreRelease(messageI2C1_LockHandle);
 800bb6e:	4b29      	ldr	r3, [pc, #164]	; (800bc14 <Spec_Task+0x1e4>)
 800bb70:	681b      	ldr	r3, [r3, #0]
 800bb72:	4618      	mov	r0, r3
 800bb74:	f017 f932 	bl	8022ddc <osSemaphoreRelease>

			specIdx++;
 800bb78:	8bfb      	ldrh	r3, [r7, #30]
 800bb7a:	3301      	adds	r3, #1
 800bb7c:	83fb      	strh	r3, [r7, #30]

			if (specIdx >= MAX_SPEC_SAMPLES_PACKET) {
 800bb7e:	8bfb      	ldrh	r3, [r7, #30]
 800bb80:	2b00      	cmp	r3, #0
 800bb82:	d027      	beq.n	800bbd4 <Spec_Task+0x1a4>
				header.packetType = SPECTROMETER;
 800bb84:	4b26      	ldr	r3, [pc, #152]	; (800bc20 <Spec_Task+0x1f0>)
 800bb86:	2203      	movs	r2, #3
 800bb88:	701a      	strb	r2, [r3, #0]
				header.packetID = specID;
 800bb8a:	69bb      	ldr	r3, [r7, #24]
 800bb8c:	b29a      	uxth	r2, r3
 800bb8e:	4b24      	ldr	r3, [pc, #144]	; (800bc20 <Spec_Task+0x1f0>)
 800bb90:	805a      	strh	r2, [r3, #2]
				header.msFromStart = HAL_GetTick();
 800bb92:	f000 ff79 	bl	800ca88 <HAL_GetTick>
 800bb96:	4603      	mov	r3, r0
 800bb98:	4a21      	ldr	r2, [pc, #132]	; (800bc20 <Spec_Task+0x1f0>)
 800bb9a:	6053      	str	r3, [r2, #4]
				packet = grabPacket();
 800bb9c:	f7ff f9ac 	bl	800aef8 <grabPacket>
 800bba0:	6178      	str	r0, [r7, #20]
				if (packet != NULL) {
 800bba2:	697b      	ldr	r3, [r7, #20]
 800bba4:	2b00      	cmp	r3, #0
 800bba6:	d010      	beq.n	800bbca <Spec_Task+0x19a>
					memcpy(&(packet->header), &header, sizeof(PacketHeader));
 800bba8:	697b      	ldr	r3, [r7, #20]
 800bbaa:	2224      	movs	r2, #36	; 0x24
 800bbac:	491c      	ldr	r1, [pc, #112]	; (800bc20 <Spec_Task+0x1f0>)
 800bbae:	4618      	mov	r0, r3
 800bbb0:	f020 fa96 	bl	802c0e0 <memcpy>
					memcpy(packet->payload, specData, header.payloadLength);
 800bbb4:	697b      	ldr	r3, [r7, #20]
 800bbb6:	3324      	adds	r3, #36	; 0x24
 800bbb8:	4a19      	ldr	r2, [pc, #100]	; (800bc20 <Spec_Task+0x1f0>)
 800bbba:	68d2      	ldr	r2, [r2, #12]
 800bbbc:	491b      	ldr	r1, [pc, #108]	; (800bc2c <Spec_Task+0x1fc>)
 800bbbe:	4618      	mov	r0, r3
 800bbc0:	f020 fa8e 	bl	802c0e0 <memcpy>
					queueUpPacket(packet);
 800bbc4:	6978      	ldr	r0, [r7, #20]
 800bbc6:	f7ff f9b3 	bl	800af30 <queueUpPacket>
				}
				specID++;
 800bbca:	69bb      	ldr	r3, [r7, #24]
 800bbcc:	3301      	adds	r3, #1
 800bbce:	61bb      	str	r3, [r7, #24]
				specIdx = 0;
 800bbd0:	2300      	movs	r3, #0
 800bbd2:	83fb      	strh	r3, [r7, #30]
			}

			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800bbd4:	4b0f      	ldr	r3, [pc, #60]	; (800bc14 <Spec_Task+0x1e4>)
 800bbd6:	681b      	ldr	r3, [r3, #0]
 800bbd8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800bbdc:	4618      	mov	r0, r3
 800bbde:	f017 f8ab 	bl	8022d38 <osSemaphoreAcquire>
			specSensor.startReading();
 800bbe2:	480e      	ldr	r0, [pc, #56]	; (800bc1c <Spec_Task+0x1ec>)
 800bbe4:	f010 fa77 	bl	801c0d6 <_ZN15Adafruit_AS734112startReadingEv>
			osSemaphoreRelease(messageI2C1_LockHandle);
 800bbe8:	4b0a      	ldr	r3, [pc, #40]	; (800bc14 <Spec_Task+0x1e4>)
 800bbea:	681b      	ldr	r3, [r3, #0]
 800bbec:	4618      	mov	r0, r3
 800bbee:	f017 f8f5 	bl	8022ddc <osSemaphoreRelease>

//			timeLeftForSample = HAL_GetTick();
		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 800bbf2:	68fb      	ldr	r3, [r7, #12]
 800bbf4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800bbf8:	2b00      	cmp	r3, #0
 800bbfa:	f43f af6e 	beq.w	800bada <Spec_Task+0xaa>
			osTimerDelete(periodicSpecTimer_id);
 800bbfe:	4b0a      	ldr	r3, [pc, #40]	; (800bc28 <Spec_Task+0x1f8>)
 800bc00:	681b      	ldr	r3, [r3, #0]
 800bc02:	4618      	mov	r0, r3
 800bc04:	f016 fecc 	bl	80229a0 <osTimerDelete>
			break;
 800bc08:	bf00      	nop
		}
	}
}
 800bc0a:	bf00      	nop
 800bc0c:	3724      	adds	r7, #36	; 0x24
 800bc0e:	46bd      	mov	sp, r7
 800bc10:	bd90      	pop	{r4, r7, pc}
 800bc12:	bf00      	nop
 800bc14:	200003dc 	.word	0x200003dc
 800bc18:	20011fa8 	.word	0x20011fa8
 800bc1c:	200028d4 	.word	0x200028d4
 800bc20:	200028ac 	.word	0x200028ac
 800bc24:	0800bc31 	.word	0x0800bc31
 800bc28:	200028d0 	.word	0x200028d0
 800bc2c:	2000288c 	.word	0x2000288c

0800bc30 <_ZL25triggerSpectrometerSamplePv>:

static void triggerSpectrometerSample(void *argument) {
 800bc30:	b580      	push	{r7, lr}
 800bc32:	b082      	sub	sp, #8
 800bc34:	af00      	add	r7, sp, #0
 800bc36:	6078      	str	r0, [r7, #4]
	osThreadFlagsSet(specTaskHandle, GRAB_SAMPLE_BIT);
 800bc38:	4b05      	ldr	r3, [pc, #20]	; (800bc50 <_ZL25triggerSpectrometerSamplePv+0x20>)
 800bc3a:	681b      	ldr	r3, [r3, #0]
 800bc3c:	f44f 7180 	mov.w	r1, #256	; 0x100
 800bc40:	4618      	mov	r0, r3
 800bc42:	f016 fd03 	bl	802264c <osThreadFlagsSet>
}
 800bc46:	bf00      	nop
 800bc48:	3708      	adds	r7, #8
 800bc4a:	46bd      	mov	sp, r7
 800bc4c:	bd80      	pop	{r7, pc}
 800bc4e:	bf00      	nop
 800bc50:	200003b8 	.word	0x200003b8

0800bc54 <_Z41__static_initialization_and_destruction_0ii>:
 800bc54:	b580      	push	{r7, lr}
 800bc56:	b082      	sub	sp, #8
 800bc58:	af00      	add	r7, sp, #0
 800bc5a:	6078      	str	r0, [r7, #4]
 800bc5c:	6039      	str	r1, [r7, #0]
 800bc5e:	687b      	ldr	r3, [r7, #4]
 800bc60:	2b01      	cmp	r3, #1
 800bc62:	d107      	bne.n	800bc74 <_Z41__static_initialization_and_destruction_0ii+0x20>
 800bc64:	683b      	ldr	r3, [r7, #0]
 800bc66:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800bc6a:	4293      	cmp	r3, r2
 800bc6c:	d102      	bne.n	800bc74 <_Z41__static_initialization_and_destruction_0ii+0x20>
Adafruit_AS7341 specSensor;
 800bc6e:	4809      	ldr	r0, [pc, #36]	; (800bc94 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800bc70:	f010 f9c0 	bl	801bff4 <_ZN15Adafruit_AS7341C1Ev>
 800bc74:	687b      	ldr	r3, [r7, #4]
 800bc76:	2b00      	cmp	r3, #0
 800bc78:	d107      	bne.n	800bc8a <_Z41__static_initialization_and_destruction_0ii+0x36>
 800bc7a:	683b      	ldr	r3, [r7, #0]
 800bc7c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800bc80:	4293      	cmp	r3, r2
 800bc82:	d102      	bne.n	800bc8a <_Z41__static_initialization_and_destruction_0ii+0x36>
 800bc84:	4803      	ldr	r0, [pc, #12]	; (800bc94 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800bc86:	f010 f9cf 	bl	801c028 <_ZN15Adafruit_AS7341D1Ev>
}
 800bc8a:	bf00      	nop
 800bc8c:	3708      	adds	r7, #8
 800bc8e:	46bd      	mov	sp, r7
 800bc90:	bd80      	pop	{r7, pc}
 800bc92:	bf00      	nop
 800bc94:	200028d4 	.word	0x200028d4

0800bc98 <_GLOBAL__sub_I_periodicSpecTimer_id>:
 800bc98:	b580      	push	{r7, lr}
 800bc9a:	af00      	add	r7, sp, #0
 800bc9c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800bca0:	2001      	movs	r0, #1
 800bca2:	f7ff ffd7 	bl	800bc54 <_Z41__static_initialization_and_destruction_0ii>
 800bca6:	bd80      	pop	{r7, pc}

0800bca8 <_GLOBAL__sub_D_periodicSpecTimer_id>:
 800bca8:	b580      	push	{r7, lr}
 800bcaa:	af00      	add	r7, sp, #0
 800bcac:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800bcb0:	2000      	movs	r0, #0
 800bcb2:	f7ff ffcf 	bl	800bc54 <_Z41__static_initialization_and_destruction_0ii>
 800bcb6:	bd80      	pop	{r7, pc}

0800bcb8 <LL_AHB2_GRP1_EnableClock>:
{
 800bcb8:	b480      	push	{r7}
 800bcba:	b085      	sub	sp, #20
 800bcbc:	af00      	add	r7, sp, #0
 800bcbe:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800bcc0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bcc4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800bcc6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800bcca:	687b      	ldr	r3, [r7, #4]
 800bccc:	4313      	orrs	r3, r2
 800bcce:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800bcd0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bcd4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800bcd6:	687b      	ldr	r3, [r7, #4]
 800bcd8:	4013      	ands	r3, r2
 800bcda:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800bcdc:	68fb      	ldr	r3, [r7, #12]
}
 800bcde:	bf00      	nop
 800bce0:	3714      	adds	r7, #20
 800bce2:	46bd      	mov	sp, r7
 800bce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bce8:	4770      	bx	lr

0800bcea <LL_APB1_GRP1_EnableClock>:
{
 800bcea:	b480      	push	{r7}
 800bcec:	b085      	sub	sp, #20
 800bcee:	af00      	add	r7, sp, #0
 800bcf0:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 800bcf2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bcf6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800bcf8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800bcfc:	687b      	ldr	r3, [r7, #4]
 800bcfe:	4313      	orrs	r3, r2
 800bd00:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800bd02:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd06:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	4013      	ands	r3, r2
 800bd0c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800bd0e:	68fb      	ldr	r3, [r7, #12]
}
 800bd10:	bf00      	nop
 800bd12:	3714      	adds	r7, #20
 800bd14:	46bd      	mov	sp, r7
 800bd16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd1a:	4770      	bx	lr

0800bd1c <LL_APB2_GRP1_EnableClock>:
{
 800bd1c:	b480      	push	{r7}
 800bd1e:	b085      	sub	sp, #20
 800bd20:	af00      	add	r7, sp, #0
 800bd22:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2ENR, Periphs);
 800bd24:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd28:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800bd2a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800bd2e:	687b      	ldr	r3, [r7, #4]
 800bd30:	4313      	orrs	r3, r2
 800bd32:	660b      	str	r3, [r1, #96]	; 0x60
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800bd34:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bd38:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800bd3a:	687b      	ldr	r3, [r7, #4]
 800bd3c:	4013      	ands	r3, r2
 800bd3e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800bd40:	68fb      	ldr	r3, [r7, #12]
}
 800bd42:	bf00      	nop
 800bd44:	3714      	adds	r7, #20
 800bd46:	46bd      	mov	sp, r7
 800bd48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd4c:	4770      	bx	lr
	...

0800bd50 <MX_SPI1_Init>:
SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi2;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 800bd50:	b580      	push	{r7, lr}
 800bd52:	af00      	add	r7, sp, #0
  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
 800bd54:	4b1b      	ldr	r3, [pc, #108]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd56:	4a1c      	ldr	r2, [pc, #112]	; (800bdc8 <MX_SPI1_Init+0x78>)
 800bd58:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 800bd5a:	4b1a      	ldr	r3, [pc, #104]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd5c:	f44f 7282 	mov.w	r2, #260	; 0x104
 800bd60:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800bd62:	4b18      	ldr	r3, [pc, #96]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd64:	2200      	movs	r2, #0
 800bd66:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800bd68:	4b16      	ldr	r3, [pc, #88]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd6a:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800bd6e:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800bd70:	4b14      	ldr	r3, [pc, #80]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd72:	2200      	movs	r2, #0
 800bd74:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 800bd76:	4b13      	ldr	r3, [pc, #76]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd78:	2200      	movs	r2, #0
 800bd7a:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 800bd7c:	4b11      	ldr	r3, [pc, #68]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd7e:	f44f 7200 	mov.w	r2, #512	; 0x200
 800bd82:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800bd84:	4b0f      	ldr	r3, [pc, #60]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd86:	2208      	movs	r2, #8
 800bd88:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800bd8a:	4b0e      	ldr	r3, [pc, #56]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd8c:	2200      	movs	r2, #0
 800bd8e:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800bd90:	4b0c      	ldr	r3, [pc, #48]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd92:	2200      	movs	r2, #0
 800bd94:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800bd96:	4b0b      	ldr	r3, [pc, #44]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd98:	2200      	movs	r2, #0
 800bd9a:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 800bd9c:	4b09      	ldr	r3, [pc, #36]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bd9e:	2207      	movs	r2, #7
 800bda0:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800bda2:	4b08      	ldr	r3, [pc, #32]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bda4:	2200      	movs	r2, #0
 800bda6:	631a      	str	r2, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800bda8:	4b06      	ldr	r3, [pc, #24]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bdaa:	2208      	movs	r2, #8
 800bdac:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800bdae:	4805      	ldr	r0, [pc, #20]	; (800bdc4 <MX_SPI1_Init+0x74>)
 800bdb0:	f008 fa08 	bl	80141c4 <HAL_SPI_Init>
 800bdb4:	4603      	mov	r3, r0
 800bdb6:	2b00      	cmp	r3, #0
 800bdb8:	d001      	beq.n	800bdbe <MX_SPI1_Init+0x6e>
  {
    Error_Handler();
 800bdba:	f7ff f897 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 800bdbe:	bf00      	nop
 800bdc0:	bd80      	pop	{r7, pc}
 800bdc2:	bf00      	nop
 800bdc4:	200121f0 	.word	0x200121f0
 800bdc8:	40013000 	.word	0x40013000

0800bdcc <MX_SPI2_Init>:
/* SPI2 init function */
void MX_SPI2_Init(void)
{
 800bdcc:	b580      	push	{r7, lr}
 800bdce:	af00      	add	r7, sp, #0
  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  hspi2.Instance = SPI2;
 800bdd0:	4b1b      	ldr	r3, [pc, #108]	; (800be40 <MX_SPI2_Init+0x74>)
 800bdd2:	4a1c      	ldr	r2, [pc, #112]	; (800be44 <MX_SPI2_Init+0x78>)
 800bdd4:	601a      	str	r2, [r3, #0]
  hspi2.Init.Mode = SPI_MODE_MASTER;
 800bdd6:	4b1a      	ldr	r3, [pc, #104]	; (800be40 <MX_SPI2_Init+0x74>)
 800bdd8:	f44f 7282 	mov.w	r2, #260	; 0x104
 800bddc:	605a      	str	r2, [r3, #4]
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
 800bdde:	4b18      	ldr	r3, [pc, #96]	; (800be40 <MX_SPI2_Init+0x74>)
 800bde0:	2200      	movs	r2, #0
 800bde2:	609a      	str	r2, [r3, #8]
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 800bde4:	4b16      	ldr	r3, [pc, #88]	; (800be40 <MX_SPI2_Init+0x74>)
 800bde6:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800bdea:	60da      	str	r2, [r3, #12]
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
 800bdec:	4b14      	ldr	r3, [pc, #80]	; (800be40 <MX_SPI2_Init+0x74>)
 800bdee:	2200      	movs	r2, #0
 800bdf0:	611a      	str	r2, [r3, #16]
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
 800bdf2:	4b13      	ldr	r3, [pc, #76]	; (800be40 <MX_SPI2_Init+0x74>)
 800bdf4:	2200      	movs	r2, #0
 800bdf6:	615a      	str	r2, [r3, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 800bdf8:	4b11      	ldr	r3, [pc, #68]	; (800be40 <MX_SPI2_Init+0x74>)
 800bdfa:	f44f 7200 	mov.w	r2, #512	; 0x200
 800bdfe:	619a      	str	r2, [r3, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 800be00:	4b0f      	ldr	r3, [pc, #60]	; (800be40 <MX_SPI2_Init+0x74>)
 800be02:	2218      	movs	r2, #24
 800be04:	61da      	str	r2, [r3, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800be06:	4b0e      	ldr	r3, [pc, #56]	; (800be40 <MX_SPI2_Init+0x74>)
 800be08:	2200      	movs	r2, #0
 800be0a:	621a      	str	r2, [r3, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 800be0c:	4b0c      	ldr	r3, [pc, #48]	; (800be40 <MX_SPI2_Init+0x74>)
 800be0e:	2200      	movs	r2, #0
 800be10:	625a      	str	r2, [r3, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800be12:	4b0b      	ldr	r3, [pc, #44]	; (800be40 <MX_SPI2_Init+0x74>)
 800be14:	2200      	movs	r2, #0
 800be16:	629a      	str	r2, [r3, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 7;
 800be18:	4b09      	ldr	r3, [pc, #36]	; (800be40 <MX_SPI2_Init+0x74>)
 800be1a:	2207      	movs	r2, #7
 800be1c:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800be1e:	4b08      	ldr	r3, [pc, #32]	; (800be40 <MX_SPI2_Init+0x74>)
 800be20:	2200      	movs	r2, #0
 800be22:	631a      	str	r2, [r3, #48]	; 0x30
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800be24:	4b06      	ldr	r3, [pc, #24]	; (800be40 <MX_SPI2_Init+0x74>)
 800be26:	2208      	movs	r2, #8
 800be28:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 800be2a:	4805      	ldr	r0, [pc, #20]	; (800be40 <MX_SPI2_Init+0x74>)
 800be2c:	f008 f9ca 	bl	80141c4 <HAL_SPI_Init>
 800be30:	4603      	mov	r3, r0
 800be32:	2b00      	cmp	r3, #0
 800be34:	d001      	beq.n	800be3a <MX_SPI2_Init+0x6e>
  {
    Error_Handler();
 800be36:	f7ff f859 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}
 800be3a:	bf00      	nop
 800be3c:	bd80      	pop	{r7, pc}
 800be3e:	bf00      	nop
 800be40:	2001218c 	.word	0x2001218c
 800be44:	40003800 	.word	0x40003800

0800be48 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 800be48:	b580      	push	{r7, lr}
 800be4a:	b088      	sub	sp, #32
 800be4c:	af00      	add	r7, sp, #0
 800be4e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800be50:	f107 030c 	add.w	r3, r7, #12
 800be54:	2200      	movs	r2, #0
 800be56:	601a      	str	r2, [r3, #0]
 800be58:	605a      	str	r2, [r3, #4]
 800be5a:	609a      	str	r2, [r3, #8]
 800be5c:	60da      	str	r2, [r3, #12]
 800be5e:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 800be60:	687b      	ldr	r3, [r7, #4]
 800be62:	681b      	ldr	r3, [r3, #0]
 800be64:	4a27      	ldr	r2, [pc, #156]	; (800bf04 <HAL_SPI_MspInit+0xbc>)
 800be66:	4293      	cmp	r3, r2
 800be68:	d117      	bne.n	800be9a <HAL_SPI_MspInit+0x52>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 800be6a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800be6e:	f7ff ff55 	bl	800bd1c <LL_APB2_GRP1_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800be72:	2002      	movs	r0, #2
 800be74:	f7ff ff20 	bl	800bcb8 <LL_AHB2_GRP1_EnableClock>
    /**SPI1 GPIO Configuration
    PB5     ------> SPI1_MOSI
    PB4     ------> SPI1_MISO
    PB3     ------> SPI1_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_4|GPIO_PIN_3;
 800be78:	2338      	movs	r3, #56	; 0x38
 800be7a:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800be7c:	2302      	movs	r3, #2
 800be7e:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800be80:	2300      	movs	r3, #0
 800be82:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800be84:	2300      	movs	r3, #0
 800be86:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 800be88:	2305      	movs	r3, #5
 800be8a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800be8c:	f107 030c 	add.w	r3, r7, #12
 800be90:	4619      	mov	r1, r3
 800be92:	481d      	ldr	r0, [pc, #116]	; (800bf08 <HAL_SPI_MspInit+0xc0>)
 800be94:	f001 ffe0 	bl	800de58 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
}
 800be98:	e02f      	b.n	800befa <HAL_SPI_MspInit+0xb2>
  else if(spiHandle->Instance==SPI2)
 800be9a:	687b      	ldr	r3, [r7, #4]
 800be9c:	681b      	ldr	r3, [r3, #0]
 800be9e:	4a1b      	ldr	r2, [pc, #108]	; (800bf0c <HAL_SPI_MspInit+0xc4>)
 800bea0:	4293      	cmp	r3, r2
 800bea2:	d12a      	bne.n	800befa <HAL_SPI_MspInit+0xb2>
    __HAL_RCC_SPI2_CLK_ENABLE();
 800bea4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800bea8:	f7ff ff1f 	bl	800bcea <LL_APB1_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800beac:	2008      	movs	r0, #8
 800beae:	f7ff ff03 	bl	800bcb8 <LL_AHB2_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800beb2:	2002      	movs	r0, #2
 800beb4:	f7ff ff00 	bl	800bcb8 <LL_AHB2_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 800beb8:	2302      	movs	r3, #2
 800beba:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bebc:	2302      	movs	r3, #2
 800bebe:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bec0:	2300      	movs	r3, #0
 800bec2:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800bec4:	2300      	movs	r3, #0
 800bec6:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800bec8:	2305      	movs	r3, #5
 800beca:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800becc:	f107 030c 	add.w	r3, r7, #12
 800bed0:	4619      	mov	r1, r3
 800bed2:	480f      	ldr	r0, [pc, #60]	; (800bf10 <HAL_SPI_MspInit+0xc8>)
 800bed4:	f001 ffc0 	bl	800de58 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
 800bed8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800bedc:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800bede:	2302      	movs	r3, #2
 800bee0:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800bee2:	2300      	movs	r3, #0
 800bee4:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800bee6:	2300      	movs	r3, #0
 800bee8:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800beea:	2305      	movs	r3, #5
 800beec:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800beee:	f107 030c 	add.w	r3, r7, #12
 800bef2:	4619      	mov	r1, r3
 800bef4:	4804      	ldr	r0, [pc, #16]	; (800bf08 <HAL_SPI_MspInit+0xc0>)
 800bef6:	f001 ffaf 	bl	800de58 <HAL_GPIO_Init>
}
 800befa:	bf00      	nop
 800befc:	3720      	adds	r7, #32
 800befe:	46bd      	mov	sp, r7
 800bf00:	bd80      	pop	{r7, pc}
 800bf02:	bf00      	nop
 800bf04:	40013000 	.word	0x40013000
 800bf08:	48000400 	.word	0x48000400
 800bf0c:	40003800 	.word	0x40003800
 800bf10:	48000c00 	.word	0x48000c00

0800bf14 <LL_AHB3_GRP1_EnableClock>:
{
 800bf14:	b480      	push	{r7}
 800bf16:	b085      	sub	sp, #20
 800bf18:	af00      	add	r7, sp, #0
 800bf1a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 800bf1c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf20:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800bf22:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800bf26:	687b      	ldr	r3, [r7, #4]
 800bf28:	4313      	orrs	r3, r2
 800bf2a:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800bf2c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf30:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800bf32:	687b      	ldr	r3, [r7, #4]
 800bf34:	4013      	ands	r3, r2
 800bf36:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800bf38:	68fb      	ldr	r3, [r7, #12]
}
 800bf3a:	bf00      	nop
 800bf3c:	3714      	adds	r7, #20
 800bf3e:	46bd      	mov	sp, r7
 800bf40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf44:	4770      	bx	lr

0800bf46 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800bf46:	b580      	push	{r7, lr}
 800bf48:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_HSEM_CLK_ENABLE();
 800bf4a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800bf4e:	f7ff ffe1 	bl	800bf14 <LL_AHB3_GRP1_EnableClock>

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 800bf52:	2200      	movs	r2, #0
 800bf54:	210f      	movs	r1, #15
 800bf56:	f06f 0001 	mvn.w	r0, #1
 800bf5a:	f001 fd6f 	bl	800da3c <HAL_NVIC_SetPriority>

  /* Peripheral interrupt init */
  /* HSEM_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(HSEM_IRQn, 5, 0);
 800bf5e:	2200      	movs	r2, #0
 800bf60:	2105      	movs	r1, #5
 800bf62:	202e      	movs	r0, #46	; 0x2e
 800bf64:	f001 fd6a 	bl	800da3c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(HSEM_IRQn);
 800bf68:	202e      	movs	r0, #46	; 0x2e
 800bf6a:	f001 fd81 	bl	800da70 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800bf6e:	bf00      	nop
 800bf70:	bd80      	pop	{r7, pc}

0800bf72 <LL_APB2_GRP1_EnableClock>:
{
 800bf72:	b480      	push	{r7}
 800bf74:	b085      	sub	sp, #20
 800bf76:	af00      	add	r7, sp, #0
 800bf78:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2ENR, Periphs);
 800bf7a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf7e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800bf80:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800bf84:	687b      	ldr	r3, [r7, #4]
 800bf86:	4313      	orrs	r3, r2
 800bf88:	660b      	str	r3, [r1, #96]	; 0x60
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800bf8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800bf8e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800bf90:	687b      	ldr	r3, [r7, #4]
 800bf92:	4013      	ands	r3, r2
 800bf94:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800bf96:	68fb      	ldr	r3, [r7, #12]
}
 800bf98:	bf00      	nop
 800bf9a:	3714      	adds	r7, #20
 800bf9c:	46bd      	mov	sp, r7
 800bf9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfa2:	4770      	bx	lr

0800bfa4 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800bfa4:	b580      	push	{r7, lr}
 800bfa6:	b08c      	sub	sp, #48	; 0x30
 800bfa8:	af00      	add	r7, sp, #0
 800bfaa:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 800bfac:	2300      	movs	r3, #0
 800bfae:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
 800bfb0:	2300      	movs	r3, #0
 800bfb2:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0);
 800bfb4:	2200      	movs	r2, #0
 800bfb6:	6879      	ldr	r1, [r7, #4]
 800bfb8:	2019      	movs	r0, #25
 800bfba:	f001 fd3f 	bl	800da3c <HAL_NVIC_SetPriority>

  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 800bfbe:	2019      	movs	r0, #25
 800bfc0:	f001 fd56 	bl	800da70 <HAL_NVIC_EnableIRQ>

  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 800bfc4:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800bfc8:	f7ff ffd3 	bl	800bf72 <LL_APB2_GRP1_EnableClock>

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800bfcc:	f107 0208 	add.w	r2, r7, #8
 800bfd0:	f107 030c 	add.w	r3, r7, #12
 800bfd4:	4611      	mov	r1, r2
 800bfd6:	4618      	mov	r0, r3
 800bfd8:	f005 fffe 	bl	8011fd8 <HAL_RCC_GetClockConfig>

  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 800bfdc:	f005 ffe6 	bl	8011fac <HAL_RCC_GetPCLK2Freq>
 800bfe0:	62f8      	str	r0, [r7, #44]	; 0x2c
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800bfe2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bfe4:	4a12      	ldr	r2, [pc, #72]	; (800c030 <HAL_InitTick+0x8c>)
 800bfe6:	fba2 2303 	umull	r2, r3, r2, r3
 800bfea:	0c9b      	lsrs	r3, r3, #18
 800bfec:	3b01      	subs	r3, #1
 800bfee:	62bb      	str	r3, [r7, #40]	; 0x28

  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 800bff0:	4b10      	ldr	r3, [pc, #64]	; (800c034 <HAL_InitTick+0x90>)
 800bff2:	4a11      	ldr	r2, [pc, #68]	; (800c038 <HAL_InitTick+0x94>)
 800bff4:	601a      	str	r2, [r3, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 800bff6:	4b0f      	ldr	r3, [pc, #60]	; (800c034 <HAL_InitTick+0x90>)
 800bff8:	f240 32e7 	movw	r2, #999	; 0x3e7
 800bffc:	60da      	str	r2, [r3, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 800bffe:	4a0d      	ldr	r2, [pc, #52]	; (800c034 <HAL_InitTick+0x90>)
 800c000:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c002:	6053      	str	r3, [r2, #4]
  htim1.Init.ClockDivision = 0;
 800c004:	4b0b      	ldr	r3, [pc, #44]	; (800c034 <HAL_InitTick+0x90>)
 800c006:	2200      	movs	r2, #0
 800c008:	611a      	str	r2, [r3, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 800c00a:	4b0a      	ldr	r3, [pc, #40]	; (800c034 <HAL_InitTick+0x90>)
 800c00c:	2200      	movs	r2, #0
 800c00e:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800c010:	4808      	ldr	r0, [pc, #32]	; (800c034 <HAL_InitTick+0x90>)
 800c012:	f008 ffe7 	bl	8014fe4 <HAL_TIM_Base_Init>
 800c016:	4603      	mov	r3, r0
 800c018:	2b00      	cmp	r3, #0
 800c01a:	d104      	bne.n	800c026 <HAL_InitTick+0x82>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
 800c01c:	4805      	ldr	r0, [pc, #20]	; (800c034 <HAL_InitTick+0x90>)
 800c01e:	f009 f839 	bl	8015094 <HAL_TIM_Base_Start_IT>
 800c022:	4603      	mov	r3, r0
 800c024:	e000      	b.n	800c028 <HAL_InitTick+0x84>
  }

  /* Return function status */
  return HAL_ERROR;
 800c026:	2301      	movs	r3, #1
}
 800c028:	4618      	mov	r0, r3
 800c02a:	3730      	adds	r7, #48	; 0x30
 800c02c:	46bd      	mov	sp, r7
 800c02e:	bd80      	pop	{r7, pc}
 800c030:	431bde83 	.word	0x431bde83
 800c034:	20012254 	.word	0x20012254
 800c038:	40012c00 	.word	0x40012c00

0800c03c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800c03c:	b480      	push	{r7}
 800c03e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800c040:	e7fe      	b.n	800c040 <NMI_Handler+0x4>

0800c042 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800c042:	b480      	push	{r7}
 800c044:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800c046:	e7fe      	b.n	800c046 <HardFault_Handler+0x4>

0800c048 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800c048:	b480      	push	{r7}
 800c04a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800c04c:	e7fe      	b.n	800c04c <MemManage_Handler+0x4>

0800c04e <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800c04e:	b480      	push	{r7}
 800c050:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800c052:	e7fe      	b.n	800c052 <BusFault_Handler+0x4>

0800c054 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800c054:	b480      	push	{r7}
 800c056:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800c058:	e7fe      	b.n	800c058 <UsageFault_Handler+0x4>

0800c05a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800c05a:	b480      	push	{r7}
 800c05c:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800c05e:	bf00      	nop
 800c060:	46bd      	mov	sp, r7
 800c062:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c066:	4770      	bx	lr

0800c068 <EXTI2_IRQHandler>:

/**
  * @brief This function handles EXTI line2 interrupt.
  */
void EXTI2_IRQHandler(void)
{
 800c068:	b580      	push	{r7, lr}
 800c06a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI2_IRQn 0 */

  /* USER CODE END EXTI2_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(IMU_INT_Pin);
 800c06c:	2004      	movs	r0, #4
 800c06e:	f002 f87b 	bl	800e168 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI2_IRQn 1 */

  /* USER CODE END EXTI2_IRQn 1 */
}
 800c072:	bf00      	nop
 800c074:	bd80      	pop	{r7, pc}
	...

0800c078 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 800c078:	b580      	push	{r7, lr}
 800c07a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 800c07c:	4802      	ldr	r0, [pc, #8]	; (800c088 <DMA1_Channel1_IRQHandler+0x10>)
 800c07e:	f001 fdd7 	bl	800dc30 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 800c082:	bf00      	nop
 800c084:	bd80      	pop	{r7, pc}
 800c086:	bf00      	nop
 800c088:	20011ef0 	.word	0x20011ef0

0800c08c <DMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
 800c08c:	b580      	push	{r7, lr}
 800c08e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 800c090:	4802      	ldr	r0, [pc, #8]	; (800c09c <DMA1_Channel2_IRQHandler+0x10>)
 800c092:	f001 fdcd 	bl	800dc30 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}
 800c096:	bf00      	nop
 800c098:	bd80      	pop	{r7, pc}
 800c09a:	bf00      	nop
 800c09c:	20012094 	.word	0x20012094

0800c0a0 <USB_LP_IRQHandler>:

/**
  * @brief This function handles USB low priority interrupt, USB wake-up interrupt through EXTI line 28.
  */
void USB_LP_IRQHandler(void)
{
 800c0a0:	b580      	push	{r7, lr}
 800c0a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_LP_IRQn 0 */

  /* USER CODE END USB_LP_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 800c0a4:	4802      	ldr	r0, [pc, #8]	; (800c0b0 <USB_LP_IRQHandler+0x10>)
 800c0a6:	f003 fa58 	bl	800f55a <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN USB_LP_IRQn 1 */

  /* USER CODE END USB_LP_IRQn 1 */
}
 800c0aa:	bf00      	nop
 800c0ac:	bd80      	pop	{r7, pc}
 800c0ae:	bf00      	nop
 800c0b0:	200138a8 	.word	0x200138a8

0800c0b4 <TIM1_UP_TIM16_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM16 global interrupt.
  */
void TIM1_UP_TIM16_IRQHandler(void)
{
 800c0b4:	b580      	push	{r7, lr}
 800c0b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 800c0b8:	4803      	ldr	r0, [pc, #12]	; (800c0c8 <TIM1_UP_TIM16_IRQHandler+0x14>)
 800c0ba:	f009 f8fb 	bl	80152b4 <HAL_TIM_IRQHandler>
  HAL_TIM_IRQHandler(&htim16);
 800c0be:	4803      	ldr	r0, [pc, #12]	; (800c0cc <TIM1_UP_TIM16_IRQHandler+0x18>)
 800c0c0:	f009 f8f8 	bl	80152b4 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 1 */
}
 800c0c4:	bf00      	nop
 800c0c6:	bd80      	pop	{r7, pc}
 800c0c8:	20012254 	.word	0x20012254
 800c0cc:	200122ec 	.word	0x200122ec

0800c0d0 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 800c0d0:	b580      	push	{r7, lr}
 800c0d2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 800c0d4:	4802      	ldr	r0, [pc, #8]	; (800c0e0 <TIM2_IRQHandler+0x10>)
 800c0d6:	f009 f8ed 	bl	80152b4 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 800c0da:	bf00      	nop
 800c0dc:	bd80      	pop	{r7, pc}
 800c0de:	bf00      	nop
 800c0e0:	200122a0 	.word	0x200122a0

0800c0e4 <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 800c0e4:	b580      	push	{r7, lr}
 800c0e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 800c0e8:	4802      	ldr	r0, [pc, #8]	; (800c0f4 <I2C1_EV_IRQHandler+0x10>)
 800c0ea:	f002 fd21 	bl	800eb30 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 800c0ee:	bf00      	nop
 800c0f0:	bd80      	pop	{r7, pc}
 800c0f2:	bf00      	nop
 800c0f4:	20011fa8 	.word	0x20011fa8

0800c0f8 <I2C3_EV_IRQHandler>:

/**
  * @brief This function handles I2C3 event interrupt.
  */
void I2C3_EV_IRQHandler(void)
{
 800c0f8:	b580      	push	{r7, lr}
 800c0fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C3_EV_IRQn 0 */

  /* USER CODE END I2C3_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c3);
 800c0fc:	4802      	ldr	r0, [pc, #8]	; (800c108 <I2C3_EV_IRQHandler+0x10>)
 800c0fe:	f002 fd17 	bl	800eb30 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C3_EV_IRQn 1 */

  /* USER CODE END I2C3_EV_IRQn 1 */
}
 800c102:	bf00      	nop
 800c104:	bd80      	pop	{r7, pc}
 800c106:	bf00      	nop
 800c108:	20011f5c 	.word	0x20011f5c

0800c10c <IPCC_C1_RX_IRQHandler>:

/**
  * @brief This function handles IPCC RX occupied interrupt.
  */
void IPCC_C1_RX_IRQHandler(void)
{
 800c10c:	b580      	push	{r7, lr}
 800c10e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN IPCC_C1_RX_IRQn 0 */

  /* USER CODE END IPCC_C1_RX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 800c110:	f01c f9e6 	bl	80284e0 <HW_IPCC_Rx_Handler>
  /* USER CODE BEGIN IPCC_C1_RX_IRQn 1 */

  /* USER CODE END IPCC_C1_RX_IRQn 1 */
}
 800c114:	bf00      	nop
 800c116:	bd80      	pop	{r7, pc}

0800c118 <IPCC_C1_TX_IRQHandler>:

/**
  * @brief This function handles IPCC TX free interrupt.
  */
void IPCC_C1_TX_IRQHandler(void)
{
 800c118:	b580      	push	{r7, lr}
 800c11a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN IPCC_C1_TX_IRQn 0 */

  /* USER CODE END IPCC_C1_TX_IRQn 0 */
  HAL_IPCC_TX_IRQHandler(&hipcc);
 800c11c:	f01c fa18 	bl	8028550 <HW_IPCC_Tx_Handler>
  /* USER CODE BEGIN IPCC_C1_TX_IRQn 1 */

  /* USER CODE END IPCC_C1_TX_IRQn 1 */
}
 800c120:	bf00      	nop
 800c122:	bd80      	pop	{r7, pc}

0800c124 <HSEM_IRQHandler>:

/**
  * @brief This function handles HSEM global interrupt.
  */
void HSEM_IRQHandler(void)
{
 800c124:	b580      	push	{r7, lr}
 800c126:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HSEM_IRQn 0 */

  /* USER CODE END HSEM_IRQn 0 */
  HAL_HSEM_IRQHandler();
 800c128:	f002 f836 	bl	800e198 <HAL_HSEM_IRQHandler>
  /* USER CODE BEGIN HSEM_IRQn 1 */

  /* USER CODE END HSEM_IRQn 1 */
}
 800c12c:	bf00      	nop
 800c12e:	bd80      	pop	{r7, pc}

0800c130 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 800c130:	b480      	push	{r7}
 800c132:	af00      	add	r7, sp, #0
	return 1;
 800c134:	2301      	movs	r3, #1
}
 800c136:	4618      	mov	r0, r3
 800c138:	46bd      	mov	sp, r7
 800c13a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c13e:	4770      	bx	lr

0800c140 <_kill>:

int _kill(int pid, int sig)
{
 800c140:	b580      	push	{r7, lr}
 800c142:	b082      	sub	sp, #8
 800c144:	af00      	add	r7, sp, #0
 800c146:	6078      	str	r0, [r7, #4]
 800c148:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 800c14a:	f01f ff8d 	bl	802c068 <__errno>
 800c14e:	4603      	mov	r3, r0
 800c150:	2216      	movs	r2, #22
 800c152:	601a      	str	r2, [r3, #0]
	return -1;
 800c154:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 800c158:	4618      	mov	r0, r3
 800c15a:	3708      	adds	r7, #8
 800c15c:	46bd      	mov	sp, r7
 800c15e:	bd80      	pop	{r7, pc}

0800c160 <_exit>:

void _exit (int status)
{
 800c160:	b580      	push	{r7, lr}
 800c162:	b082      	sub	sp, #8
 800c164:	af00      	add	r7, sp, #0
 800c166:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 800c168:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c16c:	6878      	ldr	r0, [r7, #4]
 800c16e:	f7ff ffe7 	bl	800c140 <_kill>
	while (1) {}		/* Make sure we hang here */
 800c172:	e7fe      	b.n	800c172 <_exit+0x12>

0800c174 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800c174:	b580      	push	{r7, lr}
 800c176:	b086      	sub	sp, #24
 800c178:	af00      	add	r7, sp, #0
 800c17a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800c17c:	4a14      	ldr	r2, [pc, #80]	; (800c1d0 <_sbrk+0x5c>)
 800c17e:	4b15      	ldr	r3, [pc, #84]	; (800c1d4 <_sbrk+0x60>)
 800c180:	1ad3      	subs	r3, r2, r3
 800c182:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800c184:	697b      	ldr	r3, [r7, #20]
 800c186:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800c188:	4b13      	ldr	r3, [pc, #76]	; (800c1d8 <_sbrk+0x64>)
 800c18a:	681b      	ldr	r3, [r3, #0]
 800c18c:	2b00      	cmp	r3, #0
 800c18e:	d102      	bne.n	800c196 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800c190:	4b11      	ldr	r3, [pc, #68]	; (800c1d8 <_sbrk+0x64>)
 800c192:	4a12      	ldr	r2, [pc, #72]	; (800c1dc <_sbrk+0x68>)
 800c194:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800c196:	4b10      	ldr	r3, [pc, #64]	; (800c1d8 <_sbrk+0x64>)
 800c198:	681a      	ldr	r2, [r3, #0]
 800c19a:	687b      	ldr	r3, [r7, #4]
 800c19c:	4413      	add	r3, r2
 800c19e:	693a      	ldr	r2, [r7, #16]
 800c1a0:	429a      	cmp	r2, r3
 800c1a2:	d207      	bcs.n	800c1b4 <_sbrk+0x40>
  {
    errno = ENOMEM;
 800c1a4:	f01f ff60 	bl	802c068 <__errno>
 800c1a8:	4603      	mov	r3, r0
 800c1aa:	220c      	movs	r2, #12
 800c1ac:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800c1ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800c1b2:	e009      	b.n	800c1c8 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800c1b4:	4b08      	ldr	r3, [pc, #32]	; (800c1d8 <_sbrk+0x64>)
 800c1b6:	681b      	ldr	r3, [r3, #0]
 800c1b8:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800c1ba:	4b07      	ldr	r3, [pc, #28]	; (800c1d8 <_sbrk+0x64>)
 800c1bc:	681a      	ldr	r2, [r3, #0]
 800c1be:	687b      	ldr	r3, [r7, #4]
 800c1c0:	4413      	add	r3, r2
 800c1c2:	4a05      	ldr	r2, [pc, #20]	; (800c1d8 <_sbrk+0x64>)
 800c1c4:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800c1c6:	68fb      	ldr	r3, [r7, #12]
}
 800c1c8:	4618      	mov	r0, r3
 800c1ca:	3718      	adds	r7, #24
 800c1cc:	46bd      	mov	sp, r7
 800c1ce:	bd80      	pop	{r7, pc}
 800c1d0:	20030000 	.word	0x20030000
 800c1d4:	00000400 	.word	0x00000400
 800c1d8:	200028fc 	.word	0x200028fc
 800c1dc:	20013bb0 	.word	0x20013bb0

0800c1e0 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800c1e0:	b480      	push	{r7}
 800c1e2:	af00      	add	r7, sp, #0
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
 800c1e4:	4b24      	ldr	r3, [pc, #144]	; (800c278 <SystemInit+0x98>)
 800c1e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800c1ea:	4a23      	ldr	r2, [pc, #140]	; (800c278 <SystemInit+0x98>)
 800c1ec:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800c1f0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800c1f4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c1f8:	681b      	ldr	r3, [r3, #0]
 800c1fa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c1fe:	f043 0301 	orr.w	r3, r3, #1
 800c202:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 800c204:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c208:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 800c20c:	609a      	str	r2, [r3, #8]

  /* Reset PLLSAI1ON, PLLON, HSECSSON, HSEON, HSION, and MSIPLLON bits */
  RCC->CR &= (uint32_t)0xFAF6FEFBU;
 800c20e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c212:	681a      	ldr	r2, [r3, #0]
 800c214:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c218:	4b18      	ldr	r3, [pc, #96]	; (800c27c <SystemInit+0x9c>)
 800c21a:	4013      	ands	r3, r2
 800c21c:	600b      	str	r3, [r1, #0]

  /*!< Reset LSI1 and LSI2 bits */
  RCC->CSR &= (uint32_t)0xFFFFFFFAU;
 800c21e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c222:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800c226:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c22a:	f023 0305 	bic.w	r3, r3, #5
 800c22e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 800c232:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c236:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800c23a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c23e:	f023 0301 	bic.w	r3, r3, #1
 800c242:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    
  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22041000U;
 800c246:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c24a:	4a0d      	ldr	r2, [pc, #52]	; (800c280 <SystemInit+0xa0>)
 800c24c:	60da      	str	r2, [r3, #12]

#if defined(STM32WB55xx) || defined(STM32WB5Mxx)
  /* Reset PLLSAI1CFGR register */
  RCC->PLLSAI1CFGR = 0x22041000U;
 800c24e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c252:	4a0b      	ldr	r2, [pc, #44]	; (800c280 <SystemInit+0xa0>)
 800c254:	611a      	str	r2, [r3, #16]
#endif
  
  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800c256:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c25a:	681b      	ldr	r3, [r3, #0]
 800c25c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800c260:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800c264:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800c266:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c26a:	2200      	movs	r2, #0
 800c26c:	619a      	str	r2, [r3, #24]
}
 800c26e:	bf00      	nop
 800c270:	46bd      	mov	sp, r7
 800c272:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c276:	4770      	bx	lr
 800c278:	e000ed00 	.word	0xe000ed00
 800c27c:	faf6fefb 	.word	0xfaf6fefb
 800c280:	22041000 	.word	0x22041000

0800c284 <_ZN8CALIPILEC1Ev>:
#define cycTime_60ms  0x01
#define cycTime_120ms 0x02
#define cycTime_140ms 0x03


class CALIPILE
 800c284:	b480      	push	{r7}
 800c286:	b083      	sub	sp, #12
 800c288:	af00      	add	r7, sp, #0
 800c28a:	6078      	str	r0, [r7, #4]
 800c28c:	687b      	ldr	r3, [r7, #4]
 800c28e:	2200      	movs	r2, #0
 800c290:	605a      	str	r2, [r3, #4]
 800c292:	687b      	ldr	r3, [r7, #4]
 800c294:	2200      	movs	r2, #0
 800c296:	721a      	strb	r2, [r3, #8]
 800c298:	687b      	ldr	r3, [r7, #4]
 800c29a:	4618      	mov	r0, r3
 800c29c:	370c      	adds	r7, #12
 800c29e:	46bd      	mov	sp, r7
 800c2a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2a4:	4770      	bx	lr
	...

0800c2a8 <Thermopile_Task>:
void grabThermopileSamples(thermopile_packet *data, CALIPILE *tp);

uint16_t thermIdx;
uint32_t thermID;

void Thermopile_Task(void *argument) {
 800c2a8:	b580      	push	{r7, lr}
 800c2aa:	b084      	sub	sp, #16
 800c2ac:	af00      	add	r7, sp, #0
 800c2ae:	6078      	str	r0, [r7, #4]
	SensorPacket *packet = NULL;
 800c2b0:	2300      	movs	r3, #0
 800c2b2:	60fb      	str	r3, [r7, #12]
//	tp_nose_bridge.setup((uint8_t) THERMOPLE_NOSE_BRIDGE_ADDR, &hi2c1, THERMOPLE_NOSE_BRIDGE_ID);
//	tp_nose_bridge.wake(); 		// wakeup thermopile sensors on i2c1 bus
//	tp_temple_front.setup((uint8_t) THERMOPLE_TEMPLE_FRONT_ADDR, &hi2c3, THERMOPLE_TEMPLE_FRONT_ADDR_ID);
//	tp_temple_front.wake(); 	// wakeup thermopile sensors on i2c3 bus

	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800c2b4:	4b73      	ldr	r3, [pc, #460]	; (800c484 <Thermopile_Task+0x1dc>)
 800c2b6:	681b      	ldr	r3, [r3, #0]
 800c2b8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c2bc:	4618      	mov	r0, r3
 800c2be:	f016 fd3b 	bl	8022d38 <osSemaphoreAcquire>
	initThermopiles(&tp_nose_tip,		THERMOPLE_NOSE_TIP_ADDR,	&hi2c1,	THERMOPLE_NOSE_TIP_ID);
 800c2c2:	2301      	movs	r3, #1
 800c2c4:	4a70      	ldr	r2, [pc, #448]	; (800c488 <Thermopile_Task+0x1e0>)
 800c2c6:	210c      	movs	r1, #12
 800c2c8:	4870      	ldr	r0, [pc, #448]	; (800c48c <Thermopile_Task+0x1e4>)
 800c2ca:	f000 f8f9 	bl	800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>
	initThermopiles(&tp_nose_bridge,	THERMOPLE_NOSE_BRIDGE_ADDR,	&hi2c1, THERMOPLE_NOSE_BRIDGE_ID);
 800c2ce:	2302      	movs	r3, #2
 800c2d0:	4a6d      	ldr	r2, [pc, #436]	; (800c488 <Thermopile_Task+0x1e0>)
 800c2d2:	210d      	movs	r1, #13
 800c2d4:	486e      	ldr	r0, [pc, #440]	; (800c490 <Thermopile_Task+0x1e8>)
 800c2d6:	f000 f8f3 	bl	800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>
	osSemaphoreRelease(messageI2C1_LockHandle);
 800c2da:	4b6a      	ldr	r3, [pc, #424]	; (800c484 <Thermopile_Task+0x1dc>)
 800c2dc:	681b      	ldr	r3, [r3, #0]
 800c2de:	4618      	mov	r0, r3
 800c2e0:	f016 fd7c 	bl	8022ddc <osSemaphoreRelease>

	osSemaphoreAcquire(messageI2C3_LockHandle, osWaitForever);
 800c2e4:	4b6b      	ldr	r3, [pc, #428]	; (800c494 <Thermopile_Task+0x1ec>)
 800c2e6:	681b      	ldr	r3, [r3, #0]
 800c2e8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c2ec:	4618      	mov	r0, r3
 800c2ee:	f016 fd23 	bl	8022d38 <osSemaphoreAcquire>
	initThermopiles(&tp_temple_front,	THERMOPLE_TEMPLE_FRONT_ADDR,&hi2c3, THERMOPLE_TEMPLE_FRONT_ADDR_ID);
 800c2f2:	2303      	movs	r3, #3
 800c2f4:	4a68      	ldr	r2, [pc, #416]	; (800c498 <Thermopile_Task+0x1f0>)
 800c2f6:	210f      	movs	r1, #15
 800c2f8:	4868      	ldr	r0, [pc, #416]	; (800c49c <Thermopile_Task+0x1f4>)
 800c2fa:	f000 f8e1 	bl	800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>
	initThermopiles(&tp_temple_mid,		THERMOPLE_TEMPLE_MID_ADDR,	&hi2c3, THERMOPLE_TEMPLE_MID_ADDR_ID);
 800c2fe:	2304      	movs	r3, #4
 800c300:	4a65      	ldr	r2, [pc, #404]	; (800c498 <Thermopile_Task+0x1f0>)
 800c302:	210e      	movs	r1, #14
 800c304:	4866      	ldr	r0, [pc, #408]	; (800c4a0 <Thermopile_Task+0x1f8>)
 800c306:	f000 f8db 	bl	800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>
	initThermopiles(&tp_temple_back,	THERMOPLE_TEMPLE_BACK_ADDR,	&hi2c3, THERMOPLE_TEMPLE_BACK_ADDR_ID);
 800c30a:	2305      	movs	r3, #5
 800c30c:	4a62      	ldr	r2, [pc, #392]	; (800c498 <Thermopile_Task+0x1f0>)
 800c30e:	210c      	movs	r1, #12
 800c310:	4864      	ldr	r0, [pc, #400]	; (800c4a4 <Thermopile_Task+0x1fc>)
 800c312:	f000 f8d5 	bl	800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>
	osSemaphoreRelease(messageI2C3_LockHandle);
 800c316:	4b5f      	ldr	r3, [pc, #380]	; (800c494 <Thermopile_Task+0x1ec>)
 800c318:	681b      	ldr	r3, [r3, #0]
 800c31a:	4618      	mov	r0, r3
 800c31c:	f016 fd5e 	bl	8022ddc <osSemaphoreRelease>

	header.payloadLength = THERMOPILE_CHANNELS * sizeof(thermopile_packet);
 800c320:	4b61      	ldr	r3, [pc, #388]	; (800c4a8 <Thermopile_Task+0x200>)
 800c322:	2278      	movs	r2, #120	; 0x78
 800c324:	60da      	str	r2, [r3, #12]
	header.reserved[0] = THERMOPILE_SAMPLE_PERIOD_MS;
 800c326:	4b60      	ldr	r3, [pc, #384]	; (800c4a8 <Thermopile_Task+0x200>)
 800c328:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 800c32c:	611a      	str	r2, [r3, #16]
	header.reserved[1] = THERMOPILE_CNT;
 800c32e:	4b5e      	ldr	r3, [pc, #376]	; (800c4a8 <Thermopile_Task+0x200>)
 800c330:	2202      	movs	r2, #2
 800c332:	615a      	str	r2, [r3, #20]

	thermIdx = 0;
 800c334:	4b5d      	ldr	r3, [pc, #372]	; (800c4ac <Thermopile_Task+0x204>)
 800c336:	2200      	movs	r2, #0
 800c338:	801a      	strh	r2, [r3, #0]
	thermID = 0;
 800c33a:	4b5d      	ldr	r3, [pc, #372]	; (800c4b0 <Thermopile_Task+0x208>)
 800c33c:	2200      	movs	r2, #0
 800c33e:	601a      	str	r2, [r3, #0]

	periodicThermopileTimer_id = osTimerNew(triggerThermopileSample,
 800c340:	2300      	movs	r3, #0
 800c342:	2200      	movs	r2, #0
 800c344:	2101      	movs	r1, #1
 800c346:	485b      	ldr	r0, [pc, #364]	; (800c4b4 <Thermopile_Task+0x20c>)
 800c348:	f016 fa80 	bl	802284c <osTimerNew>
 800c34c:	4603      	mov	r3, r0
 800c34e:	4a5a      	ldr	r2, [pc, #360]	; (800c4b8 <Thermopile_Task+0x210>)
 800c350:	6013      	str	r3, [r2, #0]
			osTimerPeriodic, NULL, NULL);
	osTimerStart(periodicThermopileTimer_id, THERMOPILE_SAMPLE_PERIOD_MS);
 800c352:	4b59      	ldr	r3, [pc, #356]	; (800c4b8 <Thermopile_Task+0x210>)
 800c354:	681b      	ldr	r3, [r3, #0]
 800c356:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800c35a:	4618      	mov	r0, r3
 800c35c:	f016 faf2 	bl	8022944 <osTimerStart>

	while (1) {

		flags = osThreadFlagsWait(GRAB_SAMPLE_BIT | TERMINATE_THREAD_BIT,
 800c360:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c364:	2100      	movs	r1, #0
 800c366:	f44f 7040 	mov.w	r0, #768	; 0x300
 800c36a:	f016 f9bd 	bl	80226e8 <osThreadFlagsWait>
 800c36e:	60b8      	str	r0, [r7, #8]
				osFlagsWaitAny, osWaitForever);

		if ((flags & GRAB_SAMPLE_BIT) == GRAB_SAMPLE_BIT) {
 800c370:	68bb      	ldr	r3, [r7, #8]
 800c372:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c376:	2b00      	cmp	r3, #0
 800c378:	d073      	beq.n	800c462 <Thermopile_Task+0x1ba>


			// sample nose
			osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 800c37a:	4b42      	ldr	r3, [pc, #264]	; (800c484 <Thermopile_Task+0x1dc>)
 800c37c:	681b      	ldr	r3, [r3, #0]
 800c37e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c382:	4618      	mov	r0, r3
 800c384:	f016 fcd8 	bl	8022d38 <osSemaphoreAcquire>
			grabThermopileSamples(&thermopileData[thermIdx++], &tp_nose_tip);
 800c388:	4b48      	ldr	r3, [pc, #288]	; (800c4ac <Thermopile_Task+0x204>)
 800c38a:	881b      	ldrh	r3, [r3, #0]
 800c38c:	1c5a      	adds	r2, r3, #1
 800c38e:	b291      	uxth	r1, r2
 800c390:	4a46      	ldr	r2, [pc, #280]	; (800c4ac <Thermopile_Task+0x204>)
 800c392:	8011      	strh	r1, [r2, #0]
 800c394:	461a      	mov	r2, r3
 800c396:	4613      	mov	r3, r2
 800c398:	005b      	lsls	r3, r3, #1
 800c39a:	4413      	add	r3, r2
 800c39c:	00db      	lsls	r3, r3, #3
 800c39e:	4a47      	ldr	r2, [pc, #284]	; (800c4bc <Thermopile_Task+0x214>)
 800c3a0:	4413      	add	r3, r2
 800c3a2:	493a      	ldr	r1, [pc, #232]	; (800c48c <Thermopile_Task+0x1e4>)
 800c3a4:	4618      	mov	r0, r3
 800c3a6:	f000 f8f3 	bl	800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>
			grabThermopileSamples(&thermopileData[thermIdx++], &tp_nose_bridge);
 800c3aa:	4b40      	ldr	r3, [pc, #256]	; (800c4ac <Thermopile_Task+0x204>)
 800c3ac:	881b      	ldrh	r3, [r3, #0]
 800c3ae:	1c5a      	adds	r2, r3, #1
 800c3b0:	b291      	uxth	r1, r2
 800c3b2:	4a3e      	ldr	r2, [pc, #248]	; (800c4ac <Thermopile_Task+0x204>)
 800c3b4:	8011      	strh	r1, [r2, #0]
 800c3b6:	461a      	mov	r2, r3
 800c3b8:	4613      	mov	r3, r2
 800c3ba:	005b      	lsls	r3, r3, #1
 800c3bc:	4413      	add	r3, r2
 800c3be:	00db      	lsls	r3, r3, #3
 800c3c0:	4a3e      	ldr	r2, [pc, #248]	; (800c4bc <Thermopile_Task+0x214>)
 800c3c2:	4413      	add	r3, r2
 800c3c4:	4932      	ldr	r1, [pc, #200]	; (800c490 <Thermopile_Task+0x1e8>)
 800c3c6:	4618      	mov	r0, r3
 800c3c8:	f000 f8e2 	bl	800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>
			osSemaphoreRelease(messageI2C1_LockHandle);
 800c3cc:	4b2d      	ldr	r3, [pc, #180]	; (800c484 <Thermopile_Task+0x1dc>)
 800c3ce:	681b      	ldr	r3, [r3, #0]
 800c3d0:	4618      	mov	r0, r3
 800c3d2:	f016 fd03 	bl	8022ddc <osSemaphoreRelease>

			// sample temple
			osSemaphoreAcquire(messageI2C3_LockHandle, osWaitForever);
 800c3d6:	4b2f      	ldr	r3, [pc, #188]	; (800c494 <Thermopile_Task+0x1ec>)
 800c3d8:	681b      	ldr	r3, [r3, #0]
 800c3da:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c3de:	4618      	mov	r0, r3
 800c3e0:	f016 fcaa 	bl	8022d38 <osSemaphoreAcquire>
			grabThermopileSamples(&thermopileData[thermIdx++], &tp_temple_front);
 800c3e4:	4b31      	ldr	r3, [pc, #196]	; (800c4ac <Thermopile_Task+0x204>)
 800c3e6:	881b      	ldrh	r3, [r3, #0]
 800c3e8:	1c5a      	adds	r2, r3, #1
 800c3ea:	b291      	uxth	r1, r2
 800c3ec:	4a2f      	ldr	r2, [pc, #188]	; (800c4ac <Thermopile_Task+0x204>)
 800c3ee:	8011      	strh	r1, [r2, #0]
 800c3f0:	461a      	mov	r2, r3
 800c3f2:	4613      	mov	r3, r2
 800c3f4:	005b      	lsls	r3, r3, #1
 800c3f6:	4413      	add	r3, r2
 800c3f8:	00db      	lsls	r3, r3, #3
 800c3fa:	4a30      	ldr	r2, [pc, #192]	; (800c4bc <Thermopile_Task+0x214>)
 800c3fc:	4413      	add	r3, r2
 800c3fe:	4927      	ldr	r1, [pc, #156]	; (800c49c <Thermopile_Task+0x1f4>)
 800c400:	4618      	mov	r0, r3
 800c402:	f000 f8c5 	bl	800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>
			grabThermopileSamples(&thermopileData[thermIdx++], &tp_temple_mid);
 800c406:	4b29      	ldr	r3, [pc, #164]	; (800c4ac <Thermopile_Task+0x204>)
 800c408:	881b      	ldrh	r3, [r3, #0]
 800c40a:	1c5a      	adds	r2, r3, #1
 800c40c:	b291      	uxth	r1, r2
 800c40e:	4a27      	ldr	r2, [pc, #156]	; (800c4ac <Thermopile_Task+0x204>)
 800c410:	8011      	strh	r1, [r2, #0]
 800c412:	461a      	mov	r2, r3
 800c414:	4613      	mov	r3, r2
 800c416:	005b      	lsls	r3, r3, #1
 800c418:	4413      	add	r3, r2
 800c41a:	00db      	lsls	r3, r3, #3
 800c41c:	4a27      	ldr	r2, [pc, #156]	; (800c4bc <Thermopile_Task+0x214>)
 800c41e:	4413      	add	r3, r2
 800c420:	491f      	ldr	r1, [pc, #124]	; (800c4a0 <Thermopile_Task+0x1f8>)
 800c422:	4618      	mov	r0, r3
 800c424:	f000 f8b4 	bl	800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>
			grabThermopileSamples(&thermopileData[thermIdx++], &tp_temple_back);
 800c428:	4b20      	ldr	r3, [pc, #128]	; (800c4ac <Thermopile_Task+0x204>)
 800c42a:	881b      	ldrh	r3, [r3, #0]
 800c42c:	1c5a      	adds	r2, r3, #1
 800c42e:	b291      	uxth	r1, r2
 800c430:	4a1e      	ldr	r2, [pc, #120]	; (800c4ac <Thermopile_Task+0x204>)
 800c432:	8011      	strh	r1, [r2, #0]
 800c434:	461a      	mov	r2, r3
 800c436:	4613      	mov	r3, r2
 800c438:	005b      	lsls	r3, r3, #1
 800c43a:	4413      	add	r3, r2
 800c43c:	00db      	lsls	r3, r3, #3
 800c43e:	4a1f      	ldr	r2, [pc, #124]	; (800c4bc <Thermopile_Task+0x214>)
 800c440:	4413      	add	r3, r2
 800c442:	4918      	ldr	r1, [pc, #96]	; (800c4a4 <Thermopile_Task+0x1fc>)
 800c444:	4618      	mov	r0, r3
 800c446:	f000 f8a3 	bl	800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>
			osSemaphoreRelease(messageI2C3_LockHandle);
 800c44a:	4b12      	ldr	r3, [pc, #72]	; (800c494 <Thermopile_Task+0x1ec>)
 800c44c:	681b      	ldr	r3, [r3, #0]
 800c44e:	4618      	mov	r0, r3
 800c450:	f016 fcc4 	bl	8022ddc <osSemaphoreRelease>

			queueThermopilePkt(&thermopileData[0], 5);
 800c454:	2105      	movs	r1, #5
 800c456:	4819      	ldr	r0, [pc, #100]	; (800c4bc <Thermopile_Task+0x214>)
 800c458:	f000 f856 	bl	800c508 <_Z18queueThermopilePktP18thermopile_packetst>
			thermIdx = 0;
 800c45c:	4b13      	ldr	r3, [pc, #76]	; (800c4ac <Thermopile_Task+0x204>)
 800c45e:	2200      	movs	r2, #0
 800c460:	801a      	strh	r2, [r3, #0]

		}

		if ((flags & TERMINATE_THREAD_BIT) == TERMINATE_THREAD_BIT) {
 800c462:	68bb      	ldr	r3, [r7, #8]
 800c464:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800c468:	2b00      	cmp	r3, #0
 800c46a:	f43f af79 	beq.w	800c360 <Thermopile_Task+0xb8>
			osTimerDelete(periodicThermopileTimer_id);
 800c46e:	4b12      	ldr	r3, [pc, #72]	; (800c4b8 <Thermopile_Task+0x210>)
 800c470:	681b      	ldr	r3, [r3, #0]
 800c472:	4618      	mov	r0, r3
 800c474:	f016 fa94 	bl	80229a0 <osTimerDelete>
			break;
 800c478:	bf00      	nop
		}
	}

}
 800c47a:	bf00      	nop
 800c47c:	3710      	adds	r7, #16
 800c47e:	46bd      	mov	sp, r7
 800c480:	bd80      	pop	{r7, pc}
 800c482:	bf00      	nop
 800c484:	200003dc 	.word	0x200003dc
 800c488:	20011fa8 	.word	0x20011fa8
 800c48c:	200029a0 	.word	0x200029a0
 800c490:	200029c4 	.word	0x200029c4
 800c494:	200003e0 	.word	0x200003e0
 800c498:	20011f5c 	.word	0x20011f5c
 800c49c:	200029e8 	.word	0x200029e8
 800c4a0:	20002a0c 	.word	0x20002a0c
 800c4a4:	20002a30 	.word	0x20002a30
 800c4a8:	20002978 	.word	0x20002978
 800c4ac:	20002a54 	.word	0x20002a54
 800c4b0:	20002a58 	.word	0x20002a58
 800c4b4:	0800c605 	.word	0x0800c605
 800c4b8:	2000299c 	.word	0x2000299c
 800c4bc:	20002900 	.word	0x20002900

0800c4c0 <_Z15initThermopilesP8CALIPILEhP19__I2C_HandleTypeDefh>:

void initThermopiles(CALIPILE *tp, uint8_t address, I2C_HandleTypeDef* i2c_handle, uint8_t descriptor){
 800c4c0:	b580      	push	{r7, lr}
 800c4c2:	b086      	sub	sp, #24
 800c4c4:	af00      	add	r7, sp, #0
 800c4c6:	60f8      	str	r0, [r7, #12]
 800c4c8:	607a      	str	r2, [r7, #4]
 800c4ca:	461a      	mov	r2, r3
 800c4cc:	460b      	mov	r3, r1
 800c4ce:	72fb      	strb	r3, [r7, #11]
 800c4d0:	4613      	mov	r3, r2
 800c4d2:	72bb      	strb	r3, [r7, #10]

	uint16_t Tcounts = 0x83; // set threshold for over temperature interrupt, 0x83 == 67072 counts
 800c4d4:	2383      	movs	r3, #131	; 0x83
 800c4d6:	82fb      	strh	r3, [r7, #22]
	uint32_t flags = 0;
 800c4d8:	2300      	movs	r3, #0
 800c4da:	613b      	str	r3, [r7, #16]
	//	uint8_t intStatus;


	tp->setup((uint8_t) address, i2c_handle, descriptor);
 800c4dc:	7abb      	ldrb	r3, [r7, #10]
 800c4de:	7af9      	ldrb	r1, [r7, #11]
 800c4e0:	687a      	ldr	r2, [r7, #4]
 800c4e2:	68f8      	ldr	r0, [r7, #12]
 800c4e4:	f013 f9e5 	bl	801f8b2 <_ZN8CALIPILE5setupEhP19__I2C_HandleTypeDefh>

//	if(wakeupFlag==0){
//		tp->wake();
//		wakeupFlag=1;
//	}
	tp->wake();
 800c4e8:	68f8      	ldr	r0, [r7, #12]
 800c4ea:	f013 f9fd 	bl	801f8e8 <_ZN8CALIPILE4wakeEv>
	tp->readEEPROM(); // Verify protocol number and checksum and get calibration constants
 800c4ee:	68f8      	ldr	r0, [r7, #12]
 800c4f0:	f013 fa16 	bl	801f920 <_ZN8CALIPILE10readEEPROMEv>
	//  tp_outer.initMotion(tcLP1, tcLP2, LPsource, cycTime); // configure presence and motion interrupts
	tp->initTempThr(Tcounts);  // choose something ~5% above TPAMB
 800c4f4:	8afb      	ldrh	r3, [r7, #22]
 800c4f6:	4619      	mov	r1, r3
 800c4f8:	68f8      	ldr	r0, [r7, #12]
 800c4fa:	f013 fb0f 	bl	801fb1c <_ZN8CALIPILE11initTempThrEt>
	// read interrupt status register(s) to unlatch interrupt before entering main loop
//	intStatus  = tp.checkIntStatus(); //dont do if not using interrupts

}
 800c4fe:	bf00      	nop
 800c500:	3718      	adds	r7, #24
 800c502:	46bd      	mov	sp, r7
 800c504:	bd80      	pop	{r7, pc}
	...

0800c508 <_Z18queueThermopilePktP18thermopile_packetst>:

void queueThermopilePkt(thermopile_packet *sample, uint16_t packetCnt){
 800c508:	b580      	push	{r7, lr}
 800c50a:	b084      	sub	sp, #16
 800c50c:	af00      	add	r7, sp, #0
 800c50e:	6078      	str	r0, [r7, #4]
 800c510:	460b      	mov	r3, r1
 800c512:	807b      	strh	r3, [r7, #2]
	SensorPacket *packet = NULL;
 800c514:	2300      	movs	r3, #0
 800c516:	60fb      	str	r3, [r7, #12]
	thermIdx++;
 800c518:	4b1a      	ldr	r3, [pc, #104]	; (800c584 <_Z18queueThermopilePktP18thermopile_packetst+0x7c>)
 800c51a:	881b      	ldrh	r3, [r3, #0]
 800c51c:	3301      	adds	r3, #1
 800c51e:	b29a      	uxth	r2, r3
 800c520:	4b18      	ldr	r3, [pc, #96]	; (800c584 <_Z18queueThermopilePktP18thermopile_packetst+0x7c>)
 800c522:	801a      	strh	r2, [r3, #0]

//	if (thermIdx >= MAX_THERMOPILE_SAMPLES_PACKET) {
		header.packetType = THERMOPILE;
 800c524:	4b18      	ldr	r3, [pc, #96]	; (800c588 <_Z18queueThermopilePktP18thermopile_packetst+0x80>)
 800c526:	2207      	movs	r2, #7
 800c528:	701a      	strb	r2, [r3, #0]
		header.packetID = thermID;
 800c52a:	4b18      	ldr	r3, [pc, #96]	; (800c58c <_Z18queueThermopilePktP18thermopile_packetst+0x84>)
 800c52c:	681b      	ldr	r3, [r3, #0]
 800c52e:	b29a      	uxth	r2, r3
 800c530:	4b15      	ldr	r3, [pc, #84]	; (800c588 <_Z18queueThermopilePktP18thermopile_packetst+0x80>)
 800c532:	805a      	strh	r2, [r3, #2]
		header.msFromStart = HAL_GetTick();
 800c534:	f000 faa8 	bl	800ca88 <HAL_GetTick>
 800c538:	4603      	mov	r3, r0
 800c53a:	4a13      	ldr	r2, [pc, #76]	; (800c588 <_Z18queueThermopilePktP18thermopile_packetst+0x80>)
 800c53c:	6053      	str	r3, [r2, #4]
		packet = grabPacket();
 800c53e:	f7fe fcdb 	bl	800aef8 <grabPacket>
 800c542:	60f8      	str	r0, [r7, #12]
		if (packet != NULL) {
 800c544:	68fb      	ldr	r3, [r7, #12]
 800c546:	2b00      	cmp	r3, #0
 800c548:	d010      	beq.n	800c56c <_Z18queueThermopilePktP18thermopile_packetst+0x64>
			memcpy(&(packet->header), &header, sizeof(PacketHeader));
 800c54a:	68fb      	ldr	r3, [r7, #12]
 800c54c:	2224      	movs	r2, #36	; 0x24
 800c54e:	490e      	ldr	r1, [pc, #56]	; (800c588 <_Z18queueThermopilePktP18thermopile_packetst+0x80>)
 800c550:	4618      	mov	r0, r3
 800c552:	f01f fdc5 	bl	802c0e0 <memcpy>
			memcpy(packet->payload, sample, header.payloadLength);
 800c556:	68fb      	ldr	r3, [r7, #12]
 800c558:	3324      	adds	r3, #36	; 0x24
 800c55a:	4a0b      	ldr	r2, [pc, #44]	; (800c588 <_Z18queueThermopilePktP18thermopile_packetst+0x80>)
 800c55c:	68d2      	ldr	r2, [r2, #12]
 800c55e:	6879      	ldr	r1, [r7, #4]
 800c560:	4618      	mov	r0, r3
 800c562:	f01f fdbd 	bl	802c0e0 <memcpy>
			queueUpPacket(packet);
 800c566:	68f8      	ldr	r0, [r7, #12]
 800c568:	f7fe fce2 	bl	800af30 <queueUpPacket>
		}
		thermID++;
 800c56c:	4b07      	ldr	r3, [pc, #28]	; (800c58c <_Z18queueThermopilePktP18thermopile_packetst+0x84>)
 800c56e:	681b      	ldr	r3, [r3, #0]
 800c570:	3301      	adds	r3, #1
 800c572:	4a06      	ldr	r2, [pc, #24]	; (800c58c <_Z18queueThermopilePktP18thermopile_packetst+0x84>)
 800c574:	6013      	str	r3, [r2, #0]
		thermIdx = 0;
 800c576:	4b03      	ldr	r3, [pc, #12]	; (800c584 <_Z18queueThermopilePktP18thermopile_packetst+0x7c>)
 800c578:	2200      	movs	r2, #0
 800c57a:	801a      	strh	r2, [r3, #0]
//	}
}
 800c57c:	bf00      	nop
 800c57e:	3710      	adds	r7, #16
 800c580:	46bd      	mov	sp, r7
 800c582:	bd80      	pop	{r7, pc}
 800c584:	20002a54 	.word	0x20002a54
 800c588:	20002978 	.word	0x20002978
 800c58c:	20002a58 	.word	0x20002a58

0800c590 <_Z21grabThermopileSamplesP18thermopile_packetsP8CALIPILE>:

void grabThermopileSamples(thermopile_packet *data, CALIPILE *tp) {
 800c590:	b580      	push	{r7, lr}
 800c592:	b082      	sub	sp, #8
 800c594:	af00      	add	r7, sp, #0
 800c596:	6078      	str	r0, [r7, #4]
 800c598:	6039      	str	r1, [r7, #0]
	data->descriptor = tp->descriptor;
 800c59a:	683b      	ldr	r3, [r7, #0]
 800c59c:	781a      	ldrb	r2, [r3, #0]
 800c59e:	687b      	ldr	r3, [r7, #4]
 800c5a0:	701a      	strb	r2, [r3, #0]
	data->timestamp = HAL_GetTick();
 800c5a2:	f000 fa71 	bl	800ca88 <HAL_GetTick>
 800c5a6:	4602      	mov	r2, r0
 800c5a8:	687b      	ldr	r3, [r7, #4]
 800c5aa:	605a      	str	r2, [r3, #4]
	data->ambientRaw = tp->getTPAMB();
 800c5ac:	6838      	ldr	r0, [r7, #0]
 800c5ae:	f013 faf5 	bl	801fb9c <_ZN8CALIPILE8getTPAMBEv>
 800c5b2:	4603      	mov	r3, r0
 800c5b4:	461a      	mov	r2, r3
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	811a      	strh	r2, [r3, #8]
	data->objectRaw = tp->getTPOBJ();
 800c5ba:	6838      	ldr	r0, [r7, #0]
 800c5bc:	f013 fb0e 	bl	801fbdc <_ZN8CALIPILE8getTPOBJEv>
 800c5c0:	4602      	mov	r2, r0
 800c5c2:	687b      	ldr	r3, [r7, #4]
 800c5c4:	60da      	str	r2, [r3, #12]
	data->ambientTemp = tp->getTamb(data->ambientRaw);
 800c5c6:	687b      	ldr	r3, [r7, #4]
 800c5c8:	891b      	ldrh	r3, [r3, #8]
 800c5ca:	4619      	mov	r1, r3
 800c5cc:	6838      	ldr	r0, [r7, #0]
 800c5ce:	f013 fb2d 	bl	801fc2c <_ZN8CALIPILE7getTambEt>
 800c5d2:	eef0 7a40 	vmov.f32	s15, s0
 800c5d6:	687b      	ldr	r3, [r7, #4]
 800c5d8:	edc3 7a04 	vstr	s15, [r3, #16]
	data->objectTemp = tp->getTobj(data->objectRaw, data->ambientTemp);
 800c5dc:	687b      	ldr	r3, [r7, #4]
 800c5de:	68da      	ldr	r2, [r3, #12]
 800c5e0:	687b      	ldr	r3, [r7, #4]
 800c5e2:	edd3 7a04 	vldr	s15, [r3, #16]
 800c5e6:	eeb0 0a67 	vmov.f32	s0, s15
 800c5ea:	4611      	mov	r1, r2
 800c5ec:	6838      	ldr	r0, [r7, #0]
 800c5ee:	f013 fb4f 	bl	801fc90 <_ZN8CALIPILE7getTobjEmf>
 800c5f2:	eef0 7a40 	vmov.f32	s15, s0
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	edc3 7a05 	vstr	s15, [r3, #20]
}
 800c5fc:	bf00      	nop
 800c5fe:	3708      	adds	r7, #8
 800c600:	46bd      	mov	sp, r7
 800c602:	bd80      	pop	{r7, pc}

0800c604 <triggerThermopileSample>:

static void triggerThermopileSample(void *argument) {
 800c604:	b580      	push	{r7, lr}
 800c606:	b082      	sub	sp, #8
 800c608:	af00      	add	r7, sp, #0
 800c60a:	6078      	str	r0, [r7, #4]
	osThreadFlagsSet(thermopileTaskHandle, GRAB_SAMPLE_BIT);
 800c60c:	4b05      	ldr	r3, [pc, #20]	; (800c624 <triggerThermopileSample+0x20>)
 800c60e:	681b      	ldr	r3, [r3, #0]
 800c610:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c614:	4618      	mov	r0, r3
 800c616:	f016 f819 	bl	802264c <osThreadFlagsSet>
}
 800c61a:	bf00      	nop
 800c61c:	3708      	adds	r7, #8
 800c61e:	46bd      	mov	sp, r7
 800c620:	bd80      	pop	{r7, pc}
 800c622:	bf00      	nop
 800c624:	200003d4 	.word	0x200003d4

0800c628 <_Z41__static_initialization_and_destruction_0ii>:
 800c628:	b580      	push	{r7, lr}
 800c62a:	b082      	sub	sp, #8
 800c62c:	af00      	add	r7, sp, #0
 800c62e:	6078      	str	r0, [r7, #4]
 800c630:	6039      	str	r1, [r7, #0]
 800c632:	687b      	ldr	r3, [r7, #4]
 800c634:	2b01      	cmp	r3, #1
 800c636:	d113      	bne.n	800c660 <_Z41__static_initialization_and_destruction_0ii+0x38>
 800c638:	683b      	ldr	r3, [r7, #0]
 800c63a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800c63e:	4293      	cmp	r3, r2
 800c640:	d10e      	bne.n	800c660 <_Z41__static_initialization_and_destruction_0ii+0x38>
CALIPILE tp_nose_tip;
 800c642:	4809      	ldr	r0, [pc, #36]	; (800c668 <_Z41__static_initialization_and_destruction_0ii+0x40>)
 800c644:	f7ff fe1e 	bl	800c284 <_ZN8CALIPILEC1Ev>
CALIPILE tp_nose_bridge;
 800c648:	4808      	ldr	r0, [pc, #32]	; (800c66c <_Z41__static_initialization_and_destruction_0ii+0x44>)
 800c64a:	f7ff fe1b 	bl	800c284 <_ZN8CALIPILEC1Ev>
CALIPILE tp_temple_front;
 800c64e:	4808      	ldr	r0, [pc, #32]	; (800c670 <_Z41__static_initialization_and_destruction_0ii+0x48>)
 800c650:	f7ff fe18 	bl	800c284 <_ZN8CALIPILEC1Ev>
CALIPILE tp_temple_mid;
 800c654:	4807      	ldr	r0, [pc, #28]	; (800c674 <_Z41__static_initialization_and_destruction_0ii+0x4c>)
 800c656:	f7ff fe15 	bl	800c284 <_ZN8CALIPILEC1Ev>
CALIPILE tp_temple_back;
 800c65a:	4807      	ldr	r0, [pc, #28]	; (800c678 <_Z41__static_initialization_and_destruction_0ii+0x50>)
 800c65c:	f7ff fe12 	bl	800c284 <_ZN8CALIPILEC1Ev>
}
 800c660:	bf00      	nop
 800c662:	3708      	adds	r7, #8
 800c664:	46bd      	mov	sp, r7
 800c666:	bd80      	pop	{r7, pc}
 800c668:	200029a0 	.word	0x200029a0
 800c66c:	200029c4 	.word	0x200029c4
 800c670:	200029e8 	.word	0x200029e8
 800c674:	20002a0c 	.word	0x20002a0c
 800c678:	20002a30 	.word	0x20002a30

0800c67c <_GLOBAL__sub_I_periodicThermopileTimer_id>:
 800c67c:	b580      	push	{r7, lr}
 800c67e:	af00      	add	r7, sp, #0
 800c680:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800c684:	2001      	movs	r0, #1
 800c686:	f7ff ffcf 	bl	800c628 <_Z41__static_initialization_and_destruction_0ii>
 800c68a:	bd80      	pop	{r7, pc}

0800c68c <LL_AHB2_GRP1_EnableClock>:
{
 800c68c:	b480      	push	{r7}
 800c68e:	b085      	sub	sp, #20
 800c690:	af00      	add	r7, sp, #0
 800c692:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800c694:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c698:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c69a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c69e:	687b      	ldr	r3, [r7, #4]
 800c6a0:	4313      	orrs	r3, r2
 800c6a2:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800c6a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c6a8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c6aa:	687b      	ldr	r3, [r7, #4]
 800c6ac:	4013      	ands	r3, r2
 800c6ae:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800c6b0:	68fb      	ldr	r3, [r7, #12]
}
 800c6b2:	bf00      	nop
 800c6b4:	3714      	adds	r7, #20
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6bc:	4770      	bx	lr

0800c6be <LL_APB1_GRP1_EnableClock>:
{
 800c6be:	b480      	push	{r7}
 800c6c0:	b085      	sub	sp, #20
 800c6c2:	af00      	add	r7, sp, #0
 800c6c4:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 800c6c6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c6ca:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800c6cc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c6d0:	687b      	ldr	r3, [r7, #4]
 800c6d2:	4313      	orrs	r3, r2
 800c6d4:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800c6d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c6da:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800c6dc:	687b      	ldr	r3, [r7, #4]
 800c6de:	4013      	ands	r3, r2
 800c6e0:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800c6e2:	68fb      	ldr	r3, [r7, #12]
}
 800c6e4:	bf00      	nop
 800c6e6:	3714      	adds	r7, #20
 800c6e8:	46bd      	mov	sp, r7
 800c6ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c6ee:	4770      	bx	lr

0800c6f0 <LL_APB2_GRP1_EnableClock>:
{
 800c6f0:	b480      	push	{r7}
 800c6f2:	b085      	sub	sp, #20
 800c6f4:	af00      	add	r7, sp, #0
 800c6f6:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2ENR, Periphs);
 800c6f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c6fc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800c6fe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c702:	687b      	ldr	r3, [r7, #4]
 800c704:	4313      	orrs	r3, r2
 800c706:	660b      	str	r3, [r1, #96]	; 0x60
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800c708:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c70c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800c70e:	687b      	ldr	r3, [r7, #4]
 800c710:	4013      	ands	r3, r2
 800c712:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800c714:	68fb      	ldr	r3, [r7, #12]
}
 800c716:	bf00      	nop
 800c718:	3714      	adds	r7, #20
 800c71a:	46bd      	mov	sp, r7
 800c71c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c720:	4770      	bx	lr
	...

0800c724 <MX_TIM2_Init>:
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim16;

/* TIM2 init function */
void MX_TIM2_Init(void)
{
 800c724:	b580      	push	{r7, lr}
 800c726:	b08e      	sub	sp, #56	; 0x38
 800c728:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800c72a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c72e:	2200      	movs	r2, #0
 800c730:	601a      	str	r2, [r3, #0]
 800c732:	605a      	str	r2, [r3, #4]
 800c734:	609a      	str	r2, [r3, #8]
 800c736:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800c738:	f107 031c 	add.w	r3, r7, #28
 800c73c:	2200      	movs	r2, #0
 800c73e:	601a      	str	r2, [r3, #0]
 800c740:	605a      	str	r2, [r3, #4]
 800c742:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 800c744:	463b      	mov	r3, r7
 800c746:	2200      	movs	r2, #0
 800c748:	601a      	str	r2, [r3, #0]
 800c74a:	605a      	str	r2, [r3, #4]
 800c74c:	609a      	str	r2, [r3, #8]
 800c74e:	60da      	str	r2, [r3, #12]
 800c750:	611a      	str	r2, [r3, #16]
 800c752:	615a      	str	r2, [r3, #20]
 800c754:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 800c756:	4b2c      	ldr	r3, [pc, #176]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c758:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800c75c:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 6399;
 800c75e:	4b2a      	ldr	r3, [pc, #168]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c760:	f641 02ff 	movw	r2, #6399	; 0x18ff
 800c764:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800c766:	4b28      	ldr	r3, [pc, #160]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c768:	2200      	movs	r2, #0
 800c76a:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 19;
 800c76c:	4b26      	ldr	r3, [pc, #152]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c76e:	2213      	movs	r2, #19
 800c770:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800c772:	4b25      	ldr	r3, [pc, #148]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c774:	2200      	movs	r2, #0
 800c776:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 800c778:	4b23      	ldr	r3, [pc, #140]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c77a:	2280      	movs	r2, #128	; 0x80
 800c77c:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 800c77e:	4822      	ldr	r0, [pc, #136]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c780:	f008 fc30 	bl	8014fe4 <HAL_TIM_Base_Init>
 800c784:	4603      	mov	r3, r0
 800c786:	2b00      	cmp	r3, #0
 800c788:	d001      	beq.n	800c78e <MX_TIM2_Init+0x6a>
  {
    Error_Handler();
 800c78a:	f7fe fbaf 	bl	800aeec <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800c78e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c792:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 800c794:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c798:	4619      	mov	r1, r3
 800c79a:	481b      	ldr	r0, [pc, #108]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c79c:	f009 f838 	bl	8015810 <HAL_TIM_ConfigClockSource>
 800c7a0:	4603      	mov	r3, r0
 800c7a2:	2b00      	cmp	r3, #0
 800c7a4:	d001      	beq.n	800c7aa <MX_TIM2_Init+0x86>
  {
    Error_Handler();
 800c7a6:	f7fe fba1 	bl	800aeec <Error_Handler>
  }
  if (HAL_TIM_OC_Init(&htim2) != HAL_OK)
 800c7aa:	4817      	ldr	r0, [pc, #92]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c7ac:	f008 fcc0 	bl	8015130 <HAL_TIM_OC_Init>
 800c7b0:	4603      	mov	r3, r0
 800c7b2:	2b00      	cmp	r3, #0
 800c7b4:	d001      	beq.n	800c7ba <MX_TIM2_Init+0x96>
  {
    Error_Handler();
 800c7b6:	f7fe fb99 	bl	800aeec <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 800c7ba:	2320      	movs	r3, #32
 800c7bc:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800c7be:	2300      	movs	r3, #0
 800c7c0:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800c7c2:	f107 031c 	add.w	r3, r7, #28
 800c7c6:	4619      	mov	r1, r3
 800c7c8:	480f      	ldr	r0, [pc, #60]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c7ca:	f009 fc87 	bl	80160dc <HAL_TIMEx_MasterConfigSynchronization>
 800c7ce:	4603      	mov	r3, r0
 800c7d0:	2b00      	cmp	r3, #0
 800c7d2:	d001      	beq.n	800c7d8 <MX_TIM2_Init+0xb4>
  {
    Error_Handler();
 800c7d4:	f7fe fb8a 	bl	800aeec <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_TIMING;
 800c7d8:	2300      	movs	r3, #0
 800c7da:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 800c7dc:	2300      	movs	r3, #0
 800c7de:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800c7e0:	2300      	movs	r3, #0
 800c7e2:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800c7e4:	2300      	movs	r3, #0
 800c7e6:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_OC_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 800c7e8:	463b      	mov	r3, r7
 800c7ea:	220c      	movs	r2, #12
 800c7ec:	4619      	mov	r1, r3
 800c7ee:	4806      	ldr	r0, [pc, #24]	; (800c808 <MX_TIM2_Init+0xe4>)
 800c7f0:	f008 fe80 	bl	80154f4 <HAL_TIM_OC_ConfigChannel>
 800c7f4:	4603      	mov	r3, r0
 800c7f6:	2b00      	cmp	r3, #0
 800c7f8:	d001      	beq.n	800c7fe <MX_TIM2_Init+0xda>
  {
    Error_Handler();
 800c7fa:	f7fe fb77 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 800c7fe:	bf00      	nop
 800c800:	3738      	adds	r7, #56	; 0x38
 800c802:	46bd      	mov	sp, r7
 800c804:	bd80      	pop	{r7, pc}
 800c806:	bf00      	nop
 800c808:	200122a0 	.word	0x200122a0

0800c80c <MX_TIM16_Init>:
/* TIM16 init function */
void MX_TIM16_Init(void)
{
 800c80c:	b580      	push	{r7, lr}
 800c80e:	b094      	sub	sp, #80	; 0x50
 800c810:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM16_Init 0 */

  /* USER CODE END TIM16_Init 0 */

  TIM_OC_InitTypeDef sConfigOC = {0};
 800c812:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800c816:	2200      	movs	r2, #0
 800c818:	601a      	str	r2, [r3, #0]
 800c81a:	605a      	str	r2, [r3, #4]
 800c81c:	609a      	str	r2, [r3, #8]
 800c81e:	60da      	str	r2, [r3, #12]
 800c820:	611a      	str	r2, [r3, #16]
 800c822:	615a      	str	r2, [r3, #20]
 800c824:	619a      	str	r2, [r3, #24]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 800c826:	463b      	mov	r3, r7
 800c828:	2234      	movs	r2, #52	; 0x34
 800c82a:	2100      	movs	r1, #0
 800c82c:	4618      	mov	r0, r3
 800c82e:	f01f fc65 	bl	802c0fc <memset>

  /* USER CODE BEGIN TIM16_Init 1 */

  /* USER CODE END TIM16_Init 1 */
  htim16.Instance = TIM16;
 800c832:	4b31      	ldr	r3, [pc, #196]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c834:	4a31      	ldr	r2, [pc, #196]	; (800c8fc <MX_TIM16_Init+0xf0>)
 800c836:	601a      	str	r2, [r3, #0]
  htim16.Init.Prescaler = 6399;
 800c838:	4b2f      	ldr	r3, [pc, #188]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c83a:	f641 02ff 	movw	r2, #6399	; 0x18ff
 800c83e:	605a      	str	r2, [r3, #4]
  htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
 800c840:	4b2d      	ldr	r3, [pc, #180]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c842:	2200      	movs	r2, #0
 800c844:	609a      	str	r2, [r3, #8]
  htim16.Init.Period = 99;
 800c846:	4b2c      	ldr	r3, [pc, #176]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c848:	2263      	movs	r2, #99	; 0x63
 800c84a:	60da      	str	r2, [r3, #12]
  htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800c84c:	4b2a      	ldr	r3, [pc, #168]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c84e:	2200      	movs	r2, #0
 800c850:	611a      	str	r2, [r3, #16]
  htim16.Init.RepetitionCounter = 0;
 800c852:	4b29      	ldr	r3, [pc, #164]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c854:	2200      	movs	r2, #0
 800c856:	615a      	str	r2, [r3, #20]
  htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800c858:	4b27      	ldr	r3, [pc, #156]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c85a:	2200      	movs	r2, #0
 800c85c:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
 800c85e:	4826      	ldr	r0, [pc, #152]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c860:	f008 fbc0 	bl	8014fe4 <HAL_TIM_Base_Init>
 800c864:	4603      	mov	r3, r0
 800c866:	2b00      	cmp	r3, #0
 800c868:	d001      	beq.n	800c86e <MX_TIM16_Init+0x62>
  {
    Error_Handler();
 800c86a:	f7fe fb3f 	bl	800aeec <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim16) != HAL_OK)
 800c86e:	4822      	ldr	r0, [pc, #136]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c870:	f008 fcbf 	bl	80151f2 <HAL_TIM_PWM_Init>
 800c874:	4603      	mov	r3, r0
 800c876:	2b00      	cmp	r3, #0
 800c878:	d001      	beq.n	800c87e <MX_TIM16_Init+0x72>
  {
    Error_Handler();
 800c87a:	f7fe fb37 	bl	800aeec <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800c87e:	2360      	movs	r3, #96	; 0x60
 800c880:	637b      	str	r3, [r7, #52]	; 0x34
  sConfigOC.Pulse = 50;
 800c882:	2332      	movs	r3, #50	; 0x32
 800c884:	63bb      	str	r3, [r7, #56]	; 0x38
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800c886:	2300      	movs	r3, #0
 800c888:	63fb      	str	r3, [r7, #60]	; 0x3c
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800c88a:	2300      	movs	r3, #0
 800c88c:	643b      	str	r3, [r7, #64]	; 0x40
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800c88e:	2300      	movs	r3, #0
 800c890:	647b      	str	r3, [r7, #68]	; 0x44
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 800c892:	2300      	movs	r3, #0
 800c894:	64bb      	str	r3, [r7, #72]	; 0x48
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 800c896:	2300      	movs	r3, #0
 800c898:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim16, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800c89a:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800c89e:	2200      	movs	r2, #0
 800c8a0:	4619      	mov	r1, r3
 800c8a2:	4815      	ldr	r0, [pc, #84]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c8a4:	f008 fea0 	bl	80155e8 <HAL_TIM_PWM_ConfigChannel>
 800c8a8:	4603      	mov	r3, r0
 800c8aa:	2b00      	cmp	r3, #0
 800c8ac:	d001      	beq.n	800c8b2 <MX_TIM16_Init+0xa6>
  {
    Error_Handler();
 800c8ae:	f7fe fb1d 	bl	800aeec <Error_Handler>
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 800c8b2:	2300      	movs	r3, #0
 800c8b4:	603b      	str	r3, [r7, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 800c8b6:	2300      	movs	r3, #0
 800c8b8:	607b      	str	r3, [r7, #4]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800c8ba:	2300      	movs	r3, #0
 800c8bc:	60bb      	str	r3, [r7, #8]
  sBreakDeadTimeConfig.DeadTime = 0;
 800c8be:	2300      	movs	r3, #0
 800c8c0:	60fb      	str	r3, [r7, #12]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 800c8c2:	2300      	movs	r3, #0
 800c8c4:	613b      	str	r3, [r7, #16]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 800c8c6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c8ca:	617b      	str	r3, [r7, #20]
  sBreakDeadTimeConfig.BreakFilter = 0;
 800c8cc:	2300      	movs	r3, #0
 800c8ce:	61bb      	str	r3, [r7, #24]
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 800c8d0:	2300      	movs	r3, #0
 800c8d2:	633b      	str	r3, [r7, #48]	; 0x30
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim16, &sBreakDeadTimeConfig) != HAL_OK)
 800c8d4:	463b      	mov	r3, r7
 800c8d6:	4619      	mov	r1, r3
 800c8d8:	4807      	ldr	r0, [pc, #28]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c8da:	f009 fc5f 	bl	801619c <HAL_TIMEx_ConfigBreakDeadTime>
 800c8de:	4603      	mov	r3, r0
 800c8e0:	2b00      	cmp	r3, #0
 800c8e2:	d001      	beq.n	800c8e8 <MX_TIM16_Init+0xdc>
  {
    Error_Handler();
 800c8e4:	f7fe fb02 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN TIM16_Init 2 */

  /* USER CODE END TIM16_Init 2 */
  HAL_TIM_MspPostInit(&htim16);
 800c8e8:	4803      	ldr	r0, [pc, #12]	; (800c8f8 <MX_TIM16_Init+0xec>)
 800c8ea:	f000 f835 	bl	800c958 <HAL_TIM_MspPostInit>

}
 800c8ee:	bf00      	nop
 800c8f0:	3750      	adds	r7, #80	; 0x50
 800c8f2:	46bd      	mov	sp, r7
 800c8f4:	bd80      	pop	{r7, pc}
 800c8f6:	bf00      	nop
 800c8f8:	200122ec 	.word	0x200122ec
 800c8fc:	40014400 	.word	0x40014400

0800c900 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
 800c900:	b580      	push	{r7, lr}
 800c902:	b082      	sub	sp, #8
 800c904:	af00      	add	r7, sp, #0
 800c906:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM2)
 800c908:	687b      	ldr	r3, [r7, #4]
 800c90a:	681b      	ldr	r3, [r3, #0]
 800c90c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800c910:	d10b      	bne.n	800c92a <HAL_TIM_Base_MspInit+0x2a>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 800c912:	2001      	movs	r0, #1
 800c914:	f7ff fed3 	bl	800c6be <LL_APB1_GRP1_EnableClock>

    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 800c918:	2200      	movs	r2, #0
 800c91a:	2105      	movs	r1, #5
 800c91c:	201c      	movs	r0, #28
 800c91e:	f001 f88d 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 800c922:	201c      	movs	r0, #28
 800c924:	f001 f8a4 	bl	800da70 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
  /* USER CODE BEGIN TIM16_MspInit 1 */

  /* USER CODE END TIM16_MspInit 1 */
  }
}
 800c928:	e010      	b.n	800c94c <HAL_TIM_Base_MspInit+0x4c>
  else if(tim_baseHandle->Instance==TIM16)
 800c92a:	687b      	ldr	r3, [r7, #4]
 800c92c:	681b      	ldr	r3, [r3, #0]
 800c92e:	4a09      	ldr	r2, [pc, #36]	; (800c954 <HAL_TIM_Base_MspInit+0x54>)
 800c930:	4293      	cmp	r3, r2
 800c932:	d10b      	bne.n	800c94c <HAL_TIM_Base_MspInit+0x4c>
    __HAL_RCC_TIM16_CLK_ENABLE();
 800c934:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800c938:	f7ff feda 	bl	800c6f0 <LL_APB2_GRP1_EnableClock>
    HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, 15, 0);
 800c93c:	2200      	movs	r2, #0
 800c93e:	210f      	movs	r1, #15
 800c940:	2019      	movs	r0, #25
 800c942:	f001 f87b 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn);
 800c946:	2019      	movs	r0, #25
 800c948:	f001 f892 	bl	800da70 <HAL_NVIC_EnableIRQ>
}
 800c94c:	bf00      	nop
 800c94e:	3708      	adds	r7, #8
 800c950:	46bd      	mov	sp, r7
 800c952:	bd80      	pop	{r7, pc}
 800c954:	40014400 	.word	0x40014400

0800c958 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 800c958:	b580      	push	{r7, lr}
 800c95a:	b088      	sub	sp, #32
 800c95c:	af00      	add	r7, sp, #0
 800c95e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800c960:	f107 030c 	add.w	r3, r7, #12
 800c964:	2200      	movs	r2, #0
 800c966:	601a      	str	r2, [r3, #0]
 800c968:	605a      	str	r2, [r3, #4]
 800c96a:	609a      	str	r2, [r3, #8]
 800c96c:	60da      	str	r2, [r3, #12]
 800c96e:	611a      	str	r2, [r3, #16]
  if(timHandle->Instance==TIM16)
 800c970:	687b      	ldr	r3, [r7, #4]
 800c972:	681b      	ldr	r3, [r3, #0]
 800c974:	4a0d      	ldr	r2, [pc, #52]	; (800c9ac <HAL_TIM_MspPostInit+0x54>)
 800c976:	4293      	cmp	r3, r2
 800c978:	d113      	bne.n	800c9a2 <HAL_TIM_MspPostInit+0x4a>
  {
  /* USER CODE BEGIN TIM16_MspPostInit 0 */

  /* USER CODE END TIM16_MspPostInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800c97a:	2001      	movs	r0, #1
 800c97c:	f7ff fe86 	bl	800c68c <LL_AHB2_GRP1_EnableClock>
    /**TIM16 GPIO Configuration
    PA6     ------> TIM16_CH1
    */
    GPIO_InitStruct.Pin = BLINK_PWM_Pin;
 800c980:	2340      	movs	r3, #64	; 0x40
 800c982:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800c984:	2302      	movs	r3, #2
 800c986:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800c988:	2300      	movs	r3, #0
 800c98a:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800c98c:	2300      	movs	r3, #0
 800c98e:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF14_TIM16;
 800c990:	230e      	movs	r3, #14
 800c992:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(BLINK_PWM_GPIO_Port, &GPIO_InitStruct);
 800c994:	f107 030c 	add.w	r3, r7, #12
 800c998:	4619      	mov	r1, r3
 800c99a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800c99e:	f001 fa5b 	bl	800de58 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM16_MspPostInit 1 */

  /* USER CODE END TIM16_MspPostInit 1 */
  }

}
 800c9a2:	bf00      	nop
 800c9a4:	3720      	adds	r7, #32
 800c9a6:	46bd      	mov	sp, r7
 800c9a8:	bd80      	pop	{r7, pc}
 800c9aa:	bf00      	nop
 800c9ac:	40014400 	.word	0x40014400

0800c9b0 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 800c9b0:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800c9b2:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800c9b4:	3304      	adds	r3, #4

0800c9b6 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800c9b6:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800c9b8:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 800c9ba:	d3f9      	bcc.n	800c9b0 <CopyDataInit>
  bx lr
 800c9bc:	4770      	bx	lr

0800c9be <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 800c9be:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 800c9c0:	3004      	adds	r0, #4

0800c9c2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 800c9c2:	4288      	cmp	r0, r1
  bcc FillZerobss
 800c9c4:	d3fb      	bcc.n	800c9be <FillZerobss>
  bx lr
 800c9c6:	4770      	bx	lr

0800c9c8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:  ldr   r0, =_estack
 800c9c8:	480c      	ldr	r0, [pc, #48]	; (800c9fc <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 800c9ca:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800c9cc:	f7ff fc08 	bl	800c1e0 <SystemInit>
  
/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 800c9d0:	480b      	ldr	r0, [pc, #44]	; (800ca00 <LoopForever+0x8>)
 800c9d2:	490c      	ldr	r1, [pc, #48]	; (800ca04 <LoopForever+0xc>)
 800c9d4:	4a0c      	ldr	r2, [pc, #48]	; (800ca08 <LoopForever+0x10>)
 800c9d6:	2300      	movs	r3, #0
 800c9d8:	f7ff ffed 	bl	800c9b6 <LoopCopyDataInit>

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 800c9dc:	480b      	ldr	r0, [pc, #44]	; (800ca0c <LoopForever+0x14>)
 800c9de:	490c      	ldr	r1, [pc, #48]	; (800ca10 <LoopForever+0x18>)
 800c9e0:	2300      	movs	r3, #0
 800c9e2:	f7ff ffee 	bl	800c9c2 <LoopFillZerobss>
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800c9e6:	480b      	ldr	r0, [pc, #44]	; (800ca14 <LoopForever+0x1c>)
 800c9e8:	490b      	ldr	r1, [pc, #44]	; (800ca18 <LoopForever+0x20>)
 800c9ea:	2300      	movs	r3, #0
 800c9ec:	f7ff ffe9 	bl	800c9c2 <LoopFillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800c9f0:	f01f fb40 	bl	802c074 <__libc_init_array>
/* Call the application s entry point.*/
	bl	main
 800c9f4:	f7fe f978 	bl	800ace8 <main>

0800c9f8 <LoopForever>:

LoopForever:
  b LoopForever
 800c9f8:	e7fe      	b.n	800c9f8 <LoopForever>
 800c9fa:	0000      	.short	0x0000
Reset_Handler:  ldr   r0, =_estack
 800c9fc:	20030000 	.word	0x20030000
  INIT_DATA _sdata, _edata, _sidata
 800ca00:	20000004 	.word	0x20000004
 800ca04:	20000218 	.word	0x20000218
 800ca08:	0802ddec 	.word	0x0802ddec
  INIT_BSS _sbss, _ebss
 800ca0c:	20000398 	.word	0x20000398
 800ca10:	20013bac 	.word	0x20013bac
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800ca14:	200301e0 	.word	0x200301e0
 800ca18:	20030a57 	.word	0x20030a57

0800ca1c <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800ca1c:	e7fe      	b.n	800ca1c <ADC1_IRQHandler>
	...

0800ca20 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800ca20:	b580      	push	{r7, lr}
 800ca22:	b082      	sub	sp, #8
 800ca24:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800ca26:	2300      	movs	r3, #0
 800ca28:	71fb      	strb	r3, [r7, #7]
#if (DATA_CACHE_ENABLE == 0U)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800ca2a:	4b0c      	ldr	r3, [pc, #48]	; (800ca5c <HAL_Init+0x3c>)
 800ca2c:	681b      	ldr	r3, [r3, #0]
 800ca2e:	4a0b      	ldr	r2, [pc, #44]	; (800ca5c <HAL_Init+0x3c>)
 800ca30:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ca34:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800ca36:	2003      	movs	r0, #3
 800ca38:	f000 fff5 	bl	800da26 <HAL_NVIC_SetPriorityGrouping>
  
  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800ca3c:	200f      	movs	r0, #15
 800ca3e:	f7ff fab1 	bl	800bfa4 <HAL_InitTick>
 800ca42:	4603      	mov	r3, r0
 800ca44:	2b00      	cmp	r3, #0
 800ca46:	d002      	beq.n	800ca4e <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 800ca48:	2301      	movs	r3, #1
 800ca4a:	71fb      	strb	r3, [r7, #7]
 800ca4c:	e001      	b.n	800ca52 <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 800ca4e:	f7ff fa7a 	bl	800bf46 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800ca52:	79fb      	ldrb	r3, [r7, #7]
}
 800ca54:	4618      	mov	r0, r3
 800ca56:	3708      	adds	r7, #8
 800ca58:	46bd      	mov	sp, r7
 800ca5a:	bd80      	pop	{r7, pc}
 800ca5c:	58004000 	.word	0x58004000

0800ca60 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800ca60:	b480      	push	{r7}
 800ca62:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800ca64:	4b06      	ldr	r3, [pc, #24]	; (800ca80 <HAL_IncTick+0x20>)
 800ca66:	781b      	ldrb	r3, [r3, #0]
 800ca68:	461a      	mov	r2, r3
 800ca6a:	4b06      	ldr	r3, [pc, #24]	; (800ca84 <HAL_IncTick+0x24>)
 800ca6c:	681b      	ldr	r3, [r3, #0]
 800ca6e:	4413      	add	r3, r2
 800ca70:	4a04      	ldr	r2, [pc, #16]	; (800ca84 <HAL_IncTick+0x24>)
 800ca72:	6013      	str	r3, [r2, #0]
}
 800ca74:	bf00      	nop
 800ca76:	46bd      	mov	sp, r7
 800ca78:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca7c:	4770      	bx	lr
 800ca7e:	bf00      	nop
 800ca80:	20000018 	.word	0x20000018
 800ca84:	20012338 	.word	0x20012338

0800ca88 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800ca88:	b480      	push	{r7}
 800ca8a:	af00      	add	r7, sp, #0
  return uwTick;
 800ca8c:	4b03      	ldr	r3, [pc, #12]	; (800ca9c <HAL_GetTick+0x14>)
 800ca8e:	681b      	ldr	r3, [r3, #0]
}
 800ca90:	4618      	mov	r0, r3
 800ca92:	46bd      	mov	sp, r7
 800ca94:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca98:	4770      	bx	lr
 800ca9a:	bf00      	nop
 800ca9c:	20012338 	.word	0x20012338

0800caa0 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
 800caa0:	b480      	push	{r7}
 800caa2:	af00      	add	r7, sp, #0
  return uwTickPrio;
 800caa4:	4b03      	ldr	r3, [pc, #12]	; (800cab4 <HAL_GetTickPrio+0x14>)
 800caa6:	681b      	ldr	r3, [r3, #0]
}
 800caa8:	4618      	mov	r0, r3
 800caaa:	46bd      	mov	sp, r7
 800caac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cab0:	4770      	bx	lr
 800cab2:	bf00      	nop
 800cab4:	20000014 	.word	0x20000014

0800cab8 <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
 800cab8:	b480      	push	{r7}
 800caba:	af00      	add	r7, sp, #0
  return uwTickFreq;
 800cabc:	4b03      	ldr	r3, [pc, #12]	; (800cacc <HAL_GetTickFreq+0x14>)
 800cabe:	781b      	ldrb	r3, [r3, #0]
}
 800cac0:	4618      	mov	r0, r3
 800cac2:	46bd      	mov	sp, r7
 800cac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cac8:	4770      	bx	lr
 800caca:	bf00      	nop
 800cacc:	20000018 	.word	0x20000018

0800cad0 <LL_ADC_SetCommonClock>:
  *
  *         (*) Value available on all STM32 devices except: STM32W10xxx, STM32W15xxx.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 800cad0:	b480      	push	{r7}
 800cad2:	b083      	sub	sp, #12
 800cad4:	af00      	add	r7, sp, #0
 800cad6:	6078      	str	r0, [r7, #4]
 800cad8:	6039      	str	r1, [r7, #0]
#if defined (ADC_SUPPORT_2_5_MSPS)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_PRESC, CommonClock);
#else
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 800cada:	687b      	ldr	r3, [r7, #4]
 800cadc:	689b      	ldr	r3, [r3, #8]
 800cade:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 800cae2:	683b      	ldr	r3, [r7, #0]
 800cae4:	431a      	orrs	r2, r3
 800cae6:	687b      	ldr	r3, [r7, #4]
 800cae8:	609a      	str	r2, [r3, #8]
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 800caea:	bf00      	nop
 800caec:	370c      	adds	r7, #12
 800caee:	46bd      	mov	sp, r7
 800caf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800caf4:	4770      	bx	lr

0800caf6 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 800caf6:	b480      	push	{r7}
 800caf8:	b083      	sub	sp, #12
 800cafa:	af00      	add	r7, sp, #0
 800cafc:	6078      	str	r0, [r7, #4]
 800cafe:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800cb00:	687b      	ldr	r3, [r7, #4]
 800cb02:	689b      	ldr	r3, [r3, #8]
 800cb04:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 800cb08:	683b      	ldr	r3, [r7, #0]
 800cb0a:	431a      	orrs	r2, r3
 800cb0c:	687b      	ldr	r3, [r7, #4]
 800cb0e:	609a      	str	r2, [r3, #8]
}
 800cb10:	bf00      	nop
 800cb12:	370c      	adds	r7, #12
 800cb14:	46bd      	mov	sp, r7
 800cb16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb1a:	4770      	bx	lr

0800cb1c <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 800cb1c:	b480      	push	{r7}
 800cb1e:	b083      	sub	sp, #12
 800cb20:	af00      	add	r7, sp, #0
 800cb22:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800cb24:	687b      	ldr	r3, [r7, #4]
 800cb26:	689b      	ldr	r3, [r3, #8]
 800cb28:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 800cb2c:	4618      	mov	r0, r3
 800cb2e:	370c      	adds	r7, #12
 800cb30:	46bd      	mov	sp, r7
 800cb32:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb36:	4770      	bx	lr

0800cb38 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 800cb38:	b480      	push	{r7}
 800cb3a:	b087      	sub	sp, #28
 800cb3c:	af00      	add	r7, sp, #0
 800cb3e:	60f8      	str	r0, [r7, #12]
 800cb40:	60b9      	str	r1, [r7, #8]
 800cb42:	607a      	str	r2, [r7, #4]
 800cb44:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800cb46:	68fb      	ldr	r3, [r7, #12]
 800cb48:	3360      	adds	r3, #96	; 0x60
 800cb4a:	461a      	mov	r2, r3
 800cb4c:	68bb      	ldr	r3, [r7, #8]
 800cb4e:	009b      	lsls	r3, r3, #2
 800cb50:	4413      	add	r3, r2
 800cb52:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800cb54:	697b      	ldr	r3, [r7, #20]
 800cb56:	681a      	ldr	r2, [r3, #0]
 800cb58:	4b08      	ldr	r3, [pc, #32]	; (800cb7c <LL_ADC_SetOffset+0x44>)
 800cb5a:	4013      	ands	r3, r2
 800cb5c:	687a      	ldr	r2, [r7, #4]
 800cb5e:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 800cb62:	683a      	ldr	r2, [r7, #0]
 800cb64:	430a      	orrs	r2, r1
 800cb66:	4313      	orrs	r3, r2
 800cb68:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800cb6c:	697b      	ldr	r3, [r7, #20]
 800cb6e:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}
 800cb70:	bf00      	nop
 800cb72:	371c      	adds	r7, #28
 800cb74:	46bd      	mov	sp, r7
 800cb76:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb7a:	4770      	bx	lr
 800cb7c:	03fff000 	.word	0x03fff000

0800cb80 <LL_ADC_GetOffsetChannel>:
  *         (4) For ADC channel read back from ADC register,
  *             comparison with internal channel parameter to be done
  *             using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
{
 800cb80:	b480      	push	{r7}
 800cb82:	b085      	sub	sp, #20
 800cb84:	af00      	add	r7, sp, #0
 800cb86:	6078      	str	r0, [r7, #4]
 800cb88:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800cb8a:	687b      	ldr	r3, [r7, #4]
 800cb8c:	3360      	adds	r3, #96	; 0x60
 800cb8e:	461a      	mov	r2, r3
 800cb90:	683b      	ldr	r3, [r7, #0]
 800cb92:	009b      	lsls	r3, r3, #2
 800cb94:	4413      	add	r3, r2
 800cb96:	60fb      	str	r3, [r7, #12]

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800cb98:	68fb      	ldr	r3, [r7, #12]
 800cb9a:	681b      	ldr	r3, [r3, #0]
 800cb9c:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 800cba0:	4618      	mov	r0, r3
 800cba2:	3714      	adds	r7, #20
 800cba4:	46bd      	mov	sp, r7
 800cba6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbaa:	4770      	bx	lr

0800cbac <LL_ADC_SetOffsetState>:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
 800cbac:	b480      	push	{r7}
 800cbae:	b087      	sub	sp, #28
 800cbb0:	af00      	add	r7, sp, #0
 800cbb2:	60f8      	str	r0, [r7, #12]
 800cbb4:	60b9      	str	r1, [r7, #8]
 800cbb6:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800cbb8:	68fb      	ldr	r3, [r7, #12]
 800cbba:	3360      	adds	r3, #96	; 0x60
 800cbbc:	461a      	mov	r2, r3
 800cbbe:	68bb      	ldr	r3, [r7, #8]
 800cbc0:	009b      	lsls	r3, r3, #2
 800cbc2:	4413      	add	r3, r2
 800cbc4:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800cbc6:	697b      	ldr	r3, [r7, #20]
 800cbc8:	681b      	ldr	r3, [r3, #0]
 800cbca:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 800cbce:	687b      	ldr	r3, [r7, #4]
 800cbd0:	431a      	orrs	r2, r3
 800cbd2:	697b      	ldr	r3, [r7, #20]
 800cbd4:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}
 800cbd6:	bf00      	nop
 800cbd8:	371c      	adds	r7, #28
 800cbda:	46bd      	mov	sp, r7
 800cbdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbe0:	4770      	bx	lr

0800cbe2 <LL_ADC_REG_SetSequencerRanks>:
  *         (7) On STM32WB devices (except devices: STM32WB10xx, STM32WB15xx) fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 800cbe2:	b480      	push	{r7}
 800cbe4:	b087      	sub	sp, #28
 800cbe6:	af00      	add	r7, sp, #0
 800cbe8:	60f8      	str	r0, [r7, #12]
 800cbea:	60b9      	str	r1, [r7, #8]
 800cbec:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800cbee:	68fb      	ldr	r3, [r7, #12]
 800cbf0:	3330      	adds	r3, #48	; 0x30
 800cbf2:	461a      	mov	r2, r3
 800cbf4:	68bb      	ldr	r3, [r7, #8]
 800cbf6:	0a1b      	lsrs	r3, r3, #8
 800cbf8:	009b      	lsls	r3, r3, #2
 800cbfa:	f003 030c 	and.w	r3, r3, #12
 800cbfe:	4413      	add	r3, r2
 800cc00:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800cc02:	697b      	ldr	r3, [r7, #20]
 800cc04:	681a      	ldr	r2, [r3, #0]
 800cc06:	68bb      	ldr	r3, [r7, #8]
 800cc08:	f003 031f 	and.w	r3, r3, #31
 800cc0c:	211f      	movs	r1, #31
 800cc0e:	fa01 f303 	lsl.w	r3, r1, r3
 800cc12:	43db      	mvns	r3, r3
 800cc14:	401a      	ands	r2, r3
 800cc16:	687b      	ldr	r3, [r7, #4]
 800cc18:	0e9b      	lsrs	r3, r3, #26
 800cc1a:	f003 011f 	and.w	r1, r3, #31
 800cc1e:	68bb      	ldr	r3, [r7, #8]
 800cc20:	f003 031f 	and.w	r3, r3, #31
 800cc24:	fa01 f303 	lsl.w	r3, r1, r3
 800cc28:	431a      	orrs	r2, r3
 800cc2a:	697b      	ldr	r3, [r7, #20]
 800cc2c:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 800cc2e:	bf00      	nop
 800cc30:	371c      	adds	r7, #28
 800cc32:	46bd      	mov	sp, r7
 800cc34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc38:	4770      	bx	lr

0800cc3a <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 800cc3a:	b480      	push	{r7}
 800cc3c:	b087      	sub	sp, #28
 800cc3e:	af00      	add	r7, sp, #0
 800cc40:	60f8      	str	r0, [r7, #12]
 800cc42:	60b9      	str	r1, [r7, #8]
 800cc44:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800cc46:	68fb      	ldr	r3, [r7, #12]
 800cc48:	3314      	adds	r3, #20
 800cc4a:	461a      	mov	r2, r3
 800cc4c:	68bb      	ldr	r3, [r7, #8]
 800cc4e:	0e5b      	lsrs	r3, r3, #25
 800cc50:	009b      	lsls	r3, r3, #2
 800cc52:	f003 0304 	and.w	r3, r3, #4
 800cc56:	4413      	add	r3, r2
 800cc58:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800cc5a:	697b      	ldr	r3, [r7, #20]
 800cc5c:	681a      	ldr	r2, [r3, #0]
 800cc5e:	68bb      	ldr	r3, [r7, #8]
 800cc60:	0d1b      	lsrs	r3, r3, #20
 800cc62:	f003 031f 	and.w	r3, r3, #31
 800cc66:	2107      	movs	r1, #7
 800cc68:	fa01 f303 	lsl.w	r3, r1, r3
 800cc6c:	43db      	mvns	r3, r3
 800cc6e:	401a      	ands	r2, r3
 800cc70:	68bb      	ldr	r3, [r7, #8]
 800cc72:	0d1b      	lsrs	r3, r3, #20
 800cc74:	f003 031f 	and.w	r3, r3, #31
 800cc78:	6879      	ldr	r1, [r7, #4]
 800cc7a:	fa01 f303 	lsl.w	r3, r1, r3
 800cc7e:	431a      	orrs	r2, r3
 800cc80:	697b      	ldr	r3, [r7, #20]
 800cc82:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 800cc84:	bf00      	nop
 800cc86:	371c      	adds	r7, #28
 800cc88:	46bd      	mov	sp, r7
 800cc8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc8e:	4770      	bx	lr

0800cc90 <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 800cc90:	b480      	push	{r7}
 800cc92:	b085      	sub	sp, #20
 800cc94:	af00      	add	r7, sp, #0
 800cc96:	60f8      	str	r0, [r7, #12]
 800cc98:	60b9      	str	r1, [r7, #8]
 800cc9a:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 800cc9c:	68fb      	ldr	r3, [r7, #12]
 800cc9e:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 800cca2:	68bb      	ldr	r3, [r7, #8]
 800cca4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800cca8:	43db      	mvns	r3, r3
 800ccaa:	401a      	ands	r2, r3
 800ccac:	687b      	ldr	r3, [r7, #4]
 800ccae:	f003 0318 	and.w	r3, r3, #24
 800ccb2:	4908      	ldr	r1, [pc, #32]	; (800ccd4 <LL_ADC_SetChannelSingleDiff+0x44>)
 800ccb4:	40d9      	lsrs	r1, r3
 800ccb6:	68bb      	ldr	r3, [r7, #8]
 800ccb8:	400b      	ands	r3, r1
 800ccba:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ccbe:	431a      	orrs	r2, r3
 800ccc0:	68fb      	ldr	r3, [r7, #12]
 800ccc2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
 800ccc6:	bf00      	nop
 800ccc8:	3714      	adds	r7, #20
 800ccca:	46bd      	mov	sp, r7
 800cccc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccd0:	4770      	bx	lr
 800ccd2:	bf00      	nop
 800ccd4:	0007ffff 	.word	0x0007ffff

0800ccd8 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 800ccd8:	b480      	push	{r7}
 800ccda:	b083      	sub	sp, #12
 800ccdc:	af00      	add	r7, sp, #0
 800ccde:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 800cce0:	687b      	ldr	r3, [r7, #4]
 800cce2:	689b      	ldr	r3, [r3, #8]
 800cce4:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 800cce8:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800ccec:	687a      	ldr	r2, [r7, #4]
 800ccee:	6093      	str	r3, [r2, #8]
}
 800ccf0:	bf00      	nop
 800ccf2:	370c      	adds	r7, #12
 800ccf4:	46bd      	mov	sp, r7
 800ccf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccfa:	4770      	bx	lr

0800ccfc <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 800ccfc:	b480      	push	{r7}
 800ccfe:	b083      	sub	sp, #12
 800cd00:	af00      	add	r7, sp, #0
 800cd02:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 800cd04:	687b      	ldr	r3, [r7, #4]
 800cd06:	689b      	ldr	r3, [r3, #8]
 800cd08:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800cd0c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800cd10:	d101      	bne.n	800cd16 <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 800cd12:	2301      	movs	r3, #1
 800cd14:	e000      	b.n	800cd18 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 800cd16:	2300      	movs	r3, #0
}
 800cd18:	4618      	mov	r0, r3
 800cd1a:	370c      	adds	r7, #12
 800cd1c:	46bd      	mov	sp, r7
 800cd1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd22:	4770      	bx	lr

0800cd24 <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 800cd24:	b480      	push	{r7}
 800cd26:	b083      	sub	sp, #12
 800cd28:	af00      	add	r7, sp, #0
 800cd2a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 800cd2c:	687b      	ldr	r3, [r7, #4]
 800cd2e:	689b      	ldr	r3, [r3, #8]
 800cd30:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 800cd34:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800cd38:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 800cd3c:	687b      	ldr	r3, [r7, #4]
 800cd3e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 800cd40:	bf00      	nop
 800cd42:	370c      	adds	r7, #12
 800cd44:	46bd      	mov	sp, r7
 800cd46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd4a:	4770      	bx	lr

0800cd4c <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 800cd4c:	b480      	push	{r7}
 800cd4e:	b083      	sub	sp, #12
 800cd50:	af00      	add	r7, sp, #0
 800cd52:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800cd54:	687b      	ldr	r3, [r7, #4]
 800cd56:	689b      	ldr	r3, [r3, #8]
 800cd58:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800cd5c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800cd60:	d101      	bne.n	800cd66 <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 800cd62:	2301      	movs	r3, #1
 800cd64:	e000      	b.n	800cd68 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 800cd66:	2300      	movs	r3, #0
}
 800cd68:	4618      	mov	r0, r3
 800cd6a:	370c      	adds	r7, #12
 800cd6c:	46bd      	mov	sp, r7
 800cd6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd72:	4770      	bx	lr

0800cd74 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 800cd74:	b480      	push	{r7}
 800cd76:	b083      	sub	sp, #12
 800cd78:	af00      	add	r7, sp, #0
 800cd7a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800cd7c:	687b      	ldr	r3, [r7, #4]
 800cd7e:	689b      	ldr	r3, [r3, #8]
 800cd80:	f003 0301 	and.w	r3, r3, #1
 800cd84:	2b01      	cmp	r3, #1
 800cd86:	d101      	bne.n	800cd8c <LL_ADC_IsEnabled+0x18>
 800cd88:	2301      	movs	r3, #1
 800cd8a:	e000      	b.n	800cd8e <LL_ADC_IsEnabled+0x1a>
 800cd8c:	2300      	movs	r3, #0
}
 800cd8e:	4618      	mov	r0, r3
 800cd90:	370c      	adds	r7, #12
 800cd92:	46bd      	mov	sp, r7
 800cd94:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd98:	4770      	bx	lr

0800cd9a <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 800cd9a:	b480      	push	{r7}
 800cd9c:	b083      	sub	sp, #12
 800cd9e:	af00      	add	r7, sp, #0
 800cda0:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800cda2:	687b      	ldr	r3, [r7, #4]
 800cda4:	689b      	ldr	r3, [r3, #8]
 800cda6:	f003 0304 	and.w	r3, r3, #4
 800cdaa:	2b04      	cmp	r3, #4
 800cdac:	d101      	bne.n	800cdb2 <LL_ADC_REG_IsConversionOngoing+0x18>
 800cdae:	2301      	movs	r3, #1
 800cdb0:	e000      	b.n	800cdb4 <LL_ADC_REG_IsConversionOngoing+0x1a>
 800cdb2:	2300      	movs	r3, #0
}
 800cdb4:	4618      	mov	r0, r3
 800cdb6:	370c      	adds	r7, #12
 800cdb8:	46bd      	mov	sp, r7
 800cdba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdbe:	4770      	bx	lr

0800cdc0 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 800cdc0:	b480      	push	{r7}
 800cdc2:	b083      	sub	sp, #12
 800cdc4:	af00      	add	r7, sp, #0
 800cdc6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800cdc8:	687b      	ldr	r3, [r7, #4]
 800cdca:	689b      	ldr	r3, [r3, #8]
 800cdcc:	f003 0308 	and.w	r3, r3, #8
 800cdd0:	2b08      	cmp	r3, #8
 800cdd2:	d101      	bne.n	800cdd8 <LL_ADC_INJ_IsConversionOngoing+0x18>
 800cdd4:	2301      	movs	r3, #1
 800cdd6:	e000      	b.n	800cdda <LL_ADC_INJ_IsConversionOngoing+0x1a>
 800cdd8:	2300      	movs	r3, #0
}
 800cdda:	4618      	mov	r0, r3
 800cddc:	370c      	adds	r7, #12
 800cdde:	46bd      	mov	sp, r7
 800cde0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cde4:	4770      	bx	lr
	...

0800cde8 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 800cde8:	b580      	push	{r7, lr}
 800cdea:	b088      	sub	sp, #32
 800cdec:	af00      	add	r7, sp, #0
 800cdee:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800cdf0:	2300      	movs	r3, #0
 800cdf2:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR = 0UL;
 800cdf4:	2300      	movs	r3, #0
 800cdf6:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 800cdf8:	2300      	movs	r3, #0
 800cdfa:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
#endif

  /* Check ADC handle */
  if (hadc == NULL)
 800cdfc:	687b      	ldr	r3, [r7, #4]
 800cdfe:	2b00      	cmp	r3, #0
 800ce00:	d101      	bne.n	800ce06 <HAL_ADC_Init+0x1e>
  {
    return HAL_ERROR;
 800ce02:	2301      	movs	r3, #1
 800ce04:	e12e      	b.n	800d064 <HAL_ADC_Init+0x27c>
    }
  }
#else
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 800ce06:	687b      	ldr	r3, [r7, #4]
 800ce08:	691b      	ldr	r3, [r3, #16]
 800ce0a:	2b00      	cmp	r3, #0
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 800ce0c:	687b      	ldr	r3, [r7, #4]
 800ce0e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ce10:	2b00      	cmp	r3, #0
 800ce12:	d109      	bne.n	800ce28 <HAL_ADC_Init+0x40>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 800ce14:	6878      	ldr	r0, [r7, #4]
 800ce16:	f7fb fd47 	bl	80088a8 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 800ce1a:	687b      	ldr	r3, [r7, #4]
 800ce1c:	2200      	movs	r2, #0
 800ce1e:	659a      	str	r2, [r3, #88]	; 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 800ce20:	687b      	ldr	r3, [r7, #4]
 800ce22:	2200      	movs	r2, #0
 800ce24:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* - Exit from deep power-down mode and ADC voltage regulator enable        */
#if defined (ADC_SUPPORT_2_5_MSPS)
  /* Feature "deep power-down" not available on ADC peripheral of this STM32WB device */
#else
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 800ce28:	687b      	ldr	r3, [r7, #4]
 800ce2a:	681b      	ldr	r3, [r3, #0]
 800ce2c:	4618      	mov	r0, r3
 800ce2e:	f7ff ff65 	bl	800ccfc <LL_ADC_IsDeepPowerDownEnabled>
 800ce32:	4603      	mov	r3, r0
 800ce34:	2b00      	cmp	r3, #0
 800ce36:	d004      	beq.n	800ce42 <HAL_ADC_Init+0x5a>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 800ce38:	687b      	ldr	r3, [r7, #4]
 800ce3a:	681b      	ldr	r3, [r3, #0]
 800ce3c:	4618      	mov	r0, r3
 800ce3e:	f7ff ff4b 	bl	800ccd8 <LL_ADC_DisableDeepPowerDown>
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }
#endif

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800ce42:	687b      	ldr	r3, [r7, #4]
 800ce44:	681b      	ldr	r3, [r3, #0]
 800ce46:	4618      	mov	r0, r3
 800ce48:	f7ff ff80 	bl	800cd4c <LL_ADC_IsInternalRegulatorEnabled>
 800ce4c:	4603      	mov	r3, r0
 800ce4e:	2b00      	cmp	r3, #0
 800ce50:	d115      	bne.n	800ce7e <HAL_ADC_Init+0x96>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 800ce52:	687b      	ldr	r3, [r7, #4]
 800ce54:	681b      	ldr	r3, [r3, #0]
 800ce56:	4618      	mov	r0, r3
 800ce58:	f7ff ff64 	bl	800cd24 <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 800ce5c:	4b83      	ldr	r3, [pc, #524]	; (800d06c <HAL_ADC_Init+0x284>)
 800ce5e:	681b      	ldr	r3, [r3, #0]
 800ce60:	099b      	lsrs	r3, r3, #6
 800ce62:	4a83      	ldr	r2, [pc, #524]	; (800d070 <HAL_ADC_Init+0x288>)
 800ce64:	fba2 2303 	umull	r2, r3, r2, r3
 800ce68:	099b      	lsrs	r3, r3, #6
 800ce6a:	3301      	adds	r3, #1
 800ce6c:	005b      	lsls	r3, r3, #1
 800ce6e:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 800ce70:	e002      	b.n	800ce78 <HAL_ADC_Init+0x90>
    {
      wait_loop_index--;
 800ce72:	68bb      	ldr	r3, [r7, #8]
 800ce74:	3b01      	subs	r3, #1
 800ce76:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 800ce78:	68bb      	ldr	r3, [r7, #8]
 800ce7a:	2b00      	cmp	r3, #0
 800ce7c:	d1f9      	bne.n	800ce72 <HAL_ADC_Init+0x8a>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800ce7e:	687b      	ldr	r3, [r7, #4]
 800ce80:	681b      	ldr	r3, [r3, #0]
 800ce82:	4618      	mov	r0, r3
 800ce84:	f7ff ff62 	bl	800cd4c <LL_ADC_IsInternalRegulatorEnabled>
 800ce88:	4603      	mov	r3, r0
 800ce8a:	2b00      	cmp	r3, #0
 800ce8c:	d10d      	bne.n	800ceaa <HAL_ADC_Init+0xc2>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800ce8e:	687b      	ldr	r3, [r7, #4]
 800ce90:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ce92:	f043 0210 	orr.w	r2, r3, #16
 800ce96:	687b      	ldr	r3, [r7, #4]
 800ce98:	655a      	str	r2, [r3, #84]	; 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800ce9a:	687b      	ldr	r3, [r7, #4]
 800ce9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ce9e:	f043 0201 	orr.w	r2, r3, #1
 800cea2:	687b      	ldr	r3, [r7, #4]
 800cea4:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 800cea6:	2301      	movs	r3, #1
 800cea8:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800ceaa:	687b      	ldr	r3, [r7, #4]
 800ceac:	681b      	ldr	r3, [r3, #0]
 800ceae:	4618      	mov	r0, r3
 800ceb0:	f7ff ff73 	bl	800cd9a <LL_ADC_REG_IsConversionOngoing>
 800ceb4:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 800ceb6:	687b      	ldr	r3, [r7, #4]
 800ceb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ceba:	f003 0310 	and.w	r3, r3, #16
 800cebe:	2b00      	cmp	r3, #0
 800cec0:	f040 80c7 	bne.w	800d052 <HAL_ADC_Init+0x26a>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 800cec4:	697b      	ldr	r3, [r7, #20]
 800cec6:	2b00      	cmp	r3, #0
 800cec8:	f040 80c3 	bne.w	800d052 <HAL_ADC_Init+0x26a>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800cecc:	687b      	ldr	r3, [r7, #4]
 800cece:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ced0:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 800ced4:	f043 0202 	orr.w	r2, r3, #2
 800ced8:	687b      	ldr	r3, [r7, #4]
 800ceda:	655a      	str	r2, [r3, #84]	; 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800cedc:	687b      	ldr	r3, [r7, #4]
 800cede:	681b      	ldr	r3, [r3, #0]
 800cee0:	4618      	mov	r0, r3
 800cee2:	f7ff ff47 	bl	800cd74 <LL_ADC_IsEnabled>
 800cee6:	4603      	mov	r3, r0
 800cee8:	2b00      	cmp	r3, #0
 800ceea:	d10b      	bne.n	800cf04 <HAL_ADC_Init+0x11c>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800ceec:	4861      	ldr	r0, [pc, #388]	; (800d074 <HAL_ADC_Init+0x28c>)
 800ceee:	f7ff ff41 	bl	800cd74 <LL_ADC_IsEnabled>
 800cef2:	4603      	mov	r3, r0
 800cef4:	2b00      	cmp	r3, #0
 800cef6:	d105      	bne.n	800cf04 <HAL_ADC_Init+0x11c>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800cef8:	687b      	ldr	r3, [r7, #4]
 800cefa:	685b      	ldr	r3, [r3, #4]
 800cefc:	4619      	mov	r1, r3
 800cefe:	485e      	ldr	r0, [pc, #376]	; (800d078 <HAL_ADC_Init+0x290>)
 800cf00:	f7ff fde6 	bl	800cad0 <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800cf04:	687b      	ldr	r3, [r7, #4]
 800cf06:	7e5b      	ldrb	r3, [r3, #25]
 800cf08:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 800cf0a:	687b      	ldr	r3, [r7, #4]
 800cf0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800cf0e:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 800cf10:	687b      	ldr	r3, [r7, #4]
 800cf12:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 800cf14:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 800cf16:	687b      	ldr	r3, [r7, #4]
 800cf18:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 800cf1a:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 800cf1c:	687b      	ldr	r3, [r7, #4]
 800cf1e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800cf22:	041b      	lsls	r3, r3, #16
                hadc->Init.Resolution                                                  |
 800cf24:	4313      	orrs	r3, r2
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800cf26:	69ba      	ldr	r2, [r7, #24]
 800cf28:	4313      	orrs	r3, r2
 800cf2a:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800cf2c:	687b      	ldr	r3, [r7, #4]
 800cf2e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800cf32:	2b01      	cmp	r3, #1
 800cf34:	d106      	bne.n	800cf44 <HAL_ADC_Init+0x15c>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 800cf36:	687b      	ldr	r3, [r7, #4]
 800cf38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cf3a:	3b01      	subs	r3, #1
 800cf3c:	045b      	lsls	r3, r3, #17
 800cf3e:	69ba      	ldr	r2, [r7, #24]
 800cf40:	4313      	orrs	r3, r2
 800cf42:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800cf44:	687b      	ldr	r3, [r7, #4]
 800cf46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cf48:	2b00      	cmp	r3, #0
 800cf4a:	d009      	beq.n	800cf60 <HAL_ADC_Init+0x178>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800cf4c:	687b      	ldr	r3, [r7, #4]
 800cf4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cf50:	f403 7270 	and.w	r2, r3, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 800cf54:	687b      	ldr	r3, [r7, #4]
 800cf56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cf58:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800cf5a:	69ba      	ldr	r2, [r7, #24]
 800cf5c:	4313      	orrs	r3, r2
 800cf5e:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 800cf60:	687b      	ldr	r3, [r7, #4]
 800cf62:	681b      	ldr	r3, [r3, #0]
 800cf64:	68da      	ldr	r2, [r3, #12]
 800cf66:	4b45      	ldr	r3, [pc, #276]	; (800d07c <HAL_ADC_Init+0x294>)
 800cf68:	4013      	ands	r3, r2
 800cf6a:	687a      	ldr	r2, [r7, #4]
 800cf6c:	6812      	ldr	r2, [r2, #0]
 800cf6e:	69b9      	ldr	r1, [r7, #24]
 800cf70:	430b      	orrs	r3, r1
 800cf72:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800cf74:	687b      	ldr	r3, [r7, #4]
 800cf76:	681b      	ldr	r3, [r3, #0]
 800cf78:	4618      	mov	r0, r3
 800cf7a:	f7ff ff0e 	bl	800cd9a <LL_ADC_REG_IsConversionOngoing>
 800cf7e:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800cf80:	687b      	ldr	r3, [r7, #4]
 800cf82:	681b      	ldr	r3, [r3, #0]
 800cf84:	4618      	mov	r0, r3
 800cf86:	f7ff ff1b 	bl	800cdc0 <LL_ADC_INJ_IsConversionOngoing>
 800cf8a:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800cf8c:	693b      	ldr	r3, [r7, #16]
 800cf8e:	2b00      	cmp	r3, #0
 800cf90:	d13d      	bne.n	800d00e <HAL_ADC_Init+0x226>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800cf92:	68fb      	ldr	r3, [r7, #12]
 800cf94:	2b00      	cmp	r3, #0
 800cf96:	d13a      	bne.n	800d00e <HAL_ADC_Init+0x226>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	7e1b      	ldrb	r3, [r3, #24]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 800cf9c:	039a      	lsls	r2, r3, #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 800cf9e:	687b      	ldr	r3, [r7, #4]
 800cfa0:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800cfa4:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 800cfa6:	4313      	orrs	r3, r2
 800cfa8:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 800cfaa:	687b      	ldr	r3, [r7, #4]
 800cfac:	681b      	ldr	r3, [r3, #0]
 800cfae:	68db      	ldr	r3, [r3, #12]
 800cfb0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800cfb4:	f023 0302 	bic.w	r3, r3, #2
 800cfb8:	687a      	ldr	r2, [r7, #4]
 800cfba:	6812      	ldr	r2, [r2, #0]
 800cfbc:	69b9      	ldr	r1, [r7, #24]
 800cfbe:	430b      	orrs	r3, r1
 800cfc0:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 800cfc2:	687b      	ldr	r3, [r7, #4]
 800cfc4:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800cfc8:	2b01      	cmp	r3, #1
 800cfca:	d118      	bne.n	800cffe <HAL_ADC_Init+0x216>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 800cfcc:	687b      	ldr	r3, [r7, #4]
 800cfce:	681b      	ldr	r3, [r3, #0]
 800cfd0:	691b      	ldr	r3, [r3, #16]
 800cfd2:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800cfd6:	f023 0304 	bic.w	r3, r3, #4
 800cfda:	687a      	ldr	r2, [r7, #4]
 800cfdc:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 800cfde:	687a      	ldr	r2, [r7, #4]
 800cfe0:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800cfe2:	4311      	orrs	r1, r2
 800cfe4:	687a      	ldr	r2, [r7, #4]
 800cfe6:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800cfe8:	4311      	orrs	r1, r2
 800cfea:	687a      	ldr	r2, [r7, #4]
 800cfec:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800cfee:	430a      	orrs	r2, r1
 800cff0:	431a      	orrs	r2, r3
 800cff2:	687b      	ldr	r3, [r7, #4]
 800cff4:	681b      	ldr	r3, [r3, #0]
 800cff6:	f042 0201 	orr.w	r2, r2, #1
 800cffa:	611a      	str	r2, [r3, #16]
 800cffc:	e007      	b.n	800d00e <HAL_ADC_Init+0x226>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 800cffe:	687b      	ldr	r3, [r7, #4]
 800d000:	681b      	ldr	r3, [r3, #0]
 800d002:	691a      	ldr	r2, [r3, #16]
 800d004:	687b      	ldr	r3, [r7, #4]
 800d006:	681b      	ldr	r3, [r3, #0]
 800d008:	f022 0201 	bic.w	r2, r2, #1
 800d00c:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800d00e:	687b      	ldr	r3, [r7, #4]
 800d010:	691b      	ldr	r3, [r3, #16]
 800d012:	2b01      	cmp	r3, #1
 800d014:	d10c      	bne.n	800d030 <HAL_ADC_Init+0x248>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800d016:	687b      	ldr	r3, [r7, #4]
 800d018:	681b      	ldr	r3, [r3, #0]
 800d01a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d01c:	f023 010f 	bic.w	r1, r3, #15
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	69db      	ldr	r3, [r3, #28]
 800d024:	1e5a      	subs	r2, r3, #1
 800d026:	687b      	ldr	r3, [r7, #4]
 800d028:	681b      	ldr	r3, [r3, #0]
 800d02a:	430a      	orrs	r2, r1
 800d02c:	631a      	str	r2, [r3, #48]	; 0x30
 800d02e:	e007      	b.n	800d040 <HAL_ADC_Init+0x258>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800d030:	687b      	ldr	r3, [r7, #4]
 800d032:	681b      	ldr	r3, [r3, #0]
 800d034:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d036:	687b      	ldr	r3, [r7, #4]
 800d038:	681b      	ldr	r3, [r3, #0]
 800d03a:	f022 020f 	bic.w	r2, r2, #15
 800d03e:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800d040:	687b      	ldr	r3, [r7, #4]
 800d042:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d044:	f023 0303 	bic.w	r3, r3, #3
 800d048:	f043 0201 	orr.w	r2, r3, #1
 800d04c:	687b      	ldr	r3, [r7, #4]
 800d04e:	655a      	str	r2, [r3, #84]	; 0x54
 800d050:	e007      	b.n	800d062 <HAL_ADC_Init+0x27a>
#endif /* ADC_SUPPORT_2_5_MSPS */
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800d052:	687b      	ldr	r3, [r7, #4]
 800d054:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d056:	f043 0210 	orr.w	r2, r3, #16
 800d05a:	687b      	ldr	r3, [r7, #4]
 800d05c:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 800d05e:	2301      	movs	r3, #1
 800d060:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 800d062:	7ffb      	ldrb	r3, [r7, #31]
}
 800d064:	4618      	mov	r0, r3
 800d066:	3720      	adds	r7, #32
 800d068:	46bd      	mov	sp, r7
 800d06a:	bd80      	pop	{r7, pc}
 800d06c:	20000010 	.word	0x20000010
 800d070:	053e2d63 	.word	0x053e2d63
 800d074:	50040000 	.word	0x50040000
 800d078:	50040300 	.word	0x50040300
 800d07c:	fff0c007 	.word	0xfff0c007

0800d080 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 800d080:	b580      	push	{r7, lr}
 800d082:	b0b6      	sub	sp, #216	; 0xd8
 800d084:	af00      	add	r7, sp, #0
 800d086:	6078      	str	r0, [r7, #4]
 800d088:	6039      	str	r1, [r7, #0]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
#else
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800d08a:	2300      	movs	r3, #0
 800d08c:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 800d090:	2300      	movs	r3, #0
 800d092:	60fb      	str	r3, [r7, #12]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800d094:	687b      	ldr	r3, [r7, #4]
 800d096:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800d09a:	2b01      	cmp	r3, #1
 800d09c:	d101      	bne.n	800d0a2 <HAL_ADC_ConfigChannel+0x22>
 800d09e:	2302      	movs	r3, #2
 800d0a0:	e39f      	b.n	800d7e2 <HAL_ADC_ConfigChannel+0x762>
 800d0a2:	687b      	ldr	r3, [r7, #4]
 800d0a4:	2201      	movs	r2, #1
 800d0a6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 800d0aa:	687b      	ldr	r3, [r7, #4]
 800d0ac:	681b      	ldr	r3, [r3, #0]
 800d0ae:	4618      	mov	r0, r3
 800d0b0:	f7ff fe73 	bl	800cd9a <LL_ADC_REG_IsConversionOngoing>
 800d0b4:	4603      	mov	r3, r0
 800d0b6:	2b00      	cmp	r3, #0
 800d0b8:	f040 8384 	bne.w	800d7c4 <HAL_ADC_ConfigChannel+0x744>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 800d0bc:	687b      	ldr	r3, [r7, #4]
 800d0be:	6818      	ldr	r0, [r3, #0]
 800d0c0:	683b      	ldr	r3, [r7, #0]
 800d0c2:	6859      	ldr	r1, [r3, #4]
 800d0c4:	683b      	ldr	r3, [r7, #0]
 800d0c6:	681b      	ldr	r3, [r3, #0]
 800d0c8:	461a      	mov	r2, r3
 800d0ca:	f7ff fd8a 	bl	800cbe2 <LL_ADC_REG_SetSequencerRanks>
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
#if defined (ADC_SUPPORT_2_5_MSPS)
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
#else
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800d0ce:	687b      	ldr	r3, [r7, #4]
 800d0d0:	681b      	ldr	r3, [r3, #0]
 800d0d2:	4618      	mov	r0, r3
 800d0d4:	f7ff fe61 	bl	800cd9a <LL_ADC_REG_IsConversionOngoing>
 800d0d8:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800d0dc:	687b      	ldr	r3, [r7, #4]
 800d0de:	681b      	ldr	r3, [r3, #0]
 800d0e0:	4618      	mov	r0, r3
 800d0e2:	f7ff fe6d 	bl	800cdc0 <LL_ADC_INJ_IsConversionOngoing>
 800d0e6:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800d0ea:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800d0ee:	2b00      	cmp	r3, #0
 800d0f0:	f040 81a6 	bne.w	800d440 <HAL_ADC_ConfigChannel+0x3c0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800d0f4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800d0f8:	2b00      	cmp	r3, #0
 800d0fa:	f040 81a1 	bne.w	800d440 <HAL_ADC_ConfigChannel+0x3c0>
       )
#endif /* ADC_SUPPORT_2_5_MSPS */
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800d0fe:	687b      	ldr	r3, [r7, #4]
 800d100:	6818      	ldr	r0, [r3, #0]
 800d102:	683b      	ldr	r3, [r7, #0]
 800d104:	6819      	ldr	r1, [r3, #0]
 800d106:	683b      	ldr	r3, [r7, #0]
 800d108:	689b      	ldr	r3, [r3, #8]
 800d10a:	461a      	mov	r2, r3
 800d10c:	f7ff fd95 	bl	800cc3a <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800d110:	683b      	ldr	r3, [r7, #0]
 800d112:	695a      	ldr	r2, [r3, #20]
 800d114:	687b      	ldr	r3, [r7, #4]
 800d116:	681b      	ldr	r3, [r3, #0]
 800d118:	68db      	ldr	r3, [r3, #12]
 800d11a:	08db      	lsrs	r3, r3, #3
 800d11c:	f003 0303 	and.w	r3, r3, #3
 800d120:	005b      	lsls	r3, r3, #1
 800d122:	fa02 f303 	lsl.w	r3, r2, r3
 800d126:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800d12a:	683b      	ldr	r3, [r7, #0]
 800d12c:	691b      	ldr	r3, [r3, #16]
 800d12e:	2b04      	cmp	r3, #4
 800d130:	d00a      	beq.n	800d148 <HAL_ADC_ConfigChannel+0xc8>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 800d132:	687b      	ldr	r3, [r7, #4]
 800d134:	6818      	ldr	r0, [r3, #0]
 800d136:	683b      	ldr	r3, [r7, #0]
 800d138:	6919      	ldr	r1, [r3, #16]
 800d13a:	683b      	ldr	r3, [r7, #0]
 800d13c:	681a      	ldr	r2, [r3, #0]
 800d13e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800d142:	f7ff fcf9 	bl	800cb38 <LL_ADC_SetOffset>
 800d146:	e17b      	b.n	800d440 <HAL_ADC_ConfigChannel+0x3c0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800d148:	687b      	ldr	r3, [r7, #4]
 800d14a:	681b      	ldr	r3, [r3, #0]
 800d14c:	2100      	movs	r1, #0
 800d14e:	4618      	mov	r0, r3
 800d150:	f7ff fd16 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d154:	4603      	mov	r3, r0
 800d156:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d15a:	2b00      	cmp	r3, #0
 800d15c:	d10a      	bne.n	800d174 <HAL_ADC_ConfigChannel+0xf4>
 800d15e:	687b      	ldr	r3, [r7, #4]
 800d160:	681b      	ldr	r3, [r3, #0]
 800d162:	2100      	movs	r1, #0
 800d164:	4618      	mov	r0, r3
 800d166:	f7ff fd0b 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d16a:	4603      	mov	r3, r0
 800d16c:	0e9b      	lsrs	r3, r3, #26
 800d16e:	f003 021f 	and.w	r2, r3, #31
 800d172:	e01e      	b.n	800d1b2 <HAL_ADC_ConfigChannel+0x132>
 800d174:	687b      	ldr	r3, [r7, #4]
 800d176:	681b      	ldr	r3, [r3, #0]
 800d178:	2100      	movs	r1, #0
 800d17a:	4618      	mov	r0, r3
 800d17c:	f7ff fd00 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d180:	4603      	mov	r3, r0
 800d182:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d186:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800d18a:	fa93 f3a3 	rbit	r3, r3
 800d18e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  return result;
 800d192:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800d196:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  if (value == 0U)
 800d19a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800d19e:	2b00      	cmp	r3, #0
 800d1a0:	d101      	bne.n	800d1a6 <HAL_ADC_ConfigChannel+0x126>
    return 32U;
 800d1a2:	2320      	movs	r3, #32
 800d1a4:	e004      	b.n	800d1b0 <HAL_ADC_ConfigChannel+0x130>
  return __builtin_clz(value);
 800d1a6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800d1aa:	fab3 f383 	clz	r3, r3
 800d1ae:	b2db      	uxtb	r3, r3
 800d1b0:	461a      	mov	r2, r3
 800d1b2:	683b      	ldr	r3, [r7, #0]
 800d1b4:	681b      	ldr	r3, [r3, #0]
 800d1b6:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d1ba:	2b00      	cmp	r3, #0
 800d1bc:	d105      	bne.n	800d1ca <HAL_ADC_ConfigChannel+0x14a>
 800d1be:	683b      	ldr	r3, [r7, #0]
 800d1c0:	681b      	ldr	r3, [r3, #0]
 800d1c2:	0e9b      	lsrs	r3, r3, #26
 800d1c4:	f003 031f 	and.w	r3, r3, #31
 800d1c8:	e018      	b.n	800d1fc <HAL_ADC_ConfigChannel+0x17c>
 800d1ca:	683b      	ldr	r3, [r7, #0]
 800d1cc:	681b      	ldr	r3, [r3, #0]
 800d1ce:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d1d2:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800d1d6:	fa93 f3a3 	rbit	r3, r3
 800d1da:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 800d1de:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800d1e2:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 800d1e6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800d1ea:	2b00      	cmp	r3, #0
 800d1ec:	d101      	bne.n	800d1f2 <HAL_ADC_ConfigChannel+0x172>
    return 32U;
 800d1ee:	2320      	movs	r3, #32
 800d1f0:	e004      	b.n	800d1fc <HAL_ADC_ConfigChannel+0x17c>
  return __builtin_clz(value);
 800d1f2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800d1f6:	fab3 f383 	clz	r3, r3
 800d1fa:	b2db      	uxtb	r3, r3
 800d1fc:	429a      	cmp	r2, r3
 800d1fe:	d106      	bne.n	800d20e <HAL_ADC_ConfigChannel+0x18e>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 800d200:	687b      	ldr	r3, [r7, #4]
 800d202:	681b      	ldr	r3, [r3, #0]
 800d204:	2200      	movs	r2, #0
 800d206:	2100      	movs	r1, #0
 800d208:	4618      	mov	r0, r3
 800d20a:	f7ff fccf 	bl	800cbac <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800d20e:	687b      	ldr	r3, [r7, #4]
 800d210:	681b      	ldr	r3, [r3, #0]
 800d212:	2101      	movs	r1, #1
 800d214:	4618      	mov	r0, r3
 800d216:	f7ff fcb3 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d21a:	4603      	mov	r3, r0
 800d21c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d220:	2b00      	cmp	r3, #0
 800d222:	d10a      	bne.n	800d23a <HAL_ADC_ConfigChannel+0x1ba>
 800d224:	687b      	ldr	r3, [r7, #4]
 800d226:	681b      	ldr	r3, [r3, #0]
 800d228:	2101      	movs	r1, #1
 800d22a:	4618      	mov	r0, r3
 800d22c:	f7ff fca8 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d230:	4603      	mov	r3, r0
 800d232:	0e9b      	lsrs	r3, r3, #26
 800d234:	f003 021f 	and.w	r2, r3, #31
 800d238:	e01e      	b.n	800d278 <HAL_ADC_ConfigChannel+0x1f8>
 800d23a:	687b      	ldr	r3, [r7, #4]
 800d23c:	681b      	ldr	r3, [r3, #0]
 800d23e:	2101      	movs	r1, #1
 800d240:	4618      	mov	r0, r3
 800d242:	f7ff fc9d 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d246:	4603      	mov	r3, r0
 800d248:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d24c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800d250:	fa93 f3a3 	rbit	r3, r3
 800d254:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 800d258:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800d25c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 800d260:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800d264:	2b00      	cmp	r3, #0
 800d266:	d101      	bne.n	800d26c <HAL_ADC_ConfigChannel+0x1ec>
    return 32U;
 800d268:	2320      	movs	r3, #32
 800d26a:	e004      	b.n	800d276 <HAL_ADC_ConfigChannel+0x1f6>
  return __builtin_clz(value);
 800d26c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800d270:	fab3 f383 	clz	r3, r3
 800d274:	b2db      	uxtb	r3, r3
 800d276:	461a      	mov	r2, r3
 800d278:	683b      	ldr	r3, [r7, #0]
 800d27a:	681b      	ldr	r3, [r3, #0]
 800d27c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d280:	2b00      	cmp	r3, #0
 800d282:	d105      	bne.n	800d290 <HAL_ADC_ConfigChannel+0x210>
 800d284:	683b      	ldr	r3, [r7, #0]
 800d286:	681b      	ldr	r3, [r3, #0]
 800d288:	0e9b      	lsrs	r3, r3, #26
 800d28a:	f003 031f 	and.w	r3, r3, #31
 800d28e:	e018      	b.n	800d2c2 <HAL_ADC_ConfigChannel+0x242>
 800d290:	683b      	ldr	r3, [r7, #0]
 800d292:	681b      	ldr	r3, [r3, #0]
 800d294:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d298:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800d29c:	fa93 f3a3 	rbit	r3, r3
 800d2a0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 800d2a4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800d2a8:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 800d2ac:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800d2b0:	2b00      	cmp	r3, #0
 800d2b2:	d101      	bne.n	800d2b8 <HAL_ADC_ConfigChannel+0x238>
    return 32U;
 800d2b4:	2320      	movs	r3, #32
 800d2b6:	e004      	b.n	800d2c2 <HAL_ADC_ConfigChannel+0x242>
  return __builtin_clz(value);
 800d2b8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800d2bc:	fab3 f383 	clz	r3, r3
 800d2c0:	b2db      	uxtb	r3, r3
 800d2c2:	429a      	cmp	r2, r3
 800d2c4:	d106      	bne.n	800d2d4 <HAL_ADC_ConfigChannel+0x254>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 800d2c6:	687b      	ldr	r3, [r7, #4]
 800d2c8:	681b      	ldr	r3, [r3, #0]
 800d2ca:	2200      	movs	r2, #0
 800d2cc:	2101      	movs	r1, #1
 800d2ce:	4618      	mov	r0, r3
 800d2d0:	f7ff fc6c 	bl	800cbac <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	681b      	ldr	r3, [r3, #0]
 800d2d8:	2102      	movs	r1, #2
 800d2da:	4618      	mov	r0, r3
 800d2dc:	f7ff fc50 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d2e0:	4603      	mov	r3, r0
 800d2e2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d2e6:	2b00      	cmp	r3, #0
 800d2e8:	d10a      	bne.n	800d300 <HAL_ADC_ConfigChannel+0x280>
 800d2ea:	687b      	ldr	r3, [r7, #4]
 800d2ec:	681b      	ldr	r3, [r3, #0]
 800d2ee:	2102      	movs	r1, #2
 800d2f0:	4618      	mov	r0, r3
 800d2f2:	f7ff fc45 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d2f6:	4603      	mov	r3, r0
 800d2f8:	0e9b      	lsrs	r3, r3, #26
 800d2fa:	f003 021f 	and.w	r2, r3, #31
 800d2fe:	e01e      	b.n	800d33e <HAL_ADC_ConfigChannel+0x2be>
 800d300:	687b      	ldr	r3, [r7, #4]
 800d302:	681b      	ldr	r3, [r3, #0]
 800d304:	2102      	movs	r1, #2
 800d306:	4618      	mov	r0, r3
 800d308:	f7ff fc3a 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d30c:	4603      	mov	r3, r0
 800d30e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d312:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800d316:	fa93 f3a3 	rbit	r3, r3
 800d31a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 800d31e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800d322:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 800d326:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800d32a:	2b00      	cmp	r3, #0
 800d32c:	d101      	bne.n	800d332 <HAL_ADC_ConfigChannel+0x2b2>
    return 32U;
 800d32e:	2320      	movs	r3, #32
 800d330:	e004      	b.n	800d33c <HAL_ADC_ConfigChannel+0x2bc>
  return __builtin_clz(value);
 800d332:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800d336:	fab3 f383 	clz	r3, r3
 800d33a:	b2db      	uxtb	r3, r3
 800d33c:	461a      	mov	r2, r3
 800d33e:	683b      	ldr	r3, [r7, #0]
 800d340:	681b      	ldr	r3, [r3, #0]
 800d342:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d346:	2b00      	cmp	r3, #0
 800d348:	d105      	bne.n	800d356 <HAL_ADC_ConfigChannel+0x2d6>
 800d34a:	683b      	ldr	r3, [r7, #0]
 800d34c:	681b      	ldr	r3, [r3, #0]
 800d34e:	0e9b      	lsrs	r3, r3, #26
 800d350:	f003 031f 	and.w	r3, r3, #31
 800d354:	e016      	b.n	800d384 <HAL_ADC_ConfigChannel+0x304>
 800d356:	683b      	ldr	r3, [r7, #0]
 800d358:	681b      	ldr	r3, [r3, #0]
 800d35a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d35e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800d362:	fa93 f3a3 	rbit	r3, r3
 800d366:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 800d368:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800d36a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 800d36e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800d372:	2b00      	cmp	r3, #0
 800d374:	d101      	bne.n	800d37a <HAL_ADC_ConfigChannel+0x2fa>
    return 32U;
 800d376:	2320      	movs	r3, #32
 800d378:	e004      	b.n	800d384 <HAL_ADC_ConfigChannel+0x304>
  return __builtin_clz(value);
 800d37a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800d37e:	fab3 f383 	clz	r3, r3
 800d382:	b2db      	uxtb	r3, r3
 800d384:	429a      	cmp	r2, r3
 800d386:	d106      	bne.n	800d396 <HAL_ADC_ConfigChannel+0x316>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 800d388:	687b      	ldr	r3, [r7, #4]
 800d38a:	681b      	ldr	r3, [r3, #0]
 800d38c:	2200      	movs	r2, #0
 800d38e:	2102      	movs	r1, #2
 800d390:	4618      	mov	r0, r3
 800d392:	f7ff fc0b 	bl	800cbac <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800d396:	687b      	ldr	r3, [r7, #4]
 800d398:	681b      	ldr	r3, [r3, #0]
 800d39a:	2103      	movs	r1, #3
 800d39c:	4618      	mov	r0, r3
 800d39e:	f7ff fbef 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d3a2:	4603      	mov	r3, r0
 800d3a4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d3a8:	2b00      	cmp	r3, #0
 800d3aa:	d10a      	bne.n	800d3c2 <HAL_ADC_ConfigChannel+0x342>
 800d3ac:	687b      	ldr	r3, [r7, #4]
 800d3ae:	681b      	ldr	r3, [r3, #0]
 800d3b0:	2103      	movs	r1, #3
 800d3b2:	4618      	mov	r0, r3
 800d3b4:	f7ff fbe4 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d3b8:	4603      	mov	r3, r0
 800d3ba:	0e9b      	lsrs	r3, r3, #26
 800d3bc:	f003 021f 	and.w	r2, r3, #31
 800d3c0:	e017      	b.n	800d3f2 <HAL_ADC_ConfigChannel+0x372>
 800d3c2:	687b      	ldr	r3, [r7, #4]
 800d3c4:	681b      	ldr	r3, [r3, #0]
 800d3c6:	2103      	movs	r1, #3
 800d3c8:	4618      	mov	r0, r3
 800d3ca:	f7ff fbd9 	bl	800cb80 <LL_ADC_GetOffsetChannel>
 800d3ce:	4603      	mov	r3, r0
 800d3d0:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d3d2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800d3d4:	fa93 f3a3 	rbit	r3, r3
 800d3d8:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 800d3da:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800d3dc:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 800d3de:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800d3e0:	2b00      	cmp	r3, #0
 800d3e2:	d101      	bne.n	800d3e8 <HAL_ADC_ConfigChannel+0x368>
    return 32U;
 800d3e4:	2320      	movs	r3, #32
 800d3e6:	e003      	b.n	800d3f0 <HAL_ADC_ConfigChannel+0x370>
  return __builtin_clz(value);
 800d3e8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800d3ea:	fab3 f383 	clz	r3, r3
 800d3ee:	b2db      	uxtb	r3, r3
 800d3f0:	461a      	mov	r2, r3
 800d3f2:	683b      	ldr	r3, [r7, #0]
 800d3f4:	681b      	ldr	r3, [r3, #0]
 800d3f6:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d3fa:	2b00      	cmp	r3, #0
 800d3fc:	d105      	bne.n	800d40a <HAL_ADC_ConfigChannel+0x38a>
 800d3fe:	683b      	ldr	r3, [r7, #0]
 800d400:	681b      	ldr	r3, [r3, #0]
 800d402:	0e9b      	lsrs	r3, r3, #26
 800d404:	f003 031f 	and.w	r3, r3, #31
 800d408:	e011      	b.n	800d42e <HAL_ADC_ConfigChannel+0x3ae>
 800d40a:	683b      	ldr	r3, [r7, #0]
 800d40c:	681b      	ldr	r3, [r3, #0]
 800d40e:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d410:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800d412:	fa93 f3a3 	rbit	r3, r3
 800d416:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 800d418:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d41a:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 800d41c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d41e:	2b00      	cmp	r3, #0
 800d420:	d101      	bne.n	800d426 <HAL_ADC_ConfigChannel+0x3a6>
    return 32U;
 800d422:	2320      	movs	r3, #32
 800d424:	e003      	b.n	800d42e <HAL_ADC_ConfigChannel+0x3ae>
  return __builtin_clz(value);
 800d426:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800d428:	fab3 f383 	clz	r3, r3
 800d42c:	b2db      	uxtb	r3, r3
 800d42e:	429a      	cmp	r2, r3
 800d430:	d106      	bne.n	800d440 <HAL_ADC_ConfigChannel+0x3c0>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 800d432:	687b      	ldr	r3, [r7, #4]
 800d434:	681b      	ldr	r3, [r3, #0]
 800d436:	2200      	movs	r2, #0
 800d438:	2103      	movs	r1, #3
 800d43a:	4618      	mov	r0, r3
 800d43c:	f7ff fbb6 	bl	800cbac <LL_ADC_SetOffsetState>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800d440:	687b      	ldr	r3, [r7, #4]
 800d442:	681b      	ldr	r3, [r3, #0]
 800d444:	4618      	mov	r0, r3
 800d446:	f7ff fc95 	bl	800cd74 <LL_ADC_IsEnabled>
 800d44a:	4603      	mov	r3, r0
 800d44c:	2b00      	cmp	r3, #0
 800d44e:	f040 81c2 	bne.w	800d7d6 <HAL_ADC_ConfigChannel+0x756>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800d452:	687b      	ldr	r3, [r7, #4]
 800d454:	6818      	ldr	r0, [r3, #0]
 800d456:	683b      	ldr	r3, [r7, #0]
 800d458:	6819      	ldr	r1, [r3, #0]
 800d45a:	683b      	ldr	r3, [r7, #0]
 800d45c:	68db      	ldr	r3, [r3, #12]
 800d45e:	461a      	mov	r2, r3
 800d460:	f7ff fc16 	bl	800cc90 <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 800d464:	683b      	ldr	r3, [r7, #0]
 800d466:	68db      	ldr	r3, [r3, #12]
 800d468:	4a8e      	ldr	r2, [pc, #568]	; (800d6a4 <HAL_ADC_ConfigChannel+0x624>)
 800d46a:	4293      	cmp	r3, r2
 800d46c:	f040 8130 	bne.w	800d6d0 <HAL_ADC_ConfigChannel+0x650>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800d470:	687b      	ldr	r3, [r7, #4]
 800d472:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800d474:	683b      	ldr	r3, [r7, #0]
 800d476:	681b      	ldr	r3, [r3, #0]
 800d478:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d47c:	2b00      	cmp	r3, #0
 800d47e:	d10b      	bne.n	800d498 <HAL_ADC_ConfigChannel+0x418>
 800d480:	683b      	ldr	r3, [r7, #0]
 800d482:	681b      	ldr	r3, [r3, #0]
 800d484:	0e9b      	lsrs	r3, r3, #26
 800d486:	3301      	adds	r3, #1
 800d488:	f003 031f 	and.w	r3, r3, #31
 800d48c:	2b09      	cmp	r3, #9
 800d48e:	bf94      	ite	ls
 800d490:	2301      	movls	r3, #1
 800d492:	2300      	movhi	r3, #0
 800d494:	b2db      	uxtb	r3, r3
 800d496:	e019      	b.n	800d4cc <HAL_ADC_ConfigChannel+0x44c>
 800d498:	683b      	ldr	r3, [r7, #0]
 800d49a:	681b      	ldr	r3, [r3, #0]
 800d49c:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d49e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d4a0:	fa93 f3a3 	rbit	r3, r3
 800d4a4:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 800d4a6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d4a8:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 800d4aa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d4ac:	2b00      	cmp	r3, #0
 800d4ae:	d101      	bne.n	800d4b4 <HAL_ADC_ConfigChannel+0x434>
    return 32U;
 800d4b0:	2320      	movs	r3, #32
 800d4b2:	e003      	b.n	800d4bc <HAL_ADC_ConfigChannel+0x43c>
  return __builtin_clz(value);
 800d4b4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d4b6:	fab3 f383 	clz	r3, r3
 800d4ba:	b2db      	uxtb	r3, r3
 800d4bc:	3301      	adds	r3, #1
 800d4be:	f003 031f 	and.w	r3, r3, #31
 800d4c2:	2b09      	cmp	r3, #9
 800d4c4:	bf94      	ite	ls
 800d4c6:	2301      	movls	r3, #1
 800d4c8:	2300      	movhi	r3, #0
 800d4ca:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800d4cc:	2b00      	cmp	r3, #0
 800d4ce:	d079      	beq.n	800d5c4 <HAL_ADC_ConfigChannel+0x544>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800d4d0:	683b      	ldr	r3, [r7, #0]
 800d4d2:	681b      	ldr	r3, [r3, #0]
 800d4d4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d4d8:	2b00      	cmp	r3, #0
 800d4da:	d107      	bne.n	800d4ec <HAL_ADC_ConfigChannel+0x46c>
 800d4dc:	683b      	ldr	r3, [r7, #0]
 800d4de:	681b      	ldr	r3, [r3, #0]
 800d4e0:	0e9b      	lsrs	r3, r3, #26
 800d4e2:	3301      	adds	r3, #1
 800d4e4:	069b      	lsls	r3, r3, #26
 800d4e6:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800d4ea:	e015      	b.n	800d518 <HAL_ADC_ConfigChannel+0x498>
 800d4ec:	683b      	ldr	r3, [r7, #0]
 800d4ee:	681b      	ldr	r3, [r3, #0]
 800d4f0:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d4f2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d4f4:	fa93 f3a3 	rbit	r3, r3
 800d4f8:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 800d4fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d4fc:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 800d4fe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d500:	2b00      	cmp	r3, #0
 800d502:	d101      	bne.n	800d508 <HAL_ADC_ConfigChannel+0x488>
    return 32U;
 800d504:	2320      	movs	r3, #32
 800d506:	e003      	b.n	800d510 <HAL_ADC_ConfigChannel+0x490>
  return __builtin_clz(value);
 800d508:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d50a:	fab3 f383 	clz	r3, r3
 800d50e:	b2db      	uxtb	r3, r3
 800d510:	3301      	adds	r3, #1
 800d512:	069b      	lsls	r3, r3, #26
 800d514:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800d518:	683b      	ldr	r3, [r7, #0]
 800d51a:	681b      	ldr	r3, [r3, #0]
 800d51c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d520:	2b00      	cmp	r3, #0
 800d522:	d109      	bne.n	800d538 <HAL_ADC_ConfigChannel+0x4b8>
 800d524:	683b      	ldr	r3, [r7, #0]
 800d526:	681b      	ldr	r3, [r3, #0]
 800d528:	0e9b      	lsrs	r3, r3, #26
 800d52a:	3301      	adds	r3, #1
 800d52c:	f003 031f 	and.w	r3, r3, #31
 800d530:	2101      	movs	r1, #1
 800d532:	fa01 f303 	lsl.w	r3, r1, r3
 800d536:	e017      	b.n	800d568 <HAL_ADC_ConfigChannel+0x4e8>
 800d538:	683b      	ldr	r3, [r7, #0]
 800d53a:	681b      	ldr	r3, [r3, #0]
 800d53c:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d53e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d540:	fa93 f3a3 	rbit	r3, r3
 800d544:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 800d546:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d548:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 800d54a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d54c:	2b00      	cmp	r3, #0
 800d54e:	d101      	bne.n	800d554 <HAL_ADC_ConfigChannel+0x4d4>
    return 32U;
 800d550:	2320      	movs	r3, #32
 800d552:	e003      	b.n	800d55c <HAL_ADC_ConfigChannel+0x4dc>
  return __builtin_clz(value);
 800d554:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d556:	fab3 f383 	clz	r3, r3
 800d55a:	b2db      	uxtb	r3, r3
 800d55c:	3301      	adds	r3, #1
 800d55e:	f003 031f 	and.w	r3, r3, #31
 800d562:	2101      	movs	r1, #1
 800d564:	fa01 f303 	lsl.w	r3, r1, r3
 800d568:	ea42 0103 	orr.w	r1, r2, r3
 800d56c:	683b      	ldr	r3, [r7, #0]
 800d56e:	681b      	ldr	r3, [r3, #0]
 800d570:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d574:	2b00      	cmp	r3, #0
 800d576:	d10a      	bne.n	800d58e <HAL_ADC_ConfigChannel+0x50e>
 800d578:	683b      	ldr	r3, [r7, #0]
 800d57a:	681b      	ldr	r3, [r3, #0]
 800d57c:	0e9b      	lsrs	r3, r3, #26
 800d57e:	3301      	adds	r3, #1
 800d580:	f003 021f 	and.w	r2, r3, #31
 800d584:	4613      	mov	r3, r2
 800d586:	005b      	lsls	r3, r3, #1
 800d588:	4413      	add	r3, r2
 800d58a:	051b      	lsls	r3, r3, #20
 800d58c:	e018      	b.n	800d5c0 <HAL_ADC_ConfigChannel+0x540>
 800d58e:	683b      	ldr	r3, [r7, #0]
 800d590:	681b      	ldr	r3, [r3, #0]
 800d592:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d594:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d596:	fa93 f3a3 	rbit	r3, r3
 800d59a:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 800d59c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d59e:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 800d5a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d5a2:	2b00      	cmp	r3, #0
 800d5a4:	d101      	bne.n	800d5aa <HAL_ADC_ConfigChannel+0x52a>
    return 32U;
 800d5a6:	2320      	movs	r3, #32
 800d5a8:	e003      	b.n	800d5b2 <HAL_ADC_ConfigChannel+0x532>
  return __builtin_clz(value);
 800d5aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d5ac:	fab3 f383 	clz	r3, r3
 800d5b0:	b2db      	uxtb	r3, r3
 800d5b2:	3301      	adds	r3, #1
 800d5b4:	f003 021f 	and.w	r2, r3, #31
 800d5b8:	4613      	mov	r3, r2
 800d5ba:	005b      	lsls	r3, r3, #1
 800d5bc:	4413      	add	r3, r2
 800d5be:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800d5c0:	430b      	orrs	r3, r1
 800d5c2:	e080      	b.n	800d6c6 <HAL_ADC_ConfigChannel+0x646>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800d5c4:	683b      	ldr	r3, [r7, #0]
 800d5c6:	681b      	ldr	r3, [r3, #0]
 800d5c8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d5cc:	2b00      	cmp	r3, #0
 800d5ce:	d107      	bne.n	800d5e0 <HAL_ADC_ConfigChannel+0x560>
 800d5d0:	683b      	ldr	r3, [r7, #0]
 800d5d2:	681b      	ldr	r3, [r3, #0]
 800d5d4:	0e9b      	lsrs	r3, r3, #26
 800d5d6:	3301      	adds	r3, #1
 800d5d8:	069b      	lsls	r3, r3, #26
 800d5da:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800d5de:	e015      	b.n	800d60c <HAL_ADC_ConfigChannel+0x58c>
 800d5e0:	683b      	ldr	r3, [r7, #0]
 800d5e2:	681b      	ldr	r3, [r3, #0]
 800d5e4:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d5e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5e8:	fa93 f3a3 	rbit	r3, r3
 800d5ec:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 800d5ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d5f0:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 800d5f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d5f4:	2b00      	cmp	r3, #0
 800d5f6:	d101      	bne.n	800d5fc <HAL_ADC_ConfigChannel+0x57c>
    return 32U;
 800d5f8:	2320      	movs	r3, #32
 800d5fa:	e003      	b.n	800d604 <HAL_ADC_ConfigChannel+0x584>
  return __builtin_clz(value);
 800d5fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d5fe:	fab3 f383 	clz	r3, r3
 800d602:	b2db      	uxtb	r3, r3
 800d604:	3301      	adds	r3, #1
 800d606:	069b      	lsls	r3, r3, #26
 800d608:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800d60c:	683b      	ldr	r3, [r7, #0]
 800d60e:	681b      	ldr	r3, [r3, #0]
 800d610:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d614:	2b00      	cmp	r3, #0
 800d616:	d109      	bne.n	800d62c <HAL_ADC_ConfigChannel+0x5ac>
 800d618:	683b      	ldr	r3, [r7, #0]
 800d61a:	681b      	ldr	r3, [r3, #0]
 800d61c:	0e9b      	lsrs	r3, r3, #26
 800d61e:	3301      	adds	r3, #1
 800d620:	f003 031f 	and.w	r3, r3, #31
 800d624:	2101      	movs	r1, #1
 800d626:	fa01 f303 	lsl.w	r3, r1, r3
 800d62a:	e017      	b.n	800d65c <HAL_ADC_ConfigChannel+0x5dc>
 800d62c:	683b      	ldr	r3, [r7, #0]
 800d62e:	681b      	ldr	r3, [r3, #0]
 800d630:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d632:	6a3b      	ldr	r3, [r7, #32]
 800d634:	fa93 f3a3 	rbit	r3, r3
 800d638:	61fb      	str	r3, [r7, #28]
  return result;
 800d63a:	69fb      	ldr	r3, [r7, #28]
 800d63c:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 800d63e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d640:	2b00      	cmp	r3, #0
 800d642:	d101      	bne.n	800d648 <HAL_ADC_ConfigChannel+0x5c8>
    return 32U;
 800d644:	2320      	movs	r3, #32
 800d646:	e003      	b.n	800d650 <HAL_ADC_ConfigChannel+0x5d0>
  return __builtin_clz(value);
 800d648:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d64a:	fab3 f383 	clz	r3, r3
 800d64e:	b2db      	uxtb	r3, r3
 800d650:	3301      	adds	r3, #1
 800d652:	f003 031f 	and.w	r3, r3, #31
 800d656:	2101      	movs	r1, #1
 800d658:	fa01 f303 	lsl.w	r3, r1, r3
 800d65c:	ea42 0103 	orr.w	r1, r2, r3
 800d660:	683b      	ldr	r3, [r7, #0]
 800d662:	681b      	ldr	r3, [r3, #0]
 800d664:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d668:	2b00      	cmp	r3, #0
 800d66a:	d10d      	bne.n	800d688 <HAL_ADC_ConfigChannel+0x608>
 800d66c:	683b      	ldr	r3, [r7, #0]
 800d66e:	681b      	ldr	r3, [r3, #0]
 800d670:	0e9b      	lsrs	r3, r3, #26
 800d672:	3301      	adds	r3, #1
 800d674:	f003 021f 	and.w	r2, r3, #31
 800d678:	4613      	mov	r3, r2
 800d67a:	005b      	lsls	r3, r3, #1
 800d67c:	4413      	add	r3, r2
 800d67e:	3b1e      	subs	r3, #30
 800d680:	051b      	lsls	r3, r3, #20
 800d682:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800d686:	e01d      	b.n	800d6c4 <HAL_ADC_ConfigChannel+0x644>
 800d688:	683b      	ldr	r3, [r7, #0]
 800d68a:	681b      	ldr	r3, [r3, #0]
 800d68c:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800d68e:	697b      	ldr	r3, [r7, #20]
 800d690:	fa93 f3a3 	rbit	r3, r3
 800d694:	613b      	str	r3, [r7, #16]
  return result;
 800d696:	693b      	ldr	r3, [r7, #16]
 800d698:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 800d69a:	69bb      	ldr	r3, [r7, #24]
 800d69c:	2b00      	cmp	r3, #0
 800d69e:	d103      	bne.n	800d6a8 <HAL_ADC_ConfigChannel+0x628>
    return 32U;
 800d6a0:	2320      	movs	r3, #32
 800d6a2:	e005      	b.n	800d6b0 <HAL_ADC_ConfigChannel+0x630>
 800d6a4:	407f0000 	.word	0x407f0000
  return __builtin_clz(value);
 800d6a8:	69bb      	ldr	r3, [r7, #24]
 800d6aa:	fab3 f383 	clz	r3, r3
 800d6ae:	b2db      	uxtb	r3, r3
 800d6b0:	3301      	adds	r3, #1
 800d6b2:	f003 021f 	and.w	r2, r3, #31
 800d6b6:	4613      	mov	r3, r2
 800d6b8:	005b      	lsls	r3, r3, #1
 800d6ba:	4413      	add	r3, r2
 800d6bc:	3b1e      	subs	r3, #30
 800d6be:	051b      	lsls	r3, r3, #20
 800d6c0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800d6c4:	430b      	orrs	r3, r1
 800d6c6:	683a      	ldr	r2, [r7, #0]
 800d6c8:	6892      	ldr	r2, [r2, #8]
 800d6ca:	4619      	mov	r1, r3
 800d6cc:	f7ff fab5 	bl	800cc3a <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800d6d0:	683b      	ldr	r3, [r7, #0]
 800d6d2:	681a      	ldr	r2, [r3, #0]
 800d6d4:	4b45      	ldr	r3, [pc, #276]	; (800d7ec <HAL_ADC_ConfigChannel+0x76c>)
 800d6d6:	4013      	ands	r3, r2
 800d6d8:	2b00      	cmp	r3, #0
 800d6da:	d07c      	beq.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800d6dc:	4844      	ldr	r0, [pc, #272]	; (800d7f0 <HAL_ADC_ConfigChannel+0x770>)
 800d6de:	f7ff fa1d 	bl	800cb1c <LL_ADC_GetCommonPathInternalCh>
 800d6e2:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800d6e6:	4843      	ldr	r0, [pc, #268]	; (800d7f4 <HAL_ADC_ConfigChannel+0x774>)
 800d6e8:	f7ff fb44 	bl	800cd74 <LL_ADC_IsEnabled>
 800d6ec:	4603      	mov	r3, r0
 800d6ee:	2b00      	cmp	r3, #0
 800d6f0:	d15e      	bne.n	800d7b0 <HAL_ADC_ConfigChannel+0x730>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800d6f2:	683b      	ldr	r3, [r7, #0]
 800d6f4:	681b      	ldr	r3, [r3, #0]
 800d6f6:	4a40      	ldr	r2, [pc, #256]	; (800d7f8 <HAL_ADC_ConfigChannel+0x778>)
 800d6f8:	4293      	cmp	r3, r2
 800d6fa:	d127      	bne.n	800d74c <HAL_ADC_ConfigChannel+0x6cc>
 800d6fc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d700:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800d704:	2b00      	cmp	r3, #0
 800d706:	d121      	bne.n	800d74c <HAL_ADC_ConfigChannel+0x6cc>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	681b      	ldr	r3, [r3, #0]
 800d70c:	4a39      	ldr	r2, [pc, #228]	; (800d7f4 <HAL_ADC_ConfigChannel+0x774>)
 800d70e:	4293      	cmp	r3, r2
 800d710:	d161      	bne.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 800d712:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d716:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800d71a:	4619      	mov	r1, r3
 800d71c:	4834      	ldr	r0, [pc, #208]	; (800d7f0 <HAL_ADC_ConfigChannel+0x770>)
 800d71e:	f7ff f9ea 	bl	800caf6 <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 800d722:	4b36      	ldr	r3, [pc, #216]	; (800d7fc <HAL_ADC_ConfigChannel+0x77c>)
 800d724:	681b      	ldr	r3, [r3, #0]
 800d726:	099b      	lsrs	r3, r3, #6
 800d728:	4a35      	ldr	r2, [pc, #212]	; (800d800 <HAL_ADC_ConfigChannel+0x780>)
 800d72a:	fba2 2303 	umull	r2, r3, r2, r3
 800d72e:	099b      	lsrs	r3, r3, #6
 800d730:	1c5a      	adds	r2, r3, #1
 800d732:	4613      	mov	r3, r2
 800d734:	005b      	lsls	r3, r3, #1
 800d736:	4413      	add	r3, r2
 800d738:	009b      	lsls	r3, r3, #2
 800d73a:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 800d73c:	e002      	b.n	800d744 <HAL_ADC_ConfigChannel+0x6c4>
              {
                wait_loop_index--;
 800d73e:	68fb      	ldr	r3, [r7, #12]
 800d740:	3b01      	subs	r3, #1
 800d742:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 800d744:	68fb      	ldr	r3, [r7, #12]
 800d746:	2b00      	cmp	r3, #0
 800d748:	d1f9      	bne.n	800d73e <HAL_ADC_ConfigChannel+0x6be>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800d74a:	e044      	b.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800d74c:	683b      	ldr	r3, [r7, #0]
 800d74e:	681b      	ldr	r3, [r3, #0]
 800d750:	4a2c      	ldr	r2, [pc, #176]	; (800d804 <HAL_ADC_ConfigChannel+0x784>)
 800d752:	4293      	cmp	r3, r2
 800d754:	d113      	bne.n	800d77e <HAL_ADC_ConfigChannel+0x6fe>
 800d756:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d75a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800d75e:	2b00      	cmp	r3, #0
 800d760:	d10d      	bne.n	800d77e <HAL_ADC_ConfigChannel+0x6fe>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800d762:	687b      	ldr	r3, [r7, #4]
 800d764:	681b      	ldr	r3, [r3, #0]
 800d766:	4a23      	ldr	r2, [pc, #140]	; (800d7f4 <HAL_ADC_ConfigChannel+0x774>)
 800d768:	4293      	cmp	r3, r2
 800d76a:	d134      	bne.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 800d76c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d770:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800d774:	4619      	mov	r1, r3
 800d776:	481e      	ldr	r0, [pc, #120]	; (800d7f0 <HAL_ADC_ConfigChannel+0x770>)
 800d778:	f7ff f9bd 	bl	800caf6 <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800d77c:	e02b      	b.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800d77e:	683b      	ldr	r3, [r7, #0]
 800d780:	681b      	ldr	r3, [r3, #0]
 800d782:	4a21      	ldr	r2, [pc, #132]	; (800d808 <HAL_ADC_ConfigChannel+0x788>)
 800d784:	4293      	cmp	r3, r2
 800d786:	d126      	bne.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
 800d788:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d78c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800d790:	2b00      	cmp	r3, #0
 800d792:	d120      	bne.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	681b      	ldr	r3, [r3, #0]
 800d798:	4a16      	ldr	r2, [pc, #88]	; (800d7f4 <HAL_ADC_ConfigChannel+0x774>)
 800d79a:	4293      	cmp	r3, r2
 800d79c:	d11b      	bne.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 800d79e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800d7a2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800d7a6:	4619      	mov	r1, r3
 800d7a8:	4811      	ldr	r0, [pc, #68]	; (800d7f0 <HAL_ADC_ConfigChannel+0x770>)
 800d7aa:	f7ff f9a4 	bl	800caf6 <LL_ADC_SetCommonPathInternalCh>
 800d7ae:	e012      	b.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800d7b0:	687b      	ldr	r3, [r7, #4]
 800d7b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d7b4:	f043 0220 	orr.w	r2, r3, #32
 800d7b8:	687b      	ldr	r3, [r7, #4]
 800d7ba:	655a      	str	r2, [r3, #84]	; 0x54

          tmp_hal_status = HAL_ERROR;
 800d7bc:	2301      	movs	r3, #1
 800d7be:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
 800d7c2:	e008      	b.n	800d7d6 <HAL_ADC_ConfigChannel+0x756>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800d7c4:	687b      	ldr	r3, [r7, #4]
 800d7c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d7c8:	f043 0220 	orr.w	r2, r3, #32
 800d7cc:	687b      	ldr	r3, [r7, #4]
 800d7ce:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 800d7d0:	2301      	movs	r3, #1
 800d7d2:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800d7d6:	687b      	ldr	r3, [r7, #4]
 800d7d8:	2200      	movs	r2, #0
 800d7da:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Return function status */
  return tmp_hal_status;
 800d7de:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 800d7e2:	4618      	mov	r0, r3
 800d7e4:	37d8      	adds	r7, #216	; 0xd8
 800d7e6:	46bd      	mov	sp, r7
 800d7e8:	bd80      	pop	{r7, pc}
 800d7ea:	bf00      	nop
 800d7ec:	80080000 	.word	0x80080000
 800d7f0:	50040300 	.word	0x50040300
 800d7f4:	50040000 	.word	0x50040000
 800d7f8:	c7520000 	.word	0xc7520000
 800d7fc:	20000010 	.word	0x20000010
 800d800:	053e2d63 	.word	0x053e2d63
 800d804:	cb840000 	.word	0xcb840000
 800d808:	80000001 	.word	0x80000001

0800d80c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800d80c:	b480      	push	{r7}
 800d80e:	b085      	sub	sp, #20
 800d810:	af00      	add	r7, sp, #0
 800d812:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800d814:	687b      	ldr	r3, [r7, #4]
 800d816:	f003 0307 	and.w	r3, r3, #7
 800d81a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800d81c:	4b0c      	ldr	r3, [pc, #48]	; (800d850 <__NVIC_SetPriorityGrouping+0x44>)
 800d81e:	68db      	ldr	r3, [r3, #12]
 800d820:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800d822:	68ba      	ldr	r2, [r7, #8]
 800d824:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800d828:	4013      	ands	r3, r2
 800d82a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800d82c:	68fb      	ldr	r3, [r7, #12]
 800d82e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800d830:	68bb      	ldr	r3, [r7, #8]
 800d832:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800d834:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800d838:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800d83c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800d83e:	4a04      	ldr	r2, [pc, #16]	; (800d850 <__NVIC_SetPriorityGrouping+0x44>)
 800d840:	68bb      	ldr	r3, [r7, #8]
 800d842:	60d3      	str	r3, [r2, #12]
}
 800d844:	bf00      	nop
 800d846:	3714      	adds	r7, #20
 800d848:	46bd      	mov	sp, r7
 800d84a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d84e:	4770      	bx	lr
 800d850:	e000ed00 	.word	0xe000ed00

0800d854 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800d854:	b480      	push	{r7}
 800d856:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800d858:	4b04      	ldr	r3, [pc, #16]	; (800d86c <__NVIC_GetPriorityGrouping+0x18>)
 800d85a:	68db      	ldr	r3, [r3, #12]
 800d85c:	0a1b      	lsrs	r3, r3, #8
 800d85e:	f003 0307 	and.w	r3, r3, #7
}
 800d862:	4618      	mov	r0, r3
 800d864:	46bd      	mov	sp, r7
 800d866:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d86a:	4770      	bx	lr
 800d86c:	e000ed00 	.word	0xe000ed00

0800d870 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800d870:	b480      	push	{r7}
 800d872:	b083      	sub	sp, #12
 800d874:	af00      	add	r7, sp, #0
 800d876:	4603      	mov	r3, r0
 800d878:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d87a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d87e:	2b00      	cmp	r3, #0
 800d880:	db0b      	blt.n	800d89a <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d882:	79fb      	ldrb	r3, [r7, #7]
 800d884:	f003 021f 	and.w	r2, r3, #31
 800d888:	4907      	ldr	r1, [pc, #28]	; (800d8a8 <__NVIC_EnableIRQ+0x38>)
 800d88a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d88e:	095b      	lsrs	r3, r3, #5
 800d890:	2001      	movs	r0, #1
 800d892:	fa00 f202 	lsl.w	r2, r0, r2
 800d896:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800d89a:	bf00      	nop
 800d89c:	370c      	adds	r7, #12
 800d89e:	46bd      	mov	sp, r7
 800d8a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8a4:	4770      	bx	lr
 800d8a6:	bf00      	nop
 800d8a8:	e000e100 	.word	0xe000e100

0800d8ac <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800d8ac:	b480      	push	{r7}
 800d8ae:	b083      	sub	sp, #12
 800d8b0:	af00      	add	r7, sp, #0
 800d8b2:	4603      	mov	r3, r0
 800d8b4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d8b6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d8ba:	2b00      	cmp	r3, #0
 800d8bc:	db12      	blt.n	800d8e4 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d8be:	79fb      	ldrb	r3, [r7, #7]
 800d8c0:	f003 021f 	and.w	r2, r3, #31
 800d8c4:	490a      	ldr	r1, [pc, #40]	; (800d8f0 <__NVIC_DisableIRQ+0x44>)
 800d8c6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d8ca:	095b      	lsrs	r3, r3, #5
 800d8cc:	2001      	movs	r0, #1
 800d8ce:	fa00 f202 	lsl.w	r2, r0, r2
 800d8d2:	3320      	adds	r3, #32
 800d8d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800d8d8:	f3bf 8f4f 	dsb	sy
}
 800d8dc:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800d8de:	f3bf 8f6f 	isb	sy
}
 800d8e2:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 800d8e4:	bf00      	nop
 800d8e6:	370c      	adds	r7, #12
 800d8e8:	46bd      	mov	sp, r7
 800d8ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8ee:	4770      	bx	lr
 800d8f0:	e000e100 	.word	0xe000e100

0800d8f4 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 800d8f4:	b480      	push	{r7}
 800d8f6:	b083      	sub	sp, #12
 800d8f8:	af00      	add	r7, sp, #0
 800d8fa:	4603      	mov	r3, r0
 800d8fc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d8fe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d902:	2b00      	cmp	r3, #0
 800d904:	db0c      	blt.n	800d920 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d906:	79fb      	ldrb	r3, [r7, #7]
 800d908:	f003 021f 	and.w	r2, r3, #31
 800d90c:	4907      	ldr	r1, [pc, #28]	; (800d92c <__NVIC_SetPendingIRQ+0x38>)
 800d90e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d912:	095b      	lsrs	r3, r3, #5
 800d914:	2001      	movs	r0, #1
 800d916:	fa00 f202 	lsl.w	r2, r0, r2
 800d91a:	3340      	adds	r3, #64	; 0x40
 800d91c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 800d920:	bf00      	nop
 800d922:	370c      	adds	r7, #12
 800d924:	46bd      	mov	sp, r7
 800d926:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d92a:	4770      	bx	lr
 800d92c:	e000e100 	.word	0xe000e100

0800d930 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 800d930:	b480      	push	{r7}
 800d932:	b083      	sub	sp, #12
 800d934:	af00      	add	r7, sp, #0
 800d936:	4603      	mov	r3, r0
 800d938:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d93a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d93e:	2b00      	cmp	r3, #0
 800d940:	db0c      	blt.n	800d95c <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800d942:	79fb      	ldrb	r3, [r7, #7]
 800d944:	f003 021f 	and.w	r2, r3, #31
 800d948:	4907      	ldr	r1, [pc, #28]	; (800d968 <__NVIC_ClearPendingIRQ+0x38>)
 800d94a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d94e:	095b      	lsrs	r3, r3, #5
 800d950:	2001      	movs	r0, #1
 800d952:	fa00 f202 	lsl.w	r2, r0, r2
 800d956:	3360      	adds	r3, #96	; 0x60
 800d958:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 800d95c:	bf00      	nop
 800d95e:	370c      	adds	r7, #12
 800d960:	46bd      	mov	sp, r7
 800d962:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d966:	4770      	bx	lr
 800d968:	e000e100 	.word	0xe000e100

0800d96c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800d96c:	b480      	push	{r7}
 800d96e:	b083      	sub	sp, #12
 800d970:	af00      	add	r7, sp, #0
 800d972:	4603      	mov	r3, r0
 800d974:	6039      	str	r1, [r7, #0]
 800d976:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800d978:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d97c:	2b00      	cmp	r3, #0
 800d97e:	db0a      	blt.n	800d996 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d980:	683b      	ldr	r3, [r7, #0]
 800d982:	b2da      	uxtb	r2, r3
 800d984:	490c      	ldr	r1, [pc, #48]	; (800d9b8 <__NVIC_SetPriority+0x4c>)
 800d986:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800d98a:	0112      	lsls	r2, r2, #4
 800d98c:	b2d2      	uxtb	r2, r2
 800d98e:	440b      	add	r3, r1
 800d990:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800d994:	e00a      	b.n	800d9ac <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800d996:	683b      	ldr	r3, [r7, #0]
 800d998:	b2da      	uxtb	r2, r3
 800d99a:	4908      	ldr	r1, [pc, #32]	; (800d9bc <__NVIC_SetPriority+0x50>)
 800d99c:	79fb      	ldrb	r3, [r7, #7]
 800d99e:	f003 030f 	and.w	r3, r3, #15
 800d9a2:	3b04      	subs	r3, #4
 800d9a4:	0112      	lsls	r2, r2, #4
 800d9a6:	b2d2      	uxtb	r2, r2
 800d9a8:	440b      	add	r3, r1
 800d9aa:	761a      	strb	r2, [r3, #24]
}
 800d9ac:	bf00      	nop
 800d9ae:	370c      	adds	r7, #12
 800d9b0:	46bd      	mov	sp, r7
 800d9b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9b6:	4770      	bx	lr
 800d9b8:	e000e100 	.word	0xe000e100
 800d9bc:	e000ed00 	.word	0xe000ed00

0800d9c0 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800d9c0:	b480      	push	{r7}
 800d9c2:	b089      	sub	sp, #36	; 0x24
 800d9c4:	af00      	add	r7, sp, #0
 800d9c6:	60f8      	str	r0, [r7, #12]
 800d9c8:	60b9      	str	r1, [r7, #8]
 800d9ca:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800d9cc:	68fb      	ldr	r3, [r7, #12]
 800d9ce:	f003 0307 	and.w	r3, r3, #7
 800d9d2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800d9d4:	69fb      	ldr	r3, [r7, #28]
 800d9d6:	f1c3 0307 	rsb	r3, r3, #7
 800d9da:	2b04      	cmp	r3, #4
 800d9dc:	bf28      	it	cs
 800d9de:	2304      	movcs	r3, #4
 800d9e0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800d9e2:	69fb      	ldr	r3, [r7, #28]
 800d9e4:	3304      	adds	r3, #4
 800d9e6:	2b06      	cmp	r3, #6
 800d9e8:	d902      	bls.n	800d9f0 <NVIC_EncodePriority+0x30>
 800d9ea:	69fb      	ldr	r3, [r7, #28]
 800d9ec:	3b03      	subs	r3, #3
 800d9ee:	e000      	b.n	800d9f2 <NVIC_EncodePriority+0x32>
 800d9f0:	2300      	movs	r3, #0
 800d9f2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800d9f4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800d9f8:	69bb      	ldr	r3, [r7, #24]
 800d9fa:	fa02 f303 	lsl.w	r3, r2, r3
 800d9fe:	43da      	mvns	r2, r3
 800da00:	68bb      	ldr	r3, [r7, #8]
 800da02:	401a      	ands	r2, r3
 800da04:	697b      	ldr	r3, [r7, #20]
 800da06:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800da08:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800da0c:	697b      	ldr	r3, [r7, #20]
 800da0e:	fa01 f303 	lsl.w	r3, r1, r3
 800da12:	43d9      	mvns	r1, r3
 800da14:	687b      	ldr	r3, [r7, #4]
 800da16:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800da18:	4313      	orrs	r3, r2
         );
}
 800da1a:	4618      	mov	r0, r3
 800da1c:	3724      	adds	r7, #36	; 0x24
 800da1e:	46bd      	mov	sp, r7
 800da20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da24:	4770      	bx	lr

0800da26 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800da26:	b580      	push	{r7, lr}
 800da28:	b082      	sub	sp, #8
 800da2a:	af00      	add	r7, sp, #0
 800da2c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800da2e:	6878      	ldr	r0, [r7, #4]
 800da30:	f7ff feec 	bl	800d80c <__NVIC_SetPriorityGrouping>
}
 800da34:	bf00      	nop
 800da36:	3708      	adds	r7, #8
 800da38:	46bd      	mov	sp, r7
 800da3a:	bd80      	pop	{r7, pc}

0800da3c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800da3c:	b580      	push	{r7, lr}
 800da3e:	b086      	sub	sp, #24
 800da40:	af00      	add	r7, sp, #0
 800da42:	4603      	mov	r3, r0
 800da44:	60b9      	str	r1, [r7, #8]
 800da46:	607a      	str	r2, [r7, #4]
 800da48:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800da4a:	f7ff ff03 	bl	800d854 <__NVIC_GetPriorityGrouping>
 800da4e:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800da50:	687a      	ldr	r2, [r7, #4]
 800da52:	68b9      	ldr	r1, [r7, #8]
 800da54:	6978      	ldr	r0, [r7, #20]
 800da56:	f7ff ffb3 	bl	800d9c0 <NVIC_EncodePriority>
 800da5a:	4602      	mov	r2, r0
 800da5c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800da60:	4611      	mov	r1, r2
 800da62:	4618      	mov	r0, r3
 800da64:	f7ff ff82 	bl	800d96c <__NVIC_SetPriority>
}
 800da68:	bf00      	nop
 800da6a:	3718      	adds	r7, #24
 800da6c:	46bd      	mov	sp, r7
 800da6e:	bd80      	pop	{r7, pc}

0800da70 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800da70:	b580      	push	{r7, lr}
 800da72:	b082      	sub	sp, #8
 800da74:	af00      	add	r7, sp, #0
 800da76:	4603      	mov	r3, r0
 800da78:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800da7a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800da7e:	4618      	mov	r0, r3
 800da80:	f7ff fef6 	bl	800d870 <__NVIC_EnableIRQ>
}
 800da84:	bf00      	nop
 800da86:	3708      	adds	r7, #8
 800da88:	46bd      	mov	sp, r7
 800da8a:	bd80      	pop	{r7, pc}

0800da8c <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800da8c:	b580      	push	{r7, lr}
 800da8e:	b082      	sub	sp, #8
 800da90:	af00      	add	r7, sp, #0
 800da92:	4603      	mov	r3, r0
 800da94:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800da96:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800da9a:	4618      	mov	r0, r3
 800da9c:	f7ff ff06 	bl	800d8ac <__NVIC_DisableIRQ>
}
 800daa0:	bf00      	nop
 800daa2:	3708      	adds	r7, #8
 800daa4:	46bd      	mov	sp, r7
 800daa6:	bd80      	pop	{r7, pc}

0800daa8 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 800daa8:	b580      	push	{r7, lr}
 800daaa:	b082      	sub	sp, #8
 800daac:	af00      	add	r7, sp, #0
 800daae:	4603      	mov	r3, r0
 800dab0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
 800dab2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dab6:	4618      	mov	r0, r3
 800dab8:	f7ff ff1c 	bl	800d8f4 <__NVIC_SetPendingIRQ>
}
 800dabc:	bf00      	nop
 800dabe:	3708      	adds	r7, #8
 800dac0:	46bd      	mov	sp, r7
 800dac2:	bd80      	pop	{r7, pc}

0800dac4 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 800dac4:	b580      	push	{r7, lr}
 800dac6:	b082      	sub	sp, #8
 800dac8:	af00      	add	r7, sp, #0
 800daca:	4603      	mov	r3, r0
 800dacc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
 800dace:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800dad2:	4618      	mov	r0, r3
 800dad4:	f7ff ff2c 	bl	800d930 <__NVIC_ClearPendingIRQ>
}
 800dad8:	bf00      	nop
 800dada:	3708      	adds	r7, #8
 800dadc:	46bd      	mov	sp, r7
 800dade:	bd80      	pop	{r7, pc}

0800dae0 <HAL_DMA_Init>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800dae0:	b580      	push	{r7, lr}
 800dae2:	b084      	sub	sp, #16
 800dae4:	af00      	add	r7, sp, #0
 800dae6:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 800dae8:	687b      	ldr	r3, [r7, #4]
 800daea:	2b00      	cmp	r3, #0
 800daec:	d101      	bne.n	800daf2 <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
 800daee:	2301      	movs	r3, #1
 800daf0:	e08e      	b.n	800dc10 <HAL_DMA_Init+0x130>

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

#if defined(DMA2)
  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800daf2:	687b      	ldr	r3, [r7, #4]
 800daf4:	681b      	ldr	r3, [r3, #0]
 800daf6:	461a      	mov	r2, r3
 800daf8:	4b47      	ldr	r3, [pc, #284]	; (800dc18 <HAL_DMA_Init+0x138>)
 800dafa:	429a      	cmp	r2, r3
 800dafc:	d80f      	bhi.n	800db1e <HAL_DMA_Init+0x3e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800dafe:	687b      	ldr	r3, [r7, #4]
 800db00:	681b      	ldr	r3, [r3, #0]
 800db02:	461a      	mov	r2, r3
 800db04:	4b45      	ldr	r3, [pc, #276]	; (800dc1c <HAL_DMA_Init+0x13c>)
 800db06:	4413      	add	r3, r2
 800db08:	4a45      	ldr	r2, [pc, #276]	; (800dc20 <HAL_DMA_Init+0x140>)
 800db0a:	fba2 2303 	umull	r2, r3, r2, r3
 800db0e:	091b      	lsrs	r3, r3, #4
 800db10:	009a      	lsls	r2, r3, #2
 800db12:	687b      	ldr	r3, [r7, #4]
 800db14:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 800db16:	687b      	ldr	r3, [r7, #4]
 800db18:	4a42      	ldr	r2, [pc, #264]	; (800dc24 <HAL_DMA_Init+0x144>)
 800db1a:	641a      	str	r2, [r3, #64]	; 0x40
 800db1c:	e00e      	b.n	800db3c <HAL_DMA_Init+0x5c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 800db1e:	687b      	ldr	r3, [r7, #4]
 800db20:	681b      	ldr	r3, [r3, #0]
 800db22:	461a      	mov	r2, r3
 800db24:	4b40      	ldr	r3, [pc, #256]	; (800dc28 <HAL_DMA_Init+0x148>)
 800db26:	4413      	add	r3, r2
 800db28:	4a3d      	ldr	r2, [pc, #244]	; (800dc20 <HAL_DMA_Init+0x140>)
 800db2a:	fba2 2303 	umull	r2, r3, r2, r3
 800db2e:	091b      	lsrs	r3, r3, #4
 800db30:	009a      	lsls	r2, r3, #2
 800db32:	687b      	ldr	r3, [r7, #4]
 800db34:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 800db36:	687b      	ldr	r3, [r7, #4]
 800db38:	4a3c      	ldr	r2, [pc, #240]	; (800dc2c <HAL_DMA_Init+0x14c>)
 800db3a:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
  hdma->DmaBaseAddress = DMA1;
#endif

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800db3c:	687b      	ldr	r3, [r7, #4]
 800db3e:	2202      	movs	r2, #2
 800db40:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 800db44:	687b      	ldr	r3, [r7, #4]
 800db46:	681b      	ldr	r3, [r3, #0]
 800db48:	681b      	ldr	r3, [r3, #0]
 800db4a:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 800db4c:	68fb      	ldr	r3, [r7, #12]
 800db4e:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800db52:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800db56:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800db58:	687b      	ldr	r3, [r7, #4]
 800db5a:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800db5c:	687b      	ldr	r3, [r7, #4]
 800db5e:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 800db60:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800db62:	687b      	ldr	r3, [r7, #4]
 800db64:	691b      	ldr	r3, [r3, #16]
 800db66:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800db68:	687b      	ldr	r3, [r7, #4]
 800db6a:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800db6c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800db6e:	687b      	ldr	r3, [r7, #4]
 800db70:	699b      	ldr	r3, [r3, #24]
 800db72:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800db74:	687b      	ldr	r3, [r7, #4]
 800db76:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800db78:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800db7a:	687b      	ldr	r3, [r7, #4]
 800db7c:	6a1b      	ldr	r3, [r3, #32]
 800db7e:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
 800db80:	68fa      	ldr	r2, [r7, #12]
 800db82:	4313      	orrs	r3, r2
 800db84:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 800db86:	687b      	ldr	r3, [r7, #4]
 800db88:	681b      	ldr	r3, [r3, #0]
 800db8a:	68fa      	ldr	r2, [r7, #12]
 800db8c:	601a      	str	r2, [r3, #0]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
  */
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 800db8e:	6878      	ldr	r0, [r7, #4]
 800db90:	f000 f8fe 	bl	800dd90 <DMA_CalcDMAMUXChannelBaseAndMask>

  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800db94:	687b      	ldr	r3, [r7, #4]
 800db96:	689b      	ldr	r3, [r3, #8]
 800db98:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800db9c:	d102      	bne.n	800dba4 <HAL_DMA_Init+0xc4>
  {
    /* if memory to memory force the request to 0*/
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800db9e:	687b      	ldr	r3, [r7, #4]
 800dba0:	2200      	movs	r2, #0
 800dba2:	605a      	str	r2, [r3, #4]
  }

  /* Set peripheral request  to DMAMUX channel */
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800dba4:	687b      	ldr	r3, [r7, #4]
 800dba6:	685a      	ldr	r2, [r3, #4]
 800dba8:	687b      	ldr	r3, [r7, #4]
 800dbaa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800dbac:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800dbb0:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800dbb2:	687b      	ldr	r3, [r7, #4]
 800dbb4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800dbb6:	687a      	ldr	r2, [r7, #4]
 800dbb8:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800dbba:	605a      	str	r2, [r3, #4]

  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 800dbbc:	687b      	ldr	r3, [r7, #4]
 800dbbe:	685b      	ldr	r3, [r3, #4]
 800dbc0:	2b00      	cmp	r3, #0
 800dbc2:	d010      	beq.n	800dbe6 <HAL_DMA_Init+0x106>
 800dbc4:	687b      	ldr	r3, [r7, #4]
 800dbc6:	685b      	ldr	r3, [r3, #4]
 800dbc8:	2b04      	cmp	r3, #4
 800dbca:	d80c      	bhi.n	800dbe6 <HAL_DMA_Init+0x106>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 800dbcc:	6878      	ldr	r0, [r7, #4]
 800dbce:	f000 f91d 	bl	800de0c <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800dbd2:	687b      	ldr	r3, [r7, #4]
 800dbd4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800dbd6:	2200      	movs	r2, #0
 800dbd8:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800dbda:	687b      	ldr	r3, [r7, #4]
 800dbdc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800dbde:	687a      	ldr	r2, [r7, #4]
 800dbe0:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800dbe2:	605a      	str	r2, [r3, #4]
 800dbe4:	e008      	b.n	800dbf8 <HAL_DMA_Init+0x118>
  }
  else
  {
    hdma->DMAmuxRequestGen = 0U;
 800dbe6:	687b      	ldr	r3, [r7, #4]
 800dbe8:	2200      	movs	r2, #0
 800dbea:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatus = 0U;
 800dbec:	687b      	ldr	r3, [r7, #4]
 800dbee:	2200      	movs	r2, #0
 800dbf0:	659a      	str	r2, [r3, #88]	; 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800dbf2:	687b      	ldr	r3, [r7, #4]
 800dbf4:	2200      	movs	r2, #0
 800dbf6:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800dbf8:	687b      	ldr	r3, [r7, #4]
 800dbfa:	2200      	movs	r2, #0
 800dbfc:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 800dbfe:	687b      	ldr	r3, [r7, #4]
 800dc00:	2201      	movs	r2, #1
 800dc02:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 800dc06:	687b      	ldr	r3, [r7, #4]
 800dc08:	2200      	movs	r2, #0
 800dc0a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
 800dc0e:	2300      	movs	r3, #0
}
 800dc10:	4618      	mov	r0, r3
 800dc12:	3710      	adds	r7, #16
 800dc14:	46bd      	mov	sp, r7
 800dc16:	bd80      	pop	{r7, pc}
 800dc18:	40020407 	.word	0x40020407
 800dc1c:	bffdfff8 	.word	0xbffdfff8
 800dc20:	cccccccd 	.word	0xcccccccd
 800dc24:	40020000 	.word	0x40020000
 800dc28:	bffdfbf8 	.word	0xbffdfbf8
 800dc2c:	40020400 	.word	0x40020400

0800dc30 <HAL_DMA_IRQHandler>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800dc30:	b580      	push	{r7, lr}
 800dc32:	b084      	sub	sp, #16
 800dc34:	af00      	add	r7, sp, #0
 800dc36:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 800dc38:	687b      	ldr	r3, [r7, #4]
 800dc3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dc3c:	681b      	ldr	r3, [r3, #0]
 800dc3e:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 800dc40:	687b      	ldr	r3, [r7, #4]
 800dc42:	681b      	ldr	r3, [r3, #0]
 800dc44:	681b      	ldr	r3, [r3, #0]
 800dc46:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 800dc48:	687b      	ldr	r3, [r7, #4]
 800dc4a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dc4c:	f003 031c 	and.w	r3, r3, #28
 800dc50:	2204      	movs	r2, #4
 800dc52:	409a      	lsls	r2, r3
 800dc54:	68fb      	ldr	r3, [r7, #12]
 800dc56:	4013      	ands	r3, r2
 800dc58:	2b00      	cmp	r3, #0
 800dc5a:	d026      	beq.n	800dcaa <HAL_DMA_IRQHandler+0x7a>
 800dc5c:	68bb      	ldr	r3, [r7, #8]
 800dc5e:	f003 0304 	and.w	r3, r3, #4
 800dc62:	2b00      	cmp	r3, #0
 800dc64:	d021      	beq.n	800dcaa <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800dc66:	687b      	ldr	r3, [r7, #4]
 800dc68:	681b      	ldr	r3, [r3, #0]
 800dc6a:	681b      	ldr	r3, [r3, #0]
 800dc6c:	f003 0320 	and.w	r3, r3, #32
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	d107      	bne.n	800dc84 <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800dc74:	687b      	ldr	r3, [r7, #4]
 800dc76:	681b      	ldr	r3, [r3, #0]
 800dc78:	681a      	ldr	r2, [r3, #0]
 800dc7a:	687b      	ldr	r3, [r7, #4]
 800dc7c:	681b      	ldr	r3, [r3, #0]
 800dc7e:	f022 0204 	bic.w	r2, r2, #4
 800dc82:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU));
 800dc84:	687b      	ldr	r3, [r7, #4]
 800dc86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dc88:	f003 021c 	and.w	r2, r3, #28
 800dc8c:	687b      	ldr	r3, [r7, #4]
 800dc8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dc90:	2104      	movs	r1, #4
 800dc92:	fa01 f202 	lsl.w	r2, r1, r2
 800dc96:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dc9c:	2b00      	cmp	r3, #0
 800dc9e:	d071      	beq.n	800dd84 <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dca4:	6878      	ldr	r0, [r7, #4]
 800dca6:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
 800dca8:	e06c      	b.n	800dd84 <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 800dcaa:	687b      	ldr	r3, [r7, #4]
 800dcac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dcae:	f003 031c 	and.w	r3, r3, #28
 800dcb2:	2202      	movs	r2, #2
 800dcb4:	409a      	lsls	r2, r3
 800dcb6:	68fb      	ldr	r3, [r7, #12]
 800dcb8:	4013      	ands	r3, r2
 800dcba:	2b00      	cmp	r3, #0
 800dcbc:	d02e      	beq.n	800dd1c <HAL_DMA_IRQHandler+0xec>
 800dcbe:	68bb      	ldr	r3, [r7, #8]
 800dcc0:	f003 0302 	and.w	r3, r3, #2
 800dcc4:	2b00      	cmp	r3, #0
 800dcc6:	d029      	beq.n	800dd1c <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800dcc8:	687b      	ldr	r3, [r7, #4]
 800dcca:	681b      	ldr	r3, [r3, #0]
 800dccc:	681b      	ldr	r3, [r3, #0]
 800dcce:	f003 0320 	and.w	r3, r3, #32
 800dcd2:	2b00      	cmp	r3, #0
 800dcd4:	d10b      	bne.n	800dcee <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800dcd6:	687b      	ldr	r3, [r7, #4]
 800dcd8:	681b      	ldr	r3, [r3, #0]
 800dcda:	681a      	ldr	r2, [r3, #0]
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	681b      	ldr	r3, [r3, #0]
 800dce0:	f022 020a 	bic.w	r2, r2, #10
 800dce4:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 800dce6:	687b      	ldr	r3, [r7, #4]
 800dce8:	2201      	movs	r2, #1
 800dcea:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 800dcee:	687b      	ldr	r3, [r7, #4]
 800dcf0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dcf2:	f003 021c 	and.w	r2, r3, #28
 800dcf6:	687b      	ldr	r3, [r7, #4]
 800dcf8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dcfa:	2102      	movs	r1, #2
 800dcfc:	fa01 f202 	lsl.w	r2, r1, r2
 800dd00:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800dd02:	687b      	ldr	r3, [r7, #4]
 800dd04:	2200      	movs	r2, #0
 800dd06:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
 800dd0a:	687b      	ldr	r3, [r7, #4]
 800dd0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dd0e:	2b00      	cmp	r3, #0
 800dd10:	d038      	beq.n	800dd84 <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 800dd12:	687b      	ldr	r3, [r7, #4]
 800dd14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800dd16:	6878      	ldr	r0, [r7, #4]
 800dd18:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
 800dd1a:	e033      	b.n	800dd84 <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))!= 0U) && ((source_it & DMA_IT_TE) != 0U))
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dd20:	f003 031c 	and.w	r3, r3, #28
 800dd24:	2208      	movs	r2, #8
 800dd26:	409a      	lsls	r2, r3
 800dd28:	68fb      	ldr	r3, [r7, #12]
 800dd2a:	4013      	ands	r3, r2
 800dd2c:	2b00      	cmp	r3, #0
 800dd2e:	d02a      	beq.n	800dd86 <HAL_DMA_IRQHandler+0x156>
 800dd30:	68bb      	ldr	r3, [r7, #8]
 800dd32:	f003 0308 	and.w	r3, r3, #8
 800dd36:	2b00      	cmp	r3, #0
 800dd38:	d025      	beq.n	800dd86 <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800dd3a:	687b      	ldr	r3, [r7, #4]
 800dd3c:	681b      	ldr	r3, [r3, #0]
 800dd3e:	681a      	ldr	r2, [r3, #0]
 800dd40:	687b      	ldr	r3, [r7, #4]
 800dd42:	681b      	ldr	r3, [r3, #0]
 800dd44:	f022 020e 	bic.w	r2, r2, #14
 800dd48:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800dd4a:	687b      	ldr	r3, [r7, #4]
 800dd4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dd4e:	f003 021c 	and.w	r2, r3, #28
 800dd52:	687b      	ldr	r3, [r7, #4]
 800dd54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800dd56:	2101      	movs	r1, #1
 800dd58:	fa01 f202 	lsl.w	r2, r1, r2
 800dd5c:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800dd5e:	687b      	ldr	r3, [r7, #4]
 800dd60:	2201      	movs	r2, #1
 800dd62:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800dd64:	687b      	ldr	r3, [r7, #4]
 800dd66:	2201      	movs	r2, #1
 800dd68:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800dd6c:	687b      	ldr	r3, [r7, #4]
 800dd6e:	2200      	movs	r2, #0
 800dd70:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
 800dd74:	687b      	ldr	r3, [r7, #4]
 800dd76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800dd78:	2b00      	cmp	r3, #0
 800dd7a:	d004      	beq.n	800dd86 <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800dd7c:	687b      	ldr	r3, [r7, #4]
 800dd7e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800dd80:	6878      	ldr	r0, [r7, #4]
 800dd82:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 800dd84:	bf00      	nop
 800dd86:	bf00      	nop
}
 800dd88:	3710      	adds	r7, #16
 800dd8a:	46bd      	mov	sp, r7
 800dd8c:	bd80      	pop	{r7, pc}
	...

0800dd90 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 800dd90:	b480      	push	{r7}
 800dd92:	b085      	sub	sp, #20
 800dd94:	af00      	add	r7, sp, #0
 800dd96:	6078      	str	r0, [r7, #4]
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
#if defined(DMA2)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 800dd98:	687b      	ldr	r3, [r7, #4]
 800dd9a:	681b      	ldr	r3, [r3, #0]
 800dd9c:	461a      	mov	r2, r3
 800dd9e:	4b17      	ldr	r3, [pc, #92]	; (800ddfc <DMA_CalcDMAMUXChannelBaseAndMask+0x6c>)
 800dda0:	429a      	cmp	r2, r3
 800dda2:	d80a      	bhi.n	800ddba <DMA_CalcDMAMUXChannelBaseAndMask+0x2a>
  {
    /* DMA1 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 800dda4:	687b      	ldr	r3, [r7, #4]
 800dda6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800dda8:	089b      	lsrs	r3, r3, #2
 800ddaa:	009b      	lsls	r3, r3, #2
 800ddac:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800ddb0:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 800ddb4:	687a      	ldr	r2, [r7, #4]
 800ddb6:	6493      	str	r3, [r2, #72]	; 0x48
 800ddb8:	e007      	b.n	800ddca <DMA_CalcDMAMUXChannelBaseAndMask+0x3a>
  }
  else
  {
    /* DMA2 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ddbe:	089b      	lsrs	r3, r3, #2
 800ddc0:	009a      	lsls	r2, r3, #2
 800ddc2:	4b0f      	ldr	r3, [pc, #60]	; (800de00 <DMA_CalcDMAMUXChannelBaseAndMask+0x70>)
 800ddc4:	4413      	add	r3, r2
 800ddc6:	687a      	ldr	r2, [r7, #4]
 800ddc8:	6493      	str	r3, [r2, #72]	; 0x48
  }
#else
  /* DMA1 */
  hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
#endif
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800ddca:	687b      	ldr	r3, [r7, #4]
 800ddcc:	681b      	ldr	r3, [r3, #0]
 800ddce:	b2db      	uxtb	r3, r3
 800ddd0:	3b08      	subs	r3, #8
 800ddd2:	4a0c      	ldr	r2, [pc, #48]	; (800de04 <DMA_CalcDMAMUXChannelBaseAndMask+0x74>)
 800ddd4:	fba2 2303 	umull	r2, r3, r2, r3
 800ddd8:	091b      	lsrs	r3, r3, #4
 800ddda:	60fb      	str	r3, [r7, #12]
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800dddc:	687b      	ldr	r3, [r7, #4]
 800ddde:	4a0a      	ldr	r2, [pc, #40]	; (800de08 <DMA_CalcDMAMUXChannelBaseAndMask+0x78>)
 800dde0:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800dde2:	68fb      	ldr	r3, [r7, #12]
 800dde4:	f003 031f 	and.w	r3, r3, #31
 800dde8:	2201      	movs	r2, #1
 800ddea:	409a      	lsls	r2, r3
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	651a      	str	r2, [r3, #80]	; 0x50
}
 800ddf0:	bf00      	nop
 800ddf2:	3714      	adds	r7, #20
 800ddf4:	46bd      	mov	sp, r7
 800ddf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ddfa:	4770      	bx	lr
 800ddfc:	40020407 	.word	0x40020407
 800de00:	4002081c 	.word	0x4002081c
 800de04:	cccccccd 	.word	0xcccccccd
 800de08:	40020880 	.word	0x40020880

0800de0c <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 800de0c:	b480      	push	{r7}
 800de0e:	b085      	sub	sp, #20
 800de10:	af00      	add	r7, sp, #0
 800de12:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 800de14:	687b      	ldr	r3, [r7, #4]
 800de16:	685b      	ldr	r3, [r3, #4]
 800de18:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800de1c:	60fb      	str	r3, [r7, #12]

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800de1e:	68fa      	ldr	r2, [r7, #12]
 800de20:	4b0b      	ldr	r3, [pc, #44]	; (800de50 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>)
 800de22:	4413      	add	r3, r2
 800de24:	009b      	lsls	r3, r3, #2
 800de26:	461a      	mov	r2, r3
 800de28:	687b      	ldr	r3, [r7, #4]
 800de2a:	655a      	str	r2, [r3, #84]	; 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800de2c:	687b      	ldr	r3, [r7, #4]
 800de2e:	4a09      	ldr	r2, [pc, #36]	; (800de54 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x48>)
 800de30:	659a      	str	r2, [r3, #88]	; 0x58

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 800de32:	68fb      	ldr	r3, [r7, #12]
 800de34:	3b01      	subs	r3, #1
 800de36:	f003 0303 	and.w	r3, r3, #3
 800de3a:	2201      	movs	r2, #1
 800de3c:	409a      	lsls	r2, r3
 800de3e:	687b      	ldr	r3, [r7, #4]
 800de40:	65da      	str	r2, [r3, #92]	; 0x5c
}
 800de42:	bf00      	nop
 800de44:	3714      	adds	r7, #20
 800de46:	46bd      	mov	sp, r7
 800de48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de4c:	4770      	bx	lr
 800de4e:	bf00      	nop
 800de50:	1000823f 	.word	0x1000823f
 800de54:	40020940 	.word	0x40020940

0800de58 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800de58:	b480      	push	{r7}
 800de5a:	b087      	sub	sp, #28
 800de5c:	af00      	add	r7, sp, #0
 800de5e:	6078      	str	r0, [r7, #4]
 800de60:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 800de62:	2300      	movs	r3, #0
 800de64:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800de66:	e14c      	b.n	800e102 <HAL_GPIO_Init+0x2aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800de68:	683b      	ldr	r3, [r7, #0]
 800de6a:	681a      	ldr	r2, [r3, #0]
 800de6c:	2101      	movs	r1, #1
 800de6e:	697b      	ldr	r3, [r7, #20]
 800de70:	fa01 f303 	lsl.w	r3, r1, r3
 800de74:	4013      	ands	r3, r2
 800de76:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800de78:	68fb      	ldr	r3, [r7, #12]
 800de7a:	2b00      	cmp	r3, #0
 800de7c:	f000 813e 	beq.w	800e0fc <HAL_GPIO_Init+0x2a4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800de80:	683b      	ldr	r3, [r7, #0]
 800de82:	685b      	ldr	r3, [r3, #4]
 800de84:	f003 0303 	and.w	r3, r3, #3
 800de88:	2b01      	cmp	r3, #1
 800de8a:	d005      	beq.n	800de98 <HAL_GPIO_Init+0x40>
 800de8c:	683b      	ldr	r3, [r7, #0]
 800de8e:	685b      	ldr	r3, [r3, #4]
 800de90:	f003 0303 	and.w	r3, r3, #3
 800de94:	2b02      	cmp	r3, #2
 800de96:	d130      	bne.n	800defa <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800de98:	687b      	ldr	r3, [r7, #4]
 800de9a:	689b      	ldr	r3, [r3, #8]
 800de9c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 800de9e:	697b      	ldr	r3, [r7, #20]
 800dea0:	005b      	lsls	r3, r3, #1
 800dea2:	2203      	movs	r2, #3
 800dea4:	fa02 f303 	lsl.w	r3, r2, r3
 800dea8:	43db      	mvns	r3, r3
 800deaa:	693a      	ldr	r2, [r7, #16]
 800deac:	4013      	ands	r3, r2
 800deae:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 800deb0:	683b      	ldr	r3, [r7, #0]
 800deb2:	68da      	ldr	r2, [r3, #12]
 800deb4:	697b      	ldr	r3, [r7, #20]
 800deb6:	005b      	lsls	r3, r3, #1
 800deb8:	fa02 f303 	lsl.w	r3, r2, r3
 800debc:	693a      	ldr	r2, [r7, #16]
 800debe:	4313      	orrs	r3, r2
 800dec0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	693a      	ldr	r2, [r7, #16]
 800dec6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800dec8:	687b      	ldr	r3, [r7, #4]
 800deca:	685b      	ldr	r3, [r3, #4]
 800decc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800dece:	2201      	movs	r2, #1
 800ded0:	697b      	ldr	r3, [r7, #20]
 800ded2:	fa02 f303 	lsl.w	r3, r2, r3
 800ded6:	43db      	mvns	r3, r3
 800ded8:	693a      	ldr	r2, [r7, #16]
 800deda:	4013      	ands	r3, r2
 800dedc:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800dede:	683b      	ldr	r3, [r7, #0]
 800dee0:	685b      	ldr	r3, [r3, #4]
 800dee2:	091b      	lsrs	r3, r3, #4
 800dee4:	f003 0201 	and.w	r2, r3, #1
 800dee8:	697b      	ldr	r3, [r7, #20]
 800deea:	fa02 f303 	lsl.w	r3, r2, r3
 800deee:	693a      	ldr	r2, [r7, #16]
 800def0:	4313      	orrs	r3, r2
 800def2:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800def4:	687b      	ldr	r3, [r7, #4]
 800def6:	693a      	ldr	r2, [r7, #16]
 800def8:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800defa:	683b      	ldr	r3, [r7, #0]
 800defc:	685b      	ldr	r3, [r3, #4]
 800defe:	f003 0303 	and.w	r3, r3, #3
 800df02:	2b03      	cmp	r3, #3
 800df04:	d017      	beq.n	800df36 <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
 800df06:	687b      	ldr	r3, [r7, #4]
 800df08:	68db      	ldr	r3, [r3, #12]
 800df0a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800df0c:	697b      	ldr	r3, [r7, #20]
 800df0e:	005b      	lsls	r3, r3, #1
 800df10:	2203      	movs	r2, #3
 800df12:	fa02 f303 	lsl.w	r3, r2, r3
 800df16:	43db      	mvns	r3, r3
 800df18:	693a      	ldr	r2, [r7, #16]
 800df1a:	4013      	ands	r3, r2
 800df1c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800df1e:	683b      	ldr	r3, [r7, #0]
 800df20:	689a      	ldr	r2, [r3, #8]
 800df22:	697b      	ldr	r3, [r7, #20]
 800df24:	005b      	lsls	r3, r3, #1
 800df26:	fa02 f303 	lsl.w	r3, r2, r3
 800df2a:	693a      	ldr	r2, [r7, #16]
 800df2c:	4313      	orrs	r3, r2
 800df2e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 800df30:	687b      	ldr	r3, [r7, #4]
 800df32:	693a      	ldr	r2, [r7, #16]
 800df34:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800df36:	683b      	ldr	r3, [r7, #0]
 800df38:	685b      	ldr	r3, [r3, #4]
 800df3a:	f003 0303 	and.w	r3, r3, #3
 800df3e:	2b02      	cmp	r3, #2
 800df40:	d123      	bne.n	800df8a <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 800df42:	697b      	ldr	r3, [r7, #20]
 800df44:	08da      	lsrs	r2, r3, #3
 800df46:	687b      	ldr	r3, [r7, #4]
 800df48:	3208      	adds	r2, #8
 800df4a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800df4e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800df50:	697b      	ldr	r3, [r7, #20]
 800df52:	f003 0307 	and.w	r3, r3, #7
 800df56:	009b      	lsls	r3, r3, #2
 800df58:	220f      	movs	r2, #15
 800df5a:	fa02 f303 	lsl.w	r3, r2, r3
 800df5e:	43db      	mvns	r3, r3
 800df60:	693a      	ldr	r2, [r7, #16]
 800df62:	4013      	ands	r3, r2
 800df64:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 800df66:	683b      	ldr	r3, [r7, #0]
 800df68:	691a      	ldr	r2, [r3, #16]
 800df6a:	697b      	ldr	r3, [r7, #20]
 800df6c:	f003 0307 	and.w	r3, r3, #7
 800df70:	009b      	lsls	r3, r3, #2
 800df72:	fa02 f303 	lsl.w	r3, r2, r3
 800df76:	693a      	ldr	r2, [r7, #16]
 800df78:	4313      	orrs	r3, r2
 800df7a:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 800df7c:	697b      	ldr	r3, [r7, #20]
 800df7e:	08da      	lsrs	r2, r3, #3
 800df80:	687b      	ldr	r3, [r7, #4]
 800df82:	3208      	adds	r2, #8
 800df84:	6939      	ldr	r1, [r7, #16]
 800df86:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800df8a:	687b      	ldr	r3, [r7, #4]
 800df8c:	681b      	ldr	r3, [r3, #0]
 800df8e:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 800df90:	697b      	ldr	r3, [r7, #20]
 800df92:	005b      	lsls	r3, r3, #1
 800df94:	2203      	movs	r2, #3
 800df96:	fa02 f303 	lsl.w	r3, r2, r3
 800df9a:	43db      	mvns	r3, r3
 800df9c:	693a      	ldr	r2, [r7, #16]
 800df9e:	4013      	ands	r3, r2
 800dfa0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800dfa2:	683b      	ldr	r3, [r7, #0]
 800dfa4:	685b      	ldr	r3, [r3, #4]
 800dfa6:	f003 0203 	and.w	r2, r3, #3
 800dfaa:	697b      	ldr	r3, [r7, #20]
 800dfac:	005b      	lsls	r3, r3, #1
 800dfae:	fa02 f303 	lsl.w	r3, r2, r3
 800dfb2:	693a      	ldr	r2, [r7, #16]
 800dfb4:	4313      	orrs	r3, r2
 800dfb6:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800dfb8:	687b      	ldr	r3, [r7, #4]
 800dfba:	693a      	ldr	r2, [r7, #16]
 800dfbc:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800dfbe:	683b      	ldr	r3, [r7, #0]
 800dfc0:	685b      	ldr	r3, [r3, #4]
 800dfc2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800dfc6:	2b00      	cmp	r3, #0
 800dfc8:	f000 8098 	beq.w	800e0fc <HAL_GPIO_Init+0x2a4>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 800dfcc:	4a54      	ldr	r2, [pc, #336]	; (800e120 <HAL_GPIO_Init+0x2c8>)
 800dfce:	697b      	ldr	r3, [r7, #20]
 800dfd0:	089b      	lsrs	r3, r3, #2
 800dfd2:	3302      	adds	r3, #2
 800dfd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dfd8:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800dfda:	697b      	ldr	r3, [r7, #20]
 800dfdc:	f003 0303 	and.w	r3, r3, #3
 800dfe0:	009b      	lsls	r3, r3, #2
 800dfe2:	220f      	movs	r2, #15
 800dfe4:	fa02 f303 	lsl.w	r3, r2, r3
 800dfe8:	43db      	mvns	r3, r3
 800dfea:	693a      	ldr	r2, [r7, #16]
 800dfec:	4013      	ands	r3, r2
 800dfee:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800dff0:	687b      	ldr	r3, [r7, #4]
 800dff2:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 800dff6:	d019      	beq.n	800e02c <HAL_GPIO_Init+0x1d4>
 800dff8:	687b      	ldr	r3, [r7, #4]
 800dffa:	4a4a      	ldr	r2, [pc, #296]	; (800e124 <HAL_GPIO_Init+0x2cc>)
 800dffc:	4293      	cmp	r3, r2
 800dffe:	d013      	beq.n	800e028 <HAL_GPIO_Init+0x1d0>
 800e000:	687b      	ldr	r3, [r7, #4]
 800e002:	4a49      	ldr	r2, [pc, #292]	; (800e128 <HAL_GPIO_Init+0x2d0>)
 800e004:	4293      	cmp	r3, r2
 800e006:	d00d      	beq.n	800e024 <HAL_GPIO_Init+0x1cc>
 800e008:	687b      	ldr	r3, [r7, #4]
 800e00a:	4a48      	ldr	r2, [pc, #288]	; (800e12c <HAL_GPIO_Init+0x2d4>)
 800e00c:	4293      	cmp	r3, r2
 800e00e:	d007      	beq.n	800e020 <HAL_GPIO_Init+0x1c8>
 800e010:	687b      	ldr	r3, [r7, #4]
 800e012:	4a47      	ldr	r2, [pc, #284]	; (800e130 <HAL_GPIO_Init+0x2d8>)
 800e014:	4293      	cmp	r3, r2
 800e016:	d101      	bne.n	800e01c <HAL_GPIO_Init+0x1c4>
 800e018:	2304      	movs	r3, #4
 800e01a:	e008      	b.n	800e02e <HAL_GPIO_Init+0x1d6>
 800e01c:	2307      	movs	r3, #7
 800e01e:	e006      	b.n	800e02e <HAL_GPIO_Init+0x1d6>
 800e020:	2303      	movs	r3, #3
 800e022:	e004      	b.n	800e02e <HAL_GPIO_Init+0x1d6>
 800e024:	2302      	movs	r3, #2
 800e026:	e002      	b.n	800e02e <HAL_GPIO_Init+0x1d6>
 800e028:	2301      	movs	r3, #1
 800e02a:	e000      	b.n	800e02e <HAL_GPIO_Init+0x1d6>
 800e02c:	2300      	movs	r3, #0
 800e02e:	697a      	ldr	r2, [r7, #20]
 800e030:	f002 0203 	and.w	r2, r2, #3
 800e034:	0092      	lsls	r2, r2, #2
 800e036:	4093      	lsls	r3, r2
 800e038:	693a      	ldr	r2, [r7, #16]
 800e03a:	4313      	orrs	r3, r2
 800e03c:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 800e03e:	4938      	ldr	r1, [pc, #224]	; (800e120 <HAL_GPIO_Init+0x2c8>)
 800e040:	697b      	ldr	r3, [r7, #20]
 800e042:	089b      	lsrs	r3, r3, #2
 800e044:	3302      	adds	r3, #2
 800e046:	693a      	ldr	r2, [r7, #16]
 800e048:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800e04c:	4b39      	ldr	r3, [pc, #228]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e04e:	681b      	ldr	r3, [r3, #0]
 800e050:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800e052:	68fb      	ldr	r3, [r7, #12]
 800e054:	43db      	mvns	r3, r3
 800e056:	693a      	ldr	r2, [r7, #16]
 800e058:	4013      	ands	r3, r2
 800e05a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800e05c:	683b      	ldr	r3, [r7, #0]
 800e05e:	685b      	ldr	r3, [r3, #4]
 800e060:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e064:	2b00      	cmp	r3, #0
 800e066:	d003      	beq.n	800e070 <HAL_GPIO_Init+0x218>
        {
          temp |= iocurrent;
 800e068:	693a      	ldr	r2, [r7, #16]
 800e06a:	68fb      	ldr	r3, [r7, #12]
 800e06c:	4313      	orrs	r3, r2
 800e06e:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 800e070:	4a30      	ldr	r2, [pc, #192]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e072:	693b      	ldr	r3, [r7, #16]
 800e074:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 800e076:	4b2f      	ldr	r3, [pc, #188]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e078:	685b      	ldr	r3, [r3, #4]
 800e07a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800e07c:	68fb      	ldr	r3, [r7, #12]
 800e07e:	43db      	mvns	r3, r3
 800e080:	693a      	ldr	r2, [r7, #16]
 800e082:	4013      	ands	r3, r2
 800e084:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800e086:	683b      	ldr	r3, [r7, #0]
 800e088:	685b      	ldr	r3, [r3, #4]
 800e08a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800e08e:	2b00      	cmp	r3, #0
 800e090:	d003      	beq.n	800e09a <HAL_GPIO_Init+0x242>
        {
          temp |= iocurrent;
 800e092:	693a      	ldr	r2, [r7, #16]
 800e094:	68fb      	ldr	r3, [r7, #12]
 800e096:	4313      	orrs	r3, r2
 800e098:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 800e09a:	4a26      	ldr	r2, [pc, #152]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e09c:	693b      	ldr	r3, [r7, #16]
 800e09e:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800e0a0:	4b24      	ldr	r3, [pc, #144]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e0a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800e0a6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800e0a8:	68fb      	ldr	r3, [r7, #12]
 800e0aa:	43db      	mvns	r3, r3
 800e0ac:	693a      	ldr	r2, [r7, #16]
 800e0ae:	4013      	ands	r3, r2
 800e0b0:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800e0b2:	683b      	ldr	r3, [r7, #0]
 800e0b4:	685b      	ldr	r3, [r3, #4]
 800e0b6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800e0ba:	2b00      	cmp	r3, #0
 800e0bc:	d003      	beq.n	800e0c6 <HAL_GPIO_Init+0x26e>
        {
          temp |= iocurrent;
 800e0be:	693a      	ldr	r2, [r7, #16]
 800e0c0:	68fb      	ldr	r3, [r7, #12]
 800e0c2:	4313      	orrs	r3, r2
 800e0c4:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 800e0c6:	4a1b      	ldr	r2, [pc, #108]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e0c8:	693b      	ldr	r3, [r7, #16]
 800e0ca:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

        temp = EXTI->EMR1;
 800e0ce:	4b19      	ldr	r3, [pc, #100]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e0d0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800e0d4:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800e0d6:	68fb      	ldr	r3, [r7, #12]
 800e0d8:	43db      	mvns	r3, r3
 800e0da:	693a      	ldr	r2, [r7, #16]
 800e0dc:	4013      	ands	r3, r2
 800e0de:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 800e0e0:	683b      	ldr	r3, [r7, #0]
 800e0e2:	685b      	ldr	r3, [r3, #4]
 800e0e4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e0e8:	2b00      	cmp	r3, #0
 800e0ea:	d003      	beq.n	800e0f4 <HAL_GPIO_Init+0x29c>
        {
          temp |= iocurrent;
 800e0ec:	693a      	ldr	r2, [r7, #16]
 800e0ee:	68fb      	ldr	r3, [r7, #12]
 800e0f0:	4313      	orrs	r3, r2
 800e0f2:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 800e0f4:	4a0f      	ldr	r2, [pc, #60]	; (800e134 <HAL_GPIO_Init+0x2dc>)
 800e0f6:	693b      	ldr	r3, [r7, #16]
 800e0f8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      }
    }

    position++;
 800e0fc:	697b      	ldr	r3, [r7, #20]
 800e0fe:	3301      	adds	r3, #1
 800e100:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800e102:	683b      	ldr	r3, [r7, #0]
 800e104:	681a      	ldr	r2, [r3, #0]
 800e106:	697b      	ldr	r3, [r7, #20]
 800e108:	fa22 f303 	lsr.w	r3, r2, r3
 800e10c:	2b00      	cmp	r3, #0
 800e10e:	f47f aeab 	bne.w	800de68 <HAL_GPIO_Init+0x10>
  }
}
 800e112:	bf00      	nop
 800e114:	bf00      	nop
 800e116:	371c      	adds	r7, #28
 800e118:	46bd      	mov	sp, r7
 800e11a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e11e:	4770      	bx	lr
 800e120:	40010000 	.word	0x40010000
 800e124:	48000400 	.word	0x48000400
 800e128:	48000800 	.word	0x48000800
 800e12c:	48000c00 	.word	0x48000c00
 800e130:	48001000 	.word	0x48001000
 800e134:	58000800 	.word	0x58000800

0800e138 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800e138:	b480      	push	{r7}
 800e13a:	b083      	sub	sp, #12
 800e13c:	af00      	add	r7, sp, #0
 800e13e:	6078      	str	r0, [r7, #4]
 800e140:	460b      	mov	r3, r1
 800e142:	807b      	strh	r3, [r7, #2]
 800e144:	4613      	mov	r3, r2
 800e146:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800e148:	787b      	ldrb	r3, [r7, #1]
 800e14a:	2b00      	cmp	r3, #0
 800e14c:	d003      	beq.n	800e156 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800e14e:	887a      	ldrh	r2, [r7, #2]
 800e150:	687b      	ldr	r3, [r7, #4]
 800e152:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800e154:	e002      	b.n	800e15c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800e156:	887a      	ldrh	r2, [r7, #2]
 800e158:	687b      	ldr	r3, [r7, #4]
 800e15a:	629a      	str	r2, [r3, #40]	; 0x28
}
 800e15c:	bf00      	nop
 800e15e:	370c      	adds	r7, #12
 800e160:	46bd      	mov	sp, r7
 800e162:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e166:	4770      	bx	lr

0800e168 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800e168:	b580      	push	{r7, lr}
 800e16a:	b082      	sub	sp, #8
 800e16c:	af00      	add	r7, sp, #0
 800e16e:	4603      	mov	r3, r0
 800e170:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800e172:	4b08      	ldr	r3, [pc, #32]	; (800e194 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800e174:	68da      	ldr	r2, [r3, #12]
 800e176:	88fb      	ldrh	r3, [r7, #6]
 800e178:	4013      	ands	r3, r2
 800e17a:	2b00      	cmp	r3, #0
 800e17c:	d006      	beq.n	800e18c <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800e17e:	4a05      	ldr	r2, [pc, #20]	; (800e194 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800e180:	88fb      	ldrh	r3, [r7, #6]
 800e182:	60d3      	str	r3, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800e184:	88fb      	ldrh	r3, [r7, #6]
 800e186:	4618      	mov	r0, r3
 800e188:	f7fc fac8 	bl	800a71c <HAL_GPIO_EXTI_Callback>
  }
}
 800e18c:	bf00      	nop
 800e18e:	3708      	adds	r7, #8
 800e190:	46bd      	mov	sp, r7
 800e192:	bd80      	pop	{r7, pc}
 800e194:	58000800 	.word	0x58000800

0800e198 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
 800e198:	b580      	push	{r7, lr}
 800e19a:	b082      	sub	sp, #8
 800e19c:	af00      	add	r7, sp, #0
  uint32_t statusreg;
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
 800e19e:	4b0a      	ldr	r3, [pc, #40]	; (800e1c8 <HAL_HSEM_IRQHandler+0x30>)
 800e1a0:	68db      	ldr	r3, [r3, #12]
 800e1a2:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
 800e1a4:	4b08      	ldr	r3, [pc, #32]	; (800e1c8 <HAL_HSEM_IRQHandler+0x30>)
 800e1a6:	681a      	ldr	r2, [r3, #0]
 800e1a8:	687b      	ldr	r3, [r7, #4]
 800e1aa:	43db      	mvns	r3, r3
 800e1ac:	4906      	ldr	r1, [pc, #24]	; (800e1c8 <HAL_HSEM_IRQHandler+0x30>)
 800e1ae:	4013      	ands	r3, r2
 800e1b0:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
 800e1b2:	4a05      	ldr	r2, [pc, #20]	; (800e1c8 <HAL_HSEM_IRQHandler+0x30>)
 800e1b4:	687b      	ldr	r3, [r7, #4]
 800e1b6:	6053      	str	r3, [r2, #4]

  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
 800e1b8:	6878      	ldr	r0, [r7, #4]
 800e1ba:	f000 f807 	bl	800e1cc <HAL_HSEM_FreeCallback>
}
 800e1be:	bf00      	nop
 800e1c0:	3708      	adds	r7, #8
 800e1c2:	46bd      	mov	sp, r7
 800e1c4:	bd80      	pop	{r7, pc}
 800e1c6:	bf00      	nop
 800e1c8:	58001500 	.word	0x58001500

0800e1cc <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
 800e1cc:	b480      	push	{r7}
 800e1ce:	b083      	sub	sp, #12
 800e1d0:	af00      	add	r7, sp, #0
 800e1d2:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
 800e1d4:	bf00      	nop
 800e1d6:	370c      	adds	r7, #12
 800e1d8:	46bd      	mov	sp, r7
 800e1da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1de:	4770      	bx	lr

0800e1e0 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800e1e0:	b580      	push	{r7, lr}
 800e1e2:	b082      	sub	sp, #8
 800e1e4:	af00      	add	r7, sp, #0
 800e1e6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800e1e8:	687b      	ldr	r3, [r7, #4]
 800e1ea:	2b00      	cmp	r3, #0
 800e1ec:	d101      	bne.n	800e1f2 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800e1ee:	2301      	movs	r3, #1
 800e1f0:	e081      	b.n	800e2f6 <HAL_I2C_Init+0x116>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e1f8:	b2db      	uxtb	r3, r3
 800e1fa:	2b00      	cmp	r3, #0
 800e1fc:	d106      	bne.n	800e20c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800e1fe:	687b      	ldr	r3, [r7, #4]
 800e200:	2200      	movs	r2, #0
 800e202:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800e206:	6878      	ldr	r0, [r7, #4]
 800e208:	f7fc f9da 	bl	800a5c0 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	2224      	movs	r2, #36	; 0x24
 800e210:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800e214:	687b      	ldr	r3, [r7, #4]
 800e216:	681b      	ldr	r3, [r3, #0]
 800e218:	681a      	ldr	r2, [r3, #0]
 800e21a:	687b      	ldr	r3, [r7, #4]
 800e21c:	681b      	ldr	r3, [r3, #0]
 800e21e:	f022 0201 	bic.w	r2, r2, #1
 800e222:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800e224:	687b      	ldr	r3, [r7, #4]
 800e226:	685a      	ldr	r2, [r3, #4]
 800e228:	687b      	ldr	r3, [r7, #4]
 800e22a:	681b      	ldr	r3, [r3, #0]
 800e22c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800e230:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800e232:	687b      	ldr	r3, [r7, #4]
 800e234:	681b      	ldr	r3, [r3, #0]
 800e236:	689a      	ldr	r2, [r3, #8]
 800e238:	687b      	ldr	r3, [r7, #4]
 800e23a:	681b      	ldr	r3, [r3, #0]
 800e23c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800e240:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800e242:	687b      	ldr	r3, [r7, #4]
 800e244:	68db      	ldr	r3, [r3, #12]
 800e246:	2b01      	cmp	r3, #1
 800e248:	d107      	bne.n	800e25a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800e24a:	687b      	ldr	r3, [r7, #4]
 800e24c:	689a      	ldr	r2, [r3, #8]
 800e24e:	687b      	ldr	r3, [r7, #4]
 800e250:	681b      	ldr	r3, [r3, #0]
 800e252:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800e256:	609a      	str	r2, [r3, #8]
 800e258:	e006      	b.n	800e268 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800e25a:	687b      	ldr	r3, [r7, #4]
 800e25c:	689a      	ldr	r2, [r3, #8]
 800e25e:	687b      	ldr	r3, [r7, #4]
 800e260:	681b      	ldr	r3, [r3, #0]
 800e262:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
 800e266:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800e268:	687b      	ldr	r3, [r7, #4]
 800e26a:	68db      	ldr	r3, [r3, #12]
 800e26c:	2b02      	cmp	r3, #2
 800e26e:	d104      	bne.n	800e27a <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800e270:	687b      	ldr	r3, [r7, #4]
 800e272:	681b      	ldr	r3, [r3, #0]
 800e274:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800e278:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800e27a:	687b      	ldr	r3, [r7, #4]
 800e27c:	681b      	ldr	r3, [r3, #0]
 800e27e:	685b      	ldr	r3, [r3, #4]
 800e280:	687a      	ldr	r2, [r7, #4]
 800e282:	6812      	ldr	r2, [r2, #0]
 800e284:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800e288:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800e28c:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800e28e:	687b      	ldr	r3, [r7, #4]
 800e290:	681b      	ldr	r3, [r3, #0]
 800e292:	68da      	ldr	r2, [r3, #12]
 800e294:	687b      	ldr	r3, [r7, #4]
 800e296:	681b      	ldr	r3, [r3, #0]
 800e298:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800e29c:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800e29e:	687b      	ldr	r3, [r7, #4]
 800e2a0:	691a      	ldr	r2, [r3, #16]
 800e2a2:	687b      	ldr	r3, [r7, #4]
 800e2a4:	695b      	ldr	r3, [r3, #20]
 800e2a6:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
 800e2aa:	687b      	ldr	r3, [r7, #4]
 800e2ac:	699b      	ldr	r3, [r3, #24]
 800e2ae:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 800e2b0:	687b      	ldr	r3, [r7, #4]
 800e2b2:	681b      	ldr	r3, [r3, #0]
 800e2b4:	430a      	orrs	r2, r1
 800e2b6:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800e2b8:	687b      	ldr	r3, [r7, #4]
 800e2ba:	69d9      	ldr	r1, [r3, #28]
 800e2bc:	687b      	ldr	r3, [r7, #4]
 800e2be:	6a1a      	ldr	r2, [r3, #32]
 800e2c0:	687b      	ldr	r3, [r7, #4]
 800e2c2:	681b      	ldr	r3, [r3, #0]
 800e2c4:	430a      	orrs	r2, r1
 800e2c6:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800e2c8:	687b      	ldr	r3, [r7, #4]
 800e2ca:	681b      	ldr	r3, [r3, #0]
 800e2cc:	681a      	ldr	r2, [r3, #0]
 800e2ce:	687b      	ldr	r3, [r7, #4]
 800e2d0:	681b      	ldr	r3, [r3, #0]
 800e2d2:	f042 0201 	orr.w	r2, r2, #1
 800e2d6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800e2d8:	687b      	ldr	r3, [r7, #4]
 800e2da:	2200      	movs	r2, #0
 800e2dc:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800e2de:	687b      	ldr	r3, [r7, #4]
 800e2e0:	2220      	movs	r2, #32
 800e2e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800e2e6:	687b      	ldr	r3, [r7, #4]
 800e2e8:	2200      	movs	r2, #0
 800e2ea:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800e2ec:	687b      	ldr	r3, [r7, #4]
 800e2ee:	2200      	movs	r2, #0
 800e2f0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
 800e2f4:	2300      	movs	r3, #0
}
 800e2f6:	4618      	mov	r0, r3
 800e2f8:	3708      	adds	r7, #8
 800e2fa:	46bd      	mov	sp, r7
 800e2fc:	bd80      	pop	{r7, pc}
	...

0800e300 <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                          uint16_t Size, uint32_t Timeout)
{
 800e300:	b580      	push	{r7, lr}
 800e302:	b088      	sub	sp, #32
 800e304:	af02      	add	r7, sp, #8
 800e306:	60f8      	str	r0, [r7, #12]
 800e308:	607a      	str	r2, [r7, #4]
 800e30a:	461a      	mov	r2, r3
 800e30c:	460b      	mov	r3, r1
 800e30e:	817b      	strh	r3, [r7, #10]
 800e310:	4613      	mov	r3, r2
 800e312:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800e314:	68fb      	ldr	r3, [r7, #12]
 800e316:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e31a:	b2db      	uxtb	r3, r3
 800e31c:	2b20      	cmp	r3, #32
 800e31e:	f040 80da 	bne.w	800e4d6 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800e322:	68fb      	ldr	r3, [r7, #12]
 800e324:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800e328:	2b01      	cmp	r3, #1
 800e32a:	d101      	bne.n	800e330 <HAL_I2C_Master_Transmit+0x30>
 800e32c:	2302      	movs	r3, #2
 800e32e:	e0d3      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
 800e330:	68fb      	ldr	r3, [r7, #12]
 800e332:	2201      	movs	r2, #1
 800e334:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800e338:	f7fe fba6 	bl	800ca88 <HAL_GetTick>
 800e33c:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800e33e:	697b      	ldr	r3, [r7, #20]
 800e340:	9300      	str	r3, [sp, #0]
 800e342:	2319      	movs	r3, #25
 800e344:	2201      	movs	r2, #1
 800e346:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800e34a:	68f8      	ldr	r0, [r7, #12]
 800e34c:	f000 fcd6 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e350:	4603      	mov	r3, r0
 800e352:	2b00      	cmp	r3, #0
 800e354:	d001      	beq.n	800e35a <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
 800e356:	2301      	movs	r3, #1
 800e358:	e0be      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800e35a:	68fb      	ldr	r3, [r7, #12]
 800e35c:	2221      	movs	r2, #33	; 0x21
 800e35e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800e362:	68fb      	ldr	r3, [r7, #12]
 800e364:	2210      	movs	r2, #16
 800e366:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800e36a:	68fb      	ldr	r3, [r7, #12]
 800e36c:	2200      	movs	r2, #0
 800e36e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800e370:	68fb      	ldr	r3, [r7, #12]
 800e372:	687a      	ldr	r2, [r7, #4]
 800e374:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800e376:	68fb      	ldr	r3, [r7, #12]
 800e378:	893a      	ldrh	r2, [r7, #8]
 800e37a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800e37c:	68fb      	ldr	r3, [r7, #12]
 800e37e:	2200      	movs	r2, #0
 800e380:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e382:	68fb      	ldr	r3, [r7, #12]
 800e384:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e386:	b29b      	uxth	r3, r3
 800e388:	2bff      	cmp	r3, #255	; 0xff
 800e38a:	d90e      	bls.n	800e3aa <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800e38c:	68fb      	ldr	r3, [r7, #12]
 800e38e:	22ff      	movs	r2, #255	; 0xff
 800e390:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e392:	68fb      	ldr	r3, [r7, #12]
 800e394:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e396:	b2da      	uxtb	r2, r3
 800e398:	8979      	ldrh	r1, [r7, #10]
 800e39a:	4b51      	ldr	r3, [pc, #324]	; (800e4e0 <HAL_I2C_Master_Transmit+0x1e0>)
 800e39c:	9300      	str	r3, [sp, #0]
 800e39e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e3a2:	68f8      	ldr	r0, [r7, #12]
 800e3a4:	f000 fe82 	bl	800f0ac <I2C_TransferConfig>
 800e3a8:	e06c      	b.n	800e484 <HAL_I2C_Master_Transmit+0x184>
                         I2C_GENERATE_START_WRITE);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800e3aa:	68fb      	ldr	r3, [r7, #12]
 800e3ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e3ae:	b29a      	uxth	r2, r3
 800e3b0:	68fb      	ldr	r3, [r7, #12]
 800e3b2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e3b4:	68fb      	ldr	r3, [r7, #12]
 800e3b6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e3b8:	b2da      	uxtb	r2, r3
 800e3ba:	8979      	ldrh	r1, [r7, #10]
 800e3bc:	4b48      	ldr	r3, [pc, #288]	; (800e4e0 <HAL_I2C_Master_Transmit+0x1e0>)
 800e3be:	9300      	str	r3, [sp, #0]
 800e3c0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e3c4:	68f8      	ldr	r0, [r7, #12]
 800e3c6:	f000 fe71 	bl	800f0ac <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);
    }

    while (hi2c->XferCount > 0U)
 800e3ca:	e05b      	b.n	800e484 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e3cc:	697a      	ldr	r2, [r7, #20]
 800e3ce:	6a39      	ldr	r1, [r7, #32]
 800e3d0:	68f8      	ldr	r0, [r7, #12]
 800e3d2:	f000 fcd3 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800e3d6:	4603      	mov	r3, r0
 800e3d8:	2b00      	cmp	r3, #0
 800e3da:	d001      	beq.n	800e3e0 <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
 800e3dc:	2301      	movs	r3, #1
 800e3de:	e07b      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800e3e0:	68fb      	ldr	r3, [r7, #12]
 800e3e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e3e4:	781a      	ldrb	r2, [r3, #0]
 800e3e6:	68fb      	ldr	r3, [r7, #12]
 800e3e8:	681b      	ldr	r3, [r3, #0]
 800e3ea:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800e3ec:	68fb      	ldr	r3, [r7, #12]
 800e3ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e3f0:	1c5a      	adds	r2, r3, #1
 800e3f2:	68fb      	ldr	r3, [r7, #12]
 800e3f4:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 800e3f6:	68fb      	ldr	r3, [r7, #12]
 800e3f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e3fa:	b29b      	uxth	r3, r3
 800e3fc:	3b01      	subs	r3, #1
 800e3fe:	b29a      	uxth	r2, r3
 800e400:	68fb      	ldr	r3, [r7, #12]
 800e402:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 800e404:	68fb      	ldr	r3, [r7, #12]
 800e406:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e408:	3b01      	subs	r3, #1
 800e40a:	b29a      	uxth	r2, r3
 800e40c:	68fb      	ldr	r3, [r7, #12]
 800e40e:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800e410:	68fb      	ldr	r3, [r7, #12]
 800e412:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e414:	b29b      	uxth	r3, r3
 800e416:	2b00      	cmp	r3, #0
 800e418:	d034      	beq.n	800e484 <HAL_I2C_Master_Transmit+0x184>
 800e41a:	68fb      	ldr	r3, [r7, #12]
 800e41c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e41e:	2b00      	cmp	r3, #0
 800e420:	d130      	bne.n	800e484 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800e422:	697b      	ldr	r3, [r7, #20]
 800e424:	9300      	str	r3, [sp, #0]
 800e426:	6a3b      	ldr	r3, [r7, #32]
 800e428:	2200      	movs	r2, #0
 800e42a:	2180      	movs	r1, #128	; 0x80
 800e42c:	68f8      	ldr	r0, [r7, #12]
 800e42e:	f000 fc65 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e432:	4603      	mov	r3, r0
 800e434:	2b00      	cmp	r3, #0
 800e436:	d001      	beq.n	800e43c <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
 800e438:	2301      	movs	r3, #1
 800e43a:	e04d      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e43c:	68fb      	ldr	r3, [r7, #12]
 800e43e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e440:	b29b      	uxth	r3, r3
 800e442:	2bff      	cmp	r3, #255	; 0xff
 800e444:	d90e      	bls.n	800e464 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800e446:	68fb      	ldr	r3, [r7, #12]
 800e448:	22ff      	movs	r2, #255	; 0xff
 800e44a:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e44c:	68fb      	ldr	r3, [r7, #12]
 800e44e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e450:	b2da      	uxtb	r2, r3
 800e452:	8979      	ldrh	r1, [r7, #10]
 800e454:	2300      	movs	r3, #0
 800e456:	9300      	str	r3, [sp, #0]
 800e458:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e45c:	68f8      	ldr	r0, [r7, #12]
 800e45e:	f000 fe25 	bl	800f0ac <I2C_TransferConfig>
 800e462:	e00f      	b.n	800e484 <HAL_I2C_Master_Transmit+0x184>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800e464:	68fb      	ldr	r3, [r7, #12]
 800e466:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e468:	b29a      	uxth	r2, r3
 800e46a:	68fb      	ldr	r3, [r7, #12]
 800e46c:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e46e:	68fb      	ldr	r3, [r7, #12]
 800e470:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e472:	b2da      	uxtb	r2, r3
 800e474:	8979      	ldrh	r1, [r7, #10]
 800e476:	2300      	movs	r3, #0
 800e478:	9300      	str	r3, [sp, #0]
 800e47a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e47e:	68f8      	ldr	r0, [r7, #12]
 800e480:	f000 fe14 	bl	800f0ac <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 800e484:	68fb      	ldr	r3, [r7, #12]
 800e486:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e488:	b29b      	uxth	r3, r3
 800e48a:	2b00      	cmp	r3, #0
 800e48c:	d19e      	bne.n	800e3cc <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e48e:	697a      	ldr	r2, [r7, #20]
 800e490:	6a39      	ldr	r1, [r7, #32]
 800e492:	68f8      	ldr	r0, [r7, #12]
 800e494:	f000 fcb2 	bl	800edfc <I2C_WaitOnSTOPFlagUntilTimeout>
 800e498:	4603      	mov	r3, r0
 800e49a:	2b00      	cmp	r3, #0
 800e49c:	d001      	beq.n	800e4a2 <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
 800e49e:	2301      	movs	r3, #1
 800e4a0:	e01a      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800e4a2:	68fb      	ldr	r3, [r7, #12]
 800e4a4:	681b      	ldr	r3, [r3, #0]
 800e4a6:	2220      	movs	r2, #32
 800e4a8:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800e4aa:	68fb      	ldr	r3, [r7, #12]
 800e4ac:	681b      	ldr	r3, [r3, #0]
 800e4ae:	6859      	ldr	r1, [r3, #4]
 800e4b0:	68fb      	ldr	r3, [r7, #12]
 800e4b2:	681a      	ldr	r2, [r3, #0]
 800e4b4:	4b0b      	ldr	r3, [pc, #44]	; (800e4e4 <HAL_I2C_Master_Transmit+0x1e4>)
 800e4b6:	400b      	ands	r3, r1
 800e4b8:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800e4ba:	68fb      	ldr	r3, [r7, #12]
 800e4bc:	2220      	movs	r2, #32
 800e4be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800e4c2:	68fb      	ldr	r3, [r7, #12]
 800e4c4:	2200      	movs	r2, #0
 800e4c6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800e4ca:	68fb      	ldr	r3, [r7, #12]
 800e4cc:	2200      	movs	r2, #0
 800e4ce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800e4d2:	2300      	movs	r3, #0
 800e4d4:	e000      	b.n	800e4d8 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
 800e4d6:	2302      	movs	r3, #2
  }
}
 800e4d8:	4618      	mov	r0, r3
 800e4da:	3718      	adds	r7, #24
 800e4dc:	46bd      	mov	sp, r7
 800e4de:	bd80      	pop	{r7, pc}
 800e4e0:	80002000 	.word	0x80002000
 800e4e4:	fe00e800 	.word	0xfe00e800

0800e4e8 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                         uint16_t Size, uint32_t Timeout)
{
 800e4e8:	b580      	push	{r7, lr}
 800e4ea:	b088      	sub	sp, #32
 800e4ec:	af02      	add	r7, sp, #8
 800e4ee:	60f8      	str	r0, [r7, #12]
 800e4f0:	607a      	str	r2, [r7, #4]
 800e4f2:	461a      	mov	r2, r3
 800e4f4:	460b      	mov	r3, r1
 800e4f6:	817b      	strh	r3, [r7, #10]
 800e4f8:	4613      	mov	r3, r2
 800e4fa:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800e4fc:	68fb      	ldr	r3, [r7, #12]
 800e4fe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e502:	b2db      	uxtb	r3, r3
 800e504:	2b20      	cmp	r3, #32
 800e506:	f040 80db 	bne.w	800e6c0 <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800e50a:	68fb      	ldr	r3, [r7, #12]
 800e50c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800e510:	2b01      	cmp	r3, #1
 800e512:	d101      	bne.n	800e518 <HAL_I2C_Master_Receive+0x30>
 800e514:	2302      	movs	r3, #2
 800e516:	e0d4      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
 800e518:	68fb      	ldr	r3, [r7, #12]
 800e51a:	2201      	movs	r2, #1
 800e51c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800e520:	f7fe fab2 	bl	800ca88 <HAL_GetTick>
 800e524:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800e526:	697b      	ldr	r3, [r7, #20]
 800e528:	9300      	str	r3, [sp, #0]
 800e52a:	2319      	movs	r3, #25
 800e52c:	2201      	movs	r2, #1
 800e52e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800e532:	68f8      	ldr	r0, [r7, #12]
 800e534:	f000 fbe2 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e538:	4603      	mov	r3, r0
 800e53a:	2b00      	cmp	r3, #0
 800e53c:	d001      	beq.n	800e542 <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
 800e53e:	2301      	movs	r3, #1
 800e540:	e0bf      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800e542:	68fb      	ldr	r3, [r7, #12]
 800e544:	2222      	movs	r2, #34	; 0x22
 800e546:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800e54a:	68fb      	ldr	r3, [r7, #12]
 800e54c:	2210      	movs	r2, #16
 800e54e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800e552:	68fb      	ldr	r3, [r7, #12]
 800e554:	2200      	movs	r2, #0
 800e556:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800e558:	68fb      	ldr	r3, [r7, #12]
 800e55a:	687a      	ldr	r2, [r7, #4]
 800e55c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800e55e:	68fb      	ldr	r3, [r7, #12]
 800e560:	893a      	ldrh	r2, [r7, #8]
 800e562:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800e564:	68fb      	ldr	r3, [r7, #12]
 800e566:	2200      	movs	r2, #0
 800e568:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e56a:	68fb      	ldr	r3, [r7, #12]
 800e56c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e56e:	b29b      	uxth	r3, r3
 800e570:	2bff      	cmp	r3, #255	; 0xff
 800e572:	d90e      	bls.n	800e592 <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800e574:	68fb      	ldr	r3, [r7, #12]
 800e576:	22ff      	movs	r2, #255	; 0xff
 800e578:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e57a:	68fb      	ldr	r3, [r7, #12]
 800e57c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e57e:	b2da      	uxtb	r2, r3
 800e580:	8979      	ldrh	r1, [r7, #10]
 800e582:	4b52      	ldr	r3, [pc, #328]	; (800e6cc <HAL_I2C_Master_Receive+0x1e4>)
 800e584:	9300      	str	r3, [sp, #0]
 800e586:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e58a:	68f8      	ldr	r0, [r7, #12]
 800e58c:	f000 fd8e 	bl	800f0ac <I2C_TransferConfig>
 800e590:	e06d      	b.n	800e66e <HAL_I2C_Master_Receive+0x186>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800e592:	68fb      	ldr	r3, [r7, #12]
 800e594:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e596:	b29a      	uxth	r2, r3
 800e598:	68fb      	ldr	r3, [r7, #12]
 800e59a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e59c:	68fb      	ldr	r3, [r7, #12]
 800e59e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e5a0:	b2da      	uxtb	r2, r3
 800e5a2:	8979      	ldrh	r1, [r7, #10]
 800e5a4:	4b49      	ldr	r3, [pc, #292]	; (800e6cc <HAL_I2C_Master_Receive+0x1e4>)
 800e5a6:	9300      	str	r3, [sp, #0]
 800e5a8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e5ac:	68f8      	ldr	r0, [r7, #12]
 800e5ae:	f000 fd7d 	bl	800f0ac <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);
    }

    while (hi2c->XferCount > 0U)
 800e5b2:	e05c      	b.n	800e66e <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e5b4:	697a      	ldr	r2, [r7, #20]
 800e5b6:	6a39      	ldr	r1, [r7, #32]
 800e5b8:	68f8      	ldr	r0, [r7, #12]
 800e5ba:	f000 fc5b 	bl	800ee74 <I2C_WaitOnRXNEFlagUntilTimeout>
 800e5be:	4603      	mov	r3, r0
 800e5c0:	2b00      	cmp	r3, #0
 800e5c2:	d001      	beq.n	800e5c8 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
 800e5c4:	2301      	movs	r3, #1
 800e5c6:	e07c      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800e5c8:	68fb      	ldr	r3, [r7, #12]
 800e5ca:	681b      	ldr	r3, [r3, #0]
 800e5cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e5ce:	68fb      	ldr	r3, [r7, #12]
 800e5d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e5d2:	b2d2      	uxtb	r2, r2
 800e5d4:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800e5d6:	68fb      	ldr	r3, [r7, #12]
 800e5d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e5da:	1c5a      	adds	r2, r3, #1
 800e5dc:	68fb      	ldr	r3, [r7, #12]
 800e5de:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 800e5e0:	68fb      	ldr	r3, [r7, #12]
 800e5e2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e5e4:	3b01      	subs	r3, #1
 800e5e6:	b29a      	uxth	r2, r3
 800e5e8:	68fb      	ldr	r3, [r7, #12]
 800e5ea:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 800e5ec:	68fb      	ldr	r3, [r7, #12]
 800e5ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e5f0:	b29b      	uxth	r3, r3
 800e5f2:	3b01      	subs	r3, #1
 800e5f4:	b29a      	uxth	r2, r3
 800e5f6:	68fb      	ldr	r3, [r7, #12]
 800e5f8:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800e5fa:	68fb      	ldr	r3, [r7, #12]
 800e5fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e5fe:	b29b      	uxth	r3, r3
 800e600:	2b00      	cmp	r3, #0
 800e602:	d034      	beq.n	800e66e <HAL_I2C_Master_Receive+0x186>
 800e604:	68fb      	ldr	r3, [r7, #12]
 800e606:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e608:	2b00      	cmp	r3, #0
 800e60a:	d130      	bne.n	800e66e <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800e60c:	697b      	ldr	r3, [r7, #20]
 800e60e:	9300      	str	r3, [sp, #0]
 800e610:	6a3b      	ldr	r3, [r7, #32]
 800e612:	2200      	movs	r2, #0
 800e614:	2180      	movs	r1, #128	; 0x80
 800e616:	68f8      	ldr	r0, [r7, #12]
 800e618:	f000 fb70 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e61c:	4603      	mov	r3, r0
 800e61e:	2b00      	cmp	r3, #0
 800e620:	d001      	beq.n	800e626 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
 800e622:	2301      	movs	r3, #1
 800e624:	e04d      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e626:	68fb      	ldr	r3, [r7, #12]
 800e628:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e62a:	b29b      	uxth	r3, r3
 800e62c:	2bff      	cmp	r3, #255	; 0xff
 800e62e:	d90e      	bls.n	800e64e <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800e630:	68fb      	ldr	r3, [r7, #12]
 800e632:	22ff      	movs	r2, #255	; 0xff
 800e634:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e636:	68fb      	ldr	r3, [r7, #12]
 800e638:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e63a:	b2da      	uxtb	r2, r3
 800e63c:	8979      	ldrh	r1, [r7, #10]
 800e63e:	2300      	movs	r3, #0
 800e640:	9300      	str	r3, [sp, #0]
 800e642:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e646:	68f8      	ldr	r0, [r7, #12]
 800e648:	f000 fd30 	bl	800f0ac <I2C_TransferConfig>
 800e64c:	e00f      	b.n	800e66e <HAL_I2C_Master_Receive+0x186>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800e64e:	68fb      	ldr	r3, [r7, #12]
 800e650:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e652:	b29a      	uxth	r2, r3
 800e654:	68fb      	ldr	r3, [r7, #12]
 800e656:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e658:	68fb      	ldr	r3, [r7, #12]
 800e65a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e65c:	b2da      	uxtb	r2, r3
 800e65e:	8979      	ldrh	r1, [r7, #10]
 800e660:	2300      	movs	r3, #0
 800e662:	9300      	str	r3, [sp, #0]
 800e664:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e668:	68f8      	ldr	r0, [r7, #12]
 800e66a:	f000 fd1f 	bl	800f0ac <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 800e66e:	68fb      	ldr	r3, [r7, #12]
 800e670:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e672:	b29b      	uxth	r3, r3
 800e674:	2b00      	cmp	r3, #0
 800e676:	d19d      	bne.n	800e5b4 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e678:	697a      	ldr	r2, [r7, #20]
 800e67a:	6a39      	ldr	r1, [r7, #32]
 800e67c:	68f8      	ldr	r0, [r7, #12]
 800e67e:	f000 fbbd 	bl	800edfc <I2C_WaitOnSTOPFlagUntilTimeout>
 800e682:	4603      	mov	r3, r0
 800e684:	2b00      	cmp	r3, #0
 800e686:	d001      	beq.n	800e68c <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
 800e688:	2301      	movs	r3, #1
 800e68a:	e01a      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800e68c:	68fb      	ldr	r3, [r7, #12]
 800e68e:	681b      	ldr	r3, [r3, #0]
 800e690:	2220      	movs	r2, #32
 800e692:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800e694:	68fb      	ldr	r3, [r7, #12]
 800e696:	681b      	ldr	r3, [r3, #0]
 800e698:	6859      	ldr	r1, [r3, #4]
 800e69a:	68fb      	ldr	r3, [r7, #12]
 800e69c:	681a      	ldr	r2, [r3, #0]
 800e69e:	4b0c      	ldr	r3, [pc, #48]	; (800e6d0 <HAL_I2C_Master_Receive+0x1e8>)
 800e6a0:	400b      	ands	r3, r1
 800e6a2:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800e6a4:	68fb      	ldr	r3, [r7, #12]
 800e6a6:	2220      	movs	r2, #32
 800e6a8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800e6ac:	68fb      	ldr	r3, [r7, #12]
 800e6ae:	2200      	movs	r2, #0
 800e6b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800e6b4:	68fb      	ldr	r3, [r7, #12]
 800e6b6:	2200      	movs	r2, #0
 800e6b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800e6bc:	2300      	movs	r3, #0
 800e6be:	e000      	b.n	800e6c2 <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
 800e6c0:	2302      	movs	r3, #2
  }
}
 800e6c2:	4618      	mov	r0, r3
 800e6c4:	3718      	adds	r7, #24
 800e6c6:	46bd      	mov	sp, r7
 800e6c8:	bd80      	pop	{r7, pc}
 800e6ca:	bf00      	nop
 800e6cc:	80002400 	.word	0x80002400
 800e6d0:	fe00e800 	.word	0xfe00e800

0800e6d4 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800e6d4:	b580      	push	{r7, lr}
 800e6d6:	b088      	sub	sp, #32
 800e6d8:	af02      	add	r7, sp, #8
 800e6da:	60f8      	str	r0, [r7, #12]
 800e6dc:	4608      	mov	r0, r1
 800e6de:	4611      	mov	r1, r2
 800e6e0:	461a      	mov	r2, r3
 800e6e2:	4603      	mov	r3, r0
 800e6e4:	817b      	strh	r3, [r7, #10]
 800e6e6:	460b      	mov	r3, r1
 800e6e8:	813b      	strh	r3, [r7, #8]
 800e6ea:	4613      	mov	r3, r2
 800e6ec:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800e6ee:	68fb      	ldr	r3, [r7, #12]
 800e6f0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e6f4:	b2db      	uxtb	r3, r3
 800e6f6:	2b20      	cmp	r3, #32
 800e6f8:	f040 80f9 	bne.w	800e8ee <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
 800e6fc:	6a3b      	ldr	r3, [r7, #32]
 800e6fe:	2b00      	cmp	r3, #0
 800e700:	d002      	beq.n	800e708 <HAL_I2C_Mem_Write+0x34>
 800e702:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e704:	2b00      	cmp	r3, #0
 800e706:	d105      	bne.n	800e714 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800e708:	68fb      	ldr	r3, [r7, #12]
 800e70a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800e70e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 800e710:	2301      	movs	r3, #1
 800e712:	e0ed      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800e714:	68fb      	ldr	r3, [r7, #12]
 800e716:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800e71a:	2b01      	cmp	r3, #1
 800e71c:	d101      	bne.n	800e722 <HAL_I2C_Mem_Write+0x4e>
 800e71e:	2302      	movs	r3, #2
 800e720:	e0e6      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
 800e722:	68fb      	ldr	r3, [r7, #12]
 800e724:	2201      	movs	r2, #1
 800e726:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800e72a:	f7fe f9ad 	bl	800ca88 <HAL_GetTick>
 800e72e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800e730:	697b      	ldr	r3, [r7, #20]
 800e732:	9300      	str	r3, [sp, #0]
 800e734:	2319      	movs	r3, #25
 800e736:	2201      	movs	r2, #1
 800e738:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800e73c:	68f8      	ldr	r0, [r7, #12]
 800e73e:	f000 fadd 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e742:	4603      	mov	r3, r0
 800e744:	2b00      	cmp	r3, #0
 800e746:	d001      	beq.n	800e74c <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
 800e748:	2301      	movs	r3, #1
 800e74a:	e0d1      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800e74c:	68fb      	ldr	r3, [r7, #12]
 800e74e:	2221      	movs	r2, #33	; 0x21
 800e750:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800e754:	68fb      	ldr	r3, [r7, #12]
 800e756:	2240      	movs	r2, #64	; 0x40
 800e758:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800e75c:	68fb      	ldr	r3, [r7, #12]
 800e75e:	2200      	movs	r2, #0
 800e760:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800e762:	68fb      	ldr	r3, [r7, #12]
 800e764:	6a3a      	ldr	r2, [r7, #32]
 800e766:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800e768:	68fb      	ldr	r3, [r7, #12]
 800e76a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800e76c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800e76e:	68fb      	ldr	r3, [r7, #12]
 800e770:	2200      	movs	r2, #0
 800e772:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800e774:	88f8      	ldrh	r0, [r7, #6]
 800e776:	893a      	ldrh	r2, [r7, #8]
 800e778:	8979      	ldrh	r1, [r7, #10]
 800e77a:	697b      	ldr	r3, [r7, #20]
 800e77c:	9301      	str	r3, [sp, #4]
 800e77e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e780:	9300      	str	r3, [sp, #0]
 800e782:	4603      	mov	r3, r0
 800e784:	68f8      	ldr	r0, [r7, #12]
 800e786:	f000 f9ed 	bl	800eb64 <I2C_RequestMemoryWrite>
 800e78a:	4603      	mov	r3, r0
 800e78c:	2b00      	cmp	r3, #0
 800e78e:	d005      	beq.n	800e79c <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800e790:	68fb      	ldr	r3, [r7, #12]
 800e792:	2200      	movs	r2, #0
 800e794:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
 800e798:	2301      	movs	r3, #1
 800e79a:	e0a9      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e79c:	68fb      	ldr	r3, [r7, #12]
 800e79e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e7a0:	b29b      	uxth	r3, r3
 800e7a2:	2bff      	cmp	r3, #255	; 0xff
 800e7a4:	d90e      	bls.n	800e7c4 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800e7a6:	68fb      	ldr	r3, [r7, #12]
 800e7a8:	22ff      	movs	r2, #255	; 0xff
 800e7aa:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800e7ac:	68fb      	ldr	r3, [r7, #12]
 800e7ae:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e7b0:	b2da      	uxtb	r2, r3
 800e7b2:	8979      	ldrh	r1, [r7, #10]
 800e7b4:	2300      	movs	r3, #0
 800e7b6:	9300      	str	r3, [sp, #0]
 800e7b8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e7bc:	68f8      	ldr	r0, [r7, #12]
 800e7be:	f000 fc75 	bl	800f0ac <I2C_TransferConfig>
 800e7c2:	e00f      	b.n	800e7e4 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800e7c4:	68fb      	ldr	r3, [r7, #12]
 800e7c6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e7c8:	b29a      	uxth	r2, r3
 800e7ca:	68fb      	ldr	r3, [r7, #12]
 800e7cc:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800e7ce:	68fb      	ldr	r3, [r7, #12]
 800e7d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e7d2:	b2da      	uxtb	r2, r3
 800e7d4:	8979      	ldrh	r1, [r7, #10]
 800e7d6:	2300      	movs	r3, #0
 800e7d8:	9300      	str	r3, [sp, #0]
 800e7da:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e7de:	68f8      	ldr	r0, [r7, #12]
 800e7e0:	f000 fc64 	bl	800f0ac <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e7e4:	697a      	ldr	r2, [r7, #20]
 800e7e6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e7e8:	68f8      	ldr	r0, [r7, #12]
 800e7ea:	f000 fac7 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800e7ee:	4603      	mov	r3, r0
 800e7f0:	2b00      	cmp	r3, #0
 800e7f2:	d001      	beq.n	800e7f8 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
 800e7f4:	2301      	movs	r3, #1
 800e7f6:	e07b      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800e7f8:	68fb      	ldr	r3, [r7, #12]
 800e7fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e7fc:	781a      	ldrb	r2, [r3, #0]
 800e7fe:	68fb      	ldr	r3, [r7, #12]
 800e800:	681b      	ldr	r3, [r3, #0]
 800e802:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800e804:	68fb      	ldr	r3, [r7, #12]
 800e806:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e808:	1c5a      	adds	r2, r3, #1
 800e80a:	68fb      	ldr	r3, [r7, #12]
 800e80c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 800e80e:	68fb      	ldr	r3, [r7, #12]
 800e810:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e812:	b29b      	uxth	r3, r3
 800e814:	3b01      	subs	r3, #1
 800e816:	b29a      	uxth	r2, r3
 800e818:	68fb      	ldr	r3, [r7, #12]
 800e81a:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 800e81c:	68fb      	ldr	r3, [r7, #12]
 800e81e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e820:	3b01      	subs	r3, #1
 800e822:	b29a      	uxth	r2, r3
 800e824:	68fb      	ldr	r3, [r7, #12]
 800e826:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800e828:	68fb      	ldr	r3, [r7, #12]
 800e82a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e82c:	b29b      	uxth	r3, r3
 800e82e:	2b00      	cmp	r3, #0
 800e830:	d034      	beq.n	800e89c <HAL_I2C_Mem_Write+0x1c8>
 800e832:	68fb      	ldr	r3, [r7, #12]
 800e834:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e836:	2b00      	cmp	r3, #0
 800e838:	d130      	bne.n	800e89c <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800e83a:	697b      	ldr	r3, [r7, #20]
 800e83c:	9300      	str	r3, [sp, #0]
 800e83e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e840:	2200      	movs	r2, #0
 800e842:	2180      	movs	r1, #128	; 0x80
 800e844:	68f8      	ldr	r0, [r7, #12]
 800e846:	f000 fa59 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e84a:	4603      	mov	r3, r0
 800e84c:	2b00      	cmp	r3, #0
 800e84e:	d001      	beq.n	800e854 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
 800e850:	2301      	movs	r3, #1
 800e852:	e04d      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e854:	68fb      	ldr	r3, [r7, #12]
 800e856:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e858:	b29b      	uxth	r3, r3
 800e85a:	2bff      	cmp	r3, #255	; 0xff
 800e85c:	d90e      	bls.n	800e87c <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800e85e:	68fb      	ldr	r3, [r7, #12]
 800e860:	22ff      	movs	r2, #255	; 0xff
 800e862:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e864:	68fb      	ldr	r3, [r7, #12]
 800e866:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e868:	b2da      	uxtb	r2, r3
 800e86a:	8979      	ldrh	r1, [r7, #10]
 800e86c:	2300      	movs	r3, #0
 800e86e:	9300      	str	r3, [sp, #0]
 800e870:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e874:	68f8      	ldr	r0, [r7, #12]
 800e876:	f000 fc19 	bl	800f0ac <I2C_TransferConfig>
 800e87a:	e00f      	b.n	800e89c <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800e87c:	68fb      	ldr	r3, [r7, #12]
 800e87e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e880:	b29a      	uxth	r2, r3
 800e882:	68fb      	ldr	r3, [r7, #12]
 800e884:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e886:	68fb      	ldr	r3, [r7, #12]
 800e888:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e88a:	b2da      	uxtb	r2, r3
 800e88c:	8979      	ldrh	r1, [r7, #10]
 800e88e:	2300      	movs	r3, #0
 800e890:	9300      	str	r3, [sp, #0]
 800e892:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800e896:	68f8      	ldr	r0, [r7, #12]
 800e898:	f000 fc08 	bl	800f0ac <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
 800e89c:	68fb      	ldr	r3, [r7, #12]
 800e89e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e8a0:	b29b      	uxth	r3, r3
 800e8a2:	2b00      	cmp	r3, #0
 800e8a4:	d19e      	bne.n	800e7e4 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800e8a6:	697a      	ldr	r2, [r7, #20]
 800e8a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e8aa:	68f8      	ldr	r0, [r7, #12]
 800e8ac:	f000 faa6 	bl	800edfc <I2C_WaitOnSTOPFlagUntilTimeout>
 800e8b0:	4603      	mov	r3, r0
 800e8b2:	2b00      	cmp	r3, #0
 800e8b4:	d001      	beq.n	800e8ba <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
 800e8b6:	2301      	movs	r3, #1
 800e8b8:	e01a      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800e8ba:	68fb      	ldr	r3, [r7, #12]
 800e8bc:	681b      	ldr	r3, [r3, #0]
 800e8be:	2220      	movs	r2, #32
 800e8c0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800e8c2:	68fb      	ldr	r3, [r7, #12]
 800e8c4:	681b      	ldr	r3, [r3, #0]
 800e8c6:	6859      	ldr	r1, [r3, #4]
 800e8c8:	68fb      	ldr	r3, [r7, #12]
 800e8ca:	681a      	ldr	r2, [r3, #0]
 800e8cc:	4b0a      	ldr	r3, [pc, #40]	; (800e8f8 <HAL_I2C_Mem_Write+0x224>)
 800e8ce:	400b      	ands	r3, r1
 800e8d0:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800e8d2:	68fb      	ldr	r3, [r7, #12]
 800e8d4:	2220      	movs	r2, #32
 800e8d6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800e8da:	68fb      	ldr	r3, [r7, #12]
 800e8dc:	2200      	movs	r2, #0
 800e8de:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800e8e2:	68fb      	ldr	r3, [r7, #12]
 800e8e4:	2200      	movs	r2, #0
 800e8e6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800e8ea:	2300      	movs	r3, #0
 800e8ec:	e000      	b.n	800e8f0 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
 800e8ee:	2302      	movs	r3, #2
  }
}
 800e8f0:	4618      	mov	r0, r3
 800e8f2:	3718      	adds	r7, #24
 800e8f4:	46bd      	mov	sp, r7
 800e8f6:	bd80      	pop	{r7, pc}
 800e8f8:	fe00e800 	.word	0xfe00e800

0800e8fc <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800e8fc:	b580      	push	{r7, lr}
 800e8fe:	b088      	sub	sp, #32
 800e900:	af02      	add	r7, sp, #8
 800e902:	60f8      	str	r0, [r7, #12]
 800e904:	4608      	mov	r0, r1
 800e906:	4611      	mov	r1, r2
 800e908:	461a      	mov	r2, r3
 800e90a:	4603      	mov	r3, r0
 800e90c:	817b      	strh	r3, [r7, #10]
 800e90e:	460b      	mov	r3, r1
 800e910:	813b      	strh	r3, [r7, #8]
 800e912:	4613      	mov	r3, r2
 800e914:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800e916:	68fb      	ldr	r3, [r7, #12]
 800e918:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800e91c:	b2db      	uxtb	r3, r3
 800e91e:	2b20      	cmp	r3, #32
 800e920:	f040 80fd 	bne.w	800eb1e <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
 800e924:	6a3b      	ldr	r3, [r7, #32]
 800e926:	2b00      	cmp	r3, #0
 800e928:	d002      	beq.n	800e930 <HAL_I2C_Mem_Read+0x34>
 800e92a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d105      	bne.n	800e93c <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800e930:	68fb      	ldr	r3, [r7, #12]
 800e932:	f44f 7200 	mov.w	r2, #512	; 0x200
 800e936:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 800e938:	2301      	movs	r3, #1
 800e93a:	e0f1      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800e93c:	68fb      	ldr	r3, [r7, #12]
 800e93e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800e942:	2b01      	cmp	r3, #1
 800e944:	d101      	bne.n	800e94a <HAL_I2C_Mem_Read+0x4e>
 800e946:	2302      	movs	r3, #2
 800e948:	e0ea      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
 800e94a:	68fb      	ldr	r3, [r7, #12]
 800e94c:	2201      	movs	r2, #1
 800e94e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800e952:	f7fe f899 	bl	800ca88 <HAL_GetTick>
 800e956:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800e958:	697b      	ldr	r3, [r7, #20]
 800e95a:	9300      	str	r3, [sp, #0]
 800e95c:	2319      	movs	r3, #25
 800e95e:	2201      	movs	r2, #1
 800e960:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800e964:	68f8      	ldr	r0, [r7, #12]
 800e966:	f000 f9c9 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800e96a:	4603      	mov	r3, r0
 800e96c:	2b00      	cmp	r3, #0
 800e96e:	d001      	beq.n	800e974 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
 800e970:	2301      	movs	r3, #1
 800e972:	e0d5      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800e974:	68fb      	ldr	r3, [r7, #12]
 800e976:	2222      	movs	r2, #34	; 0x22
 800e978:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800e97c:	68fb      	ldr	r3, [r7, #12]
 800e97e:	2240      	movs	r2, #64	; 0x40
 800e980:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800e984:	68fb      	ldr	r3, [r7, #12]
 800e986:	2200      	movs	r2, #0
 800e988:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800e98a:	68fb      	ldr	r3, [r7, #12]
 800e98c:	6a3a      	ldr	r2, [r7, #32]
 800e98e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800e990:	68fb      	ldr	r3, [r7, #12]
 800e992:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800e994:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800e996:	68fb      	ldr	r3, [r7, #12]
 800e998:	2200      	movs	r2, #0
 800e99a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800e99c:	88f8      	ldrh	r0, [r7, #6]
 800e99e:	893a      	ldrh	r2, [r7, #8]
 800e9a0:	8979      	ldrh	r1, [r7, #10]
 800e9a2:	697b      	ldr	r3, [r7, #20]
 800e9a4:	9301      	str	r3, [sp, #4]
 800e9a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e9a8:	9300      	str	r3, [sp, #0]
 800e9aa:	4603      	mov	r3, r0
 800e9ac:	68f8      	ldr	r0, [r7, #12]
 800e9ae:	f000 f92d 	bl	800ec0c <I2C_RequestMemoryRead>
 800e9b2:	4603      	mov	r3, r0
 800e9b4:	2b00      	cmp	r3, #0
 800e9b6:	d005      	beq.n	800e9c4 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800e9b8:	68fb      	ldr	r3, [r7, #12]
 800e9ba:	2200      	movs	r2, #0
 800e9bc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
 800e9c0:	2301      	movs	r3, #1
 800e9c2:	e0ad      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800e9c4:	68fb      	ldr	r3, [r7, #12]
 800e9c6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e9c8:	b29b      	uxth	r3, r3
 800e9ca:	2bff      	cmp	r3, #255	; 0xff
 800e9cc:	d90e      	bls.n	800e9ec <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800e9ce:	68fb      	ldr	r3, [r7, #12]
 800e9d0:	22ff      	movs	r2, #255	; 0xff
 800e9d2:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 800e9d4:	68fb      	ldr	r3, [r7, #12]
 800e9d6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e9d8:	b2da      	uxtb	r2, r3
 800e9da:	8979      	ldrh	r1, [r7, #10]
 800e9dc:	4b52      	ldr	r3, [pc, #328]	; (800eb28 <HAL_I2C_Mem_Read+0x22c>)
 800e9de:	9300      	str	r3, [sp, #0]
 800e9e0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800e9e4:	68f8      	ldr	r0, [r7, #12]
 800e9e6:	f000 fb61 	bl	800f0ac <I2C_TransferConfig>
 800e9ea:	e00f      	b.n	800ea0c <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800e9ec:	68fb      	ldr	r3, [r7, #12]
 800e9ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800e9f0:	b29a      	uxth	r2, r3
 800e9f2:	68fb      	ldr	r3, [r7, #12]
 800e9f4:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800e9f6:	68fb      	ldr	r3, [r7, #12]
 800e9f8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800e9fa:	b2da      	uxtb	r2, r3
 800e9fc:	8979      	ldrh	r1, [r7, #10]
 800e9fe:	4b4a      	ldr	r3, [pc, #296]	; (800eb28 <HAL_I2C_Mem_Read+0x22c>)
 800ea00:	9300      	str	r3, [sp, #0]
 800ea02:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800ea06:	68f8      	ldr	r0, [r7, #12]
 800ea08:	f000 fb50 	bl	800f0ac <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 800ea0c:	697b      	ldr	r3, [r7, #20]
 800ea0e:	9300      	str	r3, [sp, #0]
 800ea10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ea12:	2200      	movs	r2, #0
 800ea14:	2104      	movs	r1, #4
 800ea16:	68f8      	ldr	r0, [r7, #12]
 800ea18:	f000 f970 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800ea1c:	4603      	mov	r3, r0
 800ea1e:	2b00      	cmp	r3, #0
 800ea20:	d001      	beq.n	800ea26 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
 800ea22:	2301      	movs	r3, #1
 800ea24:	e07c      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800ea26:	68fb      	ldr	r3, [r7, #12]
 800ea28:	681b      	ldr	r3, [r3, #0]
 800ea2a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ea2c:	68fb      	ldr	r3, [r7, #12]
 800ea2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ea30:	b2d2      	uxtb	r2, r2
 800ea32:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800ea34:	68fb      	ldr	r3, [r7, #12]
 800ea36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ea38:	1c5a      	adds	r2, r3, #1
 800ea3a:	68fb      	ldr	r3, [r7, #12]
 800ea3c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 800ea3e:	68fb      	ldr	r3, [r7, #12]
 800ea40:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ea42:	3b01      	subs	r3, #1
 800ea44:	b29a      	uxth	r2, r3
 800ea46:	68fb      	ldr	r3, [r7, #12]
 800ea48:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 800ea4a:	68fb      	ldr	r3, [r7, #12]
 800ea4c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ea4e:	b29b      	uxth	r3, r3
 800ea50:	3b01      	subs	r3, #1
 800ea52:	b29a      	uxth	r2, r3
 800ea54:	68fb      	ldr	r3, [r7, #12]
 800ea56:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800ea58:	68fb      	ldr	r3, [r7, #12]
 800ea5a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ea5c:	b29b      	uxth	r3, r3
 800ea5e:	2b00      	cmp	r3, #0
 800ea60:	d034      	beq.n	800eacc <HAL_I2C_Mem_Read+0x1d0>
 800ea62:	68fb      	ldr	r3, [r7, #12]
 800ea64:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ea66:	2b00      	cmp	r3, #0
 800ea68:	d130      	bne.n	800eacc <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800ea6a:	697b      	ldr	r3, [r7, #20]
 800ea6c:	9300      	str	r3, [sp, #0]
 800ea6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ea70:	2200      	movs	r2, #0
 800ea72:	2180      	movs	r1, #128	; 0x80
 800ea74:	68f8      	ldr	r0, [r7, #12]
 800ea76:	f000 f941 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800ea7a:	4603      	mov	r3, r0
 800ea7c:	2b00      	cmp	r3, #0
 800ea7e:	d001      	beq.n	800ea84 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
 800ea80:	2301      	movs	r3, #1
 800ea82:	e04d      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800ea84:	68fb      	ldr	r3, [r7, #12]
 800ea86:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ea88:	b29b      	uxth	r3, r3
 800ea8a:	2bff      	cmp	r3, #255	; 0xff
 800ea8c:	d90e      	bls.n	800eaac <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800ea8e:	68fb      	ldr	r3, [r7, #12]
 800ea90:	22ff      	movs	r2, #255	; 0xff
 800ea92:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
 800ea94:	68fb      	ldr	r3, [r7, #12]
 800ea96:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800ea98:	b2da      	uxtb	r2, r3
 800ea9a:	8979      	ldrh	r1, [r7, #10]
 800ea9c:	2300      	movs	r3, #0
 800ea9e:	9300      	str	r3, [sp, #0]
 800eaa0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800eaa4:	68f8      	ldr	r0, [r7, #12]
 800eaa6:	f000 fb01 	bl	800f0ac <I2C_TransferConfig>
 800eaaa:	e00f      	b.n	800eacc <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800eaac:	68fb      	ldr	r3, [r7, #12]
 800eaae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800eab0:	b29a      	uxth	r2, r3
 800eab2:	68fb      	ldr	r3, [r7, #12]
 800eab4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800eab6:	68fb      	ldr	r3, [r7, #12]
 800eab8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800eaba:	b2da      	uxtb	r2, r3
 800eabc:	8979      	ldrh	r1, [r7, #10]
 800eabe:	2300      	movs	r3, #0
 800eac0:	9300      	str	r3, [sp, #0]
 800eac2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800eac6:	68f8      	ldr	r0, [r7, #12]
 800eac8:	f000 faf0 	bl	800f0ac <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
 800eacc:	68fb      	ldr	r3, [r7, #12]
 800eace:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800ead0:	b29b      	uxth	r3, r3
 800ead2:	2b00      	cmp	r3, #0
 800ead4:	d19a      	bne.n	800ea0c <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800ead6:	697a      	ldr	r2, [r7, #20]
 800ead8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800eada:	68f8      	ldr	r0, [r7, #12]
 800eadc:	f000 f98e 	bl	800edfc <I2C_WaitOnSTOPFlagUntilTimeout>
 800eae0:	4603      	mov	r3, r0
 800eae2:	2b00      	cmp	r3, #0
 800eae4:	d001      	beq.n	800eaea <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
 800eae6:	2301      	movs	r3, #1
 800eae8:	e01a      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800eaea:	68fb      	ldr	r3, [r7, #12]
 800eaec:	681b      	ldr	r3, [r3, #0]
 800eaee:	2220      	movs	r2, #32
 800eaf0:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800eaf2:	68fb      	ldr	r3, [r7, #12]
 800eaf4:	681b      	ldr	r3, [r3, #0]
 800eaf6:	6859      	ldr	r1, [r3, #4]
 800eaf8:	68fb      	ldr	r3, [r7, #12]
 800eafa:	681a      	ldr	r2, [r3, #0]
 800eafc:	4b0b      	ldr	r3, [pc, #44]	; (800eb2c <HAL_I2C_Mem_Read+0x230>)
 800eafe:	400b      	ands	r3, r1
 800eb00:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800eb02:	68fb      	ldr	r3, [r7, #12]
 800eb04:	2220      	movs	r2, #32
 800eb06:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800eb0a:	68fb      	ldr	r3, [r7, #12]
 800eb0c:	2200      	movs	r2, #0
 800eb0e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800eb12:	68fb      	ldr	r3, [r7, #12]
 800eb14:	2200      	movs	r2, #0
 800eb16:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800eb1a:	2300      	movs	r3, #0
 800eb1c:	e000      	b.n	800eb20 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
 800eb1e:	2302      	movs	r3, #2
  }
}
 800eb20:	4618      	mov	r0, r3
 800eb22:	3718      	adds	r7, #24
 800eb24:	46bd      	mov	sp, r7
 800eb26:	bd80      	pop	{r7, pc}
 800eb28:	80002400 	.word	0x80002400
 800eb2c:	fe00e800 	.word	0xfe00e800

0800eb30 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 800eb30:	b580      	push	{r7, lr}
 800eb32:	b084      	sub	sp, #16
 800eb34:	af00      	add	r7, sp, #0
 800eb36:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800eb38:	687b      	ldr	r3, [r7, #4]
 800eb3a:	681b      	ldr	r3, [r3, #0]
 800eb3c:	699b      	ldr	r3, [r3, #24]
 800eb3e:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 800eb40:	687b      	ldr	r3, [r7, #4]
 800eb42:	681b      	ldr	r3, [r3, #0]
 800eb44:	681b      	ldr	r3, [r3, #0]
 800eb46:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
 800eb48:	687b      	ldr	r3, [r7, #4]
 800eb4a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800eb4c:	2b00      	cmp	r3, #0
 800eb4e:	d005      	beq.n	800eb5c <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
 800eb50:	687b      	ldr	r3, [r7, #4]
 800eb52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800eb54:	68ba      	ldr	r2, [r7, #8]
 800eb56:	68f9      	ldr	r1, [r7, #12]
 800eb58:	6878      	ldr	r0, [r7, #4]
 800eb5a:	4798      	blx	r3
  }
}
 800eb5c:	bf00      	nop
 800eb5e:	3710      	adds	r7, #16
 800eb60:	46bd      	mov	sp, r7
 800eb62:	bd80      	pop	{r7, pc}

0800eb64 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
 800eb64:	b580      	push	{r7, lr}
 800eb66:	b086      	sub	sp, #24
 800eb68:	af02      	add	r7, sp, #8
 800eb6a:	60f8      	str	r0, [r7, #12]
 800eb6c:	4608      	mov	r0, r1
 800eb6e:	4611      	mov	r1, r2
 800eb70:	461a      	mov	r2, r3
 800eb72:	4603      	mov	r3, r0
 800eb74:	817b      	strh	r3, [r7, #10]
 800eb76:	460b      	mov	r3, r1
 800eb78:	813b      	strh	r3, [r7, #8]
 800eb7a:	4613      	mov	r3, r2
 800eb7c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800eb7e:	88fb      	ldrh	r3, [r7, #6]
 800eb80:	b2da      	uxtb	r2, r3
 800eb82:	8979      	ldrh	r1, [r7, #10]
 800eb84:	4b20      	ldr	r3, [pc, #128]	; (800ec08 <I2C_RequestMemoryWrite+0xa4>)
 800eb86:	9300      	str	r3, [sp, #0]
 800eb88:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800eb8c:	68f8      	ldr	r0, [r7, #12]
 800eb8e:	f000 fa8d 	bl	800f0ac <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800eb92:	69fa      	ldr	r2, [r7, #28]
 800eb94:	69b9      	ldr	r1, [r7, #24]
 800eb96:	68f8      	ldr	r0, [r7, #12]
 800eb98:	f000 f8f0 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800eb9c:	4603      	mov	r3, r0
 800eb9e:	2b00      	cmp	r3, #0
 800eba0:	d001      	beq.n	800eba6 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
 800eba2:	2301      	movs	r3, #1
 800eba4:	e02c      	b.n	800ec00 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800eba6:	88fb      	ldrh	r3, [r7, #6]
 800eba8:	2b01      	cmp	r3, #1
 800ebaa:	d105      	bne.n	800ebb8 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800ebac:	893b      	ldrh	r3, [r7, #8]
 800ebae:	b2da      	uxtb	r2, r3
 800ebb0:	68fb      	ldr	r3, [r7, #12]
 800ebb2:	681b      	ldr	r3, [r3, #0]
 800ebb4:	629a      	str	r2, [r3, #40]	; 0x28
 800ebb6:	e015      	b.n	800ebe4 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800ebb8:	893b      	ldrh	r3, [r7, #8]
 800ebba:	0a1b      	lsrs	r3, r3, #8
 800ebbc:	b29b      	uxth	r3, r3
 800ebbe:	b2da      	uxtb	r2, r3
 800ebc0:	68fb      	ldr	r3, [r7, #12]
 800ebc2:	681b      	ldr	r3, [r3, #0]
 800ebc4:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800ebc6:	69fa      	ldr	r2, [r7, #28]
 800ebc8:	69b9      	ldr	r1, [r7, #24]
 800ebca:	68f8      	ldr	r0, [r7, #12]
 800ebcc:	f000 f8d6 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800ebd0:	4603      	mov	r3, r0
 800ebd2:	2b00      	cmp	r3, #0
 800ebd4:	d001      	beq.n	800ebda <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
 800ebd6:	2301      	movs	r3, #1
 800ebd8:	e012      	b.n	800ec00 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800ebda:	893b      	ldrh	r3, [r7, #8]
 800ebdc:	b2da      	uxtb	r2, r3
 800ebde:	68fb      	ldr	r3, [r7, #12]
 800ebe0:	681b      	ldr	r3, [r3, #0]
 800ebe2:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 800ebe4:	69fb      	ldr	r3, [r7, #28]
 800ebe6:	9300      	str	r3, [sp, #0]
 800ebe8:	69bb      	ldr	r3, [r7, #24]
 800ebea:	2200      	movs	r2, #0
 800ebec:	2180      	movs	r1, #128	; 0x80
 800ebee:	68f8      	ldr	r0, [r7, #12]
 800ebf0:	f000 f884 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800ebf4:	4603      	mov	r3, r0
 800ebf6:	2b00      	cmp	r3, #0
 800ebf8:	d001      	beq.n	800ebfe <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
 800ebfa:	2301      	movs	r3, #1
 800ebfc:	e000      	b.n	800ec00 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
 800ebfe:	2300      	movs	r3, #0
}
 800ec00:	4618      	mov	r0, r3
 800ec02:	3710      	adds	r7, #16
 800ec04:	46bd      	mov	sp, r7
 800ec06:	bd80      	pop	{r7, pc}
 800ec08:	80002000 	.word	0x80002000

0800ec0c <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
 800ec0c:	b580      	push	{r7, lr}
 800ec0e:	b086      	sub	sp, #24
 800ec10:	af02      	add	r7, sp, #8
 800ec12:	60f8      	str	r0, [r7, #12]
 800ec14:	4608      	mov	r0, r1
 800ec16:	4611      	mov	r1, r2
 800ec18:	461a      	mov	r2, r3
 800ec1a:	4603      	mov	r3, r0
 800ec1c:	817b      	strh	r3, [r7, #10]
 800ec1e:	460b      	mov	r3, r1
 800ec20:	813b      	strh	r3, [r7, #8]
 800ec22:	4613      	mov	r3, r2
 800ec24:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 800ec26:	88fb      	ldrh	r3, [r7, #6]
 800ec28:	b2da      	uxtb	r2, r3
 800ec2a:	8979      	ldrh	r1, [r7, #10]
 800ec2c:	4b20      	ldr	r3, [pc, #128]	; (800ecb0 <I2C_RequestMemoryRead+0xa4>)
 800ec2e:	9300      	str	r3, [sp, #0]
 800ec30:	2300      	movs	r3, #0
 800ec32:	68f8      	ldr	r0, [r7, #12]
 800ec34:	f000 fa3a 	bl	800f0ac <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800ec38:	69fa      	ldr	r2, [r7, #28]
 800ec3a:	69b9      	ldr	r1, [r7, #24]
 800ec3c:	68f8      	ldr	r0, [r7, #12]
 800ec3e:	f000 f89d 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800ec42:	4603      	mov	r3, r0
 800ec44:	2b00      	cmp	r3, #0
 800ec46:	d001      	beq.n	800ec4c <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
 800ec48:	2301      	movs	r3, #1
 800ec4a:	e02c      	b.n	800eca6 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800ec4c:	88fb      	ldrh	r3, [r7, #6]
 800ec4e:	2b01      	cmp	r3, #1
 800ec50:	d105      	bne.n	800ec5e <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800ec52:	893b      	ldrh	r3, [r7, #8]
 800ec54:	b2da      	uxtb	r2, r3
 800ec56:	68fb      	ldr	r3, [r7, #12]
 800ec58:	681b      	ldr	r3, [r3, #0]
 800ec5a:	629a      	str	r2, [r3, #40]	; 0x28
 800ec5c:	e015      	b.n	800ec8a <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 800ec5e:	893b      	ldrh	r3, [r7, #8]
 800ec60:	0a1b      	lsrs	r3, r3, #8
 800ec62:	b29b      	uxth	r3, r3
 800ec64:	b2da      	uxtb	r2, r3
 800ec66:	68fb      	ldr	r3, [r7, #12]
 800ec68:	681b      	ldr	r3, [r3, #0]
 800ec6a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800ec6c:	69fa      	ldr	r2, [r7, #28]
 800ec6e:	69b9      	ldr	r1, [r7, #24]
 800ec70:	68f8      	ldr	r0, [r7, #12]
 800ec72:	f000 f883 	bl	800ed7c <I2C_WaitOnTXISFlagUntilTimeout>
 800ec76:	4603      	mov	r3, r0
 800ec78:	2b00      	cmp	r3, #0
 800ec7a:	d001      	beq.n	800ec80 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
 800ec7c:	2301      	movs	r3, #1
 800ec7e:	e012      	b.n	800eca6 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800ec80:	893b      	ldrh	r3, [r7, #8]
 800ec82:	b2da      	uxtb	r2, r3
 800ec84:	68fb      	ldr	r3, [r7, #12]
 800ec86:	681b      	ldr	r3, [r3, #0]
 800ec88:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 800ec8a:	69fb      	ldr	r3, [r7, #28]
 800ec8c:	9300      	str	r3, [sp, #0]
 800ec8e:	69bb      	ldr	r3, [r7, #24]
 800ec90:	2200      	movs	r2, #0
 800ec92:	2140      	movs	r1, #64	; 0x40
 800ec94:	68f8      	ldr	r0, [r7, #12]
 800ec96:	f000 f831 	bl	800ecfc <I2C_WaitOnFlagUntilTimeout>
 800ec9a:	4603      	mov	r3, r0
 800ec9c:	2b00      	cmp	r3, #0
 800ec9e:	d001      	beq.n	800eca4 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
 800eca0:	2301      	movs	r3, #1
 800eca2:	e000      	b.n	800eca6 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
 800eca4:	2300      	movs	r3, #0
}
 800eca6:	4618      	mov	r0, r3
 800eca8:	3710      	adds	r7, #16
 800ecaa:	46bd      	mov	sp, r7
 800ecac:	bd80      	pop	{r7, pc}
 800ecae:	bf00      	nop
 800ecb0:	80002000 	.word	0x80002000

0800ecb4 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 800ecb4:	b480      	push	{r7}
 800ecb6:	b083      	sub	sp, #12
 800ecb8:	af00      	add	r7, sp, #0
 800ecba:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800ecbc:	687b      	ldr	r3, [r7, #4]
 800ecbe:	681b      	ldr	r3, [r3, #0]
 800ecc0:	699b      	ldr	r3, [r3, #24]
 800ecc2:	f003 0302 	and.w	r3, r3, #2
 800ecc6:	2b02      	cmp	r3, #2
 800ecc8:	d103      	bne.n	800ecd2 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 800ecca:	687b      	ldr	r3, [r7, #4]
 800eccc:	681b      	ldr	r3, [r3, #0]
 800ecce:	2200      	movs	r2, #0
 800ecd0:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800ecd2:	687b      	ldr	r3, [r7, #4]
 800ecd4:	681b      	ldr	r3, [r3, #0]
 800ecd6:	699b      	ldr	r3, [r3, #24]
 800ecd8:	f003 0301 	and.w	r3, r3, #1
 800ecdc:	2b01      	cmp	r3, #1
 800ecde:	d007      	beq.n	800ecf0 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800ece0:	687b      	ldr	r3, [r7, #4]
 800ece2:	681b      	ldr	r3, [r3, #0]
 800ece4:	699a      	ldr	r2, [r3, #24]
 800ece6:	687b      	ldr	r3, [r7, #4]
 800ece8:	681b      	ldr	r3, [r3, #0]
 800ecea:	f042 0201 	orr.w	r2, r2, #1
 800ecee:	619a      	str	r2, [r3, #24]
  }
}
 800ecf0:	bf00      	nop
 800ecf2:	370c      	adds	r7, #12
 800ecf4:	46bd      	mov	sp, r7
 800ecf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecfa:	4770      	bx	lr

0800ecfc <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 800ecfc:	b580      	push	{r7, lr}
 800ecfe:	b084      	sub	sp, #16
 800ed00:	af00      	add	r7, sp, #0
 800ed02:	60f8      	str	r0, [r7, #12]
 800ed04:	60b9      	str	r1, [r7, #8]
 800ed06:	603b      	str	r3, [r7, #0]
 800ed08:	4613      	mov	r3, r2
 800ed0a:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800ed0c:	e022      	b.n	800ed54 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ed0e:	683b      	ldr	r3, [r7, #0]
 800ed10:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ed14:	d01e      	beq.n	800ed54 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ed16:	f7fd feb7 	bl	800ca88 <HAL_GetTick>
 800ed1a:	4602      	mov	r2, r0
 800ed1c:	69bb      	ldr	r3, [r7, #24]
 800ed1e:	1ad3      	subs	r3, r2, r3
 800ed20:	683a      	ldr	r2, [r7, #0]
 800ed22:	429a      	cmp	r2, r3
 800ed24:	d302      	bcc.n	800ed2c <I2C_WaitOnFlagUntilTimeout+0x30>
 800ed26:	683b      	ldr	r3, [r7, #0]
 800ed28:	2b00      	cmp	r3, #0
 800ed2a:	d113      	bne.n	800ed54 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ed2c:	68fb      	ldr	r3, [r7, #12]
 800ed2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ed30:	f043 0220 	orr.w	r2, r3, #32
 800ed34:	68fb      	ldr	r3, [r7, #12]
 800ed36:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800ed38:	68fb      	ldr	r3, [r7, #12]
 800ed3a:	2220      	movs	r2, #32
 800ed3c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800ed40:	68fb      	ldr	r3, [r7, #12]
 800ed42:	2200      	movs	r2, #0
 800ed44:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800ed48:	68fb      	ldr	r3, [r7, #12]
 800ed4a:	2200      	movs	r2, #0
 800ed4c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
 800ed50:	2301      	movs	r3, #1
 800ed52:	e00f      	b.n	800ed74 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800ed54:	68fb      	ldr	r3, [r7, #12]
 800ed56:	681b      	ldr	r3, [r3, #0]
 800ed58:	699a      	ldr	r2, [r3, #24]
 800ed5a:	68bb      	ldr	r3, [r7, #8]
 800ed5c:	4013      	ands	r3, r2
 800ed5e:	68ba      	ldr	r2, [r7, #8]
 800ed60:	429a      	cmp	r2, r3
 800ed62:	bf0c      	ite	eq
 800ed64:	2301      	moveq	r3, #1
 800ed66:	2300      	movne	r3, #0
 800ed68:	b2db      	uxtb	r3, r3
 800ed6a:	461a      	mov	r2, r3
 800ed6c:	79fb      	ldrb	r3, [r7, #7]
 800ed6e:	429a      	cmp	r2, r3
 800ed70:	d0cd      	beq.n	800ed0e <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800ed72:	2300      	movs	r3, #0
}
 800ed74:	4618      	mov	r0, r3
 800ed76:	3710      	adds	r7, #16
 800ed78:	46bd      	mov	sp, r7
 800ed7a:	bd80      	pop	{r7, pc}

0800ed7c <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 800ed7c:	b580      	push	{r7, lr}
 800ed7e:	b084      	sub	sp, #16
 800ed80:	af00      	add	r7, sp, #0
 800ed82:	60f8      	str	r0, [r7, #12]
 800ed84:	60b9      	str	r1, [r7, #8]
 800ed86:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800ed88:	e02c      	b.n	800ede4 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 800ed8a:	687a      	ldr	r2, [r7, #4]
 800ed8c:	68b9      	ldr	r1, [r7, #8]
 800ed8e:	68f8      	ldr	r0, [r7, #12]
 800ed90:	f000 f8dc 	bl	800ef4c <I2C_IsErrorOccurred>
 800ed94:	4603      	mov	r3, r0
 800ed96:	2b00      	cmp	r3, #0
 800ed98:	d001      	beq.n	800ed9e <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800ed9a:	2301      	movs	r3, #1
 800ed9c:	e02a      	b.n	800edf4 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ed9e:	68bb      	ldr	r3, [r7, #8]
 800eda0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800eda4:	d01e      	beq.n	800ede4 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800eda6:	f7fd fe6f 	bl	800ca88 <HAL_GetTick>
 800edaa:	4602      	mov	r2, r0
 800edac:	687b      	ldr	r3, [r7, #4]
 800edae:	1ad3      	subs	r3, r2, r3
 800edb0:	68ba      	ldr	r2, [r7, #8]
 800edb2:	429a      	cmp	r2, r3
 800edb4:	d302      	bcc.n	800edbc <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 800edb6:	68bb      	ldr	r3, [r7, #8]
 800edb8:	2b00      	cmp	r3, #0
 800edba:	d113      	bne.n	800ede4 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800edbc:	68fb      	ldr	r3, [r7, #12]
 800edbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800edc0:	f043 0220 	orr.w	r2, r3, #32
 800edc4:	68fb      	ldr	r3, [r7, #12]
 800edc6:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800edc8:	68fb      	ldr	r3, [r7, #12]
 800edca:	2220      	movs	r2, #32
 800edcc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800edd0:	68fb      	ldr	r3, [r7, #12]
 800edd2:	2200      	movs	r2, #0
 800edd4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800edd8:	68fb      	ldr	r3, [r7, #12]
 800edda:	2200      	movs	r2, #0
 800eddc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
 800ede0:	2301      	movs	r3, #1
 800ede2:	e007      	b.n	800edf4 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800ede4:	68fb      	ldr	r3, [r7, #12]
 800ede6:	681b      	ldr	r3, [r3, #0]
 800ede8:	699b      	ldr	r3, [r3, #24]
 800edea:	f003 0302 	and.w	r3, r3, #2
 800edee:	2b02      	cmp	r3, #2
 800edf0:	d1cb      	bne.n	800ed8a <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 800edf2:	2300      	movs	r3, #0
}
 800edf4:	4618      	mov	r0, r3
 800edf6:	3710      	adds	r7, #16
 800edf8:	46bd      	mov	sp, r7
 800edfa:	bd80      	pop	{r7, pc}

0800edfc <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 800edfc:	b580      	push	{r7, lr}
 800edfe:	b084      	sub	sp, #16
 800ee00:	af00      	add	r7, sp, #0
 800ee02:	60f8      	str	r0, [r7, #12]
 800ee04:	60b9      	str	r1, [r7, #8]
 800ee06:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800ee08:	e028      	b.n	800ee5c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 800ee0a:	687a      	ldr	r2, [r7, #4]
 800ee0c:	68b9      	ldr	r1, [r7, #8]
 800ee0e:	68f8      	ldr	r0, [r7, #12]
 800ee10:	f000 f89c 	bl	800ef4c <I2C_IsErrorOccurred>
 800ee14:	4603      	mov	r3, r0
 800ee16:	2b00      	cmp	r3, #0
 800ee18:	d001      	beq.n	800ee1e <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800ee1a:	2301      	movs	r3, #1
 800ee1c:	e026      	b.n	800ee6c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ee1e:	f7fd fe33 	bl	800ca88 <HAL_GetTick>
 800ee22:	4602      	mov	r2, r0
 800ee24:	687b      	ldr	r3, [r7, #4]
 800ee26:	1ad3      	subs	r3, r2, r3
 800ee28:	68ba      	ldr	r2, [r7, #8]
 800ee2a:	429a      	cmp	r2, r3
 800ee2c:	d302      	bcc.n	800ee34 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 800ee2e:	68bb      	ldr	r3, [r7, #8]
 800ee30:	2b00      	cmp	r3, #0
 800ee32:	d113      	bne.n	800ee5c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ee34:	68fb      	ldr	r3, [r7, #12]
 800ee36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ee38:	f043 0220 	orr.w	r2, r3, #32
 800ee3c:	68fb      	ldr	r3, [r7, #12]
 800ee3e:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800ee40:	68fb      	ldr	r3, [r7, #12]
 800ee42:	2220      	movs	r2, #32
 800ee44:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800ee48:	68fb      	ldr	r3, [r7, #12]
 800ee4a:	2200      	movs	r2, #0
 800ee4c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800ee50:	68fb      	ldr	r3, [r7, #12]
 800ee52:	2200      	movs	r2, #0
 800ee54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 800ee58:	2301      	movs	r3, #1
 800ee5a:	e007      	b.n	800ee6c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800ee5c:	68fb      	ldr	r3, [r7, #12]
 800ee5e:	681b      	ldr	r3, [r3, #0]
 800ee60:	699b      	ldr	r3, [r3, #24]
 800ee62:	f003 0320 	and.w	r3, r3, #32
 800ee66:	2b20      	cmp	r3, #32
 800ee68:	d1cf      	bne.n	800ee0a <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 800ee6a:	2300      	movs	r3, #0
}
 800ee6c:	4618      	mov	r0, r3
 800ee6e:	3710      	adds	r7, #16
 800ee70:	46bd      	mov	sp, r7
 800ee72:	bd80      	pop	{r7, pc}

0800ee74 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 800ee74:	b580      	push	{r7, lr}
 800ee76:	b084      	sub	sp, #16
 800ee78:	af00      	add	r7, sp, #0
 800ee7a:	60f8      	str	r0, [r7, #12]
 800ee7c:	60b9      	str	r1, [r7, #8]
 800ee7e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800ee80:	e055      	b.n	800ef2e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 800ee82:	687a      	ldr	r2, [r7, #4]
 800ee84:	68b9      	ldr	r1, [r7, #8]
 800ee86:	68f8      	ldr	r0, [r7, #12]
 800ee88:	f000 f860 	bl	800ef4c <I2C_IsErrorOccurred>
 800ee8c:	4603      	mov	r3, r0
 800ee8e:	2b00      	cmp	r3, #0
 800ee90:	d001      	beq.n	800ee96 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 800ee92:	2301      	movs	r3, #1
 800ee94:	e053      	b.n	800ef3e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 800ee96:	68fb      	ldr	r3, [r7, #12]
 800ee98:	681b      	ldr	r3, [r3, #0]
 800ee9a:	699b      	ldr	r3, [r3, #24]
 800ee9c:	f003 0320 	and.w	r3, r3, #32
 800eea0:	2b20      	cmp	r3, #32
 800eea2:	d129      	bne.n	800eef8 <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 800eea4:	68fb      	ldr	r3, [r7, #12]
 800eea6:	681b      	ldr	r3, [r3, #0]
 800eea8:	699b      	ldr	r3, [r3, #24]
 800eeaa:	f003 0304 	and.w	r3, r3, #4
 800eeae:	2b04      	cmp	r3, #4
 800eeb0:	d105      	bne.n	800eebe <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
 800eeb2:	68fb      	ldr	r3, [r7, #12]
 800eeb4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800eeb6:	2b00      	cmp	r3, #0
 800eeb8:	d001      	beq.n	800eebe <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
 800eeba:	2300      	movs	r3, #0
 800eebc:	e03f      	b.n	800ef3e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800eebe:	68fb      	ldr	r3, [r7, #12]
 800eec0:	681b      	ldr	r3, [r3, #0]
 800eec2:	2220      	movs	r2, #32
 800eec4:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 800eec6:	68fb      	ldr	r3, [r7, #12]
 800eec8:	681b      	ldr	r3, [r3, #0]
 800eeca:	6859      	ldr	r1, [r3, #4]
 800eecc:	68fb      	ldr	r3, [r7, #12]
 800eece:	681a      	ldr	r2, [r3, #0]
 800eed0:	4b1d      	ldr	r3, [pc, #116]	; (800ef48 <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
 800eed2:	400b      	ands	r3, r1
 800eed4:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800eed6:	68fb      	ldr	r3, [r7, #12]
 800eed8:	2200      	movs	r2, #0
 800eeda:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800eedc:	68fb      	ldr	r3, [r7, #12]
 800eede:	2220      	movs	r2, #32
 800eee0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800eee4:	68fb      	ldr	r3, [r7, #12]
 800eee6:	2200      	movs	r2, #0
 800eee8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800eeec:	68fb      	ldr	r3, [r7, #12]
 800eeee:	2200      	movs	r2, #0
 800eef0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
 800eef4:	2301      	movs	r3, #1
 800eef6:	e022      	b.n	800ef3e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800eef8:	f7fd fdc6 	bl	800ca88 <HAL_GetTick>
 800eefc:	4602      	mov	r2, r0
 800eefe:	687b      	ldr	r3, [r7, #4]
 800ef00:	1ad3      	subs	r3, r2, r3
 800ef02:	68ba      	ldr	r2, [r7, #8]
 800ef04:	429a      	cmp	r2, r3
 800ef06:	d302      	bcc.n	800ef0e <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
 800ef08:	68bb      	ldr	r3, [r7, #8]
 800ef0a:	2b00      	cmp	r3, #0
 800ef0c:	d10f      	bne.n	800ef2e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ef0e:	68fb      	ldr	r3, [r7, #12]
 800ef10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ef12:	f043 0220 	orr.w	r2, r3, #32
 800ef16:	68fb      	ldr	r3, [r7, #12]
 800ef18:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800ef1a:	68fb      	ldr	r3, [r7, #12]
 800ef1c:	2220      	movs	r2, #32
 800ef1e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800ef22:	68fb      	ldr	r3, [r7, #12]
 800ef24:	2200      	movs	r2, #0
 800ef26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 800ef2a:	2301      	movs	r3, #1
 800ef2c:	e007      	b.n	800ef3e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800ef2e:	68fb      	ldr	r3, [r7, #12]
 800ef30:	681b      	ldr	r3, [r3, #0]
 800ef32:	699b      	ldr	r3, [r3, #24]
 800ef34:	f003 0304 	and.w	r3, r3, #4
 800ef38:	2b04      	cmp	r3, #4
 800ef3a:	d1a2      	bne.n	800ee82 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 800ef3c:	2300      	movs	r3, #0
}
 800ef3e:	4618      	mov	r0, r3
 800ef40:	3710      	adds	r7, #16
 800ef42:	46bd      	mov	sp, r7
 800ef44:	bd80      	pop	{r7, pc}
 800ef46:	bf00      	nop
 800ef48:	fe00e800 	.word	0xfe00e800

0800ef4c <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800ef4c:	b580      	push	{r7, lr}
 800ef4e:	b088      	sub	sp, #32
 800ef50:	af00      	add	r7, sp, #0
 800ef52:	60f8      	str	r0, [r7, #12]
 800ef54:	60b9      	str	r1, [r7, #8]
 800ef56:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800ef58:	2300      	movs	r3, #0
 800ef5a:	77fb      	strb	r3, [r7, #31]
  uint32_t itflag   = hi2c->Instance->ISR;
 800ef5c:	68fb      	ldr	r3, [r7, #12]
 800ef5e:	681b      	ldr	r3, [r3, #0]
 800ef60:	699b      	ldr	r3, [r3, #24]
 800ef62:	617b      	str	r3, [r7, #20]
  uint32_t error_code = 0;
 800ef64:	2300      	movs	r3, #0
 800ef66:	61bb      	str	r3, [r7, #24]

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 800ef68:	697b      	ldr	r3, [r7, #20]
 800ef6a:	f003 0310 	and.w	r3, r3, #16
 800ef6e:	2b00      	cmp	r3, #0
 800ef70:	d040      	beq.n	800eff4 <I2C_IsErrorOccurred+0xa8>
  {
    /* In case of Soft End condition, generate the STOP condition */
    if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 800ef72:	68fb      	ldr	r3, [r7, #12]
 800ef74:	681b      	ldr	r3, [r3, #0]
 800ef76:	685b      	ldr	r3, [r3, #4]
 800ef78:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800ef7c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800ef80:	d01d      	beq.n	800efbe <I2C_IsErrorOccurred+0x72>
    {
      /* Generate Stop */
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
 800ef82:	68fb      	ldr	r3, [r7, #12]
 800ef84:	681b      	ldr	r3, [r3, #0]
 800ef86:	685a      	ldr	r2, [r3, #4]
 800ef88:	68fb      	ldr	r3, [r7, #12]
 800ef8a:	681b      	ldr	r3, [r3, #0]
 800ef8c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800ef90:	605a      	str	r2, [r3, #4]
    }

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 800ef92:	e014      	b.n	800efbe <I2C_IsErrorOccurred+0x72>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 800ef94:	68bb      	ldr	r3, [r7, #8]
 800ef96:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ef9a:	d010      	beq.n	800efbe <I2C_IsErrorOccurred+0x72>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ef9c:	f7fd fd74 	bl	800ca88 <HAL_GetTick>
 800efa0:	4602      	mov	r2, r0
 800efa2:	687b      	ldr	r3, [r7, #4]
 800efa4:	1ad3      	subs	r3, r2, r3
 800efa6:	68ba      	ldr	r2, [r7, #8]
 800efa8:	429a      	cmp	r2, r3
 800efaa:	d302      	bcc.n	800efb2 <I2C_IsErrorOccurred+0x66>
 800efac:	68bb      	ldr	r3, [r7, #8]
 800efae:	2b00      	cmp	r3, #0
 800efb0:	d105      	bne.n	800efbe <I2C_IsErrorOccurred+0x72>
        {
          error_code |= HAL_I2C_ERROR_TIMEOUT;
 800efb2:	69bb      	ldr	r3, [r7, #24]
 800efb4:	f043 0320 	orr.w	r3, r3, #32
 800efb8:	61bb      	str	r3, [r7, #24]

          status = HAL_ERROR;
 800efba:	2301      	movs	r3, #1
 800efbc:	77fb      	strb	r3, [r7, #31]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 800efbe:	68fb      	ldr	r3, [r7, #12]
 800efc0:	681b      	ldr	r3, [r3, #0]
 800efc2:	699b      	ldr	r3, [r3, #24]
 800efc4:	f003 0320 	and.w	r3, r3, #32
 800efc8:	2b20      	cmp	r3, #32
 800efca:	d002      	beq.n	800efd2 <I2C_IsErrorOccurred+0x86>
 800efcc:	7ffb      	ldrb	r3, [r7, #31]
 800efce:	2b00      	cmp	r3, #0
 800efd0:	d0e0      	beq.n	800ef94 <I2C_IsErrorOccurred+0x48>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
 800efd2:	7ffb      	ldrb	r3, [r7, #31]
 800efd4:	2b00      	cmp	r3, #0
 800efd6:	d103      	bne.n	800efe0 <I2C_IsErrorOccurred+0x94>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800efd8:	68fb      	ldr	r3, [r7, #12]
 800efda:	681b      	ldr	r3, [r3, #0]
 800efdc:	2220      	movs	r2, #32
 800efde:	61da      	str	r2, [r3, #28]
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800efe0:	68fb      	ldr	r3, [r7, #12]
 800efe2:	681b      	ldr	r3, [r3, #0]
 800efe4:	2210      	movs	r2, #16
 800efe6:	61da      	str	r2, [r3, #28]

    error_code |= HAL_I2C_ERROR_AF;
 800efe8:	69bb      	ldr	r3, [r7, #24]
 800efea:	f043 0304 	orr.w	r3, r3, #4
 800efee:	61bb      	str	r3, [r7, #24]

    status = HAL_ERROR;
 800eff0:	2301      	movs	r3, #1
 800eff2:	77fb      	strb	r3, [r7, #31]
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 800eff4:	68fb      	ldr	r3, [r7, #12]
 800eff6:	681b      	ldr	r3, [r3, #0]
 800eff8:	699b      	ldr	r3, [r3, #24]
 800effa:	617b      	str	r3, [r7, #20]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 800effc:	697b      	ldr	r3, [r7, #20]
 800effe:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800f002:	2b00      	cmp	r3, #0
 800f004:	d00a      	beq.n	800f01c <I2C_IsErrorOccurred+0xd0>
  {
    error_code |= HAL_I2C_ERROR_BERR;
 800f006:	69bb      	ldr	r3, [r7, #24]
 800f008:	f043 0301 	orr.w	r3, r3, #1
 800f00c:	61bb      	str	r3, [r7, #24]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800f00e:	68fb      	ldr	r3, [r7, #12]
 800f010:	681b      	ldr	r3, [r3, #0]
 800f012:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f016:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 800f018:	2301      	movs	r3, #1
 800f01a:	77fb      	strb	r3, [r7, #31]
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 800f01c:	697b      	ldr	r3, [r7, #20]
 800f01e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800f022:	2b00      	cmp	r3, #0
 800f024:	d00a      	beq.n	800f03c <I2C_IsErrorOccurred+0xf0>
  {
    error_code |= HAL_I2C_ERROR_OVR;
 800f026:	69bb      	ldr	r3, [r7, #24]
 800f028:	f043 0308 	orr.w	r3, r3, #8
 800f02c:	61bb      	str	r3, [r7, #24]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800f02e:	68fb      	ldr	r3, [r7, #12]
 800f030:	681b      	ldr	r3, [r3, #0]
 800f032:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f036:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 800f038:	2301      	movs	r3, #1
 800f03a:	77fb      	strb	r3, [r7, #31]
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 800f03c:	697b      	ldr	r3, [r7, #20]
 800f03e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800f042:	2b00      	cmp	r3, #0
 800f044:	d00a      	beq.n	800f05c <I2C_IsErrorOccurred+0x110>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
 800f046:	69bb      	ldr	r3, [r7, #24]
 800f048:	f043 0302 	orr.w	r3, r3, #2
 800f04c:	61bb      	str	r3, [r7, #24]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 800f04e:	68fb      	ldr	r3, [r7, #12]
 800f050:	681b      	ldr	r3, [r3, #0]
 800f052:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f056:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 800f058:	2301      	movs	r3, #1
 800f05a:	77fb      	strb	r3, [r7, #31]
  }

  if (status != HAL_OK)
 800f05c:	7ffb      	ldrb	r3, [r7, #31]
 800f05e:	2b00      	cmp	r3, #0
 800f060:	d01c      	beq.n	800f09c <I2C_IsErrorOccurred+0x150>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 800f062:	68f8      	ldr	r0, [r7, #12]
 800f064:	f7ff fe26 	bl	800ecb4 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800f068:	68fb      	ldr	r3, [r7, #12]
 800f06a:	681b      	ldr	r3, [r3, #0]
 800f06c:	6859      	ldr	r1, [r3, #4]
 800f06e:	68fb      	ldr	r3, [r7, #12]
 800f070:	681a      	ldr	r2, [r3, #0]
 800f072:	4b0d      	ldr	r3, [pc, #52]	; (800f0a8 <I2C_IsErrorOccurred+0x15c>)
 800f074:	400b      	ands	r3, r1
 800f076:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
 800f078:	68fb      	ldr	r3, [r7, #12]
 800f07a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800f07c:	69bb      	ldr	r3, [r7, #24]
 800f07e:	431a      	orrs	r2, r3
 800f080:	68fb      	ldr	r3, [r7, #12]
 800f082:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800f084:	68fb      	ldr	r3, [r7, #12]
 800f086:	2220      	movs	r2, #32
 800f088:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800f08c:	68fb      	ldr	r3, [r7, #12]
 800f08e:	2200      	movs	r2, #0
 800f090:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800f094:	68fb      	ldr	r3, [r7, #12]
 800f096:	2200      	movs	r2, #0
 800f098:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
 800f09c:	7ffb      	ldrb	r3, [r7, #31]
}
 800f09e:	4618      	mov	r0, r3
 800f0a0:	3720      	adds	r7, #32
 800f0a2:	46bd      	mov	sp, r7
 800f0a4:	bd80      	pop	{r7, pc}
 800f0a6:	bf00      	nop
 800f0a8:	fe00e800 	.word	0xfe00e800

0800f0ac <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 800f0ac:	b480      	push	{r7}
 800f0ae:	b087      	sub	sp, #28
 800f0b0:	af00      	add	r7, sp, #0
 800f0b2:	60f8      	str	r0, [r7, #12]
 800f0b4:	607b      	str	r3, [r7, #4]
 800f0b6:	460b      	mov	r3, r1
 800f0b8:	817b      	strh	r3, [r7, #10]
 800f0ba:	4613      	mov	r3, r2
 800f0bc:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800f0be:	897b      	ldrh	r3, [r7, #10]
 800f0c0:	f3c3 0209 	ubfx	r2, r3, #0, #10
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 800f0c4:	7a7b      	ldrb	r3, [r7, #9]
 800f0c6:	041b      	lsls	r3, r3, #16
 800f0c8:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800f0cc:	431a      	orrs	r2, r3
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 800f0ce:	687b      	ldr	r3, [r7, #4]
 800f0d0:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800f0d2:	6a3b      	ldr	r3, [r7, #32]
 800f0d4:	4313      	orrs	r3, r2
 800f0d6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800f0da:	617b      	str	r3, [r7, #20]
                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 800f0dc:	68fb      	ldr	r3, [r7, #12]
 800f0de:	681b      	ldr	r3, [r3, #0]
 800f0e0:	685a      	ldr	r2, [r3, #4]
 800f0e2:	6a3b      	ldr	r3, [r7, #32]
 800f0e4:	0d5b      	lsrs	r3, r3, #21
 800f0e6:	f403 6180 	and.w	r1, r3, #1024	; 0x400
 800f0ea:	4b08      	ldr	r3, [pc, #32]	; (800f10c <I2C_TransferConfig+0x60>)
 800f0ec:	430b      	orrs	r3, r1
 800f0ee:	43db      	mvns	r3, r3
 800f0f0:	ea02 0103 	and.w	r1, r2, r3
 800f0f4:	68fb      	ldr	r3, [r7, #12]
 800f0f6:	681b      	ldr	r3, [r3, #0]
 800f0f8:	697a      	ldr	r2, [r7, #20]
 800f0fa:	430a      	orrs	r2, r1
 800f0fc:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
                I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 800f0fe:	bf00      	nop
 800f100:	371c      	adds	r7, #28
 800f102:	46bd      	mov	sp, r7
 800f104:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f108:	4770      	bx	lr
 800f10a:	bf00      	nop
 800f10c:	03ff63ff 	.word	0x03ff63ff

0800f110 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800f110:	b480      	push	{r7}
 800f112:	b083      	sub	sp, #12
 800f114:	af00      	add	r7, sp, #0
 800f116:	6078      	str	r0, [r7, #4]
 800f118:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800f11a:	687b      	ldr	r3, [r7, #4]
 800f11c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800f120:	b2db      	uxtb	r3, r3
 800f122:	2b20      	cmp	r3, #32
 800f124:	d138      	bne.n	800f198 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800f126:	687b      	ldr	r3, [r7, #4]
 800f128:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800f12c:	2b01      	cmp	r3, #1
 800f12e:	d101      	bne.n	800f134 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 800f130:	2302      	movs	r3, #2
 800f132:	e032      	b.n	800f19a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 800f134:	687b      	ldr	r3, [r7, #4]
 800f136:	2201      	movs	r2, #1
 800f138:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800f13c:	687b      	ldr	r3, [r7, #4]
 800f13e:	2224      	movs	r2, #36	; 0x24
 800f140:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800f144:	687b      	ldr	r3, [r7, #4]
 800f146:	681b      	ldr	r3, [r3, #0]
 800f148:	681a      	ldr	r2, [r3, #0]
 800f14a:	687b      	ldr	r3, [r7, #4]
 800f14c:	681b      	ldr	r3, [r3, #0]
 800f14e:	f022 0201 	bic.w	r2, r2, #1
 800f152:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800f154:	687b      	ldr	r3, [r7, #4]
 800f156:	681b      	ldr	r3, [r3, #0]
 800f158:	681a      	ldr	r2, [r3, #0]
 800f15a:	687b      	ldr	r3, [r7, #4]
 800f15c:	681b      	ldr	r3, [r3, #0]
 800f15e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800f162:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 800f164:	687b      	ldr	r3, [r7, #4]
 800f166:	681b      	ldr	r3, [r3, #0]
 800f168:	6819      	ldr	r1, [r3, #0]
 800f16a:	687b      	ldr	r3, [r7, #4]
 800f16c:	681b      	ldr	r3, [r3, #0]
 800f16e:	683a      	ldr	r2, [r7, #0]
 800f170:	430a      	orrs	r2, r1
 800f172:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800f174:	687b      	ldr	r3, [r7, #4]
 800f176:	681b      	ldr	r3, [r3, #0]
 800f178:	681a      	ldr	r2, [r3, #0]
 800f17a:	687b      	ldr	r3, [r7, #4]
 800f17c:	681b      	ldr	r3, [r3, #0]
 800f17e:	f042 0201 	orr.w	r2, r2, #1
 800f182:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800f184:	687b      	ldr	r3, [r7, #4]
 800f186:	2220      	movs	r2, #32
 800f188:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800f18c:	687b      	ldr	r3, [r7, #4]
 800f18e:	2200      	movs	r2, #0
 800f190:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800f194:	2300      	movs	r3, #0
 800f196:	e000      	b.n	800f19a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 800f198:	2302      	movs	r3, #2
  }
}
 800f19a:	4618      	mov	r0, r3
 800f19c:	370c      	adds	r7, #12
 800f19e:	46bd      	mov	sp, r7
 800f1a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1a4:	4770      	bx	lr

0800f1a6 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800f1a6:	b480      	push	{r7}
 800f1a8:	b085      	sub	sp, #20
 800f1aa:	af00      	add	r7, sp, #0
 800f1ac:	6078      	str	r0, [r7, #4]
 800f1ae:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800f1b0:	687b      	ldr	r3, [r7, #4]
 800f1b2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800f1b6:	b2db      	uxtb	r3, r3
 800f1b8:	2b20      	cmp	r3, #32
 800f1ba:	d139      	bne.n	800f230 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800f1bc:	687b      	ldr	r3, [r7, #4]
 800f1be:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800f1c2:	2b01      	cmp	r3, #1
 800f1c4:	d101      	bne.n	800f1ca <HAL_I2CEx_ConfigDigitalFilter+0x24>
 800f1c6:	2302      	movs	r3, #2
 800f1c8:	e033      	b.n	800f232 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 800f1ca:	687b      	ldr	r3, [r7, #4]
 800f1cc:	2201      	movs	r2, #1
 800f1ce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800f1d2:	687b      	ldr	r3, [r7, #4]
 800f1d4:	2224      	movs	r2, #36	; 0x24
 800f1d6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800f1da:	687b      	ldr	r3, [r7, #4]
 800f1dc:	681b      	ldr	r3, [r3, #0]
 800f1de:	681a      	ldr	r2, [r3, #0]
 800f1e0:	687b      	ldr	r3, [r7, #4]
 800f1e2:	681b      	ldr	r3, [r3, #0]
 800f1e4:	f022 0201 	bic.w	r2, r2, #1
 800f1e8:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 800f1ea:	687b      	ldr	r3, [r7, #4]
 800f1ec:	681b      	ldr	r3, [r3, #0]
 800f1ee:	681b      	ldr	r3, [r3, #0]
 800f1f0:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800f1f2:	68fb      	ldr	r3, [r7, #12]
 800f1f4:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800f1f8:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800f1fa:	683b      	ldr	r3, [r7, #0]
 800f1fc:	021b      	lsls	r3, r3, #8
 800f1fe:	68fa      	ldr	r2, [r7, #12]
 800f200:	4313      	orrs	r3, r2
 800f202:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 800f204:	687b      	ldr	r3, [r7, #4]
 800f206:	681b      	ldr	r3, [r3, #0]
 800f208:	68fa      	ldr	r2, [r7, #12]
 800f20a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800f20c:	687b      	ldr	r3, [r7, #4]
 800f20e:	681b      	ldr	r3, [r3, #0]
 800f210:	681a      	ldr	r2, [r3, #0]
 800f212:	687b      	ldr	r3, [r7, #4]
 800f214:	681b      	ldr	r3, [r3, #0]
 800f216:	f042 0201 	orr.w	r2, r2, #1
 800f21a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800f21c:	687b      	ldr	r3, [r7, #4]
 800f21e:	2220      	movs	r2, #32
 800f220:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800f224:	687b      	ldr	r3, [r7, #4]
 800f226:	2200      	movs	r2, #0
 800f228:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 800f22c:	2300      	movs	r3, #0
 800f22e:	e000      	b.n	800f232 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 800f230:	2302      	movs	r3, #2
  }
}
 800f232:	4618      	mov	r0, r3
 800f234:	3714      	adds	r7, #20
 800f236:	46bd      	mov	sp, r7
 800f238:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f23c:	4770      	bx	lr
	...

0800f240 <HAL_IPCC_Init>:
  * @brief  Initialize the IPCC peripheral.
  * @param  hipcc IPCC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IPCC_Init(IPCC_HandleTypeDef *hipcc)
{
 800f240:	b580      	push	{r7, lr}
 800f242:	b084      	sub	sp, #16
 800f244:	af00      	add	r7, sp, #0
 800f246:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef err = HAL_OK;
 800f248:	2300      	movs	r3, #0
 800f24a:	73fb      	strb	r3, [r7, #15]

  /* Check the IPCC handle allocation */
  if (hipcc != NULL)
 800f24c:	687b      	ldr	r3, [r7, #4]
 800f24e:	2b00      	cmp	r3, #0
 800f250:	d01e      	beq.n	800f290 <HAL_IPCC_Init+0x50>
  {
    /* Check the parameters */
    assert_param(IS_IPCC_ALL_INSTANCE(hipcc->Instance));

    IPCC_CommonTypeDef *currentInstance = IPCC_C1;
 800f252:	4b13      	ldr	r3, [pc, #76]	; (800f2a0 <HAL_IPCC_Init+0x60>)
 800f254:	60bb      	str	r3, [r7, #8]

    if (hipcc->State == HAL_IPCC_STATE_RESET)
 800f256:	687b      	ldr	r3, [r7, #4]
 800f258:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800f25c:	b2db      	uxtb	r3, r3
 800f25e:	2b00      	cmp	r3, #0
 800f260:	d102      	bne.n	800f268 <HAL_IPCC_Init+0x28>
    {
      /* Init the low level hardware : CLOCK, NVIC */
      HAL_IPCC_MspInit(hipcc);
 800f262:	6878      	ldr	r0, [r7, #4]
 800f264:	f7fb fac6 	bl	800a7f4 <HAL_IPCC_MspInit>
    }

    /* Reset all registers of the current cpu to default state */
    IPCC_Reset_Register(currentInstance);
 800f268:	68b8      	ldr	r0, [r7, #8]
 800f26a:	f000 f85b 	bl	800f324 <IPCC_Reset_Register>

    /* Activate the interrupts */
    currentInstance->CR |= (IPCC_CR_RXOIE | IPCC_CR_TXFIE);
 800f26e:	68bb      	ldr	r3, [r7, #8]
 800f270:	681b      	ldr	r3, [r3, #0]
 800f272:	f043 1201 	orr.w	r2, r3, #65537	; 0x10001
 800f276:	68bb      	ldr	r3, [r7, #8]
 800f278:	601a      	str	r2, [r3, #0]

    /* Clear callback pointers */
    IPCC_SetDefaultCallbacks(hipcc);
 800f27a:	6878      	ldr	r0, [r7, #4]
 800f27c:	f000 f82c 	bl	800f2d8 <IPCC_SetDefaultCallbacks>

    /* Reset all callback notification request */
    hipcc->callbackRequest = 0;
 800f280:	687b      	ldr	r3, [r7, #4]
 800f282:	2200      	movs	r2, #0
 800f284:	635a      	str	r2, [r3, #52]	; 0x34

    hipcc->State = HAL_IPCC_STATE_READY;
 800f286:	687b      	ldr	r3, [r7, #4]
 800f288:	2201      	movs	r2, #1
 800f28a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 800f28e:	e001      	b.n	800f294 <HAL_IPCC_Init+0x54>
  }
  else
  {
    err = HAL_ERROR;
 800f290:	2301      	movs	r3, #1
 800f292:	73fb      	strb	r3, [r7, #15]
  }

  return err;
 800f294:	7bfb      	ldrb	r3, [r7, #15]
}
 800f296:	4618      	mov	r0, r3
 800f298:	3710      	adds	r7, #16
 800f29a:	46bd      	mov	sp, r7
 800f29c:	bd80      	pop	{r7, pc}
 800f29e:	bf00      	nop
 800f2a0:	58000c00 	.word	0x58000c00

0800f2a4 <HAL_IPCC_RxCallback>:
  *            @arg IPCC_CHANNEL_5: IPCC Channel 5
  *            @arg IPCC_CHANNEL_6: IPCC Channel 6
  * @param ChannelDir Channel direction
  */
__weak void HAL_IPCC_RxCallback(IPCC_HandleTypeDef *hipcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 800f2a4:	b480      	push	{r7}
 800f2a6:	b085      	sub	sp, #20
 800f2a8:	af00      	add	r7, sp, #0
 800f2aa:	60f8      	str	r0, [r7, #12]
 800f2ac:	60b9      	str	r1, [r7, #8]
 800f2ae:	4613      	mov	r3, r2
 800f2b0:	71fb      	strb	r3, [r7, #7]
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_RxCallback can be implemented in the user file
   */
}
 800f2b2:	bf00      	nop
 800f2b4:	3714      	adds	r7, #20
 800f2b6:	46bd      	mov	sp, r7
 800f2b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2bc:	4770      	bx	lr

0800f2be <HAL_IPCC_TxCallback>:
  *            @arg IPCC_CHANNEL_5: IPCC Channel 5
  *            @arg IPCC_CHANNEL_6: IPCC Channel 6
  * @param ChannelDir Channel direction
  */
__weak void HAL_IPCC_TxCallback(IPCC_HandleTypeDef *hipcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 800f2be:	b480      	push	{r7}
 800f2c0:	b085      	sub	sp, #20
 800f2c2:	af00      	add	r7, sp, #0
 800f2c4:	60f8      	str	r0, [r7, #12]
 800f2c6:	60b9      	str	r1, [r7, #8]
 800f2c8:	4613      	mov	r3, r2
 800f2ca:	71fb      	strb	r3, [r7, #7]
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_TxCallback can be implemented in the user file
   */
}
 800f2cc:	bf00      	nop
 800f2ce:	3714      	adds	r7, #20
 800f2d0:	46bd      	mov	sp, r7
 800f2d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2d6:	4770      	bx	lr

0800f2d8 <IPCC_SetDefaultCallbacks>:
/**
  * @brief Reset all callbacks of the handle to NULL.
  * @param  hipcc IPCC handle
  */
void IPCC_SetDefaultCallbacks(IPCC_HandleTypeDef *hipcc)
{
 800f2d8:	b480      	push	{r7}
 800f2da:	b085      	sub	sp, #20
 800f2dc:	af00      	add	r7, sp, #0
 800f2de:	6078      	str	r0, [r7, #4]
  uint32_t i;
  /* Set all callbacks to default */
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 800f2e0:	2300      	movs	r3, #0
 800f2e2:	60fb      	str	r3, [r7, #12]
 800f2e4:	e00f      	b.n	800f306 <IPCC_SetDefaultCallbacks+0x2e>
  {
    hipcc->ChannelCallbackRx[i] = HAL_IPCC_RxCallback;
 800f2e6:	687a      	ldr	r2, [r7, #4]
 800f2e8:	68fb      	ldr	r3, [r7, #12]
 800f2ea:	009b      	lsls	r3, r3, #2
 800f2ec:	4413      	add	r3, r2
 800f2ee:	4a0b      	ldr	r2, [pc, #44]	; (800f31c <IPCC_SetDefaultCallbacks+0x44>)
 800f2f0:	605a      	str	r2, [r3, #4]
    hipcc->ChannelCallbackTx[i] = HAL_IPCC_TxCallback;
 800f2f2:	687a      	ldr	r2, [r7, #4]
 800f2f4:	68fb      	ldr	r3, [r7, #12]
 800f2f6:	3306      	adds	r3, #6
 800f2f8:	009b      	lsls	r3, r3, #2
 800f2fa:	4413      	add	r3, r2
 800f2fc:	4a08      	ldr	r2, [pc, #32]	; (800f320 <IPCC_SetDefaultCallbacks+0x48>)
 800f2fe:	605a      	str	r2, [r3, #4]
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 800f300:	68fb      	ldr	r3, [r7, #12]
 800f302:	3301      	adds	r3, #1
 800f304:	60fb      	str	r3, [r7, #12]
 800f306:	68fb      	ldr	r3, [r7, #12]
 800f308:	2b05      	cmp	r3, #5
 800f30a:	d9ec      	bls.n	800f2e6 <IPCC_SetDefaultCallbacks+0xe>
  }
}
 800f30c:	bf00      	nop
 800f30e:	bf00      	nop
 800f310:	3714      	adds	r7, #20
 800f312:	46bd      	mov	sp, r7
 800f314:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f318:	4770      	bx	lr
 800f31a:	bf00      	nop
 800f31c:	0800f2a5 	.word	0x0800f2a5
 800f320:	0800f2bf 	.word	0x0800f2bf

0800f324 <IPCC_Reset_Register>:
/**
  * @brief Reset IPCC register to default value for the concerned instance.
  * @param  Instance pointer to register
  */
void IPCC_Reset_Register(IPCC_CommonTypeDef *Instance)
{
 800f324:	b480      	push	{r7}
 800f326:	b083      	sub	sp, #12
 800f328:	af00      	add	r7, sp, #0
 800f32a:	6078      	str	r0, [r7, #4]
  /* Disable RX and TX interrupts */
  Instance->CR  = 0x00000000U;
 800f32c:	687b      	ldr	r3, [r7, #4]
 800f32e:	2200      	movs	r2, #0
 800f330:	601a      	str	r2, [r3, #0]

  /* Mask RX and TX interrupts */
  Instance->MR  = (IPCC_ALL_TX_BUF | IPCC_ALL_RX_BUF);
 800f332:	687b      	ldr	r3, [r7, #4]
 800f334:	f04f 123f 	mov.w	r2, #4128831	; 0x3f003f
 800f338:	605a      	str	r2, [r3, #4]

  /* Clear RX status */
  Instance->SCR = IPCC_ALL_RX_BUF;
 800f33a:	687b      	ldr	r3, [r7, #4]
 800f33c:	223f      	movs	r2, #63	; 0x3f
 800f33e:	609a      	str	r2, [r3, #8]
}
 800f340:	bf00      	nop
 800f342:	370c      	adds	r7, #12
 800f344:	46bd      	mov	sp, r7
 800f346:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f34a:	4770      	bx	lr

0800f34c <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800f34c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f34e:	b08b      	sub	sp, #44	; 0x2c
 800f350:	af06      	add	r7, sp, #24
 800f352:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800f354:	687b      	ldr	r3, [r7, #4]
 800f356:	2b00      	cmp	r3, #0
 800f358:	d101      	bne.n	800f35e <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 800f35a:	2301      	movs	r3, #1
 800f35c:	e0d7      	b.n	800f50e <HAL_PCD_Init+0x1c2>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800f35e:	687b      	ldr	r3, [r7, #4]
 800f360:	f893 32a9 	ldrb.w	r3, [r3, #681]	; 0x2a9
 800f364:	b2db      	uxtb	r3, r3
 800f366:	2b00      	cmp	r3, #0
 800f368:	d106      	bne.n	800f378 <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800f36a:	687b      	ldr	r3, [r7, #4]
 800f36c:	2200      	movs	r2, #0
 800f36e:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800f372:	6878      	ldr	r0, [r7, #4]
 800f374:	f019 fc0a 	bl	8028b8c <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800f378:	687b      	ldr	r3, [r7, #4]
 800f37a:	2203      	movs	r2, #3
 800f37c:	f883 22a9 	strb.w	r2, [r3, #681]	; 0x2a9

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800f380:	687b      	ldr	r3, [r7, #4]
 800f382:	681b      	ldr	r3, [r3, #0]
 800f384:	4618      	mov	r0, r3
 800f386:	f006 ffce 	bl	8016326 <USB_DisableGlobalInt>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800f38a:	2300      	movs	r3, #0
 800f38c:	73fb      	strb	r3, [r7, #15]
 800f38e:	e04c      	b.n	800f42a <HAL_PCD_Init+0xde>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800f390:	7bfb      	ldrb	r3, [r7, #15]
 800f392:	6879      	ldr	r1, [r7, #4]
 800f394:	1c5a      	adds	r2, r3, #1
 800f396:	4613      	mov	r3, r2
 800f398:	009b      	lsls	r3, r3, #2
 800f39a:	4413      	add	r3, r2
 800f39c:	00db      	lsls	r3, r3, #3
 800f39e:	440b      	add	r3, r1
 800f3a0:	3301      	adds	r3, #1
 800f3a2:	2201      	movs	r2, #1
 800f3a4:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 800f3a6:	7bfb      	ldrb	r3, [r7, #15]
 800f3a8:	6879      	ldr	r1, [r7, #4]
 800f3aa:	1c5a      	adds	r2, r3, #1
 800f3ac:	4613      	mov	r3, r2
 800f3ae:	009b      	lsls	r3, r3, #2
 800f3b0:	4413      	add	r3, r2
 800f3b2:	00db      	lsls	r3, r3, #3
 800f3b4:	440b      	add	r3, r1
 800f3b6:	7bfa      	ldrb	r2, [r7, #15]
 800f3b8:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800f3ba:	7bfa      	ldrb	r2, [r7, #15]
 800f3bc:	7bfb      	ldrb	r3, [r7, #15]
 800f3be:	b298      	uxth	r0, r3
 800f3c0:	6879      	ldr	r1, [r7, #4]
 800f3c2:	4613      	mov	r3, r2
 800f3c4:	009b      	lsls	r3, r3, #2
 800f3c6:	4413      	add	r3, r2
 800f3c8:	00db      	lsls	r3, r3, #3
 800f3ca:	440b      	add	r3, r1
 800f3cc:	3336      	adds	r3, #54	; 0x36
 800f3ce:	4602      	mov	r2, r0
 800f3d0:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800f3d2:	7bfb      	ldrb	r3, [r7, #15]
 800f3d4:	6879      	ldr	r1, [r7, #4]
 800f3d6:	1c5a      	adds	r2, r3, #1
 800f3d8:	4613      	mov	r3, r2
 800f3da:	009b      	lsls	r3, r3, #2
 800f3dc:	4413      	add	r3, r2
 800f3de:	00db      	lsls	r3, r3, #3
 800f3e0:	440b      	add	r3, r1
 800f3e2:	3303      	adds	r3, #3
 800f3e4:	2200      	movs	r2, #0
 800f3e6:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 800f3e8:	7bfa      	ldrb	r2, [r7, #15]
 800f3ea:	6879      	ldr	r1, [r7, #4]
 800f3ec:	4613      	mov	r3, r2
 800f3ee:	009b      	lsls	r3, r3, #2
 800f3f0:	4413      	add	r3, r2
 800f3f2:	00db      	lsls	r3, r3, #3
 800f3f4:	440b      	add	r3, r1
 800f3f6:	3338      	adds	r3, #56	; 0x38
 800f3f8:	2200      	movs	r2, #0
 800f3fa:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 800f3fc:	7bfa      	ldrb	r2, [r7, #15]
 800f3fe:	6879      	ldr	r1, [r7, #4]
 800f400:	4613      	mov	r3, r2
 800f402:	009b      	lsls	r3, r3, #2
 800f404:	4413      	add	r3, r2
 800f406:	00db      	lsls	r3, r3, #3
 800f408:	440b      	add	r3, r1
 800f40a:	333c      	adds	r3, #60	; 0x3c
 800f40c:	2200      	movs	r2, #0
 800f40e:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800f410:	7bfa      	ldrb	r2, [r7, #15]
 800f412:	6879      	ldr	r1, [r7, #4]
 800f414:	4613      	mov	r3, r2
 800f416:	009b      	lsls	r3, r3, #2
 800f418:	4413      	add	r3, r2
 800f41a:	00db      	lsls	r3, r3, #3
 800f41c:	440b      	add	r3, r1
 800f41e:	3340      	adds	r3, #64	; 0x40
 800f420:	2200      	movs	r2, #0
 800f422:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800f424:	7bfb      	ldrb	r3, [r7, #15]
 800f426:	3301      	adds	r3, #1
 800f428:	73fb      	strb	r3, [r7, #15]
 800f42a:	7bfa      	ldrb	r2, [r7, #15]
 800f42c:	687b      	ldr	r3, [r7, #4]
 800f42e:	685b      	ldr	r3, [r3, #4]
 800f430:	429a      	cmp	r2, r3
 800f432:	d3ad      	bcc.n	800f390 <HAL_PCD_Init+0x44>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800f434:	2300      	movs	r3, #0
 800f436:	73fb      	strb	r3, [r7, #15]
 800f438:	e044      	b.n	800f4c4 <HAL_PCD_Init+0x178>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800f43a:	7bfa      	ldrb	r2, [r7, #15]
 800f43c:	6879      	ldr	r1, [r7, #4]
 800f43e:	4613      	mov	r3, r2
 800f440:	009b      	lsls	r3, r3, #2
 800f442:	4413      	add	r3, r2
 800f444:	00db      	lsls	r3, r3, #3
 800f446:	440b      	add	r3, r1
 800f448:	f203 1369 	addw	r3, r3, #361	; 0x169
 800f44c:	2200      	movs	r2, #0
 800f44e:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800f450:	7bfa      	ldrb	r2, [r7, #15]
 800f452:	6879      	ldr	r1, [r7, #4]
 800f454:	4613      	mov	r3, r2
 800f456:	009b      	lsls	r3, r3, #2
 800f458:	4413      	add	r3, r2
 800f45a:	00db      	lsls	r3, r3, #3
 800f45c:	440b      	add	r3, r1
 800f45e:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800f462:	7bfa      	ldrb	r2, [r7, #15]
 800f464:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800f466:	7bfa      	ldrb	r2, [r7, #15]
 800f468:	6879      	ldr	r1, [r7, #4]
 800f46a:	4613      	mov	r3, r2
 800f46c:	009b      	lsls	r3, r3, #2
 800f46e:	4413      	add	r3, r2
 800f470:	00db      	lsls	r3, r3, #3
 800f472:	440b      	add	r3, r1
 800f474:	f203 136b 	addw	r3, r3, #363	; 0x16b
 800f478:	2200      	movs	r2, #0
 800f47a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 800f47c:	7bfa      	ldrb	r2, [r7, #15]
 800f47e:	6879      	ldr	r1, [r7, #4]
 800f480:	4613      	mov	r3, r2
 800f482:	009b      	lsls	r3, r3, #2
 800f484:	4413      	add	r3, r2
 800f486:	00db      	lsls	r3, r3, #3
 800f488:	440b      	add	r3, r1
 800f48a:	f503 73bc 	add.w	r3, r3, #376	; 0x178
 800f48e:	2200      	movs	r2, #0
 800f490:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800f492:	7bfa      	ldrb	r2, [r7, #15]
 800f494:	6879      	ldr	r1, [r7, #4]
 800f496:	4613      	mov	r3, r2
 800f498:	009b      	lsls	r3, r3, #2
 800f49a:	4413      	add	r3, r2
 800f49c:	00db      	lsls	r3, r3, #3
 800f49e:	440b      	add	r3, r1
 800f4a0:	f503 73be 	add.w	r3, r3, #380	; 0x17c
 800f4a4:	2200      	movs	r2, #0
 800f4a6:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 800f4a8:	7bfa      	ldrb	r2, [r7, #15]
 800f4aa:	6879      	ldr	r1, [r7, #4]
 800f4ac:	4613      	mov	r3, r2
 800f4ae:	009b      	lsls	r3, r3, #2
 800f4b0:	4413      	add	r3, r2
 800f4b2:	00db      	lsls	r3, r3, #3
 800f4b4:	440b      	add	r3, r1
 800f4b6:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800f4ba:	2200      	movs	r2, #0
 800f4bc:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800f4be:	7bfb      	ldrb	r3, [r7, #15]
 800f4c0:	3301      	adds	r3, #1
 800f4c2:	73fb      	strb	r3, [r7, #15]
 800f4c4:	7bfa      	ldrb	r2, [r7, #15]
 800f4c6:	687b      	ldr	r3, [r7, #4]
 800f4c8:	685b      	ldr	r3, [r3, #4]
 800f4ca:	429a      	cmp	r2, r3
 800f4cc:	d3b5      	bcc.n	800f43a <HAL_PCD_Init+0xee>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 800f4ce:	687b      	ldr	r3, [r7, #4]
 800f4d0:	681b      	ldr	r3, [r3, #0]
 800f4d2:	603b      	str	r3, [r7, #0]
 800f4d4:	687e      	ldr	r6, [r7, #4]
 800f4d6:	466d      	mov	r5, sp
 800f4d8:	f106 0410 	add.w	r4, r6, #16
 800f4dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800f4de:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800f4e0:	6823      	ldr	r3, [r4, #0]
 800f4e2:	602b      	str	r3, [r5, #0]
 800f4e4:	1d33      	adds	r3, r6, #4
 800f4e6:	cb0e      	ldmia	r3, {r1, r2, r3}
 800f4e8:	6838      	ldr	r0, [r7, #0]
 800f4ea:	f006 ff37 	bl	801635c <USB_DevInit>

  hpcd->USB_Address = 0U;
 800f4ee:	687b      	ldr	r3, [r7, #4]
 800f4f0:	2200      	movs	r2, #0
 800f4f2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hpcd->State = HAL_PCD_STATE_READY;
 800f4f6:	687b      	ldr	r3, [r7, #4]
 800f4f8:	2201      	movs	r2, #1
 800f4fa:	f883 22a9 	strb.w	r2, [r3, #681]	; 0x2a9

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 800f4fe:	687b      	ldr	r3, [r7, #4]
 800f500:	69db      	ldr	r3, [r3, #28]
 800f502:	2b01      	cmp	r3, #1
 800f504:	d102      	bne.n	800f50c <HAL_PCD_Init+0x1c0>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800f506:	6878      	ldr	r0, [r7, #4]
 800f508:	f001 fc29 	bl	8010d5e <HAL_PCDEx_ActivateLPM>
  }

  return HAL_OK;
 800f50c:	2300      	movs	r3, #0
}
 800f50e:	4618      	mov	r0, r3
 800f510:	3714      	adds	r7, #20
 800f512:	46bd      	mov	sp, r7
 800f514:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800f516 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800f516:	b580      	push	{r7, lr}
 800f518:	b082      	sub	sp, #8
 800f51a:	af00      	add	r7, sp, #0
 800f51c:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd);
 800f51e:	687b      	ldr	r3, [r7, #4]
 800f520:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800f524:	2b01      	cmp	r3, #1
 800f526:	d101      	bne.n	800f52c <HAL_PCD_Start+0x16>
 800f528:	2302      	movs	r3, #2
 800f52a:	e012      	b.n	800f552 <HAL_PCD_Start+0x3c>
 800f52c:	687b      	ldr	r3, [r7, #4]
 800f52e:	2201      	movs	r2, #1
 800f530:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  __HAL_PCD_ENABLE(hpcd);
 800f534:	687b      	ldr	r3, [r7, #4]
 800f536:	681b      	ldr	r3, [r3, #0]
 800f538:	4618      	mov	r0, r3
 800f53a:	f006 fedd 	bl	80162f8 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800f53e:	687b      	ldr	r3, [r7, #4]
 800f540:	681b      	ldr	r3, [r3, #0]
 800f542:	4618      	mov	r0, r3
 800f544:	f008 fe92 	bl	801826c <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800f548:	687b      	ldr	r3, [r7, #4]
 800f54a:	2200      	movs	r2, #0
 800f54c:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  return HAL_OK;
 800f550:	2300      	movs	r3, #0
}
 800f552:	4618      	mov	r0, r3
 800f554:	3708      	adds	r7, #8
 800f556:	46bd      	mov	sp, r7
 800f558:	bd80      	pop	{r7, pc}

0800f55a <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800f55a:	b580      	push	{r7, lr}
 800f55c:	b084      	sub	sp, #16
 800f55e:	af00      	add	r7, sp, #0
 800f560:	6078      	str	r0, [r7, #4]
  uint32_t wIstr = USB_ReadInterrupts(hpcd->Instance);
 800f562:	687b      	ldr	r3, [r7, #4]
 800f564:	681b      	ldr	r3, [r3, #0]
 800f566:	4618      	mov	r0, r3
 800f568:	f008 fe97 	bl	801829a <USB_ReadInterrupts>
 800f56c:	60f8      	str	r0, [r7, #12]

  if ((wIstr & USB_ISTR_CTR) == USB_ISTR_CTR)
 800f56e:	68fb      	ldr	r3, [r7, #12]
 800f570:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800f574:	2b00      	cmp	r3, #0
 800f576:	d003      	beq.n	800f580 <HAL_PCD_IRQHandler+0x26>
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    (void)PCD_EP_ISR_Handler(hpcd);
 800f578:	6878      	ldr	r0, [r7, #4]
 800f57a:	f000 fb26 	bl	800fbca <PCD_EP_ISR_Handler>

    return;
 800f57e:	e110      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_RESET) == USB_ISTR_RESET)
 800f580:	68fb      	ldr	r3, [r7, #12]
 800f582:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800f586:	2b00      	cmp	r3, #0
 800f588:	d013      	beq.n	800f5b2 <HAL_PCD_IRQHandler+0x58>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800f58a:	687b      	ldr	r3, [r7, #4]
 800f58c:	681b      	ldr	r3, [r3, #0]
 800f58e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f592:	b29a      	uxth	r2, r3
 800f594:	687b      	ldr	r3, [r7, #4]
 800f596:	681b      	ldr	r3, [r3, #0]
 800f598:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800f59c:	b292      	uxth	r2, r2
 800f59e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResetCallback(hpcd);
#else
    HAL_PCD_ResetCallback(hpcd);
 800f5a2:	6878      	ldr	r0, [r7, #4]
 800f5a4:	f019 fb95 	bl	8028cd2 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    (void)HAL_PCD_SetAddress(hpcd, 0U);
 800f5a8:	2100      	movs	r1, #0
 800f5aa:	6878      	ldr	r0, [r7, #4]
 800f5ac:	f000 f8fc 	bl	800f7a8 <HAL_PCD_SetAddress>

    return;
 800f5b0:	e0f7      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_PMAOVR) == USB_ISTR_PMAOVR)
 800f5b2:	68fb      	ldr	r3, [r7, #12]
 800f5b4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800f5b8:	2b00      	cmp	r3, #0
 800f5ba:	d00c      	beq.n	800f5d6 <HAL_PCD_IRQHandler+0x7c>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 800f5bc:	687b      	ldr	r3, [r7, #4]
 800f5be:	681b      	ldr	r3, [r3, #0]
 800f5c0:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f5c4:	b29a      	uxth	r2, r3
 800f5c6:	687b      	ldr	r3, [r7, #4]
 800f5c8:	681b      	ldr	r3, [r3, #0]
 800f5ca:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800f5ce:	b292      	uxth	r2, r2
 800f5d0:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800f5d4:	e0e5      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_ERR) == USB_ISTR_ERR)
 800f5d6:	68fb      	ldr	r3, [r7, #12]
 800f5d8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800f5dc:	2b00      	cmp	r3, #0
 800f5de:	d00c      	beq.n	800f5fa <HAL_PCD_IRQHandler+0xa0>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 800f5e0:	687b      	ldr	r3, [r7, #4]
 800f5e2:	681b      	ldr	r3, [r3, #0]
 800f5e4:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f5e8:	b29a      	uxth	r2, r3
 800f5ea:	687b      	ldr	r3, [r7, #4]
 800f5ec:	681b      	ldr	r3, [r3, #0]
 800f5ee:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800f5f2:	b292      	uxth	r2, r2
 800f5f4:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800f5f8:	e0d3      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_WKUP) == USB_ISTR_WKUP)
 800f5fa:	68fb      	ldr	r3, [r7, #12]
 800f5fc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800f600:	2b00      	cmp	r3, #0
 800f602:	d034      	beq.n	800f66e <HAL_PCD_IRQHandler+0x114>
  {
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 800f604:	687b      	ldr	r3, [r7, #4]
 800f606:	681b      	ldr	r3, [r3, #0]
 800f608:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f60c:	b29a      	uxth	r2, r3
 800f60e:	687b      	ldr	r3, [r7, #4]
 800f610:	681b      	ldr	r3, [r3, #0]
 800f612:	f022 0204 	bic.w	r2, r2, #4
 800f616:	b292      	uxth	r2, r2
 800f618:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 800f61c:	687b      	ldr	r3, [r7, #4]
 800f61e:	681b      	ldr	r3, [r3, #0]
 800f620:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f624:	b29a      	uxth	r2, r3
 800f626:	687b      	ldr	r3, [r7, #4]
 800f628:	681b      	ldr	r3, [r3, #0]
 800f62a:	f022 0208 	bic.w	r2, r2, #8
 800f62e:	b292      	uxth	r2, r2
 800f630:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    if (hpcd->LPM_State == LPM_L1)
 800f634:	687b      	ldr	r3, [r7, #4]
 800f636:	f893 32e0 	ldrb.w	r3, [r3, #736]	; 0x2e0
 800f63a:	2b01      	cmp	r3, #1
 800f63c:	d107      	bne.n	800f64e <HAL_PCD_IRQHandler+0xf4>
    {
      hpcd->LPM_State = LPM_L0;
 800f63e:	687b      	ldr	r3, [r7, #4]
 800f640:	2200      	movs	r2, #0
 800f642:	f883 22e0 	strb.w	r2, [r3, #736]	; 0x2e0
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800f646:	2100      	movs	r1, #0
 800f648:	6878      	ldr	r0, [r7, #4]
 800f64a:	f019 fd39 	bl	80290c0 <HAL_PCDEx_LPM_Callback>
    }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->ResumeCallback(hpcd);
#else
    HAL_PCD_ResumeCallback(hpcd);
 800f64e:	6878      	ldr	r0, [r7, #4]
 800f650:	f019 fb78 	bl	8028d44 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 800f654:	687b      	ldr	r3, [r7, #4]
 800f656:	681b      	ldr	r3, [r3, #0]
 800f658:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f65c:	b29a      	uxth	r2, r3
 800f65e:	687b      	ldr	r3, [r7, #4]
 800f660:	681b      	ldr	r3, [r3, #0]
 800f662:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800f666:	b292      	uxth	r2, r2
 800f668:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800f66c:	e099      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_SUSP) == USB_ISTR_SUSP)
 800f66e:	68fb      	ldr	r3, [r7, #12]
 800f670:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800f674:	2b00      	cmp	r3, #0
 800f676:	d027      	beq.n	800f6c8 <HAL_PCD_IRQHandler+0x16e>
  {
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800f678:	687b      	ldr	r3, [r7, #4]
 800f67a:	681b      	ldr	r3, [r3, #0]
 800f67c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f680:	b29a      	uxth	r2, r3
 800f682:	687b      	ldr	r3, [r7, #4]
 800f684:	681b      	ldr	r3, [r3, #0]
 800f686:	f042 0208 	orr.w	r2, r2, #8
 800f68a:	b292      	uxth	r2, r2
 800f68c:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 800f690:	687b      	ldr	r3, [r7, #4]
 800f692:	681b      	ldr	r3, [r3, #0]
 800f694:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f698:	b29a      	uxth	r2, r3
 800f69a:	687b      	ldr	r3, [r7, #4]
 800f69c:	681b      	ldr	r3, [r3, #0]
 800f69e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800f6a2:	b292      	uxth	r2, r2
 800f6a4:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800f6a8:	687b      	ldr	r3, [r7, #4]
 800f6aa:	681b      	ldr	r3, [r3, #0]
 800f6ac:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f6b0:	b29a      	uxth	r2, r3
 800f6b2:	687b      	ldr	r3, [r7, #4]
 800f6b4:	681b      	ldr	r3, [r3, #0]
 800f6b6:	f042 0204 	orr.w	r2, r2, #4
 800f6ba:	b292      	uxth	r2, r2
 800f6bc:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SuspendCallback(hpcd);
#else
    HAL_PCD_SuspendCallback(hpcd);
 800f6c0:	6878      	ldr	r0, [r7, #4]
 800f6c2:	f019 fb25 	bl	8028d10 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    return;
 800f6c6:	e06c      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  /* Handle LPM Interrupt */
  if ((wIstr & USB_ISTR_L1REQ) == USB_ISTR_L1REQ)
 800f6c8:	68fb      	ldr	r3, [r7, #12]
 800f6ca:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800f6ce:	2b00      	cmp	r3, #0
 800f6d0:	d040      	beq.n	800f754 <HAL_PCD_IRQHandler+0x1fa>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_L1REQ);
 800f6d2:	687b      	ldr	r3, [r7, #4]
 800f6d4:	681b      	ldr	r3, [r3, #0]
 800f6d6:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f6da:	b29a      	uxth	r2, r3
 800f6dc:	687b      	ldr	r3, [r7, #4]
 800f6de:	681b      	ldr	r3, [r3, #0]
 800f6e0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800f6e4:	b292      	uxth	r2, r2
 800f6e6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    if (hpcd->LPM_State == LPM_L0)
 800f6ea:	687b      	ldr	r3, [r7, #4]
 800f6ec:	f893 32e0 	ldrb.w	r3, [r3, #736]	; 0x2e0
 800f6f0:	2b00      	cmp	r3, #0
 800f6f2:	d12b      	bne.n	800f74c <HAL_PCD_IRQHandler+0x1f2>
    {
      /* Force suspend and low-power mode before going to L1 state*/
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	681b      	ldr	r3, [r3, #0]
 800f6f8:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f6fc:	b29a      	uxth	r2, r3
 800f6fe:	687b      	ldr	r3, [r7, #4]
 800f700:	681b      	ldr	r3, [r3, #0]
 800f702:	f042 0204 	orr.w	r2, r2, #4
 800f706:	b292      	uxth	r2, r2
 800f708:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800f70c:	687b      	ldr	r3, [r7, #4]
 800f70e:	681b      	ldr	r3, [r3, #0]
 800f710:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800f714:	b29a      	uxth	r2, r3
 800f716:	687b      	ldr	r3, [r7, #4]
 800f718:	681b      	ldr	r3, [r3, #0]
 800f71a:	f042 0208 	orr.w	r2, r2, #8
 800f71e:	b292      	uxth	r2, r2
 800f720:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

      hpcd->LPM_State = LPM_L1;
 800f724:	687b      	ldr	r3, [r7, #4]
 800f726:	2201      	movs	r2, #1
 800f728:	f883 22e0 	strb.w	r2, [r3, #736]	; 0x2e0
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800f72c:	687b      	ldr	r3, [r7, #4]
 800f72e:	681b      	ldr	r3, [r3, #0]
 800f730:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 800f734:	b29b      	uxth	r3, r3
 800f736:	089b      	lsrs	r3, r3, #2
 800f738:	f003 023c 	and.w	r2, r3, #60	; 0x3c
 800f73c:	687b      	ldr	r3, [r7, #4]
 800f73e:	f8c3 22e4 	str.w	r2, [r3, #740]	; 0x2e4
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800f742:	2101      	movs	r1, #1
 800f744:	6878      	ldr	r0, [r7, #4]
 800f746:	f019 fcbb 	bl	80290c0 <HAL_PCDEx_LPM_Callback>
#else
      HAL_PCD_SuspendCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }

    return;
 800f74a:	e02a      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
      HAL_PCD_SuspendCallback(hpcd);
 800f74c:	6878      	ldr	r0, [r7, #4]
 800f74e:	f019 fadf 	bl	8028d10 <HAL_PCD_SuspendCallback>
    return;
 800f752:	e026      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_SOF) == USB_ISTR_SOF)
 800f754:	68fb      	ldr	r3, [r7, #12]
 800f756:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800f75a:	2b00      	cmp	r3, #0
 800f75c:	d00f      	beq.n	800f77e <HAL_PCD_IRQHandler+0x224>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800f75e:	687b      	ldr	r3, [r7, #4]
 800f760:	681b      	ldr	r3, [r3, #0]
 800f762:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f766:	b29a      	uxth	r2, r3
 800f768:	687b      	ldr	r3, [r7, #4]
 800f76a:	681b      	ldr	r3, [r3, #0]
 800f76c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800f770:	b292      	uxth	r2, r2
 800f772:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    hpcd->SOFCallback(hpcd);
#else
    HAL_PCD_SOFCallback(hpcd);
 800f776:	6878      	ldr	r0, [r7, #4]
 800f778:	f019 fa9d 	bl	8028cb6 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

    return;
 800f77c:	e011      	b.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  }

  if ((wIstr & USB_ISTR_ESOF) == USB_ISTR_ESOF)
 800f77e:	68fb      	ldr	r3, [r7, #12]
 800f780:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800f784:	2b00      	cmp	r3, #0
 800f786:	d00c      	beq.n	800f7a2 <HAL_PCD_IRQHandler+0x248>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 800f788:	687b      	ldr	r3, [r7, #4]
 800f78a:	681b      	ldr	r3, [r3, #0]
 800f78c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800f790:	b29a      	uxth	r2, r3
 800f792:	687b      	ldr	r3, [r7, #4]
 800f794:	681b      	ldr	r3, [r3, #0]
 800f796:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800f79a:	b292      	uxth	r2, r2
 800f79c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

    return;
 800f7a0:	bf00      	nop
  }
}
 800f7a2:	3710      	adds	r7, #16
 800f7a4:	46bd      	mov	sp, r7
 800f7a6:	bd80      	pop	{r7, pc}

0800f7a8 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800f7a8:	b580      	push	{r7, lr}
 800f7aa:	b082      	sub	sp, #8
 800f7ac:	af00      	add	r7, sp, #0
 800f7ae:	6078      	str	r0, [r7, #4]
 800f7b0:	460b      	mov	r3, r1
 800f7b2:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 800f7b4:	687b      	ldr	r3, [r7, #4]
 800f7b6:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800f7ba:	2b01      	cmp	r3, #1
 800f7bc:	d101      	bne.n	800f7c2 <HAL_PCD_SetAddress+0x1a>
 800f7be:	2302      	movs	r3, #2
 800f7c0:	e013      	b.n	800f7ea <HAL_PCD_SetAddress+0x42>
 800f7c2:	687b      	ldr	r3, [r7, #4]
 800f7c4:	2201      	movs	r2, #1
 800f7c6:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  hpcd->USB_Address = address;
 800f7ca:	687b      	ldr	r3, [r7, #4]
 800f7cc:	78fa      	ldrb	r2, [r7, #3]
 800f7ce:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800f7d2:	687b      	ldr	r3, [r7, #4]
 800f7d4:	681b      	ldr	r3, [r3, #0]
 800f7d6:	78fa      	ldrb	r2, [r7, #3]
 800f7d8:	4611      	mov	r1, r2
 800f7da:	4618      	mov	r0, r3
 800f7dc:	f008 fd32 	bl	8018244 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800f7e0:	687b      	ldr	r3, [r7, #4]
 800f7e2:	2200      	movs	r2, #0
 800f7e4:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  return HAL_OK;
 800f7e8:	2300      	movs	r3, #0
}
 800f7ea:	4618      	mov	r0, r3
 800f7ec:	3708      	adds	r7, #8
 800f7ee:	46bd      	mov	sp, r7
 800f7f0:	bd80      	pop	{r7, pc}

0800f7f2 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 800f7f2:	b580      	push	{r7, lr}
 800f7f4:	b084      	sub	sp, #16
 800f7f6:	af00      	add	r7, sp, #0
 800f7f8:	6078      	str	r0, [r7, #4]
 800f7fa:	4608      	mov	r0, r1
 800f7fc:	4611      	mov	r1, r2
 800f7fe:	461a      	mov	r2, r3
 800f800:	4603      	mov	r3, r0
 800f802:	70fb      	strb	r3, [r7, #3]
 800f804:	460b      	mov	r3, r1
 800f806:	803b      	strh	r3, [r7, #0]
 800f808:	4613      	mov	r3, r2
 800f80a:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 800f80c:	2300      	movs	r3, #0
 800f80e:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800f810:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800f814:	2b00      	cmp	r3, #0
 800f816:	da0e      	bge.n	800f836 <HAL_PCD_EP_Open+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800f818:	78fb      	ldrb	r3, [r7, #3]
 800f81a:	f003 0307 	and.w	r3, r3, #7
 800f81e:	1c5a      	adds	r2, r3, #1
 800f820:	4613      	mov	r3, r2
 800f822:	009b      	lsls	r3, r3, #2
 800f824:	4413      	add	r3, r2
 800f826:	00db      	lsls	r3, r3, #3
 800f828:	687a      	ldr	r2, [r7, #4]
 800f82a:	4413      	add	r3, r2
 800f82c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800f82e:	68fb      	ldr	r3, [r7, #12]
 800f830:	2201      	movs	r2, #1
 800f832:	705a      	strb	r2, [r3, #1]
 800f834:	e00e      	b.n	800f854 <HAL_PCD_EP_Open+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800f836:	78fb      	ldrb	r3, [r7, #3]
 800f838:	f003 0207 	and.w	r2, r3, #7
 800f83c:	4613      	mov	r3, r2
 800f83e:	009b      	lsls	r3, r3, #2
 800f840:	4413      	add	r3, r2
 800f842:	00db      	lsls	r3, r3, #3
 800f844:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800f848:	687a      	ldr	r2, [r7, #4]
 800f84a:	4413      	add	r3, r2
 800f84c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800f84e:	68fb      	ldr	r3, [r7, #12]
 800f850:	2200      	movs	r2, #0
 800f852:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 800f854:	78fb      	ldrb	r3, [r7, #3]
 800f856:	f003 0307 	and.w	r3, r3, #7
 800f85a:	b2da      	uxtb	r2, r3
 800f85c:	68fb      	ldr	r3, [r7, #12]
 800f85e:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 800f860:	883a      	ldrh	r2, [r7, #0]
 800f862:	68fb      	ldr	r3, [r7, #12]
 800f864:	611a      	str	r2, [r3, #16]
  ep->type = ep_type;
 800f866:	68fb      	ldr	r3, [r7, #12]
 800f868:	78ba      	ldrb	r2, [r7, #2]
 800f86a:	70da      	strb	r2, [r3, #3]

  if (ep->is_in != 0U)
 800f86c:	68fb      	ldr	r3, [r7, #12]
 800f86e:	785b      	ldrb	r3, [r3, #1]
 800f870:	2b00      	cmp	r3, #0
 800f872:	d004      	beq.n	800f87e <HAL_PCD_EP_Open+0x8c>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 800f874:	68fb      	ldr	r3, [r7, #12]
 800f876:	781b      	ldrb	r3, [r3, #0]
 800f878:	b29a      	uxth	r2, r3
 800f87a:	68fb      	ldr	r3, [r7, #12]
 800f87c:	81da      	strh	r2, [r3, #14]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 800f87e:	78bb      	ldrb	r3, [r7, #2]
 800f880:	2b02      	cmp	r3, #2
 800f882:	d102      	bne.n	800f88a <HAL_PCD_EP_Open+0x98>
  {
    ep->data_pid_start = 0U;
 800f884:	68fb      	ldr	r3, [r7, #12]
 800f886:	2200      	movs	r2, #0
 800f888:	711a      	strb	r2, [r3, #4]
  }

  __HAL_LOCK(hpcd);
 800f88a:	687b      	ldr	r3, [r7, #4]
 800f88c:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800f890:	2b01      	cmp	r3, #1
 800f892:	d101      	bne.n	800f898 <HAL_PCD_EP_Open+0xa6>
 800f894:	2302      	movs	r3, #2
 800f896:	e00e      	b.n	800f8b6 <HAL_PCD_EP_Open+0xc4>
 800f898:	687b      	ldr	r3, [r7, #4]
 800f89a:	2201      	movs	r2, #1
 800f89c:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800f8a0:	687b      	ldr	r3, [r7, #4]
 800f8a2:	681b      	ldr	r3, [r3, #0]
 800f8a4:	68f9      	ldr	r1, [r7, #12]
 800f8a6:	4618      	mov	r0, r3
 800f8a8:	f006 fd7a 	bl	80163a0 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800f8ac:	687b      	ldr	r3, [r7, #4]
 800f8ae:	2200      	movs	r2, #0
 800f8b0:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  return ret;
 800f8b4:	7afb      	ldrb	r3, [r7, #11]
}
 800f8b6:	4618      	mov	r0, r3
 800f8b8:	3710      	adds	r7, #16
 800f8ba:	46bd      	mov	sp, r7
 800f8bc:	bd80      	pop	{r7, pc}

0800f8be <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800f8be:	b580      	push	{r7, lr}
 800f8c0:	b084      	sub	sp, #16
 800f8c2:	af00      	add	r7, sp, #0
 800f8c4:	6078      	str	r0, [r7, #4]
 800f8c6:	460b      	mov	r3, r1
 800f8c8:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800f8ca:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800f8ce:	2b00      	cmp	r3, #0
 800f8d0:	da0e      	bge.n	800f8f0 <HAL_PCD_EP_Close+0x32>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800f8d2:	78fb      	ldrb	r3, [r7, #3]
 800f8d4:	f003 0307 	and.w	r3, r3, #7
 800f8d8:	1c5a      	adds	r2, r3, #1
 800f8da:	4613      	mov	r3, r2
 800f8dc:	009b      	lsls	r3, r3, #2
 800f8de:	4413      	add	r3, r2
 800f8e0:	00db      	lsls	r3, r3, #3
 800f8e2:	687a      	ldr	r2, [r7, #4]
 800f8e4:	4413      	add	r3, r2
 800f8e6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800f8e8:	68fb      	ldr	r3, [r7, #12]
 800f8ea:	2201      	movs	r2, #1
 800f8ec:	705a      	strb	r2, [r3, #1]
 800f8ee:	e00e      	b.n	800f90e <HAL_PCD_EP_Close+0x50>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800f8f0:	78fb      	ldrb	r3, [r7, #3]
 800f8f2:	f003 0207 	and.w	r2, r3, #7
 800f8f6:	4613      	mov	r3, r2
 800f8f8:	009b      	lsls	r3, r3, #2
 800f8fa:	4413      	add	r3, r2
 800f8fc:	00db      	lsls	r3, r3, #3
 800f8fe:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800f902:	687a      	ldr	r2, [r7, #4]
 800f904:	4413      	add	r3, r2
 800f906:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800f908:	68fb      	ldr	r3, [r7, #12]
 800f90a:	2200      	movs	r2, #0
 800f90c:	705a      	strb	r2, [r3, #1]
  }
  ep->num   = ep_addr & EP_ADDR_MSK;
 800f90e:	78fb      	ldrb	r3, [r7, #3]
 800f910:	f003 0307 	and.w	r3, r3, #7
 800f914:	b2da      	uxtb	r2, r3
 800f916:	68fb      	ldr	r3, [r7, #12]
 800f918:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800f91a:	687b      	ldr	r3, [r7, #4]
 800f91c:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800f920:	2b01      	cmp	r3, #1
 800f922:	d101      	bne.n	800f928 <HAL_PCD_EP_Close+0x6a>
 800f924:	2302      	movs	r3, #2
 800f926:	e00e      	b.n	800f946 <HAL_PCD_EP_Close+0x88>
 800f928:	687b      	ldr	r3, [r7, #4]
 800f92a:	2201      	movs	r2, #1
 800f92c:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800f930:	687b      	ldr	r3, [r7, #4]
 800f932:	681b      	ldr	r3, [r3, #0]
 800f934:	68f9      	ldr	r1, [r7, #12]
 800f936:	4618      	mov	r0, r3
 800f938:	f007 f8c6 	bl	8016ac8 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800f93c:	687b      	ldr	r3, [r7, #4]
 800f93e:	2200      	movs	r2, #0
 800f940:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  return HAL_OK;
 800f944:	2300      	movs	r3, #0
}
 800f946:	4618      	mov	r0, r3
 800f948:	3710      	adds	r7, #16
 800f94a:	46bd      	mov	sp, r7
 800f94c:	bd80      	pop	{r7, pc}

0800f94e <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800f94e:	b580      	push	{r7, lr}
 800f950:	b086      	sub	sp, #24
 800f952:	af00      	add	r7, sp, #0
 800f954:	60f8      	str	r0, [r7, #12]
 800f956:	607a      	str	r2, [r7, #4]
 800f958:	603b      	str	r3, [r7, #0]
 800f95a:	460b      	mov	r3, r1
 800f95c:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800f95e:	7afb      	ldrb	r3, [r7, #11]
 800f960:	f003 0207 	and.w	r2, r3, #7
 800f964:	4613      	mov	r3, r2
 800f966:	009b      	lsls	r3, r3, #2
 800f968:	4413      	add	r3, r2
 800f96a:	00db      	lsls	r3, r3, #3
 800f96c:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800f970:	68fa      	ldr	r2, [r7, #12]
 800f972:	4413      	add	r3, r2
 800f974:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800f976:	697b      	ldr	r3, [r7, #20]
 800f978:	687a      	ldr	r2, [r7, #4]
 800f97a:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800f97c:	697b      	ldr	r3, [r7, #20]
 800f97e:	683a      	ldr	r2, [r7, #0]
 800f980:	619a      	str	r2, [r3, #24]
  ep->xfer_count = 0U;
 800f982:	697b      	ldr	r3, [r7, #20]
 800f984:	2200      	movs	r2, #0
 800f986:	61da      	str	r2, [r3, #28]
  ep->is_in = 0U;
 800f988:	697b      	ldr	r3, [r7, #20]
 800f98a:	2200      	movs	r2, #0
 800f98c:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800f98e:	7afb      	ldrb	r3, [r7, #11]
 800f990:	f003 0307 	and.w	r3, r3, #7
 800f994:	b2da      	uxtb	r2, r3
 800f996:	697b      	ldr	r3, [r7, #20]
 800f998:	701a      	strb	r2, [r3, #0]

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800f99a:	7afb      	ldrb	r3, [r7, #11]
 800f99c:	f003 0307 	and.w	r3, r3, #7
 800f9a0:	2b00      	cmp	r3, #0
 800f9a2:	d106      	bne.n	800f9b2 <HAL_PCD_EP_Receive+0x64>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 800f9a4:	68fb      	ldr	r3, [r7, #12]
 800f9a6:	681b      	ldr	r3, [r3, #0]
 800f9a8:	6979      	ldr	r1, [r7, #20]
 800f9aa:	4618      	mov	r0, r3
 800f9ac:	f007 fa79 	bl	8016ea2 <USB_EPStartXfer>
 800f9b0:	e005      	b.n	800f9be <HAL_PCD_EP_Receive+0x70>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800f9b2:	68fb      	ldr	r3, [r7, #12]
 800f9b4:	681b      	ldr	r3, [r3, #0]
 800f9b6:	6979      	ldr	r1, [r7, #20]
 800f9b8:	4618      	mov	r0, r3
 800f9ba:	f007 fa72 	bl	8016ea2 <USB_EPStartXfer>
  }

  return HAL_OK;
 800f9be:	2300      	movs	r3, #0
}
 800f9c0:	4618      	mov	r0, r3
 800f9c2:	3718      	adds	r7, #24
 800f9c4:	46bd      	mov	sp, r7
 800f9c6:	bd80      	pop	{r7, pc}

0800f9c8 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800f9c8:	b480      	push	{r7}
 800f9ca:	b083      	sub	sp, #12
 800f9cc:	af00      	add	r7, sp, #0
 800f9ce:	6078      	str	r0, [r7, #4]
 800f9d0:	460b      	mov	r3, r1
 800f9d2:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800f9d4:	78fb      	ldrb	r3, [r7, #3]
 800f9d6:	f003 0207 	and.w	r2, r3, #7
 800f9da:	6879      	ldr	r1, [r7, #4]
 800f9dc:	4613      	mov	r3, r2
 800f9de:	009b      	lsls	r3, r3, #2
 800f9e0:	4413      	add	r3, r2
 800f9e2:	00db      	lsls	r3, r3, #3
 800f9e4:	440b      	add	r3, r1
 800f9e6:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 800f9ea:	681b      	ldr	r3, [r3, #0]
}
 800f9ec:	4618      	mov	r0, r3
 800f9ee:	370c      	adds	r7, #12
 800f9f0:	46bd      	mov	sp, r7
 800f9f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9f6:	4770      	bx	lr

0800f9f8 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800f9f8:	b580      	push	{r7, lr}
 800f9fa:	b086      	sub	sp, #24
 800f9fc:	af00      	add	r7, sp, #0
 800f9fe:	60f8      	str	r0, [r7, #12]
 800fa00:	607a      	str	r2, [r7, #4]
 800fa02:	603b      	str	r3, [r7, #0]
 800fa04:	460b      	mov	r3, r1
 800fa06:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800fa08:	7afb      	ldrb	r3, [r7, #11]
 800fa0a:	f003 0307 	and.w	r3, r3, #7
 800fa0e:	1c5a      	adds	r2, r3, #1
 800fa10:	4613      	mov	r3, r2
 800fa12:	009b      	lsls	r3, r3, #2
 800fa14:	4413      	add	r3, r2
 800fa16:	00db      	lsls	r3, r3, #3
 800fa18:	68fa      	ldr	r2, [r7, #12]
 800fa1a:	4413      	add	r3, r2
 800fa1c:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800fa1e:	697b      	ldr	r3, [r7, #20]
 800fa20:	687a      	ldr	r2, [r7, #4]
 800fa22:	615a      	str	r2, [r3, #20]
  ep->xfer_len = len;
 800fa24:	697b      	ldr	r3, [r7, #20]
 800fa26:	683a      	ldr	r2, [r7, #0]
 800fa28:	619a      	str	r2, [r3, #24]
  ep->xfer_fill_db = 1U;
 800fa2a:	697b      	ldr	r3, [r7, #20]
 800fa2c:	2201      	movs	r2, #1
 800fa2e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  ep->xfer_len_db = len;
 800fa32:	697b      	ldr	r3, [r7, #20]
 800fa34:	683a      	ldr	r2, [r7, #0]
 800fa36:	621a      	str	r2, [r3, #32]
  ep->xfer_count = 0U;
 800fa38:	697b      	ldr	r3, [r7, #20]
 800fa3a:	2200      	movs	r2, #0
 800fa3c:	61da      	str	r2, [r3, #28]
  ep->is_in = 1U;
 800fa3e:	697b      	ldr	r3, [r7, #20]
 800fa40:	2201      	movs	r2, #1
 800fa42:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800fa44:	7afb      	ldrb	r3, [r7, #11]
 800fa46:	f003 0307 	and.w	r3, r3, #7
 800fa4a:	b2da      	uxtb	r2, r3
 800fa4c:	697b      	ldr	r3, [r7, #20]
 800fa4e:	701a      	strb	r2, [r3, #0]

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800fa50:	7afb      	ldrb	r3, [r7, #11]
 800fa52:	f003 0307 	and.w	r3, r3, #7
 800fa56:	2b00      	cmp	r3, #0
 800fa58:	d106      	bne.n	800fa68 <HAL_PCD_EP_Transmit+0x70>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 800fa5a:	68fb      	ldr	r3, [r7, #12]
 800fa5c:	681b      	ldr	r3, [r3, #0]
 800fa5e:	6979      	ldr	r1, [r7, #20]
 800fa60:	4618      	mov	r0, r3
 800fa62:	f007 fa1e 	bl	8016ea2 <USB_EPStartXfer>
 800fa66:	e005      	b.n	800fa74 <HAL_PCD_EP_Transmit+0x7c>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800fa68:	68fb      	ldr	r3, [r7, #12]
 800fa6a:	681b      	ldr	r3, [r3, #0]
 800fa6c:	6979      	ldr	r1, [r7, #20]
 800fa6e:	4618      	mov	r0, r3
 800fa70:	f007 fa17 	bl	8016ea2 <USB_EPStartXfer>
  }

  return HAL_OK;
 800fa74:	2300      	movs	r3, #0
}
 800fa76:	4618      	mov	r0, r3
 800fa78:	3718      	adds	r7, #24
 800fa7a:	46bd      	mov	sp, r7
 800fa7c:	bd80      	pop	{r7, pc}

0800fa7e <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800fa7e:	b580      	push	{r7, lr}
 800fa80:	b084      	sub	sp, #16
 800fa82:	af00      	add	r7, sp, #0
 800fa84:	6078      	str	r0, [r7, #4]
 800fa86:	460b      	mov	r3, r1
 800fa88:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800fa8a:	78fb      	ldrb	r3, [r7, #3]
 800fa8c:	f003 0207 	and.w	r2, r3, #7
 800fa90:	687b      	ldr	r3, [r7, #4]
 800fa92:	685b      	ldr	r3, [r3, #4]
 800fa94:	429a      	cmp	r2, r3
 800fa96:	d901      	bls.n	800fa9c <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 800fa98:	2301      	movs	r3, #1
 800fa9a:	e03e      	b.n	800fb1a <HAL_PCD_EP_SetStall+0x9c>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800fa9c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800faa0:	2b00      	cmp	r3, #0
 800faa2:	da0e      	bge.n	800fac2 <HAL_PCD_EP_SetStall+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800faa4:	78fb      	ldrb	r3, [r7, #3]
 800faa6:	f003 0307 	and.w	r3, r3, #7
 800faaa:	1c5a      	adds	r2, r3, #1
 800faac:	4613      	mov	r3, r2
 800faae:	009b      	lsls	r3, r3, #2
 800fab0:	4413      	add	r3, r2
 800fab2:	00db      	lsls	r3, r3, #3
 800fab4:	687a      	ldr	r2, [r7, #4]
 800fab6:	4413      	add	r3, r2
 800fab8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800faba:	68fb      	ldr	r3, [r7, #12]
 800fabc:	2201      	movs	r2, #1
 800fabe:	705a      	strb	r2, [r3, #1]
 800fac0:	e00c      	b.n	800fadc <HAL_PCD_EP_SetStall+0x5e>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800fac2:	78fa      	ldrb	r2, [r7, #3]
 800fac4:	4613      	mov	r3, r2
 800fac6:	009b      	lsls	r3, r3, #2
 800fac8:	4413      	add	r3, r2
 800faca:	00db      	lsls	r3, r3, #3
 800facc:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800fad0:	687a      	ldr	r2, [r7, #4]
 800fad2:	4413      	add	r3, r2
 800fad4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800fad6:	68fb      	ldr	r3, [r7, #12]
 800fad8:	2200      	movs	r2, #0
 800fada:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 800fadc:	68fb      	ldr	r3, [r7, #12]
 800fade:	2201      	movs	r2, #1
 800fae0:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800fae2:	78fb      	ldrb	r3, [r7, #3]
 800fae4:	f003 0307 	and.w	r3, r3, #7
 800fae8:	b2da      	uxtb	r2, r3
 800faea:	68fb      	ldr	r3, [r7, #12]
 800faec:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800faee:	687b      	ldr	r3, [r7, #4]
 800faf0:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800faf4:	2b01      	cmp	r3, #1
 800faf6:	d101      	bne.n	800fafc <HAL_PCD_EP_SetStall+0x7e>
 800faf8:	2302      	movs	r3, #2
 800fafa:	e00e      	b.n	800fb1a <HAL_PCD_EP_SetStall+0x9c>
 800fafc:	687b      	ldr	r3, [r7, #4]
 800fafe:	2201      	movs	r2, #1
 800fb00:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  (void)USB_EPSetStall(hpcd->Instance, ep);
 800fb04:	687b      	ldr	r3, [r7, #4]
 800fb06:	681b      	ldr	r3, [r3, #0]
 800fb08:	68f9      	ldr	r1, [r7, #12]
 800fb0a:	4618      	mov	r0, r3
 800fb0c:	f008 fa9b 	bl	8018046 <USB_EPSetStall>

  __HAL_UNLOCK(hpcd);
 800fb10:	687b      	ldr	r3, [r7, #4]
 800fb12:	2200      	movs	r2, #0
 800fb14:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  return HAL_OK;
 800fb18:	2300      	movs	r3, #0
}
 800fb1a:	4618      	mov	r0, r3
 800fb1c:	3710      	adds	r7, #16
 800fb1e:	46bd      	mov	sp, r7
 800fb20:	bd80      	pop	{r7, pc}

0800fb22 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800fb22:	b580      	push	{r7, lr}
 800fb24:	b084      	sub	sp, #16
 800fb26:	af00      	add	r7, sp, #0
 800fb28:	6078      	str	r0, [r7, #4]
 800fb2a:	460b      	mov	r3, r1
 800fb2c:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800fb2e:	78fb      	ldrb	r3, [r7, #3]
 800fb30:	f003 020f 	and.w	r2, r3, #15
 800fb34:	687b      	ldr	r3, [r7, #4]
 800fb36:	685b      	ldr	r3, [r3, #4]
 800fb38:	429a      	cmp	r2, r3
 800fb3a:	d901      	bls.n	800fb40 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 800fb3c:	2301      	movs	r3, #1
 800fb3e:	e040      	b.n	800fbc2 <HAL_PCD_EP_ClrStall+0xa0>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800fb40:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800fb44:	2b00      	cmp	r3, #0
 800fb46:	da0e      	bge.n	800fb66 <HAL_PCD_EP_ClrStall+0x44>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800fb48:	78fb      	ldrb	r3, [r7, #3]
 800fb4a:	f003 0307 	and.w	r3, r3, #7
 800fb4e:	1c5a      	adds	r2, r3, #1
 800fb50:	4613      	mov	r3, r2
 800fb52:	009b      	lsls	r3, r3, #2
 800fb54:	4413      	add	r3, r2
 800fb56:	00db      	lsls	r3, r3, #3
 800fb58:	687a      	ldr	r2, [r7, #4]
 800fb5a:	4413      	add	r3, r2
 800fb5c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800fb5e:	68fb      	ldr	r3, [r7, #12]
 800fb60:	2201      	movs	r2, #1
 800fb62:	705a      	strb	r2, [r3, #1]
 800fb64:	e00e      	b.n	800fb84 <HAL_PCD_EP_ClrStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800fb66:	78fb      	ldrb	r3, [r7, #3]
 800fb68:	f003 0207 	and.w	r2, r3, #7
 800fb6c:	4613      	mov	r3, r2
 800fb6e:	009b      	lsls	r3, r3, #2
 800fb70:	4413      	add	r3, r2
 800fb72:	00db      	lsls	r3, r3, #3
 800fb74:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800fb78:	687a      	ldr	r2, [r7, #4]
 800fb7a:	4413      	add	r3, r2
 800fb7c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800fb7e:	68fb      	ldr	r3, [r7, #12]
 800fb80:	2200      	movs	r2, #0
 800fb82:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 800fb84:	68fb      	ldr	r3, [r7, #12]
 800fb86:	2200      	movs	r2, #0
 800fb88:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800fb8a:	78fb      	ldrb	r3, [r7, #3]
 800fb8c:	f003 0307 	and.w	r3, r3, #7
 800fb90:	b2da      	uxtb	r2, r3
 800fb92:	68fb      	ldr	r3, [r7, #12]
 800fb94:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800fb96:	687b      	ldr	r3, [r7, #4]
 800fb98:	f893 32a8 	ldrb.w	r3, [r3, #680]	; 0x2a8
 800fb9c:	2b01      	cmp	r3, #1
 800fb9e:	d101      	bne.n	800fba4 <HAL_PCD_EP_ClrStall+0x82>
 800fba0:	2302      	movs	r3, #2
 800fba2:	e00e      	b.n	800fbc2 <HAL_PCD_EP_ClrStall+0xa0>
 800fba4:	687b      	ldr	r3, [r7, #4]
 800fba6:	2201      	movs	r2, #1
 800fba8:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800fbac:	687b      	ldr	r3, [r7, #4]
 800fbae:	681b      	ldr	r3, [r3, #0]
 800fbb0:	68f9      	ldr	r1, [r7, #12]
 800fbb2:	4618      	mov	r0, r3
 800fbb4:	f008 fa98 	bl	80180e8 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 800fbb8:	687b      	ldr	r3, [r7, #4]
 800fbba:	2200      	movs	r2, #0
 800fbbc:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

  return HAL_OK;
 800fbc0:	2300      	movs	r3, #0
}
 800fbc2:	4618      	mov	r0, r3
 800fbc4:	3710      	adds	r7, #16
 800fbc6:	46bd      	mov	sp, r7
 800fbc8:	bd80      	pop	{r7, pc}

0800fbca <PCD_EP_ISR_Handler>:
  * @brief  This function handles PCD Endpoint interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
 800fbca:	b580      	push	{r7, lr}
 800fbcc:	b096      	sub	sp, #88	; 0x58
 800fbce:	af00      	add	r7, sp, #0
 800fbd0:	6078      	str	r0, [r7, #4]
  uint16_t wEPVal;
  uint16_t TxPctSize;
  uint8_t epindex;

  /* stay in loop while pending interrupts */
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800fbd2:	e39c      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
  {
    wIstr = hpcd->Instance->ISTR;
 800fbd4:	687b      	ldr	r3, [r7, #4]
 800fbd6:	681b      	ldr	r3, [r3, #0]
 800fbd8:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800fbdc:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 800fbe0:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 800fbe4:	b2db      	uxtb	r3, r3
 800fbe6:	f003 030f 	and.w	r3, r3, #15
 800fbea:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55

    if (epindex == 0U)
 800fbee:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 800fbf2:	2b00      	cmp	r3, #0
 800fbf4:	f040 815e 	bne.w	800feb4 <PCD_EP_ISR_Handler+0x2ea>
    {
      /* Decode and service control endpoint interrupt */

      /* DIR bit = origin of the interrupt */
      if ((wIstr & USB_ISTR_DIR) == 0U)
 800fbf8:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 800fbfc:	f003 0310 	and.w	r3, r3, #16
 800fc00:	2b00      	cmp	r3, #0
 800fc02:	d150      	bne.n	800fca6 <PCD_EP_ISR_Handler+0xdc>
      {
        /* DIR = 0 */

        /* DIR = 0 => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800fc04:	687b      	ldr	r3, [r7, #4]
 800fc06:	681b      	ldr	r3, [r3, #0]
 800fc08:	881b      	ldrh	r3, [r3, #0]
 800fc0a:	b29b      	uxth	r3, r3
 800fc0c:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 800fc10:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fc14:	81fb      	strh	r3, [r7, #14]
 800fc16:	687b      	ldr	r3, [r7, #4]
 800fc18:	681a      	ldr	r2, [r3, #0]
 800fc1a:	89fb      	ldrh	r3, [r7, #14]
 800fc1c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800fc20:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800fc24:	b29b      	uxth	r3, r3
 800fc26:	8013      	strh	r3, [r2, #0]
        ep = &hpcd->IN_ep[0];
 800fc28:	687b      	ldr	r3, [r7, #4]
 800fc2a:	3328      	adds	r3, #40	; 0x28
 800fc2c:	64fb      	str	r3, [r7, #76]	; 0x4c

        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800fc2e:	687b      	ldr	r3, [r7, #4]
 800fc30:	681b      	ldr	r3, [r3, #0]
 800fc32:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fc36:	b29b      	uxth	r3, r3
 800fc38:	461a      	mov	r2, r3
 800fc3a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc3c:	781b      	ldrb	r3, [r3, #0]
 800fc3e:	00db      	lsls	r3, r3, #3
 800fc40:	4413      	add	r3, r2
 800fc42:	687a      	ldr	r2, [r7, #4]
 800fc44:	6812      	ldr	r2, [r2, #0]
 800fc46:	4413      	add	r3, r2
 800fc48:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800fc4c:	881b      	ldrh	r3, [r3, #0]
 800fc4e:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800fc52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc54:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += ep->xfer_count;
 800fc56:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc58:	695a      	ldr	r2, [r3, #20]
 800fc5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc5c:	69db      	ldr	r3, [r3, #28]
 800fc5e:	441a      	add	r2, r3
 800fc60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc62:	615a      	str	r2, [r3, #20]

        /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataInStageCallback(hpcd, 0U);
#else
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 800fc64:	2100      	movs	r1, #0
 800fc66:	6878      	ldr	r0, [r7, #4]
 800fc68:	f019 f80b 	bl	8028c82 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 800fc6c:	687b      	ldr	r3, [r7, #4]
 800fc6e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fc72:	b2db      	uxtb	r3, r3
 800fc74:	2b00      	cmp	r3, #0
 800fc76:	f000 834a 	beq.w	801030e <PCD_EP_ISR_Handler+0x744>
 800fc7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc7c:	699b      	ldr	r3, [r3, #24]
 800fc7e:	2b00      	cmp	r3, #0
 800fc80:	f040 8345 	bne.w	801030e <PCD_EP_ISR_Handler+0x744>
        {
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 800fc84:	687b      	ldr	r3, [r7, #4]
 800fc86:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fc8a:	b2db      	uxtb	r3, r3
 800fc8c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800fc90:	b2da      	uxtb	r2, r3
 800fc92:	687b      	ldr	r3, [r7, #4]
 800fc94:	681b      	ldr	r3, [r3, #0]
 800fc96:	b292      	uxth	r2, r2
 800fc98:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
          hpcd->USB_Address = 0U;
 800fc9c:	687b      	ldr	r3, [r7, #4]
 800fc9e:	2200      	movs	r2, #0
 800fca0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 800fca4:	e333      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
      {
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
 800fca6:	687b      	ldr	r3, [r7, #4]
 800fca8:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800fcac:	64fb      	str	r3, [r7, #76]	; 0x4c
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800fcae:	687b      	ldr	r3, [r7, #4]
 800fcb0:	681b      	ldr	r3, [r3, #0]
 800fcb2:	881b      	ldrh	r3, [r3, #0]
 800fcb4:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

        if ((wEPVal & USB_EP_SETUP) != 0U)
 800fcb8:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800fcbc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800fcc0:	2b00      	cmp	r3, #0
 800fcc2:	d032      	beq.n	800fd2a <PCD_EP_ISR_Handler+0x160>
        {
          /* Get SETUP Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800fcc4:	687b      	ldr	r3, [r7, #4]
 800fcc6:	681b      	ldr	r3, [r3, #0]
 800fcc8:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fccc:	b29b      	uxth	r3, r3
 800fcce:	461a      	mov	r2, r3
 800fcd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcd2:	781b      	ldrb	r3, [r3, #0]
 800fcd4:	00db      	lsls	r3, r3, #3
 800fcd6:	4413      	add	r3, r2
 800fcd8:	687a      	ldr	r2, [r7, #4]
 800fcda:	6812      	ldr	r2, [r2, #0]
 800fcdc:	4413      	add	r3, r2
 800fcde:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800fce2:	881b      	ldrh	r3, [r3, #0]
 800fce4:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800fce8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcea:	61da      	str	r2, [r3, #28]

          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800fcec:	687b      	ldr	r3, [r7, #4]
 800fcee:	6818      	ldr	r0, [r3, #0]
 800fcf0:	687b      	ldr	r3, [r7, #4]
 800fcf2:	f503 712c 	add.w	r1, r3, #688	; 0x2b0
 800fcf6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcf8:	88da      	ldrh	r2, [r3, #6]
                      ep->pmaadress, (uint16_t)ep->xfer_count);
 800fcfa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcfc:	69db      	ldr	r3, [r3, #28]
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800fcfe:	b29b      	uxth	r3, r3
 800fd00:	f008 fb1d 	bl	801833e <USB_ReadPMA>

          /* SETUP bit kept frozen while CTR_RX = 1 */
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800fd04:	687b      	ldr	r3, [r7, #4]
 800fd06:	681b      	ldr	r3, [r3, #0]
 800fd08:	881b      	ldrh	r3, [r3, #0]
 800fd0a:	b29a      	uxth	r2, r3
 800fd0c:	f640 738f 	movw	r3, #3983	; 0xf8f
 800fd10:	4013      	ands	r3, r2
 800fd12:	823b      	strh	r3, [r7, #16]
 800fd14:	687b      	ldr	r3, [r7, #4]
 800fd16:	681b      	ldr	r3, [r3, #0]
 800fd18:	8a3a      	ldrh	r2, [r7, #16]
 800fd1a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800fd1e:	b292      	uxth	r2, r2
 800fd20:	801a      	strh	r2, [r3, #0]

          /* Process SETUP Packet*/
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->SetupStageCallback(hpcd);
#else
          HAL_PCD_SetupStageCallback(hpcd);
 800fd22:	6878      	ldr	r0, [r7, #4]
 800fd24:	f018 ff80 	bl	8028c28 <HAL_PCD_SetupStageCallback>
 800fd28:	e2f1      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800fd2a:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 800fd2e:	2b00      	cmp	r3, #0
 800fd30:	f280 82ed 	bge.w	801030e <PCD_EP_ISR_Handler+0x744>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800fd34:	687b      	ldr	r3, [r7, #4]
 800fd36:	681b      	ldr	r3, [r3, #0]
 800fd38:	881b      	ldrh	r3, [r3, #0]
 800fd3a:	b29a      	uxth	r2, r3
 800fd3c:	f640 738f 	movw	r3, #3983	; 0xf8f
 800fd40:	4013      	ands	r3, r2
 800fd42:	83fb      	strh	r3, [r7, #30]
 800fd44:	687b      	ldr	r3, [r7, #4]
 800fd46:	681b      	ldr	r3, [r3, #0]
 800fd48:	8bfa      	ldrh	r2, [r7, #30]
 800fd4a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800fd4e:	b292      	uxth	r2, r2
 800fd50:	801a      	strh	r2, [r3, #0]

          /* Get Control Data OUT Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800fd52:	687b      	ldr	r3, [r7, #4]
 800fd54:	681b      	ldr	r3, [r3, #0]
 800fd56:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fd5a:	b29b      	uxth	r3, r3
 800fd5c:	461a      	mov	r2, r3
 800fd5e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd60:	781b      	ldrb	r3, [r3, #0]
 800fd62:	00db      	lsls	r3, r3, #3
 800fd64:	4413      	add	r3, r2
 800fd66:	687a      	ldr	r2, [r7, #4]
 800fd68:	6812      	ldr	r2, [r2, #0]
 800fd6a:	4413      	add	r3, r2
 800fd6c:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800fd70:	881b      	ldrh	r3, [r3, #0]
 800fd72:	f3c3 0209 	ubfx	r2, r3, #0, #10
 800fd76:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd78:	61da      	str	r2, [r3, #28]

          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800fd7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd7c:	69db      	ldr	r3, [r3, #28]
 800fd7e:	2b00      	cmp	r3, #0
 800fd80:	d019      	beq.n	800fdb6 <PCD_EP_ISR_Handler+0x1ec>
 800fd82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd84:	695b      	ldr	r3, [r3, #20]
 800fd86:	2b00      	cmp	r3, #0
 800fd88:	d015      	beq.n	800fdb6 <PCD_EP_ISR_Handler+0x1ec>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800fd8a:	687b      	ldr	r3, [r7, #4]
 800fd8c:	6818      	ldr	r0, [r3, #0]
 800fd8e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd90:	6959      	ldr	r1, [r3, #20]
 800fd92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd94:	88da      	ldrh	r2, [r3, #6]
                        ep->pmaadress, (uint16_t)ep->xfer_count);
 800fd96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fd98:	69db      	ldr	r3, [r3, #28]
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800fd9a:	b29b      	uxth	r3, r3
 800fd9c:	f008 facf 	bl	801833e <USB_ReadPMA>

            ep->xfer_buff += ep->xfer_count;
 800fda0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fda2:	695a      	ldr	r2, [r3, #20]
 800fda4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fda6:	69db      	ldr	r3, [r3, #28]
 800fda8:	441a      	add	r2, r3
 800fdaa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fdac:	615a      	str	r2, [r3, #20]

            /* Process Control Data OUT Packet */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataOutStageCallback(hpcd, 0U);
#else
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800fdae:	2100      	movs	r1, #0
 800fdb0:	6878      	ldr	r0, [r7, #4]
 800fdb2:	f018 ff4b 	bl	8028c4c <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }

          if ((PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0) & USB_EP_SETUP) == 0U)
 800fdb6:	687b      	ldr	r3, [r7, #4]
 800fdb8:	681b      	ldr	r3, [r3, #0]
 800fdba:	881b      	ldrh	r3, [r3, #0]
 800fdbc:	b29b      	uxth	r3, r3
 800fdbe:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800fdc2:	2b00      	cmp	r3, #0
 800fdc4:	f040 82a3 	bne.w	801030e <PCD_EP_ISR_Handler+0x744>
          {
            PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800fdc8:	687b      	ldr	r3, [r7, #4]
 800fdca:	681b      	ldr	r3, [r3, #0]
 800fdcc:	61bb      	str	r3, [r7, #24]
 800fdce:	687b      	ldr	r3, [r7, #4]
 800fdd0:	681b      	ldr	r3, [r3, #0]
 800fdd2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fdd6:	b29b      	uxth	r3, r3
 800fdd8:	461a      	mov	r2, r3
 800fdda:	69bb      	ldr	r3, [r7, #24]
 800fddc:	4413      	add	r3, r2
 800fdde:	61bb      	str	r3, [r7, #24]
 800fde0:	69bb      	ldr	r3, [r7, #24]
 800fde2:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800fde6:	617b      	str	r3, [r7, #20]
 800fde8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fdea:	691b      	ldr	r3, [r3, #16]
 800fdec:	2b3e      	cmp	r3, #62	; 0x3e
 800fdee:	d918      	bls.n	800fe22 <PCD_EP_ISR_Handler+0x258>
 800fdf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fdf2:	691b      	ldr	r3, [r3, #16]
 800fdf4:	095b      	lsrs	r3, r3, #5
 800fdf6:	647b      	str	r3, [r7, #68]	; 0x44
 800fdf8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fdfa:	691b      	ldr	r3, [r3, #16]
 800fdfc:	f003 031f 	and.w	r3, r3, #31
 800fe00:	2b00      	cmp	r3, #0
 800fe02:	d102      	bne.n	800fe0a <PCD_EP_ISR_Handler+0x240>
 800fe04:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fe06:	3b01      	subs	r3, #1
 800fe08:	647b      	str	r3, [r7, #68]	; 0x44
 800fe0a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fe0c:	b29b      	uxth	r3, r3
 800fe0e:	029b      	lsls	r3, r3, #10
 800fe10:	b29b      	uxth	r3, r3
 800fe12:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800fe16:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800fe1a:	b29a      	uxth	r2, r3
 800fe1c:	697b      	ldr	r3, [r7, #20]
 800fe1e:	801a      	strh	r2, [r3, #0]
 800fe20:	e029      	b.n	800fe76 <PCD_EP_ISR_Handler+0x2ac>
 800fe22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fe24:	691b      	ldr	r3, [r3, #16]
 800fe26:	2b00      	cmp	r3, #0
 800fe28:	d112      	bne.n	800fe50 <PCD_EP_ISR_Handler+0x286>
 800fe2a:	697b      	ldr	r3, [r7, #20]
 800fe2c:	881b      	ldrh	r3, [r3, #0]
 800fe2e:	b29b      	uxth	r3, r3
 800fe30:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 800fe34:	b29a      	uxth	r2, r3
 800fe36:	697b      	ldr	r3, [r7, #20]
 800fe38:	801a      	strh	r2, [r3, #0]
 800fe3a:	697b      	ldr	r3, [r7, #20]
 800fe3c:	881b      	ldrh	r3, [r3, #0]
 800fe3e:	b29b      	uxth	r3, r3
 800fe40:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800fe44:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800fe48:	b29a      	uxth	r2, r3
 800fe4a:	697b      	ldr	r3, [r7, #20]
 800fe4c:	801a      	strh	r2, [r3, #0]
 800fe4e:	e012      	b.n	800fe76 <PCD_EP_ISR_Handler+0x2ac>
 800fe50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fe52:	691b      	ldr	r3, [r3, #16]
 800fe54:	085b      	lsrs	r3, r3, #1
 800fe56:	647b      	str	r3, [r7, #68]	; 0x44
 800fe58:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fe5a:	691b      	ldr	r3, [r3, #16]
 800fe5c:	f003 0301 	and.w	r3, r3, #1
 800fe60:	2b00      	cmp	r3, #0
 800fe62:	d002      	beq.n	800fe6a <PCD_EP_ISR_Handler+0x2a0>
 800fe64:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fe66:	3301      	adds	r3, #1
 800fe68:	647b      	str	r3, [r7, #68]	; 0x44
 800fe6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800fe6c:	b29b      	uxth	r3, r3
 800fe6e:	029b      	lsls	r3, r3, #10
 800fe70:	b29a      	uxth	r2, r3
 800fe72:	697b      	ldr	r3, [r7, #20]
 800fe74:	801a      	strh	r2, [r3, #0]
            PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 800fe76:	687b      	ldr	r3, [r7, #4]
 800fe78:	681b      	ldr	r3, [r3, #0]
 800fe7a:	881b      	ldrh	r3, [r3, #0]
 800fe7c:	b29b      	uxth	r3, r3
 800fe7e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800fe82:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800fe86:	827b      	strh	r3, [r7, #18]
 800fe88:	8a7b      	ldrh	r3, [r7, #18]
 800fe8a:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800fe8e:	827b      	strh	r3, [r7, #18]
 800fe90:	8a7b      	ldrh	r3, [r7, #18]
 800fe92:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800fe96:	827b      	strh	r3, [r7, #18]
 800fe98:	687b      	ldr	r3, [r7, #4]
 800fe9a:	681a      	ldr	r2, [r3, #0]
 800fe9c:	8a7b      	ldrh	r3, [r7, #18]
 800fe9e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800fea2:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800fea6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800feaa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800feae:	b29b      	uxth	r3, r3
 800feb0:	8013      	strh	r3, [r2, #0]
 800feb2:	e22c      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
    }
    else
    {
      /* Decode and service non control endpoints interrupt */
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 800feb4:	687b      	ldr	r3, [r7, #4]
 800feb6:	681b      	ldr	r3, [r3, #0]
 800feb8:	461a      	mov	r2, r3
 800feba:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 800febe:	009b      	lsls	r3, r3, #2
 800fec0:	4413      	add	r3, r2
 800fec2:	881b      	ldrh	r3, [r3, #0]
 800fec4:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800fec8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 800fecc:	2b00      	cmp	r3, #0
 800fece:	f280 80f6 	bge.w	80100be <PCD_EP_ISR_Handler+0x4f4>
      {
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800fed2:	687b      	ldr	r3, [r7, #4]
 800fed4:	681b      	ldr	r3, [r3, #0]
 800fed6:	461a      	mov	r2, r3
 800fed8:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 800fedc:	009b      	lsls	r3, r3, #2
 800fede:	4413      	add	r3, r2
 800fee0:	881b      	ldrh	r3, [r3, #0]
 800fee2:	b29a      	uxth	r2, r3
 800fee4:	f640 738f 	movw	r3, #3983	; 0xf8f
 800fee8:	4013      	ands	r3, r2
 800feea:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 800feee:	687b      	ldr	r3, [r7, #4]
 800fef0:	681b      	ldr	r3, [r3, #0]
 800fef2:	461a      	mov	r2, r3
 800fef4:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 800fef8:	009b      	lsls	r3, r3, #2
 800fefa:	4413      	add	r3, r2
 800fefc:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 800ff00:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ff04:	b292      	uxth	r2, r2
 800ff06:	801a      	strh	r2, [r3, #0]
        ep = &hpcd->OUT_ep[epindex];
 800ff08:	f897 2055 	ldrb.w	r2, [r7, #85]	; 0x55
 800ff0c:	4613      	mov	r3, r2
 800ff0e:	009b      	lsls	r3, r3, #2
 800ff10:	4413      	add	r3, r2
 800ff12:	00db      	lsls	r3, r3, #3
 800ff14:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800ff18:	687a      	ldr	r2, [r7, #4]
 800ff1a:	4413      	add	r3, r2
 800ff1c:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* OUT Single Buffering */
        if (ep->doublebuffer == 0U)
 800ff1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff20:	7b1b      	ldrb	r3, [r3, #12]
 800ff22:	2b00      	cmp	r3, #0
 800ff24:	d123      	bne.n	800ff6e <PCD_EP_ISR_Handler+0x3a4>
        {
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800ff26:	687b      	ldr	r3, [r7, #4]
 800ff28:	681b      	ldr	r3, [r3, #0]
 800ff2a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800ff2e:	b29b      	uxth	r3, r3
 800ff30:	461a      	mov	r2, r3
 800ff32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff34:	781b      	ldrb	r3, [r3, #0]
 800ff36:	00db      	lsls	r3, r3, #3
 800ff38:	4413      	add	r3, r2
 800ff3a:	687a      	ldr	r2, [r7, #4]
 800ff3c:	6812      	ldr	r2, [r2, #0]
 800ff3e:	4413      	add	r3, r2
 800ff40:	f203 4306 	addw	r3, r3, #1030	; 0x406
 800ff44:	881b      	ldrh	r3, [r3, #0]
 800ff46:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800ff4a:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48

          if (count != 0U)
 800ff4e:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 800ff52:	2b00      	cmp	r3, #0
 800ff54:	f000 808e 	beq.w	8010074 <PCD_EP_ISR_Handler+0x4aa>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 800ff58:	687b      	ldr	r3, [r7, #4]
 800ff5a:	6818      	ldr	r0, [r3, #0]
 800ff5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff5e:	6959      	ldr	r1, [r3, #20]
 800ff60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff62:	88da      	ldrh	r2, [r3, #6]
 800ff64:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 800ff68:	f008 f9e9 	bl	801833e <USB_ReadPMA>
 800ff6c:	e082      	b.n	8010074 <PCD_EP_ISR_Handler+0x4aa>
        }
#if (USE_USB_DOUBLE_BUFFER == 1U)
        else
        {
          /* manage double buffer bulk out */
          if (ep->type == EP_TYPE_BULK)
 800ff6e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff70:	78db      	ldrb	r3, [r3, #3]
 800ff72:	2b02      	cmp	r3, #2
 800ff74:	d10a      	bne.n	800ff8c <PCD_EP_ISR_Handler+0x3c2>
          {
            count = HAL_PCD_EP_DB_Receive(hpcd, ep, wEPVal);
 800ff76:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800ff7a:	461a      	mov	r2, r3
 800ff7c:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800ff7e:	6878      	ldr	r0, [r7, #4]
 800ff80:	f000 f9d3 	bl	801032a <HAL_PCD_EP_DB_Receive>
 800ff84:	4603      	mov	r3, r0
 800ff86:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 800ff8a:	e073      	b.n	8010074 <PCD_EP_ISR_Handler+0x4aa>
          }
          else /* manage double buffer iso out */
          {
            /* free EP OUT Buffer */
            PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 800ff8c:	687b      	ldr	r3, [r7, #4]
 800ff8e:	681b      	ldr	r3, [r3, #0]
 800ff90:	461a      	mov	r2, r3
 800ff92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ff94:	781b      	ldrb	r3, [r3, #0]
 800ff96:	009b      	lsls	r3, r3, #2
 800ff98:	4413      	add	r3, r2
 800ff9a:	881b      	ldrh	r3, [r3, #0]
 800ff9c:	b29b      	uxth	r3, r3
 800ff9e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800ffa2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800ffa6:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 800ffaa:	687b      	ldr	r3, [r7, #4]
 800ffac:	681b      	ldr	r3, [r3, #0]
 800ffae:	461a      	mov	r2, r3
 800ffb0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ffb2:	781b      	ldrb	r3, [r3, #0]
 800ffb4:	009b      	lsls	r3, r3, #2
 800ffb6:	441a      	add	r2, r3
 800ffb8:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 800ffbc:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800ffc0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 800ffc4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800ffc8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800ffcc:	b29b      	uxth	r3, r3
 800ffce:	8013      	strh	r3, [r2, #0]

            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800ffd0:	687b      	ldr	r3, [r7, #4]
 800ffd2:	681b      	ldr	r3, [r3, #0]
 800ffd4:	461a      	mov	r2, r3
 800ffd6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ffd8:	781b      	ldrb	r3, [r3, #0]
 800ffda:	009b      	lsls	r3, r3, #2
 800ffdc:	4413      	add	r3, r2
 800ffde:	881b      	ldrh	r3, [r3, #0]
 800ffe0:	b29b      	uxth	r3, r3
 800ffe2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800ffe6:	2b00      	cmp	r3, #0
 800ffe8:	d022      	beq.n	8010030 <PCD_EP_ISR_Handler+0x466>
            {
              /* read from endpoint BUF0Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800ffea:	687b      	ldr	r3, [r7, #4]
 800ffec:	681b      	ldr	r3, [r3, #0]
 800ffee:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800fff2:	b29b      	uxth	r3, r3
 800fff4:	461a      	mov	r2, r3
 800fff6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fff8:	781b      	ldrb	r3, [r3, #0]
 800fffa:	00db      	lsls	r3, r3, #3
 800fffc:	4413      	add	r3, r2
 800fffe:	687a      	ldr	r2, [r7, #4]
 8010000:	6812      	ldr	r2, [r2, #0]
 8010002:	4413      	add	r3, r2
 8010004:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010008:	881b      	ldrh	r3, [r3, #0]
 801000a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801000e:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48

              if (count != 0U)
 8010012:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 8010016:	2b00      	cmp	r3, #0
 8010018:	d02c      	beq.n	8010074 <PCD_EP_ISR_Handler+0x4aa>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 801001a:	687b      	ldr	r3, [r7, #4]
 801001c:	6818      	ldr	r0, [r3, #0]
 801001e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010020:	6959      	ldr	r1, [r3, #20]
 8010022:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010024:	891a      	ldrh	r2, [r3, #8]
 8010026:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801002a:	f008 f988 	bl	801833e <USB_ReadPMA>
 801002e:	e021      	b.n	8010074 <PCD_EP_ISR_Handler+0x4aa>
              }
            }
            else
            {
              /* read from endpoint BUF1Addr buffer */
              count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8010030:	687b      	ldr	r3, [r7, #4]
 8010032:	681b      	ldr	r3, [r3, #0]
 8010034:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010038:	b29b      	uxth	r3, r3
 801003a:	461a      	mov	r2, r3
 801003c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801003e:	781b      	ldrb	r3, [r3, #0]
 8010040:	00db      	lsls	r3, r3, #3
 8010042:	4413      	add	r3, r2
 8010044:	687a      	ldr	r2, [r7, #4]
 8010046:	6812      	ldr	r2, [r2, #0]
 8010048:	4413      	add	r3, r2
 801004a:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801004e:	881b      	ldrh	r3, [r3, #0]
 8010050:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010054:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48

              if (count != 0U)
 8010058:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801005c:	2b00      	cmp	r3, #0
 801005e:	d009      	beq.n	8010074 <PCD_EP_ISR_Handler+0x4aa>
              {
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8010060:	687b      	ldr	r3, [r7, #4]
 8010062:	6818      	ldr	r0, [r3, #0]
 8010064:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010066:	6959      	ldr	r1, [r3, #20]
 8010068:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801006a:	895a      	ldrh	r2, [r3, #10]
 801006c:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 8010070:	f008 f965 	bl	801833e <USB_ReadPMA>
          }
        }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

        /* multi-packet on the NON control OUT endpoint */
        ep->xfer_count += count;
 8010074:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010076:	69da      	ldr	r2, [r3, #28]
 8010078:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801007c:	441a      	add	r2, r3
 801007e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010080:	61da      	str	r2, [r3, #28]
        ep->xfer_buff += count;
 8010082:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010084:	695a      	ldr	r2, [r3, #20]
 8010086:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 801008a:	441a      	add	r2, r3
 801008c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801008e:	615a      	str	r2, [r3, #20]

        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 8010090:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010092:	699b      	ldr	r3, [r3, #24]
 8010094:	2b00      	cmp	r3, #0
 8010096:	d005      	beq.n	80100a4 <PCD_EP_ISR_Handler+0x4da>
 8010098:	f8b7 2048 	ldrh.w	r2, [r7, #72]	; 0x48
 801009c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801009e:	691b      	ldr	r3, [r3, #16]
 80100a0:	429a      	cmp	r2, r3
 80100a2:	d206      	bcs.n	80100b2 <PCD_EP_ISR_Handler+0x4e8>
        {
          /* RX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataOutStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80100a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100a6:	781b      	ldrb	r3, [r3, #0]
 80100a8:	4619      	mov	r1, r3
 80100aa:	6878      	ldr	r0, [r7, #4]
 80100ac:	f018 fdce 	bl	8028c4c <HAL_PCD_DataOutStageCallback>
 80100b0:	e005      	b.n	80100be <PCD_EP_ISR_Handler+0x4f4>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          (void) USB_EPStartXfer(hpcd->Instance, ep);
 80100b2:	687b      	ldr	r3, [r7, #4]
 80100b4:	681b      	ldr	r3, [r3, #0]
 80100b6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80100b8:	4618      	mov	r0, r3
 80100ba:	f006 fef2 	bl	8016ea2 <USB_EPStartXfer>
        }
      }

      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 80100be:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 80100c2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80100c6:	2b00      	cmp	r3, #0
 80100c8:	f000 8121 	beq.w	801030e <PCD_EP_ISR_Handler+0x744>
      {
        ep = &hpcd->IN_ep[epindex];
 80100cc:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 80100d0:	1c5a      	adds	r2, r3, #1
 80100d2:	4613      	mov	r3, r2
 80100d4:	009b      	lsls	r3, r3, #2
 80100d6:	4413      	add	r3, r2
 80100d8:	00db      	lsls	r3, r3, #3
 80100da:	687a      	ldr	r2, [r7, #4]
 80100dc:	4413      	add	r3, r2
 80100de:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 80100e0:	687b      	ldr	r3, [r7, #4]
 80100e2:	681b      	ldr	r3, [r3, #0]
 80100e4:	461a      	mov	r2, r3
 80100e6:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 80100ea:	009b      	lsls	r3, r3, #2
 80100ec:	4413      	add	r3, r2
 80100ee:	881b      	ldrh	r3, [r3, #0]
 80100f0:	b29b      	uxth	r3, r3
 80100f2:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 80100f6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80100fa:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 80100fe:	687b      	ldr	r3, [r7, #4]
 8010100:	681b      	ldr	r3, [r3, #0]
 8010102:	461a      	mov	r2, r3
 8010104:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
 8010108:	009b      	lsls	r3, r3, #2
 801010a:	441a      	add	r2, r3
 801010c:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8010110:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010114:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010118:	b29b      	uxth	r3, r3
 801011a:	8013      	strh	r3, [r2, #0]

        if (ep->type != EP_TYPE_BULK)
 801011c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801011e:	78db      	ldrb	r3, [r3, #3]
 8010120:	2b02      	cmp	r3, #2
 8010122:	f000 80a2 	beq.w	801026a <PCD_EP_ISR_Handler+0x6a0>
        {
          ep->xfer_len = 0U;
 8010126:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010128:	2200      	movs	r2, #0
 801012a:	619a      	str	r2, [r3, #24]

#if (USE_USB_DOUBLE_BUFFER == 1U)
          if (ep->doublebuffer != 0U)
 801012c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801012e:	7b1b      	ldrb	r3, [r3, #12]
 8010130:	2b00      	cmp	r3, #0
 8010132:	f000 8093 	beq.w	801025c <PCD_EP_ISR_Handler+0x692>
          {
            if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 8010136:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801013a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801013e:	2b00      	cmp	r3, #0
 8010140:	d046      	beq.n	80101d0 <PCD_EP_ISR_Handler+0x606>
            {
              PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8010142:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010144:	785b      	ldrb	r3, [r3, #1]
 8010146:	2b00      	cmp	r3, #0
 8010148:	d126      	bne.n	8010198 <PCD_EP_ISR_Handler+0x5ce>
 801014a:	687b      	ldr	r3, [r7, #4]
 801014c:	681b      	ldr	r3, [r3, #0]
 801014e:	627b      	str	r3, [r7, #36]	; 0x24
 8010150:	687b      	ldr	r3, [r7, #4]
 8010152:	681b      	ldr	r3, [r3, #0]
 8010154:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010158:	b29b      	uxth	r3, r3
 801015a:	461a      	mov	r2, r3
 801015c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801015e:	4413      	add	r3, r2
 8010160:	627b      	str	r3, [r7, #36]	; 0x24
 8010162:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010164:	781b      	ldrb	r3, [r3, #0]
 8010166:	00da      	lsls	r2, r3, #3
 8010168:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801016a:	4413      	add	r3, r2
 801016c:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010170:	623b      	str	r3, [r7, #32]
 8010172:	6a3b      	ldr	r3, [r7, #32]
 8010174:	881b      	ldrh	r3, [r3, #0]
 8010176:	b29b      	uxth	r3, r3
 8010178:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 801017c:	b29a      	uxth	r2, r3
 801017e:	6a3b      	ldr	r3, [r7, #32]
 8010180:	801a      	strh	r2, [r3, #0]
 8010182:	6a3b      	ldr	r3, [r7, #32]
 8010184:	881b      	ldrh	r3, [r3, #0]
 8010186:	b29b      	uxth	r3, r3
 8010188:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801018c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010190:	b29a      	uxth	r2, r3
 8010192:	6a3b      	ldr	r3, [r7, #32]
 8010194:	801a      	strh	r2, [r3, #0]
 8010196:	e061      	b.n	801025c <PCD_EP_ISR_Handler+0x692>
 8010198:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801019a:	785b      	ldrb	r3, [r3, #1]
 801019c:	2b01      	cmp	r3, #1
 801019e:	d15d      	bne.n	801025c <PCD_EP_ISR_Handler+0x692>
 80101a0:	687b      	ldr	r3, [r7, #4]
 80101a2:	681b      	ldr	r3, [r3, #0]
 80101a4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80101a6:	687b      	ldr	r3, [r7, #4]
 80101a8:	681b      	ldr	r3, [r3, #0]
 80101aa:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80101ae:	b29b      	uxth	r3, r3
 80101b0:	461a      	mov	r2, r3
 80101b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101b4:	4413      	add	r3, r2
 80101b6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80101b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101ba:	781b      	ldrb	r3, [r3, #0]
 80101bc:	00da      	lsls	r2, r3, #3
 80101be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101c0:	4413      	add	r3, r2
 80101c2:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80101c6:	62bb      	str	r3, [r7, #40]	; 0x28
 80101c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80101ca:	2200      	movs	r2, #0
 80101cc:	801a      	strh	r2, [r3, #0]
 80101ce:	e045      	b.n	801025c <PCD_EP_ISR_Handler+0x692>
            }
            else
            {
              PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 80101d0:	687b      	ldr	r3, [r7, #4]
 80101d2:	681b      	ldr	r3, [r3, #0]
 80101d4:	63fb      	str	r3, [r7, #60]	; 0x3c
 80101d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101d8:	785b      	ldrb	r3, [r3, #1]
 80101da:	2b00      	cmp	r3, #0
 80101dc:	d126      	bne.n	801022c <PCD_EP_ISR_Handler+0x662>
 80101de:	687b      	ldr	r3, [r7, #4]
 80101e0:	681b      	ldr	r3, [r3, #0]
 80101e2:	637b      	str	r3, [r7, #52]	; 0x34
 80101e4:	687b      	ldr	r3, [r7, #4]
 80101e6:	681b      	ldr	r3, [r3, #0]
 80101e8:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80101ec:	b29b      	uxth	r3, r3
 80101ee:	461a      	mov	r2, r3
 80101f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101f2:	4413      	add	r3, r2
 80101f4:	637b      	str	r3, [r7, #52]	; 0x34
 80101f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101f8:	781b      	ldrb	r3, [r3, #0]
 80101fa:	00da      	lsls	r2, r3, #3
 80101fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101fe:	4413      	add	r3, r2
 8010200:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010204:	633b      	str	r3, [r7, #48]	; 0x30
 8010206:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010208:	881b      	ldrh	r3, [r3, #0]
 801020a:	b29b      	uxth	r3, r3
 801020c:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8010210:	b29a      	uxth	r2, r3
 8010212:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010214:	801a      	strh	r2, [r3, #0]
 8010216:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010218:	881b      	ldrh	r3, [r3, #0]
 801021a:	b29b      	uxth	r3, r3
 801021c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010220:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010224:	b29a      	uxth	r2, r3
 8010226:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010228:	801a      	strh	r2, [r3, #0]
 801022a:	e017      	b.n	801025c <PCD_EP_ISR_Handler+0x692>
 801022c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801022e:	785b      	ldrb	r3, [r3, #1]
 8010230:	2b01      	cmp	r3, #1
 8010232:	d113      	bne.n	801025c <PCD_EP_ISR_Handler+0x692>
 8010234:	687b      	ldr	r3, [r7, #4]
 8010236:	681b      	ldr	r3, [r3, #0]
 8010238:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801023c:	b29b      	uxth	r3, r3
 801023e:	461a      	mov	r2, r3
 8010240:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010242:	4413      	add	r3, r2
 8010244:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010246:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010248:	781b      	ldrb	r3, [r3, #0]
 801024a:	00da      	lsls	r2, r3, #3
 801024c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801024e:	4413      	add	r3, r2
 8010250:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010254:	63bb      	str	r3, [r7, #56]	; 0x38
 8010256:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010258:	2200      	movs	r2, #0
 801025a:	801a      	strh	r2, [r3, #0]

          /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->DataInStageCallback(hpcd, ep->num);
#else
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 801025c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801025e:	781b      	ldrb	r3, [r3, #0]
 8010260:	4619      	mov	r1, r3
 8010262:	6878      	ldr	r0, [r7, #4]
 8010264:	f018 fd0d 	bl	8028c82 <HAL_PCD_DataInStageCallback>
 8010268:	e051      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else
        {
          /* Manage Bulk Single Buffer Transaction */
          if ((wEPVal & USB_EP_KIND) == 0U)
 801026a:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801026e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8010272:	2b00      	cmp	r3, #0
 8010274:	d144      	bne.n	8010300 <PCD_EP_ISR_Handler+0x736>
          {
            /* multi-packet on the NON control IN endpoint */
            TxPctSize = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8010276:	687b      	ldr	r3, [r7, #4]
 8010278:	681b      	ldr	r3, [r3, #0]
 801027a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801027e:	b29b      	uxth	r3, r3
 8010280:	461a      	mov	r2, r3
 8010282:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010284:	781b      	ldrb	r3, [r3, #0]
 8010286:	00db      	lsls	r3, r3, #3
 8010288:	4413      	add	r3, r2
 801028a:	687a      	ldr	r2, [r7, #4]
 801028c:	6812      	ldr	r2, [r2, #0]
 801028e:	4413      	add	r3, r2
 8010290:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010294:	881b      	ldrh	r3, [r3, #0]
 8010296:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801029a:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40

            if (ep->xfer_len > TxPctSize)
 801029e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102a0:	699a      	ldr	r2, [r3, #24]
 80102a2:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80102a6:	429a      	cmp	r2, r3
 80102a8:	d907      	bls.n	80102ba <PCD_EP_ISR_Handler+0x6f0>
            {
              ep->xfer_len -= TxPctSize;
 80102aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102ac:	699a      	ldr	r2, [r3, #24]
 80102ae:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80102b2:	1ad2      	subs	r2, r2, r3
 80102b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102b6:	619a      	str	r2, [r3, #24]
 80102b8:	e002      	b.n	80102c0 <PCD_EP_ISR_Handler+0x6f6>
            }
            else
            {
              ep->xfer_len = 0U;
 80102ba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102bc:	2200      	movs	r2, #0
 80102be:	619a      	str	r2, [r3, #24]
            }

            /* Zero Length Packet? */
            if (ep->xfer_len == 0U)
 80102c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102c2:	699b      	ldr	r3, [r3, #24]
 80102c4:	2b00      	cmp	r3, #0
 80102c6:	d106      	bne.n	80102d6 <PCD_EP_ISR_Handler+0x70c>
            {
              /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->DataInStageCallback(hpcd, ep->num);
#else
              HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80102c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102ca:	781b      	ldrb	r3, [r3, #0]
 80102cc:	4619      	mov	r1, r3
 80102ce:	6878      	ldr	r0, [r7, #4]
 80102d0:	f018 fcd7 	bl	8028c82 <HAL_PCD_DataInStageCallback>
 80102d4:	e01b      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }
            else
            {
              /* Transfer is not yet Done */
              ep->xfer_buff += TxPctSize;
 80102d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102d8:	695a      	ldr	r2, [r3, #20]
 80102da:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80102de:	441a      	add	r2, r3
 80102e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102e2:	615a      	str	r2, [r3, #20]
              ep->xfer_count += TxPctSize;
 80102e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102e6:	69da      	ldr	r2, [r3, #28]
 80102e8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80102ec:	441a      	add	r2, r3
 80102ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102f0:	61da      	str	r2, [r3, #28]
              (void)USB_EPStartXfer(hpcd->Instance, ep);
 80102f2:	687b      	ldr	r3, [r7, #4]
 80102f4:	681b      	ldr	r3, [r3, #0]
 80102f6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80102f8:	4618      	mov	r0, r3
 80102fa:	f006 fdd2 	bl	8016ea2 <USB_EPStartXfer>
 80102fe:	e006      	b.n	801030e <PCD_EP_ISR_Handler+0x744>
          }
#if (USE_USB_DOUBLE_BUFFER == 1U)
          /* Double Buffer bulk IN (bulk transfer Len > Ep_Mps) */
          else
          {
            (void)HAL_PCD_EP_DB_Transmit(hpcd, ep, wEPVal);
 8010300:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8010304:	461a      	mov	r2, r3
 8010306:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8010308:	6878      	ldr	r0, [r7, #4]
 801030a:	f000 f917 	bl	801053c <HAL_PCD_EP_DB_Transmit>
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 801030e:	687b      	ldr	r3, [r7, #4]
 8010310:	681b      	ldr	r3, [r3, #0]
 8010312:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8010316:	b29b      	uxth	r3, r3
 8010318:	b21b      	sxth	r3, r3
 801031a:	2b00      	cmp	r3, #0
 801031c:	f6ff ac5a 	blt.w	800fbd4 <PCD_EP_ISR_Handler+0xa>
        }
      }
    }
  }

  return HAL_OK;
 8010320:	2300      	movs	r3, #0
}
 8010322:	4618      	mov	r0, r3
 8010324:	3758      	adds	r7, #88	; 0x58
 8010326:	46bd      	mov	sp, r7
 8010328:	bd80      	pop	{r7, pc}

0801032a <HAL_PCD_EP_DB_Receive>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static uint16_t HAL_PCD_EP_DB_Receive(PCD_HandleTypeDef *hpcd,
                                      PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 801032a:	b580      	push	{r7, lr}
 801032c:	b088      	sub	sp, #32
 801032e:	af00      	add	r7, sp, #0
 8010330:	60f8      	str	r0, [r7, #12]
 8010332:	60b9      	str	r1, [r7, #8]
 8010334:	4613      	mov	r3, r2
 8010336:	80fb      	strh	r3, [r7, #6]
  uint16_t count;

  /* Manage Buffer0 OUT */
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 8010338:	88fb      	ldrh	r3, [r7, #6]
 801033a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801033e:	2b00      	cmp	r3, #0
 8010340:	d07c      	beq.n	801043c <HAL_PCD_EP_DB_Receive+0x112>
  {
    /* Get count of received Data on buffer0 */
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8010342:	68fb      	ldr	r3, [r7, #12]
 8010344:	681b      	ldr	r3, [r3, #0]
 8010346:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801034a:	b29b      	uxth	r3, r3
 801034c:	461a      	mov	r2, r3
 801034e:	68bb      	ldr	r3, [r7, #8]
 8010350:	781b      	ldrb	r3, [r3, #0]
 8010352:	00db      	lsls	r3, r3, #3
 8010354:	4413      	add	r3, r2
 8010356:	68fa      	ldr	r2, [r7, #12]
 8010358:	6812      	ldr	r2, [r2, #0]
 801035a:	4413      	add	r3, r2
 801035c:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010360:	881b      	ldrh	r3, [r3, #0]
 8010362:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010366:	837b      	strh	r3, [r7, #26]

    if (ep->xfer_len >= count)
 8010368:	68bb      	ldr	r3, [r7, #8]
 801036a:	699a      	ldr	r2, [r3, #24]
 801036c:	8b7b      	ldrh	r3, [r7, #26]
 801036e:	429a      	cmp	r2, r3
 8010370:	d306      	bcc.n	8010380 <HAL_PCD_EP_DB_Receive+0x56>
    {
      ep->xfer_len -= count;
 8010372:	68bb      	ldr	r3, [r7, #8]
 8010374:	699a      	ldr	r2, [r3, #24]
 8010376:	8b7b      	ldrh	r3, [r7, #26]
 8010378:	1ad2      	subs	r2, r2, r3
 801037a:	68bb      	ldr	r3, [r7, #8]
 801037c:	619a      	str	r2, [r3, #24]
 801037e:	e002      	b.n	8010386 <HAL_PCD_EP_DB_Receive+0x5c>
    }
    else
    {
      ep->xfer_len = 0U;
 8010380:	68bb      	ldr	r3, [r7, #8]
 8010382:	2200      	movs	r2, #0
 8010384:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 8010386:	68bb      	ldr	r3, [r7, #8]
 8010388:	699b      	ldr	r3, [r3, #24]
 801038a:	2b00      	cmp	r3, #0
 801038c:	d123      	bne.n	80103d6 <HAL_PCD_EP_DB_Receive+0xac>
    {
      /* set NAK to OUT endpoint since double buffer is enabled */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 801038e:	68fb      	ldr	r3, [r7, #12]
 8010390:	681b      	ldr	r3, [r3, #0]
 8010392:	461a      	mov	r2, r3
 8010394:	68bb      	ldr	r3, [r7, #8]
 8010396:	781b      	ldrb	r3, [r3, #0]
 8010398:	009b      	lsls	r3, r3, #2
 801039a:	4413      	add	r3, r2
 801039c:	881b      	ldrh	r3, [r3, #0]
 801039e:	b29b      	uxth	r3, r3
 80103a0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80103a4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80103a8:	833b      	strh	r3, [r7, #24]
 80103aa:	8b3b      	ldrh	r3, [r7, #24]
 80103ac:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80103b0:	833b      	strh	r3, [r7, #24]
 80103b2:	68fb      	ldr	r3, [r7, #12]
 80103b4:	681b      	ldr	r3, [r3, #0]
 80103b6:	461a      	mov	r2, r3
 80103b8:	68bb      	ldr	r3, [r7, #8]
 80103ba:	781b      	ldrb	r3, [r3, #0]
 80103bc:	009b      	lsls	r3, r3, #2
 80103be:	441a      	add	r2, r3
 80103c0:	8b3b      	ldrh	r3, [r7, #24]
 80103c2:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80103c6:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80103ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80103ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80103d2:	b29b      	uxth	r3, r3
 80103d4:	8013      	strh	r3, [r2, #0]
    }

    /* Check if Buffer1 is in blocked state which requires to toggle */
    if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 80103d6:	88fb      	ldrh	r3, [r7, #6]
 80103d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80103dc:	2b00      	cmp	r3, #0
 80103de:	d01f      	beq.n	8010420 <HAL_PCD_EP_DB_Receive+0xf6>
    {
      PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 80103e0:	68fb      	ldr	r3, [r7, #12]
 80103e2:	681b      	ldr	r3, [r3, #0]
 80103e4:	461a      	mov	r2, r3
 80103e6:	68bb      	ldr	r3, [r7, #8]
 80103e8:	781b      	ldrb	r3, [r3, #0]
 80103ea:	009b      	lsls	r3, r3, #2
 80103ec:	4413      	add	r3, r2
 80103ee:	881b      	ldrh	r3, [r3, #0]
 80103f0:	b29b      	uxth	r3, r3
 80103f2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80103f6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80103fa:	82fb      	strh	r3, [r7, #22]
 80103fc:	68fb      	ldr	r3, [r7, #12]
 80103fe:	681b      	ldr	r3, [r3, #0]
 8010400:	461a      	mov	r2, r3
 8010402:	68bb      	ldr	r3, [r7, #8]
 8010404:	781b      	ldrb	r3, [r3, #0]
 8010406:	009b      	lsls	r3, r3, #2
 8010408:	441a      	add	r2, r3
 801040a:	8afb      	ldrh	r3, [r7, #22]
 801040c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010410:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8010414:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010418:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 801041c:	b29b      	uxth	r3, r3
 801041e:	8013      	strh	r3, [r2, #0]
    }

    if (count != 0U)
 8010420:	8b7b      	ldrh	r3, [r7, #26]
 8010422:	2b00      	cmp	r3, #0
 8010424:	f000 8085 	beq.w	8010532 <HAL_PCD_EP_DB_Receive+0x208>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 8010428:	68fb      	ldr	r3, [r7, #12]
 801042a:	6818      	ldr	r0, [r3, #0]
 801042c:	68bb      	ldr	r3, [r7, #8]
 801042e:	6959      	ldr	r1, [r3, #20]
 8010430:	68bb      	ldr	r3, [r7, #8]
 8010432:	891a      	ldrh	r2, [r3, #8]
 8010434:	8b7b      	ldrh	r3, [r7, #26]
 8010436:	f007 ff82 	bl	801833e <USB_ReadPMA>
 801043a:	e07a      	b.n	8010532 <HAL_PCD_EP_DB_Receive+0x208>
  }
  /* Manage Buffer 1 DTOG_RX=0 */
  else
  {
    /* Get count of received data */
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 801043c:	68fb      	ldr	r3, [r7, #12]
 801043e:	681b      	ldr	r3, [r3, #0]
 8010440:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010444:	b29b      	uxth	r3, r3
 8010446:	461a      	mov	r2, r3
 8010448:	68bb      	ldr	r3, [r7, #8]
 801044a:	781b      	ldrb	r3, [r3, #0]
 801044c:	00db      	lsls	r3, r3, #3
 801044e:	4413      	add	r3, r2
 8010450:	68fa      	ldr	r2, [r7, #12]
 8010452:	6812      	ldr	r2, [r2, #0]
 8010454:	4413      	add	r3, r2
 8010456:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801045a:	881b      	ldrh	r3, [r3, #0]
 801045c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010460:	837b      	strh	r3, [r7, #26]

    if (ep->xfer_len >= count)
 8010462:	68bb      	ldr	r3, [r7, #8]
 8010464:	699a      	ldr	r2, [r3, #24]
 8010466:	8b7b      	ldrh	r3, [r7, #26]
 8010468:	429a      	cmp	r2, r3
 801046a:	d306      	bcc.n	801047a <HAL_PCD_EP_DB_Receive+0x150>
    {
      ep->xfer_len -= count;
 801046c:	68bb      	ldr	r3, [r7, #8]
 801046e:	699a      	ldr	r2, [r3, #24]
 8010470:	8b7b      	ldrh	r3, [r7, #26]
 8010472:	1ad2      	subs	r2, r2, r3
 8010474:	68bb      	ldr	r3, [r7, #8]
 8010476:	619a      	str	r2, [r3, #24]
 8010478:	e002      	b.n	8010480 <HAL_PCD_EP_DB_Receive+0x156>
    }
    else
    {
      ep->xfer_len = 0U;
 801047a:	68bb      	ldr	r3, [r7, #8]
 801047c:	2200      	movs	r2, #0
 801047e:	619a      	str	r2, [r3, #24]
    }

    if (ep->xfer_len == 0U)
 8010480:	68bb      	ldr	r3, [r7, #8]
 8010482:	699b      	ldr	r3, [r3, #24]
 8010484:	2b00      	cmp	r3, #0
 8010486:	d123      	bne.n	80104d0 <HAL_PCD_EP_DB_Receive+0x1a6>
    {
      /* set NAK on the current endpoint */
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 8010488:	68fb      	ldr	r3, [r7, #12]
 801048a:	681b      	ldr	r3, [r3, #0]
 801048c:	461a      	mov	r2, r3
 801048e:	68bb      	ldr	r3, [r7, #8]
 8010490:	781b      	ldrb	r3, [r3, #0]
 8010492:	009b      	lsls	r3, r3, #2
 8010494:	4413      	add	r3, r2
 8010496:	881b      	ldrh	r3, [r3, #0]
 8010498:	b29b      	uxth	r3, r3
 801049a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 801049e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80104a2:	83fb      	strh	r3, [r7, #30]
 80104a4:	8bfb      	ldrh	r3, [r7, #30]
 80104a6:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80104aa:	83fb      	strh	r3, [r7, #30]
 80104ac:	68fb      	ldr	r3, [r7, #12]
 80104ae:	681b      	ldr	r3, [r3, #0]
 80104b0:	461a      	mov	r2, r3
 80104b2:	68bb      	ldr	r3, [r7, #8]
 80104b4:	781b      	ldrb	r3, [r3, #0]
 80104b6:	009b      	lsls	r3, r3, #2
 80104b8:	441a      	add	r2, r3
 80104ba:	8bfb      	ldrh	r3, [r7, #30]
 80104bc:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80104c0:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80104c4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80104c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80104cc:	b29b      	uxth	r3, r3
 80104ce:	8013      	strh	r3, [r2, #0]
    }

    /*Need to FreeUser Buffer*/
    if ((wEPVal & USB_EP_DTOG_TX) == 0U)
 80104d0:	88fb      	ldrh	r3, [r7, #6]
 80104d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80104d6:	2b00      	cmp	r3, #0
 80104d8:	d11f      	bne.n	801051a <HAL_PCD_EP_DB_Receive+0x1f0>
    {
      PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 0U);
 80104da:	68fb      	ldr	r3, [r7, #12]
 80104dc:	681b      	ldr	r3, [r3, #0]
 80104de:	461a      	mov	r2, r3
 80104e0:	68bb      	ldr	r3, [r7, #8]
 80104e2:	781b      	ldrb	r3, [r3, #0]
 80104e4:	009b      	lsls	r3, r3, #2
 80104e6:	4413      	add	r3, r2
 80104e8:	881b      	ldrh	r3, [r3, #0]
 80104ea:	b29b      	uxth	r3, r3
 80104ec:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80104f0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80104f4:	83bb      	strh	r3, [r7, #28]
 80104f6:	68fb      	ldr	r3, [r7, #12]
 80104f8:	681b      	ldr	r3, [r3, #0]
 80104fa:	461a      	mov	r2, r3
 80104fc:	68bb      	ldr	r3, [r7, #8]
 80104fe:	781b      	ldrb	r3, [r3, #0]
 8010500:	009b      	lsls	r3, r3, #2
 8010502:	441a      	add	r2, r3
 8010504:	8bbb      	ldrh	r3, [r7, #28]
 8010506:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801050a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801050e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010512:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8010516:	b29b      	uxth	r3, r3
 8010518:	8013      	strh	r3, [r2, #0]
    }

    if (count != 0U)
 801051a:	8b7b      	ldrh	r3, [r7, #26]
 801051c:	2b00      	cmp	r3, #0
 801051e:	d008      	beq.n	8010532 <HAL_PCD_EP_DB_Receive+0x208>
    {
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8010520:	68fb      	ldr	r3, [r7, #12]
 8010522:	6818      	ldr	r0, [r3, #0]
 8010524:	68bb      	ldr	r3, [r7, #8]
 8010526:	6959      	ldr	r1, [r3, #20]
 8010528:	68bb      	ldr	r3, [r7, #8]
 801052a:	895a      	ldrh	r2, [r3, #10]
 801052c:	8b7b      	ldrh	r3, [r7, #26]
 801052e:	f007 ff06 	bl	801833e <USB_ReadPMA>
    }
  }

  return count;
 8010532:	8b7b      	ldrh	r3, [r7, #26]
}
 8010534:	4618      	mov	r0, r3
 8010536:	3720      	adds	r7, #32
 8010538:	46bd      	mov	sp, r7
 801053a:	bd80      	pop	{r7, pc}

0801053c <HAL_PCD_EP_DB_Transmit>:
  * @param  wEPVal Last snapshot of EPRx register value taken in ISR
  * @retval HAL status
  */
static HAL_StatusTypeDef HAL_PCD_EP_DB_Transmit(PCD_HandleTypeDef *hpcd,
                                                PCD_EPTypeDef *ep, uint16_t wEPVal)
{
 801053c:	b580      	push	{r7, lr}
 801053e:	b0a2      	sub	sp, #136	; 0x88
 8010540:	af00      	add	r7, sp, #0
 8010542:	60f8      	str	r0, [r7, #12]
 8010544:	60b9      	str	r1, [r7, #8]
 8010546:	4613      	mov	r3, r2
 8010548:	80fb      	strh	r3, [r7, #6]
  uint32_t len;
  uint16_t TxPctSize;

  /* Data Buffer0 ACK received */
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 801054a:	88fb      	ldrh	r3, [r7, #6]
 801054c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010550:	2b00      	cmp	r3, #0
 8010552:	f000 81c5 	beq.w	80108e0 <HAL_PCD_EP_DB_Transmit+0x3a4>
  {
    /* multi-packet on the NON control IN endpoint */
    TxPctSize = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8010556:	68fb      	ldr	r3, [r7, #12]
 8010558:	681b      	ldr	r3, [r3, #0]
 801055a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801055e:	b29b      	uxth	r3, r3
 8010560:	461a      	mov	r2, r3
 8010562:	68bb      	ldr	r3, [r7, #8]
 8010564:	781b      	ldrb	r3, [r3, #0]
 8010566:	00db      	lsls	r3, r3, #3
 8010568:	4413      	add	r3, r2
 801056a:	68fa      	ldr	r2, [r7, #12]
 801056c:	6812      	ldr	r2, [r2, #0]
 801056e:	4413      	add	r3, r2
 8010570:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010574:	881b      	ldrh	r3, [r3, #0]
 8010576:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801057a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    if (ep->xfer_len > TxPctSize)
 801057e:	68bb      	ldr	r3, [r7, #8]
 8010580:	699a      	ldr	r2, [r3, #24]
 8010582:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010586:	429a      	cmp	r2, r3
 8010588:	d907      	bls.n	801059a <HAL_PCD_EP_DB_Transmit+0x5e>
    {
      ep->xfer_len -= TxPctSize;
 801058a:	68bb      	ldr	r3, [r7, #8]
 801058c:	699a      	ldr	r2, [r3, #24]
 801058e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010592:	1ad2      	subs	r2, r2, r3
 8010594:	68bb      	ldr	r3, [r7, #8]
 8010596:	619a      	str	r2, [r3, #24]
 8010598:	e002      	b.n	80105a0 <HAL_PCD_EP_DB_Transmit+0x64>
    }
    else
    {
      ep->xfer_len = 0U;
 801059a:	68bb      	ldr	r3, [r7, #8]
 801059c:	2200      	movs	r2, #0
 801059e:	619a      	str	r2, [r3, #24]
    }

    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 80105a0:	68bb      	ldr	r3, [r7, #8]
 80105a2:	699b      	ldr	r3, [r3, #24]
 80105a4:	2b00      	cmp	r3, #0
 80105a6:	f040 80b9 	bne.w	801071c <HAL_PCD_EP_DB_Transmit+0x1e0>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 80105aa:	68bb      	ldr	r3, [r7, #8]
 80105ac:	785b      	ldrb	r3, [r3, #1]
 80105ae:	2b00      	cmp	r3, #0
 80105b0:	d126      	bne.n	8010600 <HAL_PCD_EP_DB_Transmit+0xc4>
 80105b2:	68fb      	ldr	r3, [r7, #12]
 80105b4:	681b      	ldr	r3, [r3, #0]
 80105b6:	62bb      	str	r3, [r7, #40]	; 0x28
 80105b8:	68fb      	ldr	r3, [r7, #12]
 80105ba:	681b      	ldr	r3, [r3, #0]
 80105bc:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80105c0:	b29b      	uxth	r3, r3
 80105c2:	461a      	mov	r2, r3
 80105c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105c6:	4413      	add	r3, r2
 80105c8:	62bb      	str	r3, [r7, #40]	; 0x28
 80105ca:	68bb      	ldr	r3, [r7, #8]
 80105cc:	781b      	ldrb	r3, [r3, #0]
 80105ce:	00da      	lsls	r2, r3, #3
 80105d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105d2:	4413      	add	r3, r2
 80105d4:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80105d8:	627b      	str	r3, [r7, #36]	; 0x24
 80105da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105dc:	881b      	ldrh	r3, [r3, #0]
 80105de:	b29b      	uxth	r3, r3
 80105e0:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80105e4:	b29a      	uxth	r2, r3
 80105e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105e8:	801a      	strh	r2, [r3, #0]
 80105ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105ec:	881b      	ldrh	r3, [r3, #0]
 80105ee:	b29b      	uxth	r3, r3
 80105f0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80105f4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80105f8:	b29a      	uxth	r2, r3
 80105fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105fc:	801a      	strh	r2, [r3, #0]
 80105fe:	e01a      	b.n	8010636 <HAL_PCD_EP_DB_Transmit+0xfa>
 8010600:	68bb      	ldr	r3, [r7, #8]
 8010602:	785b      	ldrb	r3, [r3, #1]
 8010604:	2b01      	cmp	r3, #1
 8010606:	d116      	bne.n	8010636 <HAL_PCD_EP_DB_Transmit+0xfa>
 8010608:	68fb      	ldr	r3, [r7, #12]
 801060a:	681b      	ldr	r3, [r3, #0]
 801060c:	633b      	str	r3, [r7, #48]	; 0x30
 801060e:	68fb      	ldr	r3, [r7, #12]
 8010610:	681b      	ldr	r3, [r3, #0]
 8010612:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010616:	b29b      	uxth	r3, r3
 8010618:	461a      	mov	r2, r3
 801061a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801061c:	4413      	add	r3, r2
 801061e:	633b      	str	r3, [r7, #48]	; 0x30
 8010620:	68bb      	ldr	r3, [r7, #8]
 8010622:	781b      	ldrb	r3, [r3, #0]
 8010624:	00da      	lsls	r2, r3, #3
 8010626:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010628:	4413      	add	r3, r2
 801062a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801062e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010630:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010632:	2200      	movs	r2, #0
 8010634:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8010636:	68fb      	ldr	r3, [r7, #12]
 8010638:	681b      	ldr	r3, [r3, #0]
 801063a:	623b      	str	r3, [r7, #32]
 801063c:	68bb      	ldr	r3, [r7, #8]
 801063e:	785b      	ldrb	r3, [r3, #1]
 8010640:	2b00      	cmp	r3, #0
 8010642:	d126      	bne.n	8010692 <HAL_PCD_EP_DB_Transmit+0x156>
 8010644:	68fb      	ldr	r3, [r7, #12]
 8010646:	681b      	ldr	r3, [r3, #0]
 8010648:	61bb      	str	r3, [r7, #24]
 801064a:	68fb      	ldr	r3, [r7, #12]
 801064c:	681b      	ldr	r3, [r3, #0]
 801064e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010652:	b29b      	uxth	r3, r3
 8010654:	461a      	mov	r2, r3
 8010656:	69bb      	ldr	r3, [r7, #24]
 8010658:	4413      	add	r3, r2
 801065a:	61bb      	str	r3, [r7, #24]
 801065c:	68bb      	ldr	r3, [r7, #8]
 801065e:	781b      	ldrb	r3, [r3, #0]
 8010660:	00da      	lsls	r2, r3, #3
 8010662:	69bb      	ldr	r3, [r7, #24]
 8010664:	4413      	add	r3, r2
 8010666:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801066a:	617b      	str	r3, [r7, #20]
 801066c:	697b      	ldr	r3, [r7, #20]
 801066e:	881b      	ldrh	r3, [r3, #0]
 8010670:	b29b      	uxth	r3, r3
 8010672:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8010676:	b29a      	uxth	r2, r3
 8010678:	697b      	ldr	r3, [r7, #20]
 801067a:	801a      	strh	r2, [r3, #0]
 801067c:	697b      	ldr	r3, [r7, #20]
 801067e:	881b      	ldrh	r3, [r3, #0]
 8010680:	b29b      	uxth	r3, r3
 8010682:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010686:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801068a:	b29a      	uxth	r2, r3
 801068c:	697b      	ldr	r3, [r7, #20]
 801068e:	801a      	strh	r2, [r3, #0]
 8010690:	e017      	b.n	80106c2 <HAL_PCD_EP_DB_Transmit+0x186>
 8010692:	68bb      	ldr	r3, [r7, #8]
 8010694:	785b      	ldrb	r3, [r3, #1]
 8010696:	2b01      	cmp	r3, #1
 8010698:	d113      	bne.n	80106c2 <HAL_PCD_EP_DB_Transmit+0x186>
 801069a:	68fb      	ldr	r3, [r7, #12]
 801069c:	681b      	ldr	r3, [r3, #0]
 801069e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80106a2:	b29b      	uxth	r3, r3
 80106a4:	461a      	mov	r2, r3
 80106a6:	6a3b      	ldr	r3, [r7, #32]
 80106a8:	4413      	add	r3, r2
 80106aa:	623b      	str	r3, [r7, #32]
 80106ac:	68bb      	ldr	r3, [r7, #8]
 80106ae:	781b      	ldrb	r3, [r3, #0]
 80106b0:	00da      	lsls	r2, r3, #3
 80106b2:	6a3b      	ldr	r3, [r7, #32]
 80106b4:	4413      	add	r3, r2
 80106b6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 80106ba:	61fb      	str	r3, [r7, #28]
 80106bc:	69fb      	ldr	r3, [r7, #28]
 80106be:	2200      	movs	r2, #0
 80106c0:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80106c2:	68bb      	ldr	r3, [r7, #8]
 80106c4:	781b      	ldrb	r3, [r3, #0]
 80106c6:	4619      	mov	r1, r3
 80106c8:	68f8      	ldr	r0, [r7, #12]
 80106ca:	f018 fada 	bl	8028c82 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 80106ce:	88fb      	ldrh	r3, [r7, #6]
 80106d0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80106d4:	2b00      	cmp	r3, #0
 80106d6:	f000 82d2 	beq.w	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 80106da:	68fb      	ldr	r3, [r7, #12]
 80106dc:	681b      	ldr	r3, [r3, #0]
 80106de:	461a      	mov	r2, r3
 80106e0:	68bb      	ldr	r3, [r7, #8]
 80106e2:	781b      	ldrb	r3, [r3, #0]
 80106e4:	009b      	lsls	r3, r3, #2
 80106e6:	4413      	add	r3, r2
 80106e8:	881b      	ldrh	r3, [r3, #0]
 80106ea:	b29b      	uxth	r3, r3
 80106ec:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80106f0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80106f4:	827b      	strh	r3, [r7, #18]
 80106f6:	68fb      	ldr	r3, [r7, #12]
 80106f8:	681b      	ldr	r3, [r3, #0]
 80106fa:	461a      	mov	r2, r3
 80106fc:	68bb      	ldr	r3, [r7, #8]
 80106fe:	781b      	ldrb	r3, [r3, #0]
 8010700:	009b      	lsls	r3, r3, #2
 8010702:	441a      	add	r2, r3
 8010704:	8a7b      	ldrh	r3, [r7, #18]
 8010706:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801070a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801070e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8010712:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010716:	b29b      	uxth	r3, r3
 8010718:	8013      	strh	r3, [r2, #0]
 801071a:	e2b0      	b.n	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 801071c:	88fb      	ldrh	r3, [r7, #6]
 801071e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8010722:	2b00      	cmp	r3, #0
 8010724:	d021      	beq.n	801076a <HAL_PCD_EP_DB_Transmit+0x22e>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 8010726:	68fb      	ldr	r3, [r7, #12]
 8010728:	681b      	ldr	r3, [r3, #0]
 801072a:	461a      	mov	r2, r3
 801072c:	68bb      	ldr	r3, [r7, #8]
 801072e:	781b      	ldrb	r3, [r3, #0]
 8010730:	009b      	lsls	r3, r3, #2
 8010732:	4413      	add	r3, r2
 8010734:	881b      	ldrh	r3, [r3, #0]
 8010736:	b29b      	uxth	r3, r3
 8010738:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801073c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8010740:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 8010744:	68fb      	ldr	r3, [r7, #12]
 8010746:	681b      	ldr	r3, [r3, #0]
 8010748:	461a      	mov	r2, r3
 801074a:	68bb      	ldr	r3, [r7, #8]
 801074c:	781b      	ldrb	r3, [r3, #0]
 801074e:	009b      	lsls	r3, r3, #2
 8010750:	441a      	add	r2, r3
 8010752:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8010756:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801075a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801075e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8010762:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010766:	b29b      	uxth	r3, r3
 8010768:	8013      	strh	r3, [r2, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 801076a:	68bb      	ldr	r3, [r7, #8]
 801076c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8010770:	2b01      	cmp	r3, #1
 8010772:	f040 8284 	bne.w	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      {
        ep->xfer_buff += TxPctSize;
 8010776:	68bb      	ldr	r3, [r7, #8]
 8010778:	695a      	ldr	r2, [r3, #20]
 801077a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 801077e:	441a      	add	r2, r3
 8010780:	68bb      	ldr	r3, [r7, #8]
 8010782:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxPctSize;
 8010784:	68bb      	ldr	r3, [r7, #8]
 8010786:	69da      	ldr	r2, [r3, #28]
 8010788:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 801078c:	441a      	add	r2, r3
 801078e:	68bb      	ldr	r3, [r7, #8]
 8010790:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 8010792:	68bb      	ldr	r3, [r7, #8]
 8010794:	6a1a      	ldr	r2, [r3, #32]
 8010796:	68bb      	ldr	r3, [r7, #8]
 8010798:	691b      	ldr	r3, [r3, #16]
 801079a:	429a      	cmp	r2, r3
 801079c:	d309      	bcc.n	80107b2 <HAL_PCD_EP_DB_Transmit+0x276>
        {
          len = ep->maxpacket;
 801079e:	68bb      	ldr	r3, [r7, #8]
 80107a0:	691b      	ldr	r3, [r3, #16]
 80107a2:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db -= len;
 80107a4:	68bb      	ldr	r3, [r7, #8]
 80107a6:	6a1a      	ldr	r2, [r3, #32]
 80107a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80107aa:	1ad2      	subs	r2, r2, r3
 80107ac:	68bb      	ldr	r3, [r7, #8]
 80107ae:	621a      	str	r2, [r3, #32]
 80107b0:	e015      	b.n	80107de <HAL_PCD_EP_DB_Transmit+0x2a2>
        }
        else if (ep->xfer_len_db == 0U)
 80107b2:	68bb      	ldr	r3, [r7, #8]
 80107b4:	6a1b      	ldr	r3, [r3, #32]
 80107b6:	2b00      	cmp	r3, #0
 80107b8:	d107      	bne.n	80107ca <HAL_PCD_EP_DB_Transmit+0x28e>
        {
          len = TxPctSize;
 80107ba:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80107be:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_fill_db = 0U;
 80107c0:	68bb      	ldr	r3, [r7, #8]
 80107c2:	2200      	movs	r2, #0
 80107c4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 80107c8:	e009      	b.n	80107de <HAL_PCD_EP_DB_Transmit+0x2a2>
        }
        else
        {
          ep->xfer_fill_db = 0U;
 80107ca:	68bb      	ldr	r3, [r7, #8]
 80107cc:	2200      	movs	r2, #0
 80107ce:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          len = ep->xfer_len_db;
 80107d2:	68bb      	ldr	r3, [r7, #8]
 80107d4:	6a1b      	ldr	r3, [r3, #32]
 80107d6:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db = 0U;
 80107d8:	68bb      	ldr	r3, [r7, #8]
 80107da:	2200      	movs	r2, #0
 80107dc:	621a      	str	r2, [r3, #32]
        }

        /* Write remaining Data to Buffer */
        /* Set the Double buffer counter for pma buffer1 */
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 80107de:	68bb      	ldr	r3, [r7, #8]
 80107e0:	785b      	ldrb	r3, [r3, #1]
 80107e2:	2b00      	cmp	r3, #0
 80107e4:	d155      	bne.n	8010892 <HAL_PCD_EP_DB_Transmit+0x356>
 80107e6:	68fb      	ldr	r3, [r7, #12]
 80107e8:	681b      	ldr	r3, [r3, #0]
 80107ea:	63bb      	str	r3, [r7, #56]	; 0x38
 80107ec:	68fb      	ldr	r3, [r7, #12]
 80107ee:	681b      	ldr	r3, [r3, #0]
 80107f0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80107f4:	b29b      	uxth	r3, r3
 80107f6:	461a      	mov	r2, r3
 80107f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80107fa:	4413      	add	r3, r2
 80107fc:	63bb      	str	r3, [r7, #56]	; 0x38
 80107fe:	68bb      	ldr	r3, [r7, #8]
 8010800:	781b      	ldrb	r3, [r3, #0]
 8010802:	00da      	lsls	r2, r3, #3
 8010804:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010806:	4413      	add	r3, r2
 8010808:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801080c:	637b      	str	r3, [r7, #52]	; 0x34
 801080e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010810:	2b3e      	cmp	r3, #62	; 0x3e
 8010812:	d916      	bls.n	8010842 <HAL_PCD_EP_DB_Transmit+0x306>
 8010814:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010816:	095b      	lsrs	r3, r3, #5
 8010818:	64bb      	str	r3, [r7, #72]	; 0x48
 801081a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801081c:	f003 031f 	and.w	r3, r3, #31
 8010820:	2b00      	cmp	r3, #0
 8010822:	d102      	bne.n	801082a <HAL_PCD_EP_DB_Transmit+0x2ee>
 8010824:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010826:	3b01      	subs	r3, #1
 8010828:	64bb      	str	r3, [r7, #72]	; 0x48
 801082a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801082c:	b29b      	uxth	r3, r3
 801082e:	029b      	lsls	r3, r3, #10
 8010830:	b29b      	uxth	r3, r3
 8010832:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010836:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801083a:	b29a      	uxth	r2, r3
 801083c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801083e:	801a      	strh	r2, [r3, #0]
 8010840:	e043      	b.n	80108ca <HAL_PCD_EP_DB_Transmit+0x38e>
 8010842:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010844:	2b00      	cmp	r3, #0
 8010846:	d112      	bne.n	801086e <HAL_PCD_EP_DB_Transmit+0x332>
 8010848:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801084a:	881b      	ldrh	r3, [r3, #0]
 801084c:	b29b      	uxth	r3, r3
 801084e:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8010852:	b29a      	uxth	r2, r3
 8010854:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010856:	801a      	strh	r2, [r3, #0]
 8010858:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801085a:	881b      	ldrh	r3, [r3, #0]
 801085c:	b29b      	uxth	r3, r3
 801085e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010862:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010866:	b29a      	uxth	r2, r3
 8010868:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801086a:	801a      	strh	r2, [r3, #0]
 801086c:	e02d      	b.n	80108ca <HAL_PCD_EP_DB_Transmit+0x38e>
 801086e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010870:	085b      	lsrs	r3, r3, #1
 8010872:	64bb      	str	r3, [r7, #72]	; 0x48
 8010874:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010876:	f003 0301 	and.w	r3, r3, #1
 801087a:	2b00      	cmp	r3, #0
 801087c:	d002      	beq.n	8010884 <HAL_PCD_EP_DB_Transmit+0x348>
 801087e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010880:	3301      	adds	r3, #1
 8010882:	64bb      	str	r3, [r7, #72]	; 0x48
 8010884:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010886:	b29b      	uxth	r3, r3
 8010888:	029b      	lsls	r3, r3, #10
 801088a:	b29a      	uxth	r2, r3
 801088c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801088e:	801a      	strh	r2, [r3, #0]
 8010890:	e01b      	b.n	80108ca <HAL_PCD_EP_DB_Transmit+0x38e>
 8010892:	68bb      	ldr	r3, [r7, #8]
 8010894:	785b      	ldrb	r3, [r3, #1]
 8010896:	2b01      	cmp	r3, #1
 8010898:	d117      	bne.n	80108ca <HAL_PCD_EP_DB_Transmit+0x38e>
 801089a:	68fb      	ldr	r3, [r7, #12]
 801089c:	681b      	ldr	r3, [r3, #0]
 801089e:	643b      	str	r3, [r7, #64]	; 0x40
 80108a0:	68fb      	ldr	r3, [r7, #12]
 80108a2:	681b      	ldr	r3, [r3, #0]
 80108a4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80108a8:	b29b      	uxth	r3, r3
 80108aa:	461a      	mov	r2, r3
 80108ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80108ae:	4413      	add	r3, r2
 80108b0:	643b      	str	r3, [r7, #64]	; 0x40
 80108b2:	68bb      	ldr	r3, [r7, #8]
 80108b4:	781b      	ldrb	r3, [r3, #0]
 80108b6:	00da      	lsls	r2, r3, #3
 80108b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80108ba:	4413      	add	r3, r2
 80108bc:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80108c0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80108c2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80108c4:	b29a      	uxth	r2, r3
 80108c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80108c8:	801a      	strh	r2, [r3, #0]

        /* Copy user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 80108ca:	68fb      	ldr	r3, [r7, #12]
 80108cc:	6818      	ldr	r0, [r3, #0]
 80108ce:	68bb      	ldr	r3, [r7, #8]
 80108d0:	6959      	ldr	r1, [r3, #20]
 80108d2:	68bb      	ldr	r3, [r7, #8]
 80108d4:	891a      	ldrh	r2, [r3, #8]
 80108d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80108d8:	b29b      	uxth	r3, r3
 80108da:	f007 fcee 	bl	80182ba <USB_WritePMA>
 80108de:	e1ce      	b.n	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
    }
  }
  else /* Data Buffer1 ACK received */
  {
    /* multi-packet on the NON control IN endpoint */
    TxPctSize = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80108e0:	68fb      	ldr	r3, [r7, #12]
 80108e2:	681b      	ldr	r3, [r3, #0]
 80108e4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80108e8:	b29b      	uxth	r3, r3
 80108ea:	461a      	mov	r2, r3
 80108ec:	68bb      	ldr	r3, [r7, #8]
 80108ee:	781b      	ldrb	r3, [r3, #0]
 80108f0:	00db      	lsls	r3, r3, #3
 80108f2:	4413      	add	r3, r2
 80108f4:	68fa      	ldr	r2, [r7, #12]
 80108f6:	6812      	ldr	r2, [r2, #0]
 80108f8:	4413      	add	r3, r2
 80108fa:	f203 4306 	addw	r3, r3, #1030	; 0x406
 80108fe:	881b      	ldrh	r3, [r3, #0]
 8010900:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8010904:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    if (ep->xfer_len >= TxPctSize)
 8010908:	68bb      	ldr	r3, [r7, #8]
 801090a:	699a      	ldr	r2, [r3, #24]
 801090c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010910:	429a      	cmp	r2, r3
 8010912:	d307      	bcc.n	8010924 <HAL_PCD_EP_DB_Transmit+0x3e8>
    {
      ep->xfer_len -= TxPctSize;
 8010914:	68bb      	ldr	r3, [r7, #8]
 8010916:	699a      	ldr	r2, [r3, #24]
 8010918:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 801091c:	1ad2      	subs	r2, r2, r3
 801091e:	68bb      	ldr	r3, [r7, #8]
 8010920:	619a      	str	r2, [r3, #24]
 8010922:	e002      	b.n	801092a <HAL_PCD_EP_DB_Transmit+0x3ee>
    }
    else
    {
      ep->xfer_len = 0U;
 8010924:	68bb      	ldr	r3, [r7, #8]
 8010926:	2200      	movs	r2, #0
 8010928:	619a      	str	r2, [r3, #24]
    }

    /* Transfer is completed */
    if (ep->xfer_len == 0U)
 801092a:	68bb      	ldr	r3, [r7, #8]
 801092c:	699b      	ldr	r3, [r3, #24]
 801092e:	2b00      	cmp	r3, #0
 8010930:	f040 80c4 	bne.w	8010abc <HAL_PCD_EP_DB_Transmit+0x580>
    {
      PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 8010934:	68bb      	ldr	r3, [r7, #8]
 8010936:	785b      	ldrb	r3, [r3, #1]
 8010938:	2b00      	cmp	r3, #0
 801093a:	d126      	bne.n	801098a <HAL_PCD_EP_DB_Transmit+0x44e>
 801093c:	68fb      	ldr	r3, [r7, #12]
 801093e:	681b      	ldr	r3, [r3, #0]
 8010940:	66bb      	str	r3, [r7, #104]	; 0x68
 8010942:	68fb      	ldr	r3, [r7, #12]
 8010944:	681b      	ldr	r3, [r3, #0]
 8010946:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801094a:	b29b      	uxth	r3, r3
 801094c:	461a      	mov	r2, r3
 801094e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8010950:	4413      	add	r3, r2
 8010952:	66bb      	str	r3, [r7, #104]	; 0x68
 8010954:	68bb      	ldr	r3, [r7, #8]
 8010956:	781b      	ldrb	r3, [r3, #0]
 8010958:	00da      	lsls	r2, r3, #3
 801095a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801095c:	4413      	add	r3, r2
 801095e:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010962:	667b      	str	r3, [r7, #100]	; 0x64
 8010964:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010966:	881b      	ldrh	r3, [r3, #0]
 8010968:	b29b      	uxth	r3, r3
 801096a:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 801096e:	b29a      	uxth	r2, r3
 8010970:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010972:	801a      	strh	r2, [r3, #0]
 8010974:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010976:	881b      	ldrh	r3, [r3, #0]
 8010978:	b29b      	uxth	r3, r3
 801097a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801097e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010982:	b29a      	uxth	r2, r3
 8010984:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8010986:	801a      	strh	r2, [r3, #0]
 8010988:	e01a      	b.n	80109c0 <HAL_PCD_EP_DB_Transmit+0x484>
 801098a:	68bb      	ldr	r3, [r7, #8]
 801098c:	785b      	ldrb	r3, [r3, #1]
 801098e:	2b01      	cmp	r3, #1
 8010990:	d116      	bne.n	80109c0 <HAL_PCD_EP_DB_Transmit+0x484>
 8010992:	68fb      	ldr	r3, [r7, #12]
 8010994:	681b      	ldr	r3, [r3, #0]
 8010996:	673b      	str	r3, [r7, #112]	; 0x70
 8010998:	68fb      	ldr	r3, [r7, #12]
 801099a:	681b      	ldr	r3, [r3, #0]
 801099c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80109a0:	b29b      	uxth	r3, r3
 80109a2:	461a      	mov	r2, r3
 80109a4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80109a6:	4413      	add	r3, r2
 80109a8:	673b      	str	r3, [r7, #112]	; 0x70
 80109aa:	68bb      	ldr	r3, [r7, #8]
 80109ac:	781b      	ldrb	r3, [r3, #0]
 80109ae:	00da      	lsls	r2, r3, #3
 80109b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80109b2:	4413      	add	r3, r2
 80109b4:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80109b8:	66fb      	str	r3, [r7, #108]	; 0x6c
 80109ba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80109bc:	2200      	movs	r2, #0
 80109be:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, 0U);
 80109c0:	68fb      	ldr	r3, [r7, #12]
 80109c2:	681b      	ldr	r3, [r3, #0]
 80109c4:	67fb      	str	r3, [r7, #124]	; 0x7c
 80109c6:	68bb      	ldr	r3, [r7, #8]
 80109c8:	785b      	ldrb	r3, [r3, #1]
 80109ca:	2b00      	cmp	r3, #0
 80109cc:	d12f      	bne.n	8010a2e <HAL_PCD_EP_DB_Transmit+0x4f2>
 80109ce:	68fb      	ldr	r3, [r7, #12]
 80109d0:	681b      	ldr	r3, [r3, #0]
 80109d2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 80109d6:	68fb      	ldr	r3, [r7, #12]
 80109d8:	681b      	ldr	r3, [r3, #0]
 80109da:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80109de:	b29b      	uxth	r3, r3
 80109e0:	461a      	mov	r2, r3
 80109e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80109e6:	4413      	add	r3, r2
 80109e8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 80109ec:	68bb      	ldr	r3, [r7, #8]
 80109ee:	781b      	ldrb	r3, [r3, #0]
 80109f0:	00da      	lsls	r2, r3, #3
 80109f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80109f6:	4413      	add	r3, r2
 80109f8:	f203 4306 	addw	r3, r3, #1030	; 0x406
 80109fc:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8010a00:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8010a04:	881b      	ldrh	r3, [r3, #0]
 8010a06:	b29b      	uxth	r3, r3
 8010a08:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8010a0c:	b29a      	uxth	r2, r3
 8010a0e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8010a12:	801a      	strh	r2, [r3, #0]
 8010a14:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8010a18:	881b      	ldrh	r3, [r3, #0]
 8010a1a:	b29b      	uxth	r3, r3
 8010a1c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010a20:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010a24:	b29a      	uxth	r2, r3
 8010a26:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8010a2a:	801a      	strh	r2, [r3, #0]
 8010a2c:	e017      	b.n	8010a5e <HAL_PCD_EP_DB_Transmit+0x522>
 8010a2e:	68bb      	ldr	r3, [r7, #8]
 8010a30:	785b      	ldrb	r3, [r3, #1]
 8010a32:	2b01      	cmp	r3, #1
 8010a34:	d113      	bne.n	8010a5e <HAL_PCD_EP_DB_Transmit+0x522>
 8010a36:	68fb      	ldr	r3, [r7, #12]
 8010a38:	681b      	ldr	r3, [r3, #0]
 8010a3a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010a3e:	b29b      	uxth	r3, r3
 8010a40:	461a      	mov	r2, r3
 8010a42:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8010a44:	4413      	add	r3, r2
 8010a46:	67fb      	str	r3, [r7, #124]	; 0x7c
 8010a48:	68bb      	ldr	r3, [r7, #8]
 8010a4a:	781b      	ldrb	r3, [r3, #0]
 8010a4c:	00da      	lsls	r2, r3, #3
 8010a4e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8010a50:	4413      	add	r3, r2
 8010a52:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010a56:	67bb      	str	r3, [r7, #120]	; 0x78
 8010a58:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8010a5a:	2200      	movs	r2, #0
 8010a5c:	801a      	strh	r2, [r3, #0]

      /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataInStageCallback(hpcd, ep->num);
#else
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8010a5e:	68bb      	ldr	r3, [r7, #8]
 8010a60:	781b      	ldrb	r3, [r3, #0]
 8010a62:	4619      	mov	r1, r3
 8010a64:	68f8      	ldr	r0, [r7, #12]
 8010a66:	f018 f90c 	bl	8028c82 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 8010a6a:	88fb      	ldrh	r3, [r7, #6]
 8010a6c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8010a70:	2b00      	cmp	r3, #0
 8010a72:	f040 8104 	bne.w	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 8010a76:	68fb      	ldr	r3, [r7, #12]
 8010a78:	681b      	ldr	r3, [r3, #0]
 8010a7a:	461a      	mov	r2, r3
 8010a7c:	68bb      	ldr	r3, [r7, #8]
 8010a7e:	781b      	ldrb	r3, [r3, #0]
 8010a80:	009b      	lsls	r3, r3, #2
 8010a82:	4413      	add	r3, r2
 8010a84:	881b      	ldrh	r3, [r3, #0]
 8010a86:	b29b      	uxth	r3, r3
 8010a88:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8010a8c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8010a90:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 8010a94:	68fb      	ldr	r3, [r7, #12]
 8010a96:	681b      	ldr	r3, [r3, #0]
 8010a98:	461a      	mov	r2, r3
 8010a9a:	68bb      	ldr	r3, [r7, #8]
 8010a9c:	781b      	ldrb	r3, [r3, #0]
 8010a9e:	009b      	lsls	r3, r3, #2
 8010aa0:	441a      	add	r2, r3
 8010aa2:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 8010aa6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010aaa:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8010aae:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8010ab2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010ab6:	b29b      	uxth	r3, r3
 8010ab8:	8013      	strh	r3, [r2, #0]
 8010aba:	e0e0      	b.n	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      }
    }
    else /* Transfer is not yet Done */
    {
      /* need to Free USB Buff */
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 8010abc:	88fb      	ldrh	r3, [r7, #6]
 8010abe:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8010ac2:	2b00      	cmp	r3, #0
 8010ac4:	d121      	bne.n	8010b0a <HAL_PCD_EP_DB_Transmit+0x5ce>
      {
        PCD_FREE_USER_BUFFER(hpcd->Instance, ep->num, 1U);
 8010ac6:	68fb      	ldr	r3, [r7, #12]
 8010ac8:	681b      	ldr	r3, [r3, #0]
 8010aca:	461a      	mov	r2, r3
 8010acc:	68bb      	ldr	r3, [r7, #8]
 8010ace:	781b      	ldrb	r3, [r3, #0]
 8010ad0:	009b      	lsls	r3, r3, #2
 8010ad2:	4413      	add	r3, r2
 8010ad4:	881b      	ldrh	r3, [r3, #0]
 8010ad6:	b29b      	uxth	r3, r3
 8010ad8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8010adc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8010ae0:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 8010ae4:	68fb      	ldr	r3, [r7, #12]
 8010ae6:	681b      	ldr	r3, [r3, #0]
 8010ae8:	461a      	mov	r2, r3
 8010aea:	68bb      	ldr	r3, [r7, #8]
 8010aec:	781b      	ldrb	r3, [r3, #0]
 8010aee:	009b      	lsls	r3, r3, #2
 8010af0:	441a      	add	r2, r3
 8010af2:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8010af6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010afa:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8010afe:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8010b02:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010b06:	b29b      	uxth	r3, r3
 8010b08:	8013      	strh	r3, [r2, #0]
      }

      /* Still there is data to Fill in the next Buffer */
      if (ep->xfer_fill_db == 1U)
 8010b0a:	68bb      	ldr	r3, [r7, #8]
 8010b0c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8010b10:	2b01      	cmp	r3, #1
 8010b12:	f040 80b4 	bne.w	8010c7e <HAL_PCD_EP_DB_Transmit+0x742>
      {
        ep->xfer_buff += TxPctSize;
 8010b16:	68bb      	ldr	r3, [r7, #8]
 8010b18:	695a      	ldr	r2, [r3, #20]
 8010b1a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010b1e:	441a      	add	r2, r3
 8010b20:	68bb      	ldr	r3, [r7, #8]
 8010b22:	615a      	str	r2, [r3, #20]
        ep->xfer_count += TxPctSize;
 8010b24:	68bb      	ldr	r3, [r7, #8]
 8010b26:	69da      	ldr	r2, [r3, #28]
 8010b28:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010b2c:	441a      	add	r2, r3
 8010b2e:	68bb      	ldr	r3, [r7, #8]
 8010b30:	61da      	str	r2, [r3, #28]

        /* Calculate the len of the new buffer to fill */
        if (ep->xfer_len_db >= ep->maxpacket)
 8010b32:	68bb      	ldr	r3, [r7, #8]
 8010b34:	6a1a      	ldr	r2, [r3, #32]
 8010b36:	68bb      	ldr	r3, [r7, #8]
 8010b38:	691b      	ldr	r3, [r3, #16]
 8010b3a:	429a      	cmp	r2, r3
 8010b3c:	d309      	bcc.n	8010b52 <HAL_PCD_EP_DB_Transmit+0x616>
        {
          len = ep->maxpacket;
 8010b3e:	68bb      	ldr	r3, [r7, #8]
 8010b40:	691b      	ldr	r3, [r3, #16]
 8010b42:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db -= len;
 8010b44:	68bb      	ldr	r3, [r7, #8]
 8010b46:	6a1a      	ldr	r2, [r3, #32]
 8010b48:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010b4a:	1ad2      	subs	r2, r2, r3
 8010b4c:	68bb      	ldr	r3, [r7, #8]
 8010b4e:	621a      	str	r2, [r3, #32]
 8010b50:	e015      	b.n	8010b7e <HAL_PCD_EP_DB_Transmit+0x642>
        }
        else if (ep->xfer_len_db == 0U)
 8010b52:	68bb      	ldr	r3, [r7, #8]
 8010b54:	6a1b      	ldr	r3, [r3, #32]
 8010b56:	2b00      	cmp	r3, #0
 8010b58:	d107      	bne.n	8010b6a <HAL_PCD_EP_DB_Transmit+0x62e>
        {
          len = TxPctSize;
 8010b5a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8010b5e:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_fill_db = 0U;
 8010b60:	68bb      	ldr	r3, [r7, #8]
 8010b62:	2200      	movs	r2, #0
 8010b64:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8010b68:	e009      	b.n	8010b7e <HAL_PCD_EP_DB_Transmit+0x642>
        }
        else
        {
          len = ep->xfer_len_db;
 8010b6a:	68bb      	ldr	r3, [r7, #8]
 8010b6c:	6a1b      	ldr	r3, [r3, #32]
 8010b6e:	653b      	str	r3, [r7, #80]	; 0x50
          ep->xfer_len_db = 0U;
 8010b70:	68bb      	ldr	r3, [r7, #8]
 8010b72:	2200      	movs	r2, #0
 8010b74:	621a      	str	r2, [r3, #32]
          ep->xfer_fill_db = 0;
 8010b76:	68bb      	ldr	r3, [r7, #8]
 8010b78:	2200      	movs	r2, #0
 8010b7a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
        }

        /* Set the Double buffer counter for pmabuffer1 */
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 8010b7e:	68fb      	ldr	r3, [r7, #12]
 8010b80:	681b      	ldr	r3, [r3, #0]
 8010b82:	663b      	str	r3, [r7, #96]	; 0x60
 8010b84:	68bb      	ldr	r3, [r7, #8]
 8010b86:	785b      	ldrb	r3, [r3, #1]
 8010b88:	2b00      	cmp	r3, #0
 8010b8a:	d155      	bne.n	8010c38 <HAL_PCD_EP_DB_Transmit+0x6fc>
 8010b8c:	68fb      	ldr	r3, [r7, #12]
 8010b8e:	681b      	ldr	r3, [r3, #0]
 8010b90:	65bb      	str	r3, [r7, #88]	; 0x58
 8010b92:	68fb      	ldr	r3, [r7, #12]
 8010b94:	681b      	ldr	r3, [r3, #0]
 8010b96:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010b9a:	b29b      	uxth	r3, r3
 8010b9c:	461a      	mov	r2, r3
 8010b9e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010ba0:	4413      	add	r3, r2
 8010ba2:	65bb      	str	r3, [r7, #88]	; 0x58
 8010ba4:	68bb      	ldr	r3, [r7, #8]
 8010ba6:	781b      	ldrb	r3, [r3, #0]
 8010ba8:	00da      	lsls	r2, r3, #3
 8010baa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010bac:	4413      	add	r3, r2
 8010bae:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010bb2:	657b      	str	r3, [r7, #84]	; 0x54
 8010bb4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010bb6:	2b3e      	cmp	r3, #62	; 0x3e
 8010bb8:	d916      	bls.n	8010be8 <HAL_PCD_EP_DB_Transmit+0x6ac>
 8010bba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010bbc:	095b      	lsrs	r3, r3, #5
 8010bbe:	677b      	str	r3, [r7, #116]	; 0x74
 8010bc0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010bc2:	f003 031f 	and.w	r3, r3, #31
 8010bc6:	2b00      	cmp	r3, #0
 8010bc8:	d102      	bne.n	8010bd0 <HAL_PCD_EP_DB_Transmit+0x694>
 8010bca:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010bcc:	3b01      	subs	r3, #1
 8010bce:	677b      	str	r3, [r7, #116]	; 0x74
 8010bd0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010bd2:	b29b      	uxth	r3, r3
 8010bd4:	029b      	lsls	r3, r3, #10
 8010bd6:	b29b      	uxth	r3, r3
 8010bd8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010bdc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010be0:	b29a      	uxth	r2, r3
 8010be2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010be4:	801a      	strh	r2, [r3, #0]
 8010be6:	e040      	b.n	8010c6a <HAL_PCD_EP_DB_Transmit+0x72e>
 8010be8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010bea:	2b00      	cmp	r3, #0
 8010bec:	d112      	bne.n	8010c14 <HAL_PCD_EP_DB_Transmit+0x6d8>
 8010bee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010bf0:	881b      	ldrh	r3, [r3, #0]
 8010bf2:	b29b      	uxth	r3, r3
 8010bf4:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8010bf8:	b29a      	uxth	r2, r3
 8010bfa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010bfc:	801a      	strh	r2, [r3, #0]
 8010bfe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010c00:	881b      	ldrh	r3, [r3, #0]
 8010c02:	b29b      	uxth	r3, r3
 8010c04:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8010c08:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8010c0c:	b29a      	uxth	r2, r3
 8010c0e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010c10:	801a      	strh	r2, [r3, #0]
 8010c12:	e02a      	b.n	8010c6a <HAL_PCD_EP_DB_Transmit+0x72e>
 8010c14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c16:	085b      	lsrs	r3, r3, #1
 8010c18:	677b      	str	r3, [r7, #116]	; 0x74
 8010c1a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c1c:	f003 0301 	and.w	r3, r3, #1
 8010c20:	2b00      	cmp	r3, #0
 8010c22:	d002      	beq.n	8010c2a <HAL_PCD_EP_DB_Transmit+0x6ee>
 8010c24:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010c26:	3301      	adds	r3, #1
 8010c28:	677b      	str	r3, [r7, #116]	; 0x74
 8010c2a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010c2c:	b29b      	uxth	r3, r3
 8010c2e:	029b      	lsls	r3, r3, #10
 8010c30:	b29a      	uxth	r2, r3
 8010c32:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010c34:	801a      	strh	r2, [r3, #0]
 8010c36:	e018      	b.n	8010c6a <HAL_PCD_EP_DB_Transmit+0x72e>
 8010c38:	68bb      	ldr	r3, [r7, #8]
 8010c3a:	785b      	ldrb	r3, [r3, #1]
 8010c3c:	2b01      	cmp	r3, #1
 8010c3e:	d114      	bne.n	8010c6a <HAL_PCD_EP_DB_Transmit+0x72e>
 8010c40:	68fb      	ldr	r3, [r7, #12]
 8010c42:	681b      	ldr	r3, [r3, #0]
 8010c44:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8010c48:	b29b      	uxth	r3, r3
 8010c4a:	461a      	mov	r2, r3
 8010c4c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8010c4e:	4413      	add	r3, r2
 8010c50:	663b      	str	r3, [r7, #96]	; 0x60
 8010c52:	68bb      	ldr	r3, [r7, #8]
 8010c54:	781b      	ldrb	r3, [r3, #0]
 8010c56:	00da      	lsls	r2, r3, #3
 8010c58:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8010c5a:	4413      	add	r3, r2
 8010c5c:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8010c60:	65fb      	str	r3, [r7, #92]	; 0x5c
 8010c62:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c64:	b29a      	uxth	r2, r3
 8010c66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010c68:	801a      	strh	r2, [r3, #0]

        /* Copy the user buffer to USB PMA */
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 8010c6a:	68fb      	ldr	r3, [r7, #12]
 8010c6c:	6818      	ldr	r0, [r3, #0]
 8010c6e:	68bb      	ldr	r3, [r7, #8]
 8010c70:	6959      	ldr	r1, [r3, #20]
 8010c72:	68bb      	ldr	r3, [r7, #8]
 8010c74:	895a      	ldrh	r2, [r3, #10]
 8010c76:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8010c78:	b29b      	uxth	r3, r3
 8010c7a:	f007 fb1e 	bl	80182ba <USB_WritePMA>
      }
    }
  }

  /*enable endpoint IN*/
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 8010c7e:	68fb      	ldr	r3, [r7, #12]
 8010c80:	681b      	ldr	r3, [r3, #0]
 8010c82:	461a      	mov	r2, r3
 8010c84:	68bb      	ldr	r3, [r7, #8]
 8010c86:	781b      	ldrb	r3, [r3, #0]
 8010c88:	009b      	lsls	r3, r3, #2
 8010c8a:	4413      	add	r3, r2
 8010c8c:	881b      	ldrh	r3, [r3, #0]
 8010c8e:	b29b      	uxth	r3, r3
 8010c90:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8010c94:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8010c98:	823b      	strh	r3, [r7, #16]
 8010c9a:	8a3b      	ldrh	r3, [r7, #16]
 8010c9c:	f083 0310 	eor.w	r3, r3, #16
 8010ca0:	823b      	strh	r3, [r7, #16]
 8010ca2:	8a3b      	ldrh	r3, [r7, #16]
 8010ca4:	f083 0320 	eor.w	r3, r3, #32
 8010ca8:	823b      	strh	r3, [r7, #16]
 8010caa:	68fb      	ldr	r3, [r7, #12]
 8010cac:	681b      	ldr	r3, [r3, #0]
 8010cae:	461a      	mov	r2, r3
 8010cb0:	68bb      	ldr	r3, [r7, #8]
 8010cb2:	781b      	ldrb	r3, [r3, #0]
 8010cb4:	009b      	lsls	r3, r3, #2
 8010cb6:	441a      	add	r2, r3
 8010cb8:	8a3b      	ldrh	r3, [r7, #16]
 8010cba:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8010cbe:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8010cc2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8010cc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010cca:	b29b      	uxth	r3, r3
 8010ccc:	8013      	strh	r3, [r2, #0]

  return HAL_OK;
 8010cce:	2300      	movs	r3, #0
}
 8010cd0:	4618      	mov	r0, r3
 8010cd2:	3788      	adds	r7, #136	; 0x88
 8010cd4:	46bd      	mov	sp, r7
 8010cd6:	bd80      	pop	{r7, pc}

08010cd8 <HAL_PCDEx_PMAConfig>:
  * @retval HAL status
  */

HAL_StatusTypeDef  HAL_PCDEx_PMAConfig(PCD_HandleTypeDef *hpcd, uint16_t ep_addr,
                                       uint16_t ep_kind, uint32_t pmaadress)
{
 8010cd8:	b480      	push	{r7}
 8010cda:	b087      	sub	sp, #28
 8010cdc:	af00      	add	r7, sp, #0
 8010cde:	60f8      	str	r0, [r7, #12]
 8010ce0:	607b      	str	r3, [r7, #4]
 8010ce2:	460b      	mov	r3, r1
 8010ce4:	817b      	strh	r3, [r7, #10]
 8010ce6:	4613      	mov	r3, r2
 8010ce8:	813b      	strh	r3, [r7, #8]
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 8010cea:	897b      	ldrh	r3, [r7, #10]
 8010cec:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8010cf0:	b29b      	uxth	r3, r3
 8010cf2:	2b00      	cmp	r3, #0
 8010cf4:	d00b      	beq.n	8010d0e <HAL_PCDEx_PMAConfig+0x36>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8010cf6:	897b      	ldrh	r3, [r7, #10]
 8010cf8:	f003 0307 	and.w	r3, r3, #7
 8010cfc:	1c5a      	adds	r2, r3, #1
 8010cfe:	4613      	mov	r3, r2
 8010d00:	009b      	lsls	r3, r3, #2
 8010d02:	4413      	add	r3, r2
 8010d04:	00db      	lsls	r3, r3, #3
 8010d06:	68fa      	ldr	r2, [r7, #12]
 8010d08:	4413      	add	r3, r2
 8010d0a:	617b      	str	r3, [r7, #20]
 8010d0c:	e009      	b.n	8010d22 <HAL_PCDEx_PMAConfig+0x4a>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8010d0e:	897a      	ldrh	r2, [r7, #10]
 8010d10:	4613      	mov	r3, r2
 8010d12:	009b      	lsls	r3, r3, #2
 8010d14:	4413      	add	r3, r2
 8010d16:	00db      	lsls	r3, r3, #3
 8010d18:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8010d1c:	68fa      	ldr	r2, [r7, #12]
 8010d1e:	4413      	add	r3, r2
 8010d20:	617b      	str	r3, [r7, #20]
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8010d22:	893b      	ldrh	r3, [r7, #8]
 8010d24:	2b00      	cmp	r3, #0
 8010d26:	d107      	bne.n	8010d38 <HAL_PCDEx_PMAConfig+0x60>
  {
    /* Single Buffer */
    ep->doublebuffer = 0U;
 8010d28:	697b      	ldr	r3, [r7, #20]
 8010d2a:	2200      	movs	r2, #0
 8010d2c:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaadress = (uint16_t)pmaadress;
 8010d2e:	687b      	ldr	r3, [r7, #4]
 8010d30:	b29a      	uxth	r2, r3
 8010d32:	697b      	ldr	r3, [r7, #20]
 8010d34:	80da      	strh	r2, [r3, #6]
 8010d36:	e00b      	b.n	8010d50 <HAL_PCDEx_PMAConfig+0x78>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  else /* USB_DBL_BUF */
  {
    /* Double Buffer Endpoint */
    ep->doublebuffer = 1U;
 8010d38:	697b      	ldr	r3, [r7, #20]
 8010d3a:	2201      	movs	r2, #1
 8010d3c:	731a      	strb	r2, [r3, #12]
    /* Configure the PMA */
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 8010d3e:	687b      	ldr	r3, [r7, #4]
 8010d40:	b29a      	uxth	r2, r3
 8010d42:	697b      	ldr	r3, [r7, #20]
 8010d44:	811a      	strh	r2, [r3, #8]
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
 8010d46:	687b      	ldr	r3, [r7, #4]
 8010d48:	0c1b      	lsrs	r3, r3, #16
 8010d4a:	b29a      	uxth	r2, r3
 8010d4c:	697b      	ldr	r3, [r7, #20]
 8010d4e:	815a      	strh	r2, [r3, #10]
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return HAL_OK;
 8010d50:	2300      	movs	r3, #0
}
 8010d52:	4618      	mov	r0, r3
 8010d54:	371c      	adds	r7, #28
 8010d56:	46bd      	mov	sp, r7
 8010d58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010d5c:	4770      	bx	lr

08010d5e <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8010d5e:	b480      	push	{r7}
 8010d60:	b085      	sub	sp, #20
 8010d62:	af00      	add	r7, sp, #0
 8010d64:	6078      	str	r0, [r7, #4]

  USB_TypeDef *USBx = hpcd->Instance;
 8010d66:	687b      	ldr	r3, [r7, #4]
 8010d68:	681b      	ldr	r3, [r3, #0]
 8010d6a:	60fb      	str	r3, [r7, #12]
  hpcd->lpm_active = 1U;
 8010d6c:	687b      	ldr	r3, [r7, #4]
 8010d6e:	2201      	movs	r2, #1
 8010d70:	f8c3 22e8 	str.w	r2, [r3, #744]	; 0x2e8
  hpcd->LPM_State = LPM_L0;
 8010d74:	687b      	ldr	r3, [r7, #4]
 8010d76:	2200      	movs	r2, #0
 8010d78:	f883 22e0 	strb.w	r2, [r3, #736]	; 0x2e0

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 8010d7c:	68fb      	ldr	r3, [r7, #12]
 8010d7e:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 8010d82:	b29b      	uxth	r3, r3
 8010d84:	f043 0301 	orr.w	r3, r3, #1
 8010d88:	b29a      	uxth	r2, r3
 8010d8a:	68fb      	ldr	r3, [r7, #12]
 8010d8c:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 8010d90:	68fb      	ldr	r3, [r7, #12]
 8010d92:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 8010d96:	b29b      	uxth	r3, r3
 8010d98:	f043 0302 	orr.w	r3, r3, #2
 8010d9c:	b29a      	uxth	r2, r3
 8010d9e:	68fb      	ldr	r3, [r7, #12]
 8010da0:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

  return HAL_OK;
 8010da4:	2300      	movs	r3, #0
}
 8010da6:	4618      	mov	r0, r3
 8010da8:	3714      	adds	r7, #20
 8010daa:	46bd      	mov	sp, r7
 8010dac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010db0:	4770      	bx	lr
	...

08010db4 <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 8010db4:	b480      	push	{r7}
 8010db6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8010db8:	4b05      	ldr	r3, [pc, #20]	; (8010dd0 <HAL_PWR_EnableBkUpAccess+0x1c>)
 8010dba:	681b      	ldr	r3, [r3, #0]
 8010dbc:	4a04      	ldr	r2, [pc, #16]	; (8010dd0 <HAL_PWR_EnableBkUpAccess+0x1c>)
 8010dbe:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8010dc2:	6013      	str	r3, [r2, #0]
}
 8010dc4:	bf00      	nop
 8010dc6:	46bd      	mov	sp, r7
 8010dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010dcc:	4770      	bx	lr
 8010dce:	bf00      	nop
 8010dd0:	58000400 	.word	0x58000400

08010dd4 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8010dd4:	b480      	push	{r7}
 8010dd6:	af00      	add	r7, sp, #0
  return  (PWR->CR1 & PWR_CR1_VOS);
 8010dd8:	4b04      	ldr	r3, [pc, #16]	; (8010dec <HAL_PWREx_GetVoltageRange+0x18>)
 8010dda:	681b      	ldr	r3, [r3, #0]
 8010ddc:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
}
 8010de0:	4618      	mov	r0, r3
 8010de2:	46bd      	mov	sp, r7
 8010de4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010de8:	4770      	bx	lr
 8010dea:	bf00      	nop
 8010dec:	58000400 	.word	0x58000400

08010df0 <HAL_PWREx_EnableVddUSB>:
  * @brief Enable VDDUSB supply.
  * @note  Remove VDDUSB electrical and logical isolation, once VDDUSB supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddUSB(void)
{
 8010df0:	b480      	push	{r7}
 8010df2:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR2, PWR_CR2_USV);
 8010df4:	4b05      	ldr	r3, [pc, #20]	; (8010e0c <HAL_PWREx_EnableVddUSB+0x1c>)
 8010df6:	685b      	ldr	r3, [r3, #4]
 8010df8:	4a04      	ldr	r2, [pc, #16]	; (8010e0c <HAL_PWREx_EnableVddUSB+0x1c>)
 8010dfa:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8010dfe:	6053      	str	r3, [r2, #4]
}
 8010e00:	bf00      	nop
 8010e02:	46bd      	mov	sp, r7
 8010e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e08:	4770      	bx	lr
 8010e0a:	bf00      	nop
 8010e0c:	58000400 	.word	0x58000400

08010e10 <LL_RCC_HSE_IsEnabledDiv2>:
{
 8010e10:	b480      	push	{r7}
 8010e12:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8010e14:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e18:	681b      	ldr	r3, [r3, #0]
 8010e1a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8010e1e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8010e22:	d101      	bne.n	8010e28 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 8010e24:	2301      	movs	r3, #1
 8010e26:	e000      	b.n	8010e2a <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 8010e28:	2300      	movs	r3, #0
}
 8010e2a:	4618      	mov	r0, r3
 8010e2c:	46bd      	mov	sp, r7
 8010e2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e32:	4770      	bx	lr

08010e34 <LL_RCC_HSE_Enable>:
{
 8010e34:	b480      	push	{r7}
 8010e36:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8010e38:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e3c:	681b      	ldr	r3, [r3, #0]
 8010e3e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010e42:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8010e46:	6013      	str	r3, [r2, #0]
}
 8010e48:	bf00      	nop
 8010e4a:	46bd      	mov	sp, r7
 8010e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e50:	4770      	bx	lr

08010e52 <LL_RCC_HSE_Disable>:
{
 8010e52:	b480      	push	{r7}
 8010e54:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8010e56:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e5a:	681b      	ldr	r3, [r3, #0]
 8010e5c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010e60:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8010e64:	6013      	str	r3, [r2, #0]
}
 8010e66:	bf00      	nop
 8010e68:	46bd      	mov	sp, r7
 8010e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e6e:	4770      	bx	lr

08010e70 <LL_RCC_HSE_IsReady>:
{
 8010e70:	b480      	push	{r7}
 8010e72:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8010e74:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e78:	681b      	ldr	r3, [r3, #0]
 8010e7a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8010e7e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8010e82:	d101      	bne.n	8010e88 <LL_RCC_HSE_IsReady+0x18>
 8010e84:	2301      	movs	r3, #1
 8010e86:	e000      	b.n	8010e8a <LL_RCC_HSE_IsReady+0x1a>
 8010e88:	2300      	movs	r3, #0
}
 8010e8a:	4618      	mov	r0, r3
 8010e8c:	46bd      	mov	sp, r7
 8010e8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e92:	4770      	bx	lr

08010e94 <LL_RCC_HSI_Enable>:
{
 8010e94:	b480      	push	{r7}
 8010e96:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8010e98:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e9c:	681b      	ldr	r3, [r3, #0]
 8010e9e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010ea2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8010ea6:	6013      	str	r3, [r2, #0]
}
 8010ea8:	bf00      	nop
 8010eaa:	46bd      	mov	sp, r7
 8010eac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010eb0:	4770      	bx	lr

08010eb2 <LL_RCC_HSI_Disable>:
{
 8010eb2:	b480      	push	{r7}
 8010eb4:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8010eb6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010eba:	681b      	ldr	r3, [r3, #0]
 8010ebc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010ec0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8010ec4:	6013      	str	r3, [r2, #0]
}
 8010ec6:	bf00      	nop
 8010ec8:	46bd      	mov	sp, r7
 8010eca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ece:	4770      	bx	lr

08010ed0 <LL_RCC_HSI_IsReady>:
{
 8010ed0:	b480      	push	{r7}
 8010ed2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8010ed4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010ed8:	681b      	ldr	r3, [r3, #0]
 8010eda:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8010ede:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8010ee2:	d101      	bne.n	8010ee8 <LL_RCC_HSI_IsReady+0x18>
 8010ee4:	2301      	movs	r3, #1
 8010ee6:	e000      	b.n	8010eea <LL_RCC_HSI_IsReady+0x1a>
 8010ee8:	2300      	movs	r3, #0
}
 8010eea:	4618      	mov	r0, r3
 8010eec:	46bd      	mov	sp, r7
 8010eee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ef2:	4770      	bx	lr

08010ef4 <LL_RCC_HSI_SetCalibTrimming>:
{
 8010ef4:	b480      	push	{r7}
 8010ef6:	b083      	sub	sp, #12
 8010ef8:	af00      	add	r7, sp, #0
 8010efa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8010efc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f00:	685b      	ldr	r3, [r3, #4]
 8010f02:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8010f06:	687b      	ldr	r3, [r7, #4]
 8010f08:	061b      	lsls	r3, r3, #24
 8010f0a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010f0e:	4313      	orrs	r3, r2
 8010f10:	604b      	str	r3, [r1, #4]
}
 8010f12:	bf00      	nop
 8010f14:	370c      	adds	r7, #12
 8010f16:	46bd      	mov	sp, r7
 8010f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f1c:	4770      	bx	lr

08010f1e <LL_RCC_HSI48_Enable>:
{
 8010f1e:	b480      	push	{r7}
 8010f20:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8010f22:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f26:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8010f2a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010f2e:	f043 0301 	orr.w	r3, r3, #1
 8010f32:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8010f36:	bf00      	nop
 8010f38:	46bd      	mov	sp, r7
 8010f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f3e:	4770      	bx	lr

08010f40 <LL_RCC_HSI48_Disable>:
{
 8010f40:	b480      	push	{r7}
 8010f42:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8010f44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f48:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8010f4c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010f50:	f023 0301 	bic.w	r3, r3, #1
 8010f54:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8010f58:	bf00      	nop
 8010f5a:	46bd      	mov	sp, r7
 8010f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f60:	4770      	bx	lr

08010f62 <LL_RCC_HSI48_IsReady>:
{
 8010f62:	b480      	push	{r7}
 8010f64:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 8010f66:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f6a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8010f6e:	f003 0302 	and.w	r3, r3, #2
 8010f72:	2b02      	cmp	r3, #2
 8010f74:	d101      	bne.n	8010f7a <LL_RCC_HSI48_IsReady+0x18>
 8010f76:	2301      	movs	r3, #1
 8010f78:	e000      	b.n	8010f7c <LL_RCC_HSI48_IsReady+0x1a>
 8010f7a:	2300      	movs	r3, #0
}
 8010f7c:	4618      	mov	r0, r3
 8010f7e:	46bd      	mov	sp, r7
 8010f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f84:	4770      	bx	lr

08010f86 <LL_RCC_LSE_Enable>:
{
 8010f86:	b480      	push	{r7}
 8010f88:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8010f8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010f92:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010f96:	f043 0301 	orr.w	r3, r3, #1
 8010f9a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8010f9e:	bf00      	nop
 8010fa0:	46bd      	mov	sp, r7
 8010fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fa6:	4770      	bx	lr

08010fa8 <LL_RCC_LSE_Disable>:
{
 8010fa8:	b480      	push	{r7}
 8010faa:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8010fac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010fb0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010fb4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010fb8:	f023 0301 	bic.w	r3, r3, #1
 8010fbc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8010fc0:	bf00      	nop
 8010fc2:	46bd      	mov	sp, r7
 8010fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fc8:	4770      	bx	lr

08010fca <LL_RCC_LSE_EnableBypass>:
{
 8010fca:	b480      	push	{r7}
 8010fcc:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8010fce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010fd2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010fd6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010fda:	f043 0304 	orr.w	r3, r3, #4
 8010fde:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8010fe2:	bf00      	nop
 8010fe4:	46bd      	mov	sp, r7
 8010fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fea:	4770      	bx	lr

08010fec <LL_RCC_LSE_DisableBypass>:
{
 8010fec:	b480      	push	{r7}
 8010fee:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8010ff0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010ff4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010ff8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010ffc:	f023 0304 	bic.w	r3, r3, #4
 8011000:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8011004:	bf00      	nop
 8011006:	46bd      	mov	sp, r7
 8011008:	f85d 7b04 	ldr.w	r7, [sp], #4
 801100c:	4770      	bx	lr

0801100e <LL_RCC_LSE_IsReady>:
{
 801100e:	b480      	push	{r7}
 8011010:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8011012:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011016:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801101a:	f003 0302 	and.w	r3, r3, #2
 801101e:	2b02      	cmp	r3, #2
 8011020:	d101      	bne.n	8011026 <LL_RCC_LSE_IsReady+0x18>
 8011022:	2301      	movs	r3, #1
 8011024:	e000      	b.n	8011028 <LL_RCC_LSE_IsReady+0x1a>
 8011026:	2300      	movs	r3, #0
}
 8011028:	4618      	mov	r0, r3
 801102a:	46bd      	mov	sp, r7
 801102c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011030:	4770      	bx	lr

08011032 <LL_RCC_LSI1_Enable>:
{
 8011032:	b480      	push	{r7}
 8011034:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8011036:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801103a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801103e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011042:	f043 0301 	orr.w	r3, r3, #1
 8011046:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 801104a:	bf00      	nop
 801104c:	46bd      	mov	sp, r7
 801104e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011052:	4770      	bx	lr

08011054 <LL_RCC_LSI1_Disable>:
{
 8011054:	b480      	push	{r7}
 8011056:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8011058:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801105c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011060:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011064:	f023 0301 	bic.w	r3, r3, #1
 8011068:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 801106c:	bf00      	nop
 801106e:	46bd      	mov	sp, r7
 8011070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011074:	4770      	bx	lr

08011076 <LL_RCC_LSI1_IsReady>:
{
 8011076:	b480      	push	{r7}
 8011078:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 801107a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801107e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011082:	f003 0302 	and.w	r3, r3, #2
 8011086:	2b02      	cmp	r3, #2
 8011088:	d101      	bne.n	801108e <LL_RCC_LSI1_IsReady+0x18>
 801108a:	2301      	movs	r3, #1
 801108c:	e000      	b.n	8011090 <LL_RCC_LSI1_IsReady+0x1a>
 801108e:	2300      	movs	r3, #0
}
 8011090:	4618      	mov	r0, r3
 8011092:	46bd      	mov	sp, r7
 8011094:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011098:	4770      	bx	lr

0801109a <LL_RCC_LSI2_Enable>:
{
 801109a:	b480      	push	{r7}
 801109c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 801109e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110a2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80110a6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80110aa:	f043 0304 	orr.w	r3, r3, #4
 80110ae:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 80110b2:	bf00      	nop
 80110b4:	46bd      	mov	sp, r7
 80110b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110ba:	4770      	bx	lr

080110bc <LL_RCC_LSI2_Disable>:
{
 80110bc:	b480      	push	{r7}
 80110be:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 80110c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110c4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80110c8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80110cc:	f023 0304 	bic.w	r3, r3, #4
 80110d0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 80110d4:	bf00      	nop
 80110d6:	46bd      	mov	sp, r7
 80110d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110dc:	4770      	bx	lr

080110de <LL_RCC_LSI2_IsReady>:
{
 80110de:	b480      	push	{r7}
 80110e0:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 80110e2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110e6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80110ea:	f003 0308 	and.w	r3, r3, #8
 80110ee:	2b08      	cmp	r3, #8
 80110f0:	d101      	bne.n	80110f6 <LL_RCC_LSI2_IsReady+0x18>
 80110f2:	2301      	movs	r3, #1
 80110f4:	e000      	b.n	80110f8 <LL_RCC_LSI2_IsReady+0x1a>
 80110f6:	2300      	movs	r3, #0
}
 80110f8:	4618      	mov	r0, r3
 80110fa:	46bd      	mov	sp, r7
 80110fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011100:	4770      	bx	lr

08011102 <LL_RCC_LSI2_SetTrimming>:
{
 8011102:	b480      	push	{r7}
 8011104:	b083      	sub	sp, #12
 8011106:	af00      	add	r7, sp, #0
 8011108:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_LSI2TRIM, Value << RCC_CSR_LSI2TRIM_Pos);
 801110a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801110e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8011112:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 8011116:	687b      	ldr	r3, [r7, #4]
 8011118:	021b      	lsls	r3, r3, #8
 801111a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801111e:	4313      	orrs	r3, r2
 8011120:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8011124:	bf00      	nop
 8011126:	370c      	adds	r7, #12
 8011128:	46bd      	mov	sp, r7
 801112a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801112e:	4770      	bx	lr

08011130 <LL_RCC_MSI_Enable>:
{
 8011130:	b480      	push	{r7}
 8011132:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8011134:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011138:	681b      	ldr	r3, [r3, #0]
 801113a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801113e:	f043 0301 	orr.w	r3, r3, #1
 8011142:	6013      	str	r3, [r2, #0]
}
 8011144:	bf00      	nop
 8011146:	46bd      	mov	sp, r7
 8011148:	f85d 7b04 	ldr.w	r7, [sp], #4
 801114c:	4770      	bx	lr

0801114e <LL_RCC_MSI_Disable>:
{
 801114e:	b480      	push	{r7}
 8011150:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 8011152:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011156:	681b      	ldr	r3, [r3, #0]
 8011158:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801115c:	f023 0301 	bic.w	r3, r3, #1
 8011160:	6013      	str	r3, [r2, #0]
}
 8011162:	bf00      	nop
 8011164:	46bd      	mov	sp, r7
 8011166:	f85d 7b04 	ldr.w	r7, [sp], #4
 801116a:	4770      	bx	lr

0801116c <LL_RCC_MSI_IsReady>:
{
 801116c:	b480      	push	{r7}
 801116e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8011170:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011174:	681b      	ldr	r3, [r3, #0]
 8011176:	f003 0302 	and.w	r3, r3, #2
 801117a:	2b02      	cmp	r3, #2
 801117c:	d101      	bne.n	8011182 <LL_RCC_MSI_IsReady+0x16>
 801117e:	2301      	movs	r3, #1
 8011180:	e000      	b.n	8011184 <LL_RCC_MSI_IsReady+0x18>
 8011182:	2300      	movs	r3, #0
}
 8011184:	4618      	mov	r0, r3
 8011186:	46bd      	mov	sp, r7
 8011188:	f85d 7b04 	ldr.w	r7, [sp], #4
 801118c:	4770      	bx	lr

0801118e <LL_RCC_MSI_SetRange>:
{
 801118e:	b480      	push	{r7}
 8011190:	b083      	sub	sp, #12
 8011192:	af00      	add	r7, sp, #0
 8011194:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 8011196:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801119a:	681b      	ldr	r3, [r3, #0]
 801119c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80111a0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80111a4:	687b      	ldr	r3, [r7, #4]
 80111a6:	4313      	orrs	r3, r2
 80111a8:	600b      	str	r3, [r1, #0]
}
 80111aa:	bf00      	nop
 80111ac:	370c      	adds	r7, #12
 80111ae:	46bd      	mov	sp, r7
 80111b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111b4:	4770      	bx	lr

080111b6 <LL_RCC_MSI_GetRange>:
{
 80111b6:	b480      	push	{r7}
 80111b8:	b083      	sub	sp, #12
 80111ba:	af00      	add	r7, sp, #0
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 80111bc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80111c0:	681b      	ldr	r3, [r3, #0]
 80111c2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80111c6:	607b      	str	r3, [r7, #4]
  if (msiRange > LL_RCC_MSIRANGE_11)
 80111c8:	687b      	ldr	r3, [r7, #4]
 80111ca:	2bb0      	cmp	r3, #176	; 0xb0
 80111cc:	d901      	bls.n	80111d2 <LL_RCC_MSI_GetRange+0x1c>
    msiRange = LL_RCC_MSIRANGE_11;
 80111ce:	23b0      	movs	r3, #176	; 0xb0
 80111d0:	607b      	str	r3, [r7, #4]
  return msiRange;
 80111d2:	687b      	ldr	r3, [r7, #4]
}
 80111d4:	4618      	mov	r0, r3
 80111d6:	370c      	adds	r7, #12
 80111d8:	46bd      	mov	sp, r7
 80111da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111de:	4770      	bx	lr

080111e0 <LL_RCC_MSI_SetCalibTrimming>:
{
 80111e0:	b480      	push	{r7}
 80111e2:	b083      	sub	sp, #12
 80111e4:	af00      	add	r7, sp, #0
 80111e6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 80111e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80111ec:	685b      	ldr	r3, [r3, #4]
 80111ee:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 80111f2:	687b      	ldr	r3, [r7, #4]
 80111f4:	021b      	lsls	r3, r3, #8
 80111f6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80111fa:	4313      	orrs	r3, r2
 80111fc:	604b      	str	r3, [r1, #4]
}
 80111fe:	bf00      	nop
 8011200:	370c      	adds	r7, #12
 8011202:	46bd      	mov	sp, r7
 8011204:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011208:	4770      	bx	lr

0801120a <LL_RCC_SetSysClkSource>:
{
 801120a:	b480      	push	{r7}
 801120c:	b083      	sub	sp, #12
 801120e:	af00      	add	r7, sp, #0
 8011210:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8011212:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011216:	689b      	ldr	r3, [r3, #8]
 8011218:	f023 0203 	bic.w	r2, r3, #3
 801121c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011220:	687b      	ldr	r3, [r7, #4]
 8011222:	4313      	orrs	r3, r2
 8011224:	608b      	str	r3, [r1, #8]
}
 8011226:	bf00      	nop
 8011228:	370c      	adds	r7, #12
 801122a:	46bd      	mov	sp, r7
 801122c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011230:	4770      	bx	lr

08011232 <LL_RCC_GetSysClkSource>:
{
 8011232:	b480      	push	{r7}
 8011234:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8011236:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801123a:	689b      	ldr	r3, [r3, #8]
 801123c:	f003 030c 	and.w	r3, r3, #12
}
 8011240:	4618      	mov	r0, r3
 8011242:	46bd      	mov	sp, r7
 8011244:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011248:	4770      	bx	lr

0801124a <LL_RCC_SetAHBPrescaler>:
{
 801124a:	b480      	push	{r7}
 801124c:	b083      	sub	sp, #12
 801124e:	af00      	add	r7, sp, #0
 8011250:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8011252:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011256:	689b      	ldr	r3, [r3, #8]
 8011258:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 801125c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011260:	687b      	ldr	r3, [r7, #4]
 8011262:	4313      	orrs	r3, r2
 8011264:	608b      	str	r3, [r1, #8]
}
 8011266:	bf00      	nop
 8011268:	370c      	adds	r7, #12
 801126a:	46bd      	mov	sp, r7
 801126c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011270:	4770      	bx	lr

08011272 <LL_C2_RCC_SetAHBPrescaler>:
{
 8011272:	b480      	push	{r7}
 8011274:	b083      	sub	sp, #12
 8011276:	af00      	add	r7, sp, #0
 8011278:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 801127a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801127e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8011282:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8011286:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801128a:	687b      	ldr	r3, [r7, #4]
 801128c:	4313      	orrs	r3, r2
 801128e:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 8011292:	bf00      	nop
 8011294:	370c      	adds	r7, #12
 8011296:	46bd      	mov	sp, r7
 8011298:	f85d 7b04 	ldr.w	r7, [sp], #4
 801129c:	4770      	bx	lr

0801129e <LL_RCC_SetAHB4Prescaler>:
{
 801129e:	b480      	push	{r7}
 80112a0:	b083      	sub	sp, #12
 80112a2:	af00      	add	r7, sp, #0
 80112a4:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 80112a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80112aa:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80112ae:	f023 020f 	bic.w	r2, r3, #15
 80112b2:	687b      	ldr	r3, [r7, #4]
 80112b4:	091b      	lsrs	r3, r3, #4
 80112b6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80112ba:	4313      	orrs	r3, r2
 80112bc:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 80112c0:	bf00      	nop
 80112c2:	370c      	adds	r7, #12
 80112c4:	46bd      	mov	sp, r7
 80112c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80112ca:	4770      	bx	lr

080112cc <LL_RCC_SetAPB1Prescaler>:
{
 80112cc:	b480      	push	{r7}
 80112ce:	b083      	sub	sp, #12
 80112d0:	af00      	add	r7, sp, #0
 80112d2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 80112d4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80112d8:	689b      	ldr	r3, [r3, #8]
 80112da:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 80112de:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80112e2:	687b      	ldr	r3, [r7, #4]
 80112e4:	4313      	orrs	r3, r2
 80112e6:	608b      	str	r3, [r1, #8]
}
 80112e8:	bf00      	nop
 80112ea:	370c      	adds	r7, #12
 80112ec:	46bd      	mov	sp, r7
 80112ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80112f2:	4770      	bx	lr

080112f4 <LL_RCC_SetAPB2Prescaler>:
{
 80112f4:	b480      	push	{r7}
 80112f6:	b083      	sub	sp, #12
 80112f8:	af00      	add	r7, sp, #0
 80112fa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 80112fc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011300:	689b      	ldr	r3, [r3, #8]
 8011302:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8011306:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801130a:	687b      	ldr	r3, [r7, #4]
 801130c:	4313      	orrs	r3, r2
 801130e:	608b      	str	r3, [r1, #8]
}
 8011310:	bf00      	nop
 8011312:	370c      	adds	r7, #12
 8011314:	46bd      	mov	sp, r7
 8011316:	f85d 7b04 	ldr.w	r7, [sp], #4
 801131a:	4770      	bx	lr

0801131c <LL_RCC_GetAHBPrescaler>:
{
 801131c:	b480      	push	{r7}
 801131e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8011320:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011324:	689b      	ldr	r3, [r3, #8]
 8011326:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 801132a:	4618      	mov	r0, r3
 801132c:	46bd      	mov	sp, r7
 801132e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011332:	4770      	bx	lr

08011334 <LL_C2_RCC_GetAHBPrescaler>:
{
 8011334:	b480      	push	{r7}
 8011336:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 8011338:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801133c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8011340:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 8011344:	4618      	mov	r0, r3
 8011346:	46bd      	mov	sp, r7
 8011348:	f85d 7b04 	ldr.w	r7, [sp], #4
 801134c:	4770      	bx	lr

0801134e <LL_RCC_GetAHB4Prescaler>:
{
 801134e:	b480      	push	{r7}
 8011350:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8011352:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011356:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801135a:	011b      	lsls	r3, r3, #4
 801135c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 8011360:	4618      	mov	r0, r3
 8011362:	46bd      	mov	sp, r7
 8011364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011368:	4770      	bx	lr

0801136a <LL_RCC_GetAPB1Prescaler>:
{
 801136a:	b480      	push	{r7}
 801136c:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 801136e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011372:	689b      	ldr	r3, [r3, #8]
 8011374:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
}
 8011378:	4618      	mov	r0, r3
 801137a:	46bd      	mov	sp, r7
 801137c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011380:	4770      	bx	lr

08011382 <LL_RCC_GetAPB2Prescaler>:
{
 8011382:	b480      	push	{r7}
 8011384:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8011386:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801138a:	689b      	ldr	r3, [r3, #8]
 801138c:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
}
 8011390:	4618      	mov	r0, r3
 8011392:	46bd      	mov	sp, r7
 8011394:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011398:	4770      	bx	lr

0801139a <LL_RCC_PLL_Enable>:
{
 801139a:	b480      	push	{r7}
 801139c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 801139e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80113a2:	681b      	ldr	r3, [r3, #0]
 80113a4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80113a8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80113ac:	6013      	str	r3, [r2, #0]
}
 80113ae:	bf00      	nop
 80113b0:	46bd      	mov	sp, r7
 80113b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113b6:	4770      	bx	lr

080113b8 <LL_RCC_PLL_Disable>:
{
 80113b8:	b480      	push	{r7}
 80113ba:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 80113bc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80113c0:	681b      	ldr	r3, [r3, #0]
 80113c2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80113c6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80113ca:	6013      	str	r3, [r2, #0]
}
 80113cc:	bf00      	nop
 80113ce:	46bd      	mov	sp, r7
 80113d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113d4:	4770      	bx	lr

080113d6 <LL_RCC_PLL_IsReady>:
{
 80113d6:	b480      	push	{r7}
 80113d8:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 80113da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80113de:	681b      	ldr	r3, [r3, #0]
 80113e0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80113e4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80113e8:	d101      	bne.n	80113ee <LL_RCC_PLL_IsReady+0x18>
 80113ea:	2301      	movs	r3, #1
 80113ec:	e000      	b.n	80113f0 <LL_RCC_PLL_IsReady+0x1a>
 80113ee:	2300      	movs	r3, #0
}
 80113f0:	4618      	mov	r0, r3
 80113f2:	46bd      	mov	sp, r7
 80113f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80113f8:	4770      	bx	lr

080113fa <LL_RCC_PLL_GetN>:
{
 80113fa:	b480      	push	{r7}
 80113fc:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80113fe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011402:	68db      	ldr	r3, [r3, #12]
 8011404:	0a1b      	lsrs	r3, r3, #8
 8011406:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 801140a:	4618      	mov	r0, r3
 801140c:	46bd      	mov	sp, r7
 801140e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011412:	4770      	bx	lr

08011414 <LL_RCC_PLL_GetR>:
{
 8011414:	b480      	push	{r7}
 8011416:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8011418:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801141c:	68db      	ldr	r3, [r3, #12]
 801141e:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 8011422:	4618      	mov	r0, r3
 8011424:	46bd      	mov	sp, r7
 8011426:	f85d 7b04 	ldr.w	r7, [sp], #4
 801142a:	4770      	bx	lr

0801142c <LL_RCC_PLL_GetDivider>:
{
 801142c:	b480      	push	{r7}
 801142e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8011430:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011434:	68db      	ldr	r3, [r3, #12]
 8011436:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 801143a:	4618      	mov	r0, r3
 801143c:	46bd      	mov	sp, r7
 801143e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011442:	4770      	bx	lr

08011444 <LL_RCC_PLL_GetMainSource>:
{
 8011444:	b480      	push	{r7}
 8011446:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8011448:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801144c:	68db      	ldr	r3, [r3, #12]
 801144e:	f003 0303 	and.w	r3, r3, #3
}
 8011452:	4618      	mov	r0, r3
 8011454:	46bd      	mov	sp, r7
 8011456:	f85d 7b04 	ldr.w	r7, [sp], #4
 801145a:	4770      	bx	lr

0801145c <LL_RCC_IsActiveFlag_HPRE>:
{
 801145c:	b480      	push	{r7}
 801145e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 8011460:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011464:	689b      	ldr	r3, [r3, #8]
 8011466:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801146a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801146e:	d101      	bne.n	8011474 <LL_RCC_IsActiveFlag_HPRE+0x18>
 8011470:	2301      	movs	r3, #1
 8011472:	e000      	b.n	8011476 <LL_RCC_IsActiveFlag_HPRE+0x1a>
 8011474:	2300      	movs	r3, #0
}
 8011476:	4618      	mov	r0, r3
 8011478:	46bd      	mov	sp, r7
 801147a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801147e:	4770      	bx	lr

08011480 <LL_RCC_IsActiveFlag_C2HPRE>:
{
 8011480:	b480      	push	{r7}
 8011482:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 8011484:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011488:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801148c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8011490:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8011494:	d101      	bne.n	801149a <LL_RCC_IsActiveFlag_C2HPRE+0x1a>
 8011496:	2301      	movs	r3, #1
 8011498:	e000      	b.n	801149c <LL_RCC_IsActiveFlag_C2HPRE+0x1c>
 801149a:	2300      	movs	r3, #0
}
 801149c:	4618      	mov	r0, r3
 801149e:	46bd      	mov	sp, r7
 80114a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114a4:	4770      	bx	lr

080114a6 <LL_RCC_IsActiveFlag_SHDHPRE>:
{
 80114a6:	b480      	push	{r7}
 80114a8:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 80114aa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80114ae:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80114b2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80114b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80114ba:	d101      	bne.n	80114c0 <LL_RCC_IsActiveFlag_SHDHPRE+0x1a>
 80114bc:	2301      	movs	r3, #1
 80114be:	e000      	b.n	80114c2 <LL_RCC_IsActiveFlag_SHDHPRE+0x1c>
 80114c0:	2300      	movs	r3, #0
}
 80114c2:	4618      	mov	r0, r3
 80114c4:	46bd      	mov	sp, r7
 80114c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114ca:	4770      	bx	lr

080114cc <LL_RCC_IsActiveFlag_PPRE1>:
{
 80114cc:	b480      	push	{r7}
 80114ce:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 80114d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80114d4:	689b      	ldr	r3, [r3, #8]
 80114d6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80114da:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80114de:	d101      	bne.n	80114e4 <LL_RCC_IsActiveFlag_PPRE1+0x18>
 80114e0:	2301      	movs	r3, #1
 80114e2:	e000      	b.n	80114e6 <LL_RCC_IsActiveFlag_PPRE1+0x1a>
 80114e4:	2300      	movs	r3, #0
}
 80114e6:	4618      	mov	r0, r3
 80114e8:	46bd      	mov	sp, r7
 80114ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80114ee:	4770      	bx	lr

080114f0 <LL_RCC_IsActiveFlag_PPRE2>:
{
 80114f0:	b480      	push	{r7}
 80114f2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 80114f4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80114f8:	689b      	ldr	r3, [r3, #8]
 80114fa:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80114fe:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8011502:	d101      	bne.n	8011508 <LL_RCC_IsActiveFlag_PPRE2+0x18>
 8011504:	2301      	movs	r3, #1
 8011506:	e000      	b.n	801150a <LL_RCC_IsActiveFlag_PPRE2+0x1a>
 8011508:	2300      	movs	r3, #0
}
 801150a:	4618      	mov	r0, r3
 801150c:	46bd      	mov	sp, r7
 801150e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011512:	4770      	bx	lr

08011514 <HAL_RCC_OscConfig>:
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL source is not updated when used as PLLSAI1 clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8011514:	b590      	push	{r4, r7, lr}
 8011516:	b08d      	sub	sp, #52	; 0x34
 8011518:	af00      	add	r7, sp, #0
 801151a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 801151c:	687b      	ldr	r3, [r7, #4]
 801151e:	2b00      	cmp	r3, #0
 8011520:	d101      	bne.n	8011526 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8011522:	2301      	movs	r3, #1
 8011524:	e37e      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8011526:	687b      	ldr	r3, [r7, #4]
 8011528:	681b      	ldr	r3, [r3, #0]
 801152a:	f003 0320 	and.w	r3, r3, #32
 801152e:	2b00      	cmp	r3, #0
 8011530:	f000 8092 	beq.w	8011658 <HAL_RCC_OscConfig+0x144>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8011534:	f7ff fe7d 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011538:	62f8      	str	r0, [r7, #44]	; 0x2c
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 801153a:	f7ff ff83 	bl	8011444 <LL_RCC_PLL_GetMainSource>
 801153e:	62b8      	str	r0, [r7, #40]	; 0x28
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8011540:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011542:	2b00      	cmp	r3, #0
 8011544:	d005      	beq.n	8011552 <HAL_RCC_OscConfig+0x3e>
 8011546:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011548:	2b0c      	cmp	r3, #12
 801154a:	d14c      	bne.n	80115e6 <HAL_RCC_OscConfig+0xd2>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_MSI)))
 801154c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801154e:	2b01      	cmp	r3, #1
 8011550:	d149      	bne.n	80115e6 <HAL_RCC_OscConfig+0xd2>
    {
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8011552:	f7ff fe0b 	bl	801116c <LL_RCC_MSI_IsReady>
 8011556:	4603      	mov	r3, r0
 8011558:	2b00      	cmp	r3, #0
 801155a:	d005      	beq.n	8011568 <HAL_RCC_OscConfig+0x54>
 801155c:	687b      	ldr	r3, [r7, #4]
 801155e:	69db      	ldr	r3, [r3, #28]
 8011560:	2b00      	cmp	r3, #0
 8011562:	d101      	bne.n	8011568 <HAL_RCC_OscConfig+0x54>
      {
        return HAL_ERROR;
 8011564:	2301      	movs	r3, #1
 8011566:	e35d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the AHB4 clock
           and the supply voltage of the device. */
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8011568:	687b      	ldr	r3, [r7, #4]
 801156a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 801156c:	f7ff fe23 	bl	80111b6 <LL_RCC_MSI_GetRange>
 8011570:	4603      	mov	r3, r0
 8011572:	429c      	cmp	r4, r3
 8011574:	d914      	bls.n	80115a0 <HAL_RCC_OscConfig+0x8c>
        {
          /* First increase number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8011576:	687b      	ldr	r3, [r7, #4]
 8011578:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801157a:	4618      	mov	r0, r3
 801157c:	f000 fd5e 	bl	801203c <RCC_SetFlashLatencyFromMSIRange>
 8011580:	4603      	mov	r3, r0
 8011582:	2b00      	cmp	r3, #0
 8011584:	d001      	beq.n	801158a <HAL_RCC_OscConfig+0x76>
          {
            return HAL_ERROR;
 8011586:	2301      	movs	r3, #1
 8011588:	e34c      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 801158a:	687b      	ldr	r3, [r7, #4]
 801158c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801158e:	4618      	mov	r0, r3
 8011590:	f7ff fdfd 	bl	801118e <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8011594:	687b      	ldr	r3, [r7, #4]
 8011596:	6a1b      	ldr	r3, [r3, #32]
 8011598:	4618      	mov	r0, r3
 801159a:	f7ff fe21 	bl	80111e0 <LL_RCC_MSI_SetCalibTrimming>
 801159e:	e013      	b.n	80115c8 <HAL_RCC_OscConfig+0xb4>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80115a0:	687b      	ldr	r3, [r7, #4]
 80115a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115a4:	4618      	mov	r0, r3
 80115a6:	f7ff fdf2 	bl	801118e <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80115aa:	687b      	ldr	r3, [r7, #4]
 80115ac:	6a1b      	ldr	r3, [r3, #32]
 80115ae:	4618      	mov	r0, r3
 80115b0:	f7ff fe16 	bl	80111e0 <LL_RCC_MSI_SetCalibTrimming>

          /* Decrease number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80115b4:	687b      	ldr	r3, [r7, #4]
 80115b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115b8:	4618      	mov	r0, r3
 80115ba:	f000 fd3f 	bl	801203c <RCC_SetFlashLatencyFromMSIRange>
 80115be:	4603      	mov	r3, r0
 80115c0:	2b00      	cmp	r3, #0
 80115c2:	d001      	beq.n	80115c8 <HAL_RCC_OscConfig+0xb4>
          {
            return HAL_ERROR;
 80115c4:	2301      	movs	r3, #1
 80115c6:	e32d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80115c8:	f000 fcdc 	bl	8011f84 <HAL_RCC_GetHCLKFreq>
 80115cc:	4603      	mov	r3, r0
 80115ce:	4ab3      	ldr	r2, [pc, #716]	; (801189c <HAL_RCC_OscConfig+0x388>)
 80115d0:	6013      	str	r3, [r2, #0]
        
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 80115d2:	4bb3      	ldr	r3, [pc, #716]	; (80118a0 <HAL_RCC_OscConfig+0x38c>)
 80115d4:	681b      	ldr	r3, [r3, #0]
 80115d6:	4618      	mov	r0, r3
 80115d8:	f7fa fce4 	bl	800bfa4 <HAL_InitTick>
 80115dc:	4603      	mov	r3, r0
 80115de:	2b00      	cmp	r3, #0
 80115e0:	d039      	beq.n	8011656 <HAL_RCC_OscConfig+0x142>
        {
          return HAL_ERROR;
 80115e2:	2301      	movs	r3, #1
 80115e4:	e31e      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      }
    }
    else
    {
      /* Check the MSI State */
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80115e6:	687b      	ldr	r3, [r7, #4]
 80115e8:	69db      	ldr	r3, [r3, #28]
 80115ea:	2b00      	cmp	r3, #0
 80115ec:	d01e      	beq.n	801162c <HAL_RCC_OscConfig+0x118>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80115ee:	f7ff fd9f 	bl	8011130 <LL_RCC_MSI_Enable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 80115f2:	f7fb fa49 	bl	800ca88 <HAL_GetTick>
 80115f6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
 80115f8:	e008      	b.n	801160c <HAL_RCC_OscConfig+0xf8>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80115fa:	f7fb fa45 	bl	800ca88 <HAL_GetTick>
 80115fe:	4602      	mov	r2, r0
 8011600:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011602:	1ad3      	subs	r3, r2, r3
 8011604:	2b02      	cmp	r3, #2
 8011606:	d901      	bls.n	801160c <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 8011608:	2303      	movs	r3, #3
 801160a:	e30b      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_MSI_IsReady() == 0U)
 801160c:	f7ff fdae 	bl	801116c <LL_RCC_MSI_IsReady>
 8011610:	4603      	mov	r3, r0
 8011612:	2b00      	cmp	r3, #0
 8011614:	d0f1      	beq.n	80115fa <HAL_RCC_OscConfig+0xe6>
          }
        }

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8011616:	687b      	ldr	r3, [r7, #4]
 8011618:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801161a:	4618      	mov	r0, r3
 801161c:	f7ff fdb7 	bl	801118e <LL_RCC_MSI_SetRange>
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8011620:	687b      	ldr	r3, [r7, #4]
 8011622:	6a1b      	ldr	r3, [r3, #32]
 8011624:	4618      	mov	r0, r3
 8011626:	f7ff fddb 	bl	80111e0 <LL_RCC_MSI_SetCalibTrimming>
 801162a:	e015      	b.n	8011658 <HAL_RCC_OscConfig+0x144>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 801162c:	f7ff fd8f 	bl	801114e <LL_RCC_MSI_Disable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 8011630:	f7fb fa2a 	bl	800ca88 <HAL_GetTick>
 8011634:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
 8011636:	e008      	b.n	801164a <HAL_RCC_OscConfig+0x136>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8011638:	f7fb fa26 	bl	800ca88 <HAL_GetTick>
 801163c:	4602      	mov	r2, r0
 801163e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011640:	1ad3      	subs	r3, r2, r3
 8011642:	2b02      	cmp	r3, #2
 8011644:	d901      	bls.n	801164a <HAL_RCC_OscConfig+0x136>
          {
            return HAL_TIMEOUT;
 8011646:	2303      	movs	r3, #3
 8011648:	e2ec      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_MSI_IsReady() != 0U)
 801164a:	f7ff fd8f 	bl	801116c <LL_RCC_MSI_IsReady>
 801164e:	4603      	mov	r3, r0
 8011650:	2b00      	cmp	r3, #0
 8011652:	d1f1      	bne.n	8011638 <HAL_RCC_OscConfig+0x124>
 8011654:	e000      	b.n	8011658 <HAL_RCC_OscConfig+0x144>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8011656:	bf00      	nop
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8011658:	687b      	ldr	r3, [r7, #4]
 801165a:	681b      	ldr	r3, [r3, #0]
 801165c:	f003 0301 	and.w	r3, r3, #1
 8011660:	2b00      	cmp	r3, #0
 8011662:	d04e      	beq.n	8011702 <HAL_RCC_OscConfig+0x1ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8011664:	f7ff fde5 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011668:	6238      	str	r0, [r7, #32]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 801166a:	f7ff feeb 	bl	8011444 <LL_RCC_PLL_GetMainSource>
 801166e:	61f8      	str	r0, [r7, #28]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8011670:	6a3b      	ldr	r3, [r7, #32]
 8011672:	2b08      	cmp	r3, #8
 8011674:	d005      	beq.n	8011682 <HAL_RCC_OscConfig+0x16e>
 8011676:	6a3b      	ldr	r3, [r7, #32]
 8011678:	2b0c      	cmp	r3, #12
 801167a:	d10d      	bne.n	8011698 <HAL_RCC_OscConfig+0x184>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSE)))
 801167c:	69fb      	ldr	r3, [r7, #28]
 801167e:	2b03      	cmp	r3, #3
 8011680:	d10a      	bne.n	8011698 <HAL_RCC_OscConfig+0x184>
    {
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8011682:	f7ff fbf5 	bl	8010e70 <LL_RCC_HSE_IsReady>
 8011686:	4603      	mov	r3, r0
 8011688:	2b00      	cmp	r3, #0
 801168a:	d039      	beq.n	8011700 <HAL_RCC_OscConfig+0x1ec>
 801168c:	687b      	ldr	r3, [r7, #4]
 801168e:	685b      	ldr	r3, [r3, #4]
 8011690:	2b00      	cmp	r3, #0
 8011692:	d135      	bne.n	8011700 <HAL_RCC_OscConfig+0x1ec>
      {
        return HAL_ERROR;
 8011694:	2301      	movs	r3, #1
 8011696:	e2c5      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8011698:	687b      	ldr	r3, [r7, #4]
 801169a:	685b      	ldr	r3, [r3, #4]
 801169c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80116a0:	d102      	bne.n	80116a8 <HAL_RCC_OscConfig+0x194>
 80116a2:	f7ff fbc7 	bl	8010e34 <LL_RCC_HSE_Enable>
 80116a6:	e001      	b.n	80116ac <HAL_RCC_OscConfig+0x198>
 80116a8:	f7ff fbd3 	bl	8010e52 <LL_RCC_HSE_Disable>

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80116ac:	687b      	ldr	r3, [r7, #4]
 80116ae:	685b      	ldr	r3, [r3, #4]
 80116b0:	2b00      	cmp	r3, #0
 80116b2:	d012      	beq.n	80116da <HAL_RCC_OscConfig+0x1c6>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80116b4:	f7fb f9e8 	bl	800ca88 <HAL_GetTick>
 80116b8:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while (LL_RCC_HSE_IsReady() == 0U)
 80116ba:	e008      	b.n	80116ce <HAL_RCC_OscConfig+0x1ba>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80116bc:	f7fb f9e4 	bl	800ca88 <HAL_GetTick>
 80116c0:	4602      	mov	r2, r0
 80116c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80116c4:	1ad3      	subs	r3, r2, r3
 80116c6:	2b64      	cmp	r3, #100	; 0x64
 80116c8:	d901      	bls.n	80116ce <HAL_RCC_OscConfig+0x1ba>
          {
            return HAL_TIMEOUT;
 80116ca:	2303      	movs	r3, #3
 80116cc:	e2aa      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSE_IsReady() == 0U)
 80116ce:	f7ff fbcf 	bl	8010e70 <LL_RCC_HSE_IsReady>
 80116d2:	4603      	mov	r3, r0
 80116d4:	2b00      	cmp	r3, #0
 80116d6:	d0f1      	beq.n	80116bc <HAL_RCC_OscConfig+0x1a8>
 80116d8:	e013      	b.n	8011702 <HAL_RCC_OscConfig+0x1ee>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80116da:	f7fb f9d5 	bl	800ca88 <HAL_GetTick>
 80116de:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while (LL_RCC_HSE_IsReady() != 0U)
 80116e0:	e008      	b.n	80116f4 <HAL_RCC_OscConfig+0x1e0>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80116e2:	f7fb f9d1 	bl	800ca88 <HAL_GetTick>
 80116e6:	4602      	mov	r2, r0
 80116e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80116ea:	1ad3      	subs	r3, r2, r3
 80116ec:	2b64      	cmp	r3, #100	; 0x64
 80116ee:	d901      	bls.n	80116f4 <HAL_RCC_OscConfig+0x1e0>
          {
            return HAL_TIMEOUT;
 80116f0:	2303      	movs	r3, #3
 80116f2:	e297      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSE_IsReady() != 0U)
 80116f4:	f7ff fbbc 	bl	8010e70 <LL_RCC_HSE_IsReady>
 80116f8:	4603      	mov	r3, r0
 80116fa:	2b00      	cmp	r3, #0
 80116fc:	d1f1      	bne.n	80116e2 <HAL_RCC_OscConfig+0x1ce>
 80116fe:	e000      	b.n	8011702 <HAL_RCC_OscConfig+0x1ee>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8011700:	bf00      	nop
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8011702:	687b      	ldr	r3, [r7, #4]
 8011704:	681b      	ldr	r3, [r3, #0]
 8011706:	f003 0302 	and.w	r3, r3, #2
 801170a:	2b00      	cmp	r3, #0
 801170c:	d051      	beq.n	80117b2 <HAL_RCC_OscConfig+0x29e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 801170e:	f7ff fd90 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011712:	61b8      	str	r0, [r7, #24]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 8011714:	f7ff fe96 	bl	8011444 <LL_RCC_PLL_GetMainSource>
 8011718:	6178      	str	r0, [r7, #20]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 801171a:	69bb      	ldr	r3, [r7, #24]
 801171c:	2b04      	cmp	r3, #4
 801171e:	d005      	beq.n	801172c <HAL_RCC_OscConfig+0x218>
 8011720:	69bb      	ldr	r3, [r7, #24]
 8011722:	2b0c      	cmp	r3, #12
 8011724:	d113      	bne.n	801174e <HAL_RCC_OscConfig+0x23a>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSI)))
 8011726:	697b      	ldr	r3, [r7, #20]
 8011728:	2b02      	cmp	r3, #2
 801172a:	d110      	bne.n	801174e <HAL_RCC_OscConfig+0x23a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 801172c:	f7ff fbd0 	bl	8010ed0 <LL_RCC_HSI_IsReady>
 8011730:	4603      	mov	r3, r0
 8011732:	2b00      	cmp	r3, #0
 8011734:	d005      	beq.n	8011742 <HAL_RCC_OscConfig+0x22e>
 8011736:	687b      	ldr	r3, [r7, #4]
 8011738:	68db      	ldr	r3, [r3, #12]
 801173a:	2b00      	cmp	r3, #0
 801173c:	d101      	bne.n	8011742 <HAL_RCC_OscConfig+0x22e>
      {
        return HAL_ERROR;
 801173e:	2301      	movs	r3, #1
 8011740:	e270      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8011742:	687b      	ldr	r3, [r7, #4]
 8011744:	691b      	ldr	r3, [r3, #16]
 8011746:	4618      	mov	r0, r3
 8011748:	f7ff fbd4 	bl	8010ef4 <LL_RCC_HSI_SetCalibTrimming>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 801174c:	e031      	b.n	80117b2 <HAL_RCC_OscConfig+0x29e>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 801174e:	687b      	ldr	r3, [r7, #4]
 8011750:	68db      	ldr	r3, [r3, #12]
 8011752:	2b00      	cmp	r3, #0
 8011754:	d019      	beq.n	801178a <HAL_RCC_OscConfig+0x276>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8011756:	f7ff fb9d 	bl	8010e94 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801175a:	f7fb f995 	bl	800ca88 <HAL_GetTick>
 801175e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
 8011760:	e008      	b.n	8011774 <HAL_RCC_OscConfig+0x260>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8011762:	f7fb f991 	bl	800ca88 <HAL_GetTick>
 8011766:	4602      	mov	r2, r0
 8011768:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801176a:	1ad3      	subs	r3, r2, r3
 801176c:	2b02      	cmp	r3, #2
 801176e:	d901      	bls.n	8011774 <HAL_RCC_OscConfig+0x260>
          {
            return HAL_TIMEOUT;
 8011770:	2303      	movs	r3, #3
 8011772:	e257      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSI_IsReady() == 0U)
 8011774:	f7ff fbac 	bl	8010ed0 <LL_RCC_HSI_IsReady>
 8011778:	4603      	mov	r3, r0
 801177a:	2b00      	cmp	r3, #0
 801177c:	d0f1      	beq.n	8011762 <HAL_RCC_OscConfig+0x24e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 801177e:	687b      	ldr	r3, [r7, #4]
 8011780:	691b      	ldr	r3, [r3, #16]
 8011782:	4618      	mov	r0, r3
 8011784:	f7ff fbb6 	bl	8010ef4 <LL_RCC_HSI_SetCalibTrimming>
 8011788:	e013      	b.n	80117b2 <HAL_RCC_OscConfig+0x29e>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 801178a:	f7ff fb92 	bl	8010eb2 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801178e:	f7fb f97b 	bl	800ca88 <HAL_GetTick>
 8011792:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
 8011794:	e008      	b.n	80117a8 <HAL_RCC_OscConfig+0x294>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8011796:	f7fb f977 	bl	800ca88 <HAL_GetTick>
 801179a:	4602      	mov	r2, r0
 801179c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801179e:	1ad3      	subs	r3, r2, r3
 80117a0:	2b02      	cmp	r3, #2
 80117a2:	d901      	bls.n	80117a8 <HAL_RCC_OscConfig+0x294>
          {
            return HAL_TIMEOUT;
 80117a4:	2303      	movs	r3, #3
 80117a6:	e23d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSI_IsReady() != 0U)
 80117a8:	f7ff fb92 	bl	8010ed0 <LL_RCC_HSI_IsReady>
 80117ac:	4603      	mov	r3, r0
 80117ae:	2b00      	cmp	r3, #0
 80117b0:	d1f1      	bne.n	8011796 <HAL_RCC_OscConfig+0x282>
      }
    }
  }
  /*------------------------------ LSI Configuration (LSI1 or LSI2) -------------------------*/

  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 80117b2:	687b      	ldr	r3, [r7, #4]
 80117b4:	681b      	ldr	r3, [r3, #0]
 80117b6:	f003 0308 	and.w	r3, r3, #8
 80117ba:	2b00      	cmp	r3, #0
 80117bc:	d106      	bne.n	80117cc <HAL_RCC_OscConfig+0x2b8>
      (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2))
 80117be:	687b      	ldr	r3, [r7, #4]
 80117c0:	681b      	ldr	r3, [r3, #0]
 80117c2:	f003 0310 	and.w	r3, r3, #16
  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 80117c6:	2b00      	cmp	r3, #0
 80117c8:	f000 80a3 	beq.w	8011912 <HAL_RCC_OscConfig+0x3fe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80117cc:	687b      	ldr	r3, [r7, #4]
 80117ce:	695b      	ldr	r3, [r3, #20]
 80117d0:	2b00      	cmp	r3, #0
 80117d2:	d076      	beq.n	80118c2 <HAL_RCC_OscConfig+0x3ae>
    {
      /*------------------------------ LSI2 selected by default (when Switch ON) -------------------------*/
      if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2)
 80117d4:	687b      	ldr	r3, [r7, #4]
 80117d6:	681b      	ldr	r3, [r3, #0]
 80117d8:	f003 0310 	and.w	r3, r3, #16
 80117dc:	2b00      	cmp	r3, #0
 80117de:	d046      	beq.n	801186e <HAL_RCC_OscConfig+0x35a>
      {
        assert_param(IS_RCC_LSI2_CALIBRATION_VALUE(RCC_OscInitStruct->LSI2CalibrationValue));

        /* 1. Check LSI1 state and enable if required */
        if (LL_RCC_LSI1_IsReady() == 0U)
 80117e0:	f7ff fc49 	bl	8011076 <LL_RCC_LSI1_IsReady>
 80117e4:	4603      	mov	r3, r0
 80117e6:	2b00      	cmp	r3, #0
 80117e8:	d113      	bne.n	8011812 <HAL_RCC_OscConfig+0x2fe>
        {
          /* This is required to enable LSI1 before enabling LSI2 */
          __HAL_RCC_LSI1_ENABLE();
 80117ea:	f7ff fc22 	bl	8011032 <LL_RCC_LSI1_Enable>

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 80117ee:	f7fb f94b 	bl	800ca88 <HAL_GetTick>
 80117f2:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till LSI1 is ready */
          while (LL_RCC_LSI1_IsReady() == 0U)
 80117f4:	e008      	b.n	8011808 <HAL_RCC_OscConfig+0x2f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80117f6:	f7fb f947 	bl	800ca88 <HAL_GetTick>
 80117fa:	4602      	mov	r2, r0
 80117fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117fe:	1ad3      	subs	r3, r2, r3
 8011800:	2b02      	cmp	r3, #2
 8011802:	d901      	bls.n	8011808 <HAL_RCC_OscConfig+0x2f4>
            {
              return HAL_TIMEOUT;
 8011804:	2303      	movs	r3, #3
 8011806:	e20d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
          while (LL_RCC_LSI1_IsReady() == 0U)
 8011808:	f7ff fc35 	bl	8011076 <LL_RCC_LSI1_IsReady>
 801180c:	4603      	mov	r3, r0
 801180e:	2b00      	cmp	r3, #0
 8011810:	d0f1      	beq.n	80117f6 <HAL_RCC_OscConfig+0x2e2>
            }
          }
        }

        /* 2. Enable the Internal Low Speed oscillator (LSI2) and set trimming value */
        __HAL_RCC_LSI2_ENABLE();
 8011812:	f7ff fc42 	bl	801109a <LL_RCC_LSI2_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8011816:	f7fb f937 	bl	800ca88 <HAL_GetTick>
 801181a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI2 is ready */
        while (LL_RCC_LSI2_IsReady() == 0U)
 801181c:	e008      	b.n	8011830 <HAL_RCC_OscConfig+0x31c>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 801181e:	f7fb f933 	bl	800ca88 <HAL_GetTick>
 8011822:	4602      	mov	r2, r0
 8011824:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011826:	1ad3      	subs	r3, r2, r3
 8011828:	2b03      	cmp	r3, #3
 801182a:	d901      	bls.n	8011830 <HAL_RCC_OscConfig+0x31c>
          {
            return HAL_TIMEOUT;
 801182c:	2303      	movs	r3, #3
 801182e:	e1f9      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI2_IsReady() == 0U)
 8011830:	f7ff fc55 	bl	80110de <LL_RCC_LSI2_IsReady>
 8011834:	4603      	mov	r3, r0
 8011836:	2b00      	cmp	r3, #0
 8011838:	d0f1      	beq.n	801181e <HAL_RCC_OscConfig+0x30a>
          }
        }
        /* Adjusts the Internal Low Spee oscillator (LSI2) calibration value */
        __HAL_RCC_LSI2_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->LSI2CalibrationValue);
 801183a:	687b      	ldr	r3, [r7, #4]
 801183c:	699b      	ldr	r3, [r3, #24]
 801183e:	4618      	mov	r0, r3
 8011840:	f7ff fc5f 	bl	8011102 <LL_RCC_LSI2_SetTrimming>

        /* 3. Disable LSI1 */

        /* LSI1 was initially not enable, require to disable it */
        __HAL_RCC_LSI1_DISABLE();
 8011844:	f7ff fc06 	bl	8011054 <LL_RCC_LSI1_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8011848:	f7fb f91e 	bl	800ca88 <HAL_GetTick>
 801184c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is disabled */
        while (LL_RCC_LSI1_IsReady() != 0U)
 801184e:	e008      	b.n	8011862 <HAL_RCC_OscConfig+0x34e>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8011850:	f7fb f91a 	bl	800ca88 <HAL_GetTick>
 8011854:	4602      	mov	r2, r0
 8011856:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011858:	1ad3      	subs	r3, r2, r3
 801185a:	2b02      	cmp	r3, #2
 801185c:	d901      	bls.n	8011862 <HAL_RCC_OscConfig+0x34e>
          {
            return HAL_TIMEOUT;
 801185e:	2303      	movs	r3, #3
 8011860:	e1e0      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI1_IsReady() != 0U)
 8011862:	f7ff fc08 	bl	8011076 <LL_RCC_LSI1_IsReady>
 8011866:	4603      	mov	r3, r0
 8011868:	2b00      	cmp	r3, #0
 801186a:	d1f1      	bne.n	8011850 <HAL_RCC_OscConfig+0x33c>
 801186c:	e051      	b.n	8011912 <HAL_RCC_OscConfig+0x3fe>
      else
      {
        /*------------------------------ LSI1 selected (only if LSI2 OFF)-------------------------*/

        /* 1. Enable the Internal Low Speed oscillator (LSI1). */
        __HAL_RCC_LSI1_ENABLE();
 801186e:	f7ff fbe0 	bl	8011032 <LL_RCC_LSI1_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8011872:	f7fb f909 	bl	800ca88 <HAL_GetTick>
 8011876:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is ready */
        while (LL_RCC_LSI1_IsReady() == 0U)
 8011878:	e008      	b.n	801188c <HAL_RCC_OscConfig+0x378>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 801187a:	f7fb f905 	bl	800ca88 <HAL_GetTick>
 801187e:	4602      	mov	r2, r0
 8011880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011882:	1ad3      	subs	r3, r2, r3
 8011884:	2b02      	cmp	r3, #2
 8011886:	d901      	bls.n	801188c <HAL_RCC_OscConfig+0x378>
          {
            return HAL_TIMEOUT;
 8011888:	2303      	movs	r3, #3
 801188a:	e1cb      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI1_IsReady() == 0U)
 801188c:	f7ff fbf3 	bl	8011076 <LL_RCC_LSI1_IsReady>
 8011890:	4603      	mov	r3, r0
 8011892:	2b00      	cmp	r3, #0
 8011894:	d0f1      	beq.n	801187a <HAL_RCC_OscConfig+0x366>
          }
        }
        /*2. Switch OFF LSI2*/

        /* Disable the Internal Low Speed oscillator (LSI2). */
        __HAL_RCC_LSI2_DISABLE();
 8011896:	f7ff fc11 	bl	80110bc <LL_RCC_LSI2_Disable>

        /* Wait till LSI2 is disabled */
        while (LL_RCC_LSI2_IsReady() != 0U)
 801189a:	e00c      	b.n	80118b6 <HAL_RCC_OscConfig+0x3a2>
 801189c:	20000010 	.word	0x20000010
 80118a0:	20000014 	.word	0x20000014
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 80118a4:	f7fb f8f0 	bl	800ca88 <HAL_GetTick>
 80118a8:	4602      	mov	r2, r0
 80118aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118ac:	1ad3      	subs	r3, r2, r3
 80118ae:	2b03      	cmp	r3, #3
 80118b0:	d901      	bls.n	80118b6 <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
 80118b2:	2303      	movs	r3, #3
 80118b4:	e1b6      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI2_IsReady() != 0U)
 80118b6:	f7ff fc12 	bl	80110de <LL_RCC_LSI2_IsReady>
 80118ba:	4603      	mov	r3, r0
 80118bc:	2b00      	cmp	r3, #0
 80118be:	d1f1      	bne.n	80118a4 <HAL_RCC_OscConfig+0x390>
 80118c0:	e027      	b.n	8011912 <HAL_RCC_OscConfig+0x3fe>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI2). */
      __HAL_RCC_LSI2_DISABLE();
 80118c2:	f7ff fbfb 	bl	80110bc <LL_RCC_LSI2_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80118c6:	f7fb f8df 	bl	800ca88 <HAL_GetTick>
 80118ca:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI2 is disabled */
      while (LL_RCC_LSI2_IsReady() != 0U)
 80118cc:	e008      	b.n	80118e0 <HAL_RCC_OscConfig+0x3cc>
      {
        if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 80118ce:	f7fb f8db 	bl	800ca88 <HAL_GetTick>
 80118d2:	4602      	mov	r2, r0
 80118d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118d6:	1ad3      	subs	r3, r2, r3
 80118d8:	2b03      	cmp	r3, #3
 80118da:	d901      	bls.n	80118e0 <HAL_RCC_OscConfig+0x3cc>
        {
          return HAL_TIMEOUT;
 80118dc:	2303      	movs	r3, #3
 80118de:	e1a1      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSI2_IsReady() != 0U)
 80118e0:	f7ff fbfd 	bl	80110de <LL_RCC_LSI2_IsReady>
 80118e4:	4603      	mov	r3, r0
 80118e6:	2b00      	cmp	r3, #0
 80118e8:	d1f1      	bne.n	80118ce <HAL_RCC_OscConfig+0x3ba>
        }
      }

      /* Disable the Internal Low Speed oscillator (LSI1). */
      __HAL_RCC_LSI1_DISABLE();
 80118ea:	f7ff fbb3 	bl	8011054 <LL_RCC_LSI1_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80118ee:	f7fb f8cb 	bl	800ca88 <HAL_GetTick>
 80118f2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI1 is disabled */
      while (LL_RCC_LSI1_IsReady() != 0U)
 80118f4:	e008      	b.n	8011908 <HAL_RCC_OscConfig+0x3f4>
      {
        if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80118f6:	f7fb f8c7 	bl	800ca88 <HAL_GetTick>
 80118fa:	4602      	mov	r2, r0
 80118fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118fe:	1ad3      	subs	r3, r2, r3
 8011900:	2b02      	cmp	r3, #2
 8011902:	d901      	bls.n	8011908 <HAL_RCC_OscConfig+0x3f4>
        {
          return HAL_TIMEOUT;
 8011904:	2303      	movs	r3, #3
 8011906:	e18d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSI1_IsReady() != 0U)
 8011908:	f7ff fbb5 	bl	8011076 <LL_RCC_LSI1_IsReady>
 801190c:	4603      	mov	r3, r0
 801190e:	2b00      	cmp	r3, #0
 8011910:	d1f1      	bne.n	80118f6 <HAL_RCC_OscConfig+0x3e2>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8011912:	687b      	ldr	r3, [r7, #4]
 8011914:	681b      	ldr	r3, [r3, #0]
 8011916:	f003 0304 	and.w	r3, r3, #4
 801191a:	2b00      	cmp	r3, #0
 801191c:	d05b      	beq.n	80119d6 <HAL_RCC_OscConfig+0x4c2>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 801191e:	4bb5      	ldr	r3, [pc, #724]	; (8011bf4 <HAL_RCC_OscConfig+0x6e0>)
 8011920:	681b      	ldr	r3, [r3, #0]
 8011922:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011926:	2b00      	cmp	r3, #0
 8011928:	d114      	bne.n	8011954 <HAL_RCC_OscConfig+0x440>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 801192a:	f7ff fa43 	bl	8010db4 <HAL_PWR_EnableBkUpAccess>

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 801192e:	f7fb f8ab 	bl	800ca88 <HAL_GetTick>
 8011932:	6278      	str	r0, [r7, #36]	; 0x24

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8011934:	e008      	b.n	8011948 <HAL_RCC_OscConfig+0x434>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8011936:	f7fb f8a7 	bl	800ca88 <HAL_GetTick>
 801193a:	4602      	mov	r2, r0
 801193c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801193e:	1ad3      	subs	r3, r2, r3
 8011940:	2b02      	cmp	r3, #2
 8011942:	d901      	bls.n	8011948 <HAL_RCC_OscConfig+0x434>
        {
          return HAL_TIMEOUT;
 8011944:	2303      	movs	r3, #3
 8011946:	e16d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8011948:	4baa      	ldr	r3, [pc, #680]	; (8011bf4 <HAL_RCC_OscConfig+0x6e0>)
 801194a:	681b      	ldr	r3, [r3, #0]
 801194c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011950:	2b00      	cmp	r3, #0
 8011952:	d0f0      	beq.n	8011936 <HAL_RCC_OscConfig+0x422>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8011954:	687b      	ldr	r3, [r7, #4]
 8011956:	689b      	ldr	r3, [r3, #8]
 8011958:	2b01      	cmp	r3, #1
 801195a:	d102      	bne.n	8011962 <HAL_RCC_OscConfig+0x44e>
 801195c:	f7ff fb13 	bl	8010f86 <LL_RCC_LSE_Enable>
 8011960:	e00c      	b.n	801197c <HAL_RCC_OscConfig+0x468>
 8011962:	687b      	ldr	r3, [r7, #4]
 8011964:	689b      	ldr	r3, [r3, #8]
 8011966:	2b05      	cmp	r3, #5
 8011968:	d104      	bne.n	8011974 <HAL_RCC_OscConfig+0x460>
 801196a:	f7ff fb2e 	bl	8010fca <LL_RCC_LSE_EnableBypass>
 801196e:	f7ff fb0a 	bl	8010f86 <LL_RCC_LSE_Enable>
 8011972:	e003      	b.n	801197c <HAL_RCC_OscConfig+0x468>
 8011974:	f7ff fb18 	bl	8010fa8 <LL_RCC_LSE_Disable>
 8011978:	f7ff fb38 	bl	8010fec <LL_RCC_LSE_DisableBypass>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 801197c:	687b      	ldr	r3, [r7, #4]
 801197e:	689b      	ldr	r3, [r3, #8]
 8011980:	2b00      	cmp	r3, #0
 8011982:	d014      	beq.n	80119ae <HAL_RCC_OscConfig+0x49a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8011984:	f7fb f880 	bl	800ca88 <HAL_GetTick>
 8011988:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
 801198a:	e00a      	b.n	80119a2 <HAL_RCC_OscConfig+0x48e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801198c:	f7fb f87c 	bl	800ca88 <HAL_GetTick>
 8011990:	4602      	mov	r2, r0
 8011992:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011994:	1ad3      	subs	r3, r2, r3
 8011996:	f241 3288 	movw	r2, #5000	; 0x1388
 801199a:	4293      	cmp	r3, r2
 801199c:	d901      	bls.n	80119a2 <HAL_RCC_OscConfig+0x48e>
        {
          return HAL_TIMEOUT;
 801199e:	2303      	movs	r3, #3
 80119a0:	e140      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSE_IsReady() == 0U)
 80119a2:	f7ff fb34 	bl	801100e <LL_RCC_LSE_IsReady>
 80119a6:	4603      	mov	r3, r0
 80119a8:	2b00      	cmp	r3, #0
 80119aa:	d0ef      	beq.n	801198c <HAL_RCC_OscConfig+0x478>
 80119ac:	e013      	b.n	80119d6 <HAL_RCC_OscConfig+0x4c2>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80119ae:	f7fb f86b 	bl	800ca88 <HAL_GetTick>
 80119b2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
 80119b4:	e00a      	b.n	80119cc <HAL_RCC_OscConfig+0x4b8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80119b6:	f7fb f867 	bl	800ca88 <HAL_GetTick>
 80119ba:	4602      	mov	r2, r0
 80119bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119be:	1ad3      	subs	r3, r2, r3
 80119c0:	f241 3288 	movw	r2, #5000	; 0x1388
 80119c4:	4293      	cmp	r3, r2
 80119c6:	d901      	bls.n	80119cc <HAL_RCC_OscConfig+0x4b8>
        {
          return HAL_TIMEOUT;
 80119c8:	2303      	movs	r3, #3
 80119ca:	e12b      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSE_IsReady() != 0U)
 80119cc:	f7ff fb1f 	bl	801100e <LL_RCC_LSE_IsReady>
 80119d0:	4603      	mov	r3, r0
 80119d2:	2b00      	cmp	r3, #0
 80119d4:	d1ef      	bne.n	80119b6 <HAL_RCC_OscConfig+0x4a2>
    }

  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80119d6:	687b      	ldr	r3, [r7, #4]
 80119d8:	681b      	ldr	r3, [r3, #0]
 80119da:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80119de:	2b00      	cmp	r3, #0
 80119e0:	d02c      	beq.n	8011a3c <HAL_RCC_OscConfig+0x528>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80119e2:	687b      	ldr	r3, [r7, #4]
 80119e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80119e6:	2b00      	cmp	r3, #0
 80119e8:	d014      	beq.n	8011a14 <HAL_RCC_OscConfig+0x500>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80119ea:	f7ff fa98 	bl	8010f1e <LL_RCC_HSI48_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80119ee:	f7fb f84b 	bl	800ca88 <HAL_GetTick>
 80119f2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (LL_RCC_HSI48_IsReady() == 0U)
 80119f4:	e008      	b.n	8011a08 <HAL_RCC_OscConfig+0x4f4>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80119f6:	f7fb f847 	bl	800ca88 <HAL_GetTick>
 80119fa:	4602      	mov	r2, r0
 80119fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119fe:	1ad3      	subs	r3, r2, r3
 8011a00:	2b02      	cmp	r3, #2
 8011a02:	d901      	bls.n	8011a08 <HAL_RCC_OscConfig+0x4f4>
        {
          return HAL_TIMEOUT;
 8011a04:	2303      	movs	r3, #3
 8011a06:	e10d      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_HSI48_IsReady() == 0U)
 8011a08:	f7ff faab 	bl	8010f62 <LL_RCC_HSI48_IsReady>
 8011a0c:	4603      	mov	r3, r0
 8011a0e:	2b00      	cmp	r3, #0
 8011a10:	d0f1      	beq.n	80119f6 <HAL_RCC_OscConfig+0x4e2>
 8011a12:	e013      	b.n	8011a3c <HAL_RCC_OscConfig+0x528>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8011a14:	f7ff fa94 	bl	8010f40 <LL_RCC_HSI48_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8011a18:	f7fb f836 	bl	800ca88 <HAL_GetTick>
 8011a1c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is disabled */
      while (LL_RCC_HSI48_IsReady() != 0U)
 8011a1e:	e008      	b.n	8011a32 <HAL_RCC_OscConfig+0x51e>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8011a20:	f7fb f832 	bl	800ca88 <HAL_GetTick>
 8011a24:	4602      	mov	r2, r0
 8011a26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011a28:	1ad3      	subs	r3, r2, r3
 8011a2a:	2b02      	cmp	r3, #2
 8011a2c:	d901      	bls.n	8011a32 <HAL_RCC_OscConfig+0x51e>
        {
          return HAL_TIMEOUT;
 8011a2e:	2303      	movs	r3, #3
 8011a30:	e0f8      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_HSI48_IsReady() != 0U)
 8011a32:	f7ff fa96 	bl	8010f62 <LL_RCC_HSI48_IsReady>
 8011a36:	4603      	mov	r3, r0
 8011a38:	2b00      	cmp	r3, #0
 8011a3a:	d1f1      	bne.n	8011a20 <HAL_RCC_OscConfig+0x50c>
#endif
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8011a3c:	687b      	ldr	r3, [r7, #4]
 8011a3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011a40:	2b00      	cmp	r3, #0
 8011a42:	f000 80ee 	beq.w	8011c22 <HAL_RCC_OscConfig+0x70e>
  {
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8011a46:	f7ff fbf4 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011a4a:	6138      	str	r0, [r7, #16]
    const uint32_t temp_pllconfig = RCC->PLLCFGR;
 8011a4c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011a50:	68db      	ldr	r3, [r3, #12]
 8011a52:	60fb      	str	r3, [r7, #12]
    
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8011a54:	687b      	ldr	r3, [r7, #4]
 8011a56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011a58:	2b02      	cmp	r3, #2
 8011a5a:	f040 80af 	bne.w	8011bbc <HAL_RCC_OscConfig+0x6a8>
      assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
      
      /* Do nothing if PLL configuration is unchanged */
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8011a5e:	68fb      	ldr	r3, [r7, #12]
 8011a60:	f003 0203 	and.w	r2, r3, #3
 8011a64:	687b      	ldr	r3, [r7, #4]
 8011a66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011a68:	429a      	cmp	r2, r3
 8011a6a:	d123      	bne.n	8011ab4 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8011a6c:	68fb      	ldr	r3, [r7, #12]
 8011a6e:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8011a72:	687b      	ldr	r3, [r7, #4]
 8011a74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8011a76:	429a      	cmp	r2, r3
 8011a78:	d11c      	bne.n	8011ab4 <HAL_RCC_OscConfig+0x5a0>
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8011a7a:	68fb      	ldr	r3, [r7, #12]
 8011a7c:	0a1b      	lsrs	r3, r3, #8
 8011a7e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8011a82:	687b      	ldr	r3, [r7, #4]
 8011a84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8011a86:	429a      	cmp	r2, r3
 8011a88:	d114      	bne.n	8011ab4 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8011a8a:	68fb      	ldr	r3, [r7, #12]
 8011a8c:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 8011a90:	687b      	ldr	r3, [r7, #4]
 8011a92:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8011a94:	429a      	cmp	r2, r3
 8011a96:	d10d      	bne.n	8011ab4 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8011a98:	68fb      	ldr	r3, [r7, #12]
 8011a9a:	f003 6260 	and.w	r2, r3, #234881024	; 0xe000000
 8011a9e:	687b      	ldr	r3, [r7, #4]
 8011aa0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8011aa2:	429a      	cmp	r2, r3
 8011aa4:	d106      	bne.n	8011ab4 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLR) != RCC_OscInitStruct->PLL.PLLR))
 8011aa6:	68fb      	ldr	r3, [r7, #12]
 8011aa8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 8011aac:	687b      	ldr	r3, [r7, #4]
 8011aae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8011ab0:	429a      	cmp	r2, r3
 8011ab2:	d05d      	beq.n	8011b70 <HAL_RCC_OscConfig+0x65c>
      {
        /* Check if the PLL is used as system clock or not */
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8011ab4:	693b      	ldr	r3, [r7, #16]
 8011ab6:	2b0c      	cmp	r3, #12
 8011ab8:	d058      	beq.n	8011b6c <HAL_RCC_OscConfig+0x658>
        {
#if defined(SAI1)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8011aba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011abe:	681b      	ldr	r3, [r3, #0]
 8011ac0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8011ac4:	2b00      	cmp	r3, #0
 8011ac6:	d001      	beq.n	8011acc <HAL_RCC_OscConfig+0x5b8>

          {
            return HAL_ERROR;
 8011ac8:	2301      	movs	r3, #1
 8011aca:	e0ab      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
          }
          else
#endif
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 8011acc:	f7ff fc74 	bl	80113b8 <LL_RCC_PLL_Disable>
            
            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8011ad0:	f7fa ffda 	bl	800ca88 <HAL_GetTick>
 8011ad4:	6278      	str	r0, [r7, #36]	; 0x24
            
            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8011ad6:	e008      	b.n	8011aea <HAL_RCC_OscConfig+0x5d6>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8011ad8:	f7fa ffd6 	bl	800ca88 <HAL_GetTick>
 8011adc:	4602      	mov	r2, r0
 8011ade:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ae0:	1ad3      	subs	r3, r2, r3
 8011ae2:	2b02      	cmp	r3, #2
 8011ae4:	d901      	bls.n	8011aea <HAL_RCC_OscConfig+0x5d6>
              {
                return HAL_TIMEOUT;
 8011ae6:	2303      	movs	r3, #3
 8011ae8:	e09c      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8011aea:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011aee:	681b      	ldr	r3, [r3, #0]
 8011af0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011af4:	2b00      	cmp	r3, #0
 8011af6:	d1ef      	bne.n	8011ad8 <HAL_RCC_OscConfig+0x5c4>
              }
            }
            
            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8011af8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011afc:	68da      	ldr	r2, [r3, #12]
 8011afe:	4b3e      	ldr	r3, [pc, #248]	; (8011bf8 <HAL_RCC_OscConfig+0x6e4>)
 8011b00:	4013      	ands	r3, r2
 8011b02:	687a      	ldr	r2, [r7, #4]
 8011b04:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8011b06:	687a      	ldr	r2, [r7, #4]
 8011b08:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8011b0a:	4311      	orrs	r1, r2
 8011b0c:	687a      	ldr	r2, [r7, #4]
 8011b0e:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8011b10:	0212      	lsls	r2, r2, #8
 8011b12:	4311      	orrs	r1, r2
 8011b14:	687a      	ldr	r2, [r7, #4]
 8011b16:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8011b18:	4311      	orrs	r1, r2
 8011b1a:	687a      	ldr	r2, [r7, #4]
 8011b1c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8011b1e:	4311      	orrs	r1, r2
 8011b20:	687a      	ldr	r2, [r7, #4]
 8011b22:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8011b24:	430a      	orrs	r2, r1
 8011b26:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011b2a:	4313      	orrs	r3, r2
 8011b2c:	60cb      	str	r3, [r1, #12]
                                 RCC_OscInitStruct->PLL.PLLP,
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);
            
            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 8011b2e:	f7ff fc34 	bl	801139a <LL_RCC_PLL_Enable>
            
            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8011b32:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011b36:	68db      	ldr	r3, [r3, #12]
 8011b38:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011b3c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011b40:	60d3      	str	r3, [r2, #12]
            
            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8011b42:	f7fa ffa1 	bl	800ca88 <HAL_GetTick>
 8011b46:	6278      	str	r0, [r7, #36]	; 0x24
            
            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8011b48:	e008      	b.n	8011b5c <HAL_RCC_OscConfig+0x648>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8011b4a:	f7fa ff9d 	bl	800ca88 <HAL_GetTick>
 8011b4e:	4602      	mov	r2, r0
 8011b50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b52:	1ad3      	subs	r3, r2, r3
 8011b54:	2b02      	cmp	r3, #2
 8011b56:	d901      	bls.n	8011b5c <HAL_RCC_OscConfig+0x648>
              {
                return HAL_TIMEOUT;
 8011b58:	2303      	movs	r3, #3
 8011b5a:	e063      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8011b5c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011b60:	681b      	ldr	r3, [r3, #0]
 8011b62:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011b66:	2b00      	cmp	r3, #0
 8011b68:	d0ef      	beq.n	8011b4a <HAL_RCC_OscConfig+0x636>
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8011b6a:	e05a      	b.n	8011c22 <HAL_RCC_OscConfig+0x70e>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8011b6c:	2301      	movs	r3, #1
 8011b6e:	e059      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8011b70:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011b74:	681b      	ldr	r3, [r3, #0]
 8011b76:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011b7a:	2b00      	cmp	r3, #0
 8011b7c:	d151      	bne.n	8011c22 <HAL_RCC_OscConfig+0x70e>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8011b7e:	f7ff fc0c 	bl	801139a <LL_RCC_PLL_Enable>

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8011b82:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011b86:	68db      	ldr	r3, [r3, #12]
 8011b88:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011b8c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011b90:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8011b92:	f7fa ff79 	bl	800ca88 <HAL_GetTick>
 8011b96:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till PLL is ready */
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8011b98:	e008      	b.n	8011bac <HAL_RCC_OscConfig+0x698>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8011b9a:	f7fa ff75 	bl	800ca88 <HAL_GetTick>
 8011b9e:	4602      	mov	r2, r0
 8011ba0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ba2:	1ad3      	subs	r3, r2, r3
 8011ba4:	2b02      	cmp	r3, #2
 8011ba6:	d901      	bls.n	8011bac <HAL_RCC_OscConfig+0x698>
            {
              return HAL_TIMEOUT;
 8011ba8:	2303      	movs	r3, #3
 8011baa:	e03b      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8011bac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011bb0:	681b      	ldr	r3, [r3, #0]
 8011bb2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011bb6:	2b00      	cmp	r3, #0
 8011bb8:	d0ef      	beq.n	8011b9a <HAL_RCC_OscConfig+0x686>
 8011bba:	e032      	b.n	8011c22 <HAL_RCC_OscConfig+0x70e>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8011bbc:	693b      	ldr	r3, [r7, #16]
 8011bbe:	2b0c      	cmp	r3, #12
 8011bc0:	d02d      	beq.n	8011c1e <HAL_RCC_OscConfig+0x70a>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8011bc2:	f7ff fbf9 	bl	80113b8 <LL_RCC_PLL_Disable>
        

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8011bc6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011bca:	68db      	ldr	r3, [r3, #12]
 8011bcc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011bd0:	f023 0303 	bic.w	r3, r3, #3
 8011bd4:	60d3      	str	r3, [r2, #12]

#if defined(SAI1) && defined(USB)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_USBCLK | RCC_PLL_SAI1CLK);
 8011bd6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011bda:	68db      	ldr	r3, [r3, #12]
 8011bdc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011be0:	f023 5388 	bic.w	r3, r3, #285212672	; 0x11000000
 8011be4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8011be8:	60d3      	str	r3, [r2, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK);
#endif

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8011bea:	f7fa ff4d 	bl	800ca88 <HAL_GetTick>
 8011bee:	6278      	str	r0, [r7, #36]	; 0x24
        
        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8011bf0:	e00d      	b.n	8011c0e <HAL_RCC_OscConfig+0x6fa>
 8011bf2:	bf00      	nop
 8011bf4:	58000400 	.word	0x58000400
 8011bf8:	11c1808c 	.word	0x11c1808c
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8011bfc:	f7fa ff44 	bl	800ca88 <HAL_GetTick>
 8011c00:	4602      	mov	r2, r0
 8011c02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011c04:	1ad3      	subs	r3, r2, r3
 8011c06:	2b02      	cmp	r3, #2
 8011c08:	d901      	bls.n	8011c0e <HAL_RCC_OscConfig+0x6fa>
          {
            return HAL_TIMEOUT;
 8011c0a:	2303      	movs	r3, #3
 8011c0c:	e00a      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8011c0e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011c12:	681b      	ldr	r3, [r3, #0]
 8011c14:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8011c18:	2b00      	cmp	r3, #0
 8011c1a:	d1ef      	bne.n	8011bfc <HAL_RCC_OscConfig+0x6e8>
 8011c1c:	e001      	b.n	8011c22 <HAL_RCC_OscConfig+0x70e>
        }
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 8011c1e:	2301      	movs	r3, #1
 8011c20:	e000      	b.n	8011c24 <HAL_RCC_OscConfig+0x710>
      }
    }
  }
  return HAL_OK;
 8011c22:	2300      	movs	r3, #0
}
 8011c24:	4618      	mov	r0, r3
 8011c26:	3734      	adds	r7, #52	; 0x34
 8011c28:	46bd      	mov	sp, r7
 8011c2a:	bd90      	pop	{r4, r7, pc}

08011c2c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK1 not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8011c2c:	b580      	push	{r7, lr}
 8011c2e:	b084      	sub	sp, #16
 8011c30:	af00      	add	r7, sp, #0
 8011c32:	6078      	str	r0, [r7, #4]
 8011c34:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8011c36:	687b      	ldr	r3, [r7, #4]
 8011c38:	2b00      	cmp	r3, #0
 8011c3a:	d101      	bne.n	8011c40 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8011c3c:	2301      	movs	r3, #1
 8011c3e:	e12d      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the FLASH clock
    (HCLK4) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8011c40:	4b98      	ldr	r3, [pc, #608]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011c42:	681b      	ldr	r3, [r3, #0]
 8011c44:	f003 0307 	and.w	r3, r3, #7
 8011c48:	683a      	ldr	r2, [r7, #0]
 8011c4a:	429a      	cmp	r2, r3
 8011c4c:	d91b      	bls.n	8011c86 <HAL_RCC_ClockConfig+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8011c4e:	4b95      	ldr	r3, [pc, #596]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011c50:	681b      	ldr	r3, [r3, #0]
 8011c52:	f023 0207 	bic.w	r2, r3, #7
 8011c56:	4993      	ldr	r1, [pc, #588]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011c58:	683b      	ldr	r3, [r7, #0]
 8011c5a:	4313      	orrs	r3, r2
 8011c5c:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8011c5e:	f7fa ff13 	bl	800ca88 <HAL_GetTick>
 8011c62:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8011c64:	e008      	b.n	8011c78 <HAL_RCC_ClockConfig+0x4c>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8011c66:	f7fa ff0f 	bl	800ca88 <HAL_GetTick>
 8011c6a:	4602      	mov	r2, r0
 8011c6c:	68fb      	ldr	r3, [r7, #12]
 8011c6e:	1ad3      	subs	r3, r2, r3
 8011c70:	2b02      	cmp	r3, #2
 8011c72:	d901      	bls.n	8011c78 <HAL_RCC_ClockConfig+0x4c>
      {
        return HAL_TIMEOUT;
 8011c74:	2303      	movs	r3, #3
 8011c76:	e111      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8011c78:	4b8a      	ldr	r3, [pc, #552]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011c7a:	681b      	ldr	r3, [r3, #0]
 8011c7c:	f003 0307 	and.w	r3, r3, #7
 8011c80:	683a      	ldr	r2, [r7, #0]
 8011c82:	429a      	cmp	r2, r3
 8011c84:	d1ef      	bne.n	8011c66 <HAL_RCC_ClockConfig+0x3a>
      }
    }
  }

  /*-------------------------- HCLK1 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8011c86:	687b      	ldr	r3, [r7, #4]
 8011c88:	681b      	ldr	r3, [r3, #0]
 8011c8a:	f003 0302 	and.w	r3, r3, #2
 8011c8e:	2b00      	cmp	r3, #0
 8011c90:	d016      	beq.n	8011cc0 <HAL_RCC_ClockConfig+0x94>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLKDivider));
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 8011c92:	687b      	ldr	r3, [r7, #4]
 8011c94:	689b      	ldr	r3, [r3, #8]
 8011c96:	4618      	mov	r0, r3
 8011c98:	f7ff fad7 	bl	801124a <LL_RCC_SetAHBPrescaler>

    /* HCLK1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8011c9c:	f7fa fef4 	bl	800ca88 <HAL_GetTick>
 8011ca0:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8011ca2:	e008      	b.n	8011cb6 <HAL_RCC_ClockConfig+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8011ca4:	f7fa fef0 	bl	800ca88 <HAL_GetTick>
 8011ca8:	4602      	mov	r2, r0
 8011caa:	68fb      	ldr	r3, [r7, #12]
 8011cac:	1ad3      	subs	r3, r2, r3
 8011cae:	2b02      	cmp	r3, #2
 8011cb0:	d901      	bls.n	8011cb6 <HAL_RCC_ClockConfig+0x8a>
      {
        return HAL_TIMEOUT;
 8011cb2:	2303      	movs	r3, #3
 8011cb4:	e0f2      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8011cb6:	f7ff fbd1 	bl	801145c <LL_RCC_IsActiveFlag_HPRE>
 8011cba:	4603      	mov	r3, r0
 8011cbc:	2b00      	cmp	r3, #0
 8011cbe:	d0f1      	beq.n	8011ca4 <HAL_RCC_ClockConfig+0x78>
      }
    }
  }

  /*-------------------------- HCLK2 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 8011cc0:	687b      	ldr	r3, [r7, #4]
 8011cc2:	681b      	ldr	r3, [r3, #0]
 8011cc4:	f003 0320 	and.w	r3, r3, #32
 8011cc8:	2b00      	cmp	r3, #0
 8011cca:	d016      	beq.n	8011cfa <HAL_RCC_ClockConfig+0xce>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK2Divider));
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 8011ccc:	687b      	ldr	r3, [r7, #4]
 8011cce:	695b      	ldr	r3, [r3, #20]
 8011cd0:	4618      	mov	r0, r3
 8011cd2:	f7ff face 	bl	8011272 <LL_C2_RCC_SetAHBPrescaler>

    /* HCLK2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8011cd6:	f7fa fed7 	bl	800ca88 <HAL_GetTick>
 8011cda:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 8011cdc:	e008      	b.n	8011cf0 <HAL_RCC_ClockConfig+0xc4>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8011cde:	f7fa fed3 	bl	800ca88 <HAL_GetTick>
 8011ce2:	4602      	mov	r2, r0
 8011ce4:	68fb      	ldr	r3, [r7, #12]
 8011ce6:	1ad3      	subs	r3, r2, r3
 8011ce8:	2b02      	cmp	r3, #2
 8011cea:	d901      	bls.n	8011cf0 <HAL_RCC_ClockConfig+0xc4>
      {
        return HAL_TIMEOUT;
 8011cec:	2303      	movs	r3, #3
 8011cee:	e0d5      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 8011cf0:	f7ff fbc6 	bl	8011480 <LL_RCC_IsActiveFlag_C2HPRE>
 8011cf4:	4603      	mov	r3, r0
 8011cf6:	2b00      	cmp	r3, #0
 8011cf8:	d0f1      	beq.n	8011cde <HAL_RCC_ClockConfig+0xb2>
      }
    }
  }
  /*-------------------------- HCLK4 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK4) == RCC_CLOCKTYPE_HCLK4)
 8011cfa:	687b      	ldr	r3, [r7, #4]
 8011cfc:	681b      	ldr	r3, [r3, #0]
 8011cfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011d02:	2b00      	cmp	r3, #0
 8011d04:	d016      	beq.n	8011d34 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK4Divider));
    LL_RCC_SetAHB4Prescaler(RCC_ClkInitStruct->AHBCLK4Divider);
 8011d06:	687b      	ldr	r3, [r7, #4]
 8011d08:	699b      	ldr	r3, [r3, #24]
 8011d0a:	4618      	mov	r0, r3
 8011d0c:	f7ff fac7 	bl	801129e <LL_RCC_SetAHB4Prescaler>

    /* AHB shared prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8011d10:	f7fa feba 	bl	800ca88 <HAL_GetTick>
 8011d14:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 8011d16:	e008      	b.n	8011d2a <HAL_RCC_ClockConfig+0xfe>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8011d18:	f7fa feb6 	bl	800ca88 <HAL_GetTick>
 8011d1c:	4602      	mov	r2, r0
 8011d1e:	68fb      	ldr	r3, [r7, #12]
 8011d20:	1ad3      	subs	r3, r2, r3
 8011d22:	2b02      	cmp	r3, #2
 8011d24:	d901      	bls.n	8011d2a <HAL_RCC_ClockConfig+0xfe>
      {
        return HAL_TIMEOUT;
 8011d26:	2303      	movs	r3, #3
 8011d28:	e0b8      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 8011d2a:	f7ff fbbc 	bl	80114a6 <LL_RCC_IsActiveFlag_SHDHPRE>
 8011d2e:	4603      	mov	r3, r0
 8011d30:	2b00      	cmp	r3, #0
 8011d32:	d0f1      	beq.n	8011d18 <HAL_RCC_ClockConfig+0xec>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8011d34:	687b      	ldr	r3, [r7, #4]
 8011d36:	681b      	ldr	r3, [r3, #0]
 8011d38:	f003 0304 	and.w	r3, r3, #4
 8011d3c:	2b00      	cmp	r3, #0
 8011d3e:	d016      	beq.n	8011d6e <HAL_RCC_ClockConfig+0x142>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB1CLKDivider));
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 8011d40:	687b      	ldr	r3, [r7, #4]
 8011d42:	68db      	ldr	r3, [r3, #12]
 8011d44:	4618      	mov	r0, r3
 8011d46:	f7ff fac1 	bl	80112cc <LL_RCC_SetAPB1Prescaler>

    /* APB1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8011d4a:	f7fa fe9d 	bl	800ca88 <HAL_GetTick>
 8011d4e:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8011d50:	e008      	b.n	8011d64 <HAL_RCC_ClockConfig+0x138>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8011d52:	f7fa fe99 	bl	800ca88 <HAL_GetTick>
 8011d56:	4602      	mov	r2, r0
 8011d58:	68fb      	ldr	r3, [r7, #12]
 8011d5a:	1ad3      	subs	r3, r2, r3
 8011d5c:	2b02      	cmp	r3, #2
 8011d5e:	d901      	bls.n	8011d64 <HAL_RCC_ClockConfig+0x138>
      {
        return HAL_TIMEOUT;
 8011d60:	2303      	movs	r3, #3
 8011d62:	e09b      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8011d64:	f7ff fbb2 	bl	80114cc <LL_RCC_IsActiveFlag_PPRE1>
 8011d68:	4603      	mov	r3, r0
 8011d6a:	2b00      	cmp	r3, #0
 8011d6c:	d0f1      	beq.n	8011d52 <HAL_RCC_ClockConfig+0x126>
      }
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8011d6e:	687b      	ldr	r3, [r7, #4]
 8011d70:	681b      	ldr	r3, [r3, #0]
 8011d72:	f003 0308 	and.w	r3, r3, #8
 8011d76:	2b00      	cmp	r3, #0
 8011d78:	d017      	beq.n	8011daa <HAL_RCC_ClockConfig+0x17e>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB2CLKDivider));
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 8011d7a:	687b      	ldr	r3, [r7, #4]
 8011d7c:	691b      	ldr	r3, [r3, #16]
 8011d7e:	00db      	lsls	r3, r3, #3
 8011d80:	4618      	mov	r0, r3
 8011d82:	f7ff fab7 	bl	80112f4 <LL_RCC_SetAPB2Prescaler>

    /* APB2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8011d86:	f7fa fe7f 	bl	800ca88 <HAL_GetTick>
 8011d8a:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8011d8c:	e008      	b.n	8011da0 <HAL_RCC_ClockConfig+0x174>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8011d8e:	f7fa fe7b 	bl	800ca88 <HAL_GetTick>
 8011d92:	4602      	mov	r2, r0
 8011d94:	68fb      	ldr	r3, [r7, #12]
 8011d96:	1ad3      	subs	r3, r2, r3
 8011d98:	2b02      	cmp	r3, #2
 8011d9a:	d901      	bls.n	8011da0 <HAL_RCC_ClockConfig+0x174>
      {
        return HAL_TIMEOUT;
 8011d9c:	2303      	movs	r3, #3
 8011d9e:	e07d      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8011da0:	f7ff fba6 	bl	80114f0 <LL_RCC_IsActiveFlag_PPRE2>
 8011da4:	4603      	mov	r3, r0
 8011da6:	2b00      	cmp	r3, #0
 8011da8:	d0f1      	beq.n	8011d8e <HAL_RCC_ClockConfig+0x162>
      }
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8011daa:	687b      	ldr	r3, [r7, #4]
 8011dac:	681b      	ldr	r3, [r3, #0]
 8011dae:	f003 0301 	and.w	r3, r3, #1
 8011db2:	2b00      	cmp	r3, #0
 8011db4:	d043      	beq.n	8011e3e <HAL_RCC_ClockConfig+0x212>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8011db6:	687b      	ldr	r3, [r7, #4]
 8011db8:	685b      	ldr	r3, [r3, #4]
 8011dba:	2b02      	cmp	r3, #2
 8011dbc:	d106      	bne.n	8011dcc <HAL_RCC_ClockConfig+0x1a0>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
 8011dbe:	f7ff f857 	bl	8010e70 <LL_RCC_HSE_IsReady>
 8011dc2:	4603      	mov	r3, r0
 8011dc4:	2b00      	cmp	r3, #0
 8011dc6:	d11e      	bne.n	8011e06 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8011dc8:	2301      	movs	r3, #1
 8011dca:	e067      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8011dcc:	687b      	ldr	r3, [r7, #4]
 8011dce:	685b      	ldr	r3, [r3, #4]
 8011dd0:	2b03      	cmp	r3, #3
 8011dd2:	d106      	bne.n	8011de2 <HAL_RCC_ClockConfig+0x1b6>
    {
      /* Check the PLL ready flag */
      if (LL_RCC_PLL_IsReady() == 0U)
 8011dd4:	f7ff faff 	bl	80113d6 <LL_RCC_PLL_IsReady>
 8011dd8:	4603      	mov	r3, r0
 8011dda:	2b00      	cmp	r3, #0
 8011ddc:	d113      	bne.n	8011e06 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8011dde:	2301      	movs	r3, #1
 8011de0:	e05c      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* MSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8011de2:	687b      	ldr	r3, [r7, #4]
 8011de4:	685b      	ldr	r3, [r3, #4]
 8011de6:	2b00      	cmp	r3, #0
 8011de8:	d106      	bne.n	8011df8 <HAL_RCC_ClockConfig+0x1cc>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
 8011dea:	f7ff f9bf 	bl	801116c <LL_RCC_MSI_IsReady>
 8011dee:	4603      	mov	r3, r0
 8011df0:	2b00      	cmp	r3, #0
 8011df2:	d108      	bne.n	8011e06 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8011df4:	2301      	movs	r3, #1
 8011df6:	e051      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
 8011df8:	f7ff f86a 	bl	8010ed0 <LL_RCC_HSI_IsReady>
 8011dfc:	4603      	mov	r3, r0
 8011dfe:	2b00      	cmp	r3, #0
 8011e00:	d101      	bne.n	8011e06 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8011e02:	2301      	movs	r3, #1
 8011e04:	e04a      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
      }

    }

    /* apply system clock switch */
    LL_RCC_SetSysClkSource(RCC_ClkInitStruct->SYSCLKSource);
 8011e06:	687b      	ldr	r3, [r7, #4]
 8011e08:	685b      	ldr	r3, [r3, #4]
 8011e0a:	4618      	mov	r0, r3
 8011e0c:	f7ff f9fd 	bl	801120a <LL_RCC_SetSysClkSource>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8011e10:	f7fa fe3a 	bl	800ca88 <HAL_GetTick>
 8011e14:	60f8      	str	r0, [r7, #12]

    /* check system clock source switch status */
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8011e16:	e00a      	b.n	8011e2e <HAL_RCC_ClockConfig+0x202>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8011e18:	f7fa fe36 	bl	800ca88 <HAL_GetTick>
 8011e1c:	4602      	mov	r2, r0
 8011e1e:	68fb      	ldr	r3, [r7, #12]
 8011e20:	1ad3      	subs	r3, r2, r3
 8011e22:	f241 3288 	movw	r2, #5000	; 0x1388
 8011e26:	4293      	cmp	r3, r2
 8011e28:	d901      	bls.n	8011e2e <HAL_RCC_ClockConfig+0x202>
      {
        return HAL_TIMEOUT;
 8011e2a:	2303      	movs	r3, #3
 8011e2c:	e036      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8011e2e:	f7ff fa00 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011e32:	4602      	mov	r2, r0
 8011e34:	687b      	ldr	r3, [r7, #4]
 8011e36:	685b      	ldr	r3, [r3, #4]
 8011e38:	009b      	lsls	r3, r3, #2
 8011e3a:	429a      	cmp	r2, r3
 8011e3c:	d1ec      	bne.n	8011e18 <HAL_RCC_ClockConfig+0x1ec>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8011e3e:	4b19      	ldr	r3, [pc, #100]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011e40:	681b      	ldr	r3, [r3, #0]
 8011e42:	f003 0307 	and.w	r3, r3, #7
 8011e46:	683a      	ldr	r2, [r7, #0]
 8011e48:	429a      	cmp	r2, r3
 8011e4a:	d21b      	bcs.n	8011e84 <HAL_RCC_ClockConfig+0x258>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8011e4c:	4b15      	ldr	r3, [pc, #84]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011e4e:	681b      	ldr	r3, [r3, #0]
 8011e50:	f023 0207 	bic.w	r2, r3, #7
 8011e54:	4913      	ldr	r1, [pc, #76]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011e56:	683b      	ldr	r3, [r7, #0]
 8011e58:	4313      	orrs	r3, r2
 8011e5a:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8011e5c:	f7fa fe14 	bl	800ca88 <HAL_GetTick>
 8011e60:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8011e62:	e008      	b.n	8011e76 <HAL_RCC_ClockConfig+0x24a>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8011e64:	f7fa fe10 	bl	800ca88 <HAL_GetTick>
 8011e68:	4602      	mov	r2, r0
 8011e6a:	68fb      	ldr	r3, [r7, #12]
 8011e6c:	1ad3      	subs	r3, r2, r3
 8011e6e:	2b02      	cmp	r3, #2
 8011e70:	d901      	bls.n	8011e76 <HAL_RCC_ClockConfig+0x24a>
      {
        return HAL_TIMEOUT;
 8011e72:	2303      	movs	r3, #3
 8011e74:	e012      	b.n	8011e9c <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8011e76:	4b0b      	ldr	r3, [pc, #44]	; (8011ea4 <HAL_RCC_ClockConfig+0x278>)
 8011e78:	681b      	ldr	r3, [r3, #0]
 8011e7a:	f003 0307 	and.w	r3, r3, #7
 8011e7e:	683a      	ldr	r2, [r7, #0]
 8011e80:	429a      	cmp	r2, r3
 8011e82:	d1ef      	bne.n	8011e64 <HAL_RCC_ClockConfig+0x238>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8011e84:	f000 f87e 	bl	8011f84 <HAL_RCC_GetHCLKFreq>
 8011e88:	4603      	mov	r3, r0
 8011e8a:	4a07      	ldr	r2, [pc, #28]	; (8011ea8 <HAL_RCC_ClockConfig+0x27c>)
 8011e8c:	6013      	str	r3, [r2, #0]
  
  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
 8011e8e:	f7fa fe07 	bl	800caa0 <HAL_GetTickPrio>
 8011e92:	4603      	mov	r3, r0
 8011e94:	4618      	mov	r0, r3
 8011e96:	f7fa f885 	bl	800bfa4 <HAL_InitTick>
 8011e9a:	4603      	mov	r3, r0
}
 8011e9c:	4618      	mov	r0, r3
 8011e9e:	3710      	adds	r7, #16
 8011ea0:	46bd      	mov	sp, r7
 8011ea2:	bd80      	pop	{r7, pc}
 8011ea4:	58004000 	.word	0x58004000
 8011ea8:	20000010 	.word	0x20000010

08011eac <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8011eac:	b590      	push	{r4, r7, lr}
 8011eae:	b085      	sub	sp, #20
 8011eb0:	af00      	add	r7, sp, #0
  uint32_t pllsource;
  uint32_t sysclockfreq, pllinputfreq;
  const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8011eb2:	f7ff f9be 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011eb6:	6078      	str	r0, [r7, #4]

  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI)
 8011eb8:	687b      	ldr	r3, [r7, #4]
 8011eba:	2b00      	cmp	r3, #0
 8011ebc:	d10a      	bne.n	8011ed4 <HAL_RCC_GetSysClockFreq+0x28>
  {
    /* Retrieve MSI frequency range in HZ*/
    /* MSI used as system clock source */
    sysclockfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8011ebe:	f7ff f97a 	bl	80111b6 <LL_RCC_MSI_GetRange>
 8011ec2:	4603      	mov	r3, r0
 8011ec4:	091b      	lsrs	r3, r3, #4
 8011ec6:	f003 030f 	and.w	r3, r3, #15
 8011eca:	4a2b      	ldr	r2, [pc, #172]	; (8011f78 <HAL_RCC_GetSysClockFreq+0xcc>)
 8011ecc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011ed0:	60fb      	str	r3, [r7, #12]
 8011ed2:	e04b      	b.n	8011f6c <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 8011ed4:	687b      	ldr	r3, [r7, #4]
 8011ed6:	2b04      	cmp	r3, #4
 8011ed8:	d102      	bne.n	8011ee0 <HAL_RCC_GetSysClockFreq+0x34>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8011eda:	4b28      	ldr	r3, [pc, #160]	; (8011f7c <HAL_RCC_GetSysClockFreq+0xd0>)
 8011edc:	60fb      	str	r3, [r7, #12]
 8011ede:	e045      	b.n	8011f6c <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE)
 8011ee0:	687b      	ldr	r3, [r7, #4]
 8011ee2:	2b08      	cmp	r3, #8
 8011ee4:	d10a      	bne.n	8011efc <HAL_RCC_GetSysClockFreq+0x50>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8011ee6:	f7fe ff93 	bl	8010e10 <LL_RCC_HSE_IsEnabledDiv2>
 8011eea:	4603      	mov	r3, r0
 8011eec:	2b01      	cmp	r3, #1
 8011eee:	d102      	bne.n	8011ef6 <HAL_RCC_GetSysClockFreq+0x4a>
    {
      sysclockfreq = HSE_VALUE / 2U;
 8011ef0:	4b22      	ldr	r3, [pc, #136]	; (8011f7c <HAL_RCC_GetSysClockFreq+0xd0>)
 8011ef2:	60fb      	str	r3, [r7, #12]
 8011ef4:	e03a      	b.n	8011f6c <HAL_RCC_GetSysClockFreq+0xc0>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8011ef6:	4b22      	ldr	r3, [pc, #136]	; (8011f80 <HAL_RCC_GetSysClockFreq+0xd4>)
 8011ef8:	60fb      	str	r3, [r7, #12]
 8011efa:	e037      	b.n	8011f6c <HAL_RCC_GetSysClockFreq+0xc0>
    }
  }
  else
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8011efc:	f7ff faa2 	bl	8011444 <LL_RCC_PLL_GetMainSource>
 8011f00:	6038      	str	r0, [r7, #0]
    switch (pllsource)
 8011f02:	683b      	ldr	r3, [r7, #0]
 8011f04:	2b02      	cmp	r3, #2
 8011f06:	d003      	beq.n	8011f10 <HAL_RCC_GetSysClockFreq+0x64>
 8011f08:	683b      	ldr	r3, [r7, #0]
 8011f0a:	2b03      	cmp	r3, #3
 8011f0c:	d003      	beq.n	8011f16 <HAL_RCC_GetSysClockFreq+0x6a>
 8011f0e:	e00d      	b.n	8011f2c <HAL_RCC_GetSysClockFreq+0x80>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8011f10:	4b1a      	ldr	r3, [pc, #104]	; (8011f7c <HAL_RCC_GetSysClockFreq+0xd0>)
 8011f12:	60bb      	str	r3, [r7, #8]
        break;
 8011f14:	e015      	b.n	8011f42 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8011f16:	f7fe ff7b 	bl	8010e10 <LL_RCC_HSE_IsEnabledDiv2>
 8011f1a:	4603      	mov	r3, r0
 8011f1c:	2b01      	cmp	r3, #1
 8011f1e:	d102      	bne.n	8011f26 <HAL_RCC_GetSysClockFreq+0x7a>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8011f20:	4b16      	ldr	r3, [pc, #88]	; (8011f7c <HAL_RCC_GetSysClockFreq+0xd0>)
 8011f22:	60bb      	str	r3, [r7, #8]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 8011f24:	e00d      	b.n	8011f42 <HAL_RCC_GetSysClockFreq+0x96>
          pllinputfreq = HSE_VALUE;
 8011f26:	4b16      	ldr	r3, [pc, #88]	; (8011f80 <HAL_RCC_GetSysClockFreq+0xd4>)
 8011f28:	60bb      	str	r3, [r7, #8]
        break;
 8011f2a:	e00a      	b.n	8011f42 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8011f2c:	f7ff f943 	bl	80111b6 <LL_RCC_MSI_GetRange>
 8011f30:	4603      	mov	r3, r0
 8011f32:	091b      	lsrs	r3, r3, #4
 8011f34:	f003 030f 	and.w	r3, r3, #15
 8011f38:	4a0f      	ldr	r2, [pc, #60]	; (8011f78 <HAL_RCC_GetSysClockFreq+0xcc>)
 8011f3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011f3e:	60bb      	str	r3, [r7, #8]
        break;
 8011f40:	bf00      	nop
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(), LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
 8011f42:	f7ff fa5a 	bl	80113fa <LL_RCC_PLL_GetN>
 8011f46:	4602      	mov	r2, r0
 8011f48:	68bb      	ldr	r3, [r7, #8]
 8011f4a:	fb03 f402 	mul.w	r4, r3, r2
 8011f4e:	f7ff fa6d 	bl	801142c <LL_RCC_PLL_GetDivider>
 8011f52:	4603      	mov	r3, r0
 8011f54:	091b      	lsrs	r3, r3, #4
 8011f56:	3301      	adds	r3, #1
 8011f58:	fbb4 f4f3 	udiv	r4, r4, r3
 8011f5c:	f7ff fa5a 	bl	8011414 <LL_RCC_PLL_GetR>
 8011f60:	4603      	mov	r3, r0
 8011f62:	0f5b      	lsrs	r3, r3, #29
 8011f64:	3301      	adds	r3, #1
 8011f66:	fbb4 f3f3 	udiv	r3, r4, r3
 8011f6a:	60fb      	str	r3, [r7, #12]
  }

  return sysclockfreq;
 8011f6c:	68fb      	ldr	r3, [r7, #12]
}
 8011f6e:	4618      	mov	r0, r3
 8011f70:	3714      	adds	r7, #20
 8011f72:	46bd      	mov	sp, r7
 8011f74:	bd90      	pop	{r4, r7, pc}
 8011f76:	bf00      	nop
 8011f78:	0802ca8c 	.word	0x0802ca8c
 8011f7c:	00f42400 	.word	0x00f42400
 8011f80:	01e84800 	.word	0x01e84800

08011f84 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8011f84:	b598      	push	{r3, r4, r7, lr}
 8011f86:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8011f88:	f7ff ff90 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8011f8c:	4604      	mov	r4, r0
 8011f8e:	f7ff f9c5 	bl	801131c <LL_RCC_GetAHBPrescaler>
 8011f92:	4603      	mov	r3, r0
 8011f94:	091b      	lsrs	r3, r3, #4
 8011f96:	f003 030f 	and.w	r3, r3, #15
 8011f9a:	4a03      	ldr	r2, [pc, #12]	; (8011fa8 <HAL_RCC_GetHCLKFreq+0x24>)
 8011f9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011fa0:	fbb4 f3f3 	udiv	r3, r4, r3
}
 8011fa4:	4618      	mov	r0, r3
 8011fa6:	bd98      	pop	{r3, r4, r7, pc}
 8011fa8:	0802ca2c 	.word	0x0802ca2c

08011fac <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8011fac:	b598      	push	{r3, r4, r7, lr}
 8011fae:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 8011fb0:	f7ff ffe8 	bl	8011f84 <HAL_RCC_GetHCLKFreq>
 8011fb4:	4604      	mov	r4, r0
 8011fb6:	f7ff f9e4 	bl	8011382 <LL_RCC_GetAPB2Prescaler>
 8011fba:	4603      	mov	r3, r0
 8011fbc:	0adb      	lsrs	r3, r3, #11
 8011fbe:	f003 0307 	and.w	r3, r3, #7
 8011fc2:	4a04      	ldr	r2, [pc, #16]	; (8011fd4 <HAL_RCC_GetPCLK2Freq+0x28>)
 8011fc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011fc8:	f003 031f 	and.w	r3, r3, #31
 8011fcc:	fa24 f303 	lsr.w	r3, r4, r3
}
 8011fd0:	4618      	mov	r0, r3
 8011fd2:	bd98      	pop	{r3, r4, r7, pc}
 8011fd4:	0802ca6c 	.word	0x0802ca6c

08011fd8 <HAL_RCC_GetClockConfig>:
  *                           will be configured.
  * @param  pFLatency         Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8011fd8:	b580      	push	{r7, lr}
 8011fda:	b082      	sub	sp, #8
 8011fdc:	af00      	add	r7, sp, #0
 8011fde:	6078      	str	r0, [r7, #4]
 8011fe0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |  \
 8011fe2:	687b      	ldr	r3, [r7, #4]
 8011fe4:	226f      	movs	r2, #111	; 0x6f
 8011fe6:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK2 | RCC_CLOCKTYPE_HCLK4);

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = LL_RCC_GetSysClkSource();
 8011fe8:	f7ff f923 	bl	8011232 <LL_RCC_GetSysClkSource>
 8011fec:	4602      	mov	r2, r0
 8011fee:	687b      	ldr	r3, [r7, #4]
 8011ff0:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = LL_RCC_GetAHBPrescaler();
 8011ff2:	f7ff f993 	bl	801131c <LL_RCC_GetAHBPrescaler>
 8011ff6:	4602      	mov	r2, r0
 8011ff8:	687b      	ldr	r3, [r7, #4]
 8011ffa:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = LL_RCC_GetAPB1Prescaler();
 8011ffc:	f7ff f9b5 	bl	801136a <LL_RCC_GetAPB1Prescaler>
 8012000:	4602      	mov	r2, r0
 8012002:	687b      	ldr	r3, [r7, #4]
 8012004:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = LL_RCC_GetAPB2Prescaler();
 8012006:	f7ff f9bc 	bl	8011382 <LL_RCC_GetAPB2Prescaler>
 801200a:	4602      	mov	r2, r0
 801200c:	687b      	ldr	r3, [r7, #4]
 801200e:	611a      	str	r2, [r3, #16]

  /* Get the AHBCLK2Divider configuration ------------------------------------*/
  RCC_ClkInitStruct->AHBCLK2Divider = LL_C2_RCC_GetAHBPrescaler();
 8012010:	f7ff f990 	bl	8011334 <LL_C2_RCC_GetAHBPrescaler>
 8012014:	4602      	mov	r2, r0
 8012016:	687b      	ldr	r3, [r7, #4]
 8012018:	615a      	str	r2, [r3, #20]

  /* Get the AHBCLK4Divider configuration ------------------------------------*/
  RCC_ClkInitStruct->AHBCLK4Divider = LL_RCC_GetAHB4Prescaler();
 801201a:	f7ff f998 	bl	801134e <LL_RCC_GetAHB4Prescaler>
 801201e:	4602      	mov	r2, r0
 8012020:	687b      	ldr	r3, [r7, #4]
 8012022:	619a      	str	r2, [r3, #24]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8012024:	4b04      	ldr	r3, [pc, #16]	; (8012038 <HAL_RCC_GetClockConfig+0x60>)
 8012026:	681b      	ldr	r3, [r3, #0]
 8012028:	f003 0207 	and.w	r2, r3, #7
 801202c:	683b      	ldr	r3, [r7, #0]
 801202e:	601a      	str	r2, [r3, #0]
}
 8012030:	bf00      	nop
 8012032:	3708      	adds	r7, #8
 8012034:	46bd      	mov	sp, r7
 8012036:	bd80      	pop	{r7, pc}
 8012038:	58004000 	.word	0x58004000

0801203c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 801203c:	b590      	push	{r4, r7, lr}
 801203e:	b085      	sub	sp, #20
 8012040:	af00      	add	r7, sp, #0
 8012042:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_MSI_CLOCK_RANGE(MSI_Range));

  /* MSI frequency range in Hz */
  if (MSI_Range > RCC_MSIRANGE_11)
 8012044:	687b      	ldr	r3, [r7, #4]
 8012046:	2bb0      	cmp	r3, #176	; 0xb0
 8012048:	d903      	bls.n	8012052 <RCC_SetFlashLatencyFromMSIRange+0x16>
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(RCC_MSIRANGE_11);
 801204a:	4b15      	ldr	r3, [pc, #84]	; (80120a0 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 801204c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801204e:	60fb      	str	r3, [r7, #12]
 8012050:	e007      	b.n	8012062 <RCC_SetFlashLatencyFromMSIRange+0x26>
  }
  else
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(MSI_Range);
 8012052:	687b      	ldr	r3, [r7, #4]
 8012054:	091b      	lsrs	r3, r3, #4
 8012056:	f003 030f 	and.w	r3, r3, #15
 801205a:	4a11      	ldr	r2, [pc, #68]	; (80120a0 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 801205c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012060:	60fb      	str	r3, [r7, #12]
  }

  flash_clksrcfreq = __LL_RCC_CALC_HCLK4_FREQ(msifreq, LL_RCC_GetAHB4Prescaler());
 8012062:	f7ff f974 	bl	801134e <LL_RCC_GetAHB4Prescaler>
 8012066:	4603      	mov	r3, r0
 8012068:	091b      	lsrs	r3, r3, #4
 801206a:	f003 030f 	and.w	r3, r3, #15
 801206e:	4a0d      	ldr	r2, [pc, #52]	; (80120a4 <RCC_SetFlashLatencyFromMSIRange+0x68>)
 8012070:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012074:	68fa      	ldr	r2, [r7, #12]
 8012076:	fbb2 f3f3 	udiv	r3, r2, r3
 801207a:	60bb      	str	r3, [r7, #8]

#if defined(PWR_CR1_VOS)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 801207c:	68bb      	ldr	r3, [r7, #8]
 801207e:	4a0a      	ldr	r2, [pc, #40]	; (80120a8 <RCC_SetFlashLatencyFromMSIRange+0x6c>)
 8012080:	fba2 2303 	umull	r2, r3, r2, r3
 8012084:	0c9c      	lsrs	r4, r3, #18
 8012086:	f7fe fea5 	bl	8010dd4 <HAL_PWREx_GetVoltageRange>
 801208a:	4603      	mov	r3, r0
 801208c:	4619      	mov	r1, r3
 801208e:	4620      	mov	r0, r4
 8012090:	f000 f80c 	bl	80120ac <RCC_SetFlashLatency>
 8012094:	4603      	mov	r3, r0
#else
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), PWR_REGULATOR_VOLTAGE_SCALE1);
#endif
}
 8012096:	4618      	mov	r0, r3
 8012098:	3714      	adds	r7, #20
 801209a:	46bd      	mov	sp, r7
 801209c:	bd90      	pop	{r4, r7, pc}
 801209e:	bf00      	nop
 80120a0:	0802ca8c 	.word	0x0802ca8c
 80120a4:	0802ca2c 	.word	0x0802ca2c
 80120a8:	431bde83 	.word	0x431bde83

080120ac <RCC_SetFlashLatency>:
  * @param  Flash_ClkSrcFreq  Flash Clock Source (in MHz)
  * @param  VCORE_Voltage     Current Vcore voltage (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 80120ac:	b590      	push	{r4, r7, lr}
 80120ae:	b093      	sub	sp, #76	; 0x4c
 80120b0:	af00      	add	r7, sp, #0
 80120b2:	6078      	str	r0, [r7, #4]
 80120b4:	6039      	str	r1, [r7, #0]
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range1 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS1[] = {18UL, 36UL, 54UL, 64UL};
 80120b6:	4b39      	ldr	r3, [pc, #228]	; (801219c <RCC_SetFlashLatency+0xf0>)
 80120b8:	f107 0428 	add.w	r4, r7, #40	; 0x28
 80120bc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80120be:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
#if defined(PWR_CR1_VOS)
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range2 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS2[] = {6UL, 12UL, 16UL};
 80120c2:	4a37      	ldr	r2, [pc, #220]	; (80121a0 <RCC_SetFlashLatency+0xf4>)
 80120c4:	f107 031c 	add.w	r3, r7, #28
 80120c8:	ca07      	ldmia	r2, {r0, r1, r2}
 80120ca:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#endif
  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2, FLASH_LATENCY_3};
 80120ce:	4b35      	ldr	r3, [pc, #212]	; (80121a4 <RCC_SetFlashLatency+0xf8>)
 80120d0:	f107 040c 	add.w	r4, r7, #12
 80120d4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80120d6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 80120da:	2300      	movs	r3, #0
 80120dc:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t tickstart;

#if defined(PWR_CR1_VOS)
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80120de:	683b      	ldr	r3, [r7, #0]
 80120e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80120e4:	d11c      	bne.n	8012120 <RCC_SetFlashLatency+0x74>
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 80120e6:	2300      	movs	r3, #0
 80120e8:	643b      	str	r3, [r7, #64]	; 0x40
 80120ea:	e015      	b.n	8012118 <RCC_SetFlashLatency+0x6c>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 80120ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80120ee:	009b      	lsls	r3, r3, #2
 80120f0:	f107 0248 	add.w	r2, r7, #72	; 0x48
 80120f4:	4413      	add	r3, r2
 80120f6:	f853 3c20 	ldr.w	r3, [r3, #-32]
 80120fa:	687a      	ldr	r2, [r7, #4]
 80120fc:	429a      	cmp	r2, r3
 80120fe:	d808      	bhi.n	8012112 <RCC_SetFlashLatency+0x66>
      {
        latency = FLASH_LATENCY_RANGE[index];
 8012100:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012102:	009b      	lsls	r3, r3, #2
 8012104:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8012108:	4413      	add	r3, r2
 801210a:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 801210e:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8012110:	e022      	b.n	8012158 <RCC_SetFlashLatency+0xac>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8012112:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012114:	3301      	adds	r3, #1
 8012116:	643b      	str	r3, [r7, #64]	; 0x40
 8012118:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801211a:	2b03      	cmp	r3, #3
 801211c:	d9e6      	bls.n	80120ec <RCC_SetFlashLatency+0x40>
 801211e:	e01b      	b.n	8012158 <RCC_SetFlashLatency+0xac>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8012120:	2300      	movs	r3, #0
 8012122:	63fb      	str	r3, [r7, #60]	; 0x3c
 8012124:	e015      	b.n	8012152 <RCC_SetFlashLatency+0xa6>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 8012126:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012128:	009b      	lsls	r3, r3, #2
 801212a:	f107 0248 	add.w	r2, r7, #72	; 0x48
 801212e:	4413      	add	r3, r2
 8012130:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8012134:	687a      	ldr	r2, [r7, #4]
 8012136:	429a      	cmp	r2, r3
 8012138:	d808      	bhi.n	801214c <RCC_SetFlashLatency+0xa0>
      {
        latency = FLASH_LATENCY_RANGE[index];
 801213a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801213c:	009b      	lsls	r3, r3, #2
 801213e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8012142:	4413      	add	r3, r2
 8012144:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8012148:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 801214a:	e005      	b.n	8012158 <RCC_SetFlashLatency+0xac>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 801214c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801214e:	3301      	adds	r3, #1
 8012150:	63fb      	str	r3, [r7, #60]	; 0x3c
 8012152:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012154:	2b02      	cmp	r3, #2
 8012156:	d9e6      	bls.n	8012126 <RCC_SetFlashLatency+0x7a>
      break;
    }
  }
#endif

  __HAL_FLASH_SET_LATENCY(latency);
 8012158:	4b13      	ldr	r3, [pc, #76]	; (80121a8 <RCC_SetFlashLatency+0xfc>)
 801215a:	681b      	ldr	r3, [r3, #0]
 801215c:	f023 0207 	bic.w	r2, r3, #7
 8012160:	4911      	ldr	r1, [pc, #68]	; (80121a8 <RCC_SetFlashLatency+0xfc>)
 8012162:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012164:	4313      	orrs	r3, r2
 8012166:	600b      	str	r3, [r1, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8012168:	f7fa fc8e 	bl	800ca88 <HAL_GetTick>
 801216c:	63b8      	str	r0, [r7, #56]	; 0x38

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 801216e:	e008      	b.n	8012182 <RCC_SetFlashLatency+0xd6>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8012170:	f7fa fc8a 	bl	800ca88 <HAL_GetTick>
 8012174:	4602      	mov	r2, r0
 8012176:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012178:	1ad3      	subs	r3, r2, r3
 801217a:	2b02      	cmp	r3, #2
 801217c:	d901      	bls.n	8012182 <RCC_SetFlashLatency+0xd6>
    {
      return HAL_TIMEOUT;
 801217e:	2303      	movs	r3, #3
 8012180:	e007      	b.n	8012192 <RCC_SetFlashLatency+0xe6>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8012182:	4b09      	ldr	r3, [pc, #36]	; (80121a8 <RCC_SetFlashLatency+0xfc>)
 8012184:	681b      	ldr	r3, [r3, #0]
 8012186:	f003 0307 	and.w	r3, r3, #7
 801218a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801218c:	429a      	cmp	r2, r3
 801218e:	d1ef      	bne.n	8012170 <RCC_SetFlashLatency+0xc4>
    }
  }
  return HAL_OK;
 8012190:	2300      	movs	r3, #0
}
 8012192:	4618      	mov	r0, r3
 8012194:	374c      	adds	r7, #76	; 0x4c
 8012196:	46bd      	mov	sp, r7
 8012198:	bd90      	pop	{r4, r7, pc}
 801219a:	bf00      	nop
 801219c:	0802c540 	.word	0x0802c540
 80121a0:	0802c550 	.word	0x0802c550
 80121a4:	0802c55c 	.word	0x0802c55c
 80121a8:	58004000 	.word	0x58004000

080121ac <LL_RCC_HSE_IsEnabledDiv2>:
{
 80121ac:	b480      	push	{r7}
 80121ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 80121b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80121b4:	681b      	ldr	r3, [r3, #0]
 80121b6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80121ba:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80121be:	d101      	bne.n	80121c4 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 80121c0:	2301      	movs	r3, #1
 80121c2:	e000      	b.n	80121c6 <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 80121c4:	2300      	movs	r3, #0
}
 80121c6:	4618      	mov	r0, r3
 80121c8:	46bd      	mov	sp, r7
 80121ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80121ce:	4770      	bx	lr

080121d0 <LL_RCC_HSE_IsReady>:
{
 80121d0:	b480      	push	{r7}
 80121d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 80121d4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80121d8:	681b      	ldr	r3, [r3, #0]
 80121da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80121de:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80121e2:	d101      	bne.n	80121e8 <LL_RCC_HSE_IsReady+0x18>
 80121e4:	2301      	movs	r3, #1
 80121e6:	e000      	b.n	80121ea <LL_RCC_HSE_IsReady+0x1a>
 80121e8:	2300      	movs	r3, #0
}
 80121ea:	4618      	mov	r0, r3
 80121ec:	46bd      	mov	sp, r7
 80121ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80121f2:	4770      	bx	lr

080121f4 <LL_RCC_HSI_IsReady>:
{
 80121f4:	b480      	push	{r7}
 80121f6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 80121f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80121fc:	681b      	ldr	r3, [r3, #0]
 80121fe:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012202:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8012206:	d101      	bne.n	801220c <LL_RCC_HSI_IsReady+0x18>
 8012208:	2301      	movs	r3, #1
 801220a:	e000      	b.n	801220e <LL_RCC_HSI_IsReady+0x1a>
 801220c:	2300      	movs	r3, #0
}
 801220e:	4618      	mov	r0, r3
 8012210:	46bd      	mov	sp, r7
 8012212:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012216:	4770      	bx	lr

08012218 <LL_RCC_HSI48_IsReady>:
{
 8012218:	b480      	push	{r7}
 801221a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 801221c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012220:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8012224:	f003 0302 	and.w	r3, r3, #2
 8012228:	2b02      	cmp	r3, #2
 801222a:	d101      	bne.n	8012230 <LL_RCC_HSI48_IsReady+0x18>
 801222c:	2301      	movs	r3, #1
 801222e:	e000      	b.n	8012232 <LL_RCC_HSI48_IsReady+0x1a>
 8012230:	2300      	movs	r3, #0
}
 8012232:	4618      	mov	r0, r3
 8012234:	46bd      	mov	sp, r7
 8012236:	f85d 7b04 	ldr.w	r7, [sp], #4
 801223a:	4770      	bx	lr

0801223c <LL_RCC_LSE_IsEnabled>:
{
 801223c:	b480      	push	{r7}
 801223e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == (RCC_BDCR_LSEON)) ? 1UL : 0UL);
 8012240:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012244:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012248:	f003 0301 	and.w	r3, r3, #1
 801224c:	2b01      	cmp	r3, #1
 801224e:	d101      	bne.n	8012254 <LL_RCC_LSE_IsEnabled+0x18>
 8012250:	2301      	movs	r3, #1
 8012252:	e000      	b.n	8012256 <LL_RCC_LSE_IsEnabled+0x1a>
 8012254:	2300      	movs	r3, #0
}
 8012256:	4618      	mov	r0, r3
 8012258:	46bd      	mov	sp, r7
 801225a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801225e:	4770      	bx	lr

08012260 <LL_RCC_LSE_IsReady>:
{
 8012260:	b480      	push	{r7}
 8012262:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8012264:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012268:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801226c:	f003 0302 	and.w	r3, r3, #2
 8012270:	2b02      	cmp	r3, #2
 8012272:	d101      	bne.n	8012278 <LL_RCC_LSE_IsReady+0x18>
 8012274:	2301      	movs	r3, #1
 8012276:	e000      	b.n	801227a <LL_RCC_LSE_IsReady+0x1a>
 8012278:	2300      	movs	r3, #0
}
 801227a:	4618      	mov	r0, r3
 801227c:	46bd      	mov	sp, r7
 801227e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012282:	4770      	bx	lr

08012284 <LL_RCC_LSI1_IsReady>:
{
 8012284:	b480      	push	{r7}
 8012286:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8012288:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801228c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012290:	f003 0302 	and.w	r3, r3, #2
 8012294:	2b02      	cmp	r3, #2
 8012296:	d101      	bne.n	801229c <LL_RCC_LSI1_IsReady+0x18>
 8012298:	2301      	movs	r3, #1
 801229a:	e000      	b.n	801229e <LL_RCC_LSI1_IsReady+0x1a>
 801229c:	2300      	movs	r3, #0
}
 801229e:	4618      	mov	r0, r3
 80122a0:	46bd      	mov	sp, r7
 80122a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122a6:	4770      	bx	lr

080122a8 <LL_RCC_LSI2_IsReady>:
{
 80122a8:	b480      	push	{r7}
 80122aa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 80122ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80122b0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80122b4:	f003 0308 	and.w	r3, r3, #8
 80122b8:	2b08      	cmp	r3, #8
 80122ba:	d101      	bne.n	80122c0 <LL_RCC_LSI2_IsReady+0x18>
 80122bc:	2301      	movs	r3, #1
 80122be:	e000      	b.n	80122c2 <LL_RCC_LSI2_IsReady+0x1a>
 80122c0:	2300      	movs	r3, #0
}
 80122c2:	4618      	mov	r0, r3
 80122c4:	46bd      	mov	sp, r7
 80122c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122ca:	4770      	bx	lr

080122cc <LL_RCC_MSI_IsReady>:
{
 80122cc:	b480      	push	{r7}
 80122ce:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 80122d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80122d4:	681b      	ldr	r3, [r3, #0]
 80122d6:	f003 0302 	and.w	r3, r3, #2
 80122da:	2b02      	cmp	r3, #2
 80122dc:	d101      	bne.n	80122e2 <LL_RCC_MSI_IsReady+0x16>
 80122de:	2301      	movs	r3, #1
 80122e0:	e000      	b.n	80122e4 <LL_RCC_MSI_IsReady+0x18>
 80122e2:	2300      	movs	r3, #0
}
 80122e4:	4618      	mov	r0, r3
 80122e6:	46bd      	mov	sp, r7
 80122e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122ec:	4770      	bx	lr

080122ee <LL_RCC_MSI_EnablePLLMode>:
{
 80122ee:	b480      	push	{r7}
 80122f0:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN);
 80122f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80122f6:	681b      	ldr	r3, [r3, #0]
 80122f8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80122fc:	f043 0304 	orr.w	r3, r3, #4
 8012300:	6013      	str	r3, [r2, #0]
}
 8012302:	bf00      	nop
 8012304:	46bd      	mov	sp, r7
 8012306:	f85d 7b04 	ldr.w	r7, [sp], #4
 801230a:	4770      	bx	lr

0801230c <LL_RCC_MSI_GetRange>:
{
 801230c:	b480      	push	{r7}
 801230e:	b083      	sub	sp, #12
 8012310:	af00      	add	r7, sp, #0
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8012312:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012316:	681b      	ldr	r3, [r3, #0]
 8012318:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801231c:	607b      	str	r3, [r7, #4]
  if (msiRange > LL_RCC_MSIRANGE_11)
 801231e:	687b      	ldr	r3, [r7, #4]
 8012320:	2bb0      	cmp	r3, #176	; 0xb0
 8012322:	d901      	bls.n	8012328 <LL_RCC_MSI_GetRange+0x1c>
    msiRange = LL_RCC_MSIRANGE_11;
 8012324:	23b0      	movs	r3, #176	; 0xb0
 8012326:	607b      	str	r3, [r7, #4]
  return msiRange;
 8012328:	687b      	ldr	r3, [r7, #4]
}
 801232a:	4618      	mov	r0, r3
 801232c:	370c      	adds	r7, #12
 801232e:	46bd      	mov	sp, r7
 8012330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012334:	4770      	bx	lr

08012336 <LL_RCC_SetRFWKPClockSource>:
{
 8012336:	b480      	push	{r7}
 8012338:	b083      	sub	sp, #12
 801233a:	af00      	add	r7, sp, #0
 801233c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_RFWKPSEL, Source);
 801233e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012342:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8012346:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 801234a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801234e:	687b      	ldr	r3, [r7, #4]
 8012350:	4313      	orrs	r3, r2
 8012352:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8012356:	bf00      	nop
 8012358:	370c      	adds	r7, #12
 801235a:	46bd      	mov	sp, r7
 801235c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012360:	4770      	bx	lr

08012362 <LL_RCC_GetRFWKPClockSource>:
{
 8012362:	b480      	push	{r7}
 8012364:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_RFWKPSEL));
 8012366:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801236a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801236e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
 8012372:	4618      	mov	r0, r3
 8012374:	46bd      	mov	sp, r7
 8012376:	f85d 7b04 	ldr.w	r7, [sp], #4
 801237a:	4770      	bx	lr

0801237c <LL_RCC_GetAHBPrescaler>:
{
 801237c:	b480      	push	{r7}
 801237e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8012380:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012384:	689b      	ldr	r3, [r3, #8]
 8012386:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 801238a:	4618      	mov	r0, r3
 801238c:	46bd      	mov	sp, r7
 801238e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012392:	4770      	bx	lr

08012394 <LL_RCC_GetAPB1Prescaler>:
{
 8012394:	b480      	push	{r7}
 8012396:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8012398:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801239c:	689b      	ldr	r3, [r3, #8]
 801239e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
}
 80123a2:	4618      	mov	r0, r3
 80123a4:	46bd      	mov	sp, r7
 80123a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123aa:	4770      	bx	lr

080123ac <LL_RCC_GetAPB2Prescaler>:
{
 80123ac:	b480      	push	{r7}
 80123ae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 80123b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80123b4:	689b      	ldr	r3, [r3, #8]
 80123b6:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
}
 80123ba:	4618      	mov	r0, r3
 80123bc:	46bd      	mov	sp, r7
 80123be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123c2:	4770      	bx	lr

080123c4 <LL_RCC_SetSMPSClockSource>:
{
 80123c4:	b480      	push	{r7}
 80123c6:	b083      	sub	sp, #12
 80123c8:	af00      	add	r7, sp, #0
 80123ca:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSSEL, SMPSSource);
 80123cc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80123d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80123d2:	f023 0203 	bic.w	r2, r3, #3
 80123d6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80123da:	687b      	ldr	r3, [r7, #4]
 80123dc:	4313      	orrs	r3, r2
 80123de:	624b      	str	r3, [r1, #36]	; 0x24
}
 80123e0:	bf00      	nop
 80123e2:	370c      	adds	r7, #12
 80123e4:	46bd      	mov	sp, r7
 80123e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123ea:	4770      	bx	lr

080123ec <LL_RCC_GetSMPSClockSource>:
{
 80123ec:	b480      	push	{r7}
 80123ee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->SMPSCR, RCC_SMPSCR_SMPSSWS));
 80123f0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80123f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80123f6:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 80123fa:	4618      	mov	r0, r3
 80123fc:	46bd      	mov	sp, r7
 80123fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012402:	4770      	bx	lr

08012404 <LL_RCC_SetSMPSPrescaler>:
{
 8012404:	b480      	push	{r7}
 8012406:	b083      	sub	sp, #12
 8012408:	af00      	add	r7, sp, #0
 801240a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV, Prescaler);
 801240c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012410:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012412:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8012416:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801241a:	687b      	ldr	r3, [r7, #4]
 801241c:	4313      	orrs	r3, r2
 801241e:	624b      	str	r3, [r1, #36]	; 0x24
}
 8012420:	bf00      	nop
 8012422:	370c      	adds	r7, #12
 8012424:	46bd      	mov	sp, r7
 8012426:	f85d 7b04 	ldr.w	r7, [sp], #4
 801242a:	4770      	bx	lr

0801242c <LL_RCC_GetSMPSPrescaler>:
{
 801242c:	b480      	push	{r7}
 801242e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV));
 8012430:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012434:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012436:	f003 0330 	and.w	r3, r3, #48	; 0x30
}
 801243a:	4618      	mov	r0, r3
 801243c:	46bd      	mov	sp, r7
 801243e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012442:	4770      	bx	lr

08012444 <LL_RCC_SetUSARTClockSource>:
{
 8012444:	b480      	push	{r7}
 8012446:	b083      	sub	sp, #12
 8012448:	af00      	add	r7, sp, #0
 801244a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, USARTxSource);
 801244c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012450:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012454:	f023 0203 	bic.w	r2, r3, #3
 8012458:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801245c:	687b      	ldr	r3, [r7, #4]
 801245e:	4313      	orrs	r3, r2
 8012460:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8012464:	bf00      	nop
 8012466:	370c      	adds	r7, #12
 8012468:	46bd      	mov	sp, r7
 801246a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801246e:	4770      	bx	lr

08012470 <LL_RCC_SetLPUARTClockSource>:
{
 8012470:	b480      	push	{r7}
 8012472:	b083      	sub	sp, #12
 8012474:	af00      	add	r7, sp, #0
 8012476:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8012478:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801247c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012480:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8012484:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8012488:	687b      	ldr	r3, [r7, #4]
 801248a:	4313      	orrs	r3, r2
 801248c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8012490:	bf00      	nop
 8012492:	370c      	adds	r7, #12
 8012494:	46bd      	mov	sp, r7
 8012496:	f85d 7b04 	ldr.w	r7, [sp], #4
 801249a:	4770      	bx	lr

0801249c <LL_RCC_SetI2CClockSource>:
{
 801249c:	b480      	push	{r7}
 801249e:	b083      	sub	sp, #12
 80124a0:	af00      	add	r7, sp, #0
 80124a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 80124a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80124a8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80124ac:	687b      	ldr	r3, [r7, #4]
 80124ae:	091b      	lsrs	r3, r3, #4
 80124b0:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 80124b4:	43db      	mvns	r3, r3
 80124b6:	401a      	ands	r2, r3
 80124b8:	687b      	ldr	r3, [r7, #4]
 80124ba:	011b      	lsls	r3, r3, #4
 80124bc:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 80124c0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80124c4:	4313      	orrs	r3, r2
 80124c6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80124ca:	bf00      	nop
 80124cc:	370c      	adds	r7, #12
 80124ce:	46bd      	mov	sp, r7
 80124d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80124d4:	4770      	bx	lr

080124d6 <LL_RCC_SetLPTIMClockSource>:
{
 80124d6:	b480      	push	{r7}
 80124d8:	b083      	sub	sp, #12
 80124da:	af00      	add	r7, sp, #0
 80124dc:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 80124de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80124e2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80124e6:	687b      	ldr	r3, [r7, #4]
 80124e8:	0c1b      	lsrs	r3, r3, #16
 80124ea:	041b      	lsls	r3, r3, #16
 80124ec:	43db      	mvns	r3, r3
 80124ee:	401a      	ands	r2, r3
 80124f0:	687b      	ldr	r3, [r7, #4]
 80124f2:	041b      	lsls	r3, r3, #16
 80124f4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80124f8:	4313      	orrs	r3, r2
 80124fa:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80124fe:	bf00      	nop
 8012500:	370c      	adds	r7, #12
 8012502:	46bd      	mov	sp, r7
 8012504:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012508:	4770      	bx	lr

0801250a <LL_RCC_SetSAIClockSource>:
{
 801250a:	b480      	push	{r7}
 801250c:	b083      	sub	sp, #12
 801250e:	af00      	add	r7, sp, #0
 8012510:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, SAIxSource);
 8012512:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012516:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801251a:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 801251e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8012522:	687b      	ldr	r3, [r7, #4]
 8012524:	4313      	orrs	r3, r2
 8012526:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 801252a:	bf00      	nop
 801252c:	370c      	adds	r7, #12
 801252e:	46bd      	mov	sp, r7
 8012530:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012534:	4770      	bx	lr

08012536 <LL_RCC_SetRNGClockSource>:
{
 8012536:	b480      	push	{r7}
 8012538:	b083      	sub	sp, #12
 801253a:	af00      	add	r7, sp, #0
 801253c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 801253e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012542:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012546:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 801254a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801254e:	687b      	ldr	r3, [r7, #4]
 8012550:	4313      	orrs	r3, r2
 8012552:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8012556:	bf00      	nop
 8012558:	370c      	adds	r7, #12
 801255a:	46bd      	mov	sp, r7
 801255c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012560:	4770      	bx	lr

08012562 <LL_RCC_SetCLK48ClockSource>:
{
 8012562:	b480      	push	{r7}
 8012564:	b083      	sub	sp, #12
 8012566:	af00      	add	r7, sp, #0
 8012568:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 801256a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801256e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8012572:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8012576:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801257a:	687b      	ldr	r3, [r7, #4]
 801257c:	4313      	orrs	r3, r2
 801257e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8012582:	bf00      	nop
 8012584:	370c      	adds	r7, #12
 8012586:	46bd      	mov	sp, r7
 8012588:	f85d 7b04 	ldr.w	r7, [sp], #4
 801258c:	4770      	bx	lr

0801258e <LL_RCC_SetUSBClockSource>:
{
 801258e:	b580      	push	{r7, lr}
 8012590:	b082      	sub	sp, #8
 8012592:	af00      	add	r7, sp, #0
 8012594:	6078      	str	r0, [r7, #4]
  LL_RCC_SetCLK48ClockSource(USBxSource);
 8012596:	6878      	ldr	r0, [r7, #4]
 8012598:	f7ff ffe3 	bl	8012562 <LL_RCC_SetCLK48ClockSource>
}
 801259c:	bf00      	nop
 801259e:	3708      	adds	r7, #8
 80125a0:	46bd      	mov	sp, r7
 80125a2:	bd80      	pop	{r7, pc}

080125a4 <LL_RCC_SetADCClockSource>:
{
 80125a4:	b480      	push	{r7}
 80125a6:	b083      	sub	sp, #12
 80125a8:	af00      	add	r7, sp, #0
 80125aa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 80125ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80125b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80125b4:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 80125b8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80125bc:	687b      	ldr	r3, [r7, #4]
 80125be:	4313      	orrs	r3, r2
 80125c0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80125c4:	bf00      	nop
 80125c6:	370c      	adds	r7, #12
 80125c8:	46bd      	mov	sp, r7
 80125ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125ce:	4770      	bx	lr

080125d0 <LL_RCC_GetUSARTClockSource>:
{
 80125d0:	b480      	push	{r7}
 80125d2:	b083      	sub	sp, #12
 80125d4:	af00      	add	r7, sp, #0
 80125d6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx));
 80125d8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80125dc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80125e0:	687b      	ldr	r3, [r7, #4]
 80125e2:	4013      	ands	r3, r2
}
 80125e4:	4618      	mov	r0, r3
 80125e6:	370c      	adds	r7, #12
 80125e8:	46bd      	mov	sp, r7
 80125ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125ee:	4770      	bx	lr

080125f0 <LL_RCC_GetLPUARTClockSource>:
{
 80125f0:	b480      	push	{r7}
 80125f2:	b083      	sub	sp, #12
 80125f4:	af00      	add	r7, sp, #0
 80125f6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 80125f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80125fc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8012600:	687b      	ldr	r3, [r7, #4]
 8012602:	4013      	ands	r3, r2
}
 8012604:	4618      	mov	r0, r3
 8012606:	370c      	adds	r7, #12
 8012608:	46bd      	mov	sp, r7
 801260a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801260e:	4770      	bx	lr

08012610 <LL_RCC_GetI2CClockSource>:
{
 8012610:	b480      	push	{r7}
 8012612:	b083      	sub	sp, #12
 8012614:	af00      	add	r7, sp, #0
 8012616:	6078      	str	r0, [r7, #4]
  return (uint32_t)((READ_BIT(RCC->CCIPR, I2Cx) >> 4) | (I2Cx << 4));
 8012618:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801261c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8012620:	687b      	ldr	r3, [r7, #4]
 8012622:	4013      	ands	r3, r2
 8012624:	091a      	lsrs	r2, r3, #4
 8012626:	687b      	ldr	r3, [r7, #4]
 8012628:	011b      	lsls	r3, r3, #4
 801262a:	4313      	orrs	r3, r2
}
 801262c:	4618      	mov	r0, r3
 801262e:	370c      	adds	r7, #12
 8012630:	46bd      	mov	sp, r7
 8012632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012636:	4770      	bx	lr

08012638 <LL_RCC_GetLPTIMClockSource>:
{
 8012638:	b480      	push	{r7}
 801263a:	b083      	sub	sp, #12
 801263c:	af00      	add	r7, sp, #0
 801263e:	6078      	str	r0, [r7, #4]
  return (uint32_t)((READ_BIT(RCC->CCIPR, LPTIMx) >> 16) | LPTIMx);
 8012640:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012644:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8012648:	687b      	ldr	r3, [r7, #4]
 801264a:	4013      	ands	r3, r2
 801264c:	0c1a      	lsrs	r2, r3, #16
 801264e:	687b      	ldr	r3, [r7, #4]
 8012650:	4313      	orrs	r3, r2
}
 8012652:	4618      	mov	r0, r3
 8012654:	370c      	adds	r7, #12
 8012656:	46bd      	mov	sp, r7
 8012658:	f85d 7b04 	ldr.w	r7, [sp], #4
 801265c:	4770      	bx	lr

0801265e <LL_RCC_GetSAIClockSource>:
{
 801265e:	b480      	push	{r7}
 8012660:	b083      	sub	sp, #12
 8012662:	af00      	add	r7, sp, #0
 8012664:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, SAIx));
 8012666:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801266a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801266e:	687b      	ldr	r3, [r7, #4]
 8012670:	4013      	ands	r3, r2
}
 8012672:	4618      	mov	r0, r3
 8012674:	370c      	adds	r7, #12
 8012676:	46bd      	mov	sp, r7
 8012678:	f85d 7b04 	ldr.w	r7, [sp], #4
 801267c:	4770      	bx	lr

0801267e <LL_RCC_GetRNGClockSource>:
{
 801267e:	b480      	push	{r7}
 8012680:	b083      	sub	sp, #12
 8012682:	af00      	add	r7, sp, #0
 8012684:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, RNGx));
 8012686:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801268a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801268e:	687b      	ldr	r3, [r7, #4]
 8012690:	4013      	ands	r3, r2
}
 8012692:	4618      	mov	r0, r3
 8012694:	370c      	adds	r7, #12
 8012696:	46bd      	mov	sp, r7
 8012698:	f85d 7b04 	ldr.w	r7, [sp], #4
 801269c:	4770      	bx	lr

0801269e <LL_RCC_GetCLK48ClockSource>:
{
 801269e:	b480      	push	{r7}
 80126a0:	b083      	sub	sp, #12
 80126a2:	af00      	add	r7, sp, #0
 80126a4:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, CLK48x));
 80126a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80126aa:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80126ae:	687b      	ldr	r3, [r7, #4]
 80126b0:	4013      	ands	r3, r2
}
 80126b2:	4618      	mov	r0, r3
 80126b4:	370c      	adds	r7, #12
 80126b6:	46bd      	mov	sp, r7
 80126b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126bc:	4770      	bx	lr

080126be <LL_RCC_GetUSBClockSource>:
{
 80126be:	b580      	push	{r7, lr}
 80126c0:	b082      	sub	sp, #8
 80126c2:	af00      	add	r7, sp, #0
 80126c4:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetCLK48ClockSource(USBx);
 80126c6:	6878      	ldr	r0, [r7, #4]
 80126c8:	f7ff ffe9 	bl	801269e <LL_RCC_GetCLK48ClockSource>
 80126cc:	4603      	mov	r3, r0
}
 80126ce:	4618      	mov	r0, r3
 80126d0:	3708      	adds	r7, #8
 80126d2:	46bd      	mov	sp, r7
 80126d4:	bd80      	pop	{r7, pc}

080126d6 <LL_RCC_GetADCClockSource>:
{
 80126d6:	b480      	push	{r7}
 80126d8:	b083      	sub	sp, #12
 80126da:	af00      	add	r7, sp, #0
 80126dc:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, ADCx));
 80126de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80126e2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80126e6:	687b      	ldr	r3, [r7, #4]
 80126e8:	4013      	ands	r3, r2
}
 80126ea:	4618      	mov	r0, r3
 80126ec:	370c      	adds	r7, #12
 80126ee:	46bd      	mov	sp, r7
 80126f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126f4:	4770      	bx	lr

080126f6 <LL_RCC_SetRTCClockSource>:
{
 80126f6:	b480      	push	{r7}
 80126f8:	b083      	sub	sp, #12
 80126fa:	af00      	add	r7, sp, #0
 80126fc:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 80126fe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012702:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012706:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 801270a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801270e:	687b      	ldr	r3, [r7, #4]
 8012710:	4313      	orrs	r3, r2
 8012712:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8012716:	bf00      	nop
 8012718:	370c      	adds	r7, #12
 801271a:	46bd      	mov	sp, r7
 801271c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012720:	4770      	bx	lr

08012722 <LL_RCC_GetRTCClockSource>:
{
 8012722:	b480      	push	{r7}
 8012724:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8012726:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801272a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801272e:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 8012732:	4618      	mov	r0, r3
 8012734:	46bd      	mov	sp, r7
 8012736:	f85d 7b04 	ldr.w	r7, [sp], #4
 801273a:	4770      	bx	lr

0801273c <LL_RCC_ForceBackupDomainReset>:
{
 801273c:	b480      	push	{r7}
 801273e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8012740:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012744:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8012748:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801274c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012750:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8012754:	bf00      	nop
 8012756:	46bd      	mov	sp, r7
 8012758:	f85d 7b04 	ldr.w	r7, [sp], #4
 801275c:	4770      	bx	lr

0801275e <LL_RCC_ReleaseBackupDomainReset>:
{
 801275e:	b480      	push	{r7}
 8012760:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8012762:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012766:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801276a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801276e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8012772:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8012776:	bf00      	nop
 8012778:	46bd      	mov	sp, r7
 801277a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801277e:	4770      	bx	lr

08012780 <LL_RCC_PLL_IsReady>:
{
 8012780:	b480      	push	{r7}
 8012782:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8012784:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012788:	681b      	ldr	r3, [r3, #0]
 801278a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 801278e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8012792:	d101      	bne.n	8012798 <LL_RCC_PLL_IsReady+0x18>
 8012794:	2301      	movs	r3, #1
 8012796:	e000      	b.n	801279a <LL_RCC_PLL_IsReady+0x1a>
 8012798:	2300      	movs	r3, #0
}
 801279a:	4618      	mov	r0, r3
 801279c:	46bd      	mov	sp, r7
 801279e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127a2:	4770      	bx	lr

080127a4 <LL_RCC_PLL_GetN>:
{
 80127a4:	b480      	push	{r7}
 80127a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80127a8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80127ac:	68db      	ldr	r3, [r3, #12]
 80127ae:	0a1b      	lsrs	r3, r3, #8
 80127b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 80127b4:	4618      	mov	r0, r3
 80127b6:	46bd      	mov	sp, r7
 80127b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127bc:	4770      	bx	lr

080127be <LL_RCC_PLL_GetP>:
{
 80127be:	b480      	push	{r7}
 80127c0:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
 80127c2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80127c6:	68db      	ldr	r3, [r3, #12]
 80127c8:	f403 1378 	and.w	r3, r3, #4063232	; 0x3e0000
}
 80127cc:	4618      	mov	r0, r3
 80127ce:	46bd      	mov	sp, r7
 80127d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127d4:	4770      	bx	lr

080127d6 <LL_RCC_PLL_GetQ>:
{
 80127d6:	b480      	push	{r7}
 80127d8:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ));
 80127da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80127de:	68db      	ldr	r3, [r3, #12]
 80127e0:	f003 6360 	and.w	r3, r3, #234881024	; 0xe000000
}
 80127e4:	4618      	mov	r0, r3
 80127e6:	46bd      	mov	sp, r7
 80127e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127ec:	4770      	bx	lr

080127ee <LL_RCC_PLL_GetDivider>:
{
 80127ee:	b480      	push	{r7}
 80127f0:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80127f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80127f6:	68db      	ldr	r3, [r3, #12]
 80127f8:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 80127fc:	4618      	mov	r0, r3
 80127fe:	46bd      	mov	sp, r7
 8012800:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012804:	4770      	bx	lr

08012806 <LL_RCC_PLLSAI1_Enable>:
{
 8012806:	b480      	push	{r7}
 8012808:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 801280a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801280e:	681b      	ldr	r3, [r3, #0]
 8012810:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8012814:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8012818:	6013      	str	r3, [r2, #0]
}
 801281a:	bf00      	nop
 801281c:	46bd      	mov	sp, r7
 801281e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012822:	4770      	bx	lr

08012824 <LL_RCC_PLLSAI1_Disable>:
{
 8012824:	b480      	push	{r7}
 8012826:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 8012828:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801282c:	681b      	ldr	r3, [r3, #0]
 801282e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8012832:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8012836:	6013      	str	r3, [r2, #0]
}
 8012838:	bf00      	nop
 801283a:	46bd      	mov	sp, r7
 801283c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012840:	4770      	bx	lr

08012842 <LL_RCC_PLLSAI1_IsReady>:
{
 8012842:	b480      	push	{r7}
 8012844:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 8012846:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801284a:	681b      	ldr	r3, [r3, #0]
 801284c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8012850:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8012854:	d101      	bne.n	801285a <LL_RCC_PLLSAI1_IsReady+0x18>
 8012856:	2301      	movs	r3, #1
 8012858:	e000      	b.n	801285c <LL_RCC_PLLSAI1_IsReady+0x1a>
 801285a:	2300      	movs	r3, #0
}
 801285c:	4618      	mov	r0, r3
 801285e:	46bd      	mov	sp, r7
 8012860:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012864:	4770      	bx	lr

08012866 <LL_RCC_PLLSAI1_GetN>:
{
 8012866:	b480      	push	{r7}
 8012868:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLN) >> RCC_PLLSAI1CFGR_PLLN_Pos);
 801286a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801286e:	691b      	ldr	r3, [r3, #16]
 8012870:	0a1b      	lsrs	r3, r3, #8
 8012872:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 8012876:	4618      	mov	r0, r3
 8012878:	46bd      	mov	sp, r7
 801287a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801287e:	4770      	bx	lr

08012880 <LL_RCC_PLLSAI1_GetP>:
{
 8012880:	b480      	push	{r7}
 8012882:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLP));
 8012884:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012888:	691b      	ldr	r3, [r3, #16]
 801288a:	f403 1378 	and.w	r3, r3, #4063232	; 0x3e0000
}
 801288e:	4618      	mov	r0, r3
 8012890:	46bd      	mov	sp, r7
 8012892:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012896:	4770      	bx	lr

08012898 <LL_RCC_PLLSAI1_GetQ>:
{
 8012898:	b480      	push	{r7}
 801289a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLQ));
 801289c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80128a0:	691b      	ldr	r3, [r3, #16]
 80128a2:	f003 6360 	and.w	r3, r3, #234881024	; 0xe000000
}
 80128a6:	4618      	mov	r0, r3
 80128a8:	46bd      	mov	sp, r7
 80128aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128ae:	4770      	bx	lr

080128b0 <LL_RCC_PLLSAI1_GetR>:
{
 80128b0:	b480      	push	{r7}
 80128b2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLR));
 80128b4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80128b8:	691b      	ldr	r3, [r3, #16]
 80128ba:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 80128be:	4618      	mov	r0, r3
 80128c0:	46bd      	mov	sp, r7
 80128c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128c6:	4770      	bx	lr

080128c8 <LL_RCC_PLL_GetMainSource>:
{
 80128c8:	b480      	push	{r7}
 80128ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80128cc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80128d0:	68db      	ldr	r3, [r3, #12]
 80128d2:	f003 0303 	and.w	r3, r3, #3
}
 80128d6:	4618      	mov	r0, r3
 80128d8:	46bd      	mov	sp, r7
 80128da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128de:	4770      	bx	lr

080128e0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80128e0:	b580      	push	{r7, lr}
 80128e2:	b088      	sub	sp, #32
 80128e4:	af00      	add	r7, sp, #0
 80128e6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 80128e8:	2300      	movs	r3, #0
 80128ea:	77fb      	strb	r3, [r7, #31]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 80128ec:	2300      	movs	r3, #0
 80128ee:	77bb      	strb	r3, [r7, #30]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80128f0:	687b      	ldr	r3, [r7, #4]
 80128f2:	681b      	ldr	r3, [r3, #0]
 80128f4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80128f8:	2b00      	cmp	r3, #0
 80128fa:	d034      	beq.n	8012966 <HAL_RCCEx_PeriphCLKConfig+0x86>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
 80128fc:	687b      	ldr	r3, [r7, #4]
 80128fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012900:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8012904:	d021      	beq.n	801294a <HAL_RCCEx_PeriphCLKConfig+0x6a>
 8012906:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 801290a:	d81b      	bhi.n	8012944 <HAL_RCCEx_PeriphCLKConfig+0x64>
 801290c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8012910:	d01d      	beq.n	801294e <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8012912:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8012916:	d815      	bhi.n	8012944 <HAL_RCCEx_PeriphCLKConfig+0x64>
 8012918:	2b00      	cmp	r3, #0
 801291a:	d00b      	beq.n	8012934 <HAL_RCCEx_PeriphCLKConfig+0x54>
 801291c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8012920:	d110      	bne.n	8012944 <HAL_RCCEx_PeriphCLKConfig+0x64>
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1 */
        /* Enable SAI1 Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI1CLK);
 8012922:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012926:	68db      	ldr	r3, [r3, #12]
 8012928:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801292c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012930:	60d3      	str	r3, [r2, #12]

        /* SAI1 clock source config set later after clock selection check */
        break;
 8012932:	e00d      	b.n	8012950 <HAL_RCCEx_PeriphCLKConfig+0x70>

#if defined(SAI1)
      case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1 */
        /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 8012934:	687b      	ldr	r3, [r7, #4]
 8012936:	3304      	adds	r3, #4
 8012938:	4618      	mov	r0, r3
 801293a:	f000 fd64 	bl	8013406 <RCCEx_PLLSAI1_ConfigNP>
 801293e:	4603      	mov	r3, r0
 8012940:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 8012942:	e005      	b.n	8012950 <HAL_RCCEx_PeriphCLKConfig+0x70>
      case RCC_SAI1CLKSOURCE_HSI:

        break;

      default:
        ret = HAL_ERROR;
 8012944:	2301      	movs	r3, #1
 8012946:	77fb      	strb	r3, [r7, #31]
        break;
 8012948:	e002      	b.n	8012950 <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 801294a:	bf00      	nop
 801294c:	e000      	b.n	8012950 <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 801294e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8012950:	7ffb      	ldrb	r3, [r7, #31]
 8012952:	2b00      	cmp	r3, #0
 8012954:	d105      	bne.n	8012962 <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8012956:	687b      	ldr	r3, [r7, #4]
 8012958:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801295a:	4618      	mov	r0, r3
 801295c:	f7ff fdd5 	bl	801250a <LL_RCC_SetSAIClockSource>
 8012960:	e001      	b.n	8012966 <HAL_RCCEx_PeriphCLKConfig+0x86>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8012962:	7ffb      	ldrb	r3, [r7, #31]
 8012964:	77bb      	strb	r3, [r7, #30]
    }
  }
#endif

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8012966:	687b      	ldr	r3, [r7, #4]
 8012968:	681b      	ldr	r3, [r3, #0]
 801296a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801296e:	2b00      	cmp	r3, #0
 8012970:	d046      	beq.n	8012a00 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    uint32_t rtcclocksource = LL_RCC_GetRTCClockSource();
 8012972:	f7ff fed6 	bl	8012722 <LL_RCC_GetRTCClockSource>
 8012976:	61b8      	str	r0, [r7, #24]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Configure the clock source only if a different source is expected */
    if (rtcclocksource != PeriphClkInit->RTCClockSelection)
 8012978:	687b      	ldr	r3, [r7, #4]
 801297a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801297c:	69ba      	ldr	r2, [r7, #24]
 801297e:	429a      	cmp	r2, r3
 8012980:	d03c      	beq.n	80129fc <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 8012982:	f7fe fa17 	bl	8010db4 <HAL_PWR_EnableBkUpAccess>

      /* If a clock source is not yet selected */
      if (rtcclocksource == RCC_RTCCLKSOURCE_NONE)
 8012986:	69bb      	ldr	r3, [r7, #24]
 8012988:	2b00      	cmp	r3, #0
 801298a:	d105      	bne.n	8012998 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      {
        /* Directly set the configuration of the clock source selection */
        LL_RCC_SetRTCClockSource(PeriphClkInit->RTCClockSelection);
 801298c:	687b      	ldr	r3, [r7, #4]
 801298e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012990:	4618      	mov	r0, r3
 8012992:	f7ff feb0 	bl	80126f6 <LL_RCC_SetRTCClockSource>
 8012996:	e02e      	b.n	80129f6 <HAL_RCCEx_PeriphCLKConfig+0x116>
      }
      else /* A clock source is already selected */
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        uint32_t bdcr = LL_RCC_ReadReg(BDCR);
 8012998:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801299c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80129a0:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        LL_RCC_ForceBackupDomainReset();
 80129a2:	f7ff fecb 	bl	801273c <LL_RCC_ForceBackupDomainReset>
        LL_RCC_ReleaseBackupDomainReset();
 80129a6:	f7ff feda 	bl	801275e <LL_RCC_ReleaseBackupDomainReset>

        /* Set the value of the clock source selection */
        MODIFY_REG(bdcr, RCC_BDCR_RTCSEL, PeriphClkInit->RTCClockSelection);
 80129aa:	697b      	ldr	r3, [r7, #20]
 80129ac:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80129b0:	687b      	ldr	r3, [r7, #4]
 80129b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80129b4:	4313      	orrs	r3, r2
 80129b6:	617b      	str	r3, [r7, #20]

        /* Restore the content of BDCR register */
        LL_RCC_WriteReg(BDCR, bdcr);
 80129b8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80129bc:	697b      	ldr	r3, [r7, #20]
 80129be:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
        if (LL_RCC_LSE_IsEnabled() == 1U)
 80129c2:	f7ff fc3b 	bl	801223c <LL_RCC_LSE_IsEnabled>
 80129c6:	4603      	mov	r3, r0
 80129c8:	2b01      	cmp	r3, #1
 80129ca:	d114      	bne.n	80129f6 <HAL_RCCEx_PeriphCLKConfig+0x116>
        {
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 80129cc:	f7fa f85c 	bl	800ca88 <HAL_GetTick>
 80129d0:	6138      	str	r0, [r7, #16]

          /* Wait till LSE is ready */
          while (LL_RCC_LSE_IsReady() != 1U)
 80129d2:	e00b      	b.n	80129ec <HAL_RCCEx_PeriphCLKConfig+0x10c>
          {
            if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80129d4:	f7fa f858 	bl	800ca88 <HAL_GetTick>
 80129d8:	4602      	mov	r2, r0
 80129da:	693b      	ldr	r3, [r7, #16]
 80129dc:	1ad3      	subs	r3, r2, r3
 80129de:	f241 3288 	movw	r2, #5000	; 0x1388
 80129e2:	4293      	cmp	r3, r2
 80129e4:	d902      	bls.n	80129ec <HAL_RCCEx_PeriphCLKConfig+0x10c>
            {
              ret = HAL_TIMEOUT;
 80129e6:	2303      	movs	r3, #3
 80129e8:	77fb      	strb	r3, [r7, #31]
              break;
 80129ea:	e004      	b.n	80129f6 <HAL_RCCEx_PeriphCLKConfig+0x116>
          while (LL_RCC_LSE_IsReady() != 1U)
 80129ec:	f7ff fc38 	bl	8012260 <LL_RCC_LSE_IsReady>
 80129f0:	4603      	mov	r3, r0
 80129f2:	2b01      	cmp	r3, #1
 80129f4:	d1ee      	bne.n	80129d4 <HAL_RCCEx_PeriphCLKConfig+0xf4>
          }
        }
      }

      /* set overall return value */
      status = ret;
 80129f6:	7ffb      	ldrb	r3, [r7, #31]
 80129f8:	77bb      	strb	r3, [r7, #30]
 80129fa:	e001      	b.n	8012a00 <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80129fc:	7ffb      	ldrb	r3, [r7, #31]
 80129fe:	77bb      	strb	r3, [r7, #30]
    }

  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8012a00:	687b      	ldr	r3, [r7, #4]
 8012a02:	681b      	ldr	r3, [r3, #0]
 8012a04:	f003 0301 	and.w	r3, r3, #1
 8012a08:	2b00      	cmp	r3, #0
 8012a0a:	d004      	beq.n	8012a16 <HAL_RCCEx_PeriphCLKConfig+0x136>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8012a0c:	687b      	ldr	r3, [r7, #4]
 8012a0e:	699b      	ldr	r3, [r3, #24]
 8012a10:	4618      	mov	r0, r3
 8012a12:	f7ff fd17 	bl	8012444 <LL_RCC_SetUSARTClockSource>
  }

#if defined(LPUART1)
  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8012a16:	687b      	ldr	r3, [r7, #4]
 8012a18:	681b      	ldr	r3, [r3, #0]
 8012a1a:	f003 0302 	and.w	r3, r3, #2
 8012a1e:	2b00      	cmp	r3, #0
 8012a20:	d004      	beq.n	8012a2c <HAL_RCCEx_PeriphCLKConfig+0x14c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8012a22:	687b      	ldr	r3, [r7, #4]
 8012a24:	69db      	ldr	r3, [r3, #28]
 8012a26:	4618      	mov	r0, r3
 8012a28:	f7ff fd22 	bl	8012470 <LL_RCC_SetLPUARTClockSource>
  }
#endif

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8012a2c:	687b      	ldr	r3, [r7, #4]
 8012a2e:	681b      	ldr	r3, [r3, #0]
 8012a30:	f003 0310 	and.w	r3, r3, #16
 8012a34:	2b00      	cmp	r3, #0
 8012a36:	d004      	beq.n	8012a42 <HAL_RCCEx_PeriphCLKConfig+0x162>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8012a38:	687b      	ldr	r3, [r7, #4]
 8012a3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012a3c:	4618      	mov	r0, r3
 8012a3e:	f7ff fd4a 	bl	80124d6 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8012a42:	687b      	ldr	r3, [r7, #4]
 8012a44:	681b      	ldr	r3, [r3, #0]
 8012a46:	f003 0320 	and.w	r3, r3, #32
 8012a4a:	2b00      	cmp	r3, #0
 8012a4c:	d004      	beq.n	8012a58 <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8012a4e:	687b      	ldr	r3, [r7, #4]
 8012a50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012a52:	4618      	mov	r0, r3
 8012a54:	f7ff fd3f 	bl	80124d6 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8012a58:	687b      	ldr	r3, [r7, #4]
 8012a5a:	681b      	ldr	r3, [r3, #0]
 8012a5c:	f003 0304 	and.w	r3, r3, #4
 8012a60:	2b00      	cmp	r3, #0
 8012a62:	d004      	beq.n	8012a6e <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8012a64:	687b      	ldr	r3, [r7, #4]
 8012a66:	6a1b      	ldr	r3, [r3, #32]
 8012a68:	4618      	mov	r0, r3
 8012a6a:	f7ff fd17 	bl	801249c <LL_RCC_SetI2CClockSource>
  }

#if defined(I2C3)
  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8012a6e:	687b      	ldr	r3, [r7, #4]
 8012a70:	681b      	ldr	r3, [r3, #0]
 8012a72:	f003 0308 	and.w	r3, r3, #8
 8012a76:	2b00      	cmp	r3, #0
 8012a78:	d004      	beq.n	8012a84 <HAL_RCCEx_PeriphCLKConfig+0x1a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8012a7a:	687b      	ldr	r3, [r7, #4]
 8012a7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012a7e:	4618      	mov	r0, r3
 8012a80:	f7ff fd0c 	bl	801249c <LL_RCC_SetI2CClockSource>
  }
#endif

#if defined(USB)
  /*-------------------------- USB clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8012a84:	687b      	ldr	r3, [r7, #4]
 8012a86:	681b      	ldr	r3, [r3, #0]
 8012a88:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8012a8c:	2b00      	cmp	r3, #0
 8012a8e:	d022      	beq.n	8012ad6 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8012a90:	687b      	ldr	r3, [r7, #4]
 8012a92:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012a94:	4618      	mov	r0, r3
 8012a96:	f7ff fd7a 	bl	801258e <LL_RCC_SetUSBClockSource>

    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8012a9a:	687b      	ldr	r3, [r7, #4]
 8012a9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012a9e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8012aa2:	d107      	bne.n	8012ab4 <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_USBCLK);
 8012aa4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012aa8:	68db      	ldr	r3, [r3, #12]
 8012aaa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8012aae:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012ab2:	60d3      	str	r3, [r2, #12]
    }
#if defined(SAI1)
  if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8012ab4:	687b      	ldr	r3, [r7, #4]
 8012ab6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012ab8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8012abc:	d10b      	bne.n	8012ad6 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
    ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 8012abe:	687b      	ldr	r3, [r7, #4]
 8012ac0:	3304      	adds	r3, #4
 8012ac2:	4618      	mov	r0, r3
 8012ac4:	f000 fcfa 	bl	80134bc <RCCEx_PLLSAI1_ConfigNQ>
 8012ac8:	4603      	mov	r3, r0
 8012aca:	77fb      	strb	r3, [r7, #31]

    if (ret != HAL_OK)
 8012acc:	7ffb      	ldrb	r3, [r7, #31]
 8012ace:	2b00      	cmp	r3, #0
 8012ad0:	d001      	beq.n	8012ad6 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    {
      /* set overall return value */
      status = ret;
 8012ad2:	7ffb      	ldrb	r3, [r7, #31]
 8012ad4:	77bb      	strb	r3, [r7, #30]
#endif
  }
#endif

  /*-------------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8012ad6:	687b      	ldr	r3, [r7, #4]
 8012ad8:	681b      	ldr	r3, [r3, #0]
 8012ada:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8012ade:	2b00      	cmp	r3, #0
 8012ae0:	d02b      	beq.n	8012b3a <HAL_RCCEx_PeriphCLKConfig+0x25a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));

    /* Configure the RNG clock source */
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8012ae2:	687b      	ldr	r3, [r7, #4]
 8012ae4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012ae6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8012aea:	d008      	beq.n	8012afe <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8012aec:	687b      	ldr	r3, [r7, #4]
 8012aee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012af0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8012af4:	d003      	beq.n	8012afe <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8012af6:	687b      	ldr	r3, [r7, #4]
 8012af8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012afa:	2b00      	cmp	r3, #0
 8012afc:	d105      	bne.n	8012b0a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 8012afe:	687b      	ldr	r3, [r7, #4]
 8012b00:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012b02:	4618      	mov	r0, r3
 8012b04:	f7ff fd17 	bl	8012536 <LL_RCC_SetRNGClockSource>
 8012b08:	e00a      	b.n	8012b20 <HAL_RCCEx_PeriphCLKConfig+0x240>
 8012b0a:	687b      	ldr	r3, [r7, #4]
 8012b0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012b0e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8012b12:	60fb      	str	r3, [r7, #12]
 8012b14:	2000      	movs	r0, #0
 8012b16:	f7ff fd0e 	bl	8012536 <LL_RCC_SetRNGClockSource>
 8012b1a:	68f8      	ldr	r0, [r7, #12]
 8012b1c:	f7ff fd21 	bl	8012562 <LL_RCC_SetCLK48ClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8012b20:	687b      	ldr	r3, [r7, #4]
 8012b22:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8012b24:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 8012b28:	d107      	bne.n	8012b3a <HAL_RCCEx_PeriphCLKConfig+0x25a>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8012b2a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012b2e:	68db      	ldr	r3, [r3, #12]
 8012b30:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8012b34:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8012b38:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8012b3a:	687b      	ldr	r3, [r7, #4]
 8012b3c:	681b      	ldr	r3, [r3, #0]
 8012b3e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012b42:	2b00      	cmp	r3, #0
 8012b44:	d022      	beq.n	8012b8c <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8012b46:	687b      	ldr	r3, [r7, #4]
 8012b48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012b4a:	4618      	mov	r0, r3
 8012b4c:	f7ff fd2a 	bl	80125a4 <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8012b50:	687b      	ldr	r3, [r7, #4]
 8012b52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012b54:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8012b58:	d107      	bne.n	8012b6a <HAL_RCCEx_PeriphCLKConfig+0x28a>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8012b5a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8012b5e:	68db      	ldr	r3, [r3, #12]
 8012b60:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8012b64:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012b68:	60d3      	str	r3, [r2, #12]
    }

#if defined(SAI1)
  if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8012b6a:	687b      	ldr	r3, [r7, #4]
 8012b6c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012b6e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8012b72:	d10b      	bne.n	8012b8c <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* PLLSAI1 parameters N & R configuration and clock output (PLLSAI1ClockOut) */
    ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
 8012b74:	687b      	ldr	r3, [r7, #4]
 8012b76:	3304      	adds	r3, #4
 8012b78:	4618      	mov	r0, r3
 8012b7a:	f000 fcfa 	bl	8013572 <RCCEx_PLLSAI1_ConfigNR>
 8012b7e:	4603      	mov	r3, r0
 8012b80:	77fb      	strb	r3, [r7, #31]

    if (ret != HAL_OK)
 8012b82:	7ffb      	ldrb	r3, [r7, #31]
 8012b84:	2b00      	cmp	r3, #0
 8012b86:	d001      	beq.n	8012b8c <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    {
      /* set overall return value */
      status = ret;
 8012b88:	7ffb      	ldrb	r3, [r7, #31]
 8012b8a:	77bb      	strb	r3, [r7, #30]
  }
#endif
  }

  /*-------------------------- RFWKP clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RFWAKEUP) == RCC_PERIPHCLK_RFWAKEUP)
 8012b8c:	687b      	ldr	r3, [r7, #4]
 8012b8e:	681b      	ldr	r3, [r3, #0]
 8012b90:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8012b94:	2b00      	cmp	r3, #0
 8012b96:	d004      	beq.n	8012ba2 <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RFWKPCLKSOURCE(PeriphClkInit->RFWakeUpClockSelection));

    /* Configure the RFWKP interface clock source */
    __HAL_RCC_RFWAKEUP_CONFIG(PeriphClkInit->RFWakeUpClockSelection);
 8012b98:	687b      	ldr	r3, [r7, #4]
 8012b9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012b9c:	4618      	mov	r0, r3
 8012b9e:	f7ff fbca 	bl	8012336 <LL_RCC_SetRFWKPClockSource>

  }

#if defined(RCC_SMPS_SUPPORT)
  /*-------------------------- SMPS clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS)
 8012ba2:	687b      	ldr	r3, [r7, #4]
 8012ba4:	681b      	ldr	r3, [r3, #0]
 8012ba6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8012baa:	2b00      	cmp	r3, #0
 8012bac:	d009      	beq.n	8012bc2 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
    /* Check the parameters */
    assert_param(IS_RCC_SMPSCLKDIV(PeriphClkInit->SmpsDivSelection));
    assert_param(IS_RCC_SMPSCLKSOURCE(PeriphClkInit->SmpsClockSelection));

    /* Configure the SMPS interface clock division factor */
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
 8012bae:	687b      	ldr	r3, [r7, #4]
 8012bb0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8012bb2:	4618      	mov	r0, r3
 8012bb4:	f7ff fc26 	bl	8012404 <LL_RCC_SetSMPSPrescaler>

    /* Configure the SMPS interface clock source */
    __HAL_RCC_SMPS_CONFIG(PeriphClkInit->SmpsClockSelection);
 8012bb8:	687b      	ldr	r3, [r7, #4]
 8012bba:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8012bbc:	4618      	mov	r0, r3
 8012bbe:	f7ff fc01 	bl	80123c4 <LL_RCC_SetSMPSClockSource>
  }
#endif


  return status;
 8012bc2:	7fbb      	ldrb	r3, [r7, #30]
}
 8012bc4:	4618      	mov	r0, r3
 8012bc6:	3720      	adds	r7, #32
 8012bc8:	46bd      	mov	sp, r7
 8012bca:	bd80      	pop	{r7, pc}

08012bcc <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_RFWAKEUP  RFWKP peripheral clock
  *            @arg @ref RCC_PERIPHCLK_SMPS  SMPS peripheral clock
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8012bcc:	b590      	push	{r4, r7, lr}
 8012bce:	b093      	sub	sp, #76	; 0x4c
 8012bd0:	af00      	add	r7, sp, #0
 8012bd2:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0U;
 8012bd4:	2300      	movs	r3, #0
 8012bd6:	647b      	str	r3, [r7, #68]	; 0x44
  
#if defined(RCC_SMPS_SUPPORT)
  uint32_t smps_prescaler_index = ((LL_RCC_GetSMPSPrescaler()) >> RCC_SMPSCR_SMPSDIV_Pos);
 8012bd8:	f7ff fc28 	bl	801242c <LL_RCC_GetSMPSPrescaler>
 8012bdc:	4603      	mov	r3, r0
 8012bde:	091b      	lsrs	r3, r3, #4
 8012be0:	643b      	str	r3, [r7, #64]	; 0x40
#endif
  
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
  
  if (PeriphClk == RCC_PERIPHCLK_RTC)
 8012be2:	687b      	ldr	r3, [r7, #4]
 8012be4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8012be8:	d12d      	bne.n	8012c46 <HAL_RCCEx_GetPeriphCLKFreq+0x7a>
  {
    uint32_t rtcClockSource = LL_RCC_GetRTCClockSource();
 8012bea:	f7ff fd9a 	bl	8012722 <LL_RCC_GetRTCClockSource>
 8012bee:	6138      	str	r0, [r7, #16]
    
    if (rtcClockSource == LL_RCC_RTC_CLKSOURCE_LSE) /* LSE clock used as RTC clock source */
 8012bf0:	693b      	ldr	r3, [r7, #16]
 8012bf2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012bf6:	d109      	bne.n	8012c0c <HAL_RCCEx_GetPeriphCLKFreq+0x40>
    {
      if (LL_RCC_LSE_IsReady() == 1U)
 8012bf8:	f7ff fb32 	bl	8012260 <LL_RCC_LSE_IsReady>
 8012bfc:	4603      	mov	r3, r0
 8012bfe:	2b01      	cmp	r3, #1
 8012c00:	f040 83d8 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSE_VALUE;
 8012c04:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8012c08:	647b      	str	r3, [r7, #68]	; 0x44
 8012c0a:	e3d3      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rtcClockSource == LL_RCC_RTC_CLKSOURCE_LSI) /* LSI clock used as RTC clock source */
 8012c0c:	693b      	ldr	r3, [r7, #16]
 8012c0e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8012c12:	d110      	bne.n	8012c36 <HAL_RCCEx_GetPeriphCLKFreq+0x6a>
    {
      const uint32_t temp_lsi1ready = LL_RCC_LSI1_IsReady();
 8012c14:	f7ff fb36 	bl	8012284 <LL_RCC_LSI1_IsReady>
 8012c18:	60f8      	str	r0, [r7, #12]
      const uint32_t temp_lsi2ready = LL_RCC_LSI2_IsReady();
 8012c1a:	f7ff fb45 	bl	80122a8 <LL_RCC_LSI2_IsReady>
 8012c1e:	60b8      	str	r0, [r7, #8]
      if ((temp_lsi1ready == 1U) || (temp_lsi2ready == 1U))
 8012c20:	68fb      	ldr	r3, [r7, #12]
 8012c22:	2b01      	cmp	r3, #1
 8012c24:	d003      	beq.n	8012c2e <HAL_RCCEx_GetPeriphCLKFreq+0x62>
 8012c26:	68bb      	ldr	r3, [r7, #8]
 8012c28:	2b01      	cmp	r3, #1
 8012c2a:	f040 83c3 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSI_VALUE;
 8012c2e:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 8012c32:	647b      	str	r3, [r7, #68]	; 0x44
 8012c34:	e3be      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rtcClockSource == LL_RCC_RTC_CLKSOURCE_HSE_DIV32) /* HSE clock used as RTC clock source */
 8012c36:	693b      	ldr	r3, [r7, #16]
 8012c38:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8012c3c:	f040 83ba 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    {
      frequency = HSE_VALUE / 32U;
 8012c40:	4bba      	ldr	r3, [pc, #744]	; (8012f2c <HAL_RCCEx_GetPeriphCLKFreq+0x360>)
 8012c42:	647b      	str	r3, [r7, #68]	; 0x44
 8012c44:	e3b6      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    {
      /* Nothing to do as frequency already initialized to 0U */
    }
  }
#if defined(SAI1)
  else if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8012c46:	687b      	ldr	r3, [r7, #4]
 8012c48:	2b40      	cmp	r3, #64	; 0x40
 8012c4a:	d130      	bne.n	8012cae <HAL_RCCEx_GetPeriphCLKFreq+0xe2>
  {
    switch (LL_RCC_GetSAIClockSource(LL_RCC_SAI1_CLKSOURCE))
 8012c4c:	f44f 0040 	mov.w	r0, #12582912	; 0xc00000
 8012c50:	f7ff fd05 	bl	801265e <LL_RCC_GetSAIClockSource>
 8012c54:	4603      	mov	r3, r0
 8012c56:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8012c5a:	d008      	beq.n	8012c6e <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
 8012c5c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8012c60:	d822      	bhi.n	8012ca8 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>
 8012c62:	2b00      	cmp	r3, #0
 8012c64:	d00c      	beq.n	8012c80 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
 8012c66:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8012c6a:	d013      	beq.n	8012c94 <HAL_RCCEx_GetPeriphCLKFreq+0xc8>
 8012c6c:	e01c      	b.n	8012ca8 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>
    {
    case LL_RCC_SAI1_CLKSOURCE_HSI:        /* HSI clock used as SAI1 clock source */
      if (LL_RCC_HSI_IsReady() == 1U)
 8012c6e:	f7ff fac1 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8012c72:	4603      	mov	r3, r0
 8012c74:	2b01      	cmp	r3, #1
 8012c76:	f040 837e 	bne.w	8013376 <HAL_RCCEx_GetPeriphCLKFreq+0x7aa>
      {
        frequency = HSI_VALUE;
 8012c7a:	4bad      	ldr	r3, [pc, #692]	; (8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x364>)
 8012c7c:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012c7e:	e37a      	b.n	8013376 <HAL_RCCEx_GetPeriphCLKFreq+0x7aa>
      
#if defined(SAI1)
    case LL_RCC_SAI1_CLKSOURCE_PLLSAI1:    /* PLLSAI1 clock used as SAI1 clock source */
      if (LL_RCC_PLLSAI1_IsReady() == 1U)
 8012c80:	f7ff fddf 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8012c84:	4603      	mov	r3, r0
 8012c86:	2b01      	cmp	r3, #1
 8012c88:	f040 8377 	bne.w	801337a <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
      {
        frequency = RCC_PLLSAI1_GetFreqDomain_P();
 8012c8c:	f000 fdce 	bl	801382c <RCC_PLLSAI1_GetFreqDomain_P>
 8012c90:	6478      	str	r0, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012c92:	e372      	b.n	801337a <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
#endif
      
    case LL_RCC_SAI1_CLKSOURCE_PLL:        /* PLL clock used as SAI1 clock source */
      if (LL_RCC_PLL_IsReady() == 1U)
 8012c94:	f7ff fd74 	bl	8012780 <LL_RCC_PLL_IsReady>
 8012c98:	4603      	mov	r3, r0
 8012c9a:	2b01      	cmp	r3, #1
 8012c9c:	f040 836f 	bne.w	801337e <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
      {
        frequency = RCC_PLL_GetFreqDomain_P();
 8012ca0:	f000 fcc2 	bl	8013628 <RCC_PLL_GetFreqDomain_P>
 8012ca4:	6478      	str	r0, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012ca6:	e36a      	b.n	801337e <HAL_RCCEx_GetPeriphCLKFreq+0x7b2>
      
    default: /* External input clock used as SAI1 clock source */
      frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 8012ca8:	4ba2      	ldr	r3, [pc, #648]	; (8012f34 <HAL_RCCEx_GetPeriphCLKFreq+0x368>)
 8012caa:	647b      	str	r3, [r7, #68]	; 0x44
      break;
 8012cac:	e382      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
#endif
  else if (PeriphClk == RCC_PERIPHCLK_RNG)
 8012cae:	687b      	ldr	r3, [r7, #4]
 8012cb0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8012cb4:	d168      	bne.n	8012d88 <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
  {
    uint32_t rngClockSource = HAL_RCCEx_GetRngCLKSource();
 8012cb6:	f000 fb87 	bl	80133c8 <HAL_RCCEx_GetRngCLKSource>
 8012cba:	61f8      	str	r0, [r7, #28]
    
    if (rngClockSource == RCC_RNGCLKSOURCE_LSI)             /* LSI clock used as RNG clock source */
 8012cbc:	69fb      	ldr	r3, [r7, #28]
 8012cbe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8012cc2:	d110      	bne.n	8012ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x11a>
    {
      const uint32_t temp_lsi1ready = LL_RCC_LSI1_IsReady();
 8012cc4:	f7ff fade 	bl	8012284 <LL_RCC_LSI1_IsReady>
 8012cc8:	61b8      	str	r0, [r7, #24]
      const uint32_t temp_lsi2ready = LL_RCC_LSI2_IsReady();
 8012cca:	f7ff faed 	bl	80122a8 <LL_RCC_LSI2_IsReady>
 8012cce:	6178      	str	r0, [r7, #20]
      if ((temp_lsi1ready == 1U) || (temp_lsi2ready == 1U))
 8012cd0:	69bb      	ldr	r3, [r7, #24]
 8012cd2:	2b01      	cmp	r3, #1
 8012cd4:	d003      	beq.n	8012cde <HAL_RCCEx_GetPeriphCLKFreq+0x112>
 8012cd6:	697b      	ldr	r3, [r7, #20]
 8012cd8:	2b01      	cmp	r3, #1
 8012cda:	f040 836b 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSI_VALUE;
 8012cde:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 8012ce2:	647b      	str	r3, [r7, #68]	; 0x44
 8012ce4:	e366      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rngClockSource == RCC_RNGCLKSOURCE_LSE)        /* LSE clock used as RNG clock source */
 8012ce6:	69fb      	ldr	r3, [r7, #28]
 8012ce8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8012cec:	d109      	bne.n	8012d02 <HAL_RCCEx_GetPeriphCLKFreq+0x136>
    {
      if (LL_RCC_LSE_IsReady() == 1U)
 8012cee:	f7ff fab7 	bl	8012260 <LL_RCC_LSE_IsReady>
 8012cf2:	4603      	mov	r3, r0
 8012cf4:	2b01      	cmp	r3, #1
 8012cf6:	f040 835d 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSE_VALUE;
 8012cfa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8012cfe:	647b      	str	r3, [r7, #68]	; 0x44
 8012d00:	e358      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rngClockSource == RCC_RNGCLKSOURCE_PLL)        /* PLL clock divided by 3 used as RNG clock source */
 8012d02:	69fb      	ldr	r3, [r7, #28]
 8012d04:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 8012d08:	d10e      	bne.n	8012d28 <HAL_RCCEx_GetPeriphCLKFreq+0x15c>
    {
      if (LL_RCC_PLL_IsReady() == 1U)
 8012d0a:	f7ff fd39 	bl	8012780 <LL_RCC_PLL_IsReady>
 8012d0e:	4603      	mov	r3, r0
 8012d10:	2b01      	cmp	r3, #1
 8012d12:	f040 834f 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = (RCC_PLL_GetFreqDomain_Q() / 3U);
 8012d16:	f000 fcdd 	bl	80136d4 <RCC_PLL_GetFreqDomain_Q>
 8012d1a:	4603      	mov	r3, r0
 8012d1c:	4a86      	ldr	r2, [pc, #536]	; (8012f38 <HAL_RCCEx_GetPeriphCLKFreq+0x36c>)
 8012d1e:	fba2 2303 	umull	r2, r3, r2, r3
 8012d22:	085b      	lsrs	r3, r3, #1
 8012d24:	647b      	str	r3, [r7, #68]	; 0x44
 8012d26:	e345      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rngClockSource == RCC_RNGCLKSOURCE_MSI)        /* MSI clock divided by 3 used as RNG clock source */
 8012d28:	69fb      	ldr	r3, [r7, #28]
 8012d2a:	f1b3 5fe0 	cmp.w	r3, #469762048	; 0x1c000000
 8012d2e:	d114      	bne.n	8012d5a <HAL_RCCEx_GetPeriphCLKFreq+0x18e>
    {
      if (LL_RCC_MSI_IsReady() == 1U)
 8012d30:	f7ff facc 	bl	80122cc <LL_RCC_MSI_IsReady>
 8012d34:	4603      	mov	r3, r0
 8012d36:	2b01      	cmp	r3, #1
 8012d38:	f040 833c 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = (__LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange()) / 3U);
 8012d3c:	f7ff fae6 	bl	801230c <LL_RCC_MSI_GetRange>
 8012d40:	4603      	mov	r3, r0
 8012d42:	091b      	lsrs	r3, r3, #4
 8012d44:	f003 030f 	and.w	r3, r3, #15
 8012d48:	4a7c      	ldr	r2, [pc, #496]	; (8012f3c <HAL_RCCEx_GetPeriphCLKFreq+0x370>)
 8012d4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012d4e:	4a7a      	ldr	r2, [pc, #488]	; (8012f38 <HAL_RCCEx_GetPeriphCLKFreq+0x36c>)
 8012d50:	fba2 2303 	umull	r2, r3, r2, r3
 8012d54:	085b      	lsrs	r3, r3, #1
 8012d56:	647b      	str	r3, [r7, #68]	; 0x44
 8012d58:	e32c      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
#if defined(SAI1)
    else if (rngClockSource == RCC_RNGCLKSOURCE_PLLSAI1)    /* PLLSAI1 clock used as SAI1 clock source */
 8012d5a:	69fb      	ldr	r3, [r7, #28]
 8012d5c:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
 8012d60:	d109      	bne.n	8012d76 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
    {
      if (LL_RCC_PLLSAI1_IsReady() == 1U)
 8012d62:	f7ff fd6e 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8012d66:	4603      	mov	r3, r0
 8012d68:	2b01      	cmp	r3, #1
 8012d6a:	f040 8323 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = RCC_PLLSAI1_GetFreqDomain_Q();
 8012d6e:	f000 fdb3 	bl	80138d8 <RCC_PLLSAI1_GetFreqDomain_Q>
 8012d72:	6478      	str	r0, [r7, #68]	; 0x44
 8012d74:	e31e      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
#endif /* SAI1 */
    else                                                    /* HSI48 clock divided by 3 used as RNG clock source */
    {
#if defined(RCC_HSI48_SUPPORT)
      if (LL_RCC_HSI48_IsReady() == 1U)
 8012d76:	f7ff fa4f 	bl	8012218 <LL_RCC_HSI48_IsReady>
 8012d7a:	4603      	mov	r3, r0
 8012d7c:	2b01      	cmp	r3, #1
 8012d7e:	f040 8319 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = HSI48_VALUE / 3U;
 8012d82:	4b6b      	ldr	r3, [pc, #428]	; (8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x364>)
 8012d84:	647b      	str	r3, [r7, #68]	; 0x44
 8012d86:	e315      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      /* Nothing to do as frequency already initialized to 0U */
#endif
    }
  }
#if defined(USB)
  else if (PeriphClk == RCC_PERIPHCLK_USB)
 8012d88:	687b      	ldr	r3, [r7, #4]
 8012d8a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012d8e:	d13f      	bne.n	8012e10 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
  {
    switch (LL_RCC_GetUSBClockSource(LL_RCC_USB_CLKSOURCE))
 8012d90:	f04f 6040 	mov.w	r0, #201326592	; 0xc000000
 8012d94:	f7ff fc93 	bl	80126be <LL_RCC_GetUSBClockSource>
 8012d98:	4603      	mov	r3, r0
 8012d9a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8012d9e:	d01d      	beq.n	8012ddc <HAL_RCCEx_GetPeriphCLKFreq+0x210>
 8012da0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 8012da4:	d82b      	bhi.n	8012dfe <HAL_RCCEx_GetPeriphCLKFreq+0x232>
 8012da6:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8012daa:	d003      	beq.n	8012db4 <HAL_RCCEx_GetPeriphCLKFreq+0x1e8>
 8012dac:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8012db0:	d00a      	beq.n	8012dc8 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
 8012db2:	e024      	b.n	8012dfe <HAL_RCCEx_GetPeriphCLKFreq+0x232>
    {
#if defined(SAI1)
    case LL_RCC_USB_CLKSOURCE_PLLSAI1:       /* PLLSAI1 clock used as USB clock source */
      if (LL_RCC_PLLSAI1_IsReady() == 1U)
 8012db4:	f7ff fd45 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8012db8:	4603      	mov	r3, r0
 8012dba:	2b01      	cmp	r3, #1
 8012dbc:	f040 82e1 	bne.w	8013382 <HAL_RCCEx_GetPeriphCLKFreq+0x7b6>
      {
        frequency = RCC_PLLSAI1_GetFreqDomain_Q();
 8012dc0:	f000 fd8a 	bl	80138d8 <RCC_PLLSAI1_GetFreqDomain_Q>
 8012dc4:	6478      	str	r0, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012dc6:	e2dc      	b.n	8013382 <HAL_RCCEx_GetPeriphCLKFreq+0x7b6>
#endif
      
    case LL_RCC_USB_CLKSOURCE_PLL:           /* PLL clock used as USB clock source */
      if (LL_RCC_PLL_IsReady() == 1U)
 8012dc8:	f7ff fcda 	bl	8012780 <LL_RCC_PLL_IsReady>
 8012dcc:	4603      	mov	r3, r0
 8012dce:	2b01      	cmp	r3, #1
 8012dd0:	f040 82d9 	bne.w	8013386 <HAL_RCCEx_GetPeriphCLKFreq+0x7ba>
      {
        frequency = RCC_PLL_GetFreqDomain_Q();
 8012dd4:	f000 fc7e 	bl	80136d4 <RCC_PLL_GetFreqDomain_Q>
 8012dd8:	6478      	str	r0, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012dda:	e2d4      	b.n	8013386 <HAL_RCCEx_GetPeriphCLKFreq+0x7ba>
      
    case LL_RCC_USB_CLKSOURCE_MSI:           /* MSI clock used as USB clock source */
      if (LL_RCC_MSI_IsReady() == 1U)
 8012ddc:	f7ff fa76 	bl	80122cc <LL_RCC_MSI_IsReady>
 8012de0:	4603      	mov	r3, r0
 8012de2:	2b01      	cmp	r3, #1
 8012de4:	f040 82d1 	bne.w	801338a <HAL_RCCEx_GetPeriphCLKFreq+0x7be>
      {
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8012de8:	f7ff fa90 	bl	801230c <LL_RCC_MSI_GetRange>
 8012dec:	4603      	mov	r3, r0
 8012dee:	091b      	lsrs	r3, r3, #4
 8012df0:	f003 030f 	and.w	r3, r3, #15
 8012df4:	4a51      	ldr	r2, [pc, #324]	; (8012f3c <HAL_RCCEx_GetPeriphCLKFreq+0x370>)
 8012df6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012dfa:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012dfc:	e2c5      	b.n	801338a <HAL_RCCEx_GetPeriphCLKFreq+0x7be>
      
    default: /* HSI48 clock used as USB clock source */
      if (LL_RCC_HSI48_IsReady() == 1U)
 8012dfe:	f7ff fa0b 	bl	8012218 <LL_RCC_HSI48_IsReady>
 8012e02:	4603      	mov	r3, r0
 8012e04:	2b01      	cmp	r3, #1
 8012e06:	f040 82c2 	bne.w	801338e <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
      {
        frequency = HSI48_VALUE;
 8012e0a:	4b4d      	ldr	r3, [pc, #308]	; (8012f40 <HAL_RCCEx_GetPeriphCLKFreq+0x374>)
 8012e0c:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012e0e:	e2be      	b.n	801338e <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
    }
  }
#endif
  else if (PeriphClk == RCC_PERIPHCLK_USART1)
 8012e10:	687b      	ldr	r3, [r7, #4]
 8012e12:	2b01      	cmp	r3, #1
 8012e14:	d140      	bne.n	8012e98 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>
  {
    switch (LL_RCC_GetUSARTClockSource(LL_RCC_USART1_CLKSOURCE))
 8012e16:	2003      	movs	r0, #3
 8012e18:	f7ff fbda 	bl	80125d0 <LL_RCC_GetUSARTClockSource>
 8012e1c:	4603      	mov	r3, r0
 8012e1e:	2b03      	cmp	r3, #3
 8012e20:	d013      	beq.n	8012e4a <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
 8012e22:	2b03      	cmp	r3, #3
 8012e24:	d81b      	bhi.n	8012e5e <HAL_RCCEx_GetPeriphCLKFreq+0x292>
 8012e26:	2b01      	cmp	r3, #1
 8012e28:	d002      	beq.n	8012e30 <HAL_RCCEx_GetPeriphCLKFreq+0x264>
 8012e2a:	2b02      	cmp	r3, #2
 8012e2c:	d004      	beq.n	8012e38 <HAL_RCCEx_GetPeriphCLKFreq+0x26c>
 8012e2e:	e016      	b.n	8012e5e <HAL_RCCEx_GetPeriphCLKFreq+0x292>
    {
    case LL_RCC_USART1_CLKSOURCE_SYSCLK: /* USART1 Clock is System Clock */
      frequency = HAL_RCC_GetSysClockFreq();
 8012e30:	f7ff f83c 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012e34:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012e36:	e2bd      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      
    case LL_RCC_USART1_CLKSOURCE_HSI:    /* USART1 Clock is HSI Osc. */
      if (LL_RCC_HSI_IsReady() == 1U)
 8012e38:	f7ff f9dc 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8012e3c:	4603      	mov	r3, r0
 8012e3e:	2b01      	cmp	r3, #1
 8012e40:	f040 82a7 	bne.w	8013392 <HAL_RCCEx_GetPeriphCLKFreq+0x7c6>
      {
        frequency = HSI_VALUE;
 8012e44:	4b3a      	ldr	r3, [pc, #232]	; (8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x364>)
 8012e46:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012e48:	e2a3      	b.n	8013392 <HAL_RCCEx_GetPeriphCLKFreq+0x7c6>
      
    case LL_RCC_USART1_CLKSOURCE_LSE:    /* USART1 Clock is LSE Osc. */
      if (LL_RCC_LSE_IsReady() == 1U)
 8012e4a:	f7ff fa09 	bl	8012260 <LL_RCC_LSE_IsReady>
 8012e4e:	4603      	mov	r3, r0
 8012e50:	2b01      	cmp	r3, #1
 8012e52:	f040 82a0 	bne.w	8013396 <HAL_RCCEx_GetPeriphCLKFreq+0x7ca>
      {
        frequency = LSE_VALUE;
 8012e56:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8012e5a:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012e5c:	e29b      	b.n	8013396 <HAL_RCCEx_GetPeriphCLKFreq+0x7ca>
      
    default: /* USART1 Clock is PCLK2 */
      frequency = __LL_RCC_CALC_PCLK2_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), \
 8012e5e:	f7ff f825 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012e62:	4604      	mov	r4, r0
 8012e64:	f7ff fa8a 	bl	801237c <LL_RCC_GetAHBPrescaler>
 8012e68:	4603      	mov	r3, r0
 8012e6a:	091b      	lsrs	r3, r3, #4
 8012e6c:	f003 030f 	and.w	r3, r3, #15
 8012e70:	4a34      	ldr	r2, [pc, #208]	; (8012f44 <HAL_RCCEx_GetPeriphCLKFreq+0x378>)
 8012e72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012e76:	fbb4 f4f3 	udiv	r4, r4, r3
 8012e7a:	f7ff fa97 	bl	80123ac <LL_RCC_GetAPB2Prescaler>
 8012e7e:	4603      	mov	r3, r0
 8012e80:	0adb      	lsrs	r3, r3, #11
 8012e82:	f003 0307 	and.w	r3, r3, #7
 8012e86:	4a30      	ldr	r2, [pc, #192]	; (8012f48 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>)
 8012e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012e8c:	f003 031f 	and.w	r3, r3, #31
 8012e90:	fa24 f303 	lsr.w	r3, r4, r3
 8012e94:	647b      	str	r3, [r7, #68]	; 0x44
        LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB2Prescaler());
      break;
 8012e96:	e28d      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
#if defined(LPUART1)
  else if (PeriphClk == RCC_PERIPHCLK_LPUART1)
 8012e98:	687b      	ldr	r3, [r7, #4]
 8012e9a:	2b02      	cmp	r3, #2
 8012e9c:	d156      	bne.n	8012f4c <HAL_RCCEx_GetPeriphCLKFreq+0x380>
  {
    switch (LL_RCC_GetLPUARTClockSource(LL_RCC_LPUART1_CLKSOURCE))
 8012e9e:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8012ea2:	f7ff fba5 	bl	80125f0 <LL_RCC_GetLPUARTClockSource>
 8012ea6:	4603      	mov	r3, r0
 8012ea8:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8012eac:	d016      	beq.n	8012edc <HAL_RCCEx_GetPeriphCLKFreq+0x310>
 8012eae:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8012eb2:	d81d      	bhi.n	8012ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x324>
 8012eb4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8012eb8:	d003      	beq.n	8012ec2 <HAL_RCCEx_GetPeriphCLKFreq+0x2f6>
 8012eba:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8012ebe:	d004      	beq.n	8012eca <HAL_RCCEx_GetPeriphCLKFreq+0x2fe>
 8012ec0:	e016      	b.n	8012ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x324>
    {
    case LL_RCC_LPUART1_CLKSOURCE_SYSCLK: /* LPUART1 Clock is System Clock */
      frequency = HAL_RCC_GetSysClockFreq();
 8012ec2:	f7fe fff3 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012ec6:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012ec8:	e274      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      
    case LL_RCC_LPUART1_CLKSOURCE_HSI:    /* LPUART1 Clock is HSI Osc. */
      if (LL_RCC_HSI_IsReady() == 1U)
 8012eca:	f7ff f993 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8012ece:	4603      	mov	r3, r0
 8012ed0:	2b01      	cmp	r3, #1
 8012ed2:	f040 8262 	bne.w	801339a <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
      {
        frequency = HSI_VALUE;
 8012ed6:	4b16      	ldr	r3, [pc, #88]	; (8012f30 <HAL_RCCEx_GetPeriphCLKFreq+0x364>)
 8012ed8:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012eda:	e25e      	b.n	801339a <HAL_RCCEx_GetPeriphCLKFreq+0x7ce>
      
    case LL_RCC_LPUART1_CLKSOURCE_LSE:    /* LPUART1 Clock is LSE Osc. */
      if (LL_RCC_LSE_IsReady() == 1U)
 8012edc:	f7ff f9c0 	bl	8012260 <LL_RCC_LSE_IsReady>
 8012ee0:	4603      	mov	r3, r0
 8012ee2:	2b01      	cmp	r3, #1
 8012ee4:	f040 825b 	bne.w	801339e <HAL_RCCEx_GetPeriphCLKFreq+0x7d2>
      {
        frequency = LSE_VALUE;
 8012ee8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8012eec:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012eee:	e256      	b.n	801339e <HAL_RCCEx_GetPeriphCLKFreq+0x7d2>
      
    default: /* LPUART1 Clock is PCLK1 */
      frequency = __LL_RCC_CALC_PCLK1_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), \
 8012ef0:	f7fe ffdc 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012ef4:	4604      	mov	r4, r0
 8012ef6:	f7ff fa41 	bl	801237c <LL_RCC_GetAHBPrescaler>
 8012efa:	4603      	mov	r3, r0
 8012efc:	091b      	lsrs	r3, r3, #4
 8012efe:	f003 030f 	and.w	r3, r3, #15
 8012f02:	4a10      	ldr	r2, [pc, #64]	; (8012f44 <HAL_RCCEx_GetPeriphCLKFreq+0x378>)
 8012f04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012f08:	fbb4 f4f3 	udiv	r4, r4, r3
 8012f0c:	f7ff fa42 	bl	8012394 <LL_RCC_GetAPB1Prescaler>
 8012f10:	4603      	mov	r3, r0
 8012f12:	0a1b      	lsrs	r3, r3, #8
 8012f14:	f003 0307 	and.w	r3, r3, #7
 8012f18:	4a0b      	ldr	r2, [pc, #44]	; (8012f48 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>)
 8012f1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012f1e:	f003 031f 	and.w	r3, r3, #31
 8012f22:	fa24 f303 	lsr.w	r3, r4, r3
 8012f26:	647b      	str	r3, [r7, #68]	; 0x44
        LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB1Prescaler());
      break;
 8012f28:	e244      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
 8012f2a:	bf00      	nop
 8012f2c:	000f4240 	.word	0x000f4240
 8012f30:	00f42400 	.word	0x00f42400
 8012f34:	001fff68 	.word	0x001fff68
 8012f38:	aaaaaaab 	.word	0xaaaaaaab
 8012f3c:	0802ca8c 	.word	0x0802ca8c
 8012f40:	02dc6c00 	.word	0x02dc6c00
 8012f44:	0802ca2c 	.word	0x0802ca2c
 8012f48:	0802ca6c 	.word	0x0802ca6c
    }
  }
#endif
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 8012f4c:	687b      	ldr	r3, [r7, #4]
 8012f4e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8012f52:	d12a      	bne.n	8012faa <HAL_RCCEx_GetPeriphCLKFreq+0x3de>
  {
    switch (LL_RCC_GetADCClockSource(LL_RCC_ADC_CLKSOURCE))
 8012f54:	f04f 5040 	mov.w	r0, #805306368	; 0x30000000
 8012f58:	f7ff fbbd 	bl	80126d6 <LL_RCC_GetADCClockSource>
 8012f5c:	4603      	mov	r3, r0
 8012f5e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8012f62:	d014      	beq.n	8012f8e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
 8012f64:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8012f68:	f200 821b 	bhi.w	80133a2 <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
 8012f6c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8012f70:	d003      	beq.n	8012f7a <HAL_RCCEx_GetPeriphCLKFreq+0x3ae>
 8012f72:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8012f76:	d00e      	beq.n	8012f96 <HAL_RCCEx_GetPeriphCLKFreq+0x3ca>
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
      
    default: /* No clock used as ADC clock source */
      break;
 8012f78:	e213      	b.n	80133a2 <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
      if (LL_RCC_PLLSAI1_IsReady() == 1U)
 8012f7a:	f7ff fc62 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8012f7e:	4603      	mov	r3, r0
 8012f80:	2b01      	cmp	r3, #1
 8012f82:	f040 8210 	bne.w	80133a6 <HAL_RCCEx_GetPeriphCLKFreq+0x7da>
        frequency = RCC_PLLSAI1_GetFreqDomain_R();
 8012f86:	f000 fbfb 	bl	8013780 <RCC_PLLSAI1_GetFreqDomain_R>
 8012f8a:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012f8c:	e20b      	b.n	80133a6 <HAL_RCCEx_GetPeriphCLKFreq+0x7da>
      frequency = HAL_RCC_GetSysClockFreq();
 8012f8e:	f7fe ff8d 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012f92:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012f94:	e20e      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      if (LL_RCC_PLL_IsReady() == 1U)
 8012f96:	f7ff fbf3 	bl	8012780 <LL_RCC_PLL_IsReady>
 8012f9a:	4603      	mov	r3, r0
 8012f9c:	2b01      	cmp	r3, #1
 8012f9e:	f040 8204 	bne.w	80133aa <HAL_RCCEx_GetPeriphCLKFreq+0x7de>
        frequency = RCC_PLL_GetFreqDomain_P();
 8012fa2:	f000 fb41 	bl	8013628 <RCC_PLL_GetFreqDomain_P>
 8012fa6:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012fa8:	e1ff      	b.n	80133aa <HAL_RCCEx_GetPeriphCLKFreq+0x7de>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_I2C1)
 8012faa:	687b      	ldr	r3, [r7, #4]
 8012fac:	2b04      	cmp	r3, #4
 8012fae:	d135      	bne.n	801301c <HAL_RCCEx_GetPeriphCLKFreq+0x450>
  {
    switch (LL_RCC_GetI2CClockSource(LL_RCC_I2C1_CLKSOURCE))
 8012fb0:	f44f 5040 	mov.w	r0, #12288	; 0x3000
 8012fb4:	f7ff fb2c 	bl	8012610 <LL_RCC_GetI2CClockSource>
 8012fb8:	4603      	mov	r3, r0
 8012fba:	4ab7      	ldr	r2, [pc, #732]	; (8013298 <HAL_RCCEx_GetPeriphCLKFreq+0x6cc>)
 8012fbc:	4293      	cmp	r3, r2
 8012fbe:	d003      	beq.n	8012fc8 <HAL_RCCEx_GetPeriphCLKFreq+0x3fc>
 8012fc0:	4ab6      	ldr	r2, [pc, #728]	; (801329c <HAL_RCCEx_GetPeriphCLKFreq+0x6d0>)
 8012fc2:	4293      	cmp	r3, r2
 8012fc4:	d004      	beq.n	8012fd0 <HAL_RCCEx_GetPeriphCLKFreq+0x404>
 8012fc6:	e00c      	b.n	8012fe2 <HAL_RCCEx_GetPeriphCLKFreq+0x416>
    {
    case LL_RCC_I2C1_CLKSOURCE_SYSCLK: /* I2C1 Clock is System Clock */
      frequency = HAL_RCC_GetSysClockFreq();
 8012fc8:	f7fe ff70 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012fcc:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8012fce:	e1f1      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      
    case LL_RCC_I2C1_CLKSOURCE_HSI:    /* I2C1 Clock is HSI Osc. */
      if (LL_RCC_HSI_IsReady() == 1U)
 8012fd0:	f7ff f910 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8012fd4:	4603      	mov	r3, r0
 8012fd6:	2b01      	cmp	r3, #1
 8012fd8:	f040 81e9 	bne.w	80133ae <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
      {
        frequency = HSI_VALUE;
 8012fdc:	4bb0      	ldr	r3, [pc, #704]	; (80132a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>)
 8012fde:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8012fe0:	e1e5      	b.n	80133ae <HAL_RCCEx_GetPeriphCLKFreq+0x7e2>
      
    default: /* I2C1 Clock is PCLK1 */
      frequency = __LL_RCC_CALC_PCLK1_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), \
 8012fe2:	f7fe ff63 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8012fe6:	4604      	mov	r4, r0
 8012fe8:	f7ff f9c8 	bl	801237c <LL_RCC_GetAHBPrescaler>
 8012fec:	4603      	mov	r3, r0
 8012fee:	091b      	lsrs	r3, r3, #4
 8012ff0:	f003 030f 	and.w	r3, r3, #15
 8012ff4:	4aab      	ldr	r2, [pc, #684]	; (80132a4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>)
 8012ff6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012ffa:	fbb4 f4f3 	udiv	r4, r4, r3
 8012ffe:	f7ff f9c9 	bl	8012394 <LL_RCC_GetAPB1Prescaler>
 8013002:	4603      	mov	r3, r0
 8013004:	0a1b      	lsrs	r3, r3, #8
 8013006:	f003 0307 	and.w	r3, r3, #7
 801300a:	4aa7      	ldr	r2, [pc, #668]	; (80132a8 <HAL_RCCEx_GetPeriphCLKFreq+0x6dc>)
 801300c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013010:	f003 031f 	and.w	r3, r3, #31
 8013014:	fa24 f303 	lsr.w	r3, r4, r3
 8013018:	647b      	str	r3, [r7, #68]	; 0x44
        LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB1Prescaler());
      break;
 801301a:	e1cb      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
#if defined(I2C3)
  else if (PeriphClk == RCC_PERIPHCLK_I2C3)
 801301c:	687b      	ldr	r3, [r7, #4]
 801301e:	2b08      	cmp	r3, #8
 8013020:	d135      	bne.n	801308e <HAL_RCCEx_GetPeriphCLKFreq+0x4c2>
  {
    switch (LL_RCC_GetI2CClockSource(LL_RCC_I2C3_CLKSOURCE))
 8013022:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8013026:	f7ff faf3 	bl	8012610 <LL_RCC_GetI2CClockSource>
 801302a:	4603      	mov	r3, r0
 801302c:	4a9f      	ldr	r2, [pc, #636]	; (80132ac <HAL_RCCEx_GetPeriphCLKFreq+0x6e0>)
 801302e:	4293      	cmp	r3, r2
 8013030:	d003      	beq.n	801303a <HAL_RCCEx_GetPeriphCLKFreq+0x46e>
 8013032:	4a9f      	ldr	r2, [pc, #636]	; (80132b0 <HAL_RCCEx_GetPeriphCLKFreq+0x6e4>)
 8013034:	4293      	cmp	r3, r2
 8013036:	d004      	beq.n	8013042 <HAL_RCCEx_GetPeriphCLKFreq+0x476>
 8013038:	e00c      	b.n	8013054 <HAL_RCCEx_GetPeriphCLKFreq+0x488>
    {
    case LL_RCC_I2C3_CLKSOURCE_SYSCLK: /* I2C3 Clock is System Clock */
      frequency = HAL_RCC_GetSysClockFreq();
 801303a:	f7fe ff37 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 801303e:	6478      	str	r0, [r7, #68]	; 0x44
      break;
 8013040:	e1b8      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      
    case LL_RCC_I2C3_CLKSOURCE_HSI: /* I2C3 Clock is HSI Osc. */
      if (LL_RCC_HSI_IsReady() == 1U)
 8013042:	f7ff f8d7 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8013046:	4603      	mov	r3, r0
 8013048:	2b01      	cmp	r3, #1
 801304a:	f040 81b2 	bne.w	80133b2 <HAL_RCCEx_GetPeriphCLKFreq+0x7e6>
      {
        frequency = HSI_VALUE;
 801304e:	4b94      	ldr	r3, [pc, #592]	; (80132a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>)
 8013050:	647b      	str	r3, [r7, #68]	; 0x44
      }
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
      break;
 8013052:	e1ae      	b.n	80133b2 <HAL_RCCEx_GetPeriphCLKFreq+0x7e6>
      
    default: /* I2C3 Clock is PCLK1 */
      frequency = __LL_RCC_CALC_PCLK1_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), \
 8013054:	f7fe ff2a 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8013058:	4604      	mov	r4, r0
 801305a:	f7ff f98f 	bl	801237c <LL_RCC_GetAHBPrescaler>
 801305e:	4603      	mov	r3, r0
 8013060:	091b      	lsrs	r3, r3, #4
 8013062:	f003 030f 	and.w	r3, r3, #15
 8013066:	4a8f      	ldr	r2, [pc, #572]	; (80132a4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>)
 8013068:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801306c:	fbb4 f4f3 	udiv	r4, r4, r3
 8013070:	f7ff f990 	bl	8012394 <LL_RCC_GetAPB1Prescaler>
 8013074:	4603      	mov	r3, r0
 8013076:	0a1b      	lsrs	r3, r3, #8
 8013078:	f003 0307 	and.w	r3, r3, #7
 801307c:	4a8a      	ldr	r2, [pc, #552]	; (80132a8 <HAL_RCCEx_GetPeriphCLKFreq+0x6dc>)
 801307e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013082:	f003 031f 	and.w	r3, r3, #31
 8013086:	fa24 f303 	lsr.w	r3, r4, r3
 801308a:	647b      	str	r3, [r7, #68]	; 0x44
        LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB1Prescaler());
      break;
 801308c:	e192      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
#endif
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM1)
 801308e:	687b      	ldr	r3, [r7, #4]
 8013090:	2b10      	cmp	r3, #16
 8013092:	d151      	bne.n	8013138 <HAL_RCCEx_GetPeriphCLKFreq+0x56c>
  {
    uint32_t lptimClockSource = LL_RCC_GetLPTIMClockSource(LL_RCC_LPTIM1_CLKSOURCE);
 8013094:	f44f 2040 	mov.w	r0, #786432	; 0xc0000
 8013098:	f7ff face 	bl	8012638 <LL_RCC_GetLPTIMClockSource>
 801309c:	62b8      	str	r0, [r7, #40]	; 0x28
    
    if (lptimClockSource == LL_RCC_LPTIM1_CLKSOURCE_LSI) /* LPTIM1 Clock is LSI Osc. */
 801309e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80130a0:	4a84      	ldr	r2, [pc, #528]	; (80132b4 <HAL_RCCEx_GetPeriphCLKFreq+0x6e8>)
 80130a2:	4293      	cmp	r3, r2
 80130a4:	d110      	bne.n	80130c8 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
    {
      const uint32_t temp_lsi1ready = LL_RCC_LSI1_IsReady();
 80130a6:	f7ff f8ed 	bl	8012284 <LL_RCC_LSI1_IsReady>
 80130aa:	6278      	str	r0, [r7, #36]	; 0x24
      const uint32_t temp_lsi2ready = LL_RCC_LSI2_IsReady();
 80130ac:	f7ff f8fc 	bl	80122a8 <LL_RCC_LSI2_IsReady>
 80130b0:	6238      	str	r0, [r7, #32]
      if ((temp_lsi1ready == 1U) || (temp_lsi2ready == 1U))
 80130b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80130b4:	2b01      	cmp	r3, #1
 80130b6:	d003      	beq.n	80130c0 <HAL_RCCEx_GetPeriphCLKFreq+0x4f4>
 80130b8:	6a3b      	ldr	r3, [r7, #32]
 80130ba:	2b01      	cmp	r3, #1
 80130bc:	f040 817a 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSI_VALUE;
 80130c0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 80130c4:	647b      	str	r3, [r7, #68]	; 0x44
 80130c6:	e175      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (lptimClockSource == LL_RCC_LPTIM1_CLKSOURCE_HSI) /* LPTIM1 Clock is HSI Osc. */
 80130c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80130ca:	4a7b      	ldr	r2, [pc, #492]	; (80132b8 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>)
 80130cc:	4293      	cmp	r3, r2
 80130ce:	d108      	bne.n	80130e2 <HAL_RCCEx_GetPeriphCLKFreq+0x516>
    {
      if (LL_RCC_HSI_IsReady() == 1U)
 80130d0:	f7ff f890 	bl	80121f4 <LL_RCC_HSI_IsReady>
 80130d4:	4603      	mov	r3, r0
 80130d6:	2b01      	cmp	r3, #1
 80130d8:	f040 816c 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = HSI_VALUE;
 80130dc:	4b70      	ldr	r3, [pc, #448]	; (80132a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>)
 80130de:	647b      	str	r3, [r7, #68]	; 0x44
 80130e0:	e168      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (lptimClockSource == LL_RCC_LPTIM1_CLKSOURCE_LSE) /* LPTIM1 Clock is LSE Osc. */
 80130e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80130e4:	f1b3 1f0c 	cmp.w	r3, #786444	; 0xc000c
 80130e8:	d109      	bne.n	80130fe <HAL_RCCEx_GetPeriphCLKFreq+0x532>
    {
      if (LL_RCC_LSE_IsReady() == 1U)
 80130ea:	f7ff f8b9 	bl	8012260 <LL_RCC_LSE_IsReady>
 80130ee:	4603      	mov	r3, r0
 80130f0:	2b01      	cmp	r3, #1
 80130f2:	f040 815f 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSE_VALUE;
 80130f6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80130fa:	647b      	str	r3, [r7, #68]	; 0x44
 80130fc:	e15a      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else /* LPTIM1 Clock is PCLK1 */
    {
      frequency = __LL_RCC_CALC_PCLK1_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB1Prescaler());
 80130fe:	f7fe fed5 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 8013102:	4604      	mov	r4, r0
 8013104:	f7ff f93a 	bl	801237c <LL_RCC_GetAHBPrescaler>
 8013108:	4603      	mov	r3, r0
 801310a:	091b      	lsrs	r3, r3, #4
 801310c:	f003 030f 	and.w	r3, r3, #15
 8013110:	4a64      	ldr	r2, [pc, #400]	; (80132a4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>)
 8013112:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013116:	fbb4 f4f3 	udiv	r4, r4, r3
 801311a:	f7ff f93b 	bl	8012394 <LL_RCC_GetAPB1Prescaler>
 801311e:	4603      	mov	r3, r0
 8013120:	0a1b      	lsrs	r3, r3, #8
 8013122:	f003 0307 	and.w	r3, r3, #7
 8013126:	4a60      	ldr	r2, [pc, #384]	; (80132a8 <HAL_RCCEx_GetPeriphCLKFreq+0x6dc>)
 8013128:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801312c:	f003 031f 	and.w	r3, r3, #31
 8013130:	fa24 f303 	lsr.w	r3, r4, r3
 8013134:	647b      	str	r3, [r7, #68]	; 0x44
 8013136:	e13d      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_LPTIM2)
 8013138:	687b      	ldr	r3, [r7, #4]
 801313a:	2b20      	cmp	r3, #32
 801313c:	d151      	bne.n	80131e2 <HAL_RCCEx_GetPeriphCLKFreq+0x616>
  {
    uint32_t lptimClockSource = LL_RCC_GetLPTIMClockSource(LL_RCC_LPTIM2_CLKSOURCE);
 801313e:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 8013142:	f7ff fa79 	bl	8012638 <LL_RCC_GetLPTIMClockSource>
 8013146:	6378      	str	r0, [r7, #52]	; 0x34
    
    if (lptimClockSource == LL_RCC_LPTIM2_CLKSOURCE_LSI) /* LPTIM2 Clock is LSI Osc. */
 8013148:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801314a:	4a5c      	ldr	r2, [pc, #368]	; (80132bc <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>)
 801314c:	4293      	cmp	r3, r2
 801314e:	d110      	bne.n	8013172 <HAL_RCCEx_GetPeriphCLKFreq+0x5a6>
    {
      const uint32_t temp_lsi1ready = LL_RCC_LSI1_IsReady();
 8013150:	f7ff f898 	bl	8012284 <LL_RCC_LSI1_IsReady>
 8013154:	6338      	str	r0, [r7, #48]	; 0x30
      const uint32_t temp_lsi2ready = LL_RCC_LSI2_IsReady();
 8013156:	f7ff f8a7 	bl	80122a8 <LL_RCC_LSI2_IsReady>
 801315a:	62f8      	str	r0, [r7, #44]	; 0x2c
      if ((temp_lsi1ready == 1U) || (temp_lsi2ready == 1U))
 801315c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801315e:	2b01      	cmp	r3, #1
 8013160:	d003      	beq.n	801316a <HAL_RCCEx_GetPeriphCLKFreq+0x59e>
 8013162:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013164:	2b01      	cmp	r3, #1
 8013166:	f040 8125 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSI_VALUE;
 801316a:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 801316e:	647b      	str	r3, [r7, #68]	; 0x44
 8013170:	e120      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (lptimClockSource == LL_RCC_LPTIM2_CLKSOURCE_HSI) /* LPTIM2 Clock is HSI Osc. */
 8013172:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013174:	4a52      	ldr	r2, [pc, #328]	; (80132c0 <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>)
 8013176:	4293      	cmp	r3, r2
 8013178:	d108      	bne.n	801318c <HAL_RCCEx_GetPeriphCLKFreq+0x5c0>
    {
      if (LL_RCC_HSI_IsReady() == 1U)
 801317a:	f7ff f83b 	bl	80121f4 <LL_RCC_HSI_IsReady>
 801317e:	4603      	mov	r3, r0
 8013180:	2b01      	cmp	r3, #1
 8013182:	f040 8117 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = HSI_VALUE;
 8013186:	4b46      	ldr	r3, [pc, #280]	; (80132a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>)
 8013188:	647b      	str	r3, [r7, #68]	; 0x44
 801318a:	e113      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (lptimClockSource == LL_RCC_LPTIM2_CLKSOURCE_LSE) /* LPTIM2 Clock is LSE Osc. */
 801318c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801318e:	f1b3 1f30 	cmp.w	r3, #3145776	; 0x300030
 8013192:	d109      	bne.n	80131a8 <HAL_RCCEx_GetPeriphCLKFreq+0x5dc>
    {
      if (LL_RCC_LSE_IsReady() == 1U)
 8013194:	f7ff f864 	bl	8012260 <LL_RCC_LSE_IsReady>
 8013198:	4603      	mov	r3, r0
 801319a:	2b01      	cmp	r3, #1
 801319c:	f040 810a 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSE_VALUE;
 80131a0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80131a4:	647b      	str	r3, [r7, #68]	; 0x44
 80131a6:	e105      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else /* LPTIM2 Clock is PCLK1 */
    {
      frequency = __LL_RCC_CALC_PCLK1_FREQ(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler()), LL_RCC_GetAPB1Prescaler());
 80131a8:	f7fe fe80 	bl	8011eac <HAL_RCC_GetSysClockFreq>
 80131ac:	4604      	mov	r4, r0
 80131ae:	f7ff f8e5 	bl	801237c <LL_RCC_GetAHBPrescaler>
 80131b2:	4603      	mov	r3, r0
 80131b4:	091b      	lsrs	r3, r3, #4
 80131b6:	f003 030f 	and.w	r3, r3, #15
 80131ba:	4a3a      	ldr	r2, [pc, #232]	; (80132a4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>)
 80131bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80131c0:	fbb4 f4f3 	udiv	r4, r4, r3
 80131c4:	f7ff f8e6 	bl	8012394 <LL_RCC_GetAPB1Prescaler>
 80131c8:	4603      	mov	r3, r0
 80131ca:	0a1b      	lsrs	r3, r3, #8
 80131cc:	f003 0307 	and.w	r3, r3, #7
 80131d0:	4a35      	ldr	r2, [pc, #212]	; (80132a8 <HAL_RCCEx_GetPeriphCLKFreq+0x6dc>)
 80131d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80131d6:	f003 031f 	and.w	r3, r3, #31
 80131da:	fa24 f303 	lsr.w	r3, r4, r3
 80131de:	647b      	str	r3, [r7, #68]	; 0x44
 80131e0:	e0e8      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_RFWAKEUP)
 80131e2:	687b      	ldr	r3, [r7, #4]
 80131e4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80131e8:	d119      	bne.n	801321e <HAL_RCCEx_GetPeriphCLKFreq+0x652>
  {
    uint32_t rfwkpClockSource = LL_RCC_GetRFWKPClockSource();
 80131ea:	f7ff f8ba 	bl	8012362 <LL_RCC_GetRFWKPClockSource>
 80131ee:	63b8      	str	r0, [r7, #56]	; 0x38
    
    if (rfwkpClockSource == LL_RCC_RFWKP_CLKSOURCE_LSE) /* LSE clock used as RF Wakeup clock source */
 80131f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80131f2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80131f6:	d109      	bne.n	801320c <HAL_RCCEx_GetPeriphCLKFreq+0x640>
    {
      if (LL_RCC_LSE_IsReady() == 1U)
 80131f8:	f7ff f832 	bl	8012260 <LL_RCC_LSE_IsReady>
 80131fc:	4603      	mov	r3, r0
 80131fe:	2b01      	cmp	r3, #1
 8013200:	f040 80d8 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = LSE_VALUE;
 8013204:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8013208:	647b      	str	r3, [r7, #68]	; 0x44
 801320a:	e0d3      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (rfwkpClockSource == LL_RCC_RFWKP_CLKSOURCE_HSE_DIV1024) /* HSE clock used as RF Wakeup clock source */
 801320c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801320e:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8013212:	f040 80cf 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    {
      frequency = HSE_VALUE / 1024U;
 8013216:	f647 2312 	movw	r3, #31250	; 0x7a12
 801321a:	647b      	str	r3, [r7, #68]	; 0x44
 801321c:	e0ca      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    {
      /* Nothing to do as frequency already initialized to 0U */
    }
  }
#if defined(RCC_SMPS_SUPPORT)
  else if (PeriphClk == RCC_PERIPHCLK_SMPS)
 801321e:	687b      	ldr	r3, [r7, #4]
 8013220:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013224:	f040 80c6 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
  {
    uint32_t smpsClockSource = LL_RCC_GetSMPSClockSource();
 8013228:	f7ff f8e0 	bl	80123ec <LL_RCC_GetSMPSClockSource>
 801322c:	63f8      	str	r0, [r7, #60]	; 0x3c
    
    if (smpsClockSource == LL_RCC_SMPS_CLKSOURCE_STATUS_HSI) /* SMPS Clock source is HSI Osc. */
 801322e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013230:	2b00      	cmp	r3, #0
 8013232:	d115      	bne.n	8013260 <HAL_RCCEx_GetPeriphCLKFreq+0x694>
    {
      if (LL_RCC_HSI_IsReady() == 1U)
 8013234:	f7fe ffde 	bl	80121f4 <LL_RCC_HSI_IsReady>
 8013238:	4603      	mov	r3, r0
 801323a:	2b01      	cmp	r3, #1
 801323c:	f040 80ba 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = HSI_VALUE / SmpsPrescalerTable[smps_prescaler_index][0];
 8013240:	4920      	ldr	r1, [pc, #128]	; (80132c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>)
 8013242:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013244:	4613      	mov	r3, r2
 8013246:	005b      	lsls	r3, r3, #1
 8013248:	4413      	add	r3, r2
 801324a:	00db      	lsls	r3, r3, #3
 801324c:	440b      	add	r3, r1
 801324e:	681b      	ldr	r3, [r3, #0]
 8013250:	4a13      	ldr	r2, [pc, #76]	; (80132a0 <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>)
 8013252:	fbb2 f3f3 	udiv	r3, r2, r3
 8013256:	647b      	str	r3, [r7, #68]	; 0x44
        frequency = frequency >> 1U; /* Systematic Div by 2 */
 8013258:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801325a:	085b      	lsrs	r3, r3, #1
 801325c:	647b      	str	r3, [r7, #68]	; 0x44
 801325e:	e0a9      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (smpsClockSource == LL_RCC_SMPS_CLKSOURCE_STATUS_HSE) /* SMPS Clock source is HSE Osc. */
 8013260:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013262:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8013266:	d131      	bne.n	80132cc <HAL_RCCEx_GetPeriphCLKFreq+0x700>
    {
      if (LL_RCC_HSE_IsReady() == 1U)
 8013268:	f7fe ffb2 	bl	80121d0 <LL_RCC_HSE_IsReady>
 801326c:	4603      	mov	r3, r0
 801326e:	2b01      	cmp	r3, #1
 8013270:	f040 80a0 	bne.w	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      {
        frequency = HSE_VALUE / SmpsPrescalerTable[smps_prescaler_index][5];
 8013274:	4913      	ldr	r1, [pc, #76]	; (80132c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>)
 8013276:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013278:	4613      	mov	r3, r2
 801327a:	005b      	lsls	r3, r3, #1
 801327c:	4413      	add	r3, r2
 801327e:	00db      	lsls	r3, r3, #3
 8013280:	440b      	add	r3, r1
 8013282:	3314      	adds	r3, #20
 8013284:	681b      	ldr	r3, [r3, #0]
 8013286:	4a10      	ldr	r2, [pc, #64]	; (80132c8 <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>)
 8013288:	fbb2 f3f3 	udiv	r3, r2, r3
 801328c:	647b      	str	r3, [r7, #68]	; 0x44
        frequency = frequency >> 1U; /* Systematic Div by 2 */
 801328e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013290:	085b      	lsrs	r3, r3, #1
 8013292:	647b      	str	r3, [r7, #68]	; 0x44
 8013294:	e08e      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
 8013296:	bf00      	nop
 8013298:	00030100 	.word	0x00030100
 801329c:	00030200 	.word	0x00030200
 80132a0:	00f42400 	.word	0x00f42400
 80132a4:	0802ca2c 	.word	0x0802ca2c
 80132a8:	0802ca6c 	.word	0x0802ca6c
 80132ac:	00301000 	.word	0x00301000
 80132b0:	00302000 	.word	0x00302000
 80132b4:	000c0004 	.word	0x000c0004
 80132b8:	000c0008 	.word	0x000c0008
 80132bc:	00300010 	.word	0x00300010
 80132c0:	00300020 	.word	0x00300020
 80132c4:	0802cacc 	.word	0x0802cacc
 80132c8:	01e84800 	.word	0x01e84800
      else
      {
        /* Nothing to do as frequency already initialized to 0U */
      }
    }
    else if (smpsClockSource == LL_RCC_SMPS_CLKSOURCE_STATUS_MSI) /* SMPS Clock source is MSI Osc. */
 80132cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80132ce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80132d2:	d16f      	bne.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
    {
      switch (LL_RCC_MSI_GetRange())
 80132d4:	f7ff f81a 	bl	801230c <LL_RCC_MSI_GetRange>
 80132d8:	4603      	mov	r3, r0
 80132da:	2bb0      	cmp	r3, #176	; 0xb0
 80132dc:	d037      	beq.n	801334e <HAL_RCCEx_GetPeriphCLKFreq+0x782>
 80132de:	2bb0      	cmp	r3, #176	; 0xb0
 80132e0:	d844      	bhi.n	801336c <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>
 80132e2:	2ba0      	cmp	r3, #160	; 0xa0
 80132e4:	d024      	beq.n	8013330 <HAL_RCCEx_GetPeriphCLKFreq+0x764>
 80132e6:	2ba0      	cmp	r3, #160	; 0xa0
 80132e8:	d840      	bhi.n	801336c <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>
 80132ea:	2b80      	cmp	r3, #128	; 0x80
 80132ec:	d002      	beq.n	80132f4 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
 80132ee:	2b90      	cmp	r3, #144	; 0x90
 80132f0:	d00f      	beq.n	8013312 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
        break;
      case LL_RCC_MSIRANGE_11:
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGE_11) / SmpsPrescalerTable[smps_prescaler_index][1];
        break;
      default:
        break;
 80132f2:	e03b      	b.n	801336c <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGE_8) / SmpsPrescalerTable[smps_prescaler_index][4];
 80132f4:	4b32      	ldr	r3, [pc, #200]	; (80133c0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>)
 80132f6:	6a19      	ldr	r1, [r3, #32]
 80132f8:	4832      	ldr	r0, [pc, #200]	; (80133c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>)
 80132fa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80132fc:	4613      	mov	r3, r2
 80132fe:	005b      	lsls	r3, r3, #1
 8013300:	4413      	add	r3, r2
 8013302:	00db      	lsls	r3, r3, #3
 8013304:	4403      	add	r3, r0
 8013306:	3310      	adds	r3, #16
 8013308:	681b      	ldr	r3, [r3, #0]
 801330a:	fbb1 f3f3 	udiv	r3, r1, r3
 801330e:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8013310:	e02d      	b.n	801336e <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGE_9) / SmpsPrescalerTable[smps_prescaler_index][3];
 8013312:	4b2b      	ldr	r3, [pc, #172]	; (80133c0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>)
 8013314:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8013316:	482b      	ldr	r0, [pc, #172]	; (80133c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>)
 8013318:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801331a:	4613      	mov	r3, r2
 801331c:	005b      	lsls	r3, r3, #1
 801331e:	4413      	add	r3, r2
 8013320:	00db      	lsls	r3, r3, #3
 8013322:	4403      	add	r3, r0
 8013324:	330c      	adds	r3, #12
 8013326:	681b      	ldr	r3, [r3, #0]
 8013328:	fbb1 f3f3 	udiv	r3, r1, r3
 801332c:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 801332e:	e01e      	b.n	801336e <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGE_10) / SmpsPrescalerTable[smps_prescaler_index][2];
 8013330:	4b23      	ldr	r3, [pc, #140]	; (80133c0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>)
 8013332:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8013334:	4823      	ldr	r0, [pc, #140]	; (80133c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>)
 8013336:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013338:	4613      	mov	r3, r2
 801333a:	005b      	lsls	r3, r3, #1
 801333c:	4413      	add	r3, r2
 801333e:	00db      	lsls	r3, r3, #3
 8013340:	4403      	add	r3, r0
 8013342:	3308      	adds	r3, #8
 8013344:	681b      	ldr	r3, [r3, #0]
 8013346:	fbb1 f3f3 	udiv	r3, r1, r3
 801334a:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 801334c:	e00f      	b.n	801336e <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
        frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGE_11) / SmpsPrescalerTable[smps_prescaler_index][1];
 801334e:	4b1c      	ldr	r3, [pc, #112]	; (80133c0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>)
 8013350:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8013352:	481c      	ldr	r0, [pc, #112]	; (80133c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f8>)
 8013354:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013356:	4613      	mov	r3, r2
 8013358:	005b      	lsls	r3, r3, #1
 801335a:	4413      	add	r3, r2
 801335c:	00db      	lsls	r3, r3, #3
 801335e:	4403      	add	r3, r0
 8013360:	3304      	adds	r3, #4
 8013362:	681b      	ldr	r3, [r3, #0]
 8013364:	fbb1 f3f3 	udiv	r3, r1, r3
 8013368:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 801336a:	e000      	b.n	801336e <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
        break;
 801336c:	bf00      	nop
      }
      frequency = frequency >> 1U; /* Systematic Div by 2 */
 801336e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013370:	085b      	lsrs	r3, r3, #1
 8013372:	647b      	str	r3, [r7, #68]	; 0x44
 8013374:	e01e      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 8013376:	bf00      	nop
 8013378:	e01c      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801337a:	bf00      	nop
 801337c:	e01a      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801337e:	bf00      	nop
 8013380:	e018      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 8013382:	bf00      	nop
 8013384:	e016      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 8013386:	bf00      	nop
 8013388:	e014      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801338a:	bf00      	nop
 801338c:	e012      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801338e:	bf00      	nop
 8013390:	e010      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 8013392:	bf00      	nop
 8013394:	e00e      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 8013396:	bf00      	nop
 8013398:	e00c      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801339a:	bf00      	nop
 801339c:	e00a      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 801339e:	bf00      	nop
 80133a0:	e008      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 80133a2:	bf00      	nop
 80133a4:	e006      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 80133a6:	bf00      	nop
 80133a8:	e004      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 80133aa:	bf00      	nop
 80133ac:	e002      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 80133ae:	bf00      	nop
 80133b0:	e000      	b.n	80133b4 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
      break;
 80133b2:	bf00      	nop
    {
      /* Nothing to do as frequency already initialized to 0U */
    }
  }
#endif
  return (frequency);
 80133b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 80133b6:	4618      	mov	r0, r3
 80133b8:	374c      	adds	r7, #76	; 0x4c
 80133ba:	46bd      	mov	sp, r7
 80133bc:	bd90      	pop	{r4, r7, pc}
 80133be:	bf00      	nop
 80133c0:	0802ca8c 	.word	0x0802ca8c
 80133c4:	0802cacc 	.word	0x0802cacc

080133c8 <HAL_RCCEx_GetRngCLKSource>:
  *
  *         (*) Value not defined in all devices.
  *
  */
uint32_t HAL_RCCEx_GetRngCLKSource(void)
{
 80133c8:	b580      	push	{r7, lr}
 80133ca:	b082      	sub	sp, #8
 80133cc:	af00      	add	r7, sp, #0
  uint32_t rng_clock_source = LL_RCC_GetRNGClockSource(LL_RCC_RNG_CLKSOURCE);
 80133ce:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
 80133d2:	f7ff f954 	bl	801267e <LL_RCC_GetRNGClockSource>
 80133d6:	6078      	str	r0, [r7, #4]
  uint32_t clk48_clock_source;

  /* RNG clock source originates from 48 MHz RC oscillator */
  if (rng_clock_source == RCC_RNGCLKSOURCE_CLK48)
 80133d8:	687b      	ldr	r3, [r7, #4]
 80133da:	2b00      	cmp	r3, #0
 80133dc:	d108      	bne.n	80133f0 <HAL_RCCEx_GetRngCLKSource+0x28>
  {
    clk48_clock_source = LL_RCC_GetCLK48ClockSource(LL_RCC_CLK48_CLKSOURCE);
 80133de:	f04f 6040 	mov.w	r0, #201326592	; 0xc000000
 80133e2:	f7ff f95c 	bl	801269e <LL_RCC_GetCLK48ClockSource>
 80133e6:	6038      	str	r0, [r7, #0]
    rng_clock_source = (CLK48_MASK | clk48_clock_source);
 80133e8:	683b      	ldr	r3, [r7, #0]
 80133ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80133ee:	607b      	str	r3, [r7, #4]
  }

  return rng_clock_source;
 80133f0:	687b      	ldr	r3, [r7, #4]
}
 80133f2:	4618      	mov	r0, r3
 80133f4:	3708      	adds	r7, #8
 80133f6:	46bd      	mov	sp, r7
 80133f8:	bd80      	pop	{r7, pc}

080133fa <HAL_RCCEx_EnableMSIPLLMode>:
  * @note   Prior to enable the PLL-mode of the MSI for automatic hardware
  *         calibration LSE oscillator is to be enabled with @ref HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
 80133fa:	b580      	push	{r7, lr}
 80133fc:	af00      	add	r7, sp, #0
  LL_RCC_MSI_EnablePLLMode() ;
 80133fe:	f7fe ff76 	bl	80122ee <LL_RCC_MSI_EnablePLLMode>
}
 8013402:	bf00      	nop
 8013404:	bd80      	pop	{r7, pc}

08013406 <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8013406:	b580      	push	{r7, lr}
 8013408:	b084      	sub	sp, #16
 801340a:	af00      	add	r7, sp, #0
 801340c:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 801340e:	2300      	movs	r3, #0
 8013410:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLSAI1->PLLP));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8013412:	f7ff fa07 	bl	8012824 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8013416:	f7f9 fb37 	bl	800ca88 <HAL_GetTick>
 801341a:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 801341c:	e009      	b.n	8013432 <RCCEx_PLLSAI1_ConfigNP+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801341e:	f7f9 fb33 	bl	800ca88 <HAL_GetTick>
 8013422:	4602      	mov	r2, r0
 8013424:	68bb      	ldr	r3, [r7, #8]
 8013426:	1ad3      	subs	r3, r2, r3
 8013428:	2b02      	cmp	r3, #2
 801342a:	d902      	bls.n	8013432 <RCCEx_PLLSAI1_ConfigNP+0x2c>
    {
      status = HAL_TIMEOUT;
 801342c:	2303      	movs	r3, #3
 801342e:	73fb      	strb	r3, [r7, #15]
      break;
 8013430:	e004      	b.n	801343c <RCCEx_PLLSAI1_ConfigNP+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8013432:	f7ff fa06 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8013436:	4603      	mov	r3, r0
 8013438:	2b00      	cmp	r3, #0
 801343a:	d1f0      	bne.n	801341e <RCCEx_PLLSAI1_ConfigNP+0x18>
    }
  }

  if (status == HAL_OK)
 801343c:	7bfb      	ldrb	r3, [r7, #15]
 801343e:	2b00      	cmp	r3, #0
 8013440:	d137      	bne.n	80134b2 <RCCEx_PLLSAI1_ConfigNP+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8013442:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8013446:	691b      	ldr	r3, [r3, #16]
 8013448:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 801344c:	687b      	ldr	r3, [r7, #4]
 801344e:	681b      	ldr	r3, [r3, #0]
 8013450:	021b      	lsls	r3, r3, #8
 8013452:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8013456:	4313      	orrs	r3, r2
 8013458:	610b      	str	r3, [r1, #16]

    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PLLSAI1->PLLP);
 801345a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801345e:	691b      	ldr	r3, [r3, #16]
 8013460:	f423 1278 	bic.w	r2, r3, #4063232	; 0x3e0000
 8013464:	687b      	ldr	r3, [r7, #4]
 8013466:	685b      	ldr	r3, [r3, #4]
 8013468:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801346c:	4313      	orrs	r3, r2
 801346e:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8013470:	f7ff f9c9 	bl	8012806 <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8013474:	f7f9 fb08 	bl	800ca88 <HAL_GetTick>
 8013478:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 801347a:	e009      	b.n	8013490 <RCCEx_PLLSAI1_ConfigNP+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801347c:	f7f9 fb04 	bl	800ca88 <HAL_GetTick>
 8013480:	4602      	mov	r2, r0
 8013482:	68bb      	ldr	r3, [r7, #8]
 8013484:	1ad3      	subs	r3, r2, r3
 8013486:	2b02      	cmp	r3, #2
 8013488:	d902      	bls.n	8013490 <RCCEx_PLLSAI1_ConfigNP+0x8a>
      {
        status = HAL_TIMEOUT;
 801348a:	2303      	movs	r3, #3
 801348c:	73fb      	strb	r3, [r7, #15]
        break;
 801348e:	e004      	b.n	801349a <RCCEx_PLLSAI1_ConfigNP+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8013490:	f7ff f9d7 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8013494:	4603      	mov	r3, r0
 8013496:	2b01      	cmp	r3, #1
 8013498:	d1f0      	bne.n	801347c <RCCEx_PLLSAI1_ConfigNP+0x76>
      }
    }

    if (status == HAL_OK)
 801349a:	7bfb      	ldrb	r3, [r7, #15]
 801349c:	2b00      	cmp	r3, #0
 801349e:	d108      	bne.n	80134b2 <RCCEx_PLLSAI1_ConfigNP+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80134a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80134a4:	691a      	ldr	r2, [r3, #16]
 80134a6:	687b      	ldr	r3, [r7, #4]
 80134a8:	691b      	ldr	r3, [r3, #16]
 80134aa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80134ae:	4313      	orrs	r3, r2
 80134b0:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 80134b2:	7bfb      	ldrb	r3, [r7, #15]
}
 80134b4:	4618      	mov	r0, r3
 80134b6:	3710      	adds	r7, #16
 80134b8:	46bd      	mov	sp, r7
 80134ba:	bd80      	pop	{r7, pc}

080134bc <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 80134bc:	b580      	push	{r7, lr}
 80134be:	b084      	sub	sp, #16
 80134c0:	af00      	add	r7, sp, #0
 80134c2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80134c4:	2300      	movs	r3, #0
 80134c6:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLQ_VALUE(PLLSAI1->PLLQ));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 80134c8:	f7ff f9ac 	bl	8012824 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80134cc:	f7f9 fadc 	bl	800ca88 <HAL_GetTick>
 80134d0:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80134d2:	e009      	b.n	80134e8 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80134d4:	f7f9 fad8 	bl	800ca88 <HAL_GetTick>
 80134d8:	4602      	mov	r2, r0
 80134da:	68bb      	ldr	r3, [r7, #8]
 80134dc:	1ad3      	subs	r3, r2, r3
 80134de:	2b02      	cmp	r3, #2
 80134e0:	d902      	bls.n	80134e8 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
    {
      status = HAL_TIMEOUT;
 80134e2:	2303      	movs	r3, #3
 80134e4:	73fb      	strb	r3, [r7, #15]
      break;
 80134e6:	e004      	b.n	80134f2 <RCCEx_PLLSAI1_ConfigNQ+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80134e8:	f7ff f9ab 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 80134ec:	4603      	mov	r3, r0
 80134ee:	2b00      	cmp	r3, #0
 80134f0:	d1f0      	bne.n	80134d4 <RCCEx_PLLSAI1_ConfigNQ+0x18>
    }
  }

  if (status == HAL_OK)
 80134f2:	7bfb      	ldrb	r3, [r7, #15]
 80134f4:	2b00      	cmp	r3, #0
 80134f6:	d137      	bne.n	8013568 <RCCEx_PLLSAI1_ConfigNQ+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80134f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80134fc:	691b      	ldr	r3, [r3, #16]
 80134fe:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 8013502:	687b      	ldr	r3, [r7, #4]
 8013504:	681b      	ldr	r3, [r3, #0]
 8013506:	021b      	lsls	r3, r3, #8
 8013508:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801350c:	4313      	orrs	r3, r2
 801350e:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PLLSAI1->PLLQ);
 8013510:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8013514:	691b      	ldr	r3, [r3, #16]
 8013516:	f023 6260 	bic.w	r2, r3, #234881024	; 0xe000000
 801351a:	687b      	ldr	r3, [r7, #4]
 801351c:	689b      	ldr	r3, [r3, #8]
 801351e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8013522:	4313      	orrs	r3, r2
 8013524:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8013526:	f7ff f96e 	bl	8012806 <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 801352a:	f7f9 faad 	bl	800ca88 <HAL_GetTick>
 801352e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8013530:	e009      	b.n	8013546 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8013532:	f7f9 faa9 	bl	800ca88 <HAL_GetTick>
 8013536:	4602      	mov	r2, r0
 8013538:	68bb      	ldr	r3, [r7, #8]
 801353a:	1ad3      	subs	r3, r2, r3
 801353c:	2b02      	cmp	r3, #2
 801353e:	d902      	bls.n	8013546 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
      {
        status = HAL_TIMEOUT;
 8013540:	2303      	movs	r3, #3
 8013542:	73fb      	strb	r3, [r7, #15]
        break;
 8013544:	e004      	b.n	8013550 <RCCEx_PLLSAI1_ConfigNQ+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8013546:	f7ff f97c 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 801354a:	4603      	mov	r3, r0
 801354c:	2b01      	cmp	r3, #1
 801354e:	d1f0      	bne.n	8013532 <RCCEx_PLLSAI1_ConfigNQ+0x76>
      }
    }

    if (status == HAL_OK)
 8013550:	7bfb      	ldrb	r3, [r7, #15]
 8013552:	2b00      	cmp	r3, #0
 8013554:	d108      	bne.n	8013568 <RCCEx_PLLSAI1_ConfigNQ+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 8013556:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801355a:	691a      	ldr	r2, [r3, #16]
 801355c:	687b      	ldr	r3, [r7, #4]
 801355e:	691b      	ldr	r3, [r3, #16]
 8013560:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8013564:	4313      	orrs	r3, r2
 8013566:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 8013568:	7bfb      	ldrb	r3, [r7, #15]
}
 801356a:	4618      	mov	r0, r3
 801356c:	3710      	adds	r7, #16
 801356e:	46bd      	mov	sp, r7
 8013570:	bd80      	pop	{r7, pc}

08013572 <RCCEx_PLLSAI1_ConfigNR>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNR(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8013572:	b580      	push	{r7, lr}
 8013574:	b084      	sub	sp, #16
 8013576:	af00      	add	r7, sp, #0
 8013578:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 801357a:	2300      	movs	r3, #0
 801357c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLR_VALUE(PLLSAI1->PLLR));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 801357e:	f7ff f951 	bl	8012824 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8013582:	f7f9 fa81 	bl	800ca88 <HAL_GetTick>
 8013586:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8013588:	e009      	b.n	801359e <RCCEx_PLLSAI1_ConfigNR+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801358a:	f7f9 fa7d 	bl	800ca88 <HAL_GetTick>
 801358e:	4602      	mov	r2, r0
 8013590:	68bb      	ldr	r3, [r7, #8]
 8013592:	1ad3      	subs	r3, r2, r3
 8013594:	2b02      	cmp	r3, #2
 8013596:	d902      	bls.n	801359e <RCCEx_PLLSAI1_ConfigNR+0x2c>
    {
      status = HAL_TIMEOUT;
 8013598:	2303      	movs	r3, #3
 801359a:	73fb      	strb	r3, [r7, #15]
      break;
 801359c:	e004      	b.n	80135a8 <RCCEx_PLLSAI1_ConfigNR+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 801359e:	f7ff f950 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 80135a2:	4603      	mov	r3, r0
 80135a4:	2b00      	cmp	r3, #0
 80135a6:	d1f0      	bne.n	801358a <RCCEx_PLLSAI1_ConfigNR+0x18>
    }
  }

  if (status == HAL_OK)
 80135a8:	7bfb      	ldrb	r3, [r7, #15]
 80135aa:	2b00      	cmp	r3, #0
 80135ac:	d137      	bne.n	801361e <RCCEx_PLLSAI1_ConfigNR+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80135ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80135b2:	691b      	ldr	r3, [r3, #16]
 80135b4:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 80135b8:	687b      	ldr	r3, [r7, #4]
 80135ba:	681b      	ldr	r3, [r3, #0]
 80135bc:	021b      	lsls	r3, r3, #8
 80135be:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80135c2:	4313      	orrs	r3, r2
 80135c4:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PLLSAI1->PLLR);
 80135c6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80135ca:	691b      	ldr	r3, [r3, #16]
 80135cc:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 80135d0:	687b      	ldr	r3, [r7, #4]
 80135d2:	68db      	ldr	r3, [r3, #12]
 80135d4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80135d8:	4313      	orrs	r3, r2
 80135da:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 80135dc:	f7ff f913 	bl	8012806 <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80135e0:	f7f9 fa52 	bl	800ca88 <HAL_GetTick>
 80135e4:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80135e6:	e009      	b.n	80135fc <RCCEx_PLLSAI1_ConfigNR+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80135e8:	f7f9 fa4e 	bl	800ca88 <HAL_GetTick>
 80135ec:	4602      	mov	r2, r0
 80135ee:	68bb      	ldr	r3, [r7, #8]
 80135f0:	1ad3      	subs	r3, r2, r3
 80135f2:	2b02      	cmp	r3, #2
 80135f4:	d902      	bls.n	80135fc <RCCEx_PLLSAI1_ConfigNR+0x8a>
      {
        status = HAL_TIMEOUT;
 80135f6:	2303      	movs	r3, #3
 80135f8:	73fb      	strb	r3, [r7, #15]
        break;
 80135fa:	e004      	b.n	8013606 <RCCEx_PLLSAI1_ConfigNR+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80135fc:	f7ff f921 	bl	8012842 <LL_RCC_PLLSAI1_IsReady>
 8013600:	4603      	mov	r3, r0
 8013602:	2b01      	cmp	r3, #1
 8013604:	d1f0      	bne.n	80135e8 <RCCEx_PLLSAI1_ConfigNR+0x76>
      }
    }

    if (status == HAL_OK)
 8013606:	7bfb      	ldrb	r3, [r7, #15]
 8013608:	2b00      	cmp	r3, #0
 801360a:	d108      	bne.n	801361e <RCCEx_PLLSAI1_ConfigNR+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 801360c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8013610:	691a      	ldr	r2, [r3, #16]
 8013612:	687b      	ldr	r3, [r7, #4]
 8013614:	691b      	ldr	r3, [r3, #16]
 8013616:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801361a:	4313      	orrs	r3, r2
 801361c:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 801361e:	7bfb      	ldrb	r3, [r7, #15]
}
 8013620:	4618      	mov	r0, r3
 8013622:	3710      	adds	r7, #16
 8013624:	46bd      	mov	sp, r7
 8013626:	bd80      	pop	{r7, pc}

08013628 <RCC_PLL_GetFreqDomain_P>:
/**
  * @brief  Return PLL clock (PLLPCLK) frequency used for SAI domain
  * @retval PLLPCLK clock frequency (in Hz)
  */
static uint32_t RCC_PLL_GetFreqDomain_P(void)
{
 8013628:	b590      	push	{r4, r7, lr}
 801362a:	b083      	sub	sp, #12
 801362c:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq, pllsource;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI Value / PLLM) * PLLN
     SAI Domain clock = PLL_VCO / PLLP
  */
  pllsource = LL_RCC_PLL_GetMainSource();
 801362e:	f7ff f94b 	bl	80128c8 <LL_RCC_PLL_GetMainSource>
 8013632:	6038      	str	r0, [r7, #0]

  switch (pllsource)
 8013634:	683b      	ldr	r3, [r7, #0]
 8013636:	2b03      	cmp	r3, #3
 8013638:	d017      	beq.n	801366a <RCC_PLL_GetFreqDomain_P+0x42>
 801363a:	683b      	ldr	r3, [r7, #0]
 801363c:	2b03      	cmp	r3, #3
 801363e:	d81f      	bhi.n	8013680 <RCC_PLL_GetFreqDomain_P+0x58>
 8013640:	683b      	ldr	r3, [r7, #0]
 8013642:	2b01      	cmp	r3, #1
 8013644:	d003      	beq.n	801364e <RCC_PLL_GetFreqDomain_P+0x26>
 8013646:	683b      	ldr	r3, [r7, #0]
 8013648:	2b02      	cmp	r3, #2
 801364a:	d00b      	beq.n	8013664 <RCC_PLL_GetFreqDomain_P+0x3c>
 801364c:	e018      	b.n	8013680 <RCC_PLL_GetFreqDomain_P+0x58>
  {
    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 801364e:	f7fe fe5d 	bl	801230c <LL_RCC_MSI_GetRange>
 8013652:	4603      	mov	r3, r0
 8013654:	091b      	lsrs	r3, r3, #4
 8013656:	f003 030f 	and.w	r3, r3, #15
 801365a:	4a1b      	ldr	r2, [pc, #108]	; (80136c8 <RCC_PLL_GetFreqDomain_P+0xa0>)
 801365c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013660:	607b      	str	r3, [r7, #4]
      break;
 8013662:	e018      	b.n	8013696 <RCC_PLL_GetFreqDomain_P+0x6e>

    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 8013664:	4b19      	ldr	r3, [pc, #100]	; (80136cc <RCC_PLL_GetFreqDomain_P+0xa4>)
 8013666:	607b      	str	r3, [r7, #4]
      break;
 8013668:	e015      	b.n	8013696 <RCC_PLL_GetFreqDomain_P+0x6e>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 801366a:	f7fe fd9f 	bl	80121ac <LL_RCC_HSE_IsEnabledDiv2>
 801366e:	4603      	mov	r3, r0
 8013670:	2b01      	cmp	r3, #1
 8013672:	d102      	bne.n	801367a <RCC_PLL_GetFreqDomain_P+0x52>
      {
        pllinputfreq = HSE_VALUE / 2U;
 8013674:	4b15      	ldr	r3, [pc, #84]	; (80136cc <RCC_PLL_GetFreqDomain_P+0xa4>)
 8013676:	607b      	str	r3, [r7, #4]
      }
      else
      {
        pllinputfreq = HSE_VALUE;
      }
      break;
 8013678:	e00d      	b.n	8013696 <RCC_PLL_GetFreqDomain_P+0x6e>
        pllinputfreq = HSE_VALUE;
 801367a:	4b15      	ldr	r3, [pc, #84]	; (80136d0 <RCC_PLL_GetFreqDomain_P+0xa8>)
 801367c:	607b      	str	r3, [r7, #4]
      break;
 801367e:	e00a      	b.n	8013696 <RCC_PLL_GetFreqDomain_P+0x6e>

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8013680:	f7fe fe44 	bl	801230c <LL_RCC_MSI_GetRange>
 8013684:	4603      	mov	r3, r0
 8013686:	091b      	lsrs	r3, r3, #4
 8013688:	f003 030f 	and.w	r3, r3, #15
 801368c:	4a0e      	ldr	r2, [pc, #56]	; (80136c8 <RCC_PLL_GetFreqDomain_P+0xa0>)
 801368e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013692:	607b      	str	r3, [r7, #4]
      break;
 8013694:	bf00      	nop
  }
  return __LL_RCC_CALC_PLLCLK_ADC_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8013696:	f7ff f885 	bl	80127a4 <LL_RCC_PLL_GetN>
 801369a:	4602      	mov	r2, r0
 801369c:	687b      	ldr	r3, [r7, #4]
 801369e:	fb03 f402 	mul.w	r4, r3, r2
 80136a2:	f7ff f8a4 	bl	80127ee <LL_RCC_PLL_GetDivider>
 80136a6:	4603      	mov	r3, r0
 80136a8:	091b      	lsrs	r3, r3, #4
 80136aa:	3301      	adds	r3, #1
 80136ac:	fbb4 f4f3 	udiv	r4, r4, r3
 80136b0:	f7ff f885 	bl	80127be <LL_RCC_PLL_GetP>
 80136b4:	4603      	mov	r3, r0
 80136b6:	0c5b      	lsrs	r3, r3, #17
 80136b8:	3301      	adds	r3, #1
 80136ba:	fbb4 f3f3 	udiv	r3, r4, r3
                                       LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());
}
 80136be:	4618      	mov	r0, r3
 80136c0:	370c      	adds	r7, #12
 80136c2:	46bd      	mov	sp, r7
 80136c4:	bd90      	pop	{r4, r7, pc}
 80136c6:	bf00      	nop
 80136c8:	0802ca8c 	.word	0x0802ca8c
 80136cc:	00f42400 	.word	0x00f42400
 80136d0:	01e84800 	.word	0x01e84800

080136d4 <RCC_PLL_GetFreqDomain_Q>:
/**
  * @brief  Return PLL clock (PLLQCLK) frequency used for 48 MHz domain
  * @retval PLLQCLK clock frequency (in Hz)
  */
static uint32_t RCC_PLL_GetFreqDomain_Q(void)
{
 80136d4:	b590      	push	{r4, r7, lr}
 80136d6:	b083      	sub	sp, #12
 80136d8:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq, pllsource;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI Value/ PLLM) * PLLN
     48M Domain clock = PLL_VCO / PLLQ
  */
  pllsource = LL_RCC_PLL_GetMainSource();
 80136da:	f7ff f8f5 	bl	80128c8 <LL_RCC_PLL_GetMainSource>
 80136de:	6038      	str	r0, [r7, #0]

  switch (pllsource)
 80136e0:	683b      	ldr	r3, [r7, #0]
 80136e2:	2b03      	cmp	r3, #3
 80136e4:	d017      	beq.n	8013716 <RCC_PLL_GetFreqDomain_Q+0x42>
 80136e6:	683b      	ldr	r3, [r7, #0]
 80136e8:	2b03      	cmp	r3, #3
 80136ea:	d81f      	bhi.n	801372c <RCC_PLL_GetFreqDomain_Q+0x58>
 80136ec:	683b      	ldr	r3, [r7, #0]
 80136ee:	2b01      	cmp	r3, #1
 80136f0:	d003      	beq.n	80136fa <RCC_PLL_GetFreqDomain_Q+0x26>
 80136f2:	683b      	ldr	r3, [r7, #0]
 80136f4:	2b02      	cmp	r3, #2
 80136f6:	d00b      	beq.n	8013710 <RCC_PLL_GetFreqDomain_Q+0x3c>
 80136f8:	e018      	b.n	801372c <RCC_PLL_GetFreqDomain_Q+0x58>
  {
    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 80136fa:	f7fe fe07 	bl	801230c <LL_RCC_MSI_GetRange>
 80136fe:	4603      	mov	r3, r0
 8013700:	091b      	lsrs	r3, r3, #4
 8013702:	f003 030f 	and.w	r3, r3, #15
 8013706:	4a1b      	ldr	r2, [pc, #108]	; (8013774 <RCC_PLL_GetFreqDomain_Q+0xa0>)
 8013708:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801370c:	607b      	str	r3, [r7, #4]
      break;
 801370e:	e018      	b.n	8013742 <RCC_PLL_GetFreqDomain_Q+0x6e>

    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 8013710:	4b19      	ldr	r3, [pc, #100]	; (8013778 <RCC_PLL_GetFreqDomain_Q+0xa4>)
 8013712:	607b      	str	r3, [r7, #4]
      break;
 8013714:	e015      	b.n	8013742 <RCC_PLL_GetFreqDomain_Q+0x6e>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8013716:	f7fe fd49 	bl	80121ac <LL_RCC_HSE_IsEnabledDiv2>
 801371a:	4603      	mov	r3, r0
 801371c:	2b01      	cmp	r3, #1
 801371e:	d102      	bne.n	8013726 <RCC_PLL_GetFreqDomain_Q+0x52>
      {
        pllinputfreq = HSE_VALUE / 2U;
 8013720:	4b15      	ldr	r3, [pc, #84]	; (8013778 <RCC_PLL_GetFreqDomain_Q+0xa4>)
 8013722:	607b      	str	r3, [r7, #4]
      else
      {
        pllinputfreq = HSE_VALUE;
      }

      break;
 8013724:	e00d      	b.n	8013742 <RCC_PLL_GetFreqDomain_Q+0x6e>
        pllinputfreq = HSE_VALUE;
 8013726:	4b15      	ldr	r3, [pc, #84]	; (801377c <RCC_PLL_GetFreqDomain_Q+0xa8>)
 8013728:	607b      	str	r3, [r7, #4]
      break;
 801372a:	e00a      	b.n	8013742 <RCC_PLL_GetFreqDomain_Q+0x6e>

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 801372c:	f7fe fdee 	bl	801230c <LL_RCC_MSI_GetRange>
 8013730:	4603      	mov	r3, r0
 8013732:	091b      	lsrs	r3, r3, #4
 8013734:	f003 030f 	and.w	r3, r3, #15
 8013738:	4a0e      	ldr	r2, [pc, #56]	; (8013774 <RCC_PLL_GetFreqDomain_Q+0xa0>)
 801373a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801373e:	607b      	str	r3, [r7, #4]
      break;
 8013740:	bf00      	nop
  }
  return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8013742:	f7ff f82f 	bl	80127a4 <LL_RCC_PLL_GetN>
 8013746:	4602      	mov	r2, r0
 8013748:	687b      	ldr	r3, [r7, #4]
 801374a:	fb03 f402 	mul.w	r4, r3, r2
 801374e:	f7ff f84e 	bl	80127ee <LL_RCC_PLL_GetDivider>
 8013752:	4603      	mov	r3, r0
 8013754:	091b      	lsrs	r3, r3, #4
 8013756:	3301      	adds	r3, #1
 8013758:	fbb4 f4f3 	udiv	r4, r4, r3
 801375c:	f7ff f83b 	bl	80127d6 <LL_RCC_PLL_GetQ>
 8013760:	4603      	mov	r3, r0
 8013762:	0e5b      	lsrs	r3, r3, #25
 8013764:	3301      	adds	r3, #1
 8013766:	fbb4 f3f3 	udiv	r3, r4, r3
                                       LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());
}
 801376a:	4618      	mov	r0, r3
 801376c:	370c      	adds	r7, #12
 801376e:	46bd      	mov	sp, r7
 8013770:	bd90      	pop	{r4, r7, pc}
 8013772:	bf00      	nop
 8013774:	0802ca8c 	.word	0x0802ca8c
 8013778:	00f42400 	.word	0x00f42400
 801377c:	01e84800 	.word	0x01e84800

08013780 <RCC_PLLSAI1_GetFreqDomain_R>:
/**
  * @brief  Return PLLSAI1 clock (PLLSAI1RCLK) frequency used for ADC domain
  * @retval PLLSAI1RCLK clock frequency (in Hz)
  */
static uint32_t RCC_PLLSAI1_GetFreqDomain_R(void)
{
 8013780:	b590      	push	{r4, r7, lr}
 8013782:	b083      	sub	sp, #12
 8013784:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq, pllsource;

  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI Value/ PLLM) * PLLSAI1N */
  /* 48M Domain clock  = PLLSAI1_VCO / PLLSAI1R */
  pllsource = LL_RCC_PLL_GetMainSource();
 8013786:	f7ff f89f 	bl	80128c8 <LL_RCC_PLL_GetMainSource>
 801378a:	6038      	str	r0, [r7, #0]

  switch (pllsource)
 801378c:	683b      	ldr	r3, [r7, #0]
 801378e:	2b03      	cmp	r3, #3
 8013790:	d017      	beq.n	80137c2 <RCC_PLLSAI1_GetFreqDomain_R+0x42>
 8013792:	683b      	ldr	r3, [r7, #0]
 8013794:	2b03      	cmp	r3, #3
 8013796:	d81f      	bhi.n	80137d8 <RCC_PLLSAI1_GetFreqDomain_R+0x58>
 8013798:	683b      	ldr	r3, [r7, #0]
 801379a:	2b01      	cmp	r3, #1
 801379c:	d003      	beq.n	80137a6 <RCC_PLLSAI1_GetFreqDomain_R+0x26>
 801379e:	683b      	ldr	r3, [r7, #0]
 80137a0:	2b02      	cmp	r3, #2
 80137a2:	d00b      	beq.n	80137bc <RCC_PLLSAI1_GetFreqDomain_R+0x3c>
 80137a4:	e018      	b.n	80137d8 <RCC_PLLSAI1_GetFreqDomain_R+0x58>
  {
    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 80137a6:	f7fe fdb1 	bl	801230c <LL_RCC_MSI_GetRange>
 80137aa:	4603      	mov	r3, r0
 80137ac:	091b      	lsrs	r3, r3, #4
 80137ae:	f003 030f 	and.w	r3, r3, #15
 80137b2:	4a1b      	ldr	r2, [pc, #108]	; (8013820 <RCC_PLLSAI1_GetFreqDomain_R+0xa0>)
 80137b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80137b8:	607b      	str	r3, [r7, #4]
      break;
 80137ba:	e018      	b.n	80137ee <RCC_PLLSAI1_GetFreqDomain_R+0x6e>

    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
      pllinputfreq = HSI_VALUE;
 80137bc:	4b19      	ldr	r3, [pc, #100]	; (8013824 <RCC_PLLSAI1_GetFreqDomain_R+0xa4>)
 80137be:	607b      	str	r3, [r7, #4]
      break;
 80137c0:	e015      	b.n	80137ee <RCC_PLLSAI1_GetFreqDomain_R+0x6e>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
      if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 80137c2:	f7fe fcf3 	bl	80121ac <LL_RCC_HSE_IsEnabledDiv2>
 80137c6:	4603      	mov	r3, r0
 80137c8:	2b01      	cmp	r3, #1
 80137ca:	d102      	bne.n	80137d2 <RCC_PLLSAI1_GetFreqDomain_R+0x52>
      {
        pllinputfreq = HSE_VALUE / 2U;
 80137cc:	4b15      	ldr	r3, [pc, #84]	; (8013824 <RCC_PLLSAI1_GetFreqDomain_R+0xa4>)
 80137ce:	607b      	str	r3, [r7, #4]
      }
      else
      {
        pllinputfreq = HSE_VALUE;
      }
      break;
 80137d0:	e00d      	b.n	80137ee <RCC_PLLSAI1_GetFreqDomain_R+0x6e>
        pllinputfreq = HSE_VALUE;
 80137d2:	4b15      	ldr	r3, [pc, #84]	; (8013828 <RCC_PLLSAI1_GetFreqDomain_R+0xa8>)
 80137d4:	607b      	str	r3, [r7, #4]
      break;
 80137d6:	e00a      	b.n	80137ee <RCC_PLLSAI1_GetFreqDomain_R+0x6e>

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 80137d8:	f7fe fd98 	bl	801230c <LL_RCC_MSI_GetRange>
 80137dc:	4603      	mov	r3, r0
 80137de:	091b      	lsrs	r3, r3, #4
 80137e0:	f003 030f 	and.w	r3, r3, #15
 80137e4:	4a0e      	ldr	r2, [pc, #56]	; (8013820 <RCC_PLLSAI1_GetFreqDomain_R+0xa0>)
 80137e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80137ea:	607b      	str	r3, [r7, #4]
      break;
 80137ec:	bf00      	nop
  }
  return __LL_RCC_CALC_PLLSAI1_ADC_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80137ee:	f7ff f83a 	bl	8012866 <LL_RCC_PLLSAI1_GetN>
 80137f2:	4602      	mov	r2, r0
 80137f4:	687b      	ldr	r3, [r7, #4]
 80137f6:	fb03 f402 	mul.w	r4, r3, r2
 80137fa:	f7fe fff8 	bl	80127ee <LL_RCC_PLL_GetDivider>
 80137fe:	4603      	mov	r3, r0
 8013800:	091b      	lsrs	r3, r3, #4
 8013802:	3301      	adds	r3, #1
 8013804:	fbb4 f4f3 	udiv	r4, r4, r3
 8013808:	f7ff f852 	bl	80128b0 <LL_RCC_PLLSAI1_GetR>
 801380c:	4603      	mov	r3, r0
 801380e:	0f5b      	lsrs	r3, r3, #29
 8013810:	3301      	adds	r3, #1
 8013812:	fbb4 f3f3 	udiv	r3, r4, r3
                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetR());
}
 8013816:	4618      	mov	r0, r3
 8013818:	370c      	adds	r7, #12
 801381a:	46bd      	mov	sp, r7
 801381c:	bd90      	pop	{r4, r7, pc}
 801381e:	bf00      	nop
 8013820:	0802ca8c 	.word	0x0802ca8c
 8013824:	00f42400 	.word	0x00f42400
 8013828:	01e84800 	.word	0x01e84800

0801382c <RCC_PLLSAI1_GetFreqDomain_P>:
/**
  * @brief  Return PLLSAI1 clock (PLLSAI1PCLK) frequency used for SAI domain
  * @retval PLLSAI1PCLK clock frequency (in Hz)
  */
static uint32_t RCC_PLLSAI1_GetFreqDomain_P(void)
{
 801382c:	b590      	push	{r4, r7, lr}
 801382e:	b083      	sub	sp, #12
 8013830:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq, pllsource;

  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI Value/ PLLM) * PLLSAI1N */
  /* SAI Domain clock  = PLLSAI1_VCO / PLLSAI1P */
  pllsource = LL_RCC_PLL_GetMainSource();
 8013832:	f7ff f849 	bl	80128c8 <LL_RCC_PLL_GetMainSource>
 8013836:	6038      	str	r0, [r7, #0]

  switch (pllsource)
 8013838:	683b      	ldr	r3, [r7, #0]
 801383a:	2b03      	cmp	r3, #3
 801383c:	d017      	beq.n	801386e <RCC_PLLSAI1_GetFreqDomain_P+0x42>
 801383e:	683b      	ldr	r3, [r7, #0]
 8013840:	2b03      	cmp	r3, #3
 8013842:	d81f      	bhi.n	8013884 <RCC_PLLSAI1_GetFreqDomain_P+0x58>
 8013844:	683b      	ldr	r3, [r7, #0]
 8013846:	2b01      	cmp	r3, #1
 8013848:	d003      	beq.n	8013852 <RCC_PLLSAI1_GetFreqDomain_P+0x26>
 801384a:	683b      	ldr	r3, [r7, #0]
 801384c:	2b02      	cmp	r3, #2
 801384e:	d00b      	beq.n	8013868 <RCC_PLLSAI1_GetFreqDomain_P+0x3c>
 8013850:	e018      	b.n	8013884 <RCC_PLLSAI1_GetFreqDomain_P+0x58>
  {
    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8013852:	f7fe fd5b 	bl	801230c <LL_RCC_MSI_GetRange>
 8013856:	4603      	mov	r3, r0
 8013858:	091b      	lsrs	r3, r3, #4
 801385a:	f003 030f 	and.w	r3, r3, #15
 801385e:	4a1b      	ldr	r2, [pc, #108]	; (80138cc <RCC_PLLSAI1_GetFreqDomain_P+0xa0>)
 8013860:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013864:	607b      	str	r3, [r7, #4]
      break;
 8013866:	e018      	b.n	801389a <RCC_PLLSAI1_GetFreqDomain_P+0x6e>

    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
      pllinputfreq = HSI_VALUE;
 8013868:	4b19      	ldr	r3, [pc, #100]	; (80138d0 <RCC_PLLSAI1_GetFreqDomain_P+0xa4>)
 801386a:	607b      	str	r3, [r7, #4]
      break;
 801386c:	e015      	b.n	801389a <RCC_PLLSAI1_GetFreqDomain_P+0x6e>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
      if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 801386e:	f7fe fc9d 	bl	80121ac <LL_RCC_HSE_IsEnabledDiv2>
 8013872:	4603      	mov	r3, r0
 8013874:	2b01      	cmp	r3, #1
 8013876:	d102      	bne.n	801387e <RCC_PLLSAI1_GetFreqDomain_P+0x52>
      {
        pllinputfreq = HSE_VALUE / 2U;
 8013878:	4b15      	ldr	r3, [pc, #84]	; (80138d0 <RCC_PLLSAI1_GetFreqDomain_P+0xa4>)
 801387a:	607b      	str	r3, [r7, #4]
      }
      else
      {
        pllinputfreq = HSE_VALUE;
      }
      break;
 801387c:	e00d      	b.n	801389a <RCC_PLLSAI1_GetFreqDomain_P+0x6e>
        pllinputfreq = HSE_VALUE;
 801387e:	4b15      	ldr	r3, [pc, #84]	; (80138d4 <RCC_PLLSAI1_GetFreqDomain_P+0xa8>)
 8013880:	607b      	str	r3, [r7, #4]
      break;
 8013882:	e00a      	b.n	801389a <RCC_PLLSAI1_GetFreqDomain_P+0x6e>

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8013884:	f7fe fd42 	bl	801230c <LL_RCC_MSI_GetRange>
 8013888:	4603      	mov	r3, r0
 801388a:	091b      	lsrs	r3, r3, #4
 801388c:	f003 030f 	and.w	r3, r3, #15
 8013890:	4a0e      	ldr	r2, [pc, #56]	; (80138cc <RCC_PLLSAI1_GetFreqDomain_P+0xa0>)
 8013892:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013896:	607b      	str	r3, [r7, #4]
      break;
 8013898:	bf00      	nop
  }
  return __LL_RCC_CALC_PLLSAI1_SAI_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 801389a:	f7fe ffe4 	bl	8012866 <LL_RCC_PLLSAI1_GetN>
 801389e:	4602      	mov	r2, r0
 80138a0:	687b      	ldr	r3, [r7, #4]
 80138a2:	fb03 f402 	mul.w	r4, r3, r2
 80138a6:	f7fe ffa2 	bl	80127ee <LL_RCC_PLL_GetDivider>
 80138aa:	4603      	mov	r3, r0
 80138ac:	091b      	lsrs	r3, r3, #4
 80138ae:	3301      	adds	r3, #1
 80138b0:	fbb4 f4f3 	udiv	r4, r4, r3
 80138b4:	f7fe ffe4 	bl	8012880 <LL_RCC_PLLSAI1_GetP>
 80138b8:	4603      	mov	r3, r0
 80138ba:	0c5b      	lsrs	r3, r3, #17
 80138bc:	3301      	adds	r3, #1
 80138be:	fbb4 f3f3 	udiv	r3, r4, r3
                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetP());
}
 80138c2:	4618      	mov	r0, r3
 80138c4:	370c      	adds	r7, #12
 80138c6:	46bd      	mov	sp, r7
 80138c8:	bd90      	pop	{r4, r7, pc}
 80138ca:	bf00      	nop
 80138cc:	0802ca8c 	.word	0x0802ca8c
 80138d0:	00f42400 	.word	0x00f42400
 80138d4:	01e84800 	.word	0x01e84800

080138d8 <RCC_PLLSAI1_GetFreqDomain_Q>:
/**
  * @brief  Return PLLSAI1 clock (PLLSAI1QCLK) frequency used for 48Mhz domain
  * @retval PLLSAI1QCLK clock frequency (in Hz)
  */
static uint32_t RCC_PLLSAI1_GetFreqDomain_Q(void)
{
 80138d8:	b590      	push	{r4, r7, lr}
 80138da:	b083      	sub	sp, #12
 80138dc:	af00      	add	r7, sp, #0
  uint32_t pllinputfreq, pllsource;

  /* PLLSAI1_VCO = (HSE_VALUE or HSI_VALUE or MSI Value/ PLLM) * PLLSAI1N */
  /* 48M Domain clock  = PLLSAI1_VCO / PLLSAI1Q */
  pllsource = LL_RCC_PLL_GetMainSource();
 80138de:	f7fe fff3 	bl	80128c8 <LL_RCC_PLL_GetMainSource>
 80138e2:	6038      	str	r0, [r7, #0]

  switch (pllsource)
 80138e4:	683b      	ldr	r3, [r7, #0]
 80138e6:	2b03      	cmp	r3, #3
 80138e8:	d017      	beq.n	801391a <RCC_PLLSAI1_GetFreqDomain_Q+0x42>
 80138ea:	683b      	ldr	r3, [r7, #0]
 80138ec:	2b03      	cmp	r3, #3
 80138ee:	d81f      	bhi.n	8013930 <RCC_PLLSAI1_GetFreqDomain_Q+0x58>
 80138f0:	683b      	ldr	r3, [r7, #0]
 80138f2:	2b01      	cmp	r3, #1
 80138f4:	d003      	beq.n	80138fe <RCC_PLLSAI1_GetFreqDomain_Q+0x26>
 80138f6:	683b      	ldr	r3, [r7, #0]
 80138f8:	2b02      	cmp	r3, #2
 80138fa:	d00b      	beq.n	8013914 <RCC_PLLSAI1_GetFreqDomain_Q+0x3c>
 80138fc:	e018      	b.n	8013930 <RCC_PLLSAI1_GetFreqDomain_Q+0x58>
  {
    case LL_RCC_PLLSOURCE_MSI:  /* MSI used as PLLSAI1 clock source */
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 80138fe:	f7fe fd05 	bl	801230c <LL_RCC_MSI_GetRange>
 8013902:	4603      	mov	r3, r0
 8013904:	091b      	lsrs	r3, r3, #4
 8013906:	f003 030f 	and.w	r3, r3, #15
 801390a:	4a1b      	ldr	r2, [pc, #108]	; (8013978 <RCC_PLLSAI1_GetFreqDomain_Q+0xa0>)
 801390c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013910:	607b      	str	r3, [r7, #4]
      break;
 8013912:	e018      	b.n	8013946 <RCC_PLLSAI1_GetFreqDomain_Q+0x6e>

    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI1 clock source */
      pllinputfreq = HSI_VALUE;
 8013914:	4b19      	ldr	r3, [pc, #100]	; (801397c <RCC_PLLSAI1_GetFreqDomain_Q+0xa4>)
 8013916:	607b      	str	r3, [r7, #4]
      break;
 8013918:	e015      	b.n	8013946 <RCC_PLLSAI1_GetFreqDomain_Q+0x6e>

    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI1 clock source */
      if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 801391a:	f7fe fc47 	bl	80121ac <LL_RCC_HSE_IsEnabledDiv2>
 801391e:	4603      	mov	r3, r0
 8013920:	2b01      	cmp	r3, #1
 8013922:	d102      	bne.n	801392a <RCC_PLLSAI1_GetFreqDomain_Q+0x52>
      {
        pllinputfreq = HSE_VALUE / 2U;
 8013924:	4b15      	ldr	r3, [pc, #84]	; (801397c <RCC_PLLSAI1_GetFreqDomain_Q+0xa4>)
 8013926:	607b      	str	r3, [r7, #4]
      }
      else
      {
        pllinputfreq = HSE_VALUE;
      }
      break;
 8013928:	e00d      	b.n	8013946 <RCC_PLLSAI1_GetFreqDomain_Q+0x6e>
        pllinputfreq = HSE_VALUE;
 801392a:	4b15      	ldr	r3, [pc, #84]	; (8013980 <RCC_PLLSAI1_GetFreqDomain_Q+0xa8>)
 801392c:	607b      	str	r3, [r7, #4]
      break;
 801392e:	e00a      	b.n	8013946 <RCC_PLLSAI1_GetFreqDomain_Q+0x6e>

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8013930:	f7fe fcec 	bl	801230c <LL_RCC_MSI_GetRange>
 8013934:	4603      	mov	r3, r0
 8013936:	091b      	lsrs	r3, r3, #4
 8013938:	f003 030f 	and.w	r3, r3, #15
 801393c:	4a0e      	ldr	r2, [pc, #56]	; (8013978 <RCC_PLLSAI1_GetFreqDomain_Q+0xa0>)
 801393e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013942:	607b      	str	r3, [r7, #4]
      break;
 8013944:	bf00      	nop
  }
  return __LL_RCC_CALC_PLLSAI1_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8013946:	f7fe ff8e 	bl	8012866 <LL_RCC_PLLSAI1_GetN>
 801394a:	4602      	mov	r2, r0
 801394c:	687b      	ldr	r3, [r7, #4]
 801394e:	fb03 f402 	mul.w	r4, r3, r2
 8013952:	f7fe ff4c 	bl	80127ee <LL_RCC_PLL_GetDivider>
 8013956:	4603      	mov	r3, r0
 8013958:	091b      	lsrs	r3, r3, #4
 801395a:	3301      	adds	r3, #1
 801395c:	fbb4 f4f3 	udiv	r4, r4, r3
 8013960:	f7fe ff9a 	bl	8012898 <LL_RCC_PLLSAI1_GetQ>
 8013964:	4603      	mov	r3, r0
 8013966:	0e5b      	lsrs	r3, r3, #25
 8013968:	3301      	adds	r3, #1
 801396a:	fbb4 f3f3 	udiv	r3, r4, r3
                                        LL_RCC_PLLSAI1_GetN(), LL_RCC_PLLSAI1_GetQ());
}
 801396e:	4618      	mov	r0, r3
 8013970:	370c      	adds	r7, #12
 8013972:	46bd      	mov	sp, r7
 8013974:	bd90      	pop	{r4, r7, pc}
 8013976:	bf00      	nop
 8013978:	0802ca8c 	.word	0x0802ca8c
 801397c:	00f42400 	.word	0x00f42400
 8013980:	01e84800 	.word	0x01e84800

08013984 <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8013984:	b580      	push	{r7, lr}
 8013986:	b082      	sub	sp, #8
 8013988:	af00      	add	r7, sp, #0
 801398a:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if (hrtc == NULL)
 801398c:	687b      	ldr	r3, [r7, #4]
 801398e:	2b00      	cmp	r3, #0
 8013990:	d101      	bne.n	8013996 <HAL_RTC_Init+0x12>
  {
    return HAL_ERROR;
 8013992:	2301      	movs	r3, #1
 8013994:	e090      	b.n	8013ab8 <HAL_RTC_Init+0x134>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if (hrtc->State == HAL_RTC_STATE_RESET)
 8013996:	687b      	ldr	r3, [r7, #4]
 8013998:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 801399c:	b2db      	uxtb	r3, r3
 801399e:	2b00      	cmp	r3, #0
 80139a0:	d106      	bne.n	80139b0 <HAL_RTC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 80139a2:	687b      	ldr	r3, [r7, #4]
 80139a4:	2200      	movs	r2, #0
 80139a6:	f883 2020 	strb.w	r2, [r3, #32]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 80139aa:	6878      	ldr	r0, [r7, #4]
 80139ac:	f7f7 fba8 	bl	800b100 <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 80139b0:	687b      	ldr	r3, [r7, #4]
 80139b2:	2202      	movs	r2, #2
 80139b4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80139b8:	687b      	ldr	r3, [r7, #4]
 80139ba:	681b      	ldr	r3, [r3, #0]
 80139bc:	22ca      	movs	r2, #202	; 0xca
 80139be:	625a      	str	r2, [r3, #36]	; 0x24
 80139c0:	687b      	ldr	r3, [r7, #4]
 80139c2:	681b      	ldr	r3, [r3, #0]
 80139c4:	2253      	movs	r2, #83	; 0x53
 80139c6:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if (RTC_EnterInitMode(hrtc) != HAL_OK)
 80139c8:	6878      	ldr	r0, [r7, #4]
 80139ca:	f000 f89f 	bl	8013b0c <RTC_EnterInitMode>
 80139ce:	4603      	mov	r3, r0
 80139d0:	2b00      	cmp	r3, #0
 80139d2:	d009      	beq.n	80139e8 <HAL_RTC_Init+0x64>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80139d4:	687b      	ldr	r3, [r7, #4]
 80139d6:	681b      	ldr	r3, [r3, #0]
 80139d8:	22ff      	movs	r2, #255	; 0xff
 80139da:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 80139dc:	687b      	ldr	r3, [r7, #4]
 80139de:	2204      	movs	r2, #4
 80139e0:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    return HAL_ERROR;
 80139e4:	2301      	movs	r3, #1
 80139e6:	e067      	b.n	8013ab8 <HAL_RTC_Init+0x134>
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80139e8:	687b      	ldr	r3, [r7, #4]
 80139ea:	681b      	ldr	r3, [r3, #0]
 80139ec:	689b      	ldr	r3, [r3, #8]
 80139ee:	687a      	ldr	r2, [r7, #4]
 80139f0:	6812      	ldr	r2, [r2, #0]
 80139f2:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 80139f6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80139fa:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80139fc:	687b      	ldr	r3, [r7, #4]
 80139fe:	681b      	ldr	r3, [r3, #0]
 8013a00:	6899      	ldr	r1, [r3, #8]
 8013a02:	687b      	ldr	r3, [r7, #4]
 8013a04:	685a      	ldr	r2, [r3, #4]
 8013a06:	687b      	ldr	r3, [r7, #4]
 8013a08:	691b      	ldr	r3, [r3, #16]
 8013a0a:	431a      	orrs	r2, r3
 8013a0c:	687b      	ldr	r3, [r7, #4]
 8013a0e:	699b      	ldr	r3, [r3, #24]
 8013a10:	431a      	orrs	r2, r3
 8013a12:	687b      	ldr	r3, [r7, #4]
 8013a14:	681b      	ldr	r3, [r3, #0]
 8013a16:	430a      	orrs	r2, r1
 8013a18:	609a      	str	r2, [r3, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8013a1a:	687b      	ldr	r3, [r7, #4]
 8013a1c:	681b      	ldr	r3, [r3, #0]
 8013a1e:	687a      	ldr	r2, [r7, #4]
 8013a20:	68d2      	ldr	r2, [r2, #12]
 8013a22:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8013a24:	687b      	ldr	r3, [r7, #4]
 8013a26:	681b      	ldr	r3, [r3, #0]
 8013a28:	6919      	ldr	r1, [r3, #16]
 8013a2a:	687b      	ldr	r3, [r7, #4]
 8013a2c:	689b      	ldr	r3, [r3, #8]
 8013a2e:	041a      	lsls	r2, r3, #16
 8013a30:	687b      	ldr	r3, [r7, #4]
 8013a32:	681b      	ldr	r3, [r3, #0]
 8013a34:	430a      	orrs	r2, r1
 8013a36:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8013a38:	687b      	ldr	r3, [r7, #4]
 8013a3a:	681b      	ldr	r3, [r3, #0]
 8013a3c:	68da      	ldr	r2, [r3, #12]
 8013a3e:	687b      	ldr	r3, [r7, #4]
 8013a40:	681b      	ldr	r3, [r3, #0]
 8013a42:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8013a46:	60da      	str	r2, [r3, #12]

#if defined(RTC_OR_ALARMOUTTYPE)
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8013a48:	687b      	ldr	r3, [r7, #4]
 8013a4a:	681b      	ldr	r3, [r3, #0]
 8013a4c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013a4e:	687b      	ldr	r3, [r7, #4]
 8013a50:	681b      	ldr	r3, [r3, #0]
 8013a52:	f022 0203 	bic.w	r2, r2, #3
 8013a56:	64da      	str	r2, [r3, #76]	; 0x4c
#else
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_OUT_RMP);
#endif
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8013a58:	687b      	ldr	r3, [r7, #4]
 8013a5a:	681b      	ldr	r3, [r3, #0]
 8013a5c:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8013a5e:	687b      	ldr	r3, [r7, #4]
 8013a60:	69da      	ldr	r2, [r3, #28]
 8013a62:	687b      	ldr	r3, [r7, #4]
 8013a64:	695b      	ldr	r3, [r3, #20]
 8013a66:	431a      	orrs	r2, r3
 8013a68:	687b      	ldr	r3, [r7, #4]
 8013a6a:	681b      	ldr	r3, [r3, #0]
 8013a6c:	430a      	orrs	r2, r1
 8013a6e:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 8013a70:	687b      	ldr	r3, [r7, #4]
 8013a72:	681b      	ldr	r3, [r3, #0]
 8013a74:	689b      	ldr	r3, [r3, #8]
 8013a76:	f003 0320 	and.w	r3, r3, #32
 8013a7a:	2b00      	cmp	r3, #0
 8013a7c:	d113      	bne.n	8013aa6 <HAL_RTC_Init+0x122>
    {
      if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8013a7e:	6878      	ldr	r0, [r7, #4]
 8013a80:	f000 f81e 	bl	8013ac0 <HAL_RTC_WaitForSynchro>
 8013a84:	4603      	mov	r3, r0
 8013a86:	2b00      	cmp	r3, #0
 8013a88:	d00d      	beq.n	8013aa6 <HAL_RTC_Init+0x122>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013a8a:	687b      	ldr	r3, [r7, #4]
 8013a8c:	681b      	ldr	r3, [r3, #0]
 8013a8e:	22ff      	movs	r2, #255	; 0xff
 8013a90:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8013a92:	687b      	ldr	r3, [r7, #4]
 8013a94:	2204      	movs	r2, #4
 8013a96:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8013a9a:	687b      	ldr	r3, [r7, #4]
 8013a9c:	2200      	movs	r2, #0
 8013a9e:	f883 2020 	strb.w	r2, [r3, #32]

        return HAL_ERROR;
 8013aa2:	2301      	movs	r3, #1
 8013aa4:	e008      	b.n	8013ab8 <HAL_RTC_Init+0x134>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013aa6:	687b      	ldr	r3, [r7, #4]
 8013aa8:	681b      	ldr	r3, [r3, #0]
 8013aaa:	22ff      	movs	r2, #255	; 0xff
 8013aac:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8013aae:	687b      	ldr	r3, [r7, #4]
 8013ab0:	2201      	movs	r2, #1
 8013ab2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    return HAL_OK;
 8013ab6:	2300      	movs	r3, #0
  }
}
 8013ab8:	4618      	mov	r0, r3
 8013aba:	3708      	adds	r7, #8
 8013abc:	46bd      	mov	sp, r7
 8013abe:	bd80      	pop	{r7, pc}

08013ac0 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8013ac0:	b580      	push	{r7, lr}
 8013ac2:	b084      	sub	sp, #16
 8013ac4:	af00      	add	r7, sp, #0
 8013ac6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8013ac8:	687b      	ldr	r3, [r7, #4]
 8013aca:	681b      	ldr	r3, [r3, #0]
 8013acc:	68da      	ldr	r2, [r3, #12]
 8013ace:	687b      	ldr	r3, [r7, #4]
 8013ad0:	681b      	ldr	r3, [r3, #0]
 8013ad2:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8013ad6:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 8013ad8:	f7f8 ffd6 	bl	800ca88 <HAL_GetTick>
 8013adc:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013ade:	e009      	b.n	8013af4 <HAL_RTC_WaitForSynchro+0x34>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8013ae0:	f7f8 ffd2 	bl	800ca88 <HAL_GetTick>
 8013ae4:	4602      	mov	r2, r0
 8013ae6:	68fb      	ldr	r3, [r7, #12]
 8013ae8:	1ad3      	subs	r3, r2, r3
 8013aea:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8013aee:	d901      	bls.n	8013af4 <HAL_RTC_WaitForSynchro+0x34>
    {
      return HAL_TIMEOUT;
 8013af0:	2303      	movs	r3, #3
 8013af2:	e007      	b.n	8013b04 <HAL_RTC_WaitForSynchro+0x44>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013af4:	687b      	ldr	r3, [r7, #4]
 8013af6:	681b      	ldr	r3, [r3, #0]
 8013af8:	68db      	ldr	r3, [r3, #12]
 8013afa:	f003 0320 	and.w	r3, r3, #32
 8013afe:	2b00      	cmp	r3, #0
 8013b00:	d0ee      	beq.n	8013ae0 <HAL_RTC_WaitForSynchro+0x20>
    }
  }

  return HAL_OK;
 8013b02:	2300      	movs	r3, #0
}
 8013b04:	4618      	mov	r0, r3
 8013b06:	3710      	adds	r7, #16
 8013b08:	46bd      	mov	sp, r7
 8013b0a:	bd80      	pop	{r7, pc}

08013b0c <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8013b0c:	b580      	push	{r7, lr}
 8013b0e:	b084      	sub	sp, #16
 8013b10:	af00      	add	r7, sp, #0
 8013b12:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check if the Initialization mode is set */
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 8013b14:	687b      	ldr	r3, [r7, #4]
 8013b16:	681b      	ldr	r3, [r3, #0]
 8013b18:	68db      	ldr	r3, [r3, #12]
 8013b1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013b1e:	2b00      	cmp	r3, #0
 8013b20:	d119      	bne.n	8013b56 <RTC_EnterInitMode+0x4a>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8013b22:	687b      	ldr	r3, [r7, #4]
 8013b24:	681b      	ldr	r3, [r3, #0]
 8013b26:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8013b2a:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 8013b2c:	f7f8 ffac 	bl	800ca88 <HAL_GetTick>
 8013b30:	60f8      	str	r0, [r7, #12]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 8013b32:	e009      	b.n	8013b48 <RTC_EnterInitMode+0x3c>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8013b34:	f7f8 ffa8 	bl	800ca88 <HAL_GetTick>
 8013b38:	4602      	mov	r2, r0
 8013b3a:	68fb      	ldr	r3, [r7, #12]
 8013b3c:	1ad3      	subs	r3, r2, r3
 8013b3e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8013b42:	d901      	bls.n	8013b48 <RTC_EnterInitMode+0x3c>
      {
        return HAL_TIMEOUT;
 8013b44:	2303      	movs	r3, #3
 8013b46:	e007      	b.n	8013b58 <RTC_EnterInitMode+0x4c>
    while ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 8013b48:	687b      	ldr	r3, [r7, #4]
 8013b4a:	681b      	ldr	r3, [r3, #0]
 8013b4c:	68db      	ldr	r3, [r3, #12]
 8013b4e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013b52:	2b00      	cmp	r3, #0
 8013b54:	d0ee      	beq.n	8013b34 <RTC_EnterInitMode+0x28>
      }
    }
  }

  return HAL_OK;
 8013b56:	2300      	movs	r3, #0
}
 8013b58:	4618      	mov	r0, r3
 8013b5a:	3710      	adds	r7, #16
 8013b5c:	46bd      	mov	sp, r7
 8013b5e:	bd80      	pop	{r7, pc}

08013b60 <HAL_SAI_InitProtocol>:
  *                   the configuration information for SAI module.
  * @param  nbslot Number of slot.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 8013b60:	b580      	push	{r7, lr}
 8013b62:	b086      	sub	sp, #24
 8013b64:	af00      	add	r7, sp, #0
 8013b66:	60f8      	str	r0, [r7, #12]
 8013b68:	60b9      	str	r1, [r7, #8]
 8013b6a:	607a      	str	r2, [r7, #4]
 8013b6c:	603b      	str	r3, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));

  switch (protocol)
 8013b6e:	68bb      	ldr	r3, [r7, #8]
 8013b70:	2b02      	cmp	r3, #2
 8013b72:	d904      	bls.n	8013b7e <HAL_SAI_InitProtocol+0x1e>
 8013b74:	68bb      	ldr	r3, [r7, #8]
 8013b76:	3b03      	subs	r3, #3
 8013b78:	2b01      	cmp	r3, #1
 8013b7a:	d812      	bhi.n	8013ba2 <HAL_SAI_InitProtocol+0x42>
 8013b7c:	e008      	b.n	8013b90 <HAL_SAI_InitProtocol+0x30>
  {
    case SAI_I2S_STANDARD :
    case SAI_I2S_MSBJUSTIFIED :
    case SAI_I2S_LSBJUSTIFIED :
      status = SAI_InitI2S(hsai, protocol, datasize, nbslot);
 8013b7e:	683b      	ldr	r3, [r7, #0]
 8013b80:	687a      	ldr	r2, [r7, #4]
 8013b82:	68b9      	ldr	r1, [r7, #8]
 8013b84:	68f8      	ldr	r0, [r7, #12]
 8013b86:	f000 f9af 	bl	8013ee8 <SAI_InitI2S>
 8013b8a:	4603      	mov	r3, r0
 8013b8c:	75fb      	strb	r3, [r7, #23]
      break;
 8013b8e:	e00b      	b.n	8013ba8 <HAL_SAI_InitProtocol+0x48>
    case SAI_PCM_LONG :
    case SAI_PCM_SHORT :
      status = SAI_InitPCM(hsai, protocol, datasize, nbslot);
 8013b90:	683b      	ldr	r3, [r7, #0]
 8013b92:	687a      	ldr	r2, [r7, #4]
 8013b94:	68b9      	ldr	r1, [r7, #8]
 8013b96:	68f8      	ldr	r0, [r7, #12]
 8013b98:	f000 fa58 	bl	801404c <SAI_InitPCM>
 8013b9c:	4603      	mov	r3, r0
 8013b9e:	75fb      	strb	r3, [r7, #23]
      break;
 8013ba0:	e002      	b.n	8013ba8 <HAL_SAI_InitProtocol+0x48>
    default :
      status = HAL_ERROR;
 8013ba2:	2301      	movs	r3, #1
 8013ba4:	75fb      	strb	r3, [r7, #23]
      break;
 8013ba6:	bf00      	nop
  }

  if (status == HAL_OK)
 8013ba8:	7dfb      	ldrb	r3, [r7, #23]
 8013baa:	2b00      	cmp	r3, #0
 8013bac:	d104      	bne.n	8013bb8 <HAL_SAI_InitProtocol+0x58>
  {
    status = HAL_SAI_Init(hsai);
 8013bae:	68f8      	ldr	r0, [r7, #12]
 8013bb0:	f000 f808 	bl	8013bc4 <HAL_SAI_Init>
 8013bb4:	4603      	mov	r3, r0
 8013bb6:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 8013bb8:	7dfb      	ldrb	r3, [r7, #23]
}
 8013bba:	4618      	mov	r0, r3
 8013bbc:	3718      	adds	r7, #24
 8013bbe:	46bd      	mov	sp, r7
 8013bc0:	bd80      	pop	{r7, pc}
	...

08013bc4 <HAL_SAI_Init>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
{
 8013bc4:	b580      	push	{r7, lr}
 8013bc6:	b088      	sub	sp, #32
 8013bc8:	af00      	add	r7, sp, #0
 8013bca:	6078      	str	r0, [r7, #4]
  uint32_t ckstr_bits;
  uint32_t syncen_bits;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
 8013bcc:	687b      	ldr	r3, [r7, #4]
 8013bce:	2b00      	cmp	r3, #0
 8013bd0:	d101      	bne.n	8013bd6 <HAL_SAI_Init+0x12>
  {
    return HAL_ERROR;
 8013bd2:	2301      	movs	r3, #1
 8013bd4:	e17c      	b.n	8013ed0 <HAL_SAI_Init+0x30c>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
 8013bd6:	687b      	ldr	r3, [r7, #4]
 8013bd8:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8013bdc:	2b01      	cmp	r3, #1
 8013bde:	d10e      	bne.n	8013bfe <HAL_SAI_Init+0x3a>
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
    /* Check that SAI sub-block is SAI1 sub-block A, in master RX mode with free protocol */
    if ((hsai->Instance != SAI1_Block_A) ||
 8013be0:	687b      	ldr	r3, [r7, #4]
 8013be2:	681b      	ldr	r3, [r3, #0]
 8013be4:	4a5c      	ldr	r2, [pc, #368]	; (8013d58 <HAL_SAI_Init+0x194>)
 8013be6:	4293      	cmp	r3, r2
 8013be8:	d107      	bne.n	8013bfa <HAL_SAI_Init+0x36>
        (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 8013bea:	687b      	ldr	r3, [r7, #4]
 8013bec:	685b      	ldr	r3, [r3, #4]
    if ((hsai->Instance != SAI1_Block_A) ||
 8013bee:	2b01      	cmp	r3, #1
 8013bf0:	d103      	bne.n	8013bfa <HAL_SAI_Init+0x36>
        (hsai->Init.Protocol != SAI_FREE_PROTOCOL))
 8013bf2:	687b      	ldr	r3, [r7, #4]
 8013bf4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 8013bf6:	2b00      	cmp	r3, #0
 8013bf8:	d001      	beq.n	8013bfe <HAL_SAI_Init+0x3a>
    {
      return HAL_ERROR;
 8013bfa:	2301      	movs	r3, #1
 8013bfc:	e168      	b.n	8013ed0 <HAL_SAI_Init+0x30c>
    }
  }

  if (hsai->State == HAL_SAI_STATE_RESET)
 8013bfe:	687b      	ldr	r3, [r7, #4]
 8013c00:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
 8013c04:	b2db      	uxtb	r3, r3
 8013c06:	2b00      	cmp	r3, #0
 8013c08:	d106      	bne.n	8013c18 <HAL_SAI_Init+0x54>
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
 8013c0a:	687b      	ldr	r3, [r7, #4]
 8013c0c:	2200      	movs	r2, #0
 8013c0e:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
      hsai->MspInitCallback = HAL_SAI_MspInit;
    }
    hsai->MspInitCallback(hsai);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_SAI_MspInit(hsai);
 8013c12:	6878      	ldr	r0, [r7, #4]
 8013c14:	f7f7 faf4 	bl	800b200 <HAL_SAI_MspInit>
#endif
  }

  /* Disable the selected SAI peripheral */
  if (SAI_Disable(hsai) != HAL_OK)
 8013c18:	6878      	ldr	r0, [r7, #4]
 8013c1a:	f000 fa99 	bl	8014150 <SAI_Disable>
 8013c1e:	4603      	mov	r3, r0
 8013c20:	2b00      	cmp	r3, #0
 8013c22:	d001      	beq.n	8013c28 <HAL_SAI_Init+0x64>
  {
    return HAL_ERROR;
 8013c24:	2301      	movs	r3, #1
 8013c26:	e153      	b.n	8013ed0 <HAL_SAI_Init+0x30c>
  }

  hsai->State = HAL_SAI_STATE_BUSY;
 8013c28:	687b      	ldr	r3, [r7, #4]
 8013c2a:	2202      	movs	r2, #2
 8013c2c:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* SAI Block Synchro Configuration -----------------------------------------*/
  /* This setting must be done with both audio block (A & B) disabled         */
  switch (hsai->Init.Synchro)
 8013c30:	687b      	ldr	r3, [r7, #4]
 8013c32:	689b      	ldr	r3, [r3, #8]
 8013c34:	2b00      	cmp	r3, #0
 8013c36:	d002      	beq.n	8013c3e <HAL_SAI_Init+0x7a>
 8013c38:	2b01      	cmp	r3, #1
 8013c3a:	d003      	beq.n	8013c44 <HAL_SAI_Init+0x80>
 8013c3c:	e006      	b.n	8013c4c <HAL_SAI_Init+0x88>
  {
    case SAI_ASYNCHRONOUS :
      syncen_bits = 0;
 8013c3e:	2300      	movs	r3, #0
 8013c40:	61bb      	str	r3, [r7, #24]
      break;
 8013c42:	e006      	b.n	8013c52 <HAL_SAI_Init+0x8e>
    case SAI_SYNCHRONOUS :
      syncen_bits = SAI_xCR1_SYNCEN_0;
 8013c44:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8013c48:	61bb      	str	r3, [r7, #24]
      break;
 8013c4a:	e002      	b.n	8013c52 <HAL_SAI_Init+0x8e>
    default :
      syncen_bits = 0;
 8013c4c:	2300      	movs	r3, #0
 8013c4e:	61bb      	str	r3, [r7, #24]
      break;
 8013c50:	bf00      	nop
  }

  SAI1->GCR = 0;
 8013c52:	4b42      	ldr	r3, [pc, #264]	; (8013d5c <HAL_SAI_Init+0x198>)
 8013c54:	2200      	movs	r2, #0
 8013c56:	601a      	str	r2, [r3, #0]

  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8013c58:	687b      	ldr	r3, [r7, #4]
 8013c5a:	6a1b      	ldr	r3, [r3, #32]
 8013c5c:	2b00      	cmp	r3, #0
 8013c5e:	d062      	beq.n	8013d26 <HAL_SAI_Init+0x162>
  {
    uint32_t freq;
    uint32_t tmpval;

    /* In this case, the MCKDIV value is calculated to get AudioFrequency */
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 8013c60:	2040      	movs	r0, #64	; 0x40
 8013c62:	f7fe ffb3 	bl	8012bcc <HAL_RCCEx_GetPeriphCLKFreq>
 8013c66:	60f8      	str	r0, [r7, #12]
    /* Configure Master Clock Divider using the following formula :
       - If NODIV = 1 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (FRL + 1))
       - If NODIV = 0 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (OSR + 1) * 256) */
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
 8013c68:	687b      	ldr	r3, [r7, #4]
 8013c6a:	699b      	ldr	r3, [r3, #24]
 8013c6c:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8013c70:	d120      	bne.n	8013cb4 <HAL_SAI_Init+0xf0>
    {
      /* NODIV = 1 */
      uint32_t tmpframelength;

      if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 8013c72:	687b      	ldr	r3, [r7, #4]
 8013c74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013c76:	2b04      	cmp	r3, #4
 8013c78:	d102      	bne.n	8013c80 <HAL_SAI_Init+0xbc>
      {
        /* For SPDIF protocol, frame length is set by hardware to 64 */
        tmpframelength = 64U;
 8013c7a:	2340      	movs	r3, #64	; 0x40
 8013c7c:	613b      	str	r3, [r7, #16]
 8013c7e:	e00a      	b.n	8013c96 <HAL_SAI_Init+0xd2>
      }
      else if (hsai->Init.Protocol == SAI_AC97_PROTOCOL)
 8013c80:	687b      	ldr	r3, [r7, #4]
 8013c82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013c84:	2b08      	cmp	r3, #8
 8013c86:	d103      	bne.n	8013c90 <HAL_SAI_Init+0xcc>
      {
        /* For AC97 protocol, frame length is set by hardware to 256 */
        tmpframelength = 256U;
 8013c88:	f44f 7380 	mov.w	r3, #256	; 0x100
 8013c8c:	613b      	str	r3, [r7, #16]
 8013c8e:	e002      	b.n	8013c96 <HAL_SAI_Init+0xd2>
      }
      else
      {
        /* For free protocol, frame length is set by user */
        tmpframelength = hsai->FrameInit.FrameLength;
 8013c90:	687b      	ldr	r3, [r7, #4]
 8013c92:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8013c94:	613b      	str	r3, [r7, #16]
      }

      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmpframelength);
 8013c96:	68fa      	ldr	r2, [r7, #12]
 8013c98:	4613      	mov	r3, r2
 8013c9a:	009b      	lsls	r3, r3, #2
 8013c9c:	4413      	add	r3, r2
 8013c9e:	005b      	lsls	r3, r3, #1
 8013ca0:	4619      	mov	r1, r3
 8013ca2:	687b      	ldr	r3, [r7, #4]
 8013ca4:	6a1b      	ldr	r3, [r3, #32]
 8013ca6:	693a      	ldr	r2, [r7, #16]
 8013ca8:	fb02 f303 	mul.w	r3, r2, r3
 8013cac:	fbb1 f3f3 	udiv	r3, r1, r3
 8013cb0:	617b      	str	r3, [r7, #20]
 8013cb2:	e017      	b.n	8013ce4 <HAL_SAI_Init+0x120>
    }
    else
    {
      /* NODIV = 0 */
      uint32_t tmposr;
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 8013cb4:	687b      	ldr	r3, [r7, #4]
 8013cb6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013cb8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8013cbc:	d101      	bne.n	8013cc2 <HAL_SAI_Init+0xfe>
 8013cbe:	2302      	movs	r3, #2
 8013cc0:	e000      	b.n	8013cc4 <HAL_SAI_Init+0x100>
 8013cc2:	2301      	movs	r3, #1
 8013cc4:	60bb      	str	r3, [r7, #8]
      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 8013cc6:	68fa      	ldr	r2, [r7, #12]
 8013cc8:	4613      	mov	r3, r2
 8013cca:	009b      	lsls	r3, r3, #2
 8013ccc:	4413      	add	r3, r2
 8013cce:	005b      	lsls	r3, r3, #1
 8013cd0:	4619      	mov	r1, r3
 8013cd2:	687b      	ldr	r3, [r7, #4]
 8013cd4:	6a1b      	ldr	r3, [r3, #32]
 8013cd6:	68ba      	ldr	r2, [r7, #8]
 8013cd8:	fb02 f303 	mul.w	r3, r2, r3
 8013cdc:	021b      	lsls	r3, r3, #8
 8013cde:	fbb1 f3f3 	udiv	r3, r1, r3
 8013ce2:	617b      	str	r3, [r7, #20]
    }
    hsai->Init.Mckdiv = tmpval / 10U;
 8013ce4:	697b      	ldr	r3, [r7, #20]
 8013ce6:	4a1e      	ldr	r2, [pc, #120]	; (8013d60 <HAL_SAI_Init+0x19c>)
 8013ce8:	fba2 2303 	umull	r2, r3, r2, r3
 8013cec:	08da      	lsrs	r2, r3, #3
 8013cee:	687b      	ldr	r3, [r7, #4]
 8013cf0:	625a      	str	r2, [r3, #36]	; 0x24

    /* Round result to the nearest integer */
    if ((tmpval % 10U) > 8U)
 8013cf2:	6979      	ldr	r1, [r7, #20]
 8013cf4:	4b1a      	ldr	r3, [pc, #104]	; (8013d60 <HAL_SAI_Init+0x19c>)
 8013cf6:	fba3 2301 	umull	r2, r3, r3, r1
 8013cfa:	08da      	lsrs	r2, r3, #3
 8013cfc:	4613      	mov	r3, r2
 8013cfe:	009b      	lsls	r3, r3, #2
 8013d00:	4413      	add	r3, r2
 8013d02:	005b      	lsls	r3, r3, #1
 8013d04:	1aca      	subs	r2, r1, r3
 8013d06:	2a08      	cmp	r2, #8
 8013d08:	d904      	bls.n	8013d14 <HAL_SAI_Init+0x150>
    {
      hsai->Init.Mckdiv += 1U;
 8013d0a:	687b      	ldr	r3, [r7, #4]
 8013d0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013d0e:	1c5a      	adds	r2, r3, #1
 8013d10:	687b      	ldr	r3, [r7, #4]
 8013d12:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* For SPDIF protocol, SAI shall provide a bit clock twice faster the symbol-rate */
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 8013d14:	687b      	ldr	r3, [r7, #4]
 8013d16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013d18:	2b04      	cmp	r3, #4
 8013d1a:	d104      	bne.n	8013d26 <HAL_SAI_Init+0x162>
    {
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 8013d1c:	687b      	ldr	r3, [r7, #4]
 8013d1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013d20:	085a      	lsrs	r2, r3, #1
 8013d22:	687b      	ldr	r3, [r7, #4]
 8013d24:	625a      	str	r2, [r3, #36]	; 0x24
  }
  /* Check the SAI Block master clock divider parameter */
  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(hsai->Init.Mckdiv));

  /* Compute CKSTR bits of SAI CR1 according ClockStrobing and AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	685b      	ldr	r3, [r3, #4]
 8013d2a:	2b00      	cmp	r3, #0
 8013d2c:	d003      	beq.n	8013d36 <HAL_SAI_Init+0x172>
 8013d2e:	687b      	ldr	r3, [r7, #4]
 8013d30:	685b      	ldr	r3, [r3, #4]
 8013d32:	2b02      	cmp	r3, #2
 8013d34:	d109      	bne.n	8013d4a <HAL_SAI_Init+0x186>
  {
    /* Transmit */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 8013d36:	687b      	ldr	r3, [r7, #4]
 8013d38:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8013d3a:	2b01      	cmp	r3, #1
 8013d3c:	d101      	bne.n	8013d42 <HAL_SAI_Init+0x17e>
 8013d3e:	2300      	movs	r3, #0
 8013d40:	e001      	b.n	8013d46 <HAL_SAI_Init+0x182>
 8013d42:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013d46:	61fb      	str	r3, [r7, #28]
 8013d48:	e00e      	b.n	8013d68 <HAL_SAI_Init+0x1a4>
  }
  else
  {
    /* Receive */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0U;
 8013d4a:	687b      	ldr	r3, [r7, #4]
 8013d4c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8013d4e:	2b01      	cmp	r3, #1
 8013d50:	d108      	bne.n	8013d64 <HAL_SAI_Init+0x1a0>
 8013d52:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013d56:	e006      	b.n	8013d66 <HAL_SAI_Init+0x1a2>
 8013d58:	40015404 	.word	0x40015404
 8013d5c:	40015400 	.word	0x40015400
 8013d60:	cccccccd 	.word	0xcccccccd
 8013d64:	2300      	movs	r3, #0
 8013d66:	61fb      	str	r3, [r7, #28]
  }

  /* SAI Block Configuration -------------------------------------------------*/
  /* SAI CR1 Configuration */
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8013d68:	687b      	ldr	r3, [r7, #4]
 8013d6a:	681b      	ldr	r3, [r3, #0]
 8013d6c:	6819      	ldr	r1, [r3, #0]
 8013d6e:	687b      	ldr	r3, [r7, #4]
 8013d70:	681a      	ldr	r2, [r3, #0]
 8013d72:	4b59      	ldr	r3, [pc, #356]	; (8013ed8 <HAL_SAI_Init+0x314>)
 8013d74:	400b      	ands	r3, r1
 8013d76:	6013      	str	r3, [r2, #0]
                           SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN | \
                           SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                           SAI_xCR1_NODIV | SAI_xCR1_MCKDIV | SAI_xCR1_OSR |     \
                           SAI_xCR1_MCKEN);

  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8013d78:	687b      	ldr	r3, [r7, #4]
 8013d7a:	681b      	ldr	r3, [r3, #0]
 8013d7c:	6819      	ldr	r1, [r3, #0]
 8013d7e:	687b      	ldr	r3, [r7, #4]
 8013d80:	685a      	ldr	r2, [r3, #4]
 8013d82:	687b      	ldr	r3, [r7, #4]
 8013d84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013d86:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 8013d88:	687b      	ldr	r3, [r7, #4]
 8013d8a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8013d8c:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 8013d8e:	687b      	ldr	r3, [r7, #4]
 8013d90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8013d92:	431a      	orrs	r2, r3
 8013d94:	69fb      	ldr	r3, [r7, #28]
 8013d96:	431a      	orrs	r2, r3
                          ckstr_bits | syncen_bits |                             \
 8013d98:	69bb      	ldr	r3, [r7, #24]
 8013d9a:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8013d9c:	687b      	ldr	r3, [r7, #4]
 8013d9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                          ckstr_bits | syncen_bits |                             \
 8013da0:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8013da2:	687b      	ldr	r3, [r7, #4]
 8013da4:	695b      	ldr	r3, [r3, #20]
 8013da6:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 8013da8:	687b      	ldr	r3, [r7, #4]
 8013daa:	699b      	ldr	r3, [r3, #24]
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8013dac:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 8013dae:	687b      	ldr	r3, [r7, #4]
 8013db0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013db2:	051b      	lsls	r3, r3, #20
 8013db4:	431a      	orrs	r2, r3
                          hsai->Init.MckOverSampling | hsai->Init.MckOutput);
 8013db6:	687b      	ldr	r3, [r7, #4]
 8013db8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 8013dba:	431a      	orrs	r2, r3
                          hsai->Init.MckOverSampling | hsai->Init.MckOutput);
 8013dbc:	687b      	ldr	r3, [r7, #4]
 8013dbe:	691b      	ldr	r3, [r3, #16]
 8013dc0:	431a      	orrs	r2, r3
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8013dc2:	687b      	ldr	r3, [r7, #4]
 8013dc4:	681b      	ldr	r3, [r3, #0]
 8013dc6:	430a      	orrs	r2, r1
 8013dc8:	601a      	str	r2, [r3, #0]

  /* SAI CR2 Configuration */
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8013dca:	687b      	ldr	r3, [r7, #4]
 8013dcc:	681b      	ldr	r3, [r3, #0]
 8013dce:	685b      	ldr	r3, [r3, #4]
 8013dd0:	687a      	ldr	r2, [r7, #4]
 8013dd2:	6812      	ldr	r2, [r2, #0]
 8013dd4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8013dd8:	f023 030f 	bic.w	r3, r3, #15
 8013ddc:	6053      	str	r3, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8013dde:	687b      	ldr	r3, [r7, #4]
 8013de0:	681b      	ldr	r3, [r3, #0]
 8013de2:	6859      	ldr	r1, [r3, #4]
 8013de4:	687b      	ldr	r3, [r7, #4]
 8013de6:	69da      	ldr	r2, [r3, #28]
 8013de8:	687b      	ldr	r3, [r7, #4]
 8013dea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013dec:	431a      	orrs	r2, r3
 8013dee:	687b      	ldr	r3, [r7, #4]
 8013df0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8013df2:	431a      	orrs	r2, r3
 8013df4:	687b      	ldr	r3, [r7, #4]
 8013df6:	681b      	ldr	r3, [r3, #0]
 8013df8:	430a      	orrs	r2, r1
 8013dfa:	605a      	str	r2, [r3, #4]

  /* SAI Frame Configuration -----------------------------------------*/
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8013dfc:	687b      	ldr	r3, [r7, #4]
 8013dfe:	681b      	ldr	r3, [r3, #0]
 8013e00:	6899      	ldr	r1, [r3, #8]
 8013e02:	687b      	ldr	r3, [r7, #4]
 8013e04:	681a      	ldr	r2, [r3, #0]
 8013e06:	4b35      	ldr	r3, [pc, #212]	; (8013edc <HAL_SAI_Init+0x318>)
 8013e08:	400b      	ands	r3, r1
 8013e0a:	6093      	str	r3, [r2, #8]
                             SAI_xFRCR_FSPOL | SAI_xFRCR_FSOFF));
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 8013e0c:	687b      	ldr	r3, [r7, #4]
 8013e0e:	681b      	ldr	r3, [r3, #0]
 8013e10:	6899      	ldr	r1, [r3, #8]
 8013e12:	687b      	ldr	r3, [r7, #4]
 8013e14:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8013e16:	1e5a      	subs	r2, r3, #1
                           hsai->FrameInit.FSOffset |
 8013e18:	687b      	ldr	r3, [r7, #4]
 8013e1a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 8013e1c:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSDefinition |
 8013e1e:	687b      	ldr	r3, [r7, #4]
 8013e20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
                           hsai->FrameInit.FSOffset |
 8013e22:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSPolarity   |
 8013e24:	687b      	ldr	r3, [r7, #4]
 8013e26:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                           hsai->FrameInit.FSDefinition |
 8013e28:	431a      	orrs	r2, r3
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 8013e2a:	687b      	ldr	r3, [r7, #4]
 8013e2c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8013e2e:	3b01      	subs	r3, #1
 8013e30:	021b      	lsls	r3, r3, #8
                           hsai->FrameInit.FSPolarity   |
 8013e32:	431a      	orrs	r2, r3
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 8013e34:	687b      	ldr	r3, [r7, #4]
 8013e36:	681b      	ldr	r3, [r3, #0]
 8013e38:	430a      	orrs	r2, r1
 8013e3a:	609a      	str	r2, [r3, #8]

  /* SAI Block_x SLOT Configuration ------------------------------------------*/
  /* This register has no meaning in AC 97 and SPDIF audio protocol */
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 8013e3c:	687b      	ldr	r3, [r7, #4]
 8013e3e:	681b      	ldr	r3, [r3, #0]
 8013e40:	68d9      	ldr	r1, [r3, #12]
 8013e42:	687b      	ldr	r3, [r7, #4]
 8013e44:	681a      	ldr	r2, [r3, #0]
 8013e46:	f24f 0320 	movw	r3, #61472	; 0xf020
 8013e4a:	400b      	ands	r3, r1
 8013e4c:	60d3      	str	r3, [r2, #12]
                              SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN));

  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 8013e4e:	687b      	ldr	r3, [r7, #4]
 8013e50:	681b      	ldr	r3, [r3, #0]
 8013e52:	68d9      	ldr	r1, [r3, #12]
 8013e54:	687b      	ldr	r3, [r7, #4]
 8013e56:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8013e58:	687b      	ldr	r3, [r7, #4]
 8013e5a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8013e5c:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 8013e5e:	687b      	ldr	r3, [r7, #4]
 8013e60:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013e62:	041b      	lsls	r3, r3, #16
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 8013e64:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 8013e66:	687b      	ldr	r3, [r7, #4]
 8013e68:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013e6a:	3b01      	subs	r3, #1
 8013e6c:	021b      	lsls	r3, r3, #8
 8013e6e:	431a      	orrs	r2, r3
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 8013e70:	687b      	ldr	r3, [r7, #4]
 8013e72:	681b      	ldr	r3, [r3, #0]
 8013e74:	430a      	orrs	r2, r1
 8013e76:	60da      	str	r2, [r3, #12]

  /* SAI PDM Configuration ---------------------------------------------------*/
  if (hsai->Instance == SAI1_Block_A)
 8013e78:	687b      	ldr	r3, [r7, #4]
 8013e7a:	681b      	ldr	r3, [r3, #0]
 8013e7c:	4a18      	ldr	r2, [pc, #96]	; (8013ee0 <HAL_SAI_Init+0x31c>)
 8013e7e:	4293      	cmp	r3, r2
 8013e80:	d119      	bne.n	8013eb6 <HAL_SAI_Init+0x2f2>
  {
    /* Disable PDM interface */
    SAI1->PDMCR &= ~(SAI_PDMCR_PDMEN);
 8013e82:	4b18      	ldr	r3, [pc, #96]	; (8013ee4 <HAL_SAI_Init+0x320>)
 8013e84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013e86:	4a17      	ldr	r2, [pc, #92]	; (8013ee4 <HAL_SAI_Init+0x320>)
 8013e88:	f023 0301 	bic.w	r3, r3, #1
 8013e8c:	6453      	str	r3, [r2, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
 8013e8e:	687b      	ldr	r3, [r7, #4]
 8013e90:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8013e94:	2b01      	cmp	r3, #1
 8013e96:	d10e      	bne.n	8013eb6 <HAL_SAI_Init+0x2f2>
    {
      /* Configure and enable PDM interface */
      SAI1->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 8013e98:	687b      	ldr	r3, [r7, #4]
 8013e9a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                     ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
 8013e9c:	687b      	ldr	r3, [r7, #4]
 8013e9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013ea0:	3b01      	subs	r3, #1
 8013ea2:	011b      	lsls	r3, r3, #4
      SAI1->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 8013ea4:	490f      	ldr	r1, [pc, #60]	; (8013ee4 <HAL_SAI_Init+0x320>)
 8013ea6:	4313      	orrs	r3, r2
 8013ea8:	644b      	str	r3, [r1, #68]	; 0x44
      SAI1->PDMCR |= SAI_PDMCR_PDMEN;
 8013eaa:	4b0e      	ldr	r3, [pc, #56]	; (8013ee4 <HAL_SAI_Init+0x320>)
 8013eac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8013eae:	4a0d      	ldr	r2, [pc, #52]	; (8013ee4 <HAL_SAI_Init+0x320>)
 8013eb0:	f043 0301 	orr.w	r3, r3, #1
 8013eb4:	6453      	str	r3, [r2, #68]	; 0x44
    }
  }

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8013eb6:	687b      	ldr	r3, [r7, #4]
 8013eb8:	2200      	movs	r2, #0
 8013eba:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_READY;
 8013ebe:	687b      	ldr	r3, [r7, #4]
 8013ec0:	2201      	movs	r2, #1
 8013ec2:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* Release Lock */
  __HAL_UNLOCK(hsai);
 8013ec6:	687b      	ldr	r3, [r7, #4]
 8013ec8:	2200      	movs	r2, #0
 8013eca:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return HAL_OK;
 8013ece:	2300      	movs	r3, #0
}
 8013ed0:	4618      	mov	r0, r3
 8013ed2:	3720      	adds	r7, #32
 8013ed4:	46bd      	mov	sp, r7
 8013ed6:	bd80      	pop	{r7, pc}
 8013ed8:	f005c010 	.word	0xf005c010
 8013edc:	fff88000 	.word	0xfff88000
 8013ee0:	40015404 	.word	0x40015404
 8013ee4:	40015400 	.word	0x40015400

08013ee8 <SAI_InitI2S>:
  * @param  nbslot number of slot minimum value is 2 and max is 16.
  *         the value must be a multiple of 2.
  * @retval HAL status
  */
static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 8013ee8:	b480      	push	{r7}
 8013eea:	b087      	sub	sp, #28
 8013eec:	af00      	add	r7, sp, #0
 8013eee:	60f8      	str	r0, [r7, #12]
 8013ef0:	60b9      	str	r1, [r7, #8]
 8013ef2:	607a      	str	r2, [r7, #4]
 8013ef4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8013ef6:	2300      	movs	r3, #0
 8013ef8:	75fb      	strb	r3, [r7, #23]

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 8013efa:	68fb      	ldr	r3, [r7, #12]
 8013efc:	2200      	movs	r2, #0
 8013efe:	645a      	str	r2, [r3, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 8013f00:	68fb      	ldr	r3, [r7, #12]
 8013f02:	2200      	movs	r2, #0
 8013f04:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8013f06:	68fb      	ldr	r3, [r7, #12]
 8013f08:	685b      	ldr	r3, [r3, #4]
 8013f0a:	2b00      	cmp	r3, #0
 8013f0c:	d003      	beq.n	8013f16 <SAI_InitI2S+0x2e>
 8013f0e:	68fb      	ldr	r3, [r7, #12]
 8013f10:	685b      	ldr	r3, [r3, #4]
 8013f12:	2b02      	cmp	r3, #2
 8013f14:	d103      	bne.n	8013f1e <SAI_InitI2S+0x36>
  {
    /* Transmit */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
 8013f16:	68fb      	ldr	r3, [r7, #12]
 8013f18:	2200      	movs	r2, #0
 8013f1a:	651a      	str	r2, [r3, #80]	; 0x50
 8013f1c:	e002      	b.n	8013f24 <SAI_InitI2S+0x3c>
  }
  else
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_RISINGEDGE;
 8013f1e:	68fb      	ldr	r3, [r7, #12]
 8013f20:	2201      	movs	r2, #1
 8013f22:	651a      	str	r2, [r3, #80]	; 0x50
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 8013f24:	68fb      	ldr	r3, [r7, #12]
 8013f26:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8013f2a:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 8013f2c:	68fb      	ldr	r3, [r7, #12]
 8013f2e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013f32:	675a      	str	r2, [r3, #116]	; 0x74
  hsai->SlotInit.FirstBitOffset  = 0;
 8013f34:	68fb      	ldr	r3, [r7, #12]
 8013f36:	2200      	movs	r2, #0
 8013f38:	669a      	str	r2, [r3, #104]	; 0x68
  hsai->SlotInit.SlotNumber      = nbslot;
 8013f3a:	68fb      	ldr	r3, [r7, #12]
 8013f3c:	683a      	ldr	r2, [r7, #0]
 8013f3e:	671a      	str	r2, [r3, #112]	; 0x70

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
 8013f40:	683b      	ldr	r3, [r7, #0]
 8013f42:	f003 0301 	and.w	r3, r3, #1
 8013f46:	2b00      	cmp	r3, #0
 8013f48:	d001      	beq.n	8013f4e <SAI_InitI2S+0x66>
  {
    return HAL_ERROR;
 8013f4a:	2301      	movs	r3, #1
 8013f4c:	e077      	b.n	801403e <SAI_InitI2S+0x156>
  }

  if (protocol == SAI_I2S_STANDARD)
 8013f4e:	68bb      	ldr	r3, [r7, #8]
 8013f50:	2b00      	cmp	r3, #0
 8013f52:	d107      	bne.n	8013f64 <SAI_InitI2S+0x7c>
  {
    hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8013f54:	68fb      	ldr	r3, [r7, #12]
 8013f56:	2200      	movs	r2, #0
 8013f58:	661a      	str	r2, [r3, #96]	; 0x60
    hsai->FrameInit.FSOffset   = SAI_FS_BEFOREFIRSTBIT;
 8013f5a:	68fb      	ldr	r3, [r7, #12]
 8013f5c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8013f60:	665a      	str	r2, [r3, #100]	; 0x64
 8013f62:	e006      	b.n	8013f72 <SAI_InitI2S+0x8a>
  }
  else
  {
     /* SAI_I2S_MSBJUSTIFIED or SAI_I2S_LSBJUSTIFIED */
    hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_HIGH;
 8013f64:	68fb      	ldr	r3, [r7, #12]
 8013f66:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8013f6a:	661a      	str	r2, [r3, #96]	; 0x60
    hsai->FrameInit.FSOffset   = SAI_FS_FIRSTBIT;
 8013f6c:	68fb      	ldr	r3, [r7, #12]
 8013f6e:	2200      	movs	r2, #0
 8013f70:	665a      	str	r2, [r3, #100]	; 0x64
 8013f72:	687b      	ldr	r3, [r7, #4]
 8013f74:	2b03      	cmp	r3, #3
 8013f76:	d84f      	bhi.n	8014018 <SAI_InitI2S+0x130>
 8013f78:	a201      	add	r2, pc, #4	; (adr r2, 8013f80 <SAI_InitI2S+0x98>)
 8013f7a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013f7e:	bf00      	nop
 8013f80:	08013f91 	.word	0x08013f91
 8013f84:	08013fb3 	.word	0x08013fb3
 8013f88:	08013fd5 	.word	0x08013fd5
 8013f8c:	08013ff7 	.word	0x08013ff7

  /* Frame definition */
  switch (datasize)
  {
    case SAI_PROTOCOL_DATASIZE_16BIT:
      hsai->Init.DataSize = SAI_DATASIZE_16;
 8013f90:	68fb      	ldr	r3, [r7, #12]
 8013f92:	2280      	movs	r2, #128	; 0x80
 8013f94:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 8013f96:	683b      	ldr	r3, [r7, #0]
 8013f98:	085b      	lsrs	r3, r3, #1
 8013f9a:	015a      	lsls	r2, r3, #5
 8013f9c:	68fb      	ldr	r3, [r7, #12]
 8013f9e:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 8013fa0:	683b      	ldr	r3, [r7, #0]
 8013fa2:	085b      	lsrs	r3, r3, #1
 8013fa4:	011a      	lsls	r2, r3, #4
 8013fa6:	68fb      	ldr	r3, [r7, #12]
 8013fa8:	659a      	str	r2, [r3, #88]	; 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 8013faa:	68fb      	ldr	r3, [r7, #12]
 8013fac:	2240      	movs	r2, #64	; 0x40
 8013fae:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 8013fb0:	e035      	b.n	801401e <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
      hsai->Init.DataSize = SAI_DATASIZE_16;
 8013fb2:	68fb      	ldr	r3, [r7, #12]
 8013fb4:	2280      	movs	r2, #128	; 0x80
 8013fb6:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 8013fb8:	683b      	ldr	r3, [r7, #0]
 8013fba:	085b      	lsrs	r3, r3, #1
 8013fbc:	019a      	lsls	r2, r3, #6
 8013fbe:	68fb      	ldr	r3, [r7, #12]
 8013fc0:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 8013fc2:	683b      	ldr	r3, [r7, #0]
 8013fc4:	085b      	lsrs	r3, r3, #1
 8013fc6:	015a      	lsls	r2, r3, #5
 8013fc8:	68fb      	ldr	r3, [r7, #12]
 8013fca:	659a      	str	r2, [r3, #88]	; 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 8013fcc:	68fb      	ldr	r3, [r7, #12]
 8013fce:	2280      	movs	r2, #128	; 0x80
 8013fd0:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 8013fd2:	e024      	b.n	801401e <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_24BIT:
      hsai->Init.DataSize = SAI_DATASIZE_24;
 8013fd4:	68fb      	ldr	r3, [r7, #12]
 8013fd6:	22c0      	movs	r2, #192	; 0xc0
 8013fd8:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 8013fda:	683b      	ldr	r3, [r7, #0]
 8013fdc:	085b      	lsrs	r3, r3, #1
 8013fde:	019a      	lsls	r2, r3, #6
 8013fe0:	68fb      	ldr	r3, [r7, #12]
 8013fe2:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 8013fe4:	683b      	ldr	r3, [r7, #0]
 8013fe6:	085b      	lsrs	r3, r3, #1
 8013fe8:	015a      	lsls	r2, r3, #5
 8013fea:	68fb      	ldr	r3, [r7, #12]
 8013fec:	659a      	str	r2, [r3, #88]	; 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 8013fee:	68fb      	ldr	r3, [r7, #12]
 8013ff0:	2280      	movs	r2, #128	; 0x80
 8013ff2:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 8013ff4:	e013      	b.n	801401e <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
 8013ff6:	68fb      	ldr	r3, [r7, #12]
 8013ff8:	22e0      	movs	r2, #224	; 0xe0
 8013ffa:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 8013ffc:	683b      	ldr	r3, [r7, #0]
 8013ffe:	085b      	lsrs	r3, r3, #1
 8014000:	019a      	lsls	r2, r3, #6
 8014002:	68fb      	ldr	r3, [r7, #12]
 8014004:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 8014006:	683b      	ldr	r3, [r7, #0]
 8014008:	085b      	lsrs	r3, r3, #1
 801400a:	015a      	lsls	r2, r3, #5
 801400c:	68fb      	ldr	r3, [r7, #12]
 801400e:	659a      	str	r2, [r3, #88]	; 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 8014010:	68fb      	ldr	r3, [r7, #12]
 8014012:	2280      	movs	r2, #128	; 0x80
 8014014:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 8014016:	e002      	b.n	801401e <SAI_InitI2S+0x136>
    default :
      status = HAL_ERROR;
 8014018:	2301      	movs	r3, #1
 801401a:	75fb      	strb	r3, [r7, #23]
      break;
 801401c:	bf00      	nop
  }
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 801401e:	68bb      	ldr	r3, [r7, #8]
 8014020:	2b02      	cmp	r3, #2
 8014022:	d10b      	bne.n	801403c <SAI_InitI2S+0x154>
  {
    if (datasize == SAI_PROTOCOL_DATASIZE_16BITEXTENDED)
 8014024:	687b      	ldr	r3, [r7, #4]
 8014026:	2b01      	cmp	r3, #1
 8014028:	d102      	bne.n	8014030 <SAI_InitI2S+0x148>
    {
      hsai->SlotInit.FirstBitOffset = 16;
 801402a:	68fb      	ldr	r3, [r7, #12]
 801402c:	2210      	movs	r2, #16
 801402e:	669a      	str	r2, [r3, #104]	; 0x68
    }
    if (datasize == SAI_PROTOCOL_DATASIZE_24BIT)
 8014030:	687b      	ldr	r3, [r7, #4]
 8014032:	2b02      	cmp	r3, #2
 8014034:	d102      	bne.n	801403c <SAI_InitI2S+0x154>
    {
      hsai->SlotInit.FirstBitOffset = 8;
 8014036:	68fb      	ldr	r3, [r7, #12]
 8014038:	2208      	movs	r2, #8
 801403a:	669a      	str	r2, [r3, #104]	; 0x68
    }
  }
  return status;
 801403c:	7dfb      	ldrb	r3, [r7, #23]
}
 801403e:	4618      	mov	r0, r3
 8014040:	371c      	adds	r7, #28
 8014042:	46bd      	mov	sp, r7
 8014044:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014048:	4770      	bx	lr
 801404a:	bf00      	nop

0801404c <SAI_InitPCM>:
  * @param  datasize one of the supported datasize @ref SAI_Protocol_DataSize
  * @param  nbslot number of slot minimum value is 1 and the max is 16.
  * @retval HAL status
  */
static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 801404c:	b480      	push	{r7}
 801404e:	b087      	sub	sp, #28
 8014050:	af00      	add	r7, sp, #0
 8014052:	60f8      	str	r0, [r7, #12]
 8014054:	60b9      	str	r1, [r7, #8]
 8014056:	607a      	str	r2, [r7, #4]
 8014058:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 801405a:	2300      	movs	r3, #0
 801405c:	75fb      	strb	r3, [r7, #23]

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 801405e:	68fb      	ldr	r3, [r7, #12]
 8014060:	2200      	movs	r2, #0
 8014062:	645a      	str	r2, [r3, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 8014064:	68fb      	ldr	r3, [r7, #12]
 8014066:	2200      	movs	r2, #0
 8014068:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 801406a:	68fb      	ldr	r3, [r7, #12]
 801406c:	685b      	ldr	r3, [r3, #4]
 801406e:	2b00      	cmp	r3, #0
 8014070:	d003      	beq.n	801407a <SAI_InitPCM+0x2e>
 8014072:	68fb      	ldr	r3, [r7, #12]
 8014074:	685b      	ldr	r3, [r3, #4]
 8014076:	2b02      	cmp	r3, #2
 8014078:	d103      	bne.n	8014082 <SAI_InitPCM+0x36>
  {
    /* Transmit */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_RISINGEDGE;
 801407a:	68fb      	ldr	r3, [r7, #12]
 801407c:	2201      	movs	r2, #1
 801407e:	651a      	str	r2, [r3, #80]	; 0x50
 8014080:	e002      	b.n	8014088 <SAI_InitPCM+0x3c>
  }
  else
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
 8014082:	68fb      	ldr	r3, [r7, #12]
 8014084:	2200      	movs	r2, #0
 8014086:	651a      	str	r2, [r3, #80]	; 0x50
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
 8014088:	68fb      	ldr	r3, [r7, #12]
 801408a:	2200      	movs	r2, #0
 801408c:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
 801408e:	68fb      	ldr	r3, [r7, #12]
 8014090:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8014094:	661a      	str	r2, [r3, #96]	; 0x60
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 8014096:	68fb      	ldr	r3, [r7, #12]
 8014098:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 801409c:	665a      	str	r2, [r3, #100]	; 0x64
  hsai->SlotInit.FirstBitOffset  = 0;
 801409e:	68fb      	ldr	r3, [r7, #12]
 80140a0:	2200      	movs	r2, #0
 80140a2:	669a      	str	r2, [r3, #104]	; 0x68
  hsai->SlotInit.SlotNumber      = nbslot;
 80140a4:	68fb      	ldr	r3, [r7, #12]
 80140a6:	683a      	ldr	r2, [r7, #0]
 80140a8:	671a      	str	r2, [r3, #112]	; 0x70
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 80140aa:	68fb      	ldr	r3, [r7, #12]
 80140ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80140b0:	675a      	str	r2, [r3, #116]	; 0x74

  if (protocol == SAI_PCM_SHORT)
 80140b2:	68bb      	ldr	r3, [r7, #8]
 80140b4:	2b04      	cmp	r3, #4
 80140b6:	d103      	bne.n	80140c0 <SAI_InitPCM+0x74>
  {
    hsai->FrameInit.ActiveFrameLength = 1;
 80140b8:	68fb      	ldr	r3, [r7, #12]
 80140ba:	2201      	movs	r2, #1
 80140bc:	659a      	str	r2, [r3, #88]	; 0x58
 80140be:	e002      	b.n	80140c6 <SAI_InitPCM+0x7a>
  }
  else
  {
    /* SAI_PCM_LONG */
    hsai->FrameInit.ActiveFrameLength = 13;
 80140c0:	68fb      	ldr	r3, [r7, #12]
 80140c2:	220d      	movs	r2, #13
 80140c4:	659a      	str	r2, [r3, #88]	; 0x58
 80140c6:	687b      	ldr	r3, [r7, #4]
 80140c8:	2b03      	cmp	r3, #3
 80140ca:	d837      	bhi.n	801413c <SAI_InitPCM+0xf0>
 80140cc:	a201      	add	r2, pc, #4	; (adr r2, 80140d4 <SAI_InitPCM+0x88>)
 80140ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80140d2:	bf00      	nop
 80140d4:	080140e5 	.word	0x080140e5
 80140d8:	080140fb 	.word	0x080140fb
 80140dc:	08014111 	.word	0x08014111
 80140e0:	08014127 	.word	0x08014127
  }

  switch (datasize)
  {
    case SAI_PROTOCOL_DATASIZE_16BIT:
      hsai->Init.DataSize = SAI_DATASIZE_16;
 80140e4:	68fb      	ldr	r3, [r7, #12]
 80140e6:	2280      	movs	r2, #128	; 0x80
 80140e8:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 16U * nbslot;
 80140ea:	683b      	ldr	r3, [r7, #0]
 80140ec:	011a      	lsls	r2, r3, #4
 80140ee:	68fb      	ldr	r3, [r7, #12]
 80140f0:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 80140f2:	68fb      	ldr	r3, [r7, #12]
 80140f4:	2240      	movs	r2, #64	; 0x40
 80140f6:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 80140f8:	e023      	b.n	8014142 <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
      hsai->Init.DataSize = SAI_DATASIZE_16;
 80140fa:	68fb      	ldr	r3, [r7, #12]
 80140fc:	2280      	movs	r2, #128	; 0x80
 80140fe:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 8014100:	683b      	ldr	r3, [r7, #0]
 8014102:	015a      	lsls	r2, r3, #5
 8014104:	68fb      	ldr	r3, [r7, #12]
 8014106:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 8014108:	68fb      	ldr	r3, [r7, #12]
 801410a:	2280      	movs	r2, #128	; 0x80
 801410c:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 801410e:	e018      	b.n	8014142 <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_24BIT :
      hsai->Init.DataSize = SAI_DATASIZE_24;
 8014110:	68fb      	ldr	r3, [r7, #12]
 8014112:	22c0      	movs	r2, #192	; 0xc0
 8014114:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 8014116:	683b      	ldr	r3, [r7, #0]
 8014118:	015a      	lsls	r2, r3, #5
 801411a:	68fb      	ldr	r3, [r7, #12]
 801411c:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 801411e:	68fb      	ldr	r3, [r7, #12]
 8014120:	2280      	movs	r2, #128	; 0x80
 8014122:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 8014124:	e00d      	b.n	8014142 <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
 8014126:	68fb      	ldr	r3, [r7, #12]
 8014128:	22e0      	movs	r2, #224	; 0xe0
 801412a:	649a      	str	r2, [r3, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 801412c:	683b      	ldr	r3, [r7, #0]
 801412e:	015a      	lsls	r2, r3, #5
 8014130:	68fb      	ldr	r3, [r7, #12]
 8014132:	655a      	str	r2, [r3, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 8014134:	68fb      	ldr	r3, [r7, #12]
 8014136:	2280      	movs	r2, #128	; 0x80
 8014138:	66da      	str	r2, [r3, #108]	; 0x6c
      break;
 801413a:	e002      	b.n	8014142 <SAI_InitPCM+0xf6>
    default :
      status = HAL_ERROR;
 801413c:	2301      	movs	r3, #1
 801413e:	75fb      	strb	r3, [r7, #23]
      break;
 8014140:	bf00      	nop
  }

  return status;
 8014142:	7dfb      	ldrb	r3, [r7, #23]
}
 8014144:	4618      	mov	r0, r3
 8014146:	371c      	adds	r7, #28
 8014148:	46bd      	mov	sp, r7
 801414a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801414e:	4770      	bx	lr

08014150 <SAI_Disable>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
 8014150:	b480      	push	{r7}
 8014152:	b085      	sub	sp, #20
 8014154:	af00      	add	r7, sp, #0
 8014156:	6078      	str	r0, [r7, #4]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 8014158:	4b18      	ldr	r3, [pc, #96]	; (80141bc <SAI_Disable+0x6c>)
 801415a:	681b      	ldr	r3, [r3, #0]
 801415c:	4a18      	ldr	r2, [pc, #96]	; (80141c0 <SAI_Disable+0x70>)
 801415e:	fba2 2303 	umull	r2, r3, r2, r3
 8014162:	0b1b      	lsrs	r3, r3, #12
 8014164:	009b      	lsls	r3, r3, #2
 8014166:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef status = HAL_OK;
 8014168:	2300      	movs	r3, #0
 801416a:	72fb      	strb	r3, [r7, #11]

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 801416c:	687b      	ldr	r3, [r7, #4]
 801416e:	681b      	ldr	r3, [r3, #0]
 8014170:	681a      	ldr	r2, [r3, #0]
 8014172:	687b      	ldr	r3, [r7, #4]
 8014174:	681b      	ldr	r3, [r3, #0]
 8014176:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 801417a:	601a      	str	r2, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
 801417c:	68fb      	ldr	r3, [r7, #12]
 801417e:	2b00      	cmp	r3, #0
 8014180:	d10a      	bne.n	8014198 <SAI_Disable+0x48>
    {
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8014182:	687b      	ldr	r3, [r7, #4]
 8014184:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8014188:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 801418c:	687b      	ldr	r3, [r7, #4]
 801418e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      status = HAL_TIMEOUT;
 8014192:	2303      	movs	r3, #3
 8014194:	72fb      	strb	r3, [r7, #11]
      break;
 8014196:	e009      	b.n	80141ac <SAI_Disable+0x5c>
    }
    count--;
 8014198:	68fb      	ldr	r3, [r7, #12]
 801419a:	3b01      	subs	r3, #1
 801419c:	60fb      	str	r3, [r7, #12]
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 801419e:	687b      	ldr	r3, [r7, #4]
 80141a0:	681b      	ldr	r3, [r3, #0]
 80141a2:	681b      	ldr	r3, [r3, #0]
 80141a4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80141a8:	2b00      	cmp	r3, #0
 80141aa:	d1e7      	bne.n	801417c <SAI_Disable+0x2c>

  return status;
 80141ac:	7afb      	ldrb	r3, [r7, #11]
}
 80141ae:	4618      	mov	r0, r3
 80141b0:	3714      	adds	r7, #20
 80141b2:	46bd      	mov	sp, r7
 80141b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80141b8:	4770      	bx	lr
 80141ba:	bf00      	nop
 80141bc:	20000010 	.word	0x20000010
 80141c0:	95cbec1b 	.word	0x95cbec1b

080141c4 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80141c4:	b580      	push	{r7, lr}
 80141c6:	b084      	sub	sp, #16
 80141c8:	af00      	add	r7, sp, #0
 80141ca:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80141cc:	687b      	ldr	r3, [r7, #4]
 80141ce:	2b00      	cmp	r3, #0
 80141d0:	d101      	bne.n	80141d6 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80141d2:	2301      	movs	r3, #1
 80141d4:	e095      	b.n	8014302 <HAL_SPI_Init+0x13e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80141d6:	687b      	ldr	r3, [r7, #4]
 80141d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80141da:	2b00      	cmp	r3, #0
 80141dc:	d108      	bne.n	80141f0 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80141de:	687b      	ldr	r3, [r7, #4]
 80141e0:	685b      	ldr	r3, [r3, #4]
 80141e2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80141e6:	d009      	beq.n	80141fc <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80141e8:	687b      	ldr	r3, [r7, #4]
 80141ea:	2200      	movs	r2, #0
 80141ec:	61da      	str	r2, [r3, #28]
 80141ee:	e005      	b.n	80141fc <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80141f0:	687b      	ldr	r3, [r7, #4]
 80141f2:	2200      	movs	r2, #0
 80141f4:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 80141f6:	687b      	ldr	r3, [r7, #4]
 80141f8:	2200      	movs	r2, #0
 80141fa:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80141fc:	687b      	ldr	r3, [r7, #4]
 80141fe:	2200      	movs	r2, #0
 8014200:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8014202:	687b      	ldr	r3, [r7, #4]
 8014204:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8014208:	b2db      	uxtb	r3, r3
 801420a:	2b00      	cmp	r3, #0
 801420c:	d106      	bne.n	801421c <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 801420e:	687b      	ldr	r3, [r7, #4]
 8014210:	2200      	movs	r2, #0
 8014212:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8014216:	6878      	ldr	r0, [r7, #4]
 8014218:	f7f7 fe16 	bl	800be48 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 801421c:	687b      	ldr	r3, [r7, #4]
 801421e:	2202      	movs	r2, #2
 8014220:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8014224:	687b      	ldr	r3, [r7, #4]
 8014226:	681b      	ldr	r3, [r3, #0]
 8014228:	681a      	ldr	r2, [r3, #0]
 801422a:	687b      	ldr	r3, [r7, #4]
 801422c:	681b      	ldr	r3, [r3, #0]
 801422e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8014232:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8014234:	687b      	ldr	r3, [r7, #4]
 8014236:	68db      	ldr	r3, [r3, #12]
 8014238:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801423c:	d902      	bls.n	8014244 <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 801423e:	2300      	movs	r3, #0
 8014240:	60fb      	str	r3, [r7, #12]
 8014242:	e002      	b.n	801424a <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8014244:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8014248:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 801424a:	687b      	ldr	r3, [r7, #4]
 801424c:	68db      	ldr	r3, [r3, #12]
 801424e:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8014252:	d007      	beq.n	8014264 <HAL_SPI_Init+0xa0>
 8014254:	687b      	ldr	r3, [r7, #4]
 8014256:	68db      	ldr	r3, [r3, #12]
 8014258:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801425c:	d002      	beq.n	8014264 <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801425e:	687b      	ldr	r3, [r7, #4]
 8014260:	2200      	movs	r2, #0
 8014262:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8014264:	687b      	ldr	r3, [r7, #4]
 8014266:	685b      	ldr	r3, [r3, #4]
 8014268:	f403 7282 	and.w	r2, r3, #260	; 0x104
 801426c:	687b      	ldr	r3, [r7, #4]
 801426e:	689b      	ldr	r3, [r3, #8]
 8014270:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 8014274:	431a      	orrs	r2, r3
 8014276:	687b      	ldr	r3, [r7, #4]
 8014278:	691b      	ldr	r3, [r3, #16]
 801427a:	f003 0302 	and.w	r3, r3, #2
 801427e:	431a      	orrs	r2, r3
 8014280:	687b      	ldr	r3, [r7, #4]
 8014282:	695b      	ldr	r3, [r3, #20]
 8014284:	f003 0301 	and.w	r3, r3, #1
 8014288:	431a      	orrs	r2, r3
 801428a:	687b      	ldr	r3, [r7, #4]
 801428c:	699b      	ldr	r3, [r3, #24]
 801428e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8014292:	431a      	orrs	r2, r3
 8014294:	687b      	ldr	r3, [r7, #4]
 8014296:	69db      	ldr	r3, [r3, #28]
 8014298:	f003 0338 	and.w	r3, r3, #56	; 0x38
 801429c:	431a      	orrs	r2, r3
 801429e:	687b      	ldr	r3, [r7, #4]
 80142a0:	6a1b      	ldr	r3, [r3, #32]
 80142a2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80142a6:	ea42 0103 	orr.w	r1, r2, r3
 80142aa:	687b      	ldr	r3, [r7, #4]
 80142ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80142ae:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 80142b2:	687b      	ldr	r3, [r7, #4]
 80142b4:	681b      	ldr	r3, [r3, #0]
 80142b6:	430a      	orrs	r2, r1
 80142b8:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80142ba:	687b      	ldr	r3, [r7, #4]
 80142bc:	699b      	ldr	r3, [r3, #24]
 80142be:	0c1b      	lsrs	r3, r3, #16
 80142c0:	f003 0204 	and.w	r2, r3, #4
 80142c4:	687b      	ldr	r3, [r7, #4]
 80142c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80142c8:	f003 0310 	and.w	r3, r3, #16
 80142cc:	431a      	orrs	r2, r3
 80142ce:	687b      	ldr	r3, [r7, #4]
 80142d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80142d2:	f003 0308 	and.w	r3, r3, #8
 80142d6:	431a      	orrs	r2, r3
 80142d8:	687b      	ldr	r3, [r7, #4]
 80142da:	68db      	ldr	r3, [r3, #12]
 80142dc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80142e0:	ea42 0103 	orr.w	r1, r2, r3
 80142e4:	68fb      	ldr	r3, [r7, #12]
 80142e6:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 80142ea:	687b      	ldr	r3, [r7, #4]
 80142ec:	681b      	ldr	r3, [r3, #0]
 80142ee:	430a      	orrs	r2, r1
 80142f0:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80142f2:	687b      	ldr	r3, [r7, #4]
 80142f4:	2200      	movs	r2, #0
 80142f6:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80142f8:	687b      	ldr	r3, [r7, #4]
 80142fa:	2201      	movs	r2, #1
 80142fc:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 8014300:	2300      	movs	r3, #0
}
 8014302:	4618      	mov	r0, r3
 8014304:	3710      	adds	r7, #16
 8014306:	46bd      	mov	sp, r7
 8014308:	bd80      	pop	{r7, pc}

0801430a <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 801430a:	b580      	push	{r7, lr}
 801430c:	b088      	sub	sp, #32
 801430e:	af00      	add	r7, sp, #0
 8014310:	60f8      	str	r0, [r7, #12]
 8014312:	60b9      	str	r1, [r7, #8]
 8014314:	603b      	str	r3, [r7, #0]
 8014316:	4613      	mov	r3, r2
 8014318:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 801431a:	2300      	movs	r3, #0
 801431c:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 801431e:	68fb      	ldr	r3, [r7, #12]
 8014320:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8014324:	2b01      	cmp	r3, #1
 8014326:	d101      	bne.n	801432c <HAL_SPI_Transmit+0x22>
 8014328:	2302      	movs	r3, #2
 801432a:	e158      	b.n	80145de <HAL_SPI_Transmit+0x2d4>
 801432c:	68fb      	ldr	r3, [r7, #12]
 801432e:	2201      	movs	r2, #1
 8014330:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8014334:	f7f8 fba8 	bl	800ca88 <HAL_GetTick>
 8014338:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 801433a:	88fb      	ldrh	r3, [r7, #6]
 801433c:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 801433e:	68fb      	ldr	r3, [r7, #12]
 8014340:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8014344:	b2db      	uxtb	r3, r3
 8014346:	2b01      	cmp	r3, #1
 8014348:	d002      	beq.n	8014350 <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 801434a:	2302      	movs	r3, #2
 801434c:	77fb      	strb	r3, [r7, #31]
    goto error;
 801434e:	e13d      	b.n	80145cc <HAL_SPI_Transmit+0x2c2>
  }

  if ((pData == NULL) || (Size == 0U))
 8014350:	68bb      	ldr	r3, [r7, #8]
 8014352:	2b00      	cmp	r3, #0
 8014354:	d002      	beq.n	801435c <HAL_SPI_Transmit+0x52>
 8014356:	88fb      	ldrh	r3, [r7, #6]
 8014358:	2b00      	cmp	r3, #0
 801435a:	d102      	bne.n	8014362 <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 801435c:	2301      	movs	r3, #1
 801435e:	77fb      	strb	r3, [r7, #31]
    goto error;
 8014360:	e134      	b.n	80145cc <HAL_SPI_Transmit+0x2c2>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8014362:	68fb      	ldr	r3, [r7, #12]
 8014364:	2203      	movs	r2, #3
 8014366:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 801436a:	68fb      	ldr	r3, [r7, #12]
 801436c:	2200      	movs	r2, #0
 801436e:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8014370:	68fb      	ldr	r3, [r7, #12]
 8014372:	68ba      	ldr	r2, [r7, #8]
 8014374:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8014376:	68fb      	ldr	r3, [r7, #12]
 8014378:	88fa      	ldrh	r2, [r7, #6]
 801437a:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->TxXferCount = Size;
 801437c:	68fb      	ldr	r3, [r7, #12]
 801437e:	88fa      	ldrh	r2, [r7, #6]
 8014380:	87da      	strh	r2, [r3, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8014382:	68fb      	ldr	r3, [r7, #12]
 8014384:	2200      	movs	r2, #0
 8014386:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 8014388:	68fb      	ldr	r3, [r7, #12]
 801438a:	2200      	movs	r2, #0
 801438c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8014390:	68fb      	ldr	r3, [r7, #12]
 8014392:	2200      	movs	r2, #0
 8014394:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->TxISR       = NULL;
 8014398:	68fb      	ldr	r3, [r7, #12]
 801439a:	2200      	movs	r2, #0
 801439c:	651a      	str	r2, [r3, #80]	; 0x50
  hspi->RxISR       = NULL;
 801439e:	68fb      	ldr	r3, [r7, #12]
 80143a0:	2200      	movs	r2, #0
 80143a2:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80143a4:	68fb      	ldr	r3, [r7, #12]
 80143a6:	689b      	ldr	r3, [r3, #8]
 80143a8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80143ac:	d10f      	bne.n	80143ce <HAL_SPI_Transmit+0xc4>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 80143ae:	68fb      	ldr	r3, [r7, #12]
 80143b0:	681b      	ldr	r3, [r3, #0]
 80143b2:	681a      	ldr	r2, [r3, #0]
 80143b4:	68fb      	ldr	r3, [r7, #12]
 80143b6:	681b      	ldr	r3, [r3, #0]
 80143b8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80143bc:	601a      	str	r2, [r3, #0]
    SPI_1LINE_TX(hspi);
 80143be:	68fb      	ldr	r3, [r7, #12]
 80143c0:	681b      	ldr	r3, [r3, #0]
 80143c2:	681a      	ldr	r2, [r3, #0]
 80143c4:	68fb      	ldr	r3, [r7, #12]
 80143c6:	681b      	ldr	r3, [r3, #0]
 80143c8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80143cc:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80143ce:	68fb      	ldr	r3, [r7, #12]
 80143d0:	681b      	ldr	r3, [r3, #0]
 80143d2:	681b      	ldr	r3, [r3, #0]
 80143d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80143d8:	2b40      	cmp	r3, #64	; 0x40
 80143da:	d007      	beq.n	80143ec <HAL_SPI_Transmit+0xe2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80143dc:	68fb      	ldr	r3, [r7, #12]
 80143de:	681b      	ldr	r3, [r3, #0]
 80143e0:	681a      	ldr	r2, [r3, #0]
 80143e2:	68fb      	ldr	r3, [r7, #12]
 80143e4:	681b      	ldr	r3, [r3, #0]
 80143e6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80143ea:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80143ec:	68fb      	ldr	r3, [r7, #12]
 80143ee:	68db      	ldr	r3, [r3, #12]
 80143f0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80143f4:	d94b      	bls.n	801448e <HAL_SPI_Transmit+0x184>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80143f6:	68fb      	ldr	r3, [r7, #12]
 80143f8:	685b      	ldr	r3, [r3, #4]
 80143fa:	2b00      	cmp	r3, #0
 80143fc:	d002      	beq.n	8014404 <HAL_SPI_Transmit+0xfa>
 80143fe:	8afb      	ldrh	r3, [r7, #22]
 8014400:	2b01      	cmp	r3, #1
 8014402:	d13e      	bne.n	8014482 <HAL_SPI_Transmit+0x178>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8014404:	68fb      	ldr	r3, [r7, #12]
 8014406:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014408:	881a      	ldrh	r2, [r3, #0]
 801440a:	68fb      	ldr	r3, [r7, #12]
 801440c:	681b      	ldr	r3, [r3, #0]
 801440e:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8014410:	68fb      	ldr	r3, [r7, #12]
 8014412:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014414:	1c9a      	adds	r2, r3, #2
 8014416:	68fb      	ldr	r3, [r7, #12]
 8014418:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 801441a:	68fb      	ldr	r3, [r7, #12]
 801441c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 801441e:	b29b      	uxth	r3, r3
 8014420:	3b01      	subs	r3, #1
 8014422:	b29a      	uxth	r2, r3
 8014424:	68fb      	ldr	r3, [r7, #12]
 8014426:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8014428:	e02b      	b.n	8014482 <HAL_SPI_Transmit+0x178>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 801442a:	68fb      	ldr	r3, [r7, #12]
 801442c:	681b      	ldr	r3, [r3, #0]
 801442e:	689b      	ldr	r3, [r3, #8]
 8014430:	f003 0302 	and.w	r3, r3, #2
 8014434:	2b02      	cmp	r3, #2
 8014436:	d112      	bne.n	801445e <HAL_SPI_Transmit+0x154>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8014438:	68fb      	ldr	r3, [r7, #12]
 801443a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801443c:	881a      	ldrh	r2, [r3, #0]
 801443e:	68fb      	ldr	r3, [r7, #12]
 8014440:	681b      	ldr	r3, [r3, #0]
 8014442:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8014444:	68fb      	ldr	r3, [r7, #12]
 8014446:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014448:	1c9a      	adds	r2, r3, #2
 801444a:	68fb      	ldr	r3, [r7, #12]
 801444c:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 801444e:	68fb      	ldr	r3, [r7, #12]
 8014450:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014452:	b29b      	uxth	r3, r3
 8014454:	3b01      	subs	r3, #1
 8014456:	b29a      	uxth	r2, r3
 8014458:	68fb      	ldr	r3, [r7, #12]
 801445a:	87da      	strh	r2, [r3, #62]	; 0x3e
 801445c:	e011      	b.n	8014482 <HAL_SPI_Transmit+0x178>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 801445e:	f7f8 fb13 	bl	800ca88 <HAL_GetTick>
 8014462:	4602      	mov	r2, r0
 8014464:	69bb      	ldr	r3, [r7, #24]
 8014466:	1ad3      	subs	r3, r2, r3
 8014468:	683a      	ldr	r2, [r7, #0]
 801446a:	429a      	cmp	r2, r3
 801446c:	d803      	bhi.n	8014476 <HAL_SPI_Transmit+0x16c>
 801446e:	683b      	ldr	r3, [r7, #0]
 8014470:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014474:	d102      	bne.n	801447c <HAL_SPI_Transmit+0x172>
 8014476:	683b      	ldr	r3, [r7, #0]
 8014478:	2b00      	cmp	r3, #0
 801447a:	d102      	bne.n	8014482 <HAL_SPI_Transmit+0x178>
        {
          errorcode = HAL_TIMEOUT;
 801447c:	2303      	movs	r3, #3
 801447e:	77fb      	strb	r3, [r7, #31]
          goto error;
 8014480:	e0a4      	b.n	80145cc <HAL_SPI_Transmit+0x2c2>
    while (hspi->TxXferCount > 0U)
 8014482:	68fb      	ldr	r3, [r7, #12]
 8014484:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014486:	b29b      	uxth	r3, r3
 8014488:	2b00      	cmp	r3, #0
 801448a:	d1ce      	bne.n	801442a <HAL_SPI_Transmit+0x120>
 801448c:	e07c      	b.n	8014588 <HAL_SPI_Transmit+0x27e>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 801448e:	68fb      	ldr	r3, [r7, #12]
 8014490:	685b      	ldr	r3, [r3, #4]
 8014492:	2b00      	cmp	r3, #0
 8014494:	d002      	beq.n	801449c <HAL_SPI_Transmit+0x192>
 8014496:	8afb      	ldrh	r3, [r7, #22]
 8014498:	2b01      	cmp	r3, #1
 801449a:	d170      	bne.n	801457e <HAL_SPI_Transmit+0x274>
    {
      if (hspi->TxXferCount > 1U)
 801449c:	68fb      	ldr	r3, [r7, #12]
 801449e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80144a0:	b29b      	uxth	r3, r3
 80144a2:	2b01      	cmp	r3, #1
 80144a4:	d912      	bls.n	80144cc <HAL_SPI_Transmit+0x1c2>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80144a6:	68fb      	ldr	r3, [r7, #12]
 80144a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80144aa:	881a      	ldrh	r2, [r3, #0]
 80144ac:	68fb      	ldr	r3, [r7, #12]
 80144ae:	681b      	ldr	r3, [r3, #0]
 80144b0:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80144b2:	68fb      	ldr	r3, [r7, #12]
 80144b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80144b6:	1c9a      	adds	r2, r3, #2
 80144b8:	68fb      	ldr	r3, [r7, #12]
 80144ba:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 80144bc:	68fb      	ldr	r3, [r7, #12]
 80144be:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80144c0:	b29b      	uxth	r3, r3
 80144c2:	3b02      	subs	r3, #2
 80144c4:	b29a      	uxth	r2, r3
 80144c6:	68fb      	ldr	r3, [r7, #12]
 80144c8:	87da      	strh	r2, [r3, #62]	; 0x3e
 80144ca:	e058      	b.n	801457e <HAL_SPI_Transmit+0x274>
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 80144cc:	68fb      	ldr	r3, [r7, #12]
 80144ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80144d0:	68fb      	ldr	r3, [r7, #12]
 80144d2:	681b      	ldr	r3, [r3, #0]
 80144d4:	330c      	adds	r3, #12
 80144d6:	7812      	ldrb	r2, [r2, #0]
 80144d8:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr ++;
 80144da:	68fb      	ldr	r3, [r7, #12]
 80144dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80144de:	1c5a      	adds	r2, r3, #1
 80144e0:	68fb      	ldr	r3, [r7, #12]
 80144e2:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 80144e4:	68fb      	ldr	r3, [r7, #12]
 80144e6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80144e8:	b29b      	uxth	r3, r3
 80144ea:	3b01      	subs	r3, #1
 80144ec:	b29a      	uxth	r2, r3
 80144ee:	68fb      	ldr	r3, [r7, #12]
 80144f0:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while (hspi->TxXferCount > 0U)
 80144f2:	e044      	b.n	801457e <HAL_SPI_Transmit+0x274>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80144f4:	68fb      	ldr	r3, [r7, #12]
 80144f6:	681b      	ldr	r3, [r3, #0]
 80144f8:	689b      	ldr	r3, [r3, #8]
 80144fa:	f003 0302 	and.w	r3, r3, #2
 80144fe:	2b02      	cmp	r3, #2
 8014500:	d12b      	bne.n	801455a <HAL_SPI_Transmit+0x250>
      {
        if (hspi->TxXferCount > 1U)
 8014502:	68fb      	ldr	r3, [r7, #12]
 8014504:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014506:	b29b      	uxth	r3, r3
 8014508:	2b01      	cmp	r3, #1
 801450a:	d912      	bls.n	8014532 <HAL_SPI_Transmit+0x228>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 801450c:	68fb      	ldr	r3, [r7, #12]
 801450e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014510:	881a      	ldrh	r2, [r3, #0]
 8014512:	68fb      	ldr	r3, [r7, #12]
 8014514:	681b      	ldr	r3, [r3, #0]
 8014516:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8014518:	68fb      	ldr	r3, [r7, #12]
 801451a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801451c:	1c9a      	adds	r2, r3, #2
 801451e:	68fb      	ldr	r3, [r7, #12]
 8014520:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 8014522:	68fb      	ldr	r3, [r7, #12]
 8014524:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014526:	b29b      	uxth	r3, r3
 8014528:	3b02      	subs	r3, #2
 801452a:	b29a      	uxth	r2, r3
 801452c:	68fb      	ldr	r3, [r7, #12]
 801452e:	87da      	strh	r2, [r3, #62]	; 0x3e
 8014530:	e025      	b.n	801457e <HAL_SPI_Transmit+0x274>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8014532:	68fb      	ldr	r3, [r7, #12]
 8014534:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014536:	68fb      	ldr	r3, [r7, #12]
 8014538:	681b      	ldr	r3, [r3, #0]
 801453a:	330c      	adds	r3, #12
 801453c:	7812      	ldrb	r2, [r2, #0]
 801453e:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 8014540:	68fb      	ldr	r3, [r7, #12]
 8014542:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014544:	1c5a      	adds	r2, r3, #1
 8014546:	68fb      	ldr	r3, [r7, #12]
 8014548:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 801454a:	68fb      	ldr	r3, [r7, #12]
 801454c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 801454e:	b29b      	uxth	r3, r3
 8014550:	3b01      	subs	r3, #1
 8014552:	b29a      	uxth	r2, r3
 8014554:	68fb      	ldr	r3, [r7, #12]
 8014556:	87da      	strh	r2, [r3, #62]	; 0x3e
 8014558:	e011      	b.n	801457e <HAL_SPI_Transmit+0x274>
        }
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 801455a:	f7f8 fa95 	bl	800ca88 <HAL_GetTick>
 801455e:	4602      	mov	r2, r0
 8014560:	69bb      	ldr	r3, [r7, #24]
 8014562:	1ad3      	subs	r3, r2, r3
 8014564:	683a      	ldr	r2, [r7, #0]
 8014566:	429a      	cmp	r2, r3
 8014568:	d803      	bhi.n	8014572 <HAL_SPI_Transmit+0x268>
 801456a:	683b      	ldr	r3, [r7, #0]
 801456c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014570:	d102      	bne.n	8014578 <HAL_SPI_Transmit+0x26e>
 8014572:	683b      	ldr	r3, [r7, #0]
 8014574:	2b00      	cmp	r3, #0
 8014576:	d102      	bne.n	801457e <HAL_SPI_Transmit+0x274>
        {
          errorcode = HAL_TIMEOUT;
 8014578:	2303      	movs	r3, #3
 801457a:	77fb      	strb	r3, [r7, #31]
          goto error;
 801457c:	e026      	b.n	80145cc <HAL_SPI_Transmit+0x2c2>
    while (hspi->TxXferCount > 0U)
 801457e:	68fb      	ldr	r3, [r7, #12]
 8014580:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014582:	b29b      	uxth	r3, r3
 8014584:	2b00      	cmp	r3, #0
 8014586:	d1b5      	bne.n	80144f4 <HAL_SPI_Transmit+0x1ea>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8014588:	69ba      	ldr	r2, [r7, #24]
 801458a:	6839      	ldr	r1, [r7, #0]
 801458c:	68f8      	ldr	r0, [r7, #12]
 801458e:	f000 fce3 	bl	8014f58 <SPI_EndRxTxTransaction>
 8014592:	4603      	mov	r3, r0
 8014594:	2b00      	cmp	r3, #0
 8014596:	d002      	beq.n	801459e <HAL_SPI_Transmit+0x294>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8014598:	68fb      	ldr	r3, [r7, #12]
 801459a:	2220      	movs	r2, #32
 801459c:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 801459e:	68fb      	ldr	r3, [r7, #12]
 80145a0:	689b      	ldr	r3, [r3, #8]
 80145a2:	2b00      	cmp	r3, #0
 80145a4:	d10a      	bne.n	80145bc <HAL_SPI_Transmit+0x2b2>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80145a6:	2300      	movs	r3, #0
 80145a8:	613b      	str	r3, [r7, #16]
 80145aa:	68fb      	ldr	r3, [r7, #12]
 80145ac:	681b      	ldr	r3, [r3, #0]
 80145ae:	68db      	ldr	r3, [r3, #12]
 80145b0:	613b      	str	r3, [r7, #16]
 80145b2:	68fb      	ldr	r3, [r7, #12]
 80145b4:	681b      	ldr	r3, [r3, #0]
 80145b6:	689b      	ldr	r3, [r3, #8]
 80145b8:	613b      	str	r3, [r7, #16]
 80145ba:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80145bc:	68fb      	ldr	r3, [r7, #12]
 80145be:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80145c0:	2b00      	cmp	r3, #0
 80145c2:	d002      	beq.n	80145ca <HAL_SPI_Transmit+0x2c0>
  {
    errorcode = HAL_ERROR;
 80145c4:	2301      	movs	r3, #1
 80145c6:	77fb      	strb	r3, [r7, #31]
 80145c8:	e000      	b.n	80145cc <HAL_SPI_Transmit+0x2c2>
  }

error:
 80145ca:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 80145cc:	68fb      	ldr	r3, [r7, #12]
 80145ce:	2201      	movs	r2, #1
 80145d0:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80145d4:	68fb      	ldr	r3, [r7, #12]
 80145d6:	2200      	movs	r2, #0
 80145d8:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 80145dc:	7ffb      	ldrb	r3, [r7, #31]
}
 80145de:	4618      	mov	r0, r3
 80145e0:	3720      	adds	r7, #32
 80145e2:	46bd      	mov	sp, r7
 80145e4:	bd80      	pop	{r7, pc}

080145e6 <HAL_SPI_Receive>:
  * @param  Size amount of data to be received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80145e6:	b580      	push	{r7, lr}
 80145e8:	b088      	sub	sp, #32
 80145ea:	af02      	add	r7, sp, #8
 80145ec:	60f8      	str	r0, [r7, #12]
 80145ee:	60b9      	str	r1, [r7, #8]
 80145f0:	603b      	str	r3, [r7, #0]
 80145f2:	4613      	mov	r3, r2
 80145f4:	80fb      	strh	r3, [r7, #6]
  __IO uint32_t tmpreg = 0U;
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
#endif /* USE_SPI_CRC */
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 80145f6:	2300      	movs	r3, #0
 80145f8:	75fb      	strb	r3, [r7, #23]

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 80145fa:	68fb      	ldr	r3, [r7, #12]
 80145fc:	685b      	ldr	r3, [r3, #4]
 80145fe:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014602:	d112      	bne.n	801462a <HAL_SPI_Receive+0x44>
 8014604:	68fb      	ldr	r3, [r7, #12]
 8014606:	689b      	ldr	r3, [r3, #8]
 8014608:	2b00      	cmp	r3, #0
 801460a:	d10e      	bne.n	801462a <HAL_SPI_Receive+0x44>
  {
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 801460c:	68fb      	ldr	r3, [r7, #12]
 801460e:	2204      	movs	r2, #4
 8014610:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8014614:	88fa      	ldrh	r2, [r7, #6]
 8014616:	683b      	ldr	r3, [r7, #0]
 8014618:	9300      	str	r3, [sp, #0]
 801461a:	4613      	mov	r3, r2
 801461c:	68ba      	ldr	r2, [r7, #8]
 801461e:	68b9      	ldr	r1, [r7, #8]
 8014620:	68f8      	ldr	r0, [r7, #12]
 8014622:	f000 f910 	bl	8014846 <HAL_SPI_TransmitReceive>
 8014626:	4603      	mov	r3, r0
 8014628:	e109      	b.n	801483e <HAL_SPI_Receive+0x258>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 801462a:	68fb      	ldr	r3, [r7, #12]
 801462c:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8014630:	2b01      	cmp	r3, #1
 8014632:	d101      	bne.n	8014638 <HAL_SPI_Receive+0x52>
 8014634:	2302      	movs	r3, #2
 8014636:	e102      	b.n	801483e <HAL_SPI_Receive+0x258>
 8014638:	68fb      	ldr	r3, [r7, #12]
 801463a:	2201      	movs	r2, #1
 801463c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8014640:	f7f8 fa22 	bl	800ca88 <HAL_GetTick>
 8014644:	6138      	str	r0, [r7, #16]

  if (hspi->State != HAL_SPI_STATE_READY)
 8014646:	68fb      	ldr	r3, [r7, #12]
 8014648:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 801464c:	b2db      	uxtb	r3, r3
 801464e:	2b01      	cmp	r3, #1
 8014650:	d002      	beq.n	8014658 <HAL_SPI_Receive+0x72>
  {
    errorcode = HAL_BUSY;
 8014652:	2302      	movs	r3, #2
 8014654:	75fb      	strb	r3, [r7, #23]
    goto error;
 8014656:	e0e9      	b.n	801482c <HAL_SPI_Receive+0x246>
  }

  if ((pData == NULL) || (Size == 0U))
 8014658:	68bb      	ldr	r3, [r7, #8]
 801465a:	2b00      	cmp	r3, #0
 801465c:	d002      	beq.n	8014664 <HAL_SPI_Receive+0x7e>
 801465e:	88fb      	ldrh	r3, [r7, #6]
 8014660:	2b00      	cmp	r3, #0
 8014662:	d102      	bne.n	801466a <HAL_SPI_Receive+0x84>
  {
    errorcode = HAL_ERROR;
 8014664:	2301      	movs	r3, #1
 8014666:	75fb      	strb	r3, [r7, #23]
    goto error;
 8014668:	e0e0      	b.n	801482c <HAL_SPI_Receive+0x246>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 801466a:	68fb      	ldr	r3, [r7, #12]
 801466c:	2204      	movs	r2, #4
 801466e:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8014672:	68fb      	ldr	r3, [r7, #12]
 8014674:	2200      	movs	r2, #0
 8014676:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8014678:	68fb      	ldr	r3, [r7, #12]
 801467a:	68ba      	ldr	r2, [r7, #8]
 801467c:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferSize  = Size;
 801467e:	68fb      	ldr	r3, [r7, #12]
 8014680:	88fa      	ldrh	r2, [r7, #6]
 8014682:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->RxXferCount = Size;
 8014686:	68fb      	ldr	r3, [r7, #12]
 8014688:	88fa      	ldrh	r2, [r7, #6]
 801468a:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 801468e:	68fb      	ldr	r3, [r7, #12]
 8014690:	2200      	movs	r2, #0
 8014692:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferSize  = 0U;
 8014694:	68fb      	ldr	r3, [r7, #12]
 8014696:	2200      	movs	r2, #0
 8014698:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 801469a:	68fb      	ldr	r3, [r7, #12]
 801469c:	2200      	movs	r2, #0
 801469e:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxISR       = NULL;
 80146a0:	68fb      	ldr	r3, [r7, #12]
 80146a2:	2200      	movs	r2, #0
 80146a4:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80146a6:	68fb      	ldr	r3, [r7, #12]
 80146a8:	2200      	movs	r2, #0
 80146aa:	651a      	str	r2, [r3, #80]	; 0x50
    hspi->RxXferCount--;
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80146ac:	68fb      	ldr	r3, [r7, #12]
 80146ae:	68db      	ldr	r3, [r3, #12]
 80146b0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80146b4:	d908      	bls.n	80146c8 <HAL_SPI_Receive+0xe2>
  {
    /* Set RX Fifo threshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80146b6:	68fb      	ldr	r3, [r7, #12]
 80146b8:	681b      	ldr	r3, [r3, #0]
 80146ba:	685a      	ldr	r2, [r3, #4]
 80146bc:	68fb      	ldr	r3, [r7, #12]
 80146be:	681b      	ldr	r3, [r3, #0]
 80146c0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80146c4:	605a      	str	r2, [r3, #4]
 80146c6:	e007      	b.n	80146d8 <HAL_SPI_Receive+0xf2>
  }
  else
  {
    /* Set RX Fifo threshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80146c8:	68fb      	ldr	r3, [r7, #12]
 80146ca:	681b      	ldr	r3, [r3, #0]
 80146cc:	685a      	ldr	r2, [r3, #4]
 80146ce:	68fb      	ldr	r3, [r7, #12]
 80146d0:	681b      	ldr	r3, [r3, #0]
 80146d2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80146d6:	605a      	str	r2, [r3, #4]
  }

  /* Configure communication direction: 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80146d8:	68fb      	ldr	r3, [r7, #12]
 80146da:	689b      	ldr	r3, [r3, #8]
 80146dc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80146e0:	d10f      	bne.n	8014702 <HAL_SPI_Receive+0x11c>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 80146e2:	68fb      	ldr	r3, [r7, #12]
 80146e4:	681b      	ldr	r3, [r3, #0]
 80146e6:	681a      	ldr	r2, [r3, #0]
 80146e8:	68fb      	ldr	r3, [r7, #12]
 80146ea:	681b      	ldr	r3, [r3, #0]
 80146ec:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80146f0:	601a      	str	r2, [r3, #0]
    SPI_1LINE_RX(hspi);
 80146f2:	68fb      	ldr	r3, [r7, #12]
 80146f4:	681b      	ldr	r3, [r3, #0]
 80146f6:	681a      	ldr	r2, [r3, #0]
 80146f8:	68fb      	ldr	r3, [r7, #12]
 80146fa:	681b      	ldr	r3, [r3, #0]
 80146fc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8014700:	601a      	str	r2, [r3, #0]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8014702:	68fb      	ldr	r3, [r7, #12]
 8014704:	681b      	ldr	r3, [r3, #0]
 8014706:	681b      	ldr	r3, [r3, #0]
 8014708:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801470c:	2b40      	cmp	r3, #64	; 0x40
 801470e:	d007      	beq.n	8014720 <HAL_SPI_Receive+0x13a>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8014710:	68fb      	ldr	r3, [r7, #12]
 8014712:	681b      	ldr	r3, [r3, #0]
 8014714:	681a      	ldr	r2, [r3, #0]
 8014716:	68fb      	ldr	r3, [r7, #12]
 8014718:	681b      	ldr	r3, [r3, #0]
 801471a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801471e:	601a      	str	r2, [r3, #0]
  }

  /* Receive data in 8 Bit mode */
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
 8014720:	68fb      	ldr	r3, [r7, #12]
 8014722:	68db      	ldr	r3, [r3, #12]
 8014724:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8014728:	d867      	bhi.n	80147fa <HAL_SPI_Receive+0x214>
  {
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
 801472a:	e030      	b.n	801478e <HAL_SPI_Receive+0x1a8>
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 801472c:	68fb      	ldr	r3, [r7, #12]
 801472e:	681b      	ldr	r3, [r3, #0]
 8014730:	689b      	ldr	r3, [r3, #8]
 8014732:	f003 0301 	and.w	r3, r3, #1
 8014736:	2b01      	cmp	r3, #1
 8014738:	d117      	bne.n	801476a <HAL_SPI_Receive+0x184>
      {
        /* read the received data */
        (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 801473a:	68fb      	ldr	r3, [r7, #12]
 801473c:	681b      	ldr	r3, [r3, #0]
 801473e:	f103 020c 	add.w	r2, r3, #12
 8014742:	68fb      	ldr	r3, [r7, #12]
 8014744:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014746:	7812      	ldrb	r2, [r2, #0]
 8014748:	b2d2      	uxtb	r2, r2
 801474a:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 801474c:	68fb      	ldr	r3, [r7, #12]
 801474e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014750:	1c5a      	adds	r2, r3, #1
 8014752:	68fb      	ldr	r3, [r7, #12]
 8014754:	641a      	str	r2, [r3, #64]	; 0x40
        hspi->RxXferCount--;
 8014756:	68fb      	ldr	r3, [r7, #12]
 8014758:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 801475c:	b29b      	uxth	r3, r3
 801475e:	3b01      	subs	r3, #1
 8014760:	b29a      	uxth	r2, r3
 8014762:	68fb      	ldr	r3, [r7, #12]
 8014764:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
 8014768:	e011      	b.n	801478e <HAL_SPI_Receive+0x1a8>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 801476a:	f7f8 f98d 	bl	800ca88 <HAL_GetTick>
 801476e:	4602      	mov	r2, r0
 8014770:	693b      	ldr	r3, [r7, #16]
 8014772:	1ad3      	subs	r3, r2, r3
 8014774:	683a      	ldr	r2, [r7, #0]
 8014776:	429a      	cmp	r2, r3
 8014778:	d803      	bhi.n	8014782 <HAL_SPI_Receive+0x19c>
 801477a:	683b      	ldr	r3, [r7, #0]
 801477c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014780:	d102      	bne.n	8014788 <HAL_SPI_Receive+0x1a2>
 8014782:	683b      	ldr	r3, [r7, #0]
 8014784:	2b00      	cmp	r3, #0
 8014786:	d102      	bne.n	801478e <HAL_SPI_Receive+0x1a8>
        {
          errorcode = HAL_TIMEOUT;
 8014788:	2303      	movs	r3, #3
 801478a:	75fb      	strb	r3, [r7, #23]
          goto error;
 801478c:	e04e      	b.n	801482c <HAL_SPI_Receive+0x246>
    while (hspi->RxXferCount > 0U)
 801478e:	68fb      	ldr	r3, [r7, #12]
 8014790:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014794:	b29b      	uxth	r3, r3
 8014796:	2b00      	cmp	r3, #0
 8014798:	d1c8      	bne.n	801472c <HAL_SPI_Receive+0x146>
 801479a:	e034      	b.n	8014806 <HAL_SPI_Receive+0x220>
  {
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 801479c:	68fb      	ldr	r3, [r7, #12]
 801479e:	681b      	ldr	r3, [r3, #0]
 80147a0:	689b      	ldr	r3, [r3, #8]
 80147a2:	f003 0301 	and.w	r3, r3, #1
 80147a6:	2b01      	cmp	r3, #1
 80147a8:	d115      	bne.n	80147d6 <HAL_SPI_Receive+0x1f0>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 80147aa:	68fb      	ldr	r3, [r7, #12]
 80147ac:	681b      	ldr	r3, [r3, #0]
 80147ae:	68da      	ldr	r2, [r3, #12]
 80147b0:	68fb      	ldr	r3, [r7, #12]
 80147b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80147b4:	b292      	uxth	r2, r2
 80147b6:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 80147b8:	68fb      	ldr	r3, [r7, #12]
 80147ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80147bc:	1c9a      	adds	r2, r3, #2
 80147be:	68fb      	ldr	r3, [r7, #12]
 80147c0:	641a      	str	r2, [r3, #64]	; 0x40
        hspi->RxXferCount--;
 80147c2:	68fb      	ldr	r3, [r7, #12]
 80147c4:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80147c8:	b29b      	uxth	r3, r3
 80147ca:	3b01      	subs	r3, #1
 80147cc:	b29a      	uxth	r2, r3
 80147ce:	68fb      	ldr	r3, [r7, #12]
 80147d0:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
 80147d4:	e011      	b.n	80147fa <HAL_SPI_Receive+0x214>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80147d6:	f7f8 f957 	bl	800ca88 <HAL_GetTick>
 80147da:	4602      	mov	r2, r0
 80147dc:	693b      	ldr	r3, [r7, #16]
 80147de:	1ad3      	subs	r3, r2, r3
 80147e0:	683a      	ldr	r2, [r7, #0]
 80147e2:	429a      	cmp	r2, r3
 80147e4:	d803      	bhi.n	80147ee <HAL_SPI_Receive+0x208>
 80147e6:	683b      	ldr	r3, [r7, #0]
 80147e8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80147ec:	d102      	bne.n	80147f4 <HAL_SPI_Receive+0x20e>
 80147ee:	683b      	ldr	r3, [r7, #0]
 80147f0:	2b00      	cmp	r3, #0
 80147f2:	d102      	bne.n	80147fa <HAL_SPI_Receive+0x214>
        {
          errorcode = HAL_TIMEOUT;
 80147f4:	2303      	movs	r3, #3
 80147f6:	75fb      	strb	r3, [r7, #23]
          goto error;
 80147f8:	e018      	b.n	801482c <HAL_SPI_Receive+0x246>
    while (hspi->RxXferCount > 0U)
 80147fa:	68fb      	ldr	r3, [r7, #12]
 80147fc:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014800:	b29b      	uxth	r3, r3
 8014802:	2b00      	cmp	r3, #0
 8014804:	d1ca      	bne.n	801479c <HAL_SPI_Receive+0x1b6>
    }
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8014806:	693a      	ldr	r2, [r7, #16]
 8014808:	6839      	ldr	r1, [r7, #0]
 801480a:	68f8      	ldr	r0, [r7, #12]
 801480c:	f000 fb4c 	bl	8014ea8 <SPI_EndRxTransaction>
 8014810:	4603      	mov	r3, r0
 8014812:	2b00      	cmp	r3, #0
 8014814:	d002      	beq.n	801481c <HAL_SPI_Receive+0x236>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8014816:	68fb      	ldr	r3, [r7, #12]
 8014818:	2220      	movs	r2, #32
 801481a:	661a      	str	r2, [r3, #96]	; 0x60
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
  }
#endif /* USE_SPI_CRC */

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 801481c:	68fb      	ldr	r3, [r7, #12]
 801481e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014820:	2b00      	cmp	r3, #0
 8014822:	d002      	beq.n	801482a <HAL_SPI_Receive+0x244>
  {
    errorcode = HAL_ERROR;
 8014824:	2301      	movs	r3, #1
 8014826:	75fb      	strb	r3, [r7, #23]
 8014828:	e000      	b.n	801482c <HAL_SPI_Receive+0x246>
  }

error :
 801482a:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 801482c:	68fb      	ldr	r3, [r7, #12]
 801482e:	2201      	movs	r2, #1
 8014830:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8014834:	68fb      	ldr	r3, [r7, #12]
 8014836:	2200      	movs	r2, #0
 8014838:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 801483c:	7dfb      	ldrb	r3, [r7, #23]
}
 801483e:	4618      	mov	r0, r3
 8014840:	3718      	adds	r7, #24
 8014842:	46bd      	mov	sp, r7
 8014844:	bd80      	pop	{r7, pc}

08014846 <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 8014846:	b580      	push	{r7, lr}
 8014848:	b08a      	sub	sp, #40	; 0x28
 801484a:	af00      	add	r7, sp, #0
 801484c:	60f8      	str	r0, [r7, #12]
 801484e:	60b9      	str	r1, [r7, #8]
 8014850:	607a      	str	r2, [r7, #4]
 8014852:	807b      	strh	r3, [r7, #2]
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
#endif /* USE_SPI_CRC */

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 8014854:	2301      	movs	r3, #1
 8014856:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_StatusTypeDef    errorcode = HAL_OK;
 8014858:	2300      	movs	r3, #0
 801485a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 801485e:	68fb      	ldr	r3, [r7, #12]
 8014860:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8014864:	2b01      	cmp	r3, #1
 8014866:	d101      	bne.n	801486c <HAL_SPI_TransmitReceive+0x26>
 8014868:	2302      	movs	r3, #2
 801486a:	e1fb      	b.n	8014c64 <HAL_SPI_TransmitReceive+0x41e>
 801486c:	68fb      	ldr	r3, [r7, #12]
 801486e:	2201      	movs	r2, #1
 8014870:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8014874:	f7f8 f908 	bl	800ca88 <HAL_GetTick>
 8014878:	61f8      	str	r0, [r7, #28]

  /* Init temporary variables */
  tmp_state           = hspi->State;
 801487a:	68fb      	ldr	r3, [r7, #12]
 801487c:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8014880:	76fb      	strb	r3, [r7, #27]
  tmp_mode            = hspi->Init.Mode;
 8014882:	68fb      	ldr	r3, [r7, #12]
 8014884:	685b      	ldr	r3, [r3, #4]
 8014886:	617b      	str	r3, [r7, #20]
  initial_TxXferCount = Size;
 8014888:	887b      	ldrh	r3, [r7, #2]
 801488a:	827b      	strh	r3, [r7, #18]
  initial_RxXferCount = Size;
 801488c:	887b      	ldrh	r3, [r7, #2]
 801488e:	823b      	strh	r3, [r7, #16]
#if (USE_SPI_CRC != 0U)
  spi_cr1             = READ_REG(hspi->Instance->CR1);
  spi_cr2             = READ_REG(hspi->Instance->CR2);
#endif /* USE_SPI_CRC */

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8014890:	7efb      	ldrb	r3, [r7, #27]
 8014892:	2b01      	cmp	r3, #1
 8014894:	d00e      	beq.n	80148b4 <HAL_SPI_TransmitReceive+0x6e>
 8014896:	697b      	ldr	r3, [r7, #20]
 8014898:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 801489c:	d106      	bne.n	80148ac <HAL_SPI_TransmitReceive+0x66>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 801489e:	68fb      	ldr	r3, [r7, #12]
 80148a0:	689b      	ldr	r3, [r3, #8]
 80148a2:	2b00      	cmp	r3, #0
 80148a4:	d102      	bne.n	80148ac <HAL_SPI_TransmitReceive+0x66>
 80148a6:	7efb      	ldrb	r3, [r7, #27]
 80148a8:	2b04      	cmp	r3, #4
 80148aa:	d003      	beq.n	80148b4 <HAL_SPI_TransmitReceive+0x6e>
  {
    errorcode = HAL_BUSY;
 80148ac:	2302      	movs	r3, #2
 80148ae:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 80148b2:	e1cd      	b.n	8014c50 <HAL_SPI_TransmitReceive+0x40a>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 80148b4:	68bb      	ldr	r3, [r7, #8]
 80148b6:	2b00      	cmp	r3, #0
 80148b8:	d005      	beq.n	80148c6 <HAL_SPI_TransmitReceive+0x80>
 80148ba:	687b      	ldr	r3, [r7, #4]
 80148bc:	2b00      	cmp	r3, #0
 80148be:	d002      	beq.n	80148c6 <HAL_SPI_TransmitReceive+0x80>
 80148c0:	887b      	ldrh	r3, [r7, #2]
 80148c2:	2b00      	cmp	r3, #0
 80148c4:	d103      	bne.n	80148ce <HAL_SPI_TransmitReceive+0x88>
  {
    errorcode = HAL_ERROR;
 80148c6:	2301      	movs	r3, #1
 80148c8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    goto error;
 80148cc:	e1c0      	b.n	8014c50 <HAL_SPI_TransmitReceive+0x40a>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80148ce:	68fb      	ldr	r3, [r7, #12]
 80148d0:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80148d4:	b2db      	uxtb	r3, r3
 80148d6:	2b04      	cmp	r3, #4
 80148d8:	d003      	beq.n	80148e2 <HAL_SPI_TransmitReceive+0x9c>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80148da:	68fb      	ldr	r3, [r7, #12]
 80148dc:	2205      	movs	r2, #5
 80148de:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80148e2:	68fb      	ldr	r3, [r7, #12]
 80148e4:	2200      	movs	r2, #0
 80148e6:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80148e8:	68fb      	ldr	r3, [r7, #12]
 80148ea:	687a      	ldr	r2, [r7, #4]
 80148ec:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->RxXferCount = Size;
 80148ee:	68fb      	ldr	r3, [r7, #12]
 80148f0:	887a      	ldrh	r2, [r7, #2]
 80148f2:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
  hspi->RxXferSize  = Size;
 80148f6:	68fb      	ldr	r3, [r7, #12]
 80148f8:	887a      	ldrh	r2, [r7, #2]
 80148fa:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80148fe:	68fb      	ldr	r3, [r7, #12]
 8014900:	68ba      	ldr	r2, [r7, #8]
 8014902:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->TxXferCount = Size;
 8014904:	68fb      	ldr	r3, [r7, #12]
 8014906:	887a      	ldrh	r2, [r7, #2]
 8014908:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 801490a:	68fb      	ldr	r3, [r7, #12]
 801490c:	887a      	ldrh	r2, [r7, #2]
 801490e:	879a      	strh	r2, [r3, #60]	; 0x3c

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 8014910:	68fb      	ldr	r3, [r7, #12]
 8014912:	2200      	movs	r2, #0
 8014914:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8014916:	68fb      	ldr	r3, [r7, #12]
 8014918:	2200      	movs	r2, #0
 801491a:	651a      	str	r2, [r3, #80]	; 0x50
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (initial_RxXferCount > 1U))
 801491c:	68fb      	ldr	r3, [r7, #12]
 801491e:	68db      	ldr	r3, [r3, #12]
 8014920:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8014924:	d802      	bhi.n	801492c <HAL_SPI_TransmitReceive+0xe6>
 8014926:	8a3b      	ldrh	r3, [r7, #16]
 8014928:	2b01      	cmp	r3, #1
 801492a:	d908      	bls.n	801493e <HAL_SPI_TransmitReceive+0xf8>
  {
    /* Set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801492c:	68fb      	ldr	r3, [r7, #12]
 801492e:	681b      	ldr	r3, [r3, #0]
 8014930:	685a      	ldr	r2, [r3, #4]
 8014932:	68fb      	ldr	r3, [r7, #12]
 8014934:	681b      	ldr	r3, [r3, #0]
 8014936:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 801493a:	605a      	str	r2, [r3, #4]
 801493c:	e007      	b.n	801494e <HAL_SPI_TransmitReceive+0x108>
  }
  else
  {
    /* Set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 801493e:	68fb      	ldr	r3, [r7, #12]
 8014940:	681b      	ldr	r3, [r3, #0]
 8014942:	685a      	ldr	r2, [r3, #4]
 8014944:	68fb      	ldr	r3, [r7, #12]
 8014946:	681b      	ldr	r3, [r3, #0]
 8014948:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801494c:	605a      	str	r2, [r3, #4]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 801494e:	68fb      	ldr	r3, [r7, #12]
 8014950:	681b      	ldr	r3, [r3, #0]
 8014952:	681b      	ldr	r3, [r3, #0]
 8014954:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014958:	2b40      	cmp	r3, #64	; 0x40
 801495a:	d007      	beq.n	801496c <HAL_SPI_TransmitReceive+0x126>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 801495c:	68fb      	ldr	r3, [r7, #12]
 801495e:	681b      	ldr	r3, [r3, #0]
 8014960:	681a      	ldr	r2, [r3, #0]
 8014962:	68fb      	ldr	r3, [r7, #12]
 8014964:	681b      	ldr	r3, [r3, #0]
 8014966:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801496a:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 801496c:	68fb      	ldr	r3, [r7, #12]
 801496e:	68db      	ldr	r3, [r3, #12]
 8014970:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8014974:	d97c      	bls.n	8014a70 <HAL_SPI_TransmitReceive+0x22a>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8014976:	68fb      	ldr	r3, [r7, #12]
 8014978:	685b      	ldr	r3, [r3, #4]
 801497a:	2b00      	cmp	r3, #0
 801497c:	d002      	beq.n	8014984 <HAL_SPI_TransmitReceive+0x13e>
 801497e:	8a7b      	ldrh	r3, [r7, #18]
 8014980:	2b01      	cmp	r3, #1
 8014982:	d169      	bne.n	8014a58 <HAL_SPI_TransmitReceive+0x212>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8014984:	68fb      	ldr	r3, [r7, #12]
 8014986:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014988:	881a      	ldrh	r2, [r3, #0]
 801498a:	68fb      	ldr	r3, [r7, #12]
 801498c:	681b      	ldr	r3, [r3, #0]
 801498e:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8014990:	68fb      	ldr	r3, [r7, #12]
 8014992:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014994:	1c9a      	adds	r2, r3, #2
 8014996:	68fb      	ldr	r3, [r7, #12]
 8014998:	639a      	str	r2, [r3, #56]	; 0x38
      hspi->TxXferCount--;
 801499a:	68fb      	ldr	r3, [r7, #12]
 801499c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 801499e:	b29b      	uxth	r3, r3
 80149a0:	3b01      	subs	r3, #1
 80149a2:	b29a      	uxth	r2, r3
 80149a4:	68fb      	ldr	r3, [r7, #12]
 80149a6:	87da      	strh	r2, [r3, #62]	; 0x3e
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80149a8:	e056      	b.n	8014a58 <HAL_SPI_TransmitReceive+0x212>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 80149aa:	68fb      	ldr	r3, [r7, #12]
 80149ac:	681b      	ldr	r3, [r3, #0]
 80149ae:	689b      	ldr	r3, [r3, #8]
 80149b0:	f003 0302 	and.w	r3, r3, #2
 80149b4:	2b02      	cmp	r3, #2
 80149b6:	d11b      	bne.n	80149f0 <HAL_SPI_TransmitReceive+0x1aa>
 80149b8:	68fb      	ldr	r3, [r7, #12]
 80149ba:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80149bc:	b29b      	uxth	r3, r3
 80149be:	2b00      	cmp	r3, #0
 80149c0:	d016      	beq.n	80149f0 <HAL_SPI_TransmitReceive+0x1aa>
 80149c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149c4:	2b01      	cmp	r3, #1
 80149c6:	d113      	bne.n	80149f0 <HAL_SPI_TransmitReceive+0x1aa>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80149c8:	68fb      	ldr	r3, [r7, #12]
 80149ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80149cc:	881a      	ldrh	r2, [r3, #0]
 80149ce:	68fb      	ldr	r3, [r7, #12]
 80149d0:	681b      	ldr	r3, [r3, #0]
 80149d2:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80149d4:	68fb      	ldr	r3, [r7, #12]
 80149d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80149d8:	1c9a      	adds	r2, r3, #2
 80149da:	68fb      	ldr	r3, [r7, #12]
 80149dc:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 80149de:	68fb      	ldr	r3, [r7, #12]
 80149e0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80149e2:	b29b      	uxth	r3, r3
 80149e4:	3b01      	subs	r3, #1
 80149e6:	b29a      	uxth	r2, r3
 80149e8:	68fb      	ldr	r3, [r7, #12]
 80149ea:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 80149ec:	2300      	movs	r3, #0
 80149ee:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 80149f0:	68fb      	ldr	r3, [r7, #12]
 80149f2:	681b      	ldr	r3, [r3, #0]
 80149f4:	689b      	ldr	r3, [r3, #8]
 80149f6:	f003 0301 	and.w	r3, r3, #1
 80149fa:	2b01      	cmp	r3, #1
 80149fc:	d11c      	bne.n	8014a38 <HAL_SPI_TransmitReceive+0x1f2>
 80149fe:	68fb      	ldr	r3, [r7, #12]
 8014a00:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014a04:	b29b      	uxth	r3, r3
 8014a06:	2b00      	cmp	r3, #0
 8014a08:	d016      	beq.n	8014a38 <HAL_SPI_TransmitReceive+0x1f2>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8014a0a:	68fb      	ldr	r3, [r7, #12]
 8014a0c:	681b      	ldr	r3, [r3, #0]
 8014a0e:	68da      	ldr	r2, [r3, #12]
 8014a10:	68fb      	ldr	r3, [r7, #12]
 8014a12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014a14:	b292      	uxth	r2, r2
 8014a16:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8014a18:	68fb      	ldr	r3, [r7, #12]
 8014a1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014a1c:	1c9a      	adds	r2, r3, #2
 8014a1e:	68fb      	ldr	r3, [r7, #12]
 8014a20:	641a      	str	r2, [r3, #64]	; 0x40
        hspi->RxXferCount--;
 8014a22:	68fb      	ldr	r3, [r7, #12]
 8014a24:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014a28:	b29b      	uxth	r3, r3
 8014a2a:	3b01      	subs	r3, #1
 8014a2c:	b29a      	uxth	r2, r3
 8014a2e:	68fb      	ldr	r3, [r7, #12]
 8014a30:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8014a34:	2301      	movs	r3, #1
 8014a36:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8014a38:	f7f8 f826 	bl	800ca88 <HAL_GetTick>
 8014a3c:	4602      	mov	r2, r0
 8014a3e:	69fb      	ldr	r3, [r7, #28]
 8014a40:	1ad3      	subs	r3, r2, r3
 8014a42:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014a44:	429a      	cmp	r2, r3
 8014a46:	d807      	bhi.n	8014a58 <HAL_SPI_TransmitReceive+0x212>
 8014a48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014a4a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014a4e:	d003      	beq.n	8014a58 <HAL_SPI_TransmitReceive+0x212>
      {
        errorcode = HAL_TIMEOUT;
 8014a50:	2303      	movs	r3, #3
 8014a52:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 8014a56:	e0fb      	b.n	8014c50 <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8014a58:	68fb      	ldr	r3, [r7, #12]
 8014a5a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014a5c:	b29b      	uxth	r3, r3
 8014a5e:	2b00      	cmp	r3, #0
 8014a60:	d1a3      	bne.n	80149aa <HAL_SPI_TransmitReceive+0x164>
 8014a62:	68fb      	ldr	r3, [r7, #12]
 8014a64:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014a68:	b29b      	uxth	r3, r3
 8014a6a:	2b00      	cmp	r3, #0
 8014a6c:	d19d      	bne.n	80149aa <HAL_SPI_TransmitReceive+0x164>
 8014a6e:	e0df      	b.n	8014c30 <HAL_SPI_TransmitReceive+0x3ea>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8014a70:	68fb      	ldr	r3, [r7, #12]
 8014a72:	685b      	ldr	r3, [r3, #4]
 8014a74:	2b00      	cmp	r3, #0
 8014a76:	d003      	beq.n	8014a80 <HAL_SPI_TransmitReceive+0x23a>
 8014a78:	8a7b      	ldrh	r3, [r7, #18]
 8014a7a:	2b01      	cmp	r3, #1
 8014a7c:	f040 80cb 	bne.w	8014c16 <HAL_SPI_TransmitReceive+0x3d0>
    {
      if (hspi->TxXferCount > 1U)
 8014a80:	68fb      	ldr	r3, [r7, #12]
 8014a82:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014a84:	b29b      	uxth	r3, r3
 8014a86:	2b01      	cmp	r3, #1
 8014a88:	d912      	bls.n	8014ab0 <HAL_SPI_TransmitReceive+0x26a>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8014a8a:	68fb      	ldr	r3, [r7, #12]
 8014a8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014a8e:	881a      	ldrh	r2, [r3, #0]
 8014a90:	68fb      	ldr	r3, [r7, #12]
 8014a92:	681b      	ldr	r3, [r3, #0]
 8014a94:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8014a96:	68fb      	ldr	r3, [r7, #12]
 8014a98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014a9a:	1c9a      	adds	r2, r3, #2
 8014a9c:	68fb      	ldr	r3, [r7, #12]
 8014a9e:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8014aa0:	68fb      	ldr	r3, [r7, #12]
 8014aa2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014aa4:	b29b      	uxth	r3, r3
 8014aa6:	3b02      	subs	r3, #2
 8014aa8:	b29a      	uxth	r2, r3
 8014aaa:	68fb      	ldr	r3, [r7, #12]
 8014aac:	87da      	strh	r2, [r3, #62]	; 0x3e
 8014aae:	e0b2      	b.n	8014c16 <HAL_SPI_TransmitReceive+0x3d0>
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8014ab0:	68fb      	ldr	r3, [r7, #12]
 8014ab2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014ab4:	68fb      	ldr	r3, [r7, #12]
 8014ab6:	681b      	ldr	r3, [r3, #0]
 8014ab8:	330c      	adds	r3, #12
 8014aba:	7812      	ldrb	r2, [r2, #0]
 8014abc:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 8014abe:	68fb      	ldr	r3, [r7, #12]
 8014ac0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014ac2:	1c5a      	adds	r2, r3, #1
 8014ac4:	68fb      	ldr	r3, [r7, #12]
 8014ac6:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->TxXferCount--;
 8014ac8:	68fb      	ldr	r3, [r7, #12]
 8014aca:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014acc:	b29b      	uxth	r3, r3
 8014ace:	3b01      	subs	r3, #1
 8014ad0:	b29a      	uxth	r2, r3
 8014ad2:	68fb      	ldr	r3, [r7, #12]
 8014ad4:	87da      	strh	r2, [r3, #62]	; 0x3e
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8014ad6:	e09e      	b.n	8014c16 <HAL_SPI_TransmitReceive+0x3d0>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8014ad8:	68fb      	ldr	r3, [r7, #12]
 8014ada:	681b      	ldr	r3, [r3, #0]
 8014adc:	689b      	ldr	r3, [r3, #8]
 8014ade:	f003 0302 	and.w	r3, r3, #2
 8014ae2:	2b02      	cmp	r3, #2
 8014ae4:	d134      	bne.n	8014b50 <HAL_SPI_TransmitReceive+0x30a>
 8014ae6:	68fb      	ldr	r3, [r7, #12]
 8014ae8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014aea:	b29b      	uxth	r3, r3
 8014aec:	2b00      	cmp	r3, #0
 8014aee:	d02f      	beq.n	8014b50 <HAL_SPI_TransmitReceive+0x30a>
 8014af0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014af2:	2b01      	cmp	r3, #1
 8014af4:	d12c      	bne.n	8014b50 <HAL_SPI_TransmitReceive+0x30a>
      {
        if (hspi->TxXferCount > 1U)
 8014af6:	68fb      	ldr	r3, [r7, #12]
 8014af8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014afa:	b29b      	uxth	r3, r3
 8014afc:	2b01      	cmp	r3, #1
 8014afe:	d912      	bls.n	8014b26 <HAL_SPI_TransmitReceive+0x2e0>
        {
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8014b00:	68fb      	ldr	r3, [r7, #12]
 8014b02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014b04:	881a      	ldrh	r2, [r3, #0]
 8014b06:	68fb      	ldr	r3, [r7, #12]
 8014b08:	681b      	ldr	r3, [r3, #0]
 8014b0a:	60da      	str	r2, [r3, #12]
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8014b0c:	68fb      	ldr	r3, [r7, #12]
 8014b0e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014b10:	1c9a      	adds	r2, r3, #2
 8014b12:	68fb      	ldr	r3, [r7, #12]
 8014b14:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 8014b16:	68fb      	ldr	r3, [r7, #12]
 8014b18:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014b1a:	b29b      	uxth	r3, r3
 8014b1c:	3b02      	subs	r3, #2
 8014b1e:	b29a      	uxth	r2, r3
 8014b20:	68fb      	ldr	r3, [r7, #12]
 8014b22:	87da      	strh	r2, [r3, #62]	; 0x3e
 8014b24:	e012      	b.n	8014b4c <HAL_SPI_TransmitReceive+0x306>
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8014b26:	68fb      	ldr	r3, [r7, #12]
 8014b28:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014b2a:	68fb      	ldr	r3, [r7, #12]
 8014b2c:	681b      	ldr	r3, [r3, #0]
 8014b2e:	330c      	adds	r3, #12
 8014b30:	7812      	ldrb	r2, [r2, #0]
 8014b32:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr++;
 8014b34:	68fb      	ldr	r3, [r7, #12]
 8014b36:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014b38:	1c5a      	adds	r2, r3, #1
 8014b3a:	68fb      	ldr	r3, [r7, #12]
 8014b3c:	639a      	str	r2, [r3, #56]	; 0x38
          hspi->TxXferCount--;
 8014b3e:	68fb      	ldr	r3, [r7, #12]
 8014b40:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014b42:	b29b      	uxth	r3, r3
 8014b44:	3b01      	subs	r3, #1
 8014b46:	b29a      	uxth	r2, r3
 8014b48:	68fb      	ldr	r3, [r7, #12]
 8014b4a:	87da      	strh	r2, [r3, #62]	; 0x3e
        }
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 8014b4c:	2300      	movs	r3, #0
 8014b4e:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8014b50:	68fb      	ldr	r3, [r7, #12]
 8014b52:	681b      	ldr	r3, [r3, #0]
 8014b54:	689b      	ldr	r3, [r3, #8]
 8014b56:	f003 0301 	and.w	r3, r3, #1
 8014b5a:	2b01      	cmp	r3, #1
 8014b5c:	d148      	bne.n	8014bf0 <HAL_SPI_TransmitReceive+0x3aa>
 8014b5e:	68fb      	ldr	r3, [r7, #12]
 8014b60:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014b64:	b29b      	uxth	r3, r3
 8014b66:	2b00      	cmp	r3, #0
 8014b68:	d042      	beq.n	8014bf0 <HAL_SPI_TransmitReceive+0x3aa>
      {
        if (hspi->RxXferCount > 1U)
 8014b6a:	68fb      	ldr	r3, [r7, #12]
 8014b6c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014b70:	b29b      	uxth	r3, r3
 8014b72:	2b01      	cmp	r3, #1
 8014b74:	d923      	bls.n	8014bbe <HAL_SPI_TransmitReceive+0x378>
        {
          *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8014b76:	68fb      	ldr	r3, [r7, #12]
 8014b78:	681b      	ldr	r3, [r3, #0]
 8014b7a:	68da      	ldr	r2, [r3, #12]
 8014b7c:	68fb      	ldr	r3, [r7, #12]
 8014b7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014b80:	b292      	uxth	r2, r2
 8014b82:	801a      	strh	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8014b84:	68fb      	ldr	r3, [r7, #12]
 8014b86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014b88:	1c9a      	adds	r2, r3, #2
 8014b8a:	68fb      	ldr	r3, [r7, #12]
 8014b8c:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount -= 2U;
 8014b8e:	68fb      	ldr	r3, [r7, #12]
 8014b90:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014b94:	b29b      	uxth	r3, r3
 8014b96:	3b02      	subs	r3, #2
 8014b98:	b29a      	uxth	r2, r3
 8014b9a:	68fb      	ldr	r3, [r7, #12]
 8014b9c:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8014ba0:	68fb      	ldr	r3, [r7, #12]
 8014ba2:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014ba6:	b29b      	uxth	r3, r3
 8014ba8:	2b01      	cmp	r3, #1
 8014baa:	d81f      	bhi.n	8014bec <HAL_SPI_TransmitReceive+0x3a6>
          {
            /* Set RX Fifo threshold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8014bac:	68fb      	ldr	r3, [r7, #12]
 8014bae:	681b      	ldr	r3, [r3, #0]
 8014bb0:	685a      	ldr	r2, [r3, #4]
 8014bb2:	68fb      	ldr	r3, [r7, #12]
 8014bb4:	681b      	ldr	r3, [r3, #0]
 8014bb6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8014bba:	605a      	str	r2, [r3, #4]
 8014bbc:	e016      	b.n	8014bec <HAL_SPI_TransmitReceive+0x3a6>
          }
        }
        else
        {
          (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 8014bbe:	68fb      	ldr	r3, [r7, #12]
 8014bc0:	681b      	ldr	r3, [r3, #0]
 8014bc2:	f103 020c 	add.w	r2, r3, #12
 8014bc6:	68fb      	ldr	r3, [r7, #12]
 8014bc8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014bca:	7812      	ldrb	r2, [r2, #0]
 8014bcc:	b2d2      	uxtb	r2, r2
 8014bce:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr++;
 8014bd0:	68fb      	ldr	r3, [r7, #12]
 8014bd2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014bd4:	1c5a      	adds	r2, r3, #1
 8014bd6:	68fb      	ldr	r3, [r7, #12]
 8014bd8:	641a      	str	r2, [r3, #64]	; 0x40
          hspi->RxXferCount--;
 8014bda:	68fb      	ldr	r3, [r7, #12]
 8014bdc:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014be0:	b29b      	uxth	r3, r3
 8014be2:	3b01      	subs	r3, #1
 8014be4:	b29a      	uxth	r2, r3
 8014be6:	68fb      	ldr	r3, [r7, #12]
 8014be8:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8014bec:	2301      	movs	r3, #1
 8014bee:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8014bf0:	f7f7 ff4a 	bl	800ca88 <HAL_GetTick>
 8014bf4:	4602      	mov	r2, r0
 8014bf6:	69fb      	ldr	r3, [r7, #28]
 8014bf8:	1ad3      	subs	r3, r2, r3
 8014bfa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014bfc:	429a      	cmp	r2, r3
 8014bfe:	d803      	bhi.n	8014c08 <HAL_SPI_TransmitReceive+0x3c2>
 8014c00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c02:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014c06:	d102      	bne.n	8014c0e <HAL_SPI_TransmitReceive+0x3c8>
 8014c08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c0a:	2b00      	cmp	r3, #0
 8014c0c:	d103      	bne.n	8014c16 <HAL_SPI_TransmitReceive+0x3d0>
      {
        errorcode = HAL_TIMEOUT;
 8014c0e:	2303      	movs	r3, #3
 8014c10:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        goto error;
 8014c14:	e01c      	b.n	8014c50 <HAL_SPI_TransmitReceive+0x40a>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8014c16:	68fb      	ldr	r3, [r7, #12]
 8014c18:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8014c1a:	b29b      	uxth	r3, r3
 8014c1c:	2b00      	cmp	r3, #0
 8014c1e:	f47f af5b 	bne.w	8014ad8 <HAL_SPI_TransmitReceive+0x292>
 8014c22:	68fb      	ldr	r3, [r7, #12]
 8014c24:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014c28:	b29b      	uxth	r3, r3
 8014c2a:	2b00      	cmp	r3, #0
 8014c2c:	f47f af54 	bne.w	8014ad8 <HAL_SPI_TransmitReceive+0x292>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8014c30:	69fa      	ldr	r2, [r7, #28]
 8014c32:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8014c34:	68f8      	ldr	r0, [r7, #12]
 8014c36:	f000 f98f 	bl	8014f58 <SPI_EndRxTxTransaction>
 8014c3a:	4603      	mov	r3, r0
 8014c3c:	2b00      	cmp	r3, #0
 8014c3e:	d006      	beq.n	8014c4e <HAL_SPI_TransmitReceive+0x408>
  {
    errorcode = HAL_ERROR;
 8014c40:	2301      	movs	r3, #1
 8014c42:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8014c46:	68fb      	ldr	r3, [r7, #12]
 8014c48:	2220      	movs	r2, #32
 8014c4a:	661a      	str	r2, [r3, #96]	; 0x60
 8014c4c:	e000      	b.n	8014c50 <HAL_SPI_TransmitReceive+0x40a>
  }

error :
 8014c4e:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 8014c50:	68fb      	ldr	r3, [r7, #12]
 8014c52:	2201      	movs	r2, #1
 8014c54:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8014c58:	68fb      	ldr	r3, [r7, #12]
 8014c5a:	2200      	movs	r2, #0
 8014c5c:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 8014c60:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
}
 8014c64:	4618      	mov	r0, r3
 8014c66:	3728      	adds	r7, #40	; 0x28
 8014c68:	46bd      	mov	sp, r7
 8014c6a:	bd80      	pop	{r7, pc}

08014c6c <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8014c6c:	b580      	push	{r7, lr}
 8014c6e:	b088      	sub	sp, #32
 8014c70:	af00      	add	r7, sp, #0
 8014c72:	60f8      	str	r0, [r7, #12]
 8014c74:	60b9      	str	r1, [r7, #8]
 8014c76:	603b      	str	r3, [r7, #0]
 8014c78:	4613      	mov	r3, r2
 8014c7a:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8014c7c:	f7f7 ff04 	bl	800ca88 <HAL_GetTick>
 8014c80:	4602      	mov	r2, r0
 8014c82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014c84:	1a9b      	subs	r3, r3, r2
 8014c86:	683a      	ldr	r2, [r7, #0]
 8014c88:	4413      	add	r3, r2
 8014c8a:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 8014c8c:	f7f7 fefc 	bl	800ca88 <HAL_GetTick>
 8014c90:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8014c92:	4b39      	ldr	r3, [pc, #228]	; (8014d78 <SPI_WaitFlagStateUntilTimeout+0x10c>)
 8014c94:	681b      	ldr	r3, [r3, #0]
 8014c96:	015b      	lsls	r3, r3, #5
 8014c98:	0d1b      	lsrs	r3, r3, #20
 8014c9a:	69fa      	ldr	r2, [r7, #28]
 8014c9c:	fb02 f303 	mul.w	r3, r2, r3
 8014ca0:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8014ca2:	e054      	b.n	8014d4e <SPI_WaitFlagStateUntilTimeout+0xe2>
  {
    if (Timeout != HAL_MAX_DELAY)
 8014ca4:	683b      	ldr	r3, [r7, #0]
 8014ca6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014caa:	d050      	beq.n	8014d4e <SPI_WaitFlagStateUntilTimeout+0xe2>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8014cac:	f7f7 feec 	bl	800ca88 <HAL_GetTick>
 8014cb0:	4602      	mov	r2, r0
 8014cb2:	69bb      	ldr	r3, [r7, #24]
 8014cb4:	1ad3      	subs	r3, r2, r3
 8014cb6:	69fa      	ldr	r2, [r7, #28]
 8014cb8:	429a      	cmp	r2, r3
 8014cba:	d902      	bls.n	8014cc2 <SPI_WaitFlagStateUntilTimeout+0x56>
 8014cbc:	69fb      	ldr	r3, [r7, #28]
 8014cbe:	2b00      	cmp	r3, #0
 8014cc0:	d13d      	bne.n	8014d3e <SPI_WaitFlagStateUntilTimeout+0xd2>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8014cc2:	68fb      	ldr	r3, [r7, #12]
 8014cc4:	681b      	ldr	r3, [r3, #0]
 8014cc6:	685a      	ldr	r2, [r3, #4]
 8014cc8:	68fb      	ldr	r3, [r7, #12]
 8014cca:	681b      	ldr	r3, [r3, #0]
 8014ccc:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8014cd0:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8014cd2:	68fb      	ldr	r3, [r7, #12]
 8014cd4:	685b      	ldr	r3, [r3, #4]
 8014cd6:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014cda:	d111      	bne.n	8014d00 <SPI_WaitFlagStateUntilTimeout+0x94>
 8014cdc:	68fb      	ldr	r3, [r7, #12]
 8014cde:	689b      	ldr	r3, [r3, #8]
 8014ce0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8014ce4:	d004      	beq.n	8014cf0 <SPI_WaitFlagStateUntilTimeout+0x84>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8014ce6:	68fb      	ldr	r3, [r7, #12]
 8014ce8:	689b      	ldr	r3, [r3, #8]
 8014cea:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8014cee:	d107      	bne.n	8014d00 <SPI_WaitFlagStateUntilTimeout+0x94>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8014cf0:	68fb      	ldr	r3, [r7, #12]
 8014cf2:	681b      	ldr	r3, [r3, #0]
 8014cf4:	681a      	ldr	r2, [r3, #0]
 8014cf6:	68fb      	ldr	r3, [r7, #12]
 8014cf8:	681b      	ldr	r3, [r3, #0]
 8014cfa:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8014cfe:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8014d00:	68fb      	ldr	r3, [r7, #12]
 8014d02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014d04:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8014d08:	d10f      	bne.n	8014d2a <SPI_WaitFlagStateUntilTimeout+0xbe>
        {
          SPI_RESET_CRC(hspi);
 8014d0a:	68fb      	ldr	r3, [r7, #12]
 8014d0c:	681b      	ldr	r3, [r3, #0]
 8014d0e:	681a      	ldr	r2, [r3, #0]
 8014d10:	68fb      	ldr	r3, [r7, #12]
 8014d12:	681b      	ldr	r3, [r3, #0]
 8014d14:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8014d18:	601a      	str	r2, [r3, #0]
 8014d1a:	68fb      	ldr	r3, [r7, #12]
 8014d1c:	681b      	ldr	r3, [r3, #0]
 8014d1e:	681a      	ldr	r2, [r3, #0]
 8014d20:	68fb      	ldr	r3, [r7, #12]
 8014d22:	681b      	ldr	r3, [r3, #0]
 8014d24:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8014d28:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8014d2a:	68fb      	ldr	r3, [r7, #12]
 8014d2c:	2201      	movs	r2, #1
 8014d2e:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8014d32:	68fb      	ldr	r3, [r7, #12]
 8014d34:	2200      	movs	r2, #0
 8014d36:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 8014d3a:	2303      	movs	r3, #3
 8014d3c:	e017      	b.n	8014d6e <SPI_WaitFlagStateUntilTimeout+0x102>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 8014d3e:	697b      	ldr	r3, [r7, #20]
 8014d40:	2b00      	cmp	r3, #0
 8014d42:	d101      	bne.n	8014d48 <SPI_WaitFlagStateUntilTimeout+0xdc>
      {
        tmp_timeout = 0U;
 8014d44:	2300      	movs	r3, #0
 8014d46:	61fb      	str	r3, [r7, #28]
      }
      count--;
 8014d48:	697b      	ldr	r3, [r7, #20]
 8014d4a:	3b01      	subs	r3, #1
 8014d4c:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8014d4e:	68fb      	ldr	r3, [r7, #12]
 8014d50:	681b      	ldr	r3, [r3, #0]
 8014d52:	689a      	ldr	r2, [r3, #8]
 8014d54:	68bb      	ldr	r3, [r7, #8]
 8014d56:	4013      	ands	r3, r2
 8014d58:	68ba      	ldr	r2, [r7, #8]
 8014d5a:	429a      	cmp	r2, r3
 8014d5c:	bf0c      	ite	eq
 8014d5e:	2301      	moveq	r3, #1
 8014d60:	2300      	movne	r3, #0
 8014d62:	b2db      	uxtb	r3, r3
 8014d64:	461a      	mov	r2, r3
 8014d66:	79fb      	ldrb	r3, [r7, #7]
 8014d68:	429a      	cmp	r2, r3
 8014d6a:	d19b      	bne.n	8014ca4 <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 8014d6c:	2300      	movs	r3, #0
}
 8014d6e:	4618      	mov	r0, r3
 8014d70:	3720      	adds	r7, #32
 8014d72:	46bd      	mov	sp, r7
 8014d74:	bd80      	pop	{r7, pc}
 8014d76:	bf00      	nop
 8014d78:	20000010 	.word	0x20000010

08014d7c <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8014d7c:	b580      	push	{r7, lr}
 8014d7e:	b08a      	sub	sp, #40	; 0x28
 8014d80:	af00      	add	r7, sp, #0
 8014d82:	60f8      	str	r0, [r7, #12]
 8014d84:	60b9      	str	r1, [r7, #8]
 8014d86:	607a      	str	r2, [r7, #4]
 8014d88:	603b      	str	r3, [r7, #0]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
 8014d8a:	2300      	movs	r3, #0
 8014d8c:	75fb      	strb	r3, [r7, #23]

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 8014d8e:	f7f7 fe7b 	bl	800ca88 <HAL_GetTick>
 8014d92:	4602      	mov	r2, r0
 8014d94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014d96:	1a9b      	subs	r3, r3, r2
 8014d98:	683a      	ldr	r2, [r7, #0]
 8014d9a:	4413      	add	r3, r2
 8014d9c:	627b      	str	r3, [r7, #36]	; 0x24
  tmp_tickstart = HAL_GetTick();
 8014d9e:	f7f7 fe73 	bl	800ca88 <HAL_GetTick>
 8014da2:	6238      	str	r0, [r7, #32]

  /* Initialize the 8bit temporary pointer */
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 8014da4:	68fb      	ldr	r3, [r7, #12]
 8014da6:	681b      	ldr	r3, [r3, #0]
 8014da8:	330c      	adds	r3, #12
 8014daa:	61fb      	str	r3, [r7, #28]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8014dac:	4b3d      	ldr	r3, [pc, #244]	; (8014ea4 <SPI_WaitFifoStateUntilTimeout+0x128>)
 8014dae:	681a      	ldr	r2, [r3, #0]
 8014db0:	4613      	mov	r3, r2
 8014db2:	009b      	lsls	r3, r3, #2
 8014db4:	4413      	add	r3, r2
 8014db6:	00da      	lsls	r2, r3, #3
 8014db8:	1ad3      	subs	r3, r2, r3
 8014dba:	0d1b      	lsrs	r3, r3, #20
 8014dbc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014dbe:	fb02 f303 	mul.w	r3, r2, r3
 8014dc2:	61bb      	str	r3, [r7, #24]

  while ((hspi->Instance->SR & Fifo) != State)
 8014dc4:	e060      	b.n	8014e88 <SPI_WaitFifoStateUntilTimeout+0x10c>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8014dc6:	68bb      	ldr	r3, [r7, #8]
 8014dc8:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8014dcc:	d107      	bne.n	8014dde <SPI_WaitFifoStateUntilTimeout+0x62>
 8014dce:	687b      	ldr	r3, [r7, #4]
 8014dd0:	2b00      	cmp	r3, #0
 8014dd2:	d104      	bne.n	8014dde <SPI_WaitFifoStateUntilTimeout+0x62>
    {
      /* Flush Data Register by a blank read */
      tmpreg8 = *ptmpreg8;
 8014dd4:	69fb      	ldr	r3, [r7, #28]
 8014dd6:	781b      	ldrb	r3, [r3, #0]
 8014dd8:	b2db      	uxtb	r3, r3
 8014dda:	75fb      	strb	r3, [r7, #23]
      /* To avoid GCC warning */
      UNUSED(tmpreg8);
 8014ddc:	7dfb      	ldrb	r3, [r7, #23]
    }

    if (Timeout != HAL_MAX_DELAY)
 8014dde:	683b      	ldr	r3, [r7, #0]
 8014de0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8014de4:	d050      	beq.n	8014e88 <SPI_WaitFifoStateUntilTimeout+0x10c>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8014de6:	f7f7 fe4f 	bl	800ca88 <HAL_GetTick>
 8014dea:	4602      	mov	r2, r0
 8014dec:	6a3b      	ldr	r3, [r7, #32]
 8014dee:	1ad3      	subs	r3, r2, r3
 8014df0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014df2:	429a      	cmp	r2, r3
 8014df4:	d902      	bls.n	8014dfc <SPI_WaitFifoStateUntilTimeout+0x80>
 8014df6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014df8:	2b00      	cmp	r3, #0
 8014dfa:	d13d      	bne.n	8014e78 <SPI_WaitFifoStateUntilTimeout+0xfc>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8014dfc:	68fb      	ldr	r3, [r7, #12]
 8014dfe:	681b      	ldr	r3, [r3, #0]
 8014e00:	685a      	ldr	r2, [r3, #4]
 8014e02:	68fb      	ldr	r3, [r7, #12]
 8014e04:	681b      	ldr	r3, [r3, #0]
 8014e06:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8014e0a:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8014e0c:	68fb      	ldr	r3, [r7, #12]
 8014e0e:	685b      	ldr	r3, [r3, #4]
 8014e10:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014e14:	d111      	bne.n	8014e3a <SPI_WaitFifoStateUntilTimeout+0xbe>
 8014e16:	68fb      	ldr	r3, [r7, #12]
 8014e18:	689b      	ldr	r3, [r3, #8]
 8014e1a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8014e1e:	d004      	beq.n	8014e2a <SPI_WaitFifoStateUntilTimeout+0xae>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8014e20:	68fb      	ldr	r3, [r7, #12]
 8014e22:	689b      	ldr	r3, [r3, #8]
 8014e24:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8014e28:	d107      	bne.n	8014e3a <SPI_WaitFifoStateUntilTimeout+0xbe>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8014e2a:	68fb      	ldr	r3, [r7, #12]
 8014e2c:	681b      	ldr	r3, [r3, #0]
 8014e2e:	681a      	ldr	r2, [r3, #0]
 8014e30:	68fb      	ldr	r3, [r7, #12]
 8014e32:	681b      	ldr	r3, [r3, #0]
 8014e34:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8014e38:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8014e3a:	68fb      	ldr	r3, [r7, #12]
 8014e3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014e3e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8014e42:	d10f      	bne.n	8014e64 <SPI_WaitFifoStateUntilTimeout+0xe8>
        {
          SPI_RESET_CRC(hspi);
 8014e44:	68fb      	ldr	r3, [r7, #12]
 8014e46:	681b      	ldr	r3, [r3, #0]
 8014e48:	681a      	ldr	r2, [r3, #0]
 8014e4a:	68fb      	ldr	r3, [r7, #12]
 8014e4c:	681b      	ldr	r3, [r3, #0]
 8014e4e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8014e52:	601a      	str	r2, [r3, #0]
 8014e54:	68fb      	ldr	r3, [r7, #12]
 8014e56:	681b      	ldr	r3, [r3, #0]
 8014e58:	681a      	ldr	r2, [r3, #0]
 8014e5a:	68fb      	ldr	r3, [r7, #12]
 8014e5c:	681b      	ldr	r3, [r3, #0]
 8014e5e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8014e62:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8014e64:	68fb      	ldr	r3, [r7, #12]
 8014e66:	2201      	movs	r2, #1
 8014e68:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8014e6c:	68fb      	ldr	r3, [r7, #12]
 8014e6e:	2200      	movs	r2, #0
 8014e70:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

        return HAL_TIMEOUT;
 8014e74:	2303      	movs	r3, #3
 8014e76:	e010      	b.n	8014e9a <SPI_WaitFifoStateUntilTimeout+0x11e>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 8014e78:	69bb      	ldr	r3, [r7, #24]
 8014e7a:	2b00      	cmp	r3, #0
 8014e7c:	d101      	bne.n	8014e82 <SPI_WaitFifoStateUntilTimeout+0x106>
      {
        tmp_timeout = 0U;
 8014e7e:	2300      	movs	r3, #0
 8014e80:	627b      	str	r3, [r7, #36]	; 0x24
      }
      count--;
 8014e82:	69bb      	ldr	r3, [r7, #24]
 8014e84:	3b01      	subs	r3, #1
 8014e86:	61bb      	str	r3, [r7, #24]
  while ((hspi->Instance->SR & Fifo) != State)
 8014e88:	68fb      	ldr	r3, [r7, #12]
 8014e8a:	681b      	ldr	r3, [r3, #0]
 8014e8c:	689a      	ldr	r2, [r3, #8]
 8014e8e:	68bb      	ldr	r3, [r7, #8]
 8014e90:	4013      	ands	r3, r2
 8014e92:	687a      	ldr	r2, [r7, #4]
 8014e94:	429a      	cmp	r2, r3
 8014e96:	d196      	bne.n	8014dc6 <SPI_WaitFifoStateUntilTimeout+0x4a>
    }
  }

  return HAL_OK;
 8014e98:	2300      	movs	r3, #0
}
 8014e9a:	4618      	mov	r0, r3
 8014e9c:	3728      	adds	r7, #40	; 0x28
 8014e9e:	46bd      	mov	sp, r7
 8014ea0:	bd80      	pop	{r7, pc}
 8014ea2:	bf00      	nop
 8014ea4:	20000010 	.word	0x20000010

08014ea8 <SPI_EndRxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
 8014ea8:	b580      	push	{r7, lr}
 8014eaa:	b086      	sub	sp, #24
 8014eac:	af02      	add	r7, sp, #8
 8014eae:	60f8      	str	r0, [r7, #12]
 8014eb0:	60b9      	str	r1, [r7, #8]
 8014eb2:	607a      	str	r2, [r7, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8014eb4:	68fb      	ldr	r3, [r7, #12]
 8014eb6:	685b      	ldr	r3, [r3, #4]
 8014eb8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014ebc:	d111      	bne.n	8014ee2 <SPI_EndRxTransaction+0x3a>
 8014ebe:	68fb      	ldr	r3, [r7, #12]
 8014ec0:	689b      	ldr	r3, [r3, #8]
 8014ec2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8014ec6:	d004      	beq.n	8014ed2 <SPI_EndRxTransaction+0x2a>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8014ec8:	68fb      	ldr	r3, [r7, #12]
 8014eca:	689b      	ldr	r3, [r3, #8]
 8014ecc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8014ed0:	d107      	bne.n	8014ee2 <SPI_EndRxTransaction+0x3a>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 8014ed2:	68fb      	ldr	r3, [r7, #12]
 8014ed4:	681b      	ldr	r3, [r3, #0]
 8014ed6:	681a      	ldr	r2, [r3, #0]
 8014ed8:	68fb      	ldr	r3, [r7, #12]
 8014eda:	681b      	ldr	r3, [r3, #0]
 8014edc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8014ee0:	601a      	str	r2, [r3, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8014ee2:	687b      	ldr	r3, [r7, #4]
 8014ee4:	9300      	str	r3, [sp, #0]
 8014ee6:	68bb      	ldr	r3, [r7, #8]
 8014ee8:	2200      	movs	r2, #0
 8014eea:	2180      	movs	r1, #128	; 0x80
 8014eec:	68f8      	ldr	r0, [r7, #12]
 8014eee:	f7ff febd 	bl	8014c6c <SPI_WaitFlagStateUntilTimeout>
 8014ef2:	4603      	mov	r3, r0
 8014ef4:	2b00      	cmp	r3, #0
 8014ef6:	d007      	beq.n	8014f08 <SPI_EndRxTransaction+0x60>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014ef8:	68fb      	ldr	r3, [r7, #12]
 8014efa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014efc:	f043 0220 	orr.w	r2, r3, #32
 8014f00:	68fb      	ldr	r3, [r7, #12]
 8014f02:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 8014f04:	2303      	movs	r3, #3
 8014f06:	e023      	b.n	8014f50 <SPI_EndRxTransaction+0xa8>
  }

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8014f08:	68fb      	ldr	r3, [r7, #12]
 8014f0a:	685b      	ldr	r3, [r3, #4]
 8014f0c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8014f10:	d11d      	bne.n	8014f4e <SPI_EndRxTransaction+0xa6>
 8014f12:	68fb      	ldr	r3, [r7, #12]
 8014f14:	689b      	ldr	r3, [r3, #8]
 8014f16:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8014f1a:	d004      	beq.n	8014f26 <SPI_EndRxTransaction+0x7e>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8014f1c:	68fb      	ldr	r3, [r7, #12]
 8014f1e:	689b      	ldr	r3, [r3, #8]
 8014f20:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8014f24:	d113      	bne.n	8014f4e <SPI_EndRxTransaction+0xa6>
  {
    /* Empty the FRLVL fifo */
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8014f26:	687b      	ldr	r3, [r7, #4]
 8014f28:	9300      	str	r3, [sp, #0]
 8014f2a:	68bb      	ldr	r3, [r7, #8]
 8014f2c:	2200      	movs	r2, #0
 8014f2e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8014f32:	68f8      	ldr	r0, [r7, #12]
 8014f34:	f7ff ff22 	bl	8014d7c <SPI_WaitFifoStateUntilTimeout>
 8014f38:	4603      	mov	r3, r0
 8014f3a:	2b00      	cmp	r3, #0
 8014f3c:	d007      	beq.n	8014f4e <SPI_EndRxTransaction+0xa6>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014f3e:	68fb      	ldr	r3, [r7, #12]
 8014f40:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014f42:	f043 0220 	orr.w	r2, r3, #32
 8014f46:	68fb      	ldr	r3, [r7, #12]
 8014f48:	661a      	str	r2, [r3, #96]	; 0x60
      return HAL_TIMEOUT;
 8014f4a:	2303      	movs	r3, #3
 8014f4c:	e000      	b.n	8014f50 <SPI_EndRxTransaction+0xa8>
    }
  }
  return HAL_OK;
 8014f4e:	2300      	movs	r3, #0
}
 8014f50:	4618      	mov	r0, r3
 8014f52:	3710      	adds	r7, #16
 8014f54:	46bd      	mov	sp, r7
 8014f56:	bd80      	pop	{r7, pc}

08014f58 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8014f58:	b580      	push	{r7, lr}
 8014f5a:	b086      	sub	sp, #24
 8014f5c:	af02      	add	r7, sp, #8
 8014f5e:	60f8      	str	r0, [r7, #12]
 8014f60:	60b9      	str	r1, [r7, #8]
 8014f62:	607a      	str	r2, [r7, #4]
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8014f64:	687b      	ldr	r3, [r7, #4]
 8014f66:	9300      	str	r3, [sp, #0]
 8014f68:	68bb      	ldr	r3, [r7, #8]
 8014f6a:	2200      	movs	r2, #0
 8014f6c:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 8014f70:	68f8      	ldr	r0, [r7, #12]
 8014f72:	f7ff ff03 	bl	8014d7c <SPI_WaitFifoStateUntilTimeout>
 8014f76:	4603      	mov	r3, r0
 8014f78:	2b00      	cmp	r3, #0
 8014f7a:	d007      	beq.n	8014f8c <SPI_EndRxTxTransaction+0x34>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014f7c:	68fb      	ldr	r3, [r7, #12]
 8014f7e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014f80:	f043 0220 	orr.w	r2, r3, #32
 8014f84:	68fb      	ldr	r3, [r7, #12]
 8014f86:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 8014f88:	2303      	movs	r3, #3
 8014f8a:	e027      	b.n	8014fdc <SPI_EndRxTxTransaction+0x84>
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8014f8c:	687b      	ldr	r3, [r7, #4]
 8014f8e:	9300      	str	r3, [sp, #0]
 8014f90:	68bb      	ldr	r3, [r7, #8]
 8014f92:	2200      	movs	r2, #0
 8014f94:	2180      	movs	r1, #128	; 0x80
 8014f96:	68f8      	ldr	r0, [r7, #12]
 8014f98:	f7ff fe68 	bl	8014c6c <SPI_WaitFlagStateUntilTimeout>
 8014f9c:	4603      	mov	r3, r0
 8014f9e:	2b00      	cmp	r3, #0
 8014fa0:	d007      	beq.n	8014fb2 <SPI_EndRxTxTransaction+0x5a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014fa2:	68fb      	ldr	r3, [r7, #12]
 8014fa4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014fa6:	f043 0220 	orr.w	r2, r3, #32
 8014faa:	68fb      	ldr	r3, [r7, #12]
 8014fac:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 8014fae:	2303      	movs	r3, #3
 8014fb0:	e014      	b.n	8014fdc <SPI_EndRxTxTransaction+0x84>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8014fb2:	687b      	ldr	r3, [r7, #4]
 8014fb4:	9300      	str	r3, [sp, #0]
 8014fb6:	68bb      	ldr	r3, [r7, #8]
 8014fb8:	2200      	movs	r2, #0
 8014fba:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8014fbe:	68f8      	ldr	r0, [r7, #12]
 8014fc0:	f7ff fedc 	bl	8014d7c <SPI_WaitFifoStateUntilTimeout>
 8014fc4:	4603      	mov	r3, r0
 8014fc6:	2b00      	cmp	r3, #0
 8014fc8:	d007      	beq.n	8014fda <SPI_EndRxTxTransaction+0x82>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8014fca:	68fb      	ldr	r3, [r7, #12]
 8014fcc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8014fce:	f043 0220 	orr.w	r2, r3, #32
 8014fd2:	68fb      	ldr	r3, [r7, #12]
 8014fd4:	661a      	str	r2, [r3, #96]	; 0x60
    return HAL_TIMEOUT;
 8014fd6:	2303      	movs	r3, #3
 8014fd8:	e000      	b.n	8014fdc <SPI_EndRxTxTransaction+0x84>
  }

  return HAL_OK;
 8014fda:	2300      	movs	r3, #0
}
 8014fdc:	4618      	mov	r0, r3
 8014fde:	3710      	adds	r7, #16
 8014fe0:	46bd      	mov	sp, r7
 8014fe2:	bd80      	pop	{r7, pc}

08014fe4 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8014fe4:	b580      	push	{r7, lr}
 8014fe6:	b082      	sub	sp, #8
 8014fe8:	af00      	add	r7, sp, #0
 8014fea:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8014fec:	687b      	ldr	r3, [r7, #4]
 8014fee:	2b00      	cmp	r3, #0
 8014ff0:	d101      	bne.n	8014ff6 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8014ff2:	2301      	movs	r3, #1
 8014ff4:	e049      	b.n	801508a <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8014ff6:	687b      	ldr	r3, [r7, #4]
 8014ff8:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8014ffc:	b2db      	uxtb	r3, r3
 8014ffe:	2b00      	cmp	r3, #0
 8015000:	d106      	bne.n	8015010 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8015002:	687b      	ldr	r3, [r7, #4]
 8015004:	2200      	movs	r2, #0
 8015006:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 801500a:	6878      	ldr	r0, [r7, #4]
 801500c:	f7f7 fc78 	bl	800c900 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8015010:	687b      	ldr	r3, [r7, #4]
 8015012:	2202      	movs	r2, #2
 8015014:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8015018:	687b      	ldr	r3, [r7, #4]
 801501a:	681a      	ldr	r2, [r3, #0]
 801501c:	687b      	ldr	r3, [r7, #4]
 801501e:	3304      	adds	r3, #4
 8015020:	4619      	mov	r1, r3
 8015022:	4610      	mov	r0, r2
 8015024:	f000 fcdc 	bl	80159e0 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8015028:	687b      	ldr	r3, [r7, #4]
 801502a:	2201      	movs	r2, #1
 801502c:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8015030:	687b      	ldr	r3, [r7, #4]
 8015032:	2201      	movs	r2, #1
 8015034:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8015038:	687b      	ldr	r3, [r7, #4]
 801503a:	2201      	movs	r2, #1
 801503c:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8015040:	687b      	ldr	r3, [r7, #4]
 8015042:	2201      	movs	r2, #1
 8015044:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8015048:	687b      	ldr	r3, [r7, #4]
 801504a:	2201      	movs	r2, #1
 801504c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8015050:	687b      	ldr	r3, [r7, #4]
 8015052:	2201      	movs	r2, #1
 8015054:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8015058:	687b      	ldr	r3, [r7, #4]
 801505a:	2201      	movs	r2, #1
 801505c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8015060:	687b      	ldr	r3, [r7, #4]
 8015062:	2201      	movs	r2, #1
 8015064:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8015068:	687b      	ldr	r3, [r7, #4]
 801506a:	2201      	movs	r2, #1
 801506c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8015070:	687b      	ldr	r3, [r7, #4]
 8015072:	2201      	movs	r2, #1
 8015074:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8015078:	687b      	ldr	r3, [r7, #4]
 801507a:	2201      	movs	r2, #1
 801507c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8015080:	687b      	ldr	r3, [r7, #4]
 8015082:	2201      	movs	r2, #1
 8015084:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8015088:	2300      	movs	r3, #0
}
 801508a:	4618      	mov	r0, r3
 801508c:	3708      	adds	r7, #8
 801508e:	46bd      	mov	sp, r7
 8015090:	bd80      	pop	{r7, pc}
	...

08015094 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 8015094:	b480      	push	{r7}
 8015096:	b085      	sub	sp, #20
 8015098:	af00      	add	r7, sp, #0
 801509a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 801509c:	687b      	ldr	r3, [r7, #4]
 801509e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80150a2:	b2db      	uxtb	r3, r3
 80150a4:	2b01      	cmp	r3, #1
 80150a6:	d001      	beq.n	80150ac <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 80150a8:	2301      	movs	r3, #1
 80150aa:	e036      	b.n	801511a <HAL_TIM_Base_Start_IT+0x86>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80150ac:	687b      	ldr	r3, [r7, #4]
 80150ae:	2202      	movs	r2, #2
 80150b0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80150b4:	687b      	ldr	r3, [r7, #4]
 80150b6:	681b      	ldr	r3, [r3, #0]
 80150b8:	68da      	ldr	r2, [r3, #12]
 80150ba:	687b      	ldr	r3, [r7, #4]
 80150bc:	681b      	ldr	r3, [r3, #0]
 80150be:	f042 0201 	orr.w	r2, r2, #1
 80150c2:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80150c4:	687b      	ldr	r3, [r7, #4]
 80150c6:	681b      	ldr	r3, [r3, #0]
 80150c8:	4a17      	ldr	r2, [pc, #92]	; (8015128 <HAL_TIM_Base_Start_IT+0x94>)
 80150ca:	4293      	cmp	r3, r2
 80150cc:	d004      	beq.n	80150d8 <HAL_TIM_Base_Start_IT+0x44>
 80150ce:	687b      	ldr	r3, [r7, #4]
 80150d0:	681b      	ldr	r3, [r3, #0]
 80150d2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80150d6:	d115      	bne.n	8015104 <HAL_TIM_Base_Start_IT+0x70>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80150d8:	687b      	ldr	r3, [r7, #4]
 80150da:	681b      	ldr	r3, [r3, #0]
 80150dc:	689a      	ldr	r2, [r3, #8]
 80150de:	4b13      	ldr	r3, [pc, #76]	; (801512c <HAL_TIM_Base_Start_IT+0x98>)
 80150e0:	4013      	ands	r3, r2
 80150e2:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80150e4:	68fb      	ldr	r3, [r7, #12]
 80150e6:	2b06      	cmp	r3, #6
 80150e8:	d015      	beq.n	8015116 <HAL_TIM_Base_Start_IT+0x82>
 80150ea:	68fb      	ldr	r3, [r7, #12]
 80150ec:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80150f0:	d011      	beq.n	8015116 <HAL_TIM_Base_Start_IT+0x82>
    {
      __HAL_TIM_ENABLE(htim);
 80150f2:	687b      	ldr	r3, [r7, #4]
 80150f4:	681b      	ldr	r3, [r3, #0]
 80150f6:	681a      	ldr	r2, [r3, #0]
 80150f8:	687b      	ldr	r3, [r7, #4]
 80150fa:	681b      	ldr	r3, [r3, #0]
 80150fc:	f042 0201 	orr.w	r2, r2, #1
 8015100:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8015102:	e008      	b.n	8015116 <HAL_TIM_Base_Start_IT+0x82>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8015104:	687b      	ldr	r3, [r7, #4]
 8015106:	681b      	ldr	r3, [r3, #0]
 8015108:	681a      	ldr	r2, [r3, #0]
 801510a:	687b      	ldr	r3, [r7, #4]
 801510c:	681b      	ldr	r3, [r3, #0]
 801510e:	f042 0201 	orr.w	r2, r2, #1
 8015112:	601a      	str	r2, [r3, #0]
 8015114:	e000      	b.n	8015118 <HAL_TIM_Base_Start_IT+0x84>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8015116:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8015118:	2300      	movs	r3, #0
}
 801511a:	4618      	mov	r0, r3
 801511c:	3714      	adds	r7, #20
 801511e:	46bd      	mov	sp, r7
 8015120:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015124:	4770      	bx	lr
 8015126:	bf00      	nop
 8015128:	40012c00 	.word	0x40012c00
 801512c:	00010007 	.word	0x00010007

08015130 <HAL_TIM_OC_Init>:
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
{
 8015130:	b580      	push	{r7, lr}
 8015132:	b082      	sub	sp, #8
 8015134:	af00      	add	r7, sp, #0
 8015136:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8015138:	687b      	ldr	r3, [r7, #4]
 801513a:	2b00      	cmp	r3, #0
 801513c:	d101      	bne.n	8015142 <HAL_TIM_OC_Init+0x12>
  {
    return HAL_ERROR;
 801513e:	2301      	movs	r3, #1
 8015140:	e049      	b.n	80151d6 <HAL_TIM_OC_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8015142:	687b      	ldr	r3, [r7, #4]
 8015144:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8015148:	b2db      	uxtb	r3, r3
 801514a:	2b00      	cmp	r3, #0
 801514c:	d106      	bne.n	801515c <HAL_TIM_OC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 801514e:	687b      	ldr	r3, [r7, #4]
 8015150:	2200      	movs	r2, #0
 8015152:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->OC_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_OC_MspInit(htim);
 8015156:	6878      	ldr	r0, [r7, #4]
 8015158:	f000 f841 	bl	80151de <HAL_TIM_OC_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 801515c:	687b      	ldr	r3, [r7, #4]
 801515e:	2202      	movs	r2, #2
 8015160:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the Output Compare */
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8015164:	687b      	ldr	r3, [r7, #4]
 8015166:	681a      	ldr	r2, [r3, #0]
 8015168:	687b      	ldr	r3, [r7, #4]
 801516a:	3304      	adds	r3, #4
 801516c:	4619      	mov	r1, r3
 801516e:	4610      	mov	r0, r2
 8015170:	f000 fc36 	bl	80159e0 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8015174:	687b      	ldr	r3, [r7, #4]
 8015176:	2201      	movs	r2, #1
 8015178:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 801517c:	687b      	ldr	r3, [r7, #4]
 801517e:	2201      	movs	r2, #1
 8015180:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8015184:	687b      	ldr	r3, [r7, #4]
 8015186:	2201      	movs	r2, #1
 8015188:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 801518c:	687b      	ldr	r3, [r7, #4]
 801518e:	2201      	movs	r2, #1
 8015190:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8015194:	687b      	ldr	r3, [r7, #4]
 8015196:	2201      	movs	r2, #1
 8015198:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 801519c:	687b      	ldr	r3, [r7, #4]
 801519e:	2201      	movs	r2, #1
 80151a0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80151a4:	687b      	ldr	r3, [r7, #4]
 80151a6:	2201      	movs	r2, #1
 80151a8:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80151ac:	687b      	ldr	r3, [r7, #4]
 80151ae:	2201      	movs	r2, #1
 80151b0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80151b4:	687b      	ldr	r3, [r7, #4]
 80151b6:	2201      	movs	r2, #1
 80151b8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80151bc:	687b      	ldr	r3, [r7, #4]
 80151be:	2201      	movs	r2, #1
 80151c0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 80151c4:	687b      	ldr	r3, [r7, #4]
 80151c6:	2201      	movs	r2, #1
 80151c8:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80151cc:	687b      	ldr	r3, [r7, #4]
 80151ce:	2201      	movs	r2, #1
 80151d0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 80151d4:	2300      	movs	r3, #0
}
 80151d6:	4618      	mov	r0, r3
 80151d8:	3708      	adds	r7, #8
 80151da:	46bd      	mov	sp, r7
 80151dc:	bd80      	pop	{r7, pc}

080151de <HAL_TIM_OC_MspInit>:
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  */
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
{
 80151de:	b480      	push	{r7}
 80151e0:	b083      	sub	sp, #12
 80151e2:	af00      	add	r7, sp, #0
 80151e4:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   */
}
 80151e6:	bf00      	nop
 80151e8:	370c      	adds	r7, #12
 80151ea:	46bd      	mov	sp, r7
 80151ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80151f0:	4770      	bx	lr

080151f2 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80151f2:	b580      	push	{r7, lr}
 80151f4:	b082      	sub	sp, #8
 80151f6:	af00      	add	r7, sp, #0
 80151f8:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80151fa:	687b      	ldr	r3, [r7, #4]
 80151fc:	2b00      	cmp	r3, #0
 80151fe:	d101      	bne.n	8015204 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 8015200:	2301      	movs	r3, #1
 8015202:	e049      	b.n	8015298 <HAL_TIM_PWM_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8015204:	687b      	ldr	r3, [r7, #4]
 8015206:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 801520a:	b2db      	uxtb	r3, r3
 801520c:	2b00      	cmp	r3, #0
 801520e:	d106      	bne.n	801521e <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8015210:	687b      	ldr	r3, [r7, #4]
 8015212:	2200      	movs	r2, #0
 8015214:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 8015218:	6878      	ldr	r0, [r7, #4]
 801521a:	f000 f841 	bl	80152a0 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 801521e:	687b      	ldr	r3, [r7, #4]
 8015220:	2202      	movs	r2, #2
 8015222:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8015226:	687b      	ldr	r3, [r7, #4]
 8015228:	681a      	ldr	r2, [r3, #0]
 801522a:	687b      	ldr	r3, [r7, #4]
 801522c:	3304      	adds	r3, #4
 801522e:	4619      	mov	r1, r3
 8015230:	4610      	mov	r0, r2
 8015232:	f000 fbd5 	bl	80159e0 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8015236:	687b      	ldr	r3, [r7, #4]
 8015238:	2201      	movs	r2, #1
 801523a:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 801523e:	687b      	ldr	r3, [r7, #4]
 8015240:	2201      	movs	r2, #1
 8015242:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8015246:	687b      	ldr	r3, [r7, #4]
 8015248:	2201      	movs	r2, #1
 801524a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 801524e:	687b      	ldr	r3, [r7, #4]
 8015250:	2201      	movs	r2, #1
 8015252:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8015256:	687b      	ldr	r3, [r7, #4]
 8015258:	2201      	movs	r2, #1
 801525a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 801525e:	687b      	ldr	r3, [r7, #4]
 8015260:	2201      	movs	r2, #1
 8015262:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8015266:	687b      	ldr	r3, [r7, #4]
 8015268:	2201      	movs	r2, #1
 801526a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 801526e:	687b      	ldr	r3, [r7, #4]
 8015270:	2201      	movs	r2, #1
 8015272:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8015276:	687b      	ldr	r3, [r7, #4]
 8015278:	2201      	movs	r2, #1
 801527a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 801527e:	687b      	ldr	r3, [r7, #4]
 8015280:	2201      	movs	r2, #1
 8015282:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8015286:	687b      	ldr	r3, [r7, #4]
 8015288:	2201      	movs	r2, #1
 801528a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 801528e:	687b      	ldr	r3, [r7, #4]
 8015290:	2201      	movs	r2, #1
 8015292:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8015296:	2300      	movs	r3, #0
}
 8015298:	4618      	mov	r0, r3
 801529a:	3708      	adds	r7, #8
 801529c:	46bd      	mov	sp, r7
 801529e:	bd80      	pop	{r7, pc}

080152a0 <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 80152a0:	b480      	push	{r7}
 80152a2:	b083      	sub	sp, #12
 80152a4:	af00      	add	r7, sp, #0
 80152a6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
 80152a8:	bf00      	nop
 80152aa:	370c      	adds	r7, #12
 80152ac:	46bd      	mov	sp, r7
 80152ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152b2:	4770      	bx	lr

080152b4 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80152b4:	b580      	push	{r7, lr}
 80152b6:	b082      	sub	sp, #8
 80152b8:	af00      	add	r7, sp, #0
 80152ba:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80152bc:	687b      	ldr	r3, [r7, #4]
 80152be:	681b      	ldr	r3, [r3, #0]
 80152c0:	691b      	ldr	r3, [r3, #16]
 80152c2:	f003 0302 	and.w	r3, r3, #2
 80152c6:	2b02      	cmp	r3, #2
 80152c8:	d122      	bne.n	8015310 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80152ca:	687b      	ldr	r3, [r7, #4]
 80152cc:	681b      	ldr	r3, [r3, #0]
 80152ce:	68db      	ldr	r3, [r3, #12]
 80152d0:	f003 0302 	and.w	r3, r3, #2
 80152d4:	2b02      	cmp	r3, #2
 80152d6:	d11b      	bne.n	8015310 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80152d8:	687b      	ldr	r3, [r7, #4]
 80152da:	681b      	ldr	r3, [r3, #0]
 80152dc:	f06f 0202 	mvn.w	r2, #2
 80152e0:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80152e2:	687b      	ldr	r3, [r7, #4]
 80152e4:	2201      	movs	r2, #1
 80152e6:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80152e8:	687b      	ldr	r3, [r7, #4]
 80152ea:	681b      	ldr	r3, [r3, #0]
 80152ec:	699b      	ldr	r3, [r3, #24]
 80152ee:	f003 0303 	and.w	r3, r3, #3
 80152f2:	2b00      	cmp	r3, #0
 80152f4:	d003      	beq.n	80152fe <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 80152f6:	6878      	ldr	r0, [r7, #4]
 80152f8:	f000 fb5d 	bl	80159b6 <HAL_TIM_IC_CaptureCallback>
 80152fc:	e005      	b.n	801530a <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80152fe:	6878      	ldr	r0, [r7, #4]
 8015300:	f000 fb4f 	bl	80159a2 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8015304:	6878      	ldr	r0, [r7, #4]
 8015306:	f7f3 ff6d 	bl	80091e4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801530a:	687b      	ldr	r3, [r7, #4]
 801530c:	2200      	movs	r2, #0
 801530e:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8015310:	687b      	ldr	r3, [r7, #4]
 8015312:	681b      	ldr	r3, [r3, #0]
 8015314:	691b      	ldr	r3, [r3, #16]
 8015316:	f003 0304 	and.w	r3, r3, #4
 801531a:	2b04      	cmp	r3, #4
 801531c:	d122      	bne.n	8015364 <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 801531e:	687b      	ldr	r3, [r7, #4]
 8015320:	681b      	ldr	r3, [r3, #0]
 8015322:	68db      	ldr	r3, [r3, #12]
 8015324:	f003 0304 	and.w	r3, r3, #4
 8015328:	2b04      	cmp	r3, #4
 801532a:	d11b      	bne.n	8015364 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 801532c:	687b      	ldr	r3, [r7, #4]
 801532e:	681b      	ldr	r3, [r3, #0]
 8015330:	f06f 0204 	mvn.w	r2, #4
 8015334:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8015336:	687b      	ldr	r3, [r7, #4]
 8015338:	2202      	movs	r2, #2
 801533a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 801533c:	687b      	ldr	r3, [r7, #4]
 801533e:	681b      	ldr	r3, [r3, #0]
 8015340:	699b      	ldr	r3, [r3, #24]
 8015342:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8015346:	2b00      	cmp	r3, #0
 8015348:	d003      	beq.n	8015352 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 801534a:	6878      	ldr	r0, [r7, #4]
 801534c:	f000 fb33 	bl	80159b6 <HAL_TIM_IC_CaptureCallback>
 8015350:	e005      	b.n	801535e <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8015352:	6878      	ldr	r0, [r7, #4]
 8015354:	f000 fb25 	bl	80159a2 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8015358:	6878      	ldr	r0, [r7, #4]
 801535a:	f7f3 ff43 	bl	80091e4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801535e:	687b      	ldr	r3, [r7, #4]
 8015360:	2200      	movs	r2, #0
 8015362:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8015364:	687b      	ldr	r3, [r7, #4]
 8015366:	681b      	ldr	r3, [r3, #0]
 8015368:	691b      	ldr	r3, [r3, #16]
 801536a:	f003 0308 	and.w	r3, r3, #8
 801536e:	2b08      	cmp	r3, #8
 8015370:	d122      	bne.n	80153b8 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8015372:	687b      	ldr	r3, [r7, #4]
 8015374:	681b      	ldr	r3, [r3, #0]
 8015376:	68db      	ldr	r3, [r3, #12]
 8015378:	f003 0308 	and.w	r3, r3, #8
 801537c:	2b08      	cmp	r3, #8
 801537e:	d11b      	bne.n	80153b8 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8015380:	687b      	ldr	r3, [r7, #4]
 8015382:	681b      	ldr	r3, [r3, #0]
 8015384:	f06f 0208 	mvn.w	r2, #8
 8015388:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 801538a:	687b      	ldr	r3, [r7, #4]
 801538c:	2204      	movs	r2, #4
 801538e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8015390:	687b      	ldr	r3, [r7, #4]
 8015392:	681b      	ldr	r3, [r3, #0]
 8015394:	69db      	ldr	r3, [r3, #28]
 8015396:	f003 0303 	and.w	r3, r3, #3
 801539a:	2b00      	cmp	r3, #0
 801539c:	d003      	beq.n	80153a6 <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 801539e:	6878      	ldr	r0, [r7, #4]
 80153a0:	f000 fb09 	bl	80159b6 <HAL_TIM_IC_CaptureCallback>
 80153a4:	e005      	b.n	80153b2 <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80153a6:	6878      	ldr	r0, [r7, #4]
 80153a8:	f000 fafb 	bl	80159a2 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80153ac:	6878      	ldr	r0, [r7, #4]
 80153ae:	f7f3 ff19 	bl	80091e4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80153b2:	687b      	ldr	r3, [r7, #4]
 80153b4:	2200      	movs	r2, #0
 80153b6:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80153b8:	687b      	ldr	r3, [r7, #4]
 80153ba:	681b      	ldr	r3, [r3, #0]
 80153bc:	691b      	ldr	r3, [r3, #16]
 80153be:	f003 0310 	and.w	r3, r3, #16
 80153c2:	2b10      	cmp	r3, #16
 80153c4:	d122      	bne.n	801540c <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80153c6:	687b      	ldr	r3, [r7, #4]
 80153c8:	681b      	ldr	r3, [r3, #0]
 80153ca:	68db      	ldr	r3, [r3, #12]
 80153cc:	f003 0310 	and.w	r3, r3, #16
 80153d0:	2b10      	cmp	r3, #16
 80153d2:	d11b      	bne.n	801540c <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80153d4:	687b      	ldr	r3, [r7, #4]
 80153d6:	681b      	ldr	r3, [r3, #0]
 80153d8:	f06f 0210 	mvn.w	r2, #16
 80153dc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80153de:	687b      	ldr	r3, [r7, #4]
 80153e0:	2208      	movs	r2, #8
 80153e2:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80153e4:	687b      	ldr	r3, [r7, #4]
 80153e6:	681b      	ldr	r3, [r3, #0]
 80153e8:	69db      	ldr	r3, [r3, #28]
 80153ea:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80153ee:	2b00      	cmp	r3, #0
 80153f0:	d003      	beq.n	80153fa <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80153f2:	6878      	ldr	r0, [r7, #4]
 80153f4:	f000 fadf 	bl	80159b6 <HAL_TIM_IC_CaptureCallback>
 80153f8:	e005      	b.n	8015406 <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80153fa:	6878      	ldr	r0, [r7, #4]
 80153fc:	f000 fad1 	bl	80159a2 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8015400:	6878      	ldr	r0, [r7, #4]
 8015402:	f7f3 feef 	bl	80091e4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8015406:	687b      	ldr	r3, [r7, #4]
 8015408:	2200      	movs	r2, #0
 801540a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 801540c:	687b      	ldr	r3, [r7, #4]
 801540e:	681b      	ldr	r3, [r3, #0]
 8015410:	691b      	ldr	r3, [r3, #16]
 8015412:	f003 0301 	and.w	r3, r3, #1
 8015416:	2b01      	cmp	r3, #1
 8015418:	d10e      	bne.n	8015438 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 801541a:	687b      	ldr	r3, [r7, #4]
 801541c:	681b      	ldr	r3, [r3, #0]
 801541e:	68db      	ldr	r3, [r3, #12]
 8015420:	f003 0301 	and.w	r3, r3, #1
 8015424:	2b01      	cmp	r3, #1
 8015426:	d107      	bne.n	8015438 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8015428:	687b      	ldr	r3, [r7, #4]
 801542a:	681b      	ldr	r3, [r3, #0]
 801542c:	f06f 0201 	mvn.w	r2, #1
 8015430:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8015432:	6878      	ldr	r0, [r7, #4]
 8015434:	f7f5 fd48 	bl	800aec8 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8015438:	687b      	ldr	r3, [r7, #4]
 801543a:	681b      	ldr	r3, [r3, #0]
 801543c:	691b      	ldr	r3, [r3, #16]
 801543e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8015442:	2b80      	cmp	r3, #128	; 0x80
 8015444:	d10e      	bne.n	8015464 <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8015446:	687b      	ldr	r3, [r7, #4]
 8015448:	681b      	ldr	r3, [r3, #0]
 801544a:	68db      	ldr	r3, [r3, #12]
 801544c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8015450:	2b80      	cmp	r3, #128	; 0x80
 8015452:	d107      	bne.n	8015464 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8015454:	687b      	ldr	r3, [r7, #4]
 8015456:	681b      	ldr	r3, [r3, #0]
 8015458:	f06f 0280 	mvn.w	r2, #128	; 0x80
 801545c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 801545e:	6878      	ldr	r0, [r7, #4]
 8015460:	f000 ff36 	bl	80162d0 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8015464:	687b      	ldr	r3, [r7, #4]
 8015466:	681b      	ldr	r3, [r3, #0]
 8015468:	691b      	ldr	r3, [r3, #16]
 801546a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801546e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8015472:	d10e      	bne.n	8015492 <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8015474:	687b      	ldr	r3, [r7, #4]
 8015476:	681b      	ldr	r3, [r3, #0]
 8015478:	68db      	ldr	r3, [r3, #12]
 801547a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801547e:	2b80      	cmp	r3, #128	; 0x80
 8015480:	d107      	bne.n	8015492 <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8015482:	687b      	ldr	r3, [r7, #4]
 8015484:	681b      	ldr	r3, [r3, #0]
 8015486:	f46f 7280 	mvn.w	r2, #256	; 0x100
 801548a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 801548c:	6878      	ldr	r0, [r7, #4]
 801548e:	f000 ff29 	bl	80162e4 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8015492:	687b      	ldr	r3, [r7, #4]
 8015494:	681b      	ldr	r3, [r3, #0]
 8015496:	691b      	ldr	r3, [r3, #16]
 8015498:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801549c:	2b40      	cmp	r3, #64	; 0x40
 801549e:	d10e      	bne.n	80154be <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80154a0:	687b      	ldr	r3, [r7, #4]
 80154a2:	681b      	ldr	r3, [r3, #0]
 80154a4:	68db      	ldr	r3, [r3, #12]
 80154a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80154aa:	2b40      	cmp	r3, #64	; 0x40
 80154ac:	d107      	bne.n	80154be <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80154ae:	687b      	ldr	r3, [r7, #4]
 80154b0:	681b      	ldr	r3, [r3, #0]
 80154b2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80154b6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80154b8:	6878      	ldr	r0, [r7, #4]
 80154ba:	f000 fa86 	bl	80159ca <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80154be:	687b      	ldr	r3, [r7, #4]
 80154c0:	681b      	ldr	r3, [r3, #0]
 80154c2:	691b      	ldr	r3, [r3, #16]
 80154c4:	f003 0320 	and.w	r3, r3, #32
 80154c8:	2b20      	cmp	r3, #32
 80154ca:	d10e      	bne.n	80154ea <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80154cc:	687b      	ldr	r3, [r7, #4]
 80154ce:	681b      	ldr	r3, [r3, #0]
 80154d0:	68db      	ldr	r3, [r3, #12]
 80154d2:	f003 0320 	and.w	r3, r3, #32
 80154d6:	2b20      	cmp	r3, #32
 80154d8:	d107      	bne.n	80154ea <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80154da:	687b      	ldr	r3, [r7, #4]
 80154dc:	681b      	ldr	r3, [r3, #0]
 80154de:	f06f 0220 	mvn.w	r2, #32
 80154e2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80154e4:	6878      	ldr	r0, [r7, #4]
 80154e6:	f000 fee9 	bl	80162bc <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80154ea:	bf00      	nop
 80154ec:	3708      	adds	r7, #8
 80154ee:	46bd      	mov	sp, r7
 80154f0:	bd80      	pop	{r7, pc}
	...

080154f4 <HAL_TIM_OC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
                                           TIM_OC_InitTypeDef *sConfig,
                                           uint32_t Channel)
{
 80154f4:	b580      	push	{r7, lr}
 80154f6:	b086      	sub	sp, #24
 80154f8:	af00      	add	r7, sp, #0
 80154fa:	60f8      	str	r0, [r7, #12]
 80154fc:	60b9      	str	r1, [r7, #8]
 80154fe:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8015500:	2300      	movs	r3, #0
 8015502:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));

  /* Process Locked */
  __HAL_LOCK(htim);
 8015504:	68fb      	ldr	r3, [r7, #12]
 8015506:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 801550a:	2b01      	cmp	r3, #1
 801550c:	d101      	bne.n	8015512 <HAL_TIM_OC_ConfigChannel+0x1e>
 801550e:	2302      	movs	r3, #2
 8015510:	e066      	b.n	80155e0 <HAL_TIM_OC_ConfigChannel+0xec>
 8015512:	68fb      	ldr	r3, [r7, #12]
 8015514:	2201      	movs	r2, #1
 8015516:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 801551a:	687b      	ldr	r3, [r7, #4]
 801551c:	2b14      	cmp	r3, #20
 801551e:	d857      	bhi.n	80155d0 <HAL_TIM_OC_ConfigChannel+0xdc>
 8015520:	a201      	add	r2, pc, #4	; (adr r2, 8015528 <HAL_TIM_OC_ConfigChannel+0x34>)
 8015522:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015526:	bf00      	nop
 8015528:	0801557d 	.word	0x0801557d
 801552c:	080155d1 	.word	0x080155d1
 8015530:	080155d1 	.word	0x080155d1
 8015534:	080155d1 	.word	0x080155d1
 8015538:	0801558b 	.word	0x0801558b
 801553c:	080155d1 	.word	0x080155d1
 8015540:	080155d1 	.word	0x080155d1
 8015544:	080155d1 	.word	0x080155d1
 8015548:	08015599 	.word	0x08015599
 801554c:	080155d1 	.word	0x080155d1
 8015550:	080155d1 	.word	0x080155d1
 8015554:	080155d1 	.word	0x080155d1
 8015558:	080155a7 	.word	0x080155a7
 801555c:	080155d1 	.word	0x080155d1
 8015560:	080155d1 	.word	0x080155d1
 8015564:	080155d1 	.word	0x080155d1
 8015568:	080155b5 	.word	0x080155b5
 801556c:	080155d1 	.word	0x080155d1
 8015570:	080155d1 	.word	0x080155d1
 8015574:	080155d1 	.word	0x080155d1
 8015578:	080155c3 	.word	0x080155c3
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 1 in Output Compare */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 801557c:	68fb      	ldr	r3, [r7, #12]
 801557e:	681b      	ldr	r3, [r3, #0]
 8015580:	68b9      	ldr	r1, [r7, #8]
 8015582:	4618      	mov	r0, r3
 8015584:	f000 fa90 	bl	8015aa8 <TIM_OC1_SetConfig>
      break;
 8015588:	e025      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 2 in Output Compare */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 801558a:	68fb      	ldr	r3, [r7, #12]
 801558c:	681b      	ldr	r3, [r3, #0]
 801558e:	68b9      	ldr	r1, [r7, #8]
 8015590:	4618      	mov	r0, r3
 8015592:	f000 fb05 	bl	8015ba0 <TIM_OC2_SetConfig>
      break;
 8015596:	e01e      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 3 in Output Compare */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8015598:	68fb      	ldr	r3, [r7, #12]
 801559a:	681b      	ldr	r3, [r3, #0]
 801559c:	68b9      	ldr	r1, [r7, #8]
 801559e:	4618      	mov	r0, r3
 80155a0:	f000 fb78 	bl	8015c94 <TIM_OC3_SetConfig>
      break;
 80155a4:	e017      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 4 in Output Compare */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80155a6:	68fb      	ldr	r3, [r7, #12]
 80155a8:	681b      	ldr	r3, [r3, #0]
 80155aa:	68b9      	ldr	r1, [r7, #8]
 80155ac:	4618      	mov	r0, r3
 80155ae:	f000 fbe9 	bl	8015d84 <TIM_OC4_SetConfig>
      break;
 80155b2:	e010      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 5 in Output Compare */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 80155b4:	68fb      	ldr	r3, [r7, #12]
 80155b6:	681b      	ldr	r3, [r3, #0]
 80155b8:	68b9      	ldr	r1, [r7, #8]
 80155ba:	4618      	mov	r0, r3
 80155bc:	f000 fc40 	bl	8015e40 <TIM_OC5_SetConfig>
      break;
 80155c0:	e009      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the TIM Channel 6 in Output Compare */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80155c2:	68fb      	ldr	r3, [r7, #12]
 80155c4:	681b      	ldr	r3, [r3, #0]
 80155c6:	68b9      	ldr	r1, [r7, #8]
 80155c8:	4618      	mov	r0, r3
 80155ca:	f000 fc91 	bl	8015ef0 <TIM_OC6_SetConfig>
      break;
 80155ce:	e002      	b.n	80155d6 <HAL_TIM_OC_ConfigChannel+0xe2>
    }

    default:
      status = HAL_ERROR;
 80155d0:	2301      	movs	r3, #1
 80155d2:	75fb      	strb	r3, [r7, #23]
      break;
 80155d4:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 80155d6:	68fb      	ldr	r3, [r7, #12]
 80155d8:	2200      	movs	r2, #0
 80155da:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 80155de:	7dfb      	ldrb	r3, [r7, #23]
}
 80155e0:	4618      	mov	r0, r3
 80155e2:	3718      	adds	r7, #24
 80155e4:	46bd      	mov	sp, r7
 80155e6:	bd80      	pop	{r7, pc}

080155e8 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 80155e8:	b580      	push	{r7, lr}
 80155ea:	b086      	sub	sp, #24
 80155ec:	af00      	add	r7, sp, #0
 80155ee:	60f8      	str	r0, [r7, #12]
 80155f0:	60b9      	str	r1, [r7, #8]
 80155f2:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80155f4:	2300      	movs	r3, #0
 80155f6:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 80155f8:	68fb      	ldr	r3, [r7, #12]
 80155fa:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80155fe:	2b01      	cmp	r3, #1
 8015600:	d101      	bne.n	8015606 <HAL_TIM_PWM_ConfigChannel+0x1e>
 8015602:	2302      	movs	r3, #2
 8015604:	e0ff      	b.n	8015806 <HAL_TIM_PWM_ConfigChannel+0x21e>
 8015606:	68fb      	ldr	r3, [r7, #12]
 8015608:	2201      	movs	r2, #1
 801560a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 801560e:	687b      	ldr	r3, [r7, #4]
 8015610:	2b14      	cmp	r3, #20
 8015612:	f200 80f0 	bhi.w	80157f6 <HAL_TIM_PWM_ConfigChannel+0x20e>
 8015616:	a201      	add	r2, pc, #4	; (adr r2, 801561c <HAL_TIM_PWM_ConfigChannel+0x34>)
 8015618:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801561c:	08015671 	.word	0x08015671
 8015620:	080157f7 	.word	0x080157f7
 8015624:	080157f7 	.word	0x080157f7
 8015628:	080157f7 	.word	0x080157f7
 801562c:	080156b1 	.word	0x080156b1
 8015630:	080157f7 	.word	0x080157f7
 8015634:	080157f7 	.word	0x080157f7
 8015638:	080157f7 	.word	0x080157f7
 801563c:	080156f3 	.word	0x080156f3
 8015640:	080157f7 	.word	0x080157f7
 8015644:	080157f7 	.word	0x080157f7
 8015648:	080157f7 	.word	0x080157f7
 801564c:	08015733 	.word	0x08015733
 8015650:	080157f7 	.word	0x080157f7
 8015654:	080157f7 	.word	0x080157f7
 8015658:	080157f7 	.word	0x080157f7
 801565c:	08015775 	.word	0x08015775
 8015660:	080157f7 	.word	0x080157f7
 8015664:	080157f7 	.word	0x080157f7
 8015668:	080157f7 	.word	0x080157f7
 801566c:	080157b5 	.word	0x080157b5
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8015670:	68fb      	ldr	r3, [r7, #12]
 8015672:	681b      	ldr	r3, [r3, #0]
 8015674:	68b9      	ldr	r1, [r7, #8]
 8015676:	4618      	mov	r0, r3
 8015678:	f000 fa16 	bl	8015aa8 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 801567c:	68fb      	ldr	r3, [r7, #12]
 801567e:	681b      	ldr	r3, [r3, #0]
 8015680:	699a      	ldr	r2, [r3, #24]
 8015682:	68fb      	ldr	r3, [r7, #12]
 8015684:	681b      	ldr	r3, [r3, #0]
 8015686:	f042 0208 	orr.w	r2, r2, #8
 801568a:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 801568c:	68fb      	ldr	r3, [r7, #12]
 801568e:	681b      	ldr	r3, [r3, #0]
 8015690:	699a      	ldr	r2, [r3, #24]
 8015692:	68fb      	ldr	r3, [r7, #12]
 8015694:	681b      	ldr	r3, [r3, #0]
 8015696:	f022 0204 	bic.w	r2, r2, #4
 801569a:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 801569c:	68fb      	ldr	r3, [r7, #12]
 801569e:	681b      	ldr	r3, [r3, #0]
 80156a0:	6999      	ldr	r1, [r3, #24]
 80156a2:	68bb      	ldr	r3, [r7, #8]
 80156a4:	691a      	ldr	r2, [r3, #16]
 80156a6:	68fb      	ldr	r3, [r7, #12]
 80156a8:	681b      	ldr	r3, [r3, #0]
 80156aa:	430a      	orrs	r2, r1
 80156ac:	619a      	str	r2, [r3, #24]
      break;
 80156ae:	e0a5      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80156b0:	68fb      	ldr	r3, [r7, #12]
 80156b2:	681b      	ldr	r3, [r3, #0]
 80156b4:	68b9      	ldr	r1, [r7, #8]
 80156b6:	4618      	mov	r0, r3
 80156b8:	f000 fa72 	bl	8015ba0 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80156bc:	68fb      	ldr	r3, [r7, #12]
 80156be:	681b      	ldr	r3, [r3, #0]
 80156c0:	699a      	ldr	r2, [r3, #24]
 80156c2:	68fb      	ldr	r3, [r7, #12]
 80156c4:	681b      	ldr	r3, [r3, #0]
 80156c6:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80156ca:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80156cc:	68fb      	ldr	r3, [r7, #12]
 80156ce:	681b      	ldr	r3, [r3, #0]
 80156d0:	699a      	ldr	r2, [r3, #24]
 80156d2:	68fb      	ldr	r3, [r7, #12]
 80156d4:	681b      	ldr	r3, [r3, #0]
 80156d6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80156da:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80156dc:	68fb      	ldr	r3, [r7, #12]
 80156de:	681b      	ldr	r3, [r3, #0]
 80156e0:	6999      	ldr	r1, [r3, #24]
 80156e2:	68bb      	ldr	r3, [r7, #8]
 80156e4:	691b      	ldr	r3, [r3, #16]
 80156e6:	021a      	lsls	r2, r3, #8
 80156e8:	68fb      	ldr	r3, [r7, #12]
 80156ea:	681b      	ldr	r3, [r3, #0]
 80156ec:	430a      	orrs	r2, r1
 80156ee:	619a      	str	r2, [r3, #24]
      break;
 80156f0:	e084      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80156f2:	68fb      	ldr	r3, [r7, #12]
 80156f4:	681b      	ldr	r3, [r3, #0]
 80156f6:	68b9      	ldr	r1, [r7, #8]
 80156f8:	4618      	mov	r0, r3
 80156fa:	f000 facb 	bl	8015c94 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80156fe:	68fb      	ldr	r3, [r7, #12]
 8015700:	681b      	ldr	r3, [r3, #0]
 8015702:	69da      	ldr	r2, [r3, #28]
 8015704:	68fb      	ldr	r3, [r7, #12]
 8015706:	681b      	ldr	r3, [r3, #0]
 8015708:	f042 0208 	orr.w	r2, r2, #8
 801570c:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 801570e:	68fb      	ldr	r3, [r7, #12]
 8015710:	681b      	ldr	r3, [r3, #0]
 8015712:	69da      	ldr	r2, [r3, #28]
 8015714:	68fb      	ldr	r3, [r7, #12]
 8015716:	681b      	ldr	r3, [r3, #0]
 8015718:	f022 0204 	bic.w	r2, r2, #4
 801571c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 801571e:	68fb      	ldr	r3, [r7, #12]
 8015720:	681b      	ldr	r3, [r3, #0]
 8015722:	69d9      	ldr	r1, [r3, #28]
 8015724:	68bb      	ldr	r3, [r7, #8]
 8015726:	691a      	ldr	r2, [r3, #16]
 8015728:	68fb      	ldr	r3, [r7, #12]
 801572a:	681b      	ldr	r3, [r3, #0]
 801572c:	430a      	orrs	r2, r1
 801572e:	61da      	str	r2, [r3, #28]
      break;
 8015730:	e064      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8015732:	68fb      	ldr	r3, [r7, #12]
 8015734:	681b      	ldr	r3, [r3, #0]
 8015736:	68b9      	ldr	r1, [r7, #8]
 8015738:	4618      	mov	r0, r3
 801573a:	f000 fb23 	bl	8015d84 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 801573e:	68fb      	ldr	r3, [r7, #12]
 8015740:	681b      	ldr	r3, [r3, #0]
 8015742:	69da      	ldr	r2, [r3, #28]
 8015744:	68fb      	ldr	r3, [r7, #12]
 8015746:	681b      	ldr	r3, [r3, #0]
 8015748:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 801574c:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 801574e:	68fb      	ldr	r3, [r7, #12]
 8015750:	681b      	ldr	r3, [r3, #0]
 8015752:	69da      	ldr	r2, [r3, #28]
 8015754:	68fb      	ldr	r3, [r7, #12]
 8015756:	681b      	ldr	r3, [r3, #0]
 8015758:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 801575c:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 801575e:	68fb      	ldr	r3, [r7, #12]
 8015760:	681b      	ldr	r3, [r3, #0]
 8015762:	69d9      	ldr	r1, [r3, #28]
 8015764:	68bb      	ldr	r3, [r7, #8]
 8015766:	691b      	ldr	r3, [r3, #16]
 8015768:	021a      	lsls	r2, r3, #8
 801576a:	68fb      	ldr	r3, [r7, #12]
 801576c:	681b      	ldr	r3, [r3, #0]
 801576e:	430a      	orrs	r2, r1
 8015770:	61da      	str	r2, [r3, #28]
      break;
 8015772:	e043      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8015774:	68fb      	ldr	r3, [r7, #12]
 8015776:	681b      	ldr	r3, [r3, #0]
 8015778:	68b9      	ldr	r1, [r7, #8]
 801577a:	4618      	mov	r0, r3
 801577c:	f000 fb60 	bl	8015e40 <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8015780:	68fb      	ldr	r3, [r7, #12]
 8015782:	681b      	ldr	r3, [r3, #0]
 8015784:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8015786:	68fb      	ldr	r3, [r7, #12]
 8015788:	681b      	ldr	r3, [r3, #0]
 801578a:	f042 0208 	orr.w	r2, r2, #8
 801578e:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8015790:	68fb      	ldr	r3, [r7, #12]
 8015792:	681b      	ldr	r3, [r3, #0]
 8015794:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8015796:	68fb      	ldr	r3, [r7, #12]
 8015798:	681b      	ldr	r3, [r3, #0]
 801579a:	f022 0204 	bic.w	r2, r2, #4
 801579e:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 80157a0:	68fb      	ldr	r3, [r7, #12]
 80157a2:	681b      	ldr	r3, [r3, #0]
 80157a4:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80157a6:	68bb      	ldr	r3, [r7, #8]
 80157a8:	691a      	ldr	r2, [r3, #16]
 80157aa:	68fb      	ldr	r3, [r7, #12]
 80157ac:	681b      	ldr	r3, [r3, #0]
 80157ae:	430a      	orrs	r2, r1
 80157b0:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 80157b2:	e023      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the Channel 6 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80157b4:	68fb      	ldr	r3, [r7, #12]
 80157b6:	681b      	ldr	r3, [r3, #0]
 80157b8:	68b9      	ldr	r1, [r7, #8]
 80157ba:	4618      	mov	r0, r3
 80157bc:	f000 fb98 	bl	8015ef0 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80157c0:	68fb      	ldr	r3, [r7, #12]
 80157c2:	681b      	ldr	r3, [r3, #0]
 80157c4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80157c6:	68fb      	ldr	r3, [r7, #12]
 80157c8:	681b      	ldr	r3, [r3, #0]
 80157ca:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80157ce:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 80157d0:	68fb      	ldr	r3, [r7, #12]
 80157d2:	681b      	ldr	r3, [r3, #0]
 80157d4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80157d6:	68fb      	ldr	r3, [r7, #12]
 80157d8:	681b      	ldr	r3, [r3, #0]
 80157da:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80157de:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 80157e0:	68fb      	ldr	r3, [r7, #12]
 80157e2:	681b      	ldr	r3, [r3, #0]
 80157e4:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80157e6:	68bb      	ldr	r3, [r7, #8]
 80157e8:	691b      	ldr	r3, [r3, #16]
 80157ea:	021a      	lsls	r2, r3, #8
 80157ec:	68fb      	ldr	r3, [r7, #12]
 80157ee:	681b      	ldr	r3, [r3, #0]
 80157f0:	430a      	orrs	r2, r1
 80157f2:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 80157f4:	e002      	b.n	80157fc <HAL_TIM_PWM_ConfigChannel+0x214>
    }

    default:
      status = HAL_ERROR;
 80157f6:	2301      	movs	r3, #1
 80157f8:	75fb      	strb	r3, [r7, #23]
      break;
 80157fa:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 80157fc:	68fb      	ldr	r3, [r7, #12]
 80157fe:	2200      	movs	r2, #0
 8015800:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 8015804:	7dfb      	ldrb	r3, [r7, #23]
}
 8015806:	4618      	mov	r0, r3
 8015808:	3718      	adds	r7, #24
 801580a:	46bd      	mov	sp, r7
 801580c:	bd80      	pop	{r7, pc}
 801580e:	bf00      	nop

08015810 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 8015810:	b580      	push	{r7, lr}
 8015812:	b084      	sub	sp, #16
 8015814:	af00      	add	r7, sp, #0
 8015816:	6078      	str	r0, [r7, #4]
 8015818:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 801581a:	2300      	movs	r3, #0
 801581c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 801581e:	687b      	ldr	r3, [r7, #4]
 8015820:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8015824:	2b01      	cmp	r3, #1
 8015826:	d101      	bne.n	801582c <HAL_TIM_ConfigClockSource+0x1c>
 8015828:	2302      	movs	r3, #2
 801582a:	e0b6      	b.n	801599a <HAL_TIM_ConfigClockSource+0x18a>
 801582c:	687b      	ldr	r3, [r7, #4]
 801582e:	2201      	movs	r2, #1
 8015830:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 8015834:	687b      	ldr	r3, [r7, #4]
 8015836:	2202      	movs	r2, #2
 8015838:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 801583c:	687b      	ldr	r3, [r7, #4]
 801583e:	681b      	ldr	r3, [r3, #0]
 8015840:	689b      	ldr	r3, [r3, #8]
 8015842:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8015844:	68bb      	ldr	r3, [r7, #8]
 8015846:	f423 1344 	bic.w	r3, r3, #3211264	; 0x310000
 801584a:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 801584e:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8015850:	68bb      	ldr	r3, [r7, #8]
 8015852:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8015856:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 8015858:	687b      	ldr	r3, [r7, #4]
 801585a:	681b      	ldr	r3, [r3, #0]
 801585c:	68ba      	ldr	r2, [r7, #8]
 801585e:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 8015860:	683b      	ldr	r3, [r7, #0]
 8015862:	681b      	ldr	r3, [r3, #0]
 8015864:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8015868:	d03e      	beq.n	80158e8 <HAL_TIM_ConfigClockSource+0xd8>
 801586a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801586e:	f200 8087 	bhi.w	8015980 <HAL_TIM_ConfigClockSource+0x170>
 8015872:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8015876:	f000 8086 	beq.w	8015986 <HAL_TIM_ConfigClockSource+0x176>
 801587a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801587e:	d87f      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 8015880:	2b70      	cmp	r3, #112	; 0x70
 8015882:	d01a      	beq.n	80158ba <HAL_TIM_ConfigClockSource+0xaa>
 8015884:	2b70      	cmp	r3, #112	; 0x70
 8015886:	d87b      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 8015888:	2b60      	cmp	r3, #96	; 0x60
 801588a:	d050      	beq.n	801592e <HAL_TIM_ConfigClockSource+0x11e>
 801588c:	2b60      	cmp	r3, #96	; 0x60
 801588e:	d877      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 8015890:	2b50      	cmp	r3, #80	; 0x50
 8015892:	d03c      	beq.n	801590e <HAL_TIM_ConfigClockSource+0xfe>
 8015894:	2b50      	cmp	r3, #80	; 0x50
 8015896:	d873      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 8015898:	2b40      	cmp	r3, #64	; 0x40
 801589a:	d058      	beq.n	801594e <HAL_TIM_ConfigClockSource+0x13e>
 801589c:	2b40      	cmp	r3, #64	; 0x40
 801589e:	d86f      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 80158a0:	2b30      	cmp	r3, #48	; 0x30
 80158a2:	d064      	beq.n	801596e <HAL_TIM_ConfigClockSource+0x15e>
 80158a4:	2b30      	cmp	r3, #48	; 0x30
 80158a6:	d86b      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 80158a8:	2b20      	cmp	r3, #32
 80158aa:	d060      	beq.n	801596e <HAL_TIM_ConfigClockSource+0x15e>
 80158ac:	2b20      	cmp	r3, #32
 80158ae:	d867      	bhi.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
 80158b0:	2b00      	cmp	r3, #0
 80158b2:	d05c      	beq.n	801596e <HAL_TIM_ConfigClockSource+0x15e>
 80158b4:	2b10      	cmp	r3, #16
 80158b6:	d05a      	beq.n	801596e <HAL_TIM_ConfigClockSource+0x15e>
 80158b8:	e062      	b.n	8015980 <HAL_TIM_ConfigClockSource+0x170>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 80158ba:	687b      	ldr	r3, [r7, #4]
 80158bc:	6818      	ldr	r0, [r3, #0]
 80158be:	683b      	ldr	r3, [r7, #0]
 80158c0:	6899      	ldr	r1, [r3, #8]
 80158c2:	683b      	ldr	r3, [r7, #0]
 80158c4:	685a      	ldr	r2, [r3, #4]
 80158c6:	683b      	ldr	r3, [r7, #0]
 80158c8:	68db      	ldr	r3, [r3, #12]
 80158ca:	f000 fbe7 	bl	801609c <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 80158ce:	687b      	ldr	r3, [r7, #4]
 80158d0:	681b      	ldr	r3, [r3, #0]
 80158d2:	689b      	ldr	r3, [r3, #8]
 80158d4:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 80158d6:	68bb      	ldr	r3, [r7, #8]
 80158d8:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 80158dc:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 80158de:	687b      	ldr	r3, [r7, #4]
 80158e0:	681b      	ldr	r3, [r3, #0]
 80158e2:	68ba      	ldr	r2, [r7, #8]
 80158e4:	609a      	str	r2, [r3, #8]
      break;
 80158e6:	e04f      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 80158e8:	687b      	ldr	r3, [r7, #4]
 80158ea:	6818      	ldr	r0, [r3, #0]
 80158ec:	683b      	ldr	r3, [r7, #0]
 80158ee:	6899      	ldr	r1, [r3, #8]
 80158f0:	683b      	ldr	r3, [r7, #0]
 80158f2:	685a      	ldr	r2, [r3, #4]
 80158f4:	683b      	ldr	r3, [r7, #0]
 80158f6:	68db      	ldr	r3, [r3, #12]
 80158f8:	f000 fbd0 	bl	801609c <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80158fc:	687b      	ldr	r3, [r7, #4]
 80158fe:	681b      	ldr	r3, [r3, #0]
 8015900:	689a      	ldr	r2, [r3, #8]
 8015902:	687b      	ldr	r3, [r7, #4]
 8015904:	681b      	ldr	r3, [r3, #0]
 8015906:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801590a:	609a      	str	r2, [r3, #8]
      break;
 801590c:	e03c      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 801590e:	687b      	ldr	r3, [r7, #4]
 8015910:	6818      	ldr	r0, [r3, #0]
 8015912:	683b      	ldr	r3, [r7, #0]
 8015914:	6859      	ldr	r1, [r3, #4]
 8015916:	683b      	ldr	r3, [r7, #0]
 8015918:	68db      	ldr	r3, [r3, #12]
 801591a:	461a      	mov	r2, r3
 801591c:	f000 fb42 	bl	8015fa4 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 8015920:	687b      	ldr	r3, [r7, #4]
 8015922:	681b      	ldr	r3, [r3, #0]
 8015924:	2150      	movs	r1, #80	; 0x50
 8015926:	4618      	mov	r0, r3
 8015928:	f000 fb9b 	bl	8016062 <TIM_ITRx_SetConfig>
      break;
 801592c:	e02c      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 801592e:	687b      	ldr	r3, [r7, #4]
 8015930:	6818      	ldr	r0, [r3, #0]
 8015932:	683b      	ldr	r3, [r7, #0]
 8015934:	6859      	ldr	r1, [r3, #4]
 8015936:	683b      	ldr	r3, [r7, #0]
 8015938:	68db      	ldr	r3, [r3, #12]
 801593a:	461a      	mov	r2, r3
 801593c:	f000 fb61 	bl	8016002 <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	681b      	ldr	r3, [r3, #0]
 8015944:	2160      	movs	r1, #96	; 0x60
 8015946:	4618      	mov	r0, r3
 8015948:	f000 fb8b 	bl	8016062 <TIM_ITRx_SetConfig>
      break;
 801594c:	e01c      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 801594e:	687b      	ldr	r3, [r7, #4]
 8015950:	6818      	ldr	r0, [r3, #0]
 8015952:	683b      	ldr	r3, [r7, #0]
 8015954:	6859      	ldr	r1, [r3, #4]
 8015956:	683b      	ldr	r3, [r7, #0]
 8015958:	68db      	ldr	r3, [r3, #12]
 801595a:	461a      	mov	r2, r3
 801595c:	f000 fb22 	bl	8015fa4 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 8015960:	687b      	ldr	r3, [r7, #4]
 8015962:	681b      	ldr	r3, [r3, #0]
 8015964:	2140      	movs	r1, #64	; 0x40
 8015966:	4618      	mov	r0, r3
 8015968:	f000 fb7b 	bl	8016062 <TIM_ITRx_SetConfig>
      break;
 801596c:	e00c      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>
    case TIM_CLOCKSOURCE_ITR3:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 801596e:	687b      	ldr	r3, [r7, #4]
 8015970:	681a      	ldr	r2, [r3, #0]
 8015972:	683b      	ldr	r3, [r7, #0]
 8015974:	681b      	ldr	r3, [r3, #0]
 8015976:	4619      	mov	r1, r3
 8015978:	4610      	mov	r0, r2
 801597a:	f000 fb72 	bl	8016062 <TIM_ITRx_SetConfig>
      break;
 801597e:	e003      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>
    }

    default:
      status = HAL_ERROR;
 8015980:	2301      	movs	r3, #1
 8015982:	73fb      	strb	r3, [r7, #15]
      break;
 8015984:	e000      	b.n	8015988 <HAL_TIM_ConfigClockSource+0x178>
      break;
 8015986:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 8015988:	687b      	ldr	r3, [r7, #4]
 801598a:	2201      	movs	r2, #1
 801598c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8015990:	687b      	ldr	r3, [r7, #4]
 8015992:	2200      	movs	r2, #0
 8015994:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 8015998:	7bfb      	ldrb	r3, [r7, #15]
}
 801599a:	4618      	mov	r0, r3
 801599c:	3710      	adds	r7, #16
 801599e:	46bd      	mov	sp, r7
 80159a0:	bd80      	pop	{r7, pc}

080159a2 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 80159a2:	b480      	push	{r7}
 80159a4:	b083      	sub	sp, #12
 80159a6:	af00      	add	r7, sp, #0
 80159a8:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 80159aa:	bf00      	nop
 80159ac:	370c      	adds	r7, #12
 80159ae:	46bd      	mov	sp, r7
 80159b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80159b4:	4770      	bx	lr

080159b6 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80159b6:	b480      	push	{r7}
 80159b8:	b083      	sub	sp, #12
 80159ba:	af00      	add	r7, sp, #0
 80159bc:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 80159be:	bf00      	nop
 80159c0:	370c      	adds	r7, #12
 80159c2:	46bd      	mov	sp, r7
 80159c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80159c8:	4770      	bx	lr

080159ca <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 80159ca:	b480      	push	{r7}
 80159cc:	b083      	sub	sp, #12
 80159ce:	af00      	add	r7, sp, #0
 80159d0:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80159d2:	bf00      	nop
 80159d4:	370c      	adds	r7, #12
 80159d6:	46bd      	mov	sp, r7
 80159d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80159dc:	4770      	bx	lr
	...

080159e0 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80159e0:	b480      	push	{r7}
 80159e2:	b085      	sub	sp, #20
 80159e4:	af00      	add	r7, sp, #0
 80159e6:	6078      	str	r0, [r7, #4]
 80159e8:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80159ea:	687b      	ldr	r3, [r7, #4]
 80159ec:	681b      	ldr	r3, [r3, #0]
 80159ee:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80159f0:	687b      	ldr	r3, [r7, #4]
 80159f2:	4a2a      	ldr	r2, [pc, #168]	; (8015a9c <TIM_Base_SetConfig+0xbc>)
 80159f4:	4293      	cmp	r3, r2
 80159f6:	d003      	beq.n	8015a00 <TIM_Base_SetConfig+0x20>
 80159f8:	687b      	ldr	r3, [r7, #4]
 80159fa:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80159fe:	d108      	bne.n	8015a12 <TIM_Base_SetConfig+0x32>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8015a00:	68fb      	ldr	r3, [r7, #12]
 8015a02:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8015a06:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8015a08:	683b      	ldr	r3, [r7, #0]
 8015a0a:	685b      	ldr	r3, [r3, #4]
 8015a0c:	68fa      	ldr	r2, [r7, #12]
 8015a0e:	4313      	orrs	r3, r2
 8015a10:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8015a12:	687b      	ldr	r3, [r7, #4]
 8015a14:	4a21      	ldr	r2, [pc, #132]	; (8015a9c <TIM_Base_SetConfig+0xbc>)
 8015a16:	4293      	cmp	r3, r2
 8015a18:	d00b      	beq.n	8015a32 <TIM_Base_SetConfig+0x52>
 8015a1a:	687b      	ldr	r3, [r7, #4]
 8015a1c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8015a20:	d007      	beq.n	8015a32 <TIM_Base_SetConfig+0x52>
 8015a22:	687b      	ldr	r3, [r7, #4]
 8015a24:	4a1e      	ldr	r2, [pc, #120]	; (8015aa0 <TIM_Base_SetConfig+0xc0>)
 8015a26:	4293      	cmp	r3, r2
 8015a28:	d003      	beq.n	8015a32 <TIM_Base_SetConfig+0x52>
 8015a2a:	687b      	ldr	r3, [r7, #4]
 8015a2c:	4a1d      	ldr	r2, [pc, #116]	; (8015aa4 <TIM_Base_SetConfig+0xc4>)
 8015a2e:	4293      	cmp	r3, r2
 8015a30:	d108      	bne.n	8015a44 <TIM_Base_SetConfig+0x64>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8015a32:	68fb      	ldr	r3, [r7, #12]
 8015a34:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8015a38:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8015a3a:	683b      	ldr	r3, [r7, #0]
 8015a3c:	68db      	ldr	r3, [r3, #12]
 8015a3e:	68fa      	ldr	r2, [r7, #12]
 8015a40:	4313      	orrs	r3, r2
 8015a42:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8015a44:	68fb      	ldr	r3, [r7, #12]
 8015a46:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8015a4a:	683b      	ldr	r3, [r7, #0]
 8015a4c:	695b      	ldr	r3, [r3, #20]
 8015a4e:	4313      	orrs	r3, r2
 8015a50:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8015a52:	687b      	ldr	r3, [r7, #4]
 8015a54:	68fa      	ldr	r2, [r7, #12]
 8015a56:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8015a58:	683b      	ldr	r3, [r7, #0]
 8015a5a:	689a      	ldr	r2, [r3, #8]
 8015a5c:	687b      	ldr	r3, [r7, #4]
 8015a5e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8015a60:	683b      	ldr	r3, [r7, #0]
 8015a62:	681a      	ldr	r2, [r3, #0]
 8015a64:	687b      	ldr	r3, [r7, #4]
 8015a66:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8015a68:	687b      	ldr	r3, [r7, #4]
 8015a6a:	4a0c      	ldr	r2, [pc, #48]	; (8015a9c <TIM_Base_SetConfig+0xbc>)
 8015a6c:	4293      	cmp	r3, r2
 8015a6e:	d007      	beq.n	8015a80 <TIM_Base_SetConfig+0xa0>
 8015a70:	687b      	ldr	r3, [r7, #4]
 8015a72:	4a0b      	ldr	r2, [pc, #44]	; (8015aa0 <TIM_Base_SetConfig+0xc0>)
 8015a74:	4293      	cmp	r3, r2
 8015a76:	d003      	beq.n	8015a80 <TIM_Base_SetConfig+0xa0>
 8015a78:	687b      	ldr	r3, [r7, #4]
 8015a7a:	4a0a      	ldr	r2, [pc, #40]	; (8015aa4 <TIM_Base_SetConfig+0xc4>)
 8015a7c:	4293      	cmp	r3, r2
 8015a7e:	d103      	bne.n	8015a88 <TIM_Base_SetConfig+0xa8>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8015a80:	683b      	ldr	r3, [r7, #0]
 8015a82:	691a      	ldr	r2, [r3, #16]
 8015a84:	687b      	ldr	r3, [r7, #4]
 8015a86:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8015a88:	687b      	ldr	r3, [r7, #4]
 8015a8a:	2201      	movs	r2, #1
 8015a8c:	615a      	str	r2, [r3, #20]
}
 8015a8e:	bf00      	nop
 8015a90:	3714      	adds	r7, #20
 8015a92:	46bd      	mov	sp, r7
 8015a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015a98:	4770      	bx	lr
 8015a9a:	bf00      	nop
 8015a9c:	40012c00 	.word	0x40012c00
 8015aa0:	40014400 	.word	0x40014400
 8015aa4:	40014800 	.word	0x40014800

08015aa8 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8015aa8:	b480      	push	{r7}
 8015aaa:	b087      	sub	sp, #28
 8015aac:	af00      	add	r7, sp, #0
 8015aae:	6078      	str	r0, [r7, #4]
 8015ab0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8015ab2:	687b      	ldr	r3, [r7, #4]
 8015ab4:	6a1b      	ldr	r3, [r3, #32]
 8015ab6:	f023 0201 	bic.w	r2, r3, #1
 8015aba:	687b      	ldr	r3, [r7, #4]
 8015abc:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015abe:	687b      	ldr	r3, [r7, #4]
 8015ac0:	6a1b      	ldr	r3, [r3, #32]
 8015ac2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015ac4:	687b      	ldr	r3, [r7, #4]
 8015ac6:	685b      	ldr	r3, [r3, #4]
 8015ac8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8015aca:	687b      	ldr	r3, [r7, #4]
 8015acc:	699b      	ldr	r3, [r3, #24]
 8015ace:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8015ad0:	68fb      	ldr	r3, [r7, #12]
 8015ad2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015ad6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8015ada:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8015adc:	68fb      	ldr	r3, [r7, #12]
 8015ade:	f023 0303 	bic.w	r3, r3, #3
 8015ae2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8015ae4:	683b      	ldr	r3, [r7, #0]
 8015ae6:	681b      	ldr	r3, [r3, #0]
 8015ae8:	68fa      	ldr	r2, [r7, #12]
 8015aea:	4313      	orrs	r3, r2
 8015aec:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8015aee:	697b      	ldr	r3, [r7, #20]
 8015af0:	f023 0302 	bic.w	r3, r3, #2
 8015af4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8015af6:	683b      	ldr	r3, [r7, #0]
 8015af8:	689b      	ldr	r3, [r3, #8]
 8015afa:	697a      	ldr	r2, [r7, #20]
 8015afc:	4313      	orrs	r3, r2
 8015afe:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8015b00:	687b      	ldr	r3, [r7, #4]
 8015b02:	4a24      	ldr	r2, [pc, #144]	; (8015b94 <TIM_OC1_SetConfig+0xec>)
 8015b04:	4293      	cmp	r3, r2
 8015b06:	d007      	beq.n	8015b18 <TIM_OC1_SetConfig+0x70>
 8015b08:	687b      	ldr	r3, [r7, #4]
 8015b0a:	4a23      	ldr	r2, [pc, #140]	; (8015b98 <TIM_OC1_SetConfig+0xf0>)
 8015b0c:	4293      	cmp	r3, r2
 8015b0e:	d003      	beq.n	8015b18 <TIM_OC1_SetConfig+0x70>
 8015b10:	687b      	ldr	r3, [r7, #4]
 8015b12:	4a22      	ldr	r2, [pc, #136]	; (8015b9c <TIM_OC1_SetConfig+0xf4>)
 8015b14:	4293      	cmp	r3, r2
 8015b16:	d10c      	bne.n	8015b32 <TIM_OC1_SetConfig+0x8a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8015b18:	697b      	ldr	r3, [r7, #20]
 8015b1a:	f023 0308 	bic.w	r3, r3, #8
 8015b1e:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8015b20:	683b      	ldr	r3, [r7, #0]
 8015b22:	68db      	ldr	r3, [r3, #12]
 8015b24:	697a      	ldr	r2, [r7, #20]
 8015b26:	4313      	orrs	r3, r2
 8015b28:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8015b2a:	697b      	ldr	r3, [r7, #20]
 8015b2c:	f023 0304 	bic.w	r3, r3, #4
 8015b30:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015b32:	687b      	ldr	r3, [r7, #4]
 8015b34:	4a17      	ldr	r2, [pc, #92]	; (8015b94 <TIM_OC1_SetConfig+0xec>)
 8015b36:	4293      	cmp	r3, r2
 8015b38:	d007      	beq.n	8015b4a <TIM_OC1_SetConfig+0xa2>
 8015b3a:	687b      	ldr	r3, [r7, #4]
 8015b3c:	4a17      	ldr	r2, [pc, #92]	; (8015b9c <TIM_OC1_SetConfig+0xf4>)
 8015b3e:	4293      	cmp	r3, r2
 8015b40:	d003      	beq.n	8015b4a <TIM_OC1_SetConfig+0xa2>
 8015b42:	687b      	ldr	r3, [r7, #4]
 8015b44:	4a14      	ldr	r2, [pc, #80]	; (8015b98 <TIM_OC1_SetConfig+0xf0>)
 8015b46:	4293      	cmp	r3, r2
 8015b48:	d111      	bne.n	8015b6e <TIM_OC1_SetConfig+0xc6>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8015b4a:	693b      	ldr	r3, [r7, #16]
 8015b4c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8015b50:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8015b52:	693b      	ldr	r3, [r7, #16]
 8015b54:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8015b58:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8015b5a:	683b      	ldr	r3, [r7, #0]
 8015b5c:	695b      	ldr	r3, [r3, #20]
 8015b5e:	693a      	ldr	r2, [r7, #16]
 8015b60:	4313      	orrs	r3, r2
 8015b62:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8015b64:	683b      	ldr	r3, [r7, #0]
 8015b66:	699b      	ldr	r3, [r3, #24]
 8015b68:	693a      	ldr	r2, [r7, #16]
 8015b6a:	4313      	orrs	r3, r2
 8015b6c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015b6e:	687b      	ldr	r3, [r7, #4]
 8015b70:	693a      	ldr	r2, [r7, #16]
 8015b72:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8015b74:	687b      	ldr	r3, [r7, #4]
 8015b76:	68fa      	ldr	r2, [r7, #12]
 8015b78:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8015b7a:	683b      	ldr	r3, [r7, #0]
 8015b7c:	685a      	ldr	r2, [r3, #4]
 8015b7e:	687b      	ldr	r3, [r7, #4]
 8015b80:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015b82:	687b      	ldr	r3, [r7, #4]
 8015b84:	697a      	ldr	r2, [r7, #20]
 8015b86:	621a      	str	r2, [r3, #32]
}
 8015b88:	bf00      	nop
 8015b8a:	371c      	adds	r7, #28
 8015b8c:	46bd      	mov	sp, r7
 8015b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015b92:	4770      	bx	lr
 8015b94:	40012c00 	.word	0x40012c00
 8015b98:	40014800 	.word	0x40014800
 8015b9c:	40014400 	.word	0x40014400

08015ba0 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8015ba0:	b480      	push	{r7}
 8015ba2:	b087      	sub	sp, #28
 8015ba4:	af00      	add	r7, sp, #0
 8015ba6:	6078      	str	r0, [r7, #4]
 8015ba8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8015baa:	687b      	ldr	r3, [r7, #4]
 8015bac:	6a1b      	ldr	r3, [r3, #32]
 8015bae:	f023 0210 	bic.w	r2, r3, #16
 8015bb2:	687b      	ldr	r3, [r7, #4]
 8015bb4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015bb6:	687b      	ldr	r3, [r7, #4]
 8015bb8:	6a1b      	ldr	r3, [r3, #32]
 8015bba:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015bbc:	687b      	ldr	r3, [r7, #4]
 8015bbe:	685b      	ldr	r3, [r3, #4]
 8015bc0:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8015bc2:	687b      	ldr	r3, [r7, #4]
 8015bc4:	699b      	ldr	r3, [r3, #24]
 8015bc6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8015bc8:	68fb      	ldr	r3, [r7, #12]
 8015bca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8015bce:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8015bd2:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8015bd4:	68fb      	ldr	r3, [r7, #12]
 8015bd6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8015bda:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8015bdc:	683b      	ldr	r3, [r7, #0]
 8015bde:	681b      	ldr	r3, [r3, #0]
 8015be0:	021b      	lsls	r3, r3, #8
 8015be2:	68fa      	ldr	r2, [r7, #12]
 8015be4:	4313      	orrs	r3, r2
 8015be6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8015be8:	697b      	ldr	r3, [r7, #20]
 8015bea:	f023 0320 	bic.w	r3, r3, #32
 8015bee:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8015bf0:	683b      	ldr	r3, [r7, #0]
 8015bf2:	689b      	ldr	r3, [r3, #8]
 8015bf4:	011b      	lsls	r3, r3, #4
 8015bf6:	697a      	ldr	r2, [r7, #20]
 8015bf8:	4313      	orrs	r3, r2
 8015bfa:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8015bfc:	687b      	ldr	r3, [r7, #4]
 8015bfe:	4a22      	ldr	r2, [pc, #136]	; (8015c88 <TIM_OC2_SetConfig+0xe8>)
 8015c00:	4293      	cmp	r3, r2
 8015c02:	d10d      	bne.n	8015c20 <TIM_OC2_SetConfig+0x80>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8015c04:	697b      	ldr	r3, [r7, #20]
 8015c06:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8015c0a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8015c0c:	683b      	ldr	r3, [r7, #0]
 8015c0e:	68db      	ldr	r3, [r3, #12]
 8015c10:	011b      	lsls	r3, r3, #4
 8015c12:	697a      	ldr	r2, [r7, #20]
 8015c14:	4313      	orrs	r3, r2
 8015c16:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8015c18:	697b      	ldr	r3, [r7, #20]
 8015c1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8015c1e:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015c20:	687b      	ldr	r3, [r7, #4]
 8015c22:	4a19      	ldr	r2, [pc, #100]	; (8015c88 <TIM_OC2_SetConfig+0xe8>)
 8015c24:	4293      	cmp	r3, r2
 8015c26:	d007      	beq.n	8015c38 <TIM_OC2_SetConfig+0x98>
 8015c28:	687b      	ldr	r3, [r7, #4]
 8015c2a:	4a18      	ldr	r2, [pc, #96]	; (8015c8c <TIM_OC2_SetConfig+0xec>)
 8015c2c:	4293      	cmp	r3, r2
 8015c2e:	d003      	beq.n	8015c38 <TIM_OC2_SetConfig+0x98>
 8015c30:	687b      	ldr	r3, [r7, #4]
 8015c32:	4a17      	ldr	r2, [pc, #92]	; (8015c90 <TIM_OC2_SetConfig+0xf0>)
 8015c34:	4293      	cmp	r3, r2
 8015c36:	d113      	bne.n	8015c60 <TIM_OC2_SetConfig+0xc0>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8015c38:	693b      	ldr	r3, [r7, #16]
 8015c3a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8015c3e:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8015c40:	693b      	ldr	r3, [r7, #16]
 8015c42:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8015c46:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8015c48:	683b      	ldr	r3, [r7, #0]
 8015c4a:	695b      	ldr	r3, [r3, #20]
 8015c4c:	009b      	lsls	r3, r3, #2
 8015c4e:	693a      	ldr	r2, [r7, #16]
 8015c50:	4313      	orrs	r3, r2
 8015c52:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8015c54:	683b      	ldr	r3, [r7, #0]
 8015c56:	699b      	ldr	r3, [r3, #24]
 8015c58:	009b      	lsls	r3, r3, #2
 8015c5a:	693a      	ldr	r2, [r7, #16]
 8015c5c:	4313      	orrs	r3, r2
 8015c5e:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015c60:	687b      	ldr	r3, [r7, #4]
 8015c62:	693a      	ldr	r2, [r7, #16]
 8015c64:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8015c66:	687b      	ldr	r3, [r7, #4]
 8015c68:	68fa      	ldr	r2, [r7, #12]
 8015c6a:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8015c6c:	683b      	ldr	r3, [r7, #0]
 8015c6e:	685a      	ldr	r2, [r3, #4]
 8015c70:	687b      	ldr	r3, [r7, #4]
 8015c72:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015c74:	687b      	ldr	r3, [r7, #4]
 8015c76:	697a      	ldr	r2, [r7, #20]
 8015c78:	621a      	str	r2, [r3, #32]
}
 8015c7a:	bf00      	nop
 8015c7c:	371c      	adds	r7, #28
 8015c7e:	46bd      	mov	sp, r7
 8015c80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c84:	4770      	bx	lr
 8015c86:	bf00      	nop
 8015c88:	40012c00 	.word	0x40012c00
 8015c8c:	40014400 	.word	0x40014400
 8015c90:	40014800 	.word	0x40014800

08015c94 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8015c94:	b480      	push	{r7}
 8015c96:	b087      	sub	sp, #28
 8015c98:	af00      	add	r7, sp, #0
 8015c9a:	6078      	str	r0, [r7, #4]
 8015c9c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8015c9e:	687b      	ldr	r3, [r7, #4]
 8015ca0:	6a1b      	ldr	r3, [r3, #32]
 8015ca2:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8015ca6:	687b      	ldr	r3, [r7, #4]
 8015ca8:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015caa:	687b      	ldr	r3, [r7, #4]
 8015cac:	6a1b      	ldr	r3, [r3, #32]
 8015cae:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015cb0:	687b      	ldr	r3, [r7, #4]
 8015cb2:	685b      	ldr	r3, [r3, #4]
 8015cb4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8015cb6:	687b      	ldr	r3, [r7, #4]
 8015cb8:	69db      	ldr	r3, [r3, #28]
 8015cba:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8015cbc:	68fb      	ldr	r3, [r7, #12]
 8015cbe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015cc2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8015cc6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8015cc8:	68fb      	ldr	r3, [r7, #12]
 8015cca:	f023 0303 	bic.w	r3, r3, #3
 8015cce:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8015cd0:	683b      	ldr	r3, [r7, #0]
 8015cd2:	681b      	ldr	r3, [r3, #0]
 8015cd4:	68fa      	ldr	r2, [r7, #12]
 8015cd6:	4313      	orrs	r3, r2
 8015cd8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8015cda:	697b      	ldr	r3, [r7, #20]
 8015cdc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8015ce0:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8015ce2:	683b      	ldr	r3, [r7, #0]
 8015ce4:	689b      	ldr	r3, [r3, #8]
 8015ce6:	021b      	lsls	r3, r3, #8
 8015ce8:	697a      	ldr	r2, [r7, #20]
 8015cea:	4313      	orrs	r3, r2
 8015cec:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8015cee:	687b      	ldr	r3, [r7, #4]
 8015cf0:	4a21      	ldr	r2, [pc, #132]	; (8015d78 <TIM_OC3_SetConfig+0xe4>)
 8015cf2:	4293      	cmp	r3, r2
 8015cf4:	d10d      	bne.n	8015d12 <TIM_OC3_SetConfig+0x7e>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8015cf6:	697b      	ldr	r3, [r7, #20]
 8015cf8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8015cfc:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8015cfe:	683b      	ldr	r3, [r7, #0]
 8015d00:	68db      	ldr	r3, [r3, #12]
 8015d02:	021b      	lsls	r3, r3, #8
 8015d04:	697a      	ldr	r2, [r7, #20]
 8015d06:	4313      	orrs	r3, r2
 8015d08:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8015d0a:	697b      	ldr	r3, [r7, #20]
 8015d0c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8015d10:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015d12:	687b      	ldr	r3, [r7, #4]
 8015d14:	4a18      	ldr	r2, [pc, #96]	; (8015d78 <TIM_OC3_SetConfig+0xe4>)
 8015d16:	4293      	cmp	r3, r2
 8015d18:	d007      	beq.n	8015d2a <TIM_OC3_SetConfig+0x96>
 8015d1a:	687b      	ldr	r3, [r7, #4]
 8015d1c:	4a17      	ldr	r2, [pc, #92]	; (8015d7c <TIM_OC3_SetConfig+0xe8>)
 8015d1e:	4293      	cmp	r3, r2
 8015d20:	d003      	beq.n	8015d2a <TIM_OC3_SetConfig+0x96>
 8015d22:	687b      	ldr	r3, [r7, #4]
 8015d24:	4a16      	ldr	r2, [pc, #88]	; (8015d80 <TIM_OC3_SetConfig+0xec>)
 8015d26:	4293      	cmp	r3, r2
 8015d28:	d113      	bne.n	8015d52 <TIM_OC3_SetConfig+0xbe>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8015d2a:	693b      	ldr	r3, [r7, #16]
 8015d2c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8015d30:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8015d32:	693b      	ldr	r3, [r7, #16]
 8015d34:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8015d38:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8015d3a:	683b      	ldr	r3, [r7, #0]
 8015d3c:	695b      	ldr	r3, [r3, #20]
 8015d3e:	011b      	lsls	r3, r3, #4
 8015d40:	693a      	ldr	r2, [r7, #16]
 8015d42:	4313      	orrs	r3, r2
 8015d44:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8015d46:	683b      	ldr	r3, [r7, #0]
 8015d48:	699b      	ldr	r3, [r3, #24]
 8015d4a:	011b      	lsls	r3, r3, #4
 8015d4c:	693a      	ldr	r2, [r7, #16]
 8015d4e:	4313      	orrs	r3, r2
 8015d50:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015d52:	687b      	ldr	r3, [r7, #4]
 8015d54:	693a      	ldr	r2, [r7, #16]
 8015d56:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8015d58:	687b      	ldr	r3, [r7, #4]
 8015d5a:	68fa      	ldr	r2, [r7, #12]
 8015d5c:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8015d5e:	683b      	ldr	r3, [r7, #0]
 8015d60:	685a      	ldr	r2, [r3, #4]
 8015d62:	687b      	ldr	r3, [r7, #4]
 8015d64:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015d66:	687b      	ldr	r3, [r7, #4]
 8015d68:	697a      	ldr	r2, [r7, #20]
 8015d6a:	621a      	str	r2, [r3, #32]
}
 8015d6c:	bf00      	nop
 8015d6e:	371c      	adds	r7, #28
 8015d70:	46bd      	mov	sp, r7
 8015d72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015d76:	4770      	bx	lr
 8015d78:	40012c00 	.word	0x40012c00
 8015d7c:	40014400 	.word	0x40014400
 8015d80:	40014800 	.word	0x40014800

08015d84 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8015d84:	b480      	push	{r7}
 8015d86:	b087      	sub	sp, #28
 8015d88:	af00      	add	r7, sp, #0
 8015d8a:	6078      	str	r0, [r7, #4]
 8015d8c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8015d8e:	687b      	ldr	r3, [r7, #4]
 8015d90:	6a1b      	ldr	r3, [r3, #32]
 8015d92:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8015d96:	687b      	ldr	r3, [r7, #4]
 8015d98:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015d9a:	687b      	ldr	r3, [r7, #4]
 8015d9c:	6a1b      	ldr	r3, [r3, #32]
 8015d9e:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015da0:	687b      	ldr	r3, [r7, #4]
 8015da2:	685b      	ldr	r3, [r3, #4]
 8015da4:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8015da6:	687b      	ldr	r3, [r7, #4]
 8015da8:	69db      	ldr	r3, [r3, #28]
 8015daa:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8015dac:	68fb      	ldr	r3, [r7, #12]
 8015dae:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8015db2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8015db6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8015db8:	68fb      	ldr	r3, [r7, #12]
 8015dba:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8015dbe:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8015dc0:	683b      	ldr	r3, [r7, #0]
 8015dc2:	681b      	ldr	r3, [r3, #0]
 8015dc4:	021b      	lsls	r3, r3, #8
 8015dc6:	68fa      	ldr	r2, [r7, #12]
 8015dc8:	4313      	orrs	r3, r2
 8015dca:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8015dcc:	693b      	ldr	r3, [r7, #16]
 8015dce:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8015dd2:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8015dd4:	683b      	ldr	r3, [r7, #0]
 8015dd6:	689b      	ldr	r3, [r3, #8]
 8015dd8:	031b      	lsls	r3, r3, #12
 8015dda:	693a      	ldr	r2, [r7, #16]
 8015ddc:	4313      	orrs	r3, r2
 8015dde:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015de0:	687b      	ldr	r3, [r7, #4]
 8015de2:	4a14      	ldr	r2, [pc, #80]	; (8015e34 <TIM_OC4_SetConfig+0xb0>)
 8015de4:	4293      	cmp	r3, r2
 8015de6:	d007      	beq.n	8015df8 <TIM_OC4_SetConfig+0x74>
 8015de8:	687b      	ldr	r3, [r7, #4]
 8015dea:	4a13      	ldr	r2, [pc, #76]	; (8015e38 <TIM_OC4_SetConfig+0xb4>)
 8015dec:	4293      	cmp	r3, r2
 8015dee:	d003      	beq.n	8015df8 <TIM_OC4_SetConfig+0x74>
 8015df0:	687b      	ldr	r3, [r7, #4]
 8015df2:	4a12      	ldr	r2, [pc, #72]	; (8015e3c <TIM_OC4_SetConfig+0xb8>)
 8015df4:	4293      	cmp	r3, r2
 8015df6:	d109      	bne.n	8015e0c <TIM_OC4_SetConfig+0x88>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8015df8:	697b      	ldr	r3, [r7, #20]
 8015dfa:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8015dfe:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8015e00:	683b      	ldr	r3, [r7, #0]
 8015e02:	695b      	ldr	r3, [r3, #20]
 8015e04:	019b      	lsls	r3, r3, #6
 8015e06:	697a      	ldr	r2, [r7, #20]
 8015e08:	4313      	orrs	r3, r2
 8015e0a:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015e0c:	687b      	ldr	r3, [r7, #4]
 8015e0e:	697a      	ldr	r2, [r7, #20]
 8015e10:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8015e12:	687b      	ldr	r3, [r7, #4]
 8015e14:	68fa      	ldr	r2, [r7, #12]
 8015e16:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8015e18:	683b      	ldr	r3, [r7, #0]
 8015e1a:	685a      	ldr	r2, [r3, #4]
 8015e1c:	687b      	ldr	r3, [r7, #4]
 8015e1e:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015e20:	687b      	ldr	r3, [r7, #4]
 8015e22:	693a      	ldr	r2, [r7, #16]
 8015e24:	621a      	str	r2, [r3, #32]
}
 8015e26:	bf00      	nop
 8015e28:	371c      	adds	r7, #28
 8015e2a:	46bd      	mov	sp, r7
 8015e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015e30:	4770      	bx	lr
 8015e32:	bf00      	nop
 8015e34:	40012c00 	.word	0x40012c00
 8015e38:	40014400 	.word	0x40014400
 8015e3c:	40014800 	.word	0x40014800

08015e40 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8015e40:	b480      	push	{r7}
 8015e42:	b087      	sub	sp, #28
 8015e44:	af00      	add	r7, sp, #0
 8015e46:	6078      	str	r0, [r7, #4]
 8015e48:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8015e4a:	687b      	ldr	r3, [r7, #4]
 8015e4c:	6a1b      	ldr	r3, [r3, #32]
 8015e4e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8015e52:	687b      	ldr	r3, [r7, #4]
 8015e54:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015e56:	687b      	ldr	r3, [r7, #4]
 8015e58:	6a1b      	ldr	r3, [r3, #32]
 8015e5a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015e5c:	687b      	ldr	r3, [r7, #4]
 8015e5e:	685b      	ldr	r3, [r3, #4]
 8015e60:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8015e62:	687b      	ldr	r3, [r7, #4]
 8015e64:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015e66:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8015e68:	68fb      	ldr	r3, [r7, #12]
 8015e6a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015e6e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8015e72:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8015e74:	683b      	ldr	r3, [r7, #0]
 8015e76:	681b      	ldr	r3, [r3, #0]
 8015e78:	68fa      	ldr	r2, [r7, #12]
 8015e7a:	4313      	orrs	r3, r2
 8015e7c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 8015e7e:	693b      	ldr	r3, [r7, #16]
 8015e80:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8015e84:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8015e86:	683b      	ldr	r3, [r7, #0]
 8015e88:	689b      	ldr	r3, [r3, #8]
 8015e8a:	041b      	lsls	r3, r3, #16
 8015e8c:	693a      	ldr	r2, [r7, #16]
 8015e8e:	4313      	orrs	r3, r2
 8015e90:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015e92:	687b      	ldr	r3, [r7, #4]
 8015e94:	4a13      	ldr	r2, [pc, #76]	; (8015ee4 <TIM_OC5_SetConfig+0xa4>)
 8015e96:	4293      	cmp	r3, r2
 8015e98:	d007      	beq.n	8015eaa <TIM_OC5_SetConfig+0x6a>
 8015e9a:	687b      	ldr	r3, [r7, #4]
 8015e9c:	4a12      	ldr	r2, [pc, #72]	; (8015ee8 <TIM_OC5_SetConfig+0xa8>)
 8015e9e:	4293      	cmp	r3, r2
 8015ea0:	d003      	beq.n	8015eaa <TIM_OC5_SetConfig+0x6a>
 8015ea2:	687b      	ldr	r3, [r7, #4]
 8015ea4:	4a11      	ldr	r2, [pc, #68]	; (8015eec <TIM_OC5_SetConfig+0xac>)
 8015ea6:	4293      	cmp	r3, r2
 8015ea8:	d109      	bne.n	8015ebe <TIM_OC5_SetConfig+0x7e>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8015eaa:	697b      	ldr	r3, [r7, #20]
 8015eac:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015eb0:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8015eb2:	683b      	ldr	r3, [r7, #0]
 8015eb4:	695b      	ldr	r3, [r3, #20]
 8015eb6:	021b      	lsls	r3, r3, #8
 8015eb8:	697a      	ldr	r2, [r7, #20]
 8015eba:	4313      	orrs	r3, r2
 8015ebc:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015ebe:	687b      	ldr	r3, [r7, #4]
 8015ec0:	697a      	ldr	r2, [r7, #20]
 8015ec2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8015ec4:	687b      	ldr	r3, [r7, #4]
 8015ec6:	68fa      	ldr	r2, [r7, #12]
 8015ec8:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8015eca:	683b      	ldr	r3, [r7, #0]
 8015ecc:	685a      	ldr	r2, [r3, #4]
 8015ece:	687b      	ldr	r3, [r7, #4]
 8015ed0:	659a      	str	r2, [r3, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015ed2:	687b      	ldr	r3, [r7, #4]
 8015ed4:	693a      	ldr	r2, [r7, #16]
 8015ed6:	621a      	str	r2, [r3, #32]
}
 8015ed8:	bf00      	nop
 8015eda:	371c      	adds	r7, #28
 8015edc:	46bd      	mov	sp, r7
 8015ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ee2:	4770      	bx	lr
 8015ee4:	40012c00 	.word	0x40012c00
 8015ee8:	40014400 	.word	0x40014400
 8015eec:	40014800 	.word	0x40014800

08015ef0 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8015ef0:	b480      	push	{r7}
 8015ef2:	b087      	sub	sp, #28
 8015ef4:	af00      	add	r7, sp, #0
 8015ef6:	6078      	str	r0, [r7, #4]
 8015ef8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8015efa:	687b      	ldr	r3, [r7, #4]
 8015efc:	6a1b      	ldr	r3, [r3, #32]
 8015efe:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 8015f02:	687b      	ldr	r3, [r7, #4]
 8015f04:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8015f06:	687b      	ldr	r3, [r7, #4]
 8015f08:	6a1b      	ldr	r3, [r3, #32]
 8015f0a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8015f0c:	687b      	ldr	r3, [r7, #4]
 8015f0e:	685b      	ldr	r3, [r3, #4]
 8015f10:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8015f12:	687b      	ldr	r3, [r7, #4]
 8015f14:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015f16:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8015f18:	68fb      	ldr	r3, [r7, #12]
 8015f1a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8015f1e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8015f22:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8015f24:	683b      	ldr	r3, [r7, #0]
 8015f26:	681b      	ldr	r3, [r3, #0]
 8015f28:	021b      	lsls	r3, r3, #8
 8015f2a:	68fa      	ldr	r2, [r7, #12]
 8015f2c:	4313      	orrs	r3, r2
 8015f2e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8015f30:	693b      	ldr	r3, [r7, #16]
 8015f32:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8015f36:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8015f38:	683b      	ldr	r3, [r7, #0]
 8015f3a:	689b      	ldr	r3, [r3, #8]
 8015f3c:	051b      	lsls	r3, r3, #20
 8015f3e:	693a      	ldr	r2, [r7, #16]
 8015f40:	4313      	orrs	r3, r2
 8015f42:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8015f44:	687b      	ldr	r3, [r7, #4]
 8015f46:	4a14      	ldr	r2, [pc, #80]	; (8015f98 <TIM_OC6_SetConfig+0xa8>)
 8015f48:	4293      	cmp	r3, r2
 8015f4a:	d007      	beq.n	8015f5c <TIM_OC6_SetConfig+0x6c>
 8015f4c:	687b      	ldr	r3, [r7, #4]
 8015f4e:	4a13      	ldr	r2, [pc, #76]	; (8015f9c <TIM_OC6_SetConfig+0xac>)
 8015f50:	4293      	cmp	r3, r2
 8015f52:	d003      	beq.n	8015f5c <TIM_OC6_SetConfig+0x6c>
 8015f54:	687b      	ldr	r3, [r7, #4]
 8015f56:	4a12      	ldr	r2, [pc, #72]	; (8015fa0 <TIM_OC6_SetConfig+0xb0>)
 8015f58:	4293      	cmp	r3, r2
 8015f5a:	d109      	bne.n	8015f70 <TIM_OC6_SetConfig+0x80>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8015f5c:	697b      	ldr	r3, [r7, #20]
 8015f5e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8015f62:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8015f64:	683b      	ldr	r3, [r7, #0]
 8015f66:	695b      	ldr	r3, [r3, #20]
 8015f68:	029b      	lsls	r3, r3, #10
 8015f6a:	697a      	ldr	r2, [r7, #20]
 8015f6c:	4313      	orrs	r3, r2
 8015f6e:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8015f70:	687b      	ldr	r3, [r7, #4]
 8015f72:	697a      	ldr	r2, [r7, #20]
 8015f74:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8015f76:	687b      	ldr	r3, [r7, #4]
 8015f78:	68fa      	ldr	r2, [r7, #12]
 8015f7a:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8015f7c:	683b      	ldr	r3, [r7, #0]
 8015f7e:	685a      	ldr	r2, [r3, #4]
 8015f80:	687b      	ldr	r3, [r7, #4]
 8015f82:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8015f84:	687b      	ldr	r3, [r7, #4]
 8015f86:	693a      	ldr	r2, [r7, #16]
 8015f88:	621a      	str	r2, [r3, #32]
}
 8015f8a:	bf00      	nop
 8015f8c:	371c      	adds	r7, #28
 8015f8e:	46bd      	mov	sp, r7
 8015f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f94:	4770      	bx	lr
 8015f96:	bf00      	nop
 8015f98:	40012c00 	.word	0x40012c00
 8015f9c:	40014400 	.word	0x40014400
 8015fa0:	40014800 	.word	0x40014800

08015fa4 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8015fa4:	b480      	push	{r7}
 8015fa6:	b087      	sub	sp, #28
 8015fa8:	af00      	add	r7, sp, #0
 8015faa:	60f8      	str	r0, [r7, #12]
 8015fac:	60b9      	str	r1, [r7, #8]
 8015fae:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8015fb0:	68fb      	ldr	r3, [r7, #12]
 8015fb2:	6a1b      	ldr	r3, [r3, #32]
 8015fb4:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8015fb6:	68fb      	ldr	r3, [r7, #12]
 8015fb8:	6a1b      	ldr	r3, [r3, #32]
 8015fba:	f023 0201 	bic.w	r2, r3, #1
 8015fbe:	68fb      	ldr	r3, [r7, #12]
 8015fc0:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8015fc2:	68fb      	ldr	r3, [r7, #12]
 8015fc4:	699b      	ldr	r3, [r3, #24]
 8015fc6:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8015fc8:	693b      	ldr	r3, [r7, #16]
 8015fca:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8015fce:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8015fd0:	687b      	ldr	r3, [r7, #4]
 8015fd2:	011b      	lsls	r3, r3, #4
 8015fd4:	693a      	ldr	r2, [r7, #16]
 8015fd6:	4313      	orrs	r3, r2
 8015fd8:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8015fda:	697b      	ldr	r3, [r7, #20]
 8015fdc:	f023 030a 	bic.w	r3, r3, #10
 8015fe0:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 8015fe2:	697a      	ldr	r2, [r7, #20]
 8015fe4:	68bb      	ldr	r3, [r7, #8]
 8015fe6:	4313      	orrs	r3, r2
 8015fe8:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8015fea:	68fb      	ldr	r3, [r7, #12]
 8015fec:	693a      	ldr	r2, [r7, #16]
 8015fee:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8015ff0:	68fb      	ldr	r3, [r7, #12]
 8015ff2:	697a      	ldr	r2, [r7, #20]
 8015ff4:	621a      	str	r2, [r3, #32]
}
 8015ff6:	bf00      	nop
 8015ff8:	371c      	adds	r7, #28
 8015ffa:	46bd      	mov	sp, r7
 8015ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016000:	4770      	bx	lr

08016002 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8016002:	b480      	push	{r7}
 8016004:	b087      	sub	sp, #28
 8016006:	af00      	add	r7, sp, #0
 8016008:	60f8      	str	r0, [r7, #12]
 801600a:	60b9      	str	r1, [r7, #8]
 801600c:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 801600e:	68fb      	ldr	r3, [r7, #12]
 8016010:	6a1b      	ldr	r3, [r3, #32]
 8016012:	f023 0210 	bic.w	r2, r3, #16
 8016016:	68fb      	ldr	r3, [r7, #12]
 8016018:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 801601a:	68fb      	ldr	r3, [r7, #12]
 801601c:	699b      	ldr	r3, [r3, #24]
 801601e:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 8016020:	68fb      	ldr	r3, [r7, #12]
 8016022:	6a1b      	ldr	r3, [r3, #32]
 8016024:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8016026:	697b      	ldr	r3, [r7, #20]
 8016028:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 801602c:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 801602e:	687b      	ldr	r3, [r7, #4]
 8016030:	031b      	lsls	r3, r3, #12
 8016032:	697a      	ldr	r2, [r7, #20]
 8016034:	4313      	orrs	r3, r2
 8016036:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8016038:	693b      	ldr	r3, [r7, #16]
 801603a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 801603e:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 8016040:	68bb      	ldr	r3, [r7, #8]
 8016042:	011b      	lsls	r3, r3, #4
 8016044:	693a      	ldr	r2, [r7, #16]
 8016046:	4313      	orrs	r3, r2
 8016048:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 801604a:	68fb      	ldr	r3, [r7, #12]
 801604c:	697a      	ldr	r2, [r7, #20]
 801604e:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8016050:	68fb      	ldr	r3, [r7, #12]
 8016052:	693a      	ldr	r2, [r7, #16]
 8016054:	621a      	str	r2, [r3, #32]
}
 8016056:	bf00      	nop
 8016058:	371c      	adds	r7, #28
 801605a:	46bd      	mov	sp, r7
 801605c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016060:	4770      	bx	lr

08016062 <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8016062:	b480      	push	{r7}
 8016064:	b085      	sub	sp, #20
 8016066:	af00      	add	r7, sp, #0
 8016068:	6078      	str	r0, [r7, #4]
 801606a:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 801606c:	687b      	ldr	r3, [r7, #4]
 801606e:	689b      	ldr	r3, [r3, #8]
 8016070:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8016072:	68fb      	ldr	r3, [r7, #12]
 8016074:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8016078:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801607c:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 801607e:	683a      	ldr	r2, [r7, #0]
 8016080:	68fb      	ldr	r3, [r7, #12]
 8016082:	4313      	orrs	r3, r2
 8016084:	f043 0307 	orr.w	r3, r3, #7
 8016088:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 801608a:	687b      	ldr	r3, [r7, #4]
 801608c:	68fa      	ldr	r2, [r7, #12]
 801608e:	609a      	str	r2, [r3, #8]
}
 8016090:	bf00      	nop
 8016092:	3714      	adds	r7, #20
 8016094:	46bd      	mov	sp, r7
 8016096:	f85d 7b04 	ldr.w	r7, [sp], #4
 801609a:	4770      	bx	lr

0801609c <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 801609c:	b480      	push	{r7}
 801609e:	b087      	sub	sp, #28
 80160a0:	af00      	add	r7, sp, #0
 80160a2:	60f8      	str	r0, [r7, #12]
 80160a4:	60b9      	str	r1, [r7, #8]
 80160a6:	607a      	str	r2, [r7, #4]
 80160a8:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 80160aa:	68fb      	ldr	r3, [r7, #12]
 80160ac:	689b      	ldr	r3, [r3, #8]
 80160ae:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80160b0:	697b      	ldr	r3, [r7, #20]
 80160b2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80160b6:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80160b8:	683b      	ldr	r3, [r7, #0]
 80160ba:	021a      	lsls	r2, r3, #8
 80160bc:	687b      	ldr	r3, [r7, #4]
 80160be:	431a      	orrs	r2, r3
 80160c0:	68bb      	ldr	r3, [r7, #8]
 80160c2:	4313      	orrs	r3, r2
 80160c4:	697a      	ldr	r2, [r7, #20]
 80160c6:	4313      	orrs	r3, r2
 80160c8:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80160ca:	68fb      	ldr	r3, [r7, #12]
 80160cc:	697a      	ldr	r2, [r7, #20]
 80160ce:	609a      	str	r2, [r3, #8]
}
 80160d0:	bf00      	nop
 80160d2:	371c      	adds	r7, #28
 80160d4:	46bd      	mov	sp, r7
 80160d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160da:	4770      	bx	lr

080160dc <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 80160dc:	b480      	push	{r7}
 80160de:	b085      	sub	sp, #20
 80160e0:	af00      	add	r7, sp, #0
 80160e2:	6078      	str	r0, [r7, #4]
 80160e4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80160e6:	687b      	ldr	r3, [r7, #4]
 80160e8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80160ec:	2b01      	cmp	r3, #1
 80160ee:	d101      	bne.n	80160f4 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 80160f0:	2302      	movs	r3, #2
 80160f2:	e04a      	b.n	801618a <HAL_TIMEx_MasterConfigSynchronization+0xae>
 80160f4:	687b      	ldr	r3, [r7, #4]
 80160f6:	2201      	movs	r2, #1
 80160f8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 80160fc:	687b      	ldr	r3, [r7, #4]
 80160fe:	2202      	movs	r2, #2
 8016100:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8016104:	687b      	ldr	r3, [r7, #4]
 8016106:	681b      	ldr	r3, [r3, #0]
 8016108:	685b      	ldr	r3, [r3, #4]
 801610a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 801610c:	687b      	ldr	r3, [r7, #4]
 801610e:	681b      	ldr	r3, [r3, #0]
 8016110:	689b      	ldr	r3, [r3, #8]
 8016112:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8016114:	687b      	ldr	r3, [r7, #4]
 8016116:	681b      	ldr	r3, [r3, #0]
 8016118:	4a1f      	ldr	r2, [pc, #124]	; (8016198 <HAL_TIMEx_MasterConfigSynchronization+0xbc>)
 801611a:	4293      	cmp	r3, r2
 801611c:	d108      	bne.n	8016130 <HAL_TIMEx_MasterConfigSynchronization+0x54>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 801611e:	68fb      	ldr	r3, [r7, #12]
 8016120:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8016124:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8016126:	683b      	ldr	r3, [r7, #0]
 8016128:	685b      	ldr	r3, [r3, #4]
 801612a:	68fa      	ldr	r2, [r7, #12]
 801612c:	4313      	orrs	r3, r2
 801612e:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8016130:	68fb      	ldr	r3, [r7, #12]
 8016132:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016136:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8016138:	683b      	ldr	r3, [r7, #0]
 801613a:	681b      	ldr	r3, [r3, #0]
 801613c:	68fa      	ldr	r2, [r7, #12]
 801613e:	4313      	orrs	r3, r2
 8016140:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8016142:	687b      	ldr	r3, [r7, #4]
 8016144:	681b      	ldr	r3, [r3, #0]
 8016146:	68fa      	ldr	r2, [r7, #12]
 8016148:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801614a:	687b      	ldr	r3, [r7, #4]
 801614c:	681b      	ldr	r3, [r3, #0]
 801614e:	4a12      	ldr	r2, [pc, #72]	; (8016198 <HAL_TIMEx_MasterConfigSynchronization+0xbc>)
 8016150:	4293      	cmp	r3, r2
 8016152:	d004      	beq.n	801615e <HAL_TIMEx_MasterConfigSynchronization+0x82>
 8016154:	687b      	ldr	r3, [r7, #4]
 8016156:	681b      	ldr	r3, [r3, #0]
 8016158:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 801615c:	d10c      	bne.n	8016178 <HAL_TIMEx_MasterConfigSynchronization+0x9c>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 801615e:	68bb      	ldr	r3, [r7, #8]
 8016160:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8016164:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8016166:	683b      	ldr	r3, [r7, #0]
 8016168:	689b      	ldr	r3, [r3, #8]
 801616a:	68ba      	ldr	r2, [r7, #8]
 801616c:	4313      	orrs	r3, r2
 801616e:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8016170:	687b      	ldr	r3, [r7, #4]
 8016172:	681b      	ldr	r3, [r3, #0]
 8016174:	68ba      	ldr	r2, [r7, #8]
 8016176:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8016178:	687b      	ldr	r3, [r7, #4]
 801617a:	2201      	movs	r2, #1
 801617c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8016180:	687b      	ldr	r3, [r7, #4]
 8016182:	2200      	movs	r2, #0
 8016184:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 8016188:	2300      	movs	r3, #0
}
 801618a:	4618      	mov	r0, r3
 801618c:	3714      	adds	r7, #20
 801618e:	46bd      	mov	sp, r7
 8016190:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016194:	4770      	bx	lr
 8016196:	bf00      	nop
 8016198:	40012c00 	.word	0x40012c00

0801619c <HAL_TIMEx_ConfigBreakDeadTime>:
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 801619c:	b480      	push	{r7}
 801619e:	b085      	sub	sp, #20
 80161a0:	af00      	add	r7, sp, #0
 80161a2:	6078      	str	r0, [r7, #4]
 80161a4:	6039      	str	r1, [r7, #0]
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;
 80161a6:	2300      	movs	r3, #0
 80161a8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 80161aa:	687b      	ldr	r3, [r7, #4]
 80161ac:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80161b0:	2b01      	cmp	r3, #1
 80161b2:	d101      	bne.n	80161b8 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 80161b4:	2302      	movs	r3, #2
 80161b6:	e078      	b.n	80162aa <HAL_TIMEx_ConfigBreakDeadTime+0x10e>
 80161b8:	687b      	ldr	r3, [r7, #4]
 80161ba:	2201      	movs	r2, #1
 80161bc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 80161c0:	68fb      	ldr	r3, [r7, #12]
 80161c2:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
 80161c6:	683b      	ldr	r3, [r7, #0]
 80161c8:	68db      	ldr	r3, [r3, #12]
 80161ca:	4313      	orrs	r3, r2
 80161cc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80161ce:	68fb      	ldr	r3, [r7, #12]
 80161d0:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80161d4:	683b      	ldr	r3, [r7, #0]
 80161d6:	689b      	ldr	r3, [r3, #8]
 80161d8:	4313      	orrs	r3, r2
 80161da:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80161dc:	68fb      	ldr	r3, [r7, #12]
 80161de:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80161e2:	683b      	ldr	r3, [r7, #0]
 80161e4:	685b      	ldr	r3, [r3, #4]
 80161e6:	4313      	orrs	r3, r2
 80161e8:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 80161ea:	68fb      	ldr	r3, [r7, #12]
 80161ec:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 80161f0:	683b      	ldr	r3, [r7, #0]
 80161f2:	681b      	ldr	r3, [r3, #0]
 80161f4:	4313      	orrs	r3, r2
 80161f6:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 80161f8:	68fb      	ldr	r3, [r7, #12]
 80161fa:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80161fe:	683b      	ldr	r3, [r7, #0]
 8016200:	691b      	ldr	r3, [r3, #16]
 8016202:	4313      	orrs	r3, r2
 8016204:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8016206:	68fb      	ldr	r3, [r7, #12]
 8016208:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 801620c:	683b      	ldr	r3, [r7, #0]
 801620e:	695b      	ldr	r3, [r3, #20]
 8016210:	4313      	orrs	r3, r2
 8016212:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8016214:	68fb      	ldr	r3, [r7, #12]
 8016216:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 801621a:	683b      	ldr	r3, [r7, #0]
 801621c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801621e:	4313      	orrs	r3, r2
 8016220:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8016222:	68fb      	ldr	r3, [r7, #12]
 8016224:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
 8016228:	683b      	ldr	r3, [r7, #0]
 801622a:	699b      	ldr	r3, [r3, #24]
 801622c:	041b      	lsls	r3, r3, #16
 801622e:	4313      	orrs	r3, r2
 8016230:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 8016232:	687b      	ldr	r3, [r7, #4]
 8016234:	681b      	ldr	r3, [r3, #0]
 8016236:	4a20      	ldr	r2, [pc, #128]	; (80162b8 <HAL_TIMEx_ConfigBreakDeadTime+0x11c>)
 8016238:	4293      	cmp	r3, r2
 801623a:	d106      	bne.n	801624a <HAL_TIMEx_ConfigBreakDeadTime+0xae>
  {
    /* Check the parameters */
    assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));

    /* Set BREAK AF mode */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 801623c:	68fb      	ldr	r3, [r7, #12]
 801623e:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 8016242:	683b      	ldr	r3, [r7, #0]
 8016244:	69db      	ldr	r3, [r3, #28]
 8016246:	4313      	orrs	r3, r2
 8016248:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 801624a:	687b      	ldr	r3, [r7, #4]
 801624c:	681b      	ldr	r3, [r3, #0]
 801624e:	4a1a      	ldr	r2, [pc, #104]	; (80162b8 <HAL_TIMEx_ConfigBreakDeadTime+0x11c>)
 8016250:	4293      	cmp	r3, r2
 8016252:	d121      	bne.n	8016298 <HAL_TIMEx_ConfigBreakDeadTime+0xfc>
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8016254:	68fb      	ldr	r3, [r7, #12]
 8016256:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
 801625a:	683b      	ldr	r3, [r7, #0]
 801625c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801625e:	051b      	lsls	r3, r3, #20
 8016260:	4313      	orrs	r3, r2
 8016262:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8016264:	68fb      	ldr	r3, [r7, #12]
 8016266:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 801626a:	683b      	ldr	r3, [r7, #0]
 801626c:	6a1b      	ldr	r3, [r3, #32]
 801626e:	4313      	orrs	r3, r2
 8016270:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8016272:	68fb      	ldr	r3, [r7, #12]
 8016274:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8016278:	683b      	ldr	r3, [r7, #0]
 801627a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801627c:	4313      	orrs	r3, r2
 801627e:	60fb      	str	r3, [r7, #12]

    if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
 8016280:	687b      	ldr	r3, [r7, #4]
 8016282:	681b      	ldr	r3, [r3, #0]
 8016284:	4a0c      	ldr	r2, [pc, #48]	; (80162b8 <HAL_TIMEx_ConfigBreakDeadTime+0x11c>)
 8016286:	4293      	cmp	r3, r2
 8016288:	d106      	bne.n	8016298 <HAL_TIMEx_ConfigBreakDeadTime+0xfc>
    {
      /* Check the parameters */
      assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));

      /* Set BREAK2 AF mode */
      MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 801628a:	68fb      	ldr	r3, [r7, #12]
 801628c:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 8016290:	683b      	ldr	r3, [r7, #0]
 8016292:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8016294:	4313      	orrs	r3, r2
 8016296:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8016298:	687b      	ldr	r3, [r7, #4]
 801629a:	681b      	ldr	r3, [r3, #0]
 801629c:	68fa      	ldr	r2, [r7, #12]
 801629e:	645a      	str	r2, [r3, #68]	; 0x44

  __HAL_UNLOCK(htim);
 80162a0:	687b      	ldr	r3, [r7, #4]
 80162a2:	2200      	movs	r2, #0
 80162a4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 80162a8:	2300      	movs	r3, #0
}
 80162aa:	4618      	mov	r0, r3
 80162ac:	3714      	adds	r7, #20
 80162ae:	46bd      	mov	sp, r7
 80162b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80162b4:	4770      	bx	lr
 80162b6:	bf00      	nop
 80162b8:	40012c00 	.word	0x40012c00

080162bc <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 80162bc:	b480      	push	{r7}
 80162be:	b083      	sub	sp, #12
 80162c0:	af00      	add	r7, sp, #0
 80162c2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 80162c4:	bf00      	nop
 80162c6:	370c      	adds	r7, #12
 80162c8:	46bd      	mov	sp, r7
 80162ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80162ce:	4770      	bx	lr

080162d0 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 80162d0:	b480      	push	{r7}
 80162d2:	b083      	sub	sp, #12
 80162d4:	af00      	add	r7, sp, #0
 80162d6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80162d8:	bf00      	nop
 80162da:	370c      	adds	r7, #12
 80162dc:	46bd      	mov	sp, r7
 80162de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80162e2:	4770      	bx	lr

080162e4 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 80162e4:	b480      	push	{r7}
 80162e6:	b083      	sub	sp, #12
 80162e8:	af00      	add	r7, sp, #0
 80162ea:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 80162ec:	bf00      	nop
 80162ee:	370c      	adds	r7, #12
 80162f0:	46bd      	mov	sp, r7
 80162f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80162f6:	4770      	bx	lr

080162f8 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
 80162f8:	b480      	push	{r7}
 80162fa:	b085      	sub	sp, #20
 80162fc:	af00      	add	r7, sp, #0
 80162fe:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 8016300:	687b      	ldr	r3, [r7, #4]
 8016302:	2200      	movs	r2, #0
 8016304:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 8016308:	f64b 7380 	movw	r3, #49024	; 0xbf80
 801630c:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Set interrupt mask */
  USBx->CNTR = (uint16_t)winterruptmask;
 801630e:	68fb      	ldr	r3, [r7, #12]
 8016310:	b29a      	uxth	r2, r3
 8016312:	687b      	ldr	r3, [r7, #4]
 8016314:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 8016318:	2300      	movs	r3, #0
}
 801631a:	4618      	mov	r0, r3
 801631c:	3714      	adds	r7, #20
 801631e:	46bd      	mov	sp, r7
 8016320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016324:	4770      	bx	lr

08016326 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 8016326:	b480      	push	{r7}
 8016328:	b085      	sub	sp, #20
 801632a:	af00      	add	r7, sp, #0
 801632c:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 801632e:	f64b 7380 	movw	r3, #49024	; 0xbf80
 8016332:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 8016334:	687b      	ldr	r3, [r7, #4]
 8016336:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 801633a:	b29a      	uxth	r2, r3
 801633c:	68fb      	ldr	r3, [r7, #12]
 801633e:	b29b      	uxth	r3, r3
 8016340:	43db      	mvns	r3, r3
 8016342:	b29b      	uxth	r3, r3
 8016344:	4013      	ands	r3, r2
 8016346:	b29a      	uxth	r2, r3
 8016348:	687b      	ldr	r3, [r7, #4]
 801634a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 801634e:	2300      	movs	r3, #0
}
 8016350:	4618      	mov	r0, r3
 8016352:	3714      	adds	r7, #20
 8016354:	46bd      	mov	sp, r7
 8016356:	f85d 7b04 	ldr.w	r7, [sp], #4
 801635a:	4770      	bx	lr

0801635c <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 801635c:	b084      	sub	sp, #16
 801635e:	b480      	push	{r7}
 8016360:	b083      	sub	sp, #12
 8016362:	af00      	add	r7, sp, #0
 8016364:	6078      	str	r0, [r7, #4]
 8016366:	f107 0014 	add.w	r0, r7, #20
 801636a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 801636e:	687b      	ldr	r3, [r7, #4]
 8016370:	2201      	movs	r2, #1
 8016372:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 8016376:	687b      	ldr	r3, [r7, #4]
 8016378:	2200      	movs	r2, #0
 801637a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 801637e:	687b      	ldr	r3, [r7, #4]
 8016380:	2200      	movs	r2, #0
 8016382:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 8016386:	687b      	ldr	r3, [r7, #4]
 8016388:	2200      	movs	r2, #0
 801638a:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 801638e:	2300      	movs	r3, #0
}
 8016390:	4618      	mov	r0, r3
 8016392:	370c      	adds	r7, #12
 8016394:	46bd      	mov	sp, r7
 8016396:	f85d 7b04 	ldr.w	r7, [sp], #4
 801639a:	b004      	add	sp, #16
 801639c:	4770      	bx	lr
	...

080163a0 <USB_ActivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80163a0:	b480      	push	{r7}
 80163a2:	b09d      	sub	sp, #116	; 0x74
 80163a4:	af00      	add	r7, sp, #0
 80163a6:	6078      	str	r0, [r7, #4]
 80163a8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
 80163aa:	2300      	movs	r3, #0
 80163ac:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 80163b0:	687a      	ldr	r2, [r7, #4]
 80163b2:	683b      	ldr	r3, [r7, #0]
 80163b4:	781b      	ldrb	r3, [r3, #0]
 80163b6:	009b      	lsls	r3, r3, #2
 80163b8:	4413      	add	r3, r2
 80163ba:	881b      	ldrh	r3, [r3, #0]
 80163bc:	b29b      	uxth	r3, r3
 80163be:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80163c2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80163c6:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c

  /* initialize Endpoint */
  switch (ep->type)
 80163ca:	683b      	ldr	r3, [r7, #0]
 80163cc:	78db      	ldrb	r3, [r3, #3]
 80163ce:	2b03      	cmp	r3, #3
 80163d0:	d81f      	bhi.n	8016412 <USB_ActivateEndpoint+0x72>
 80163d2:	a201      	add	r2, pc, #4	; (adr r2, 80163d8 <USB_ActivateEndpoint+0x38>)
 80163d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80163d8:	080163e9 	.word	0x080163e9
 80163dc:	08016405 	.word	0x08016405
 80163e0:	0801641b 	.word	0x0801641b
 80163e4:	080163f7 	.word	0x080163f7
  {
    case EP_TYPE_CTRL:
      wEpRegVal |= USB_EP_CONTROL;
 80163e8:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80163ec:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80163f0:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 80163f4:	e012      	b.n	801641c <USB_ActivateEndpoint+0x7c>
    case EP_TYPE_BULK:
      wEpRegVal |= USB_EP_BULK;
      break;

    case EP_TYPE_INTR:
      wEpRegVal |= USB_EP_INTERRUPT;
 80163f6:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80163fa:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
 80163fe:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 8016402:	e00b      	b.n	801641c <USB_ActivateEndpoint+0x7c>

    case EP_TYPE_ISOC:
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 8016404:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 8016408:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801640c:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
      break;
 8016410:	e004      	b.n	801641c <USB_ActivateEndpoint+0x7c>

    default:
      ret = HAL_ERROR;
 8016412:	2301      	movs	r3, #1
 8016414:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
      break;
 8016418:	e000      	b.n	801641c <USB_ActivateEndpoint+0x7c>
      break;
 801641a:	bf00      	nop
  }

  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 801641c:	687a      	ldr	r2, [r7, #4]
 801641e:	683b      	ldr	r3, [r7, #0]
 8016420:	781b      	ldrb	r3, [r3, #0]
 8016422:	009b      	lsls	r3, r3, #2
 8016424:	441a      	add	r2, r3
 8016426:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801642a:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801642e:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016432:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016436:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801643a:	b29b      	uxth	r3, r3
 801643c:	8013      	strh	r3, [r2, #0]

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 801643e:	687a      	ldr	r2, [r7, #4]
 8016440:	683b      	ldr	r3, [r7, #0]
 8016442:	781b      	ldrb	r3, [r3, #0]
 8016444:	009b      	lsls	r3, r3, #2
 8016446:	4413      	add	r3, r2
 8016448:	881b      	ldrh	r3, [r3, #0]
 801644a:	b29b      	uxth	r3, r3
 801644c:	b21b      	sxth	r3, r3
 801644e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016452:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016456:	b21a      	sxth	r2, r3
 8016458:	683b      	ldr	r3, [r7, #0]
 801645a:	781b      	ldrb	r3, [r3, #0]
 801645c:	b21b      	sxth	r3, r3
 801645e:	4313      	orrs	r3, r2
 8016460:	b21b      	sxth	r3, r3
 8016462:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8016466:	687a      	ldr	r2, [r7, #4]
 8016468:	683b      	ldr	r3, [r7, #0]
 801646a:	781b      	ldrb	r3, [r3, #0]
 801646c:	009b      	lsls	r3, r3, #2
 801646e:	441a      	add	r2, r3
 8016470:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8016474:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016478:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801647c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016480:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016484:	b29b      	uxth	r3, r3
 8016486:	8013      	strh	r3, [r2, #0]

  if (ep->doublebuffer == 0U)
 8016488:	683b      	ldr	r3, [r7, #0]
 801648a:	7b1b      	ldrb	r3, [r3, #12]
 801648c:	2b00      	cmp	r3, #0
 801648e:	f040 8149 	bne.w	8016724 <USB_ActivateEndpoint+0x384>
  {
    if (ep->is_in != 0U)
 8016492:	683b      	ldr	r3, [r7, #0]
 8016494:	785b      	ldrb	r3, [r3, #1]
 8016496:	2b00      	cmp	r3, #0
 8016498:	f000 8084 	beq.w	80165a4 <USB_ActivateEndpoint+0x204>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 801649c:	687b      	ldr	r3, [r7, #4]
 801649e:	61bb      	str	r3, [r7, #24]
 80164a0:	687b      	ldr	r3, [r7, #4]
 80164a2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80164a6:	b29b      	uxth	r3, r3
 80164a8:	461a      	mov	r2, r3
 80164aa:	69bb      	ldr	r3, [r7, #24]
 80164ac:	4413      	add	r3, r2
 80164ae:	61bb      	str	r3, [r7, #24]
 80164b0:	683b      	ldr	r3, [r7, #0]
 80164b2:	781b      	ldrb	r3, [r3, #0]
 80164b4:	00da      	lsls	r2, r3, #3
 80164b6:	69bb      	ldr	r3, [r7, #24]
 80164b8:	4413      	add	r3, r2
 80164ba:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80164be:	617b      	str	r3, [r7, #20]
 80164c0:	683b      	ldr	r3, [r7, #0]
 80164c2:	88db      	ldrh	r3, [r3, #6]
 80164c4:	085b      	lsrs	r3, r3, #1
 80164c6:	b29b      	uxth	r3, r3
 80164c8:	005b      	lsls	r3, r3, #1
 80164ca:	b29a      	uxth	r2, r3
 80164cc:	697b      	ldr	r3, [r7, #20]
 80164ce:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80164d0:	687a      	ldr	r2, [r7, #4]
 80164d2:	683b      	ldr	r3, [r7, #0]
 80164d4:	781b      	ldrb	r3, [r3, #0]
 80164d6:	009b      	lsls	r3, r3, #2
 80164d8:	4413      	add	r3, r2
 80164da:	881b      	ldrh	r3, [r3, #0]
 80164dc:	827b      	strh	r3, [r7, #18]
 80164de:	8a7b      	ldrh	r3, [r7, #18]
 80164e0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80164e4:	2b00      	cmp	r3, #0
 80164e6:	d01b      	beq.n	8016520 <USB_ActivateEndpoint+0x180>
 80164e8:	687a      	ldr	r2, [r7, #4]
 80164ea:	683b      	ldr	r3, [r7, #0]
 80164ec:	781b      	ldrb	r3, [r3, #0]
 80164ee:	009b      	lsls	r3, r3, #2
 80164f0:	4413      	add	r3, r2
 80164f2:	881b      	ldrh	r3, [r3, #0]
 80164f4:	b29b      	uxth	r3, r3
 80164f6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80164fa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80164fe:	823b      	strh	r3, [r7, #16]
 8016500:	687a      	ldr	r2, [r7, #4]
 8016502:	683b      	ldr	r3, [r7, #0]
 8016504:	781b      	ldrb	r3, [r3, #0]
 8016506:	009b      	lsls	r3, r3, #2
 8016508:	441a      	add	r2, r3
 801650a:	8a3b      	ldrh	r3, [r7, #16]
 801650c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016510:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016514:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016518:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 801651c:	b29b      	uxth	r3, r3
 801651e:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8016520:	683b      	ldr	r3, [r7, #0]
 8016522:	78db      	ldrb	r3, [r3, #3]
 8016524:	2b01      	cmp	r3, #1
 8016526:	d020      	beq.n	801656a <USB_ActivateEndpoint+0x1ca>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 8016528:	687a      	ldr	r2, [r7, #4]
 801652a:	683b      	ldr	r3, [r7, #0]
 801652c:	781b      	ldrb	r3, [r3, #0]
 801652e:	009b      	lsls	r3, r3, #2
 8016530:	4413      	add	r3, r2
 8016532:	881b      	ldrh	r3, [r3, #0]
 8016534:	b29b      	uxth	r3, r3
 8016536:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801653a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801653e:	81bb      	strh	r3, [r7, #12]
 8016540:	89bb      	ldrh	r3, [r7, #12]
 8016542:	f083 0320 	eor.w	r3, r3, #32
 8016546:	81bb      	strh	r3, [r7, #12]
 8016548:	687a      	ldr	r2, [r7, #4]
 801654a:	683b      	ldr	r3, [r7, #0]
 801654c:	781b      	ldrb	r3, [r3, #0]
 801654e:	009b      	lsls	r3, r3, #2
 8016550:	441a      	add	r2, r3
 8016552:	89bb      	ldrh	r3, [r7, #12]
 8016554:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016558:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801655c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016560:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016564:	b29b      	uxth	r3, r3
 8016566:	8013      	strh	r3, [r2, #0]
 8016568:	e2a6      	b.n	8016ab8 <USB_ActivateEndpoint+0x718>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 801656a:	687a      	ldr	r2, [r7, #4]
 801656c:	683b      	ldr	r3, [r7, #0]
 801656e:	781b      	ldrb	r3, [r3, #0]
 8016570:	009b      	lsls	r3, r3, #2
 8016572:	4413      	add	r3, r2
 8016574:	881b      	ldrh	r3, [r3, #0]
 8016576:	b29b      	uxth	r3, r3
 8016578:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801657c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016580:	81fb      	strh	r3, [r7, #14]
 8016582:	687a      	ldr	r2, [r7, #4]
 8016584:	683b      	ldr	r3, [r7, #0]
 8016586:	781b      	ldrb	r3, [r3, #0]
 8016588:	009b      	lsls	r3, r3, #2
 801658a:	441a      	add	r2, r3
 801658c:	89fb      	ldrh	r3, [r7, #14]
 801658e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016592:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016596:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801659a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801659e:	b29b      	uxth	r3, r3
 80165a0:	8013      	strh	r3, [r2, #0]
 80165a2:	e289      	b.n	8016ab8 <USB_ActivateEndpoint+0x718>
      }
    }
    else
    {
      /* Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 80165a4:	687b      	ldr	r3, [r7, #4]
 80165a6:	633b      	str	r3, [r7, #48]	; 0x30
 80165a8:	687b      	ldr	r3, [r7, #4]
 80165aa:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80165ae:	b29b      	uxth	r3, r3
 80165b0:	461a      	mov	r2, r3
 80165b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80165b4:	4413      	add	r3, r2
 80165b6:	633b      	str	r3, [r7, #48]	; 0x30
 80165b8:	683b      	ldr	r3, [r7, #0]
 80165ba:	781b      	ldrb	r3, [r3, #0]
 80165bc:	00da      	lsls	r2, r3, #3
 80165be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80165c0:	4413      	add	r3, r2
 80165c2:	f203 4304 	addw	r3, r3, #1028	; 0x404
 80165c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80165c8:	683b      	ldr	r3, [r7, #0]
 80165ca:	88db      	ldrh	r3, [r3, #6]
 80165cc:	085b      	lsrs	r3, r3, #1
 80165ce:	b29b      	uxth	r3, r3
 80165d0:	005b      	lsls	r3, r3, #1
 80165d2:	b29a      	uxth	r2, r3
 80165d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80165d6:	801a      	strh	r2, [r3, #0]

      /* Set the endpoint Receive buffer counter */
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 80165d8:	687b      	ldr	r3, [r7, #4]
 80165da:	62bb      	str	r3, [r7, #40]	; 0x28
 80165dc:	687b      	ldr	r3, [r7, #4]
 80165de:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80165e2:	b29b      	uxth	r3, r3
 80165e4:	461a      	mov	r2, r3
 80165e6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165e8:	4413      	add	r3, r2
 80165ea:	62bb      	str	r3, [r7, #40]	; 0x28
 80165ec:	683b      	ldr	r3, [r7, #0]
 80165ee:	781b      	ldrb	r3, [r3, #0]
 80165f0:	00da      	lsls	r2, r3, #3
 80165f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165f4:	4413      	add	r3, r2
 80165f6:	f203 4306 	addw	r3, r3, #1030	; 0x406
 80165fa:	627b      	str	r3, [r7, #36]	; 0x24
 80165fc:	683b      	ldr	r3, [r7, #0]
 80165fe:	691b      	ldr	r3, [r3, #16]
 8016600:	2b3e      	cmp	r3, #62	; 0x3e
 8016602:	d918      	bls.n	8016636 <USB_ActivateEndpoint+0x296>
 8016604:	683b      	ldr	r3, [r7, #0]
 8016606:	691b      	ldr	r3, [r3, #16]
 8016608:	095b      	lsrs	r3, r3, #5
 801660a:	66bb      	str	r3, [r7, #104]	; 0x68
 801660c:	683b      	ldr	r3, [r7, #0]
 801660e:	691b      	ldr	r3, [r3, #16]
 8016610:	f003 031f 	and.w	r3, r3, #31
 8016614:	2b00      	cmp	r3, #0
 8016616:	d102      	bne.n	801661e <USB_ActivateEndpoint+0x27e>
 8016618:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801661a:	3b01      	subs	r3, #1
 801661c:	66bb      	str	r3, [r7, #104]	; 0x68
 801661e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8016620:	b29b      	uxth	r3, r3
 8016622:	029b      	lsls	r3, r3, #10
 8016624:	b29b      	uxth	r3, r3
 8016626:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801662a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801662e:	b29a      	uxth	r2, r3
 8016630:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016632:	801a      	strh	r2, [r3, #0]
 8016634:	e029      	b.n	801668a <USB_ActivateEndpoint+0x2ea>
 8016636:	683b      	ldr	r3, [r7, #0]
 8016638:	691b      	ldr	r3, [r3, #16]
 801663a:	2b00      	cmp	r3, #0
 801663c:	d112      	bne.n	8016664 <USB_ActivateEndpoint+0x2c4>
 801663e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016640:	881b      	ldrh	r3, [r3, #0]
 8016642:	b29b      	uxth	r3, r3
 8016644:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8016648:	b29a      	uxth	r2, r3
 801664a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801664c:	801a      	strh	r2, [r3, #0]
 801664e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016650:	881b      	ldrh	r3, [r3, #0]
 8016652:	b29b      	uxth	r3, r3
 8016654:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8016658:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801665c:	b29a      	uxth	r2, r3
 801665e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016660:	801a      	strh	r2, [r3, #0]
 8016662:	e012      	b.n	801668a <USB_ActivateEndpoint+0x2ea>
 8016664:	683b      	ldr	r3, [r7, #0]
 8016666:	691b      	ldr	r3, [r3, #16]
 8016668:	085b      	lsrs	r3, r3, #1
 801666a:	66bb      	str	r3, [r7, #104]	; 0x68
 801666c:	683b      	ldr	r3, [r7, #0]
 801666e:	691b      	ldr	r3, [r3, #16]
 8016670:	f003 0301 	and.w	r3, r3, #1
 8016674:	2b00      	cmp	r3, #0
 8016676:	d002      	beq.n	801667e <USB_ActivateEndpoint+0x2de>
 8016678:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801667a:	3301      	adds	r3, #1
 801667c:	66bb      	str	r3, [r7, #104]	; 0x68
 801667e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8016680:	b29b      	uxth	r3, r3
 8016682:	029b      	lsls	r3, r3, #10
 8016684:	b29a      	uxth	r2, r3
 8016686:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016688:	801a      	strh	r2, [r3, #0]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801668a:	687a      	ldr	r2, [r7, #4]
 801668c:	683b      	ldr	r3, [r7, #0]
 801668e:	781b      	ldrb	r3, [r3, #0]
 8016690:	009b      	lsls	r3, r3, #2
 8016692:	4413      	add	r3, r2
 8016694:	881b      	ldrh	r3, [r3, #0]
 8016696:	847b      	strh	r3, [r7, #34]	; 0x22
 8016698:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801669a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801669e:	2b00      	cmp	r3, #0
 80166a0:	d01b      	beq.n	80166da <USB_ActivateEndpoint+0x33a>
 80166a2:	687a      	ldr	r2, [r7, #4]
 80166a4:	683b      	ldr	r3, [r7, #0]
 80166a6:	781b      	ldrb	r3, [r3, #0]
 80166a8:	009b      	lsls	r3, r3, #2
 80166aa:	4413      	add	r3, r2
 80166ac:	881b      	ldrh	r3, [r3, #0]
 80166ae:	b29b      	uxth	r3, r3
 80166b0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80166b4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80166b8:	843b      	strh	r3, [r7, #32]
 80166ba:	687a      	ldr	r2, [r7, #4]
 80166bc:	683b      	ldr	r3, [r7, #0]
 80166be:	781b      	ldrb	r3, [r3, #0]
 80166c0:	009b      	lsls	r3, r3, #2
 80166c2:	441a      	add	r2, r3
 80166c4:	8c3b      	ldrh	r3, [r7, #32]
 80166c6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80166ca:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80166ce:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80166d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80166d6:	b29b      	uxth	r3, r3
 80166d8:	8013      	strh	r3, [r2, #0]

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80166da:	687a      	ldr	r2, [r7, #4]
 80166dc:	683b      	ldr	r3, [r7, #0]
 80166de:	781b      	ldrb	r3, [r3, #0]
 80166e0:	009b      	lsls	r3, r3, #2
 80166e2:	4413      	add	r3, r2
 80166e4:	881b      	ldrh	r3, [r3, #0]
 80166e6:	b29b      	uxth	r3, r3
 80166e8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80166ec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80166f0:	83fb      	strh	r3, [r7, #30]
 80166f2:	8bfb      	ldrh	r3, [r7, #30]
 80166f4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80166f8:	83fb      	strh	r3, [r7, #30]
 80166fa:	8bfb      	ldrh	r3, [r7, #30]
 80166fc:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8016700:	83fb      	strh	r3, [r7, #30]
 8016702:	687a      	ldr	r2, [r7, #4]
 8016704:	683b      	ldr	r3, [r7, #0]
 8016706:	781b      	ldrb	r3, [r3, #0]
 8016708:	009b      	lsls	r3, r3, #2
 801670a:	441a      	add	r2, r3
 801670c:	8bfb      	ldrh	r3, [r7, #30]
 801670e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016712:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016716:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801671a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801671e:	b29b      	uxth	r3, r3
 8016720:	8013      	strh	r3, [r2, #0]
 8016722:	e1c9      	b.n	8016ab8 <USB_ActivateEndpoint+0x718>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  /* Double Buffer */
  else
  {
    if (ep->type == EP_TYPE_BULK)
 8016724:	683b      	ldr	r3, [r7, #0]
 8016726:	78db      	ldrb	r3, [r3, #3]
 8016728:	2b02      	cmp	r3, #2
 801672a:	d11e      	bne.n	801676a <USB_ActivateEndpoint+0x3ca>
    {
      /* Set bulk endpoint as double buffered */
      PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 801672c:	687a      	ldr	r2, [r7, #4]
 801672e:	683b      	ldr	r3, [r7, #0]
 8016730:	781b      	ldrb	r3, [r3, #0]
 8016732:	009b      	lsls	r3, r3, #2
 8016734:	4413      	add	r3, r2
 8016736:	881b      	ldrh	r3, [r3, #0]
 8016738:	b29b      	uxth	r3, r3
 801673a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801673e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016742:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8016746:	687a      	ldr	r2, [r7, #4]
 8016748:	683b      	ldr	r3, [r7, #0]
 801674a:	781b      	ldrb	r3, [r3, #0]
 801674c:	009b      	lsls	r3, r3, #2
 801674e:	441a      	add	r2, r3
 8016750:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8016754:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016758:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801675c:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8016760:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016764:	b29b      	uxth	r3, r3
 8016766:	8013      	strh	r3, [r2, #0]
 8016768:	e01d      	b.n	80167a6 <USB_ActivateEndpoint+0x406>
    }
    else
    {
      /* Set the ISOC endpoint in double buffer mode */
      PCD_CLEAR_EP_KIND(USBx, ep->num);
 801676a:	687a      	ldr	r2, [r7, #4]
 801676c:	683b      	ldr	r3, [r7, #0]
 801676e:	781b      	ldrb	r3, [r3, #0]
 8016770:	009b      	lsls	r3, r3, #2
 8016772:	4413      	add	r3, r2
 8016774:	881b      	ldrh	r3, [r3, #0]
 8016776:	b29b      	uxth	r3, r3
 8016778:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
 801677c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016780:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 8016784:	687a      	ldr	r2, [r7, #4]
 8016786:	683b      	ldr	r3, [r7, #0]
 8016788:	781b      	ldrb	r3, [r3, #0]
 801678a:	009b      	lsls	r3, r3, #2
 801678c:	441a      	add	r2, r3
 801678e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8016792:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016796:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801679a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801679e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80167a2:	b29b      	uxth	r3, r3
 80167a4:	8013      	strh	r3, [r2, #0]
    }

    /* Set buffer address for double buffered mode */
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 80167a6:	687b      	ldr	r3, [r7, #4]
 80167a8:	65fb      	str	r3, [r7, #92]	; 0x5c
 80167aa:	687b      	ldr	r3, [r7, #4]
 80167ac:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80167b0:	b29b      	uxth	r3, r3
 80167b2:	461a      	mov	r2, r3
 80167b4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80167b6:	4413      	add	r3, r2
 80167b8:	65fb      	str	r3, [r7, #92]	; 0x5c
 80167ba:	683b      	ldr	r3, [r7, #0]
 80167bc:	781b      	ldrb	r3, [r3, #0]
 80167be:	00da      	lsls	r2, r3, #3
 80167c0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80167c2:	4413      	add	r3, r2
 80167c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80167c8:	65bb      	str	r3, [r7, #88]	; 0x58
 80167ca:	683b      	ldr	r3, [r7, #0]
 80167cc:	891b      	ldrh	r3, [r3, #8]
 80167ce:	085b      	lsrs	r3, r3, #1
 80167d0:	b29b      	uxth	r3, r3
 80167d2:	005b      	lsls	r3, r3, #1
 80167d4:	b29a      	uxth	r2, r3
 80167d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80167d8:	801a      	strh	r2, [r3, #0]
 80167da:	687b      	ldr	r3, [r7, #4]
 80167dc:	657b      	str	r3, [r7, #84]	; 0x54
 80167de:	687b      	ldr	r3, [r7, #4]
 80167e0:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80167e4:	b29b      	uxth	r3, r3
 80167e6:	461a      	mov	r2, r3
 80167e8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80167ea:	4413      	add	r3, r2
 80167ec:	657b      	str	r3, [r7, #84]	; 0x54
 80167ee:	683b      	ldr	r3, [r7, #0]
 80167f0:	781b      	ldrb	r3, [r3, #0]
 80167f2:	00da      	lsls	r2, r3, #3
 80167f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80167f6:	4413      	add	r3, r2
 80167f8:	f203 4304 	addw	r3, r3, #1028	; 0x404
 80167fc:	653b      	str	r3, [r7, #80]	; 0x50
 80167fe:	683b      	ldr	r3, [r7, #0]
 8016800:	895b      	ldrh	r3, [r3, #10]
 8016802:	085b      	lsrs	r3, r3, #1
 8016804:	b29b      	uxth	r3, r3
 8016806:	005b      	lsls	r3, r3, #1
 8016808:	b29a      	uxth	r2, r3
 801680a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801680c:	801a      	strh	r2, [r3, #0]

    if (ep->is_in == 0U)
 801680e:	683b      	ldr	r3, [r7, #0]
 8016810:	785b      	ldrb	r3, [r3, #1]
 8016812:	2b00      	cmp	r3, #0
 8016814:	f040 8093 	bne.w	801693e <USB_ActivateEndpoint+0x59e>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8016818:	687a      	ldr	r2, [r7, #4]
 801681a:	683b      	ldr	r3, [r7, #0]
 801681c:	781b      	ldrb	r3, [r3, #0]
 801681e:	009b      	lsls	r3, r3, #2
 8016820:	4413      	add	r3, r2
 8016822:	881b      	ldrh	r3, [r3, #0]
 8016824:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 8016828:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 801682c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8016830:	2b00      	cmp	r3, #0
 8016832:	d01b      	beq.n	801686c <USB_ActivateEndpoint+0x4cc>
 8016834:	687a      	ldr	r2, [r7, #4]
 8016836:	683b      	ldr	r3, [r7, #0]
 8016838:	781b      	ldrb	r3, [r3, #0]
 801683a:	009b      	lsls	r3, r3, #2
 801683c:	4413      	add	r3, r2
 801683e:	881b      	ldrh	r3, [r3, #0]
 8016840:	b29b      	uxth	r3, r3
 8016842:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016846:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801684a:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801684c:	687a      	ldr	r2, [r7, #4]
 801684e:	683b      	ldr	r3, [r7, #0]
 8016850:	781b      	ldrb	r3, [r3, #0]
 8016852:	009b      	lsls	r3, r3, #2
 8016854:	441a      	add	r2, r3
 8016856:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8016858:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801685c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016860:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8016864:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016868:	b29b      	uxth	r3, r3
 801686a:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 801686c:	687a      	ldr	r2, [r7, #4]
 801686e:	683b      	ldr	r3, [r7, #0]
 8016870:	781b      	ldrb	r3, [r3, #0]
 8016872:	009b      	lsls	r3, r3, #2
 8016874:	4413      	add	r3, r2
 8016876:	881b      	ldrh	r3, [r3, #0]
 8016878:	87bb      	strh	r3, [r7, #60]	; 0x3c
 801687a:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801687c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016880:	2b00      	cmp	r3, #0
 8016882:	d01b      	beq.n	80168bc <USB_ActivateEndpoint+0x51c>
 8016884:	687a      	ldr	r2, [r7, #4]
 8016886:	683b      	ldr	r3, [r7, #0]
 8016888:	781b      	ldrb	r3, [r3, #0]
 801688a:	009b      	lsls	r3, r3, #2
 801688c:	4413      	add	r3, r2
 801688e:	881b      	ldrh	r3, [r3, #0]
 8016890:	b29b      	uxth	r3, r3
 8016892:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016896:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801689a:	877b      	strh	r3, [r7, #58]	; 0x3a
 801689c:	687a      	ldr	r2, [r7, #4]
 801689e:	683b      	ldr	r3, [r7, #0]
 80168a0:	781b      	ldrb	r3, [r3, #0]
 80168a2:	009b      	lsls	r3, r3, #2
 80168a4:	441a      	add	r2, r3
 80168a6:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80168a8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80168ac:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80168b0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80168b4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80168b8:	b29b      	uxth	r3, r3
 80168ba:	8013      	strh	r3, [r2, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80168bc:	687a      	ldr	r2, [r7, #4]
 80168be:	683b      	ldr	r3, [r7, #0]
 80168c0:	781b      	ldrb	r3, [r3, #0]
 80168c2:	009b      	lsls	r3, r3, #2
 80168c4:	4413      	add	r3, r2
 80168c6:	881b      	ldrh	r3, [r3, #0]
 80168c8:	b29b      	uxth	r3, r3
 80168ca:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80168ce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80168d2:	873b      	strh	r3, [r7, #56]	; 0x38
 80168d4:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80168d6:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80168da:	873b      	strh	r3, [r7, #56]	; 0x38
 80168dc:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80168de:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80168e2:	873b      	strh	r3, [r7, #56]	; 0x38
 80168e4:	687a      	ldr	r2, [r7, #4]
 80168e6:	683b      	ldr	r3, [r7, #0]
 80168e8:	781b      	ldrb	r3, [r3, #0]
 80168ea:	009b      	lsls	r3, r3, #2
 80168ec:	441a      	add	r2, r3
 80168ee:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80168f0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80168f4:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80168f8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80168fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016900:	b29b      	uxth	r3, r3
 8016902:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8016904:	687a      	ldr	r2, [r7, #4]
 8016906:	683b      	ldr	r3, [r7, #0]
 8016908:	781b      	ldrb	r3, [r3, #0]
 801690a:	009b      	lsls	r3, r3, #2
 801690c:	4413      	add	r3, r2
 801690e:	881b      	ldrh	r3, [r3, #0]
 8016910:	b29b      	uxth	r3, r3
 8016912:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016916:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801691a:	86fb      	strh	r3, [r7, #54]	; 0x36
 801691c:	687a      	ldr	r2, [r7, #4]
 801691e:	683b      	ldr	r3, [r7, #0]
 8016920:	781b      	ldrb	r3, [r3, #0]
 8016922:	009b      	lsls	r3, r3, #2
 8016924:	441a      	add	r2, r3
 8016926:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8016928:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801692c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016930:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016934:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016938:	b29b      	uxth	r3, r3
 801693a:	8013      	strh	r3, [r2, #0]
 801693c:	e0bc      	b.n	8016ab8 <USB_ActivateEndpoint+0x718>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT */
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801693e:	687a      	ldr	r2, [r7, #4]
 8016940:	683b      	ldr	r3, [r7, #0]
 8016942:	781b      	ldrb	r3, [r3, #0]
 8016944:	009b      	lsls	r3, r3, #2
 8016946:	4413      	add	r3, r2
 8016948:	881b      	ldrh	r3, [r3, #0]
 801694a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 801694e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8016952:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8016956:	2b00      	cmp	r3, #0
 8016958:	d01d      	beq.n	8016996 <USB_ActivateEndpoint+0x5f6>
 801695a:	687a      	ldr	r2, [r7, #4]
 801695c:	683b      	ldr	r3, [r7, #0]
 801695e:	781b      	ldrb	r3, [r3, #0]
 8016960:	009b      	lsls	r3, r3, #2
 8016962:	4413      	add	r3, r2
 8016964:	881b      	ldrh	r3, [r3, #0]
 8016966:	b29b      	uxth	r3, r3
 8016968:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801696c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016970:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 8016974:	687a      	ldr	r2, [r7, #4]
 8016976:	683b      	ldr	r3, [r7, #0]
 8016978:	781b      	ldrb	r3, [r3, #0]
 801697a:	009b      	lsls	r3, r3, #2
 801697c:	441a      	add	r2, r3
 801697e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8016982:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016986:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801698a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 801698e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016992:	b29b      	uxth	r3, r3
 8016994:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8016996:	687a      	ldr	r2, [r7, #4]
 8016998:	683b      	ldr	r3, [r7, #0]
 801699a:	781b      	ldrb	r3, [r3, #0]
 801699c:	009b      	lsls	r3, r3, #2
 801699e:	4413      	add	r3, r2
 80169a0:	881b      	ldrh	r3, [r3, #0]
 80169a2:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 80169a6:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
 80169aa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80169ae:	2b00      	cmp	r3, #0
 80169b0:	d01d      	beq.n	80169ee <USB_ActivateEndpoint+0x64e>
 80169b2:	687a      	ldr	r2, [r7, #4]
 80169b4:	683b      	ldr	r3, [r7, #0]
 80169b6:	781b      	ldrb	r3, [r3, #0]
 80169b8:	009b      	lsls	r3, r3, #2
 80169ba:	4413      	add	r3, r2
 80169bc:	881b      	ldrh	r3, [r3, #0]
 80169be:	b29b      	uxth	r3, r3
 80169c0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80169c4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80169c8:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 80169cc:	687a      	ldr	r2, [r7, #4]
 80169ce:	683b      	ldr	r3, [r7, #0]
 80169d0:	781b      	ldrb	r3, [r3, #0]
 80169d2:	009b      	lsls	r3, r3, #2
 80169d4:	441a      	add	r2, r3
 80169d6:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 80169da:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80169de:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80169e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80169e6:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80169ea:	b29b      	uxth	r3, r3
 80169ec:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 80169ee:	683b      	ldr	r3, [r7, #0]
 80169f0:	78db      	ldrb	r3, [r3, #3]
 80169f2:	2b01      	cmp	r3, #1
 80169f4:	d024      	beq.n	8016a40 <USB_ActivateEndpoint+0x6a0>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 80169f6:	687a      	ldr	r2, [r7, #4]
 80169f8:	683b      	ldr	r3, [r7, #0]
 80169fa:	781b      	ldrb	r3, [r3, #0]
 80169fc:	009b      	lsls	r3, r3, #2
 80169fe:	4413      	add	r3, r2
 8016a00:	881b      	ldrh	r3, [r3, #0]
 8016a02:	b29b      	uxth	r3, r3
 8016a04:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016a08:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016a0c:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 8016a10:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8016a14:	f083 0320 	eor.w	r3, r3, #32
 8016a18:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 8016a1c:	687a      	ldr	r2, [r7, #4]
 8016a1e:	683b      	ldr	r3, [r7, #0]
 8016a20:	781b      	ldrb	r3, [r3, #0]
 8016a22:	009b      	lsls	r3, r3, #2
 8016a24:	441a      	add	r2, r3
 8016a26:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8016a2a:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016a2e:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016a32:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016a36:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016a3a:	b29b      	uxth	r3, r3
 8016a3c:	8013      	strh	r3, [r2, #0]
 8016a3e:	e01d      	b.n	8016a7c <USB_ActivateEndpoint+0x6dc>
      }
      else
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8016a40:	687a      	ldr	r2, [r7, #4]
 8016a42:	683b      	ldr	r3, [r7, #0]
 8016a44:	781b      	ldrb	r3, [r3, #0]
 8016a46:	009b      	lsls	r3, r3, #2
 8016a48:	4413      	add	r3, r2
 8016a4a:	881b      	ldrh	r3, [r3, #0]
 8016a4c:	b29b      	uxth	r3, r3
 8016a4e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016a52:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016a56:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 8016a5a:	687a      	ldr	r2, [r7, #4]
 8016a5c:	683b      	ldr	r3, [r7, #0]
 8016a5e:	781b      	ldrb	r3, [r3, #0]
 8016a60:	009b      	lsls	r3, r3, #2
 8016a62:	441a      	add	r2, r3
 8016a64:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 8016a68:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016a6c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016a70:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016a74:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016a78:	b29b      	uxth	r3, r3
 8016a7a:	8013      	strh	r3, [r2, #0]
      }

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8016a7c:	687a      	ldr	r2, [r7, #4]
 8016a7e:	683b      	ldr	r3, [r7, #0]
 8016a80:	781b      	ldrb	r3, [r3, #0]
 8016a82:	009b      	lsls	r3, r3, #2
 8016a84:	4413      	add	r3, r2
 8016a86:	881b      	ldrh	r3, [r3, #0]
 8016a88:	b29b      	uxth	r3, r3
 8016a8a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8016a8e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016a92:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 8016a96:	687a      	ldr	r2, [r7, #4]
 8016a98:	683b      	ldr	r3, [r7, #0]
 8016a9a:	781b      	ldrb	r3, [r3, #0]
 8016a9c:	009b      	lsls	r3, r3, #2
 8016a9e:	441a      	add	r2, r3
 8016aa0:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8016aa4:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016aa8:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016aac:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016ab0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016ab4:	b29b      	uxth	r3, r3
 8016ab6:	8013      	strh	r3, [r2, #0]
    }
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return ret;
 8016ab8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
}
 8016abc:	4618      	mov	r0, r3
 8016abe:	3774      	adds	r7, #116	; 0x74
 8016ac0:	46bd      	mov	sp, r7
 8016ac2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016ac6:	4770      	bx	lr

08016ac8 <USB_DeactivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8016ac8:	b480      	push	{r7}
 8016aca:	b08d      	sub	sp, #52	; 0x34
 8016acc:	af00      	add	r7, sp, #0
 8016ace:	6078      	str	r0, [r7, #4]
 8016ad0:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 8016ad2:	683b      	ldr	r3, [r7, #0]
 8016ad4:	7b1b      	ldrb	r3, [r3, #12]
 8016ad6:	2b00      	cmp	r3, #0
 8016ad8:	f040 808e 	bne.w	8016bf8 <USB_DeactivateEndpoint+0x130>
  {
    if (ep->is_in != 0U)
 8016adc:	683b      	ldr	r3, [r7, #0]
 8016ade:	785b      	ldrb	r3, [r3, #1]
 8016ae0:	2b00      	cmp	r3, #0
 8016ae2:	d044      	beq.n	8016b6e <USB_DeactivateEndpoint+0xa6>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8016ae4:	687a      	ldr	r2, [r7, #4]
 8016ae6:	683b      	ldr	r3, [r7, #0]
 8016ae8:	781b      	ldrb	r3, [r3, #0]
 8016aea:	009b      	lsls	r3, r3, #2
 8016aec:	4413      	add	r3, r2
 8016aee:	881b      	ldrh	r3, [r3, #0]
 8016af0:	81bb      	strh	r3, [r7, #12]
 8016af2:	89bb      	ldrh	r3, [r7, #12]
 8016af4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016af8:	2b00      	cmp	r3, #0
 8016afa:	d01b      	beq.n	8016b34 <USB_DeactivateEndpoint+0x6c>
 8016afc:	687a      	ldr	r2, [r7, #4]
 8016afe:	683b      	ldr	r3, [r7, #0]
 8016b00:	781b      	ldrb	r3, [r3, #0]
 8016b02:	009b      	lsls	r3, r3, #2
 8016b04:	4413      	add	r3, r2
 8016b06:	881b      	ldrh	r3, [r3, #0]
 8016b08:	b29b      	uxth	r3, r3
 8016b0a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016b0e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016b12:	817b      	strh	r3, [r7, #10]
 8016b14:	687a      	ldr	r2, [r7, #4]
 8016b16:	683b      	ldr	r3, [r7, #0]
 8016b18:	781b      	ldrb	r3, [r3, #0]
 8016b1a:	009b      	lsls	r3, r3, #2
 8016b1c:	441a      	add	r2, r3
 8016b1e:	897b      	ldrh	r3, [r7, #10]
 8016b20:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016b24:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016b28:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016b2c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8016b30:	b29b      	uxth	r3, r3
 8016b32:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint */
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8016b34:	687a      	ldr	r2, [r7, #4]
 8016b36:	683b      	ldr	r3, [r7, #0]
 8016b38:	781b      	ldrb	r3, [r3, #0]
 8016b3a:	009b      	lsls	r3, r3, #2
 8016b3c:	4413      	add	r3, r2
 8016b3e:	881b      	ldrh	r3, [r3, #0]
 8016b40:	b29b      	uxth	r3, r3
 8016b42:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016b46:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016b4a:	813b      	strh	r3, [r7, #8]
 8016b4c:	687a      	ldr	r2, [r7, #4]
 8016b4e:	683b      	ldr	r3, [r7, #0]
 8016b50:	781b      	ldrb	r3, [r3, #0]
 8016b52:	009b      	lsls	r3, r3, #2
 8016b54:	441a      	add	r2, r3
 8016b56:	893b      	ldrh	r3, [r7, #8]
 8016b58:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016b5c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016b60:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016b64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016b68:	b29b      	uxth	r3, r3
 8016b6a:	8013      	strh	r3, [r2, #0]
 8016b6c:	e192      	b.n	8016e94 <USB_DeactivateEndpoint+0x3cc>
    }

    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8016b6e:	687a      	ldr	r2, [r7, #4]
 8016b70:	683b      	ldr	r3, [r7, #0]
 8016b72:	781b      	ldrb	r3, [r3, #0]
 8016b74:	009b      	lsls	r3, r3, #2
 8016b76:	4413      	add	r3, r2
 8016b78:	881b      	ldrh	r3, [r3, #0]
 8016b7a:	827b      	strh	r3, [r7, #18]
 8016b7c:	8a7b      	ldrh	r3, [r7, #18]
 8016b7e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8016b82:	2b00      	cmp	r3, #0
 8016b84:	d01b      	beq.n	8016bbe <USB_DeactivateEndpoint+0xf6>
 8016b86:	687a      	ldr	r2, [r7, #4]
 8016b88:	683b      	ldr	r3, [r7, #0]
 8016b8a:	781b      	ldrb	r3, [r3, #0]
 8016b8c:	009b      	lsls	r3, r3, #2
 8016b8e:	4413      	add	r3, r2
 8016b90:	881b      	ldrh	r3, [r3, #0]
 8016b92:	b29b      	uxth	r3, r3
 8016b94:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016b98:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016b9c:	823b      	strh	r3, [r7, #16]
 8016b9e:	687a      	ldr	r2, [r7, #4]
 8016ba0:	683b      	ldr	r3, [r7, #0]
 8016ba2:	781b      	ldrb	r3, [r3, #0]
 8016ba4:	009b      	lsls	r3, r3, #2
 8016ba6:	441a      	add	r2, r3
 8016ba8:	8a3b      	ldrh	r3, [r7, #16]
 8016baa:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016bae:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016bb2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8016bb6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016bba:	b29b      	uxth	r3, r3
 8016bbc:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8016bbe:	687a      	ldr	r2, [r7, #4]
 8016bc0:	683b      	ldr	r3, [r7, #0]
 8016bc2:	781b      	ldrb	r3, [r3, #0]
 8016bc4:	009b      	lsls	r3, r3, #2
 8016bc6:	4413      	add	r3, r2
 8016bc8:	881b      	ldrh	r3, [r3, #0]
 8016bca:	b29b      	uxth	r3, r3
 8016bcc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8016bd0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016bd4:	81fb      	strh	r3, [r7, #14]
 8016bd6:	687a      	ldr	r2, [r7, #4]
 8016bd8:	683b      	ldr	r3, [r7, #0]
 8016bda:	781b      	ldrb	r3, [r3, #0]
 8016bdc:	009b      	lsls	r3, r3, #2
 8016bde:	441a      	add	r2, r3
 8016be0:	89fb      	ldrh	r3, [r7, #14]
 8016be2:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016be6:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016bea:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016bee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016bf2:	b29b      	uxth	r3, r3
 8016bf4:	8013      	strh	r3, [r2, #0]
 8016bf6:	e14d      	b.n	8016e94 <USB_DeactivateEndpoint+0x3cc>
  }
#if (USE_USB_DOUBLE_BUFFER == 1U)
  /* Double Buffer */
  else
  {
    if (ep->is_in == 0U)
 8016bf8:	683b      	ldr	r3, [r7, #0]
 8016bfa:	785b      	ldrb	r3, [r3, #1]
 8016bfc:	2b00      	cmp	r3, #0
 8016bfe:	f040 80a5 	bne.w	8016d4c <USB_DeactivateEndpoint+0x284>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8016c02:	687a      	ldr	r2, [r7, #4]
 8016c04:	683b      	ldr	r3, [r7, #0]
 8016c06:	781b      	ldrb	r3, [r3, #0]
 8016c08:	009b      	lsls	r3, r3, #2
 8016c0a:	4413      	add	r3, r2
 8016c0c:	881b      	ldrh	r3, [r3, #0]
 8016c0e:	843b      	strh	r3, [r7, #32]
 8016c10:	8c3b      	ldrh	r3, [r7, #32]
 8016c12:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8016c16:	2b00      	cmp	r3, #0
 8016c18:	d01b      	beq.n	8016c52 <USB_DeactivateEndpoint+0x18a>
 8016c1a:	687a      	ldr	r2, [r7, #4]
 8016c1c:	683b      	ldr	r3, [r7, #0]
 8016c1e:	781b      	ldrb	r3, [r3, #0]
 8016c20:	009b      	lsls	r3, r3, #2
 8016c22:	4413      	add	r3, r2
 8016c24:	881b      	ldrh	r3, [r3, #0]
 8016c26:	b29b      	uxth	r3, r3
 8016c28:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016c2c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016c30:	83fb      	strh	r3, [r7, #30]
 8016c32:	687a      	ldr	r2, [r7, #4]
 8016c34:	683b      	ldr	r3, [r7, #0]
 8016c36:	781b      	ldrb	r3, [r3, #0]
 8016c38:	009b      	lsls	r3, r3, #2
 8016c3a:	441a      	add	r2, r3
 8016c3c:	8bfb      	ldrh	r3, [r7, #30]
 8016c3e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016c42:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016c46:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8016c4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016c4e:	b29b      	uxth	r3, r3
 8016c50:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8016c52:	687a      	ldr	r2, [r7, #4]
 8016c54:	683b      	ldr	r3, [r7, #0]
 8016c56:	781b      	ldrb	r3, [r3, #0]
 8016c58:	009b      	lsls	r3, r3, #2
 8016c5a:	4413      	add	r3, r2
 8016c5c:	881b      	ldrh	r3, [r3, #0]
 8016c5e:	83bb      	strh	r3, [r7, #28]
 8016c60:	8bbb      	ldrh	r3, [r7, #28]
 8016c62:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016c66:	2b00      	cmp	r3, #0
 8016c68:	d01b      	beq.n	8016ca2 <USB_DeactivateEndpoint+0x1da>
 8016c6a:	687a      	ldr	r2, [r7, #4]
 8016c6c:	683b      	ldr	r3, [r7, #0]
 8016c6e:	781b      	ldrb	r3, [r3, #0]
 8016c70:	009b      	lsls	r3, r3, #2
 8016c72:	4413      	add	r3, r2
 8016c74:	881b      	ldrh	r3, [r3, #0]
 8016c76:	b29b      	uxth	r3, r3
 8016c78:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016c7c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016c80:	837b      	strh	r3, [r7, #26]
 8016c82:	687a      	ldr	r2, [r7, #4]
 8016c84:	683b      	ldr	r3, [r7, #0]
 8016c86:	781b      	ldrb	r3, [r3, #0]
 8016c88:	009b      	lsls	r3, r3, #2
 8016c8a:	441a      	add	r2, r3
 8016c8c:	8b7b      	ldrh	r3, [r7, #26]
 8016c8e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016c92:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016c96:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016c9a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8016c9e:	b29b      	uxth	r3, r3
 8016ca0:	8013      	strh	r3, [r2, #0]

      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 8016ca2:	687a      	ldr	r2, [r7, #4]
 8016ca4:	683b      	ldr	r3, [r7, #0]
 8016ca6:	781b      	ldrb	r3, [r3, #0]
 8016ca8:	009b      	lsls	r3, r3, #2
 8016caa:	4413      	add	r3, r2
 8016cac:	881b      	ldrh	r3, [r3, #0]
 8016cae:	b29b      	uxth	r3, r3
 8016cb0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016cb4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016cb8:	833b      	strh	r3, [r7, #24]
 8016cba:	687a      	ldr	r2, [r7, #4]
 8016cbc:	683b      	ldr	r3, [r7, #0]
 8016cbe:	781b      	ldrb	r3, [r3, #0]
 8016cc0:	009b      	lsls	r3, r3, #2
 8016cc2:	441a      	add	r2, r3
 8016cc4:	8b3b      	ldrh	r3, [r7, #24]
 8016cc6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016cca:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016cce:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016cd2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8016cd6:	b29b      	uxth	r3, r3
 8016cd8:	8013      	strh	r3, [r2, #0]

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8016cda:	687a      	ldr	r2, [r7, #4]
 8016cdc:	683b      	ldr	r3, [r7, #0]
 8016cde:	781b      	ldrb	r3, [r3, #0]
 8016ce0:	009b      	lsls	r3, r3, #2
 8016ce2:	4413      	add	r3, r2
 8016ce4:	881b      	ldrh	r3, [r3, #0]
 8016ce6:	b29b      	uxth	r3, r3
 8016ce8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8016cec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016cf0:	82fb      	strh	r3, [r7, #22]
 8016cf2:	687a      	ldr	r2, [r7, #4]
 8016cf4:	683b      	ldr	r3, [r7, #0]
 8016cf6:	781b      	ldrb	r3, [r3, #0]
 8016cf8:	009b      	lsls	r3, r3, #2
 8016cfa:	441a      	add	r2, r3
 8016cfc:	8afb      	ldrh	r3, [r7, #22]
 8016cfe:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016d02:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016d06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016d0a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016d0e:	b29b      	uxth	r3, r3
 8016d10:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8016d12:	687a      	ldr	r2, [r7, #4]
 8016d14:	683b      	ldr	r3, [r7, #0]
 8016d16:	781b      	ldrb	r3, [r3, #0]
 8016d18:	009b      	lsls	r3, r3, #2
 8016d1a:	4413      	add	r3, r2
 8016d1c:	881b      	ldrh	r3, [r3, #0]
 8016d1e:	b29b      	uxth	r3, r3
 8016d20:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016d24:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016d28:	82bb      	strh	r3, [r7, #20]
 8016d2a:	687a      	ldr	r2, [r7, #4]
 8016d2c:	683b      	ldr	r3, [r7, #0]
 8016d2e:	781b      	ldrb	r3, [r3, #0]
 8016d30:	009b      	lsls	r3, r3, #2
 8016d32:	441a      	add	r2, r3
 8016d34:	8abb      	ldrh	r3, [r7, #20]
 8016d36:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016d3a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016d3e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016d42:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016d46:	b29b      	uxth	r3, r3
 8016d48:	8013      	strh	r3, [r2, #0]
 8016d4a:	e0a3      	b.n	8016e94 <USB_DeactivateEndpoint+0x3cc>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8016d4c:	687a      	ldr	r2, [r7, #4]
 8016d4e:	683b      	ldr	r3, [r7, #0]
 8016d50:	781b      	ldrb	r3, [r3, #0]
 8016d52:	009b      	lsls	r3, r3, #2
 8016d54:	4413      	add	r3, r2
 8016d56:	881b      	ldrh	r3, [r3, #0]
 8016d58:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8016d5a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8016d5c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8016d60:	2b00      	cmp	r3, #0
 8016d62:	d01b      	beq.n	8016d9c <USB_DeactivateEndpoint+0x2d4>
 8016d64:	687a      	ldr	r2, [r7, #4]
 8016d66:	683b      	ldr	r3, [r7, #0]
 8016d68:	781b      	ldrb	r3, [r3, #0]
 8016d6a:	009b      	lsls	r3, r3, #2
 8016d6c:	4413      	add	r3, r2
 8016d6e:	881b      	ldrh	r3, [r3, #0]
 8016d70:	b29b      	uxth	r3, r3
 8016d72:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016d76:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016d7a:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8016d7c:	687a      	ldr	r2, [r7, #4]
 8016d7e:	683b      	ldr	r3, [r7, #0]
 8016d80:	781b      	ldrb	r3, [r3, #0]
 8016d82:	009b      	lsls	r3, r3, #2
 8016d84:	441a      	add	r2, r3
 8016d86:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8016d88:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016d8c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016d90:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8016d94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016d98:	b29b      	uxth	r3, r3
 8016d9a:	8013      	strh	r3, [r2, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8016d9c:	687a      	ldr	r2, [r7, #4]
 8016d9e:	683b      	ldr	r3, [r7, #0]
 8016da0:	781b      	ldrb	r3, [r3, #0]
 8016da2:	009b      	lsls	r3, r3, #2
 8016da4:	4413      	add	r3, r2
 8016da6:	881b      	ldrh	r3, [r3, #0]
 8016da8:	857b      	strh	r3, [r7, #42]	; 0x2a
 8016daa:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016dac:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016db0:	2b00      	cmp	r3, #0
 8016db2:	d01b      	beq.n	8016dec <USB_DeactivateEndpoint+0x324>
 8016db4:	687a      	ldr	r2, [r7, #4]
 8016db6:	683b      	ldr	r3, [r7, #0]
 8016db8:	781b      	ldrb	r3, [r3, #0]
 8016dba:	009b      	lsls	r3, r3, #2
 8016dbc:	4413      	add	r3, r2
 8016dbe:	881b      	ldrh	r3, [r3, #0]
 8016dc0:	b29b      	uxth	r3, r3
 8016dc2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016dc6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016dca:	853b      	strh	r3, [r7, #40]	; 0x28
 8016dcc:	687a      	ldr	r2, [r7, #4]
 8016dce:	683b      	ldr	r3, [r7, #0]
 8016dd0:	781b      	ldrb	r3, [r3, #0]
 8016dd2:	009b      	lsls	r3, r3, #2
 8016dd4:	441a      	add	r2, r3
 8016dd6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8016dd8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016ddc:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016de0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016de4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8016de8:	b29b      	uxth	r3, r3
 8016dea:	8013      	strh	r3, [r2, #0]
      PCD_RX_DTOG(USBx, ep->num);
 8016dec:	687a      	ldr	r2, [r7, #4]
 8016dee:	683b      	ldr	r3, [r7, #0]
 8016df0:	781b      	ldrb	r3, [r3, #0]
 8016df2:	009b      	lsls	r3, r3, #2
 8016df4:	4413      	add	r3, r2
 8016df6:	881b      	ldrh	r3, [r3, #0]
 8016df8:	b29b      	uxth	r3, r3
 8016dfa:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016dfe:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016e02:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016e04:	687a      	ldr	r2, [r7, #4]
 8016e06:	683b      	ldr	r3, [r7, #0]
 8016e08:	781b      	ldrb	r3, [r3, #0]
 8016e0a:	009b      	lsls	r3, r3, #2
 8016e0c:	441a      	add	r2, r3
 8016e0e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8016e10:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016e14:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016e18:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8016e1c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016e20:	b29b      	uxth	r3, r3
 8016e22:	8013      	strh	r3, [r2, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8016e24:	687a      	ldr	r2, [r7, #4]
 8016e26:	683b      	ldr	r3, [r7, #0]
 8016e28:	781b      	ldrb	r3, [r3, #0]
 8016e2a:	009b      	lsls	r3, r3, #2
 8016e2c:	4413      	add	r3, r2
 8016e2e:	881b      	ldrh	r3, [r3, #0]
 8016e30:	b29b      	uxth	r3, r3
 8016e32:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016e36:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016e3a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016e3c:	687a      	ldr	r2, [r7, #4]
 8016e3e:	683b      	ldr	r3, [r7, #0]
 8016e40:	781b      	ldrb	r3, [r3, #0]
 8016e42:	009b      	lsls	r3, r3, #2
 8016e44:	441a      	add	r2, r3
 8016e46:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016e48:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016e4c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016e50:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016e54:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016e58:	b29b      	uxth	r3, r3
 8016e5a:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8016e5c:	687a      	ldr	r2, [r7, #4]
 8016e5e:	683b      	ldr	r3, [r7, #0]
 8016e60:	781b      	ldrb	r3, [r3, #0]
 8016e62:	009b      	lsls	r3, r3, #2
 8016e64:	4413      	add	r3, r2
 8016e66:	881b      	ldrh	r3, [r3, #0]
 8016e68:	b29b      	uxth	r3, r3
 8016e6a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8016e6e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016e72:	847b      	strh	r3, [r7, #34]	; 0x22
 8016e74:	687a      	ldr	r2, [r7, #4]
 8016e76:	683b      	ldr	r3, [r7, #0]
 8016e78:	781b      	ldrb	r3, [r3, #0]
 8016e7a:	009b      	lsls	r3, r3, #2
 8016e7c:	441a      	add	r2, r3
 8016e7e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016e80:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016e84:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016e88:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8016e8c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016e90:	b29b      	uxth	r3, r3
 8016e92:	8013      	strh	r3, [r2, #0]
    }
  }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  return HAL_OK;
 8016e94:	2300      	movs	r3, #0
}
 8016e96:	4618      	mov	r0, r3
 8016e98:	3734      	adds	r7, #52	; 0x34
 8016e9a:	46bd      	mov	sp, r7
 8016e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016ea0:	4770      	bx	lr

08016ea2 <USB_EPStartXfer>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8016ea2:	b580      	push	{r7, lr}
 8016ea4:	b0c2      	sub	sp, #264	; 0x108
 8016ea6:	af00      	add	r7, sp, #0
 8016ea8:	1d3b      	adds	r3, r7, #4
 8016eaa:	6018      	str	r0, [r3, #0]
 8016eac:	463b      	mov	r3, r7
 8016eae:	6019      	str	r1, [r3, #0]
  uint16_t pmabuffer;
  uint16_t wEPVal;
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

  /* IN endpoint */
  if (ep->is_in == 1U)
 8016eb0:	463b      	mov	r3, r7
 8016eb2:	681b      	ldr	r3, [r3, #0]
 8016eb4:	785b      	ldrb	r3, [r3, #1]
 8016eb6:	2b01      	cmp	r3, #1
 8016eb8:	f040 8509 	bne.w	80178ce <USB_EPStartXfer+0xa2c>
  {
    /*Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 8016ebc:	463b      	mov	r3, r7
 8016ebe:	681b      	ldr	r3, [r3, #0]
 8016ec0:	699a      	ldr	r2, [r3, #24]
 8016ec2:	463b      	mov	r3, r7
 8016ec4:	681b      	ldr	r3, [r3, #0]
 8016ec6:	691b      	ldr	r3, [r3, #16]
 8016ec8:	429a      	cmp	r2, r3
 8016eca:	d905      	bls.n	8016ed8 <USB_EPStartXfer+0x36>
    {
      len = ep->maxpacket;
 8016ecc:	463b      	mov	r3, r7
 8016ece:	681b      	ldr	r3, [r3, #0]
 8016ed0:	691b      	ldr	r3, [r3, #16]
 8016ed2:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8016ed6:	e004      	b.n	8016ee2 <USB_EPStartXfer+0x40>
    }
    else
    {
      len = ep->xfer_len;
 8016ed8:	463b      	mov	r3, r7
 8016eda:	681b      	ldr	r3, [r3, #0]
 8016edc:	699b      	ldr	r3, [r3, #24]
 8016ede:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    }

    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0U)
 8016ee2:	463b      	mov	r3, r7
 8016ee4:	681b      	ldr	r3, [r3, #0]
 8016ee6:	7b1b      	ldrb	r3, [r3, #12]
 8016ee8:	2b00      	cmp	r3, #0
 8016eea:	d128      	bne.n	8016f3e <USB_EPStartXfer+0x9c>
    {
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 8016eec:	463b      	mov	r3, r7
 8016eee:	681b      	ldr	r3, [r3, #0]
 8016ef0:	6959      	ldr	r1, [r3, #20]
 8016ef2:	463b      	mov	r3, r7
 8016ef4:	681b      	ldr	r3, [r3, #0]
 8016ef6:	88da      	ldrh	r2, [r3, #6]
 8016ef8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8016efc:	b29b      	uxth	r3, r3
 8016efe:	1d38      	adds	r0, r7, #4
 8016f00:	6800      	ldr	r0, [r0, #0]
 8016f02:	f001 f9da 	bl	80182ba <USB_WritePMA>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8016f06:	1d3b      	adds	r3, r7, #4
 8016f08:	681b      	ldr	r3, [r3, #0]
 8016f0a:	613b      	str	r3, [r7, #16]
 8016f0c:	1d3b      	adds	r3, r7, #4
 8016f0e:	681b      	ldr	r3, [r3, #0]
 8016f10:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8016f14:	b29b      	uxth	r3, r3
 8016f16:	461a      	mov	r2, r3
 8016f18:	693b      	ldr	r3, [r7, #16]
 8016f1a:	4413      	add	r3, r2
 8016f1c:	613b      	str	r3, [r7, #16]
 8016f1e:	463b      	mov	r3, r7
 8016f20:	681b      	ldr	r3, [r3, #0]
 8016f22:	781b      	ldrb	r3, [r3, #0]
 8016f24:	00da      	lsls	r2, r3, #3
 8016f26:	693b      	ldr	r3, [r7, #16]
 8016f28:	4413      	add	r3, r2
 8016f2a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8016f2e:	60fb      	str	r3, [r7, #12]
 8016f30:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8016f34:	b29a      	uxth	r2, r3
 8016f36:	68fb      	ldr	r3, [r7, #12]
 8016f38:	801a      	strh	r2, [r3, #0]
 8016f3a:	f000 bc9f 	b.w	801787c <USB_EPStartXfer+0x9da>
    }
#if (USE_USB_DOUBLE_BUFFER == 1U)
    else
    {
      /* double buffer bulk management */
      if (ep->type == EP_TYPE_BULK)
 8016f3e:	463b      	mov	r3, r7
 8016f40:	681b      	ldr	r3, [r3, #0]
 8016f42:	78db      	ldrb	r3, [r3, #3]
 8016f44:	2b02      	cmp	r3, #2
 8016f46:	f040 8347 	bne.w	80175d8 <USB_EPStartXfer+0x736>
      {
        if (ep->xfer_len_db > ep->maxpacket)
 8016f4a:	463b      	mov	r3, r7
 8016f4c:	681b      	ldr	r3, [r3, #0]
 8016f4e:	6a1a      	ldr	r2, [r3, #32]
 8016f50:	463b      	mov	r3, r7
 8016f52:	681b      	ldr	r3, [r3, #0]
 8016f54:	691b      	ldr	r3, [r3, #16]
 8016f56:	429a      	cmp	r2, r3
 8016f58:	f240 82eb 	bls.w	8017532 <USB_EPStartXfer+0x690>
        {
          /* enable double buffer */
          PCD_SET_BULK_EP_DBUF(USBx, ep->num);
 8016f5c:	1d3b      	adds	r3, r7, #4
 8016f5e:	681a      	ldr	r2, [r3, #0]
 8016f60:	463b      	mov	r3, r7
 8016f62:	681b      	ldr	r3, [r3, #0]
 8016f64:	781b      	ldrb	r3, [r3, #0]
 8016f66:	009b      	lsls	r3, r3, #2
 8016f68:	4413      	add	r3, r2
 8016f6a:	881b      	ldrh	r3, [r3, #0]
 8016f6c:	b29b      	uxth	r3, r3
 8016f6e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016f72:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016f76:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 8016f7a:	1d3b      	adds	r3, r7, #4
 8016f7c:	681a      	ldr	r2, [r3, #0]
 8016f7e:	463b      	mov	r3, r7
 8016f80:	681b      	ldr	r3, [r3, #0]
 8016f82:	781b      	ldrb	r3, [r3, #0]
 8016f84:	009b      	lsls	r3, r3, #2
 8016f86:	441a      	add	r2, r3
 8016f88:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
 8016f8c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8016f90:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8016f94:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8016f98:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016f9c:	b29b      	uxth	r3, r3
 8016f9e:	8013      	strh	r3, [r2, #0]

          /* each Time to write in PMA xfer_len_db will */
          ep->xfer_len_db -= len;
 8016fa0:	463b      	mov	r3, r7
 8016fa2:	681b      	ldr	r3, [r3, #0]
 8016fa4:	6a1a      	ldr	r2, [r3, #32]
 8016fa6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8016faa:	1ad2      	subs	r2, r2, r3
 8016fac:	463b      	mov	r3, r7
 8016fae:	681b      	ldr	r3, [r3, #0]
 8016fb0:	621a      	str	r2, [r3, #32]

          /* Fill the two first buffer in the Buffer0 & Buffer1 */
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 8016fb2:	1d3b      	adds	r3, r7, #4
 8016fb4:	681a      	ldr	r2, [r3, #0]
 8016fb6:	463b      	mov	r3, r7
 8016fb8:	681b      	ldr	r3, [r3, #0]
 8016fba:	781b      	ldrb	r3, [r3, #0]
 8016fbc:	009b      	lsls	r3, r3, #2
 8016fbe:	4413      	add	r3, r2
 8016fc0:	881b      	ldrh	r3, [r3, #0]
 8016fc2:	b29b      	uxth	r3, r3
 8016fc4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016fc8:	2b00      	cmp	r3, #0
 8016fca:	f000 8159 	beq.w	8017280 <USB_EPStartXfer+0x3de>
          {
            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8016fce:	1d3b      	adds	r3, r7, #4
 8016fd0:	681b      	ldr	r3, [r3, #0]
 8016fd2:	633b      	str	r3, [r7, #48]	; 0x30
 8016fd4:	463b      	mov	r3, r7
 8016fd6:	681b      	ldr	r3, [r3, #0]
 8016fd8:	785b      	ldrb	r3, [r3, #1]
 8016fda:	2b00      	cmp	r3, #0
 8016fdc:	d164      	bne.n	80170a8 <USB_EPStartXfer+0x206>
 8016fde:	1d3b      	adds	r3, r7, #4
 8016fe0:	681b      	ldr	r3, [r3, #0]
 8016fe2:	62bb      	str	r3, [r7, #40]	; 0x28
 8016fe4:	1d3b      	adds	r3, r7, #4
 8016fe6:	681b      	ldr	r3, [r3, #0]
 8016fe8:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8016fec:	b29b      	uxth	r3, r3
 8016fee:	461a      	mov	r2, r3
 8016ff0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ff2:	4413      	add	r3, r2
 8016ff4:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ff6:	463b      	mov	r3, r7
 8016ff8:	681b      	ldr	r3, [r3, #0]
 8016ffa:	781b      	ldrb	r3, [r3, #0]
 8016ffc:	00da      	lsls	r2, r3, #3
 8016ffe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017000:	4413      	add	r3, r2
 8017002:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017006:	627b      	str	r3, [r7, #36]	; 0x24
 8017008:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801700c:	2b3e      	cmp	r3, #62	; 0x3e
 801700e:	d91c      	bls.n	801704a <USB_EPStartXfer+0x1a8>
 8017010:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017014:	095b      	lsrs	r3, r3, #5
 8017016:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 801701a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801701e:	f003 031f 	and.w	r3, r3, #31
 8017022:	2b00      	cmp	r3, #0
 8017024:	d104      	bne.n	8017030 <USB_EPStartXfer+0x18e>
 8017026:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801702a:	3b01      	subs	r3, #1
 801702c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8017030:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8017034:	b29b      	uxth	r3, r3
 8017036:	029b      	lsls	r3, r3, #10
 8017038:	b29b      	uxth	r3, r3
 801703a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801703e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017042:	b29a      	uxth	r2, r3
 8017044:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017046:	801a      	strh	r2, [r3, #0]
 8017048:	e04a      	b.n	80170e0 <USB_EPStartXfer+0x23e>
 801704a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801704e:	2b00      	cmp	r3, #0
 8017050:	d112      	bne.n	8017078 <USB_EPStartXfer+0x1d6>
 8017052:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017054:	881b      	ldrh	r3, [r3, #0]
 8017056:	b29b      	uxth	r3, r3
 8017058:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 801705c:	b29a      	uxth	r2, r3
 801705e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017060:	801a      	strh	r2, [r3, #0]
 8017062:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017064:	881b      	ldrh	r3, [r3, #0]
 8017066:	b29b      	uxth	r3, r3
 8017068:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801706c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017070:	b29a      	uxth	r2, r3
 8017072:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017074:	801a      	strh	r2, [r3, #0]
 8017076:	e033      	b.n	80170e0 <USB_EPStartXfer+0x23e>
 8017078:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801707c:	085b      	lsrs	r3, r3, #1
 801707e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8017082:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017086:	f003 0301 	and.w	r3, r3, #1
 801708a:	2b00      	cmp	r3, #0
 801708c:	d004      	beq.n	8017098 <USB_EPStartXfer+0x1f6>
 801708e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8017092:	3301      	adds	r3, #1
 8017094:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8017098:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801709c:	b29b      	uxth	r3, r3
 801709e:	029b      	lsls	r3, r3, #10
 80170a0:	b29a      	uxth	r2, r3
 80170a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80170a4:	801a      	strh	r2, [r3, #0]
 80170a6:	e01b      	b.n	80170e0 <USB_EPStartXfer+0x23e>
 80170a8:	463b      	mov	r3, r7
 80170aa:	681b      	ldr	r3, [r3, #0]
 80170ac:	785b      	ldrb	r3, [r3, #1]
 80170ae:	2b01      	cmp	r3, #1
 80170b0:	d116      	bne.n	80170e0 <USB_EPStartXfer+0x23e>
 80170b2:	1d3b      	adds	r3, r7, #4
 80170b4:	681b      	ldr	r3, [r3, #0]
 80170b6:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80170ba:	b29b      	uxth	r3, r3
 80170bc:	461a      	mov	r2, r3
 80170be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170c0:	4413      	add	r3, r2
 80170c2:	633b      	str	r3, [r7, #48]	; 0x30
 80170c4:	463b      	mov	r3, r7
 80170c6:	681b      	ldr	r3, [r3, #0]
 80170c8:	781b      	ldrb	r3, [r3, #0]
 80170ca:	00da      	lsls	r2, r3, #3
 80170cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170ce:	4413      	add	r3, r2
 80170d0:	f203 4306 	addw	r3, r3, #1030	; 0x406
 80170d4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80170d6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80170da:	b29a      	uxth	r2, r3
 80170dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80170de:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 80170e0:	463b      	mov	r3, r7
 80170e2:	681b      	ldr	r3, [r3, #0]
 80170e4:	895b      	ldrh	r3, [r3, #10]
 80170e6:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80170ea:	463b      	mov	r3, r7
 80170ec:	681b      	ldr	r3, [r3, #0]
 80170ee:	6959      	ldr	r1, [r3, #20]
 80170f0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80170f4:	b29b      	uxth	r3, r3
 80170f6:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 80170fa:	1d38      	adds	r0, r7, #4
 80170fc:	6800      	ldr	r0, [r0, #0]
 80170fe:	f001 f8dc 	bl	80182ba <USB_WritePMA>
            ep->xfer_buff += len;
 8017102:	463b      	mov	r3, r7
 8017104:	681b      	ldr	r3, [r3, #0]
 8017106:	695a      	ldr	r2, [r3, #20]
 8017108:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801710c:	441a      	add	r2, r3
 801710e:	463b      	mov	r3, r7
 8017110:	681b      	ldr	r3, [r3, #0]
 8017112:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 8017114:	463b      	mov	r3, r7
 8017116:	681b      	ldr	r3, [r3, #0]
 8017118:	6a1a      	ldr	r2, [r3, #32]
 801711a:	463b      	mov	r3, r7
 801711c:	681b      	ldr	r3, [r3, #0]
 801711e:	691b      	ldr	r3, [r3, #16]
 8017120:	429a      	cmp	r2, r3
 8017122:	d909      	bls.n	8017138 <USB_EPStartXfer+0x296>
            {
              ep->xfer_len_db -= len;
 8017124:	463b      	mov	r3, r7
 8017126:	681b      	ldr	r3, [r3, #0]
 8017128:	6a1a      	ldr	r2, [r3, #32]
 801712a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801712e:	1ad2      	subs	r2, r2, r3
 8017130:	463b      	mov	r3, r7
 8017132:	681b      	ldr	r3, [r3, #0]
 8017134:	621a      	str	r2, [r3, #32]
 8017136:	e008      	b.n	801714a <USB_EPStartXfer+0x2a8>
            }
            else
            {
              len = ep->xfer_len_db;
 8017138:	463b      	mov	r3, r7
 801713a:	681b      	ldr	r3, [r3, #0]
 801713c:	6a1b      	ldr	r3, [r3, #32]
 801713e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
              ep->xfer_len_db = 0U;
 8017142:	463b      	mov	r3, r7
 8017144:	681b      	ldr	r3, [r3, #0]
 8017146:	2200      	movs	r2, #0
 8017148:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 801714a:	463b      	mov	r3, r7
 801714c:	681b      	ldr	r3, [r3, #0]
 801714e:	785b      	ldrb	r3, [r3, #1]
 8017150:	2b00      	cmp	r3, #0
 8017152:	d164      	bne.n	801721e <USB_EPStartXfer+0x37c>
 8017154:	1d3b      	adds	r3, r7, #4
 8017156:	681b      	ldr	r3, [r3, #0]
 8017158:	61bb      	str	r3, [r7, #24]
 801715a:	1d3b      	adds	r3, r7, #4
 801715c:	681b      	ldr	r3, [r3, #0]
 801715e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017162:	b29b      	uxth	r3, r3
 8017164:	461a      	mov	r2, r3
 8017166:	69bb      	ldr	r3, [r7, #24]
 8017168:	4413      	add	r3, r2
 801716a:	61bb      	str	r3, [r7, #24]
 801716c:	463b      	mov	r3, r7
 801716e:	681b      	ldr	r3, [r3, #0]
 8017170:	781b      	ldrb	r3, [r3, #0]
 8017172:	00da      	lsls	r2, r3, #3
 8017174:	69bb      	ldr	r3, [r7, #24]
 8017176:	4413      	add	r3, r2
 8017178:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801717c:	617b      	str	r3, [r7, #20]
 801717e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017182:	2b3e      	cmp	r3, #62	; 0x3e
 8017184:	d91c      	bls.n	80171c0 <USB_EPStartXfer+0x31e>
 8017186:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801718a:	095b      	lsrs	r3, r3, #5
 801718c:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8017190:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017194:	f003 031f 	and.w	r3, r3, #31
 8017198:	2b00      	cmp	r3, #0
 801719a:	d104      	bne.n	80171a6 <USB_EPStartXfer+0x304>
 801719c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80171a0:	3b01      	subs	r3, #1
 80171a2:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 80171a6:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80171aa:	b29b      	uxth	r3, r3
 80171ac:	029b      	lsls	r3, r3, #10
 80171ae:	b29b      	uxth	r3, r3
 80171b0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80171b4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80171b8:	b29a      	uxth	r2, r3
 80171ba:	697b      	ldr	r3, [r7, #20]
 80171bc:	801a      	strh	r2, [r3, #0]
 80171be:	e04d      	b.n	801725c <USB_EPStartXfer+0x3ba>
 80171c0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80171c4:	2b00      	cmp	r3, #0
 80171c6:	d112      	bne.n	80171ee <USB_EPStartXfer+0x34c>
 80171c8:	697b      	ldr	r3, [r7, #20]
 80171ca:	881b      	ldrh	r3, [r3, #0]
 80171cc:	b29b      	uxth	r3, r3
 80171ce:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80171d2:	b29a      	uxth	r2, r3
 80171d4:	697b      	ldr	r3, [r7, #20]
 80171d6:	801a      	strh	r2, [r3, #0]
 80171d8:	697b      	ldr	r3, [r7, #20]
 80171da:	881b      	ldrh	r3, [r3, #0]
 80171dc:	b29b      	uxth	r3, r3
 80171de:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80171e2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80171e6:	b29a      	uxth	r2, r3
 80171e8:	697b      	ldr	r3, [r7, #20]
 80171ea:	801a      	strh	r2, [r3, #0]
 80171ec:	e036      	b.n	801725c <USB_EPStartXfer+0x3ba>
 80171ee:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80171f2:	085b      	lsrs	r3, r3, #1
 80171f4:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 80171f8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80171fc:	f003 0301 	and.w	r3, r3, #1
 8017200:	2b00      	cmp	r3, #0
 8017202:	d004      	beq.n	801720e <USB_EPStartXfer+0x36c>
 8017204:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8017208:	3301      	adds	r3, #1
 801720a:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 801720e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8017212:	b29b      	uxth	r3, r3
 8017214:	029b      	lsls	r3, r3, #10
 8017216:	b29a      	uxth	r2, r3
 8017218:	697b      	ldr	r3, [r7, #20]
 801721a:	801a      	strh	r2, [r3, #0]
 801721c:	e01e      	b.n	801725c <USB_EPStartXfer+0x3ba>
 801721e:	463b      	mov	r3, r7
 8017220:	681b      	ldr	r3, [r3, #0]
 8017222:	785b      	ldrb	r3, [r3, #1]
 8017224:	2b01      	cmp	r3, #1
 8017226:	d119      	bne.n	801725c <USB_EPStartXfer+0x3ba>
 8017228:	1d3b      	adds	r3, r7, #4
 801722a:	681b      	ldr	r3, [r3, #0]
 801722c:	623b      	str	r3, [r7, #32]
 801722e:	1d3b      	adds	r3, r7, #4
 8017230:	681b      	ldr	r3, [r3, #0]
 8017232:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017236:	b29b      	uxth	r3, r3
 8017238:	461a      	mov	r2, r3
 801723a:	6a3b      	ldr	r3, [r7, #32]
 801723c:	4413      	add	r3, r2
 801723e:	623b      	str	r3, [r7, #32]
 8017240:	463b      	mov	r3, r7
 8017242:	681b      	ldr	r3, [r3, #0]
 8017244:	781b      	ldrb	r3, [r3, #0]
 8017246:	00da      	lsls	r2, r3, #3
 8017248:	6a3b      	ldr	r3, [r7, #32]
 801724a:	4413      	add	r3, r2
 801724c:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017250:	61fb      	str	r3, [r7, #28]
 8017252:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017256:	b29a      	uxth	r2, r3
 8017258:	69fb      	ldr	r3, [r7, #28]
 801725a:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 801725c:	463b      	mov	r3, r7
 801725e:	681b      	ldr	r3, [r3, #0]
 8017260:	891b      	ldrh	r3, [r3, #8]
 8017262:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8017266:	463b      	mov	r3, r7
 8017268:	681b      	ldr	r3, [r3, #0]
 801726a:	6959      	ldr	r1, [r3, #20]
 801726c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017270:	b29b      	uxth	r3, r3
 8017272:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8017276:	1d38      	adds	r0, r7, #4
 8017278:	6800      	ldr	r0, [r0, #0]
 801727a:	f001 f81e 	bl	80182ba <USB_WritePMA>
 801727e:	e2fd      	b.n	801787c <USB_EPStartXfer+0x9da>
          }
          else
          {
            /* Set the Double buffer counter for pmabuffer0 */
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8017280:	463b      	mov	r3, r7
 8017282:	681b      	ldr	r3, [r3, #0]
 8017284:	785b      	ldrb	r3, [r3, #1]
 8017286:	2b00      	cmp	r3, #0
 8017288:	d164      	bne.n	8017354 <USB_EPStartXfer+0x4b2>
 801728a:	1d3b      	adds	r3, r7, #4
 801728c:	681b      	ldr	r3, [r3, #0]
 801728e:	64bb      	str	r3, [r7, #72]	; 0x48
 8017290:	1d3b      	adds	r3, r7, #4
 8017292:	681b      	ldr	r3, [r3, #0]
 8017294:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017298:	b29b      	uxth	r3, r3
 801729a:	461a      	mov	r2, r3
 801729c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801729e:	4413      	add	r3, r2
 80172a0:	64bb      	str	r3, [r7, #72]	; 0x48
 80172a2:	463b      	mov	r3, r7
 80172a4:	681b      	ldr	r3, [r3, #0]
 80172a6:	781b      	ldrb	r3, [r3, #0]
 80172a8:	00da      	lsls	r2, r3, #3
 80172aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80172ac:	4413      	add	r3, r2
 80172ae:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80172b2:	647b      	str	r3, [r7, #68]	; 0x44
 80172b4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80172b8:	2b3e      	cmp	r3, #62	; 0x3e
 80172ba:	d91c      	bls.n	80172f6 <USB_EPStartXfer+0x454>
 80172bc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80172c0:	095b      	lsrs	r3, r3, #5
 80172c2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 80172c6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80172ca:	f003 031f 	and.w	r3, r3, #31
 80172ce:	2b00      	cmp	r3, #0
 80172d0:	d104      	bne.n	80172dc <USB_EPStartXfer+0x43a>
 80172d2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80172d6:	3b01      	subs	r3, #1
 80172d8:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 80172dc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80172e0:	b29b      	uxth	r3, r3
 80172e2:	029b      	lsls	r3, r3, #10
 80172e4:	b29b      	uxth	r3, r3
 80172e6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80172ea:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80172ee:	b29a      	uxth	r2, r3
 80172f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80172f2:	801a      	strh	r2, [r3, #0]
 80172f4:	e04d      	b.n	8017392 <USB_EPStartXfer+0x4f0>
 80172f6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80172fa:	2b00      	cmp	r3, #0
 80172fc:	d112      	bne.n	8017324 <USB_EPStartXfer+0x482>
 80172fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017300:	881b      	ldrh	r3, [r3, #0]
 8017302:	b29b      	uxth	r3, r3
 8017304:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017308:	b29a      	uxth	r2, r3
 801730a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801730c:	801a      	strh	r2, [r3, #0]
 801730e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017310:	881b      	ldrh	r3, [r3, #0]
 8017312:	b29b      	uxth	r3, r3
 8017314:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017318:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801731c:	b29a      	uxth	r2, r3
 801731e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017320:	801a      	strh	r2, [r3, #0]
 8017322:	e036      	b.n	8017392 <USB_EPStartXfer+0x4f0>
 8017324:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017328:	085b      	lsrs	r3, r3, #1
 801732a:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 801732e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017332:	f003 0301 	and.w	r3, r3, #1
 8017336:	2b00      	cmp	r3, #0
 8017338:	d004      	beq.n	8017344 <USB_EPStartXfer+0x4a2>
 801733a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 801733e:	3301      	adds	r3, #1
 8017340:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8017344:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8017348:	b29b      	uxth	r3, r3
 801734a:	029b      	lsls	r3, r3, #10
 801734c:	b29a      	uxth	r2, r3
 801734e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017350:	801a      	strh	r2, [r3, #0]
 8017352:	e01e      	b.n	8017392 <USB_EPStartXfer+0x4f0>
 8017354:	463b      	mov	r3, r7
 8017356:	681b      	ldr	r3, [r3, #0]
 8017358:	785b      	ldrb	r3, [r3, #1]
 801735a:	2b01      	cmp	r3, #1
 801735c:	d119      	bne.n	8017392 <USB_EPStartXfer+0x4f0>
 801735e:	1d3b      	adds	r3, r7, #4
 8017360:	681b      	ldr	r3, [r3, #0]
 8017362:	653b      	str	r3, [r7, #80]	; 0x50
 8017364:	1d3b      	adds	r3, r7, #4
 8017366:	681b      	ldr	r3, [r3, #0]
 8017368:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801736c:	b29b      	uxth	r3, r3
 801736e:	461a      	mov	r2, r3
 8017370:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017372:	4413      	add	r3, r2
 8017374:	653b      	str	r3, [r7, #80]	; 0x50
 8017376:	463b      	mov	r3, r7
 8017378:	681b      	ldr	r3, [r3, #0]
 801737a:	781b      	ldrb	r3, [r3, #0]
 801737c:	00da      	lsls	r2, r3, #3
 801737e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017380:	4413      	add	r3, r2
 8017382:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017386:	64fb      	str	r3, [r7, #76]	; 0x4c
 8017388:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801738c:	b29a      	uxth	r2, r3
 801738e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017390:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr0;
 8017392:	463b      	mov	r3, r7
 8017394:	681b      	ldr	r3, [r3, #0]
 8017396:	891b      	ldrh	r3, [r3, #8]
 8017398:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 801739c:	463b      	mov	r3, r7
 801739e:	681b      	ldr	r3, [r3, #0]
 80173a0:	6959      	ldr	r1, [r3, #20]
 80173a2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80173a6:	b29b      	uxth	r3, r3
 80173a8:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 80173ac:	1d38      	adds	r0, r7, #4
 80173ae:	6800      	ldr	r0, [r0, #0]
 80173b0:	f000 ff83 	bl	80182ba <USB_WritePMA>
            ep->xfer_buff += len;
 80173b4:	463b      	mov	r3, r7
 80173b6:	681b      	ldr	r3, [r3, #0]
 80173b8:	695a      	ldr	r2, [r3, #20]
 80173ba:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80173be:	441a      	add	r2, r3
 80173c0:	463b      	mov	r3, r7
 80173c2:	681b      	ldr	r3, [r3, #0]
 80173c4:	615a      	str	r2, [r3, #20]

            if (ep->xfer_len_db > ep->maxpacket)
 80173c6:	463b      	mov	r3, r7
 80173c8:	681b      	ldr	r3, [r3, #0]
 80173ca:	6a1a      	ldr	r2, [r3, #32]
 80173cc:	463b      	mov	r3, r7
 80173ce:	681b      	ldr	r3, [r3, #0]
 80173d0:	691b      	ldr	r3, [r3, #16]
 80173d2:	429a      	cmp	r2, r3
 80173d4:	d909      	bls.n	80173ea <USB_EPStartXfer+0x548>
            {
              ep->xfer_len_db -= len;
 80173d6:	463b      	mov	r3, r7
 80173d8:	681b      	ldr	r3, [r3, #0]
 80173da:	6a1a      	ldr	r2, [r3, #32]
 80173dc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80173e0:	1ad2      	subs	r2, r2, r3
 80173e2:	463b      	mov	r3, r7
 80173e4:	681b      	ldr	r3, [r3, #0]
 80173e6:	621a      	str	r2, [r3, #32]
 80173e8:	e008      	b.n	80173fc <USB_EPStartXfer+0x55a>
            }
            else
            {
              len = ep->xfer_len_db;
 80173ea:	463b      	mov	r3, r7
 80173ec:	681b      	ldr	r3, [r3, #0]
 80173ee:	6a1b      	ldr	r3, [r3, #32]
 80173f0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
              ep->xfer_len_db = 0U;
 80173f4:	463b      	mov	r3, r7
 80173f6:	681b      	ldr	r3, [r3, #0]
 80173f8:	2200      	movs	r2, #0
 80173fa:	621a      	str	r2, [r3, #32]
            }

            /* Set the Double buffer counter for pmabuffer1 */
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80173fc:	1d3b      	adds	r3, r7, #4
 80173fe:	681b      	ldr	r3, [r3, #0]
 8017400:	643b      	str	r3, [r7, #64]	; 0x40
 8017402:	463b      	mov	r3, r7
 8017404:	681b      	ldr	r3, [r3, #0]
 8017406:	785b      	ldrb	r3, [r3, #1]
 8017408:	2b00      	cmp	r3, #0
 801740a:	d164      	bne.n	80174d6 <USB_EPStartXfer+0x634>
 801740c:	1d3b      	adds	r3, r7, #4
 801740e:	681b      	ldr	r3, [r3, #0]
 8017410:	63bb      	str	r3, [r7, #56]	; 0x38
 8017412:	1d3b      	adds	r3, r7, #4
 8017414:	681b      	ldr	r3, [r3, #0]
 8017416:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801741a:	b29b      	uxth	r3, r3
 801741c:	461a      	mov	r2, r3
 801741e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8017420:	4413      	add	r3, r2
 8017422:	63bb      	str	r3, [r7, #56]	; 0x38
 8017424:	463b      	mov	r3, r7
 8017426:	681b      	ldr	r3, [r3, #0]
 8017428:	781b      	ldrb	r3, [r3, #0]
 801742a:	00da      	lsls	r2, r3, #3
 801742c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801742e:	4413      	add	r3, r2
 8017430:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017434:	637b      	str	r3, [r7, #52]	; 0x34
 8017436:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801743a:	2b3e      	cmp	r3, #62	; 0x3e
 801743c:	d91c      	bls.n	8017478 <USB_EPStartXfer+0x5d6>
 801743e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017442:	095b      	lsrs	r3, r3, #5
 8017444:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 8017448:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801744c:	f003 031f 	and.w	r3, r3, #31
 8017450:	2b00      	cmp	r3, #0
 8017452:	d104      	bne.n	801745e <USB_EPStartXfer+0x5bc>
 8017454:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8017458:	3b01      	subs	r3, #1
 801745a:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 801745e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8017462:	b29b      	uxth	r3, r3
 8017464:	029b      	lsls	r3, r3, #10
 8017466:	b29b      	uxth	r3, r3
 8017468:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801746c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017470:	b29a      	uxth	r2, r3
 8017472:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017474:	801a      	strh	r2, [r3, #0]
 8017476:	e04a      	b.n	801750e <USB_EPStartXfer+0x66c>
 8017478:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801747c:	2b00      	cmp	r3, #0
 801747e:	d112      	bne.n	80174a6 <USB_EPStartXfer+0x604>
 8017480:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017482:	881b      	ldrh	r3, [r3, #0]
 8017484:	b29b      	uxth	r3, r3
 8017486:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 801748a:	b29a      	uxth	r2, r3
 801748c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801748e:	801a      	strh	r2, [r3, #0]
 8017490:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017492:	881b      	ldrh	r3, [r3, #0]
 8017494:	b29b      	uxth	r3, r3
 8017496:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801749a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801749e:	b29a      	uxth	r2, r3
 80174a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80174a2:	801a      	strh	r2, [r3, #0]
 80174a4:	e033      	b.n	801750e <USB_EPStartXfer+0x66c>
 80174a6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80174aa:	085b      	lsrs	r3, r3, #1
 80174ac:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 80174b0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80174b4:	f003 0301 	and.w	r3, r3, #1
 80174b8:	2b00      	cmp	r3, #0
 80174ba:	d004      	beq.n	80174c6 <USB_EPStartXfer+0x624>
 80174bc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80174c0:	3301      	adds	r3, #1
 80174c2:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 80174c6:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 80174ca:	b29b      	uxth	r3, r3
 80174cc:	029b      	lsls	r3, r3, #10
 80174ce:	b29a      	uxth	r2, r3
 80174d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80174d2:	801a      	strh	r2, [r3, #0]
 80174d4:	e01b      	b.n	801750e <USB_EPStartXfer+0x66c>
 80174d6:	463b      	mov	r3, r7
 80174d8:	681b      	ldr	r3, [r3, #0]
 80174da:	785b      	ldrb	r3, [r3, #1]
 80174dc:	2b01      	cmp	r3, #1
 80174de:	d116      	bne.n	801750e <USB_EPStartXfer+0x66c>
 80174e0:	1d3b      	adds	r3, r7, #4
 80174e2:	681b      	ldr	r3, [r3, #0]
 80174e4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80174e8:	b29b      	uxth	r3, r3
 80174ea:	461a      	mov	r2, r3
 80174ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80174ee:	4413      	add	r3, r2
 80174f0:	643b      	str	r3, [r7, #64]	; 0x40
 80174f2:	463b      	mov	r3, r7
 80174f4:	681b      	ldr	r3, [r3, #0]
 80174f6:	781b      	ldrb	r3, [r3, #0]
 80174f8:	00da      	lsls	r2, r3, #3
 80174fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80174fc:	4413      	add	r3, r2
 80174fe:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017502:	63fb      	str	r3, [r7, #60]	; 0x3c
 8017504:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017508:	b29a      	uxth	r2, r3
 801750a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801750c:	801a      	strh	r2, [r3, #0]
            pmabuffer = ep->pmaaddr1;
 801750e:	463b      	mov	r3, r7
 8017510:	681b      	ldr	r3, [r3, #0]
 8017512:	895b      	ldrh	r3, [r3, #10]
 8017514:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            /* Write the user buffer to USB PMA */
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8017518:	463b      	mov	r3, r7
 801751a:	681b      	ldr	r3, [r3, #0]
 801751c:	6959      	ldr	r1, [r3, #20]
 801751e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017522:	b29b      	uxth	r3, r3
 8017524:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8017528:	1d38      	adds	r0, r7, #4
 801752a:	6800      	ldr	r0, [r0, #0]
 801752c:	f000 fec5 	bl	80182ba <USB_WritePMA>
 8017530:	e1a4      	b.n	801787c <USB_EPStartXfer+0x9da>
          }
        }
        /* auto Switch to single buffer mode when transfer <Mps no need to manage in double buffer */
        else
        {
          len = ep->xfer_len_db;
 8017532:	463b      	mov	r3, r7
 8017534:	681b      	ldr	r3, [r3, #0]
 8017536:	6a1b      	ldr	r3, [r3, #32]
 8017538:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104

          /* disable double buffer mode for Bulk endpoint */
          PCD_CLEAR_BULK_EP_DBUF(USBx, ep->num);
 801753c:	1d3b      	adds	r3, r7, #4
 801753e:	681a      	ldr	r2, [r3, #0]
 8017540:	463b      	mov	r3, r7
 8017542:	681b      	ldr	r3, [r3, #0]
 8017544:	781b      	ldrb	r3, [r3, #0]
 8017546:	009b      	lsls	r3, r3, #2
 8017548:	4413      	add	r3, r2
 801754a:	881b      	ldrh	r3, [r3, #0]
 801754c:	b29b      	uxth	r3, r3
 801754e:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
 8017552:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8017556:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 801755a:	1d3b      	adds	r3, r7, #4
 801755c:	681a      	ldr	r2, [r3, #0]
 801755e:	463b      	mov	r3, r7
 8017560:	681b      	ldr	r3, [r3, #0]
 8017562:	781b      	ldrb	r3, [r3, #0]
 8017564:	009b      	lsls	r3, r3, #2
 8017566:	441a      	add	r2, r3
 8017568:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801756c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8017570:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8017574:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8017578:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801757c:	b29b      	uxth	r3, r3
 801757e:	8013      	strh	r3, [r2, #0]

          /* Set Tx count with nbre of byte to be transmitted */
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8017580:	1d3b      	adds	r3, r7, #4
 8017582:	681b      	ldr	r3, [r3, #0]
 8017584:	65fb      	str	r3, [r7, #92]	; 0x5c
 8017586:	1d3b      	adds	r3, r7, #4
 8017588:	681b      	ldr	r3, [r3, #0]
 801758a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801758e:	b29b      	uxth	r3, r3
 8017590:	461a      	mov	r2, r3
 8017592:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017594:	4413      	add	r3, r2
 8017596:	65fb      	str	r3, [r7, #92]	; 0x5c
 8017598:	463b      	mov	r3, r7
 801759a:	681b      	ldr	r3, [r3, #0]
 801759c:	781b      	ldrb	r3, [r3, #0]
 801759e:	00da      	lsls	r2, r3, #3
 80175a0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80175a2:	4413      	add	r3, r2
 80175a4:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80175a8:	65bb      	str	r3, [r7, #88]	; 0x58
 80175aa:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80175ae:	b29a      	uxth	r2, r3
 80175b0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80175b2:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 80175b4:	463b      	mov	r3, r7
 80175b6:	681b      	ldr	r3, [r3, #0]
 80175b8:	891b      	ldrh	r3, [r3, #8]
 80175ba:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 80175be:	463b      	mov	r3, r7
 80175c0:	681b      	ldr	r3, [r3, #0]
 80175c2:	6959      	ldr	r1, [r3, #20]
 80175c4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80175c8:	b29b      	uxth	r3, r3
 80175ca:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 80175ce:	1d38      	adds	r0, r7, #4
 80175d0:	6800      	ldr	r0, [r0, #0]
 80175d2:	f000 fe72 	bl	80182ba <USB_WritePMA>
 80175d6:	e151      	b.n	801787c <USB_EPStartXfer+0x9da>
        }
      }
      else /* manage isochronous double buffer IN mode */
      {
        /* each Time to write in PMA xfer_len_db will */
        ep->xfer_len_db -= len;
 80175d8:	463b      	mov	r3, r7
 80175da:	681b      	ldr	r3, [r3, #0]
 80175dc:	6a1a      	ldr	r2, [r3, #32]
 80175de:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80175e2:	1ad2      	subs	r2, r2, r3
 80175e4:	463b      	mov	r3, r7
 80175e6:	681b      	ldr	r3, [r3, #0]
 80175e8:	621a      	str	r2, [r3, #32]

        /* Fill the data buffer */
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 80175ea:	1d3b      	adds	r3, r7, #4
 80175ec:	681a      	ldr	r2, [r3, #0]
 80175ee:	463b      	mov	r3, r7
 80175f0:	681b      	ldr	r3, [r3, #0]
 80175f2:	781b      	ldrb	r3, [r3, #0]
 80175f4:	009b      	lsls	r3, r3, #2
 80175f6:	4413      	add	r3, r2
 80175f8:	881b      	ldrh	r3, [r3, #0]
 80175fa:	b29b      	uxth	r3, r3
 80175fc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017600:	2b00      	cmp	r3, #0
 8017602:	f000 809b 	beq.w	801773c <USB_EPStartXfer+0x89a>
        {
          /* Set the Double buffer counter for pmabuffer1 */
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8017606:	1d3b      	adds	r3, r7, #4
 8017608:	681b      	ldr	r3, [r3, #0]
 801760a:	673b      	str	r3, [r7, #112]	; 0x70
 801760c:	463b      	mov	r3, r7
 801760e:	681b      	ldr	r3, [r3, #0]
 8017610:	785b      	ldrb	r3, [r3, #1]
 8017612:	2b00      	cmp	r3, #0
 8017614:	d164      	bne.n	80176e0 <USB_EPStartXfer+0x83e>
 8017616:	1d3b      	adds	r3, r7, #4
 8017618:	681b      	ldr	r3, [r3, #0]
 801761a:	66bb      	str	r3, [r7, #104]	; 0x68
 801761c:	1d3b      	adds	r3, r7, #4
 801761e:	681b      	ldr	r3, [r3, #0]
 8017620:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017624:	b29b      	uxth	r3, r3
 8017626:	461a      	mov	r2, r3
 8017628:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801762a:	4413      	add	r3, r2
 801762c:	66bb      	str	r3, [r7, #104]	; 0x68
 801762e:	463b      	mov	r3, r7
 8017630:	681b      	ldr	r3, [r3, #0]
 8017632:	781b      	ldrb	r3, [r3, #0]
 8017634:	00da      	lsls	r2, r3, #3
 8017636:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017638:	4413      	add	r3, r2
 801763a:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801763e:	667b      	str	r3, [r7, #100]	; 0x64
 8017640:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017644:	2b3e      	cmp	r3, #62	; 0x3e
 8017646:	d91c      	bls.n	8017682 <USB_EPStartXfer+0x7e0>
 8017648:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801764c:	095b      	lsrs	r3, r3, #5
 801764e:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8017652:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017656:	f003 031f 	and.w	r3, r3, #31
 801765a:	2b00      	cmp	r3, #0
 801765c:	d104      	bne.n	8017668 <USB_EPStartXfer+0x7c6>
 801765e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8017662:	3b01      	subs	r3, #1
 8017664:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 8017668:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801766c:	b29b      	uxth	r3, r3
 801766e:	029b      	lsls	r3, r3, #10
 8017670:	b29b      	uxth	r3, r3
 8017672:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017676:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801767a:	b29a      	uxth	r2, r3
 801767c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801767e:	801a      	strh	r2, [r3, #0]
 8017680:	e04a      	b.n	8017718 <USB_EPStartXfer+0x876>
 8017682:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017686:	2b00      	cmp	r3, #0
 8017688:	d112      	bne.n	80176b0 <USB_EPStartXfer+0x80e>
 801768a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801768c:	881b      	ldrh	r3, [r3, #0]
 801768e:	b29b      	uxth	r3, r3
 8017690:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017694:	b29a      	uxth	r2, r3
 8017696:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017698:	801a      	strh	r2, [r3, #0]
 801769a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801769c:	881b      	ldrh	r3, [r3, #0]
 801769e:	b29b      	uxth	r3, r3
 80176a0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80176a4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80176a8:	b29a      	uxth	r2, r3
 80176aa:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80176ac:	801a      	strh	r2, [r3, #0]
 80176ae:	e033      	b.n	8017718 <USB_EPStartXfer+0x876>
 80176b0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80176b4:	085b      	lsrs	r3, r3, #1
 80176b6:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 80176ba:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80176be:	f003 0301 	and.w	r3, r3, #1
 80176c2:	2b00      	cmp	r3, #0
 80176c4:	d004      	beq.n	80176d0 <USB_EPStartXfer+0x82e>
 80176c6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80176ca:	3301      	adds	r3, #1
 80176cc:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 80176d0:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 80176d4:	b29b      	uxth	r3, r3
 80176d6:	029b      	lsls	r3, r3, #10
 80176d8:	b29a      	uxth	r2, r3
 80176da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80176dc:	801a      	strh	r2, [r3, #0]
 80176de:	e01b      	b.n	8017718 <USB_EPStartXfer+0x876>
 80176e0:	463b      	mov	r3, r7
 80176e2:	681b      	ldr	r3, [r3, #0]
 80176e4:	785b      	ldrb	r3, [r3, #1]
 80176e6:	2b01      	cmp	r3, #1
 80176e8:	d116      	bne.n	8017718 <USB_EPStartXfer+0x876>
 80176ea:	1d3b      	adds	r3, r7, #4
 80176ec:	681b      	ldr	r3, [r3, #0]
 80176ee:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 80176f2:	b29b      	uxth	r3, r3
 80176f4:	461a      	mov	r2, r3
 80176f6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80176f8:	4413      	add	r3, r2
 80176fa:	673b      	str	r3, [r7, #112]	; 0x70
 80176fc:	463b      	mov	r3, r7
 80176fe:	681b      	ldr	r3, [r3, #0]
 8017700:	781b      	ldrb	r3, [r3, #0]
 8017702:	00da      	lsls	r2, r3, #3
 8017704:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8017706:	4413      	add	r3, r2
 8017708:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801770c:	66fb      	str	r3, [r7, #108]	; 0x6c
 801770e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017712:	b29a      	uxth	r2, r3
 8017714:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017716:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr1;
 8017718:	463b      	mov	r3, r7
 801771a:	681b      	ldr	r3, [r3, #0]
 801771c:	895b      	ldrh	r3, [r3, #10]
 801771e:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8017722:	463b      	mov	r3, r7
 8017724:	681b      	ldr	r3, [r3, #0]
 8017726:	6959      	ldr	r1, [r3, #20]
 8017728:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801772c:	b29b      	uxth	r3, r3
 801772e:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8017732:	1d38      	adds	r0, r7, #4
 8017734:	6800      	ldr	r0, [r0, #0]
 8017736:	f000 fdc0 	bl	80182ba <USB_WritePMA>
 801773a:	e09f      	b.n	801787c <USB_EPStartXfer+0x9da>
        }
        else
        {
          /* Set the Double buffer counter for pmabuffer0 */
          PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 801773c:	463b      	mov	r3, r7
 801773e:	681b      	ldr	r3, [r3, #0]
 8017740:	785b      	ldrb	r3, [r3, #1]
 8017742:	2b00      	cmp	r3, #0
 8017744:	d164      	bne.n	8017810 <USB_EPStartXfer+0x96e>
 8017746:	1d3b      	adds	r3, r7, #4
 8017748:	681b      	ldr	r3, [r3, #0]
 801774a:	67fb      	str	r3, [r7, #124]	; 0x7c
 801774c:	1d3b      	adds	r3, r7, #4
 801774e:	681b      	ldr	r3, [r3, #0]
 8017750:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017754:	b29b      	uxth	r3, r3
 8017756:	461a      	mov	r2, r3
 8017758:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801775a:	4413      	add	r3, r2
 801775c:	67fb      	str	r3, [r7, #124]	; 0x7c
 801775e:	463b      	mov	r3, r7
 8017760:	681b      	ldr	r3, [r3, #0]
 8017762:	781b      	ldrb	r3, [r3, #0]
 8017764:	00da      	lsls	r2, r3, #3
 8017766:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8017768:	4413      	add	r3, r2
 801776a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801776e:	67bb      	str	r3, [r7, #120]	; 0x78
 8017770:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017774:	2b3e      	cmp	r3, #62	; 0x3e
 8017776:	d91c      	bls.n	80177b2 <USB_EPStartXfer+0x910>
 8017778:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801777c:	095b      	lsrs	r3, r3, #5
 801777e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8017782:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017786:	f003 031f 	and.w	r3, r3, #31
 801778a:	2b00      	cmp	r3, #0
 801778c:	d104      	bne.n	8017798 <USB_EPStartXfer+0x8f6>
 801778e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8017792:	3b01      	subs	r3, #1
 8017794:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8017798:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 801779c:	b29b      	uxth	r3, r3
 801779e:	029b      	lsls	r3, r3, #10
 80177a0:	b29b      	uxth	r3, r3
 80177a2:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80177a6:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80177aa:	b29a      	uxth	r2, r3
 80177ac:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80177ae:	801a      	strh	r2, [r3, #0]
 80177b0:	e053      	b.n	801785a <USB_EPStartXfer+0x9b8>
 80177b2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80177b6:	2b00      	cmp	r3, #0
 80177b8:	d112      	bne.n	80177e0 <USB_EPStartXfer+0x93e>
 80177ba:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80177bc:	881b      	ldrh	r3, [r3, #0]
 80177be:	b29b      	uxth	r3, r3
 80177c0:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80177c4:	b29a      	uxth	r2, r3
 80177c6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80177c8:	801a      	strh	r2, [r3, #0]
 80177ca:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80177cc:	881b      	ldrh	r3, [r3, #0]
 80177ce:	b29b      	uxth	r3, r3
 80177d0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80177d4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80177d8:	b29a      	uxth	r2, r3
 80177da:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80177dc:	801a      	strh	r2, [r3, #0]
 80177de:	e03c      	b.n	801785a <USB_EPStartXfer+0x9b8>
 80177e0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80177e4:	085b      	lsrs	r3, r3, #1
 80177e6:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 80177ea:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80177ee:	f003 0301 	and.w	r3, r3, #1
 80177f2:	2b00      	cmp	r3, #0
 80177f4:	d004      	beq.n	8017800 <USB_EPStartXfer+0x95e>
 80177f6:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 80177fa:	3301      	adds	r3, #1
 80177fc:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8017800:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8017804:	b29b      	uxth	r3, r3
 8017806:	029b      	lsls	r3, r3, #10
 8017808:	b29a      	uxth	r2, r3
 801780a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801780c:	801a      	strh	r2, [r3, #0]
 801780e:	e024      	b.n	801785a <USB_EPStartXfer+0x9b8>
 8017810:	463b      	mov	r3, r7
 8017812:	681b      	ldr	r3, [r3, #0]
 8017814:	785b      	ldrb	r3, [r3, #1]
 8017816:	2b01      	cmp	r3, #1
 8017818:	d11f      	bne.n	801785a <USB_EPStartXfer+0x9b8>
 801781a:	1d3b      	adds	r3, r7, #4
 801781c:	681b      	ldr	r3, [r3, #0]
 801781e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8017822:	1d3b      	adds	r3, r7, #4
 8017824:	681b      	ldr	r3, [r3, #0]
 8017826:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801782a:	b29b      	uxth	r3, r3
 801782c:	461a      	mov	r2, r3
 801782e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017832:	4413      	add	r3, r2
 8017834:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8017838:	463b      	mov	r3, r7
 801783a:	681b      	ldr	r3, [r3, #0]
 801783c:	781b      	ldrb	r3, [r3, #0]
 801783e:	00da      	lsls	r2, r3, #3
 8017840:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017844:	4413      	add	r3, r2
 8017846:	f203 4302 	addw	r3, r3, #1026	; 0x402
 801784a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 801784e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017852:	b29a      	uxth	r2, r3
 8017854:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8017858:	801a      	strh	r2, [r3, #0]
          pmabuffer = ep->pmaaddr0;
 801785a:	463b      	mov	r3, r7
 801785c:	681b      	ldr	r3, [r3, #0]
 801785e:	891b      	ldrh	r3, [r3, #8]
 8017860:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

          /* Write the user buffer to USB PMA */
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 8017864:	463b      	mov	r3, r7
 8017866:	681b      	ldr	r3, [r3, #0]
 8017868:	6959      	ldr	r1, [r3, #20]
 801786a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801786e:	b29b      	uxth	r3, r3
 8017870:	f8b7 2076 	ldrh.w	r2, [r7, #118]	; 0x76
 8017874:	1d38      	adds	r0, r7, #4
 8017876:	6800      	ldr	r0, [r0, #0]
 8017878:	f000 fd1f 	bl	80182ba <USB_WritePMA>
        }
      }
    }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 801787c:	1d3b      	adds	r3, r7, #4
 801787e:	681a      	ldr	r2, [r3, #0]
 8017880:	463b      	mov	r3, r7
 8017882:	681b      	ldr	r3, [r3, #0]
 8017884:	781b      	ldrb	r3, [r3, #0]
 8017886:	009b      	lsls	r3, r3, #2
 8017888:	4413      	add	r3, r2
 801788a:	881b      	ldrh	r3, [r3, #0]
 801788c:	b29b      	uxth	r3, r3
 801788e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8017892:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8017896:	817b      	strh	r3, [r7, #10]
 8017898:	897b      	ldrh	r3, [r7, #10]
 801789a:	f083 0310 	eor.w	r3, r3, #16
 801789e:	817b      	strh	r3, [r7, #10]
 80178a0:	897b      	ldrh	r3, [r7, #10]
 80178a2:	f083 0320 	eor.w	r3, r3, #32
 80178a6:	817b      	strh	r3, [r7, #10]
 80178a8:	1d3b      	adds	r3, r7, #4
 80178aa:	681a      	ldr	r2, [r3, #0]
 80178ac:	463b      	mov	r3, r7
 80178ae:	681b      	ldr	r3, [r3, #0]
 80178b0:	781b      	ldrb	r3, [r3, #0]
 80178b2:	009b      	lsls	r3, r3, #2
 80178b4:	441a      	add	r2, r3
 80178b6:	897b      	ldrh	r3, [r7, #10]
 80178b8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80178bc:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80178c0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80178c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80178c8:	b29b      	uxth	r3, r3
 80178ca:	8013      	strh	r3, [r2, #0]
 80178cc:	e3b5      	b.n	801803a <USB_EPStartXfer+0x1198>
  }
  else /* OUT endpoint */
  {
    if (ep->doublebuffer == 0U)
 80178ce:	463b      	mov	r3, r7
 80178d0:	681b      	ldr	r3, [r3, #0]
 80178d2:	7b1b      	ldrb	r3, [r3, #12]
 80178d4:	2b00      	cmp	r3, #0
 80178d6:	f040 8090 	bne.w	80179fa <USB_EPStartXfer+0xb58>
    {
      /* Multi packet transfer */
      if (ep->xfer_len > ep->maxpacket)
 80178da:	463b      	mov	r3, r7
 80178dc:	681b      	ldr	r3, [r3, #0]
 80178de:	699a      	ldr	r2, [r3, #24]
 80178e0:	463b      	mov	r3, r7
 80178e2:	681b      	ldr	r3, [r3, #0]
 80178e4:	691b      	ldr	r3, [r3, #16]
 80178e6:	429a      	cmp	r2, r3
 80178e8:	d90e      	bls.n	8017908 <USB_EPStartXfer+0xa66>
      {
        len = ep->maxpacket;
 80178ea:	463b      	mov	r3, r7
 80178ec:	681b      	ldr	r3, [r3, #0]
 80178ee:	691b      	ldr	r3, [r3, #16]
 80178f0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        ep->xfer_len -= len;
 80178f4:	463b      	mov	r3, r7
 80178f6:	681b      	ldr	r3, [r3, #0]
 80178f8:	699a      	ldr	r2, [r3, #24]
 80178fa:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80178fe:	1ad2      	subs	r2, r2, r3
 8017900:	463b      	mov	r3, r7
 8017902:	681b      	ldr	r3, [r3, #0]
 8017904:	619a      	str	r2, [r3, #24]
 8017906:	e008      	b.n	801791a <USB_EPStartXfer+0xa78>
      }
      else
      {
        len = ep->xfer_len;
 8017908:	463b      	mov	r3, r7
 801790a:	681b      	ldr	r3, [r3, #0]
 801790c:	699b      	ldr	r3, [r3, #24]
 801790e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        ep->xfer_len = 0U;
 8017912:	463b      	mov	r3, r7
 8017914:	681b      	ldr	r3, [r3, #0]
 8017916:	2200      	movs	r2, #0
 8017918:	619a      	str	r2, [r3, #24]
      }
      /* configure and validate Rx endpoint */
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 801791a:	1d3b      	adds	r3, r7, #4
 801791c:	681b      	ldr	r3, [r3, #0]
 801791e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8017922:	1d3b      	adds	r3, r7, #4
 8017924:	681b      	ldr	r3, [r3, #0]
 8017926:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 801792a:	b29b      	uxth	r3, r3
 801792c:	461a      	mov	r2, r3
 801792e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017932:	4413      	add	r3, r2
 8017934:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8017938:	463b      	mov	r3, r7
 801793a:	681b      	ldr	r3, [r3, #0]
 801793c:	781b      	ldrb	r3, [r3, #0]
 801793e:	00da      	lsls	r2, r3, #3
 8017940:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017944:	4413      	add	r3, r2
 8017946:	f203 4306 	addw	r3, r3, #1030	; 0x406
 801794a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 801794e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017952:	2b3e      	cmp	r3, #62	; 0x3e
 8017954:	d91d      	bls.n	8017992 <USB_EPStartXfer+0xaf0>
 8017956:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801795a:	095b      	lsrs	r3, r3, #5
 801795c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8017960:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017964:	f003 031f 	and.w	r3, r3, #31
 8017968:	2b00      	cmp	r3, #0
 801796a:	d104      	bne.n	8017976 <USB_EPStartXfer+0xad4>
 801796c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8017970:	3b01      	subs	r3, #1
 8017972:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8017976:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 801797a:	b29b      	uxth	r3, r3
 801797c:	029b      	lsls	r3, r3, #10
 801797e:	b29b      	uxth	r3, r3
 8017980:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017984:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017988:	b29a      	uxth	r2, r3
 801798a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801798e:	801a      	strh	r2, [r3, #0]
 8017990:	e325      	b.n	8017fde <USB_EPStartXfer+0x113c>
 8017992:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017996:	2b00      	cmp	r3, #0
 8017998:	d116      	bne.n	80179c8 <USB_EPStartXfer+0xb26>
 801799a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801799e:	881b      	ldrh	r3, [r3, #0]
 80179a0:	b29b      	uxth	r3, r3
 80179a2:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80179a6:	b29a      	uxth	r2, r3
 80179a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80179ac:	801a      	strh	r2, [r3, #0]
 80179ae:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80179b2:	881b      	ldrh	r3, [r3, #0]
 80179b4:	b29b      	uxth	r3, r3
 80179b6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80179ba:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80179be:	b29a      	uxth	r2, r3
 80179c0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80179c4:	801a      	strh	r2, [r3, #0]
 80179c6:	e30a      	b.n	8017fde <USB_EPStartXfer+0x113c>
 80179c8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80179cc:	085b      	lsrs	r3, r3, #1
 80179ce:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 80179d2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80179d6:	f003 0301 	and.w	r3, r3, #1
 80179da:	2b00      	cmp	r3, #0
 80179dc:	d004      	beq.n	80179e8 <USB_EPStartXfer+0xb46>
 80179de:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80179e2:	3301      	adds	r3, #1
 80179e4:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 80179e8:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 80179ec:	b29b      	uxth	r3, r3
 80179ee:	029b      	lsls	r3, r3, #10
 80179f0:	b29a      	uxth	r2, r3
 80179f2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80179f6:	801a      	strh	r2, [r3, #0]
 80179f8:	e2f1      	b.n	8017fde <USB_EPStartXfer+0x113c>
#if (USE_USB_DOUBLE_BUFFER == 1U)
    else
    {
      /* First Transfer Coming From HAL_PCD_EP_Receive & From ISR */
      /* Set the Double buffer counter */
      if (ep->type == EP_TYPE_BULK)
 80179fa:	463b      	mov	r3, r7
 80179fc:	681b      	ldr	r3, [r3, #0]
 80179fe:	78db      	ldrb	r3, [r3, #3]
 8017a00:	2b02      	cmp	r3, #2
 8017a02:	f040 818f 	bne.w	8017d24 <USB_EPStartXfer+0xe82>
      {
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 8017a06:	463b      	mov	r3, r7
 8017a08:	681b      	ldr	r3, [r3, #0]
 8017a0a:	785b      	ldrb	r3, [r3, #1]
 8017a0c:	2b00      	cmp	r3, #0
 8017a0e:	d175      	bne.n	8017afc <USB_EPStartXfer+0xc5a>
 8017a10:	1d3b      	adds	r3, r7, #4
 8017a12:	681b      	ldr	r3, [r3, #0]
 8017a14:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8017a18:	1d3b      	adds	r3, r7, #4
 8017a1a:	681b      	ldr	r3, [r3, #0]
 8017a1c:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017a20:	b29b      	uxth	r3, r3
 8017a22:	461a      	mov	r2, r3
 8017a24:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8017a28:	4413      	add	r3, r2
 8017a2a:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8017a2e:	463b      	mov	r3, r7
 8017a30:	681b      	ldr	r3, [r3, #0]
 8017a32:	781b      	ldrb	r3, [r3, #0]
 8017a34:	00da      	lsls	r2, r3, #3
 8017a36:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8017a3a:	4413      	add	r3, r2
 8017a3c:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017a40:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8017a44:	463b      	mov	r3, r7
 8017a46:	681b      	ldr	r3, [r3, #0]
 8017a48:	691b      	ldr	r3, [r3, #16]
 8017a4a:	2b3e      	cmp	r3, #62	; 0x3e
 8017a4c:	d91f      	bls.n	8017a8e <USB_EPStartXfer+0xbec>
 8017a4e:	463b      	mov	r3, r7
 8017a50:	681b      	ldr	r3, [r3, #0]
 8017a52:	691b      	ldr	r3, [r3, #16]
 8017a54:	095b      	lsrs	r3, r3, #5
 8017a56:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8017a5a:	463b      	mov	r3, r7
 8017a5c:	681b      	ldr	r3, [r3, #0]
 8017a5e:	691b      	ldr	r3, [r3, #16]
 8017a60:	f003 031f 	and.w	r3, r3, #31
 8017a64:	2b00      	cmp	r3, #0
 8017a66:	d104      	bne.n	8017a72 <USB_EPStartXfer+0xbd0>
 8017a68:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8017a6c:	3b01      	subs	r3, #1
 8017a6e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8017a72:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8017a76:	b29b      	uxth	r3, r3
 8017a78:	029b      	lsls	r3, r3, #10
 8017a7a:	b29b      	uxth	r3, r3
 8017a7c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017a80:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017a84:	b29a      	uxth	r2, r3
 8017a86:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017a8a:	801a      	strh	r2, [r3, #0]
 8017a8c:	e05c      	b.n	8017b48 <USB_EPStartXfer+0xca6>
 8017a8e:	463b      	mov	r3, r7
 8017a90:	681b      	ldr	r3, [r3, #0]
 8017a92:	691b      	ldr	r3, [r3, #16]
 8017a94:	2b00      	cmp	r3, #0
 8017a96:	d116      	bne.n	8017ac6 <USB_EPStartXfer+0xc24>
 8017a98:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017a9c:	881b      	ldrh	r3, [r3, #0]
 8017a9e:	b29b      	uxth	r3, r3
 8017aa0:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017aa4:	b29a      	uxth	r2, r3
 8017aa6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017aaa:	801a      	strh	r2, [r3, #0]
 8017aac:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017ab0:	881b      	ldrh	r3, [r3, #0]
 8017ab2:	b29b      	uxth	r3, r3
 8017ab4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017ab8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017abc:	b29a      	uxth	r2, r3
 8017abe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017ac2:	801a      	strh	r2, [r3, #0]
 8017ac4:	e040      	b.n	8017b48 <USB_EPStartXfer+0xca6>
 8017ac6:	463b      	mov	r3, r7
 8017ac8:	681b      	ldr	r3, [r3, #0]
 8017aca:	691b      	ldr	r3, [r3, #16]
 8017acc:	085b      	lsrs	r3, r3, #1
 8017ace:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8017ad2:	463b      	mov	r3, r7
 8017ad4:	681b      	ldr	r3, [r3, #0]
 8017ad6:	691b      	ldr	r3, [r3, #16]
 8017ad8:	f003 0301 	and.w	r3, r3, #1
 8017adc:	2b00      	cmp	r3, #0
 8017ade:	d004      	beq.n	8017aea <USB_EPStartXfer+0xc48>
 8017ae0:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8017ae4:	3301      	adds	r3, #1
 8017ae6:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8017aea:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8017aee:	b29b      	uxth	r3, r3
 8017af0:	029b      	lsls	r3, r3, #10
 8017af2:	b29a      	uxth	r2, r3
 8017af4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8017af8:	801a      	strh	r2, [r3, #0]
 8017afa:	e025      	b.n	8017b48 <USB_EPStartXfer+0xca6>
 8017afc:	463b      	mov	r3, r7
 8017afe:	681b      	ldr	r3, [r3, #0]
 8017b00:	785b      	ldrb	r3, [r3, #1]
 8017b02:	2b01      	cmp	r3, #1
 8017b04:	d120      	bne.n	8017b48 <USB_EPStartXfer+0xca6>
 8017b06:	1d3b      	adds	r3, r7, #4
 8017b08:	681b      	ldr	r3, [r3, #0]
 8017b0a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8017b0e:	1d3b      	adds	r3, r7, #4
 8017b10:	681b      	ldr	r3, [r3, #0]
 8017b12:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017b16:	b29b      	uxth	r3, r3
 8017b18:	461a      	mov	r2, r3
 8017b1a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017b1e:	4413      	add	r3, r2
 8017b20:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8017b24:	463b      	mov	r3, r7
 8017b26:	681b      	ldr	r3, [r3, #0]
 8017b28:	781b      	ldrb	r3, [r3, #0]
 8017b2a:	00da      	lsls	r2, r3, #3
 8017b2c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8017b30:	4413      	add	r3, r2
 8017b32:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017b36:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8017b3a:	463b      	mov	r3, r7
 8017b3c:	681b      	ldr	r3, [r3, #0]
 8017b3e:	691b      	ldr	r3, [r3, #16]
 8017b40:	b29a      	uxth	r2, r3
 8017b42:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8017b46:	801a      	strh	r2, [r3, #0]
 8017b48:	1d3b      	adds	r3, r7, #4
 8017b4a:	681b      	ldr	r3, [r3, #0]
 8017b4c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8017b50:	463b      	mov	r3, r7
 8017b52:	681b      	ldr	r3, [r3, #0]
 8017b54:	785b      	ldrb	r3, [r3, #1]
 8017b56:	2b00      	cmp	r3, #0
 8017b58:	d175      	bne.n	8017c46 <USB_EPStartXfer+0xda4>
 8017b5a:	1d3b      	adds	r3, r7, #4
 8017b5c:	681b      	ldr	r3, [r3, #0]
 8017b5e:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8017b62:	1d3b      	adds	r3, r7, #4
 8017b64:	681b      	ldr	r3, [r3, #0]
 8017b66:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017b6a:	b29b      	uxth	r3, r3
 8017b6c:	461a      	mov	r2, r3
 8017b6e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017b72:	4413      	add	r3, r2
 8017b74:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8017b78:	463b      	mov	r3, r7
 8017b7a:	681b      	ldr	r3, [r3, #0]
 8017b7c:	781b      	ldrb	r3, [r3, #0]
 8017b7e:	00da      	lsls	r2, r3, #3
 8017b80:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017b84:	4413      	add	r3, r2
 8017b86:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017b8a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8017b8e:	463b      	mov	r3, r7
 8017b90:	681b      	ldr	r3, [r3, #0]
 8017b92:	691b      	ldr	r3, [r3, #16]
 8017b94:	2b3e      	cmp	r3, #62	; 0x3e
 8017b96:	d91f      	bls.n	8017bd8 <USB_EPStartXfer+0xd36>
 8017b98:	463b      	mov	r3, r7
 8017b9a:	681b      	ldr	r3, [r3, #0]
 8017b9c:	691b      	ldr	r3, [r3, #16]
 8017b9e:	095b      	lsrs	r3, r3, #5
 8017ba0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8017ba4:	463b      	mov	r3, r7
 8017ba6:	681b      	ldr	r3, [r3, #0]
 8017ba8:	691b      	ldr	r3, [r3, #16]
 8017baa:	f003 031f 	and.w	r3, r3, #31
 8017bae:	2b00      	cmp	r3, #0
 8017bb0:	d104      	bne.n	8017bbc <USB_EPStartXfer+0xd1a>
 8017bb2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017bb6:	3b01      	subs	r3, #1
 8017bb8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8017bbc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017bc0:	b29b      	uxth	r3, r3
 8017bc2:	029b      	lsls	r3, r3, #10
 8017bc4:	b29b      	uxth	r3, r3
 8017bc6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017bca:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017bce:	b29a      	uxth	r2, r3
 8017bd0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017bd4:	801a      	strh	r2, [r3, #0]
 8017bd6:	e058      	b.n	8017c8a <USB_EPStartXfer+0xde8>
 8017bd8:	463b      	mov	r3, r7
 8017bda:	681b      	ldr	r3, [r3, #0]
 8017bdc:	691b      	ldr	r3, [r3, #16]
 8017bde:	2b00      	cmp	r3, #0
 8017be0:	d116      	bne.n	8017c10 <USB_EPStartXfer+0xd6e>
 8017be2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017be6:	881b      	ldrh	r3, [r3, #0]
 8017be8:	b29b      	uxth	r3, r3
 8017bea:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017bee:	b29a      	uxth	r2, r3
 8017bf0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017bf4:	801a      	strh	r2, [r3, #0]
 8017bf6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017bfa:	881b      	ldrh	r3, [r3, #0]
 8017bfc:	b29b      	uxth	r3, r3
 8017bfe:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017c02:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017c06:	b29a      	uxth	r2, r3
 8017c08:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017c0c:	801a      	strh	r2, [r3, #0]
 8017c0e:	e03c      	b.n	8017c8a <USB_EPStartXfer+0xde8>
 8017c10:	463b      	mov	r3, r7
 8017c12:	681b      	ldr	r3, [r3, #0]
 8017c14:	691b      	ldr	r3, [r3, #16]
 8017c16:	085b      	lsrs	r3, r3, #1
 8017c18:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8017c1c:	463b      	mov	r3, r7
 8017c1e:	681b      	ldr	r3, [r3, #0]
 8017c20:	691b      	ldr	r3, [r3, #16]
 8017c22:	f003 0301 	and.w	r3, r3, #1
 8017c26:	2b00      	cmp	r3, #0
 8017c28:	d004      	beq.n	8017c34 <USB_EPStartXfer+0xd92>
 8017c2a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017c2e:	3301      	adds	r3, #1
 8017c30:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8017c34:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8017c38:	b29b      	uxth	r3, r3
 8017c3a:	029b      	lsls	r3, r3, #10
 8017c3c:	b29a      	uxth	r2, r3
 8017c3e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017c42:	801a      	strh	r2, [r3, #0]
 8017c44:	e021      	b.n	8017c8a <USB_EPStartXfer+0xde8>
 8017c46:	463b      	mov	r3, r7
 8017c48:	681b      	ldr	r3, [r3, #0]
 8017c4a:	785b      	ldrb	r3, [r3, #1]
 8017c4c:	2b01      	cmp	r3, #1
 8017c4e:	d11c      	bne.n	8017c8a <USB_EPStartXfer+0xde8>
 8017c50:	1d3b      	adds	r3, r7, #4
 8017c52:	681b      	ldr	r3, [r3, #0]
 8017c54:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017c58:	b29b      	uxth	r3, r3
 8017c5a:	461a      	mov	r2, r3
 8017c5c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017c60:	4413      	add	r3, r2
 8017c62:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8017c66:	463b      	mov	r3, r7
 8017c68:	681b      	ldr	r3, [r3, #0]
 8017c6a:	781b      	ldrb	r3, [r3, #0]
 8017c6c:	00da      	lsls	r2, r3, #3
 8017c6e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017c72:	4413      	add	r3, r2
 8017c74:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017c78:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 8017c7c:	463b      	mov	r3, r7
 8017c7e:	681b      	ldr	r3, [r3, #0]
 8017c80:	691b      	ldr	r3, [r3, #16]
 8017c82:	b29a      	uxth	r2, r3
 8017c84:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8017c88:	801a      	strh	r2, [r3, #0]

        /* Coming from ISR */
        if (ep->xfer_count != 0U)
 8017c8a:	463b      	mov	r3, r7
 8017c8c:	681b      	ldr	r3, [r3, #0]
 8017c8e:	69db      	ldr	r3, [r3, #28]
 8017c90:	2b00      	cmp	r3, #0
 8017c92:	f000 81a4 	beq.w	8017fde <USB_EPStartXfer+0x113c>
        {
          /* update last value to check if there is blocking state */
          wEPVal = PCD_GET_ENDPOINT(USBx, ep->num);
 8017c96:	1d3b      	adds	r3, r7, #4
 8017c98:	681a      	ldr	r2, [r3, #0]
 8017c9a:	463b      	mov	r3, r7
 8017c9c:	681b      	ldr	r3, [r3, #0]
 8017c9e:	781b      	ldrb	r3, [r3, #0]
 8017ca0:	009b      	lsls	r3, r3, #2
 8017ca2:	4413      	add	r3, r2
 8017ca4:	881b      	ldrh	r3, [r3, #0]
 8017ca6:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

          /*Blocking State */
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8017caa:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8017cae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8017cb2:	2b00      	cmp	r3, #0
 8017cb4:	d005      	beq.n	8017cc2 <USB_EPStartXfer+0xe20>
 8017cb6:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8017cba:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017cbe:	2b00      	cmp	r3, #0
 8017cc0:	d10d      	bne.n	8017cde <USB_EPStartXfer+0xe3c>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 8017cc2:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8017cc6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 8017cca:	2b00      	cmp	r3, #0
 8017ccc:	f040 8187 	bne.w	8017fde <USB_EPStartXfer+0x113c>
              (((wEPVal & USB_EP_DTOG_RX) == 0U) && ((wEPVal & USB_EP_DTOG_TX) == 0U)))
 8017cd0:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 8017cd4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8017cd8:	2b00      	cmp	r3, #0
 8017cda:	f040 8180 	bne.w	8017fde <USB_EPStartXfer+0x113c>
          {
            PCD_FREE_USER_BUFFER(USBx, ep->num, 0U);
 8017cde:	1d3b      	adds	r3, r7, #4
 8017ce0:	681a      	ldr	r2, [r3, #0]
 8017ce2:	463b      	mov	r3, r7
 8017ce4:	681b      	ldr	r3, [r3, #0]
 8017ce6:	781b      	ldrb	r3, [r3, #0]
 8017ce8:	009b      	lsls	r3, r3, #2
 8017cea:	4413      	add	r3, r2
 8017cec:	881b      	ldrh	r3, [r3, #0]
 8017cee:	b29b      	uxth	r3, r3
 8017cf0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8017cf4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8017cf8:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
 8017cfc:	1d3b      	adds	r3, r7, #4
 8017cfe:	681a      	ldr	r2, [r3, #0]
 8017d00:	463b      	mov	r3, r7
 8017d02:	681b      	ldr	r3, [r3, #0]
 8017d04:	781b      	ldrb	r3, [r3, #0]
 8017d06:	009b      	lsls	r3, r3, #2
 8017d08:	441a      	add	r2, r3
 8017d0a:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
 8017d0e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8017d12:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8017d16:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8017d1a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8017d1e:	b29b      	uxth	r3, r3
 8017d20:	8013      	strh	r3, [r2, #0]
 8017d22:	e15c      	b.n	8017fde <USB_EPStartXfer+0x113c>
          }
        }
      }
      /* iso out double */
      else if (ep->type == EP_TYPE_ISOC)
 8017d24:	463b      	mov	r3, r7
 8017d26:	681b      	ldr	r3, [r3, #0]
 8017d28:	78db      	ldrb	r3, [r3, #3]
 8017d2a:	2b01      	cmp	r3, #1
 8017d2c:	f040 8155 	bne.w	8017fda <USB_EPStartXfer+0x1138>
      {
        /* Multi packet transfer */
        if (ep->xfer_len > ep->maxpacket)
 8017d30:	463b      	mov	r3, r7
 8017d32:	681b      	ldr	r3, [r3, #0]
 8017d34:	699a      	ldr	r2, [r3, #24]
 8017d36:	463b      	mov	r3, r7
 8017d38:	681b      	ldr	r3, [r3, #0]
 8017d3a:	691b      	ldr	r3, [r3, #16]
 8017d3c:	429a      	cmp	r2, r3
 8017d3e:	d90e      	bls.n	8017d5e <USB_EPStartXfer+0xebc>
        {
          len = ep->maxpacket;
 8017d40:	463b      	mov	r3, r7
 8017d42:	681b      	ldr	r3, [r3, #0]
 8017d44:	691b      	ldr	r3, [r3, #16]
 8017d46:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
          ep->xfer_len -= len;
 8017d4a:	463b      	mov	r3, r7
 8017d4c:	681b      	ldr	r3, [r3, #0]
 8017d4e:	699a      	ldr	r2, [r3, #24]
 8017d50:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017d54:	1ad2      	subs	r2, r2, r3
 8017d56:	463b      	mov	r3, r7
 8017d58:	681b      	ldr	r3, [r3, #0]
 8017d5a:	619a      	str	r2, [r3, #24]
 8017d5c:	e008      	b.n	8017d70 <USB_EPStartXfer+0xece>
        }
        else
        {
          len = ep->xfer_len;
 8017d5e:	463b      	mov	r3, r7
 8017d60:	681b      	ldr	r3, [r3, #0]
 8017d62:	699b      	ldr	r3, [r3, #24]
 8017d64:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
          ep->xfer_len = 0U;
 8017d68:	463b      	mov	r3, r7
 8017d6a:	681b      	ldr	r3, [r3, #0]
 8017d6c:	2200      	movs	r2, #0
 8017d6e:	619a      	str	r2, [r3, #24]
        }
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8017d70:	463b      	mov	r3, r7
 8017d72:	681b      	ldr	r3, [r3, #0]
 8017d74:	785b      	ldrb	r3, [r3, #1]
 8017d76:	2b00      	cmp	r3, #0
 8017d78:	d16f      	bne.n	8017e5a <USB_EPStartXfer+0xfb8>
 8017d7a:	1d3b      	adds	r3, r7, #4
 8017d7c:	681b      	ldr	r3, [r3, #0]
 8017d7e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8017d82:	1d3b      	adds	r3, r7, #4
 8017d84:	681b      	ldr	r3, [r3, #0]
 8017d86:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017d8a:	b29b      	uxth	r3, r3
 8017d8c:	461a      	mov	r2, r3
 8017d8e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8017d92:	4413      	add	r3, r2
 8017d94:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8017d98:	463b      	mov	r3, r7
 8017d9a:	681b      	ldr	r3, [r3, #0]
 8017d9c:	781b      	ldrb	r3, [r3, #0]
 8017d9e:	00da      	lsls	r2, r3, #3
 8017da0:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8017da4:	4413      	add	r3, r2
 8017da6:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017daa:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8017dae:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017db2:	2b3e      	cmp	r3, #62	; 0x3e
 8017db4:	d91d      	bls.n	8017df2 <USB_EPStartXfer+0xf50>
 8017db6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017dba:	095b      	lsrs	r3, r3, #5
 8017dbc:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8017dc0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017dc4:	f003 031f 	and.w	r3, r3, #31
 8017dc8:	2b00      	cmp	r3, #0
 8017dca:	d104      	bne.n	8017dd6 <USB_EPStartXfer+0xf34>
 8017dcc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8017dd0:	3b01      	subs	r3, #1
 8017dd2:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8017dd6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8017dda:	b29b      	uxth	r3, r3
 8017ddc:	029b      	lsls	r3, r3, #10
 8017dde:	b29b      	uxth	r3, r3
 8017de0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017de4:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017de8:	b29a      	uxth	r2, r3
 8017dea:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017dee:	801a      	strh	r2, [r3, #0]
 8017df0:	e058      	b.n	8017ea4 <USB_EPStartXfer+0x1002>
 8017df2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017df6:	2b00      	cmp	r3, #0
 8017df8:	d116      	bne.n	8017e28 <USB_EPStartXfer+0xf86>
 8017dfa:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017dfe:	881b      	ldrh	r3, [r3, #0]
 8017e00:	b29b      	uxth	r3, r3
 8017e02:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017e06:	b29a      	uxth	r2, r3
 8017e08:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017e0c:	801a      	strh	r2, [r3, #0]
 8017e0e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017e12:	881b      	ldrh	r3, [r3, #0]
 8017e14:	b29b      	uxth	r3, r3
 8017e16:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017e1a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017e1e:	b29a      	uxth	r2, r3
 8017e20:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017e24:	801a      	strh	r2, [r3, #0]
 8017e26:	e03d      	b.n	8017ea4 <USB_EPStartXfer+0x1002>
 8017e28:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017e2c:	085b      	lsrs	r3, r3, #1
 8017e2e:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8017e32:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017e36:	f003 0301 	and.w	r3, r3, #1
 8017e3a:	2b00      	cmp	r3, #0
 8017e3c:	d004      	beq.n	8017e48 <USB_EPStartXfer+0xfa6>
 8017e3e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8017e42:	3301      	adds	r3, #1
 8017e44:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8017e48:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8017e4c:	b29b      	uxth	r3, r3
 8017e4e:	029b      	lsls	r3, r3, #10
 8017e50:	b29a      	uxth	r2, r3
 8017e52:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017e56:	801a      	strh	r2, [r3, #0]
 8017e58:	e024      	b.n	8017ea4 <USB_EPStartXfer+0x1002>
 8017e5a:	463b      	mov	r3, r7
 8017e5c:	681b      	ldr	r3, [r3, #0]
 8017e5e:	785b      	ldrb	r3, [r3, #1]
 8017e60:	2b01      	cmp	r3, #1
 8017e62:	d11f      	bne.n	8017ea4 <USB_EPStartXfer+0x1002>
 8017e64:	1d3b      	adds	r3, r7, #4
 8017e66:	681b      	ldr	r3, [r3, #0]
 8017e68:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8017e6c:	1d3b      	adds	r3, r7, #4
 8017e6e:	681b      	ldr	r3, [r3, #0]
 8017e70:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017e74:	b29b      	uxth	r3, r3
 8017e76:	461a      	mov	r2, r3
 8017e78:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017e7c:	4413      	add	r3, r2
 8017e7e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8017e82:	463b      	mov	r3, r7
 8017e84:	681b      	ldr	r3, [r3, #0]
 8017e86:	781b      	ldrb	r3, [r3, #0]
 8017e88:	00da      	lsls	r2, r3, #3
 8017e8a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017e8e:	4413      	add	r3, r2
 8017e90:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8017e94:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8017e98:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017e9c:	b29a      	uxth	r2, r3
 8017e9e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8017ea2:	801a      	strh	r2, [r3, #0]
 8017ea4:	1d3b      	adds	r3, r7, #4
 8017ea6:	681b      	ldr	r3, [r3, #0]
 8017ea8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8017eac:	463b      	mov	r3, r7
 8017eae:	681b      	ldr	r3, [r3, #0]
 8017eb0:	785b      	ldrb	r3, [r3, #1]
 8017eb2:	2b00      	cmp	r3, #0
 8017eb4:	d16f      	bne.n	8017f96 <USB_EPStartXfer+0x10f4>
 8017eb6:	1d3b      	adds	r3, r7, #4
 8017eb8:	681b      	ldr	r3, [r3, #0]
 8017eba:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8017ebe:	1d3b      	adds	r3, r7, #4
 8017ec0:	681b      	ldr	r3, [r3, #0]
 8017ec2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017ec6:	b29b      	uxth	r3, r3
 8017ec8:	461a      	mov	r2, r3
 8017eca:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8017ece:	4413      	add	r3, r2
 8017ed0:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8017ed4:	463b      	mov	r3, r7
 8017ed6:	681b      	ldr	r3, [r3, #0]
 8017ed8:	781b      	ldrb	r3, [r3, #0]
 8017eda:	00da      	lsls	r2, r3, #3
 8017edc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8017ee0:	4413      	add	r3, r2
 8017ee2:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017ee6:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8017eea:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017eee:	2b3e      	cmp	r3, #62	; 0x3e
 8017ef0:	d91d      	bls.n	8017f2e <USB_EPStartXfer+0x108c>
 8017ef2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017ef6:	095b      	lsrs	r3, r3, #5
 8017ef8:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8017efc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017f00:	f003 031f 	and.w	r3, r3, #31
 8017f04:	2b00      	cmp	r3, #0
 8017f06:	d104      	bne.n	8017f12 <USB_EPStartXfer+0x1070>
 8017f08:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8017f0c:	3b01      	subs	r3, #1
 8017f0e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8017f12:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8017f16:	b29b      	uxth	r3, r3
 8017f18:	029b      	lsls	r3, r3, #10
 8017f1a:	b29b      	uxth	r3, r3
 8017f1c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017f20:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017f24:	b29a      	uxth	r2, r3
 8017f26:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f2a:	801a      	strh	r2, [r3, #0]
 8017f2c:	e057      	b.n	8017fde <USB_EPStartXfer+0x113c>
 8017f2e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017f32:	2b00      	cmp	r3, #0
 8017f34:	d116      	bne.n	8017f64 <USB_EPStartXfer+0x10c2>
 8017f36:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f3a:	881b      	ldrh	r3, [r3, #0]
 8017f3c:	b29b      	uxth	r3, r3
 8017f3e:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8017f42:	b29a      	uxth	r2, r3
 8017f44:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f48:	801a      	strh	r2, [r3, #0]
 8017f4a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f4e:	881b      	ldrh	r3, [r3, #0]
 8017f50:	b29b      	uxth	r3, r3
 8017f52:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8017f56:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8017f5a:	b29a      	uxth	r2, r3
 8017f5c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f60:	801a      	strh	r2, [r3, #0]
 8017f62:	e03c      	b.n	8017fde <USB_EPStartXfer+0x113c>
 8017f64:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017f68:	085b      	lsrs	r3, r3, #1
 8017f6a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8017f6e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017f72:	f003 0301 	and.w	r3, r3, #1
 8017f76:	2b00      	cmp	r3, #0
 8017f78:	d004      	beq.n	8017f84 <USB_EPStartXfer+0x10e2>
 8017f7a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8017f7e:	3301      	adds	r3, #1
 8017f80:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8017f84:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8017f88:	b29b      	uxth	r3, r3
 8017f8a:	029b      	lsls	r3, r3, #10
 8017f8c:	b29a      	uxth	r2, r3
 8017f8e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8017f92:	801a      	strh	r2, [r3, #0]
 8017f94:	e023      	b.n	8017fde <USB_EPStartXfer+0x113c>
 8017f96:	463b      	mov	r3, r7
 8017f98:	681b      	ldr	r3, [r3, #0]
 8017f9a:	785b      	ldrb	r3, [r3, #1]
 8017f9c:	2b01      	cmp	r3, #1
 8017f9e:	d11e      	bne.n	8017fde <USB_EPStartXfer+0x113c>
 8017fa0:	1d3b      	adds	r3, r7, #4
 8017fa2:	681b      	ldr	r3, [r3, #0]
 8017fa4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8017fa8:	b29b      	uxth	r3, r3
 8017faa:	461a      	mov	r2, r3
 8017fac:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8017fb0:	4413      	add	r3, r2
 8017fb2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8017fb6:	463b      	mov	r3, r7
 8017fb8:	681b      	ldr	r3, [r3, #0]
 8017fba:	781b      	ldrb	r3, [r3, #0]
 8017fbc:	00da      	lsls	r2, r3, #3
 8017fbe:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8017fc2:	4413      	add	r3, r2
 8017fc4:	f203 4306 	addw	r3, r3, #1030	; 0x406
 8017fc8:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8017fcc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8017fd0:	b29a      	uxth	r2, r3
 8017fd2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8017fd6:	801a      	strh	r2, [r3, #0]
 8017fd8:	e001      	b.n	8017fde <USB_EPStartXfer+0x113c>
      }
      else
      {
        return HAL_ERROR;
 8017fda:	2301      	movs	r3, #1
 8017fdc:	e02e      	b.n	801803c <USB_EPStartXfer+0x119a>
      }
    }
#endif /* (USE_USB_DOUBLE_BUFFER == 1U) */

    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8017fde:	1d3b      	adds	r3, r7, #4
 8017fe0:	681a      	ldr	r2, [r3, #0]
 8017fe2:	463b      	mov	r3, r7
 8017fe4:	681b      	ldr	r3, [r3, #0]
 8017fe6:	781b      	ldrb	r3, [r3, #0]
 8017fe8:	009b      	lsls	r3, r3, #2
 8017fea:	4413      	add	r3, r2
 8017fec:	881b      	ldrh	r3, [r3, #0]
 8017fee:	b29b      	uxth	r3, r3
 8017ff0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8017ff4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8017ff8:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 8017ffc:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 8018000:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8018004:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 8018008:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 801800c:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8018010:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
 8018014:	1d3b      	adds	r3, r7, #4
 8018016:	681a      	ldr	r2, [r3, #0]
 8018018:	463b      	mov	r3, r7
 801801a:	681b      	ldr	r3, [r3, #0]
 801801c:	781b      	ldrb	r3, [r3, #0]
 801801e:	009b      	lsls	r3, r3, #2
 8018020:	441a      	add	r2, r3
 8018022:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 8018026:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801802a:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801802e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8018032:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8018036:	b29b      	uxth	r3, r3
 8018038:	8013      	strh	r3, [r2, #0]
  }

  return HAL_OK;
 801803a:	2300      	movs	r3, #0
}
 801803c:	4618      	mov	r0, r3
 801803e:	f507 7784 	add.w	r7, r7, #264	; 0x108
 8018042:	46bd      	mov	sp, r7
 8018044:	bd80      	pop	{r7, pc}

08018046 <USB_EPSetStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8018046:	b480      	push	{r7}
 8018048:	b085      	sub	sp, #20
 801804a:	af00      	add	r7, sp, #0
 801804c:	6078      	str	r0, [r7, #4]
 801804e:	6039      	str	r1, [r7, #0]
  if (ep->is_in != 0U)
 8018050:	683b      	ldr	r3, [r7, #0]
 8018052:	785b      	ldrb	r3, [r3, #1]
 8018054:	2b00      	cmp	r3, #0
 8018056:	d020      	beq.n	801809a <USB_EPSetStall+0x54>
  {
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 8018058:	687a      	ldr	r2, [r7, #4]
 801805a:	683b      	ldr	r3, [r7, #0]
 801805c:	781b      	ldrb	r3, [r3, #0]
 801805e:	009b      	lsls	r3, r3, #2
 8018060:	4413      	add	r3, r2
 8018062:	881b      	ldrh	r3, [r3, #0]
 8018064:	b29b      	uxth	r3, r3
 8018066:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801806a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801806e:	81bb      	strh	r3, [r7, #12]
 8018070:	89bb      	ldrh	r3, [r7, #12]
 8018072:	f083 0310 	eor.w	r3, r3, #16
 8018076:	81bb      	strh	r3, [r7, #12]
 8018078:	687a      	ldr	r2, [r7, #4]
 801807a:	683b      	ldr	r3, [r7, #0]
 801807c:	781b      	ldrb	r3, [r3, #0]
 801807e:	009b      	lsls	r3, r3, #2
 8018080:	441a      	add	r2, r3
 8018082:	89bb      	ldrh	r3, [r7, #12]
 8018084:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8018088:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801808c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8018090:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8018094:	b29b      	uxth	r3, r3
 8018096:	8013      	strh	r3, [r2, #0]
 8018098:	e01f      	b.n	80180da <USB_EPSetStall+0x94>
  }
  else
  {
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 801809a:	687a      	ldr	r2, [r7, #4]
 801809c:	683b      	ldr	r3, [r7, #0]
 801809e:	781b      	ldrb	r3, [r3, #0]
 80180a0:	009b      	lsls	r3, r3, #2
 80180a2:	4413      	add	r3, r2
 80180a4:	881b      	ldrh	r3, [r3, #0]
 80180a6:	b29b      	uxth	r3, r3
 80180a8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80180ac:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80180b0:	81fb      	strh	r3, [r7, #14]
 80180b2:	89fb      	ldrh	r3, [r7, #14]
 80180b4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80180b8:	81fb      	strh	r3, [r7, #14]
 80180ba:	687a      	ldr	r2, [r7, #4]
 80180bc:	683b      	ldr	r3, [r7, #0]
 80180be:	781b      	ldrb	r3, [r3, #0]
 80180c0:	009b      	lsls	r3, r3, #2
 80180c2:	441a      	add	r2, r3
 80180c4:	89fb      	ldrh	r3, [r7, #14]
 80180c6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80180ca:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80180ce:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80180d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80180d6:	b29b      	uxth	r3, r3
 80180d8:	8013      	strh	r3, [r2, #0]
  }

  return HAL_OK;
 80180da:	2300      	movs	r3, #0
}
 80180dc:	4618      	mov	r0, r3
 80180de:	3714      	adds	r7, #20
 80180e0:	46bd      	mov	sp, r7
 80180e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80180e6:	4770      	bx	lr

080180e8 <USB_EPClearStall>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80180e8:	b480      	push	{r7}
 80180ea:	b087      	sub	sp, #28
 80180ec:	af00      	add	r7, sp, #0
 80180ee:	6078      	str	r0, [r7, #4]
 80180f0:	6039      	str	r1, [r7, #0]
  if (ep->doublebuffer == 0U)
 80180f2:	683b      	ldr	r3, [r7, #0]
 80180f4:	7b1b      	ldrb	r3, [r3, #12]
 80180f6:	2b00      	cmp	r3, #0
 80180f8:	f040 809d 	bne.w	8018236 <USB_EPClearStall+0x14e>
  {
    if (ep->is_in != 0U)
 80180fc:	683b      	ldr	r3, [r7, #0]
 80180fe:	785b      	ldrb	r3, [r3, #1]
 8018100:	2b00      	cmp	r3, #0
 8018102:	d04c      	beq.n	801819e <USB_EPClearStall+0xb6>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8018104:	687a      	ldr	r2, [r7, #4]
 8018106:	683b      	ldr	r3, [r7, #0]
 8018108:	781b      	ldrb	r3, [r3, #0]
 801810a:	009b      	lsls	r3, r3, #2
 801810c:	4413      	add	r3, r2
 801810e:	881b      	ldrh	r3, [r3, #0]
 8018110:	823b      	strh	r3, [r7, #16]
 8018112:	8a3b      	ldrh	r3, [r7, #16]
 8018114:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018118:	2b00      	cmp	r3, #0
 801811a:	d01b      	beq.n	8018154 <USB_EPClearStall+0x6c>
 801811c:	687a      	ldr	r2, [r7, #4]
 801811e:	683b      	ldr	r3, [r7, #0]
 8018120:	781b      	ldrb	r3, [r3, #0]
 8018122:	009b      	lsls	r3, r3, #2
 8018124:	4413      	add	r3, r2
 8018126:	881b      	ldrh	r3, [r3, #0]
 8018128:	b29b      	uxth	r3, r3
 801812a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801812e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8018132:	81fb      	strh	r3, [r7, #14]
 8018134:	687a      	ldr	r2, [r7, #4]
 8018136:	683b      	ldr	r3, [r7, #0]
 8018138:	781b      	ldrb	r3, [r3, #0]
 801813a:	009b      	lsls	r3, r3, #2
 801813c:	441a      	add	r2, r3
 801813e:	89fb      	ldrh	r3, [r7, #14]
 8018140:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8018144:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8018148:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801814c:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8018150:	b29b      	uxth	r3, r3
 8018152:	8013      	strh	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8018154:	683b      	ldr	r3, [r7, #0]
 8018156:	78db      	ldrb	r3, [r3, #3]
 8018158:	2b01      	cmp	r3, #1
 801815a:	d06c      	beq.n	8018236 <USB_EPClearStall+0x14e>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 801815c:	687a      	ldr	r2, [r7, #4]
 801815e:	683b      	ldr	r3, [r7, #0]
 8018160:	781b      	ldrb	r3, [r3, #0]
 8018162:	009b      	lsls	r3, r3, #2
 8018164:	4413      	add	r3, r2
 8018166:	881b      	ldrh	r3, [r3, #0]
 8018168:	b29b      	uxth	r3, r3
 801816a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801816e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8018172:	81bb      	strh	r3, [r7, #12]
 8018174:	89bb      	ldrh	r3, [r7, #12]
 8018176:	f083 0320 	eor.w	r3, r3, #32
 801817a:	81bb      	strh	r3, [r7, #12]
 801817c:	687a      	ldr	r2, [r7, #4]
 801817e:	683b      	ldr	r3, [r7, #0]
 8018180:	781b      	ldrb	r3, [r3, #0]
 8018182:	009b      	lsls	r3, r3, #2
 8018184:	441a      	add	r2, r3
 8018186:	89bb      	ldrh	r3, [r7, #12]
 8018188:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 801818c:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8018190:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8018194:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8018198:	b29b      	uxth	r3, r3
 801819a:	8013      	strh	r3, [r2, #0]
 801819c:	e04b      	b.n	8018236 <USB_EPClearStall+0x14e>
      }
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 801819e:	687a      	ldr	r2, [r7, #4]
 80181a0:	683b      	ldr	r3, [r7, #0]
 80181a2:	781b      	ldrb	r3, [r3, #0]
 80181a4:	009b      	lsls	r3, r3, #2
 80181a6:	4413      	add	r3, r2
 80181a8:	881b      	ldrh	r3, [r3, #0]
 80181aa:	82fb      	strh	r3, [r7, #22]
 80181ac:	8afb      	ldrh	r3, [r7, #22]
 80181ae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80181b2:	2b00      	cmp	r3, #0
 80181b4:	d01b      	beq.n	80181ee <USB_EPClearStall+0x106>
 80181b6:	687a      	ldr	r2, [r7, #4]
 80181b8:	683b      	ldr	r3, [r7, #0]
 80181ba:	781b      	ldrb	r3, [r3, #0]
 80181bc:	009b      	lsls	r3, r3, #2
 80181be:	4413      	add	r3, r2
 80181c0:	881b      	ldrh	r3, [r3, #0]
 80181c2:	b29b      	uxth	r3, r3
 80181c4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80181c8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80181cc:	82bb      	strh	r3, [r7, #20]
 80181ce:	687a      	ldr	r2, [r7, #4]
 80181d0:	683b      	ldr	r3, [r7, #0]
 80181d2:	781b      	ldrb	r3, [r3, #0]
 80181d4:	009b      	lsls	r3, r3, #2
 80181d6:	441a      	add	r2, r3
 80181d8:	8abb      	ldrh	r3, [r7, #20]
 80181da:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80181de:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80181e2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80181e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80181ea:	b29b      	uxth	r3, r3
 80181ec:	8013      	strh	r3, [r2, #0]

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80181ee:	687a      	ldr	r2, [r7, #4]
 80181f0:	683b      	ldr	r3, [r7, #0]
 80181f2:	781b      	ldrb	r3, [r3, #0]
 80181f4:	009b      	lsls	r3, r3, #2
 80181f6:	4413      	add	r3, r2
 80181f8:	881b      	ldrh	r3, [r3, #0]
 80181fa:	b29b      	uxth	r3, r3
 80181fc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8018200:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8018204:	827b      	strh	r3, [r7, #18]
 8018206:	8a7b      	ldrh	r3, [r7, #18]
 8018208:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 801820c:	827b      	strh	r3, [r7, #18]
 801820e:	8a7b      	ldrh	r3, [r7, #18]
 8018210:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8018214:	827b      	strh	r3, [r7, #18]
 8018216:	687a      	ldr	r2, [r7, #4]
 8018218:	683b      	ldr	r3, [r7, #0]
 801821a:	781b      	ldrb	r3, [r3, #0]
 801821c:	009b      	lsls	r3, r3, #2
 801821e:	441a      	add	r2, r3
 8018220:	8a7b      	ldrh	r3, [r7, #18]
 8018222:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8018226:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 801822a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801822e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8018232:	b29b      	uxth	r3, r3
 8018234:	8013      	strh	r3, [r2, #0]
    }
  }

  return HAL_OK;
 8018236:	2300      	movs	r3, #0
}
 8018238:	4618      	mov	r0, r3
 801823a:	371c      	adds	r7, #28
 801823c:	46bd      	mov	sp, r7
 801823e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018242:	4770      	bx	lr

08018244 <USB_SetDevAddress>:
  * @param  address new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_TypeDef *USBx, uint8_t address)
{
 8018244:	b480      	push	{r7}
 8018246:	b083      	sub	sp, #12
 8018248:	af00      	add	r7, sp, #0
 801824a:	6078      	str	r0, [r7, #4]
 801824c:	460b      	mov	r3, r1
 801824e:	70fb      	strb	r3, [r7, #3]
  if (address == 0U)
 8018250:	78fb      	ldrb	r3, [r7, #3]
 8018252:	2b00      	cmp	r3, #0
 8018254:	d103      	bne.n	801825e <USB_SetDevAddress+0x1a>
  {
    /* set device address and enable function */
    USBx->DADDR = (uint16_t)USB_DADDR_EF;
 8018256:	687b      	ldr	r3, [r7, #4]
 8018258:	2280      	movs	r2, #128	; 0x80
 801825a:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 801825e:	2300      	movs	r3, #0
}
 8018260:	4618      	mov	r0, r3
 8018262:	370c      	adds	r7, #12
 8018264:	46bd      	mov	sp, r7
 8018266:	f85d 7b04 	ldr.w	r7, [sp], #4
 801826a:	4770      	bx	lr

0801826c <USB_DevConnect>:
  * @brief  USB_DevConnect Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect(USB_TypeDef *USBx)
{
 801826c:	b480      	push	{r7}
 801826e:	b083      	sub	sp, #12
 8018270:	af00      	add	r7, sp, #0
 8018272:	6078      	str	r0, [r7, #4]
  /* Enabling DP Pull-UP bit to Connect internal PU resistor on USB DP line */
  USBx->BCDR |= (uint16_t)USB_BCDR_DPPU;
 8018274:	687b      	ldr	r3, [r7, #4]
 8018276:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801827a:	b29b      	uxth	r3, r3
 801827c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8018280:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8018284:	b29a      	uxth	r2, r3
 8018286:	687b      	ldr	r3, [r7, #4]
 8018288:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

  return HAL_OK;
 801828c:	2300      	movs	r3, #0
}
 801828e:	4618      	mov	r0, r3
 8018290:	370c      	adds	r7, #12
 8018292:	46bd      	mov	sp, r7
 8018294:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018298:	4770      	bx	lr

0801829a <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts return the global USB interrupt status
  * @param  USBx Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts(USB_TypeDef *USBx)
{
 801829a:	b480      	push	{r7}
 801829c:	b085      	sub	sp, #20
 801829e:	af00      	add	r7, sp, #0
 80182a0:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->ISTR;
 80182a2:	687b      	ldr	r3, [r7, #4]
 80182a4:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80182a8:	b29b      	uxth	r3, r3
 80182aa:	60fb      	str	r3, [r7, #12]
  return tmpreg;
 80182ac:	68fb      	ldr	r3, [r7, #12]
}
 80182ae:	4618      	mov	r0, r3
 80182b0:	3714      	adds	r7, #20
 80182b2:	46bd      	mov	sp, r7
 80182b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80182b8:	4770      	bx	lr

080182ba <USB_WritePMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 80182ba:	b480      	push	{r7}
 80182bc:	b08d      	sub	sp, #52	; 0x34
 80182be:	af00      	add	r7, sp, #0
 80182c0:	60f8      	str	r0, [r7, #12]
 80182c2:	60b9      	str	r1, [r7, #8]
 80182c4:	4611      	mov	r1, r2
 80182c6:	461a      	mov	r2, r3
 80182c8:	460b      	mov	r3, r1
 80182ca:	80fb      	strh	r3, [r7, #6]
 80182cc:	4613      	mov	r3, r2
 80182ce:	80bb      	strh	r3, [r7, #4]
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 80182d0:	88bb      	ldrh	r3, [r7, #4]
 80182d2:	3301      	adds	r3, #1
 80182d4:	085b      	lsrs	r3, r3, #1
 80182d6:	623b      	str	r3, [r7, #32]
  uint32_t BaseAddr = (uint32_t)USBx;
 80182d8:	68fb      	ldr	r3, [r7, #12]
 80182da:	61fb      	str	r3, [r7, #28]
  uint32_t i;
  uint32_t temp1;
  uint32_t temp2;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 80182dc:	68bb      	ldr	r3, [r7, #8]
 80182de:	627b      	str	r3, [r7, #36]	; 0x24

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 80182e0:	88fa      	ldrh	r2, [r7, #6]
 80182e2:	69fb      	ldr	r3, [r7, #28]
 80182e4:	4413      	add	r3, r2
 80182e6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80182ea:	62bb      	str	r3, [r7, #40]	; 0x28

  for (i = n; i != 0U; i--)
 80182ec:	6a3b      	ldr	r3, [r7, #32]
 80182ee:	62fb      	str	r3, [r7, #44]	; 0x2c
 80182f0:	e01b      	b.n	801832a <USB_WritePMA+0x70>
  {
    temp1 = *pBuf;
 80182f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80182f4:	781b      	ldrb	r3, [r3, #0]
 80182f6:	61bb      	str	r3, [r7, #24]
    pBuf++;
 80182f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80182fa:	3301      	adds	r3, #1
 80182fc:	627b      	str	r3, [r7, #36]	; 0x24
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
 80182fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018300:	781b      	ldrb	r3, [r3, #0]
 8018302:	b29b      	uxth	r3, r3
 8018304:	021b      	lsls	r3, r3, #8
 8018306:	b29b      	uxth	r3, r3
 8018308:	461a      	mov	r2, r3
 801830a:	69bb      	ldr	r3, [r7, #24]
 801830c:	4313      	orrs	r3, r2
 801830e:	617b      	str	r3, [r7, #20]
    *pdwVal = (uint16_t)temp2;
 8018310:	697b      	ldr	r3, [r7, #20]
 8018312:	b29a      	uxth	r2, r3
 8018314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018316:	801a      	strh	r2, [r3, #0]
    pdwVal++;
 8018318:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801831a:	3302      	adds	r3, #2
 801831c:	62bb      	str	r3, [r7, #40]	; 0x28

#if PMA_ACCESS > 1U
    pdwVal++;
#endif /* PMA_ACCESS */

    pBuf++;
 801831e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018320:	3301      	adds	r3, #1
 8018322:	627b      	str	r3, [r7, #36]	; 0x24
  for (i = n; i != 0U; i--)
 8018324:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018326:	3b01      	subs	r3, #1
 8018328:	62fb      	str	r3, [r7, #44]	; 0x2c
 801832a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801832c:	2b00      	cmp	r3, #0
 801832e:	d1e0      	bne.n	80182f2 <USB_WritePMA+0x38>
  }
}
 8018330:	bf00      	nop
 8018332:	bf00      	nop
 8018334:	3734      	adds	r7, #52	; 0x34
 8018336:	46bd      	mov	sp, r7
 8018338:	f85d 7b04 	ldr.w	r7, [sp], #4
 801833c:	4770      	bx	lr

0801833e <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 801833e:	b480      	push	{r7}
 8018340:	b08b      	sub	sp, #44	; 0x2c
 8018342:	af00      	add	r7, sp, #0
 8018344:	60f8      	str	r0, [r7, #12]
 8018346:	60b9      	str	r1, [r7, #8]
 8018348:	4611      	mov	r1, r2
 801834a:	461a      	mov	r2, r3
 801834c:	460b      	mov	r3, r1
 801834e:	80fb      	strh	r3, [r7, #6]
 8018350:	4613      	mov	r3, r2
 8018352:	80bb      	strh	r3, [r7, #4]
  uint32_t n = (uint32_t)wNBytes >> 1;
 8018354:	88bb      	ldrh	r3, [r7, #4]
 8018356:	085b      	lsrs	r3, r3, #1
 8018358:	b29b      	uxth	r3, r3
 801835a:	61bb      	str	r3, [r7, #24]
  uint32_t BaseAddr = (uint32_t)USBx;
 801835c:	68fb      	ldr	r3, [r7, #12]
 801835e:	617b      	str	r3, [r7, #20]
  uint32_t i;
  uint32_t temp;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;
 8018360:	68bb      	ldr	r3, [r7, #8]
 8018362:	61fb      	str	r3, [r7, #28]

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 8018364:	88fa      	ldrh	r2, [r7, #6]
 8018366:	697b      	ldr	r3, [r7, #20]
 8018368:	4413      	add	r3, r2
 801836a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801836e:	623b      	str	r3, [r7, #32]

  for (i = n; i != 0U; i--)
 8018370:	69bb      	ldr	r3, [r7, #24]
 8018372:	627b      	str	r3, [r7, #36]	; 0x24
 8018374:	e018      	b.n	80183a8 <USB_ReadPMA+0x6a>
  {
    temp = *(__IO uint16_t *)pdwVal;
 8018376:	6a3b      	ldr	r3, [r7, #32]
 8018378:	881b      	ldrh	r3, [r3, #0]
 801837a:	b29b      	uxth	r3, r3
 801837c:	613b      	str	r3, [r7, #16]
    pdwVal++;
 801837e:	6a3b      	ldr	r3, [r7, #32]
 8018380:	3302      	adds	r3, #2
 8018382:	623b      	str	r3, [r7, #32]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 8018384:	693b      	ldr	r3, [r7, #16]
 8018386:	b2da      	uxtb	r2, r3
 8018388:	69fb      	ldr	r3, [r7, #28]
 801838a:	701a      	strb	r2, [r3, #0]
    pBuf++;
 801838c:	69fb      	ldr	r3, [r7, #28]
 801838e:	3301      	adds	r3, #1
 8018390:	61fb      	str	r3, [r7, #28]
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 8018392:	693b      	ldr	r3, [r7, #16]
 8018394:	0a1b      	lsrs	r3, r3, #8
 8018396:	b2da      	uxtb	r2, r3
 8018398:	69fb      	ldr	r3, [r7, #28]
 801839a:	701a      	strb	r2, [r3, #0]
    pBuf++;
 801839c:	69fb      	ldr	r3, [r7, #28]
 801839e:	3301      	adds	r3, #1
 80183a0:	61fb      	str	r3, [r7, #28]
  for (i = n; i != 0U; i--)
 80183a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183a4:	3b01      	subs	r3, #1
 80183a6:	627b      	str	r3, [r7, #36]	; 0x24
 80183a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80183aa:	2b00      	cmp	r3, #0
 80183ac:	d1e3      	bne.n	8018376 <USB_ReadPMA+0x38>
#if PMA_ACCESS > 1U
    pdwVal++;
#endif /* PMA_ACCESS */
  }

  if ((wNBytes % 2U) != 0U)
 80183ae:	88bb      	ldrh	r3, [r7, #4]
 80183b0:	f003 0301 	and.w	r3, r3, #1
 80183b4:	b29b      	uxth	r3, r3
 80183b6:	2b00      	cmp	r3, #0
 80183b8:	d007      	beq.n	80183ca <USB_ReadPMA+0x8c>
  {
    temp = *pdwVal;
 80183ba:	6a3b      	ldr	r3, [r7, #32]
 80183bc:	881b      	ldrh	r3, [r3, #0]
 80183be:	b29b      	uxth	r3, r3
 80183c0:	613b      	str	r3, [r7, #16]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 80183c2:	693b      	ldr	r3, [r7, #16]
 80183c4:	b2da      	uxtb	r2, r3
 80183c6:	69fb      	ldr	r3, [r7, #28]
 80183c8:	701a      	strb	r2, [r3, #0]
  }
}
 80183ca:	bf00      	nop
 80183cc:	372c      	adds	r7, #44	; 0x2c
 80183ce:	46bd      	mov	sp, r7
 80183d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80183d4:	4770      	bx	lr

080183d6 <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80183d6:	b580      	push	{r7, lr}
 80183d8:	b084      	sub	sp, #16
 80183da:	af00      	add	r7, sp, #0
 80183dc:	6078      	str	r0, [r7, #4]
 80183de:	460b      	mov	r3, r1
 80183e0:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 80183e2:	f44f 7007 	mov.w	r0, #540	; 0x21c
 80183e6:	f010 fea1 	bl	802912c <USBD_static_malloc>
 80183ea:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 80183ec:	68fb      	ldr	r3, [r7, #12]
 80183ee:	2b00      	cmp	r3, #0
 80183f0:	d105      	bne.n	80183fe <USBD_CDC_Init+0x28>
  {
    pdev->pClassData = NULL;
 80183f2:	687b      	ldr	r3, [r7, #4]
 80183f4:	2200      	movs	r2, #0
 80183f6:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
    return (uint8_t)USBD_EMEM;
 80183fa:	2302      	movs	r3, #2
 80183fc:	e066      	b.n	80184cc <USBD_CDC_Init+0xf6>
  }

  pdev->pClassData = (void *)hcdc;
 80183fe:	687b      	ldr	r3, [r7, #4]
 8018400:	68fa      	ldr	r2, [r7, #12]
 8018402:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8018406:	687b      	ldr	r3, [r7, #4]
 8018408:	7c1b      	ldrb	r3, [r3, #16]
 801840a:	2b00      	cmp	r3, #0
 801840c:	d119      	bne.n	8018442 <USBD_CDC_Init+0x6c>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 801840e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8018412:	2202      	movs	r2, #2
 8018414:	2181      	movs	r1, #129	; 0x81
 8018416:	6878      	ldr	r0, [r7, #4]
 8018418:	f010 fd2d 	bl	8028e76 <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 801841c:	687b      	ldr	r3, [r7, #4]
 801841e:	2201      	movs	r2, #1
 8018420:	871a      	strh	r2, [r3, #56]	; 0x38

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8018422:	f44f 7300 	mov.w	r3, #512	; 0x200
 8018426:	2202      	movs	r2, #2
 8018428:	2101      	movs	r1, #1
 801842a:	6878      	ldr	r0, [r7, #4]
 801842c:	f010 fd23 	bl	8028e76 <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8018430:	687b      	ldr	r3, [r7, #4]
 8018432:	2201      	movs	r2, #1
 8018434:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8018438:	687b      	ldr	r3, [r7, #4]
 801843a:	2210      	movs	r2, #16
 801843c:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
 8018440:	e016      	b.n	8018470 <USBD_CDC_Init+0x9a>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 8018442:	2340      	movs	r3, #64	; 0x40
 8018444:	2202      	movs	r2, #2
 8018446:	2181      	movs	r1, #129	; 0x81
 8018448:	6878      	ldr	r0, [r7, #4]
 801844a:	f010 fd14 	bl	8028e76 <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 801844e:	687b      	ldr	r3, [r7, #4]
 8018450:	2201      	movs	r2, #1
 8018452:	871a      	strh	r2, [r3, #56]	; 0x38

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8018454:	2340      	movs	r3, #64	; 0x40
 8018456:	2202      	movs	r2, #2
 8018458:	2101      	movs	r1, #1
 801845a:	6878      	ldr	r0, [r7, #4]
 801845c:	f010 fd0b 	bl	8028e76 <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8018460:	687b      	ldr	r3, [r7, #4]
 8018462:	2201      	movs	r2, #1
 8018464:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8018468:	687b      	ldr	r3, [r7, #4]
 801846a:	2210      	movs	r2, #16
 801846c:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8018470:	2308      	movs	r3, #8
 8018472:	2203      	movs	r2, #3
 8018474:	2182      	movs	r1, #130	; 0x82
 8018476:	6878      	ldr	r0, [r7, #4]
 8018478:	f010 fcfd 	bl	8028e76 <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 801847c:	687b      	ldr	r3, [r7, #4]
 801847e:	2201      	movs	r2, #1
 8018480:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8018484:	687b      	ldr	r3, [r7, #4]
 8018486:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 801848a:	681b      	ldr	r3, [r3, #0]
 801848c:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 801848e:	68fb      	ldr	r3, [r7, #12]
 8018490:	2200      	movs	r2, #0
 8018492:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  hcdc->RxState = 0U;
 8018496:	68fb      	ldr	r3, [r7, #12]
 8018498:	2200      	movs	r2, #0
 801849a:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801849e:	687b      	ldr	r3, [r7, #4]
 80184a0:	7c1b      	ldrb	r3, [r3, #16]
 80184a2:	2b00      	cmp	r3, #0
 80184a4:	d109      	bne.n	80184ba <USBD_CDC_Init+0xe4>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 80184a6:	68fb      	ldr	r3, [r7, #12]
 80184a8:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80184ac:	f44f 7300 	mov.w	r3, #512	; 0x200
 80184b0:	2101      	movs	r1, #1
 80184b2:	6878      	ldr	r0, [r7, #4]
 80184b4:	f010 fdcf 	bl	8029056 <USBD_LL_PrepareReceive>
 80184b8:	e007      	b.n	80184ca <USBD_CDC_Init+0xf4>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 80184ba:	68fb      	ldr	r3, [r7, #12]
 80184bc:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80184c0:	2340      	movs	r3, #64	; 0x40
 80184c2:	2101      	movs	r1, #1
 80184c4:	6878      	ldr	r0, [r7, #4]
 80184c6:	f010 fdc6 	bl	8029056 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 80184ca:	2300      	movs	r3, #0
}
 80184cc:	4618      	mov	r0, r3
 80184ce:	3710      	adds	r7, #16
 80184d0:	46bd      	mov	sp, r7
 80184d2:	bd80      	pop	{r7, pc}

080184d4 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80184d4:	b580      	push	{r7, lr}
 80184d6:	b082      	sub	sp, #8
 80184d8:	af00      	add	r7, sp, #0
 80184da:	6078      	str	r0, [r7, #4]
 80184dc:	460b      	mov	r3, r1
 80184de:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDC_IN_EP);
 80184e0:	2181      	movs	r1, #129	; 0x81
 80184e2:	6878      	ldr	r0, [r7, #4]
 80184e4:	f010 fced 	bl	8028ec2 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 80184e8:	687b      	ldr	r3, [r7, #4]
 80184ea:	2200      	movs	r2, #0
 80184ec:	871a      	strh	r2, [r3, #56]	; 0x38

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 80184ee:	2101      	movs	r1, #1
 80184f0:	6878      	ldr	r0, [r7, #4]
 80184f2:	f010 fce6 	bl	8028ec2 <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 80184f6:	687b      	ldr	r3, [r7, #4]
 80184f8:	2200      	movs	r2, #0
 80184fa:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 80184fe:	2182      	movs	r1, #130	; 0x82
 8018500:	6878      	ldr	r0, [r7, #4]
 8018502:	f010 fcde 	bl	8028ec2 <USBD_LL_CloseEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 8018506:	687b      	ldr	r3, [r7, #4]
 8018508:	2200      	movs	r2, #0
 801850a:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = 0U;
 801850e:	687b      	ldr	r3, [r7, #4]
 8018510:	2200      	movs	r2, #0
 8018512:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

  /* DeInit  physical Interface components */
  if (pdev->pClassData != NULL)
 8018516:	687b      	ldr	r3, [r7, #4]
 8018518:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 801851c:	2b00      	cmp	r3, #0
 801851e:	d00e      	beq.n	801853e <USBD_CDC_DeInit+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8018520:	687b      	ldr	r3, [r7, #4]
 8018522:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8018526:	685b      	ldr	r3, [r3, #4]
 8018528:	4798      	blx	r3
    (void)USBD_free(pdev->pClassData);
 801852a:	687b      	ldr	r3, [r7, #4]
 801852c:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018530:	4618      	mov	r0, r3
 8018532:	f010 fe09 	bl	8029148 <USBD_static_free>
    pdev->pClassData = NULL;
 8018536:	687b      	ldr	r3, [r7, #4]
 8018538:	2200      	movs	r2, #0
 801853a:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
  }

  return (uint8_t)USBD_OK;
 801853e:	2300      	movs	r3, #0
}
 8018540:	4618      	mov	r0, r3
 8018542:	3708      	adds	r7, #8
 8018544:	46bd      	mov	sp, r7
 8018546:	bd80      	pop	{r7, pc}

08018548 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8018548:	b580      	push	{r7, lr}
 801854a:	b086      	sub	sp, #24
 801854c:	af00      	add	r7, sp, #0
 801854e:	6078      	str	r0, [r7, #4]
 8018550:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018558:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 801855a:	2300      	movs	r3, #0
 801855c:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 801855e:	2300      	movs	r3, #0
 8018560:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 8018562:	2300      	movs	r3, #0
 8018564:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 8018566:	693b      	ldr	r3, [r7, #16]
 8018568:	2b00      	cmp	r3, #0
 801856a:	d101      	bne.n	8018570 <USBD_CDC_Setup+0x28>
  {
    return (uint8_t)USBD_FAIL;
 801856c:	2303      	movs	r3, #3
 801856e:	e0af      	b.n	80186d0 <USBD_CDC_Setup+0x188>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8018570:	683b      	ldr	r3, [r7, #0]
 8018572:	781b      	ldrb	r3, [r3, #0]
 8018574:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8018578:	2b00      	cmp	r3, #0
 801857a:	d03f      	beq.n	80185fc <USBD_CDC_Setup+0xb4>
 801857c:	2b20      	cmp	r3, #32
 801857e:	f040 809f 	bne.w	80186c0 <USBD_CDC_Setup+0x178>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 8018582:	683b      	ldr	r3, [r7, #0]
 8018584:	88db      	ldrh	r3, [r3, #6]
 8018586:	2b00      	cmp	r3, #0
 8018588:	d02e      	beq.n	80185e8 <USBD_CDC_Setup+0xa0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 801858a:	683b      	ldr	r3, [r7, #0]
 801858c:	781b      	ldrb	r3, [r3, #0]
 801858e:	b25b      	sxtb	r3, r3
 8018590:	2b00      	cmp	r3, #0
 8018592:	da16      	bge.n	80185c2 <USBD_CDC_Setup+0x7a>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8018594:	687b      	ldr	r3, [r7, #4]
 8018596:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 801859a:	689b      	ldr	r3, [r3, #8]
 801859c:	683a      	ldr	r2, [r7, #0]
 801859e:	7850      	ldrb	r0, [r2, #1]
                                                            (uint8_t *)hcdc->data,
 80185a0:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 80185a2:	683a      	ldr	r2, [r7, #0]
 80185a4:	88d2      	ldrh	r2, [r2, #6]
 80185a6:	4798      	blx	r3
                                                            req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 80185a8:	683b      	ldr	r3, [r7, #0]
 80185aa:	88db      	ldrh	r3, [r3, #6]
 80185ac:	2b07      	cmp	r3, #7
 80185ae:	bf28      	it	cs
 80185b0:	2307      	movcs	r3, #7
 80185b2:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 80185b4:	693b      	ldr	r3, [r7, #16]
 80185b6:	89fa      	ldrh	r2, [r7, #14]
 80185b8:	4619      	mov	r1, r3
 80185ba:	6878      	ldr	r0, [r7, #4]
 80185bc:	f001 fa9f 	bl	8019afe <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                          (uint8_t *)req, 0U);
      }
      break;
 80185c0:	e085      	b.n	80186ce <USBD_CDC_Setup+0x186>
          hcdc->CmdOpCode = req->bRequest;
 80185c2:	683b      	ldr	r3, [r7, #0]
 80185c4:	785a      	ldrb	r2, [r3, #1]
 80185c6:	693b      	ldr	r3, [r7, #16]
 80185c8:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
          hcdc->CmdLength = (uint8_t)req->wLength;
 80185cc:	683b      	ldr	r3, [r7, #0]
 80185ce:	88db      	ldrh	r3, [r3, #6]
 80185d0:	b2da      	uxtb	r2, r3
 80185d2:	693b      	ldr	r3, [r7, #16]
 80185d4:	f883 2201 	strb.w	r2, [r3, #513]	; 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, req->wLength);
 80185d8:	6939      	ldr	r1, [r7, #16]
 80185da:	683b      	ldr	r3, [r7, #0]
 80185dc:	88db      	ldrh	r3, [r3, #6]
 80185de:	461a      	mov	r2, r3
 80185e0:	6878      	ldr	r0, [r7, #4]
 80185e2:	f001 fab8 	bl	8019b56 <USBD_CtlPrepareRx>
      break;
 80185e6:	e072      	b.n	80186ce <USBD_CDC_Setup+0x186>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 80185e8:	687b      	ldr	r3, [r7, #4]
 80185ea:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 80185ee:	689b      	ldr	r3, [r3, #8]
 80185f0:	683a      	ldr	r2, [r7, #0]
 80185f2:	7850      	ldrb	r0, [r2, #1]
 80185f4:	2200      	movs	r2, #0
 80185f6:	6839      	ldr	r1, [r7, #0]
 80185f8:	4798      	blx	r3
      break;
 80185fa:	e068      	b.n	80186ce <USBD_CDC_Setup+0x186>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80185fc:	683b      	ldr	r3, [r7, #0]
 80185fe:	785b      	ldrb	r3, [r3, #1]
 8018600:	2b0b      	cmp	r3, #11
 8018602:	d852      	bhi.n	80186aa <USBD_CDC_Setup+0x162>
 8018604:	a201      	add	r2, pc, #4	; (adr r2, 801860c <USBD_CDC_Setup+0xc4>)
 8018606:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801860a:	bf00      	nop
 801860c:	0801863d 	.word	0x0801863d
 8018610:	080186b9 	.word	0x080186b9
 8018614:	080186ab 	.word	0x080186ab
 8018618:	080186ab 	.word	0x080186ab
 801861c:	080186ab 	.word	0x080186ab
 8018620:	080186ab 	.word	0x080186ab
 8018624:	080186ab 	.word	0x080186ab
 8018628:	080186ab 	.word	0x080186ab
 801862c:	080186ab 	.word	0x080186ab
 8018630:	080186ab 	.word	0x080186ab
 8018634:	08018667 	.word	0x08018667
 8018638:	08018691 	.word	0x08018691
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801863c:	687b      	ldr	r3, [r7, #4]
 801863e:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018642:	b2db      	uxtb	r3, r3
 8018644:	2b03      	cmp	r3, #3
 8018646:	d107      	bne.n	8018658 <USBD_CDC_Setup+0x110>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8018648:	f107 030a 	add.w	r3, r7, #10
 801864c:	2202      	movs	r2, #2
 801864e:	4619      	mov	r1, r3
 8018650:	6878      	ldr	r0, [r7, #4]
 8018652:	f001 fa54 	bl	8019afe <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8018656:	e032      	b.n	80186be <USBD_CDC_Setup+0x176>
            USBD_CtlError(pdev, req);
 8018658:	6839      	ldr	r1, [r7, #0]
 801865a:	6878      	ldr	r0, [r7, #4]
 801865c:	f001 f9de 	bl	8019a1c <USBD_CtlError>
            ret = USBD_FAIL;
 8018660:	2303      	movs	r3, #3
 8018662:	75fb      	strb	r3, [r7, #23]
          break;
 8018664:	e02b      	b.n	80186be <USBD_CDC_Setup+0x176>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018666:	687b      	ldr	r3, [r7, #4]
 8018668:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 801866c:	b2db      	uxtb	r3, r3
 801866e:	2b03      	cmp	r3, #3
 8018670:	d107      	bne.n	8018682 <USBD_CDC_Setup+0x13a>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8018672:	f107 030d 	add.w	r3, r7, #13
 8018676:	2201      	movs	r2, #1
 8018678:	4619      	mov	r1, r3
 801867a:	6878      	ldr	r0, [r7, #4]
 801867c:	f001 fa3f 	bl	8019afe <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8018680:	e01d      	b.n	80186be <USBD_CDC_Setup+0x176>
            USBD_CtlError(pdev, req);
 8018682:	6839      	ldr	r1, [r7, #0]
 8018684:	6878      	ldr	r0, [r7, #4]
 8018686:	f001 f9c9 	bl	8019a1c <USBD_CtlError>
            ret = USBD_FAIL;
 801868a:	2303      	movs	r3, #3
 801868c:	75fb      	strb	r3, [r7, #23]
          break;
 801868e:	e016      	b.n	80186be <USBD_CDC_Setup+0x176>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8018690:	687b      	ldr	r3, [r7, #4]
 8018692:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018696:	b2db      	uxtb	r3, r3
 8018698:	2b03      	cmp	r3, #3
 801869a:	d00f      	beq.n	80186bc <USBD_CDC_Setup+0x174>
          {
            USBD_CtlError(pdev, req);
 801869c:	6839      	ldr	r1, [r7, #0]
 801869e:	6878      	ldr	r0, [r7, #4]
 80186a0:	f001 f9bc 	bl	8019a1c <USBD_CtlError>
            ret = USBD_FAIL;
 80186a4:	2303      	movs	r3, #3
 80186a6:	75fb      	strb	r3, [r7, #23]
          }
          break;
 80186a8:	e008      	b.n	80186bc <USBD_CDC_Setup+0x174>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 80186aa:	6839      	ldr	r1, [r7, #0]
 80186ac:	6878      	ldr	r0, [r7, #4]
 80186ae:	f001 f9b5 	bl	8019a1c <USBD_CtlError>
          ret = USBD_FAIL;
 80186b2:	2303      	movs	r3, #3
 80186b4:	75fb      	strb	r3, [r7, #23]
          break;
 80186b6:	e002      	b.n	80186be <USBD_CDC_Setup+0x176>
          break;
 80186b8:	bf00      	nop
 80186ba:	e008      	b.n	80186ce <USBD_CDC_Setup+0x186>
          break;
 80186bc:	bf00      	nop
      }
      break;
 80186be:	e006      	b.n	80186ce <USBD_CDC_Setup+0x186>

    default:
      USBD_CtlError(pdev, req);
 80186c0:	6839      	ldr	r1, [r7, #0]
 80186c2:	6878      	ldr	r0, [r7, #4]
 80186c4:	f001 f9aa 	bl	8019a1c <USBD_CtlError>
      ret = USBD_FAIL;
 80186c8:	2303      	movs	r3, #3
 80186ca:	75fb      	strb	r3, [r7, #23]
      break;
 80186cc:	bf00      	nop
  }

  return (uint8_t)ret;
 80186ce:	7dfb      	ldrb	r3, [r7, #23]
}
 80186d0:	4618      	mov	r0, r3
 80186d2:	3718      	adds	r7, #24
 80186d4:	46bd      	mov	sp, r7
 80186d6:	bd80      	pop	{r7, pc}

080186d8 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 80186d8:	b580      	push	{r7, lr}
 80186da:	b084      	sub	sp, #16
 80186dc:	af00      	add	r7, sp, #0
 80186de:	6078      	str	r0, [r7, #4]
 80186e0:	460b      	mov	r3, r1
 80186e2:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = pdev->pData;
 80186e4:	687b      	ldr	r3, [r7, #4]
 80186e6:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 80186ea:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 80186ec:	687b      	ldr	r3, [r7, #4]
 80186ee:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80186f2:	2b00      	cmp	r3, #0
 80186f4:	d101      	bne.n	80186fa <USBD_CDC_DataIn+0x22>
  {
    return (uint8_t)USBD_FAIL;
 80186f6:	2303      	movs	r3, #3
 80186f8:	e04f      	b.n	801879a <USBD_CDC_DataIn+0xc2>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 80186fa:	687b      	ldr	r3, [r7, #4]
 80186fc:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018700:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum].total_length > 0U) &&
 8018702:	78fa      	ldrb	r2, [r7, #3]
 8018704:	6879      	ldr	r1, [r7, #4]
 8018706:	4613      	mov	r3, r2
 8018708:	009b      	lsls	r3, r3, #2
 801870a:	4413      	add	r3, r2
 801870c:	009b      	lsls	r3, r3, #2
 801870e:	440b      	add	r3, r1
 8018710:	3318      	adds	r3, #24
 8018712:	681b      	ldr	r3, [r3, #0]
 8018714:	2b00      	cmp	r3, #0
 8018716:	d029      	beq.n	801876c <USBD_CDC_DataIn+0x94>
      ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 8018718:	78fa      	ldrb	r2, [r7, #3]
 801871a:	6879      	ldr	r1, [r7, #4]
 801871c:	4613      	mov	r3, r2
 801871e:	009b      	lsls	r3, r3, #2
 8018720:	4413      	add	r3, r2
 8018722:	009b      	lsls	r3, r3, #2
 8018724:	440b      	add	r3, r1
 8018726:	3318      	adds	r3, #24
 8018728:	681a      	ldr	r2, [r3, #0]
 801872a:	78f9      	ldrb	r1, [r7, #3]
 801872c:	68f8      	ldr	r0, [r7, #12]
 801872e:	460b      	mov	r3, r1
 8018730:	009b      	lsls	r3, r3, #2
 8018732:	440b      	add	r3, r1
 8018734:	00db      	lsls	r3, r3, #3
 8018736:	4403      	add	r3, r0
 8018738:	3338      	adds	r3, #56	; 0x38
 801873a:	681b      	ldr	r3, [r3, #0]
 801873c:	fbb2 f1f3 	udiv	r1, r2, r3
 8018740:	fb03 f301 	mul.w	r3, r3, r1
 8018744:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum].total_length > 0U) &&
 8018746:	2b00      	cmp	r3, #0
 8018748:	d110      	bne.n	801876c <USBD_CDC_DataIn+0x94>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum].total_length = 0U;
 801874a:	78fa      	ldrb	r2, [r7, #3]
 801874c:	6879      	ldr	r1, [r7, #4]
 801874e:	4613      	mov	r3, r2
 8018750:	009b      	lsls	r3, r3, #2
 8018752:	4413      	add	r3, r2
 8018754:	009b      	lsls	r3, r3, #2
 8018756:	440b      	add	r3, r1
 8018758:	3318      	adds	r3, #24
 801875a:	2200      	movs	r2, #0
 801875c:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 801875e:	78f9      	ldrb	r1, [r7, #3]
 8018760:	2300      	movs	r3, #0
 8018762:	2200      	movs	r2, #0
 8018764:	6878      	ldr	r0, [r7, #4]
 8018766:	f010 fc55 	bl	8029014 <USBD_LL_Transmit>
 801876a:	e015      	b.n	8018798 <USBD_CDC_DataIn+0xc0>
  }
  else
  {
    hcdc->TxState = 0U;
 801876c:	68bb      	ldr	r3, [r7, #8]
 801876e:	2200      	movs	r2, #0
 8018770:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData)->TransmitCplt != NULL)
 8018774:	687b      	ldr	r3, [r7, #4]
 8018776:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 801877a:	691b      	ldr	r3, [r3, #16]
 801877c:	2b00      	cmp	r3, #0
 801877e:	d00b      	beq.n	8018798 <USBD_CDC_DataIn+0xc0>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8018780:	687b      	ldr	r3, [r7, #4]
 8018782:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8018786:	691b      	ldr	r3, [r3, #16]
 8018788:	68ba      	ldr	r2, [r7, #8]
 801878a:	f8d2 0208 	ldr.w	r0, [r2, #520]	; 0x208
 801878e:	68ba      	ldr	r2, [r7, #8]
 8018790:	f502 7104 	add.w	r1, r2, #528	; 0x210
 8018794:	78fa      	ldrb	r2, [r7, #3]
 8018796:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8018798:	2300      	movs	r3, #0
}
 801879a:	4618      	mov	r0, r3
 801879c:	3710      	adds	r7, #16
 801879e:	46bd      	mov	sp, r7
 80187a0:	bd80      	pop	{r7, pc}

080187a2 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 80187a2:	b580      	push	{r7, lr}
 80187a4:	b084      	sub	sp, #16
 80187a6:	af00      	add	r7, sp, #0
 80187a8:	6078      	str	r0, [r7, #4]
 80187aa:	460b      	mov	r3, r1
 80187ac:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 80187ae:	687b      	ldr	r3, [r7, #4]
 80187b0:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80187b4:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 80187b6:	687b      	ldr	r3, [r7, #4]
 80187b8:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80187bc:	2b00      	cmp	r3, #0
 80187be:	d101      	bne.n	80187c4 <USBD_CDC_DataOut+0x22>
  {
    return (uint8_t)USBD_FAIL;
 80187c0:	2303      	movs	r3, #3
 80187c2:	e015      	b.n	80187f0 <USBD_CDC_DataOut+0x4e>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 80187c4:	78fb      	ldrb	r3, [r7, #3]
 80187c6:	4619      	mov	r1, r3
 80187c8:	6878      	ldr	r0, [r7, #4]
 80187ca:	f010 fc65 	bl	8029098 <USBD_LL_GetRxDataSize>
 80187ce:	4602      	mov	r2, r0
 80187d0:	68fb      	ldr	r3, [r7, #12]
 80187d2:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 80187d6:	687b      	ldr	r3, [r7, #4]
 80187d8:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 80187dc:	68db      	ldr	r3, [r3, #12]
 80187de:	68fa      	ldr	r2, [r7, #12]
 80187e0:	f8d2 0204 	ldr.w	r0, [r2, #516]	; 0x204
 80187e4:	68fa      	ldr	r2, [r7, #12]
 80187e6:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 80187ea:	4611      	mov	r1, r2
 80187ec:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 80187ee:	2300      	movs	r3, #0
}
 80187f0:	4618      	mov	r0, r3
 80187f2:	3710      	adds	r7, #16
 80187f4:	46bd      	mov	sp, r7
 80187f6:	bd80      	pop	{r7, pc}

080187f8 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 80187f8:	b580      	push	{r7, lr}
 80187fa:	b084      	sub	sp, #16
 80187fc:	af00      	add	r7, sp, #0
 80187fe:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8018800:	687b      	ldr	r3, [r7, #4]
 8018802:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018806:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8018808:	68fb      	ldr	r3, [r7, #12]
 801880a:	2b00      	cmp	r3, #0
 801880c:	d101      	bne.n	8018812 <USBD_CDC_EP0_RxReady+0x1a>
  {
    return (uint8_t)USBD_FAIL;
 801880e:	2303      	movs	r3, #3
 8018810:	e01b      	b.n	801884a <USBD_CDC_EP0_RxReady+0x52>
  }

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8018812:	687b      	ldr	r3, [r7, #4]
 8018814:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8018818:	2b00      	cmp	r3, #0
 801881a:	d015      	beq.n	8018848 <USBD_CDC_EP0_RxReady+0x50>
 801881c:	68fb      	ldr	r3, [r7, #12]
 801881e:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8018822:	2bff      	cmp	r3, #255	; 0xff
 8018824:	d010      	beq.n	8018848 <USBD_CDC_EP0_RxReady+0x50>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8018826:	687b      	ldr	r3, [r7, #4]
 8018828:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 801882c:	689b      	ldr	r3, [r3, #8]
 801882e:	68fa      	ldr	r2, [r7, #12]
 8018830:	f892 0200 	ldrb.w	r0, [r2, #512]	; 0x200
                                                      (uint8_t *)hcdc->data,
 8018834:	68f9      	ldr	r1, [r7, #12]
                                                      (uint16_t)hcdc->CmdLength);
 8018836:	68fa      	ldr	r2, [r7, #12]
 8018838:	f892 2201 	ldrb.w	r2, [r2, #513]	; 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 801883c:	b292      	uxth	r2, r2
 801883e:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8018840:	68fb      	ldr	r3, [r7, #12]
 8018842:	22ff      	movs	r2, #255	; 0xff
 8018844:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
  }

  return (uint8_t)USBD_OK;
 8018848:	2300      	movs	r3, #0
}
 801884a:	4618      	mov	r0, r3
 801884c:	3710      	adds	r7, #16
 801884e:	46bd      	mov	sp, r7
 8018850:	bd80      	pop	{r7, pc}
	...

08018854 <USBD_CDC_GetFSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8018854:	b480      	push	{r7}
 8018856:	b083      	sub	sp, #12
 8018858:	af00      	add	r7, sp, #0
 801885a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgFSDesc);
 801885c:	687b      	ldr	r3, [r7, #4]
 801885e:	2243      	movs	r2, #67	; 0x43
 8018860:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_CfgFSDesc;
 8018862:	4b03      	ldr	r3, [pc, #12]	; (8018870 <USBD_CDC_GetFSCfgDesc+0x1c>)
}
 8018864:	4618      	mov	r0, r3
 8018866:	370c      	adds	r7, #12
 8018868:	46bd      	mov	sp, r7
 801886a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801886e:	4770      	bx	lr
 8018870:	200000a4 	.word	0x200000a4

08018874 <USBD_CDC_GetHSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8018874:	b480      	push	{r7}
 8018876:	b083      	sub	sp, #12
 8018878:	af00      	add	r7, sp, #0
 801887a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgHSDesc);
 801887c:	687b      	ldr	r3, [r7, #4]
 801887e:	2243      	movs	r2, #67	; 0x43
 8018880:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_CfgHSDesc;
 8018882:	4b03      	ldr	r3, [pc, #12]	; (8018890 <USBD_CDC_GetHSCfgDesc+0x1c>)
}
 8018884:	4618      	mov	r0, r3
 8018886:	370c      	adds	r7, #12
 8018888:	46bd      	mov	sp, r7
 801888a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801888e:	4770      	bx	lr
 8018890:	20000060 	.word	0x20000060

08018894 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8018894:	b480      	push	{r7}
 8018896:	b083      	sub	sp, #12
 8018898:	af00      	add	r7, sp, #0
 801889a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_OtherSpeedCfgDesc);
 801889c:	687b      	ldr	r3, [r7, #4]
 801889e:	2243      	movs	r2, #67	; 0x43
 80188a0:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_OtherSpeedCfgDesc;
 80188a2:	4b03      	ldr	r3, [pc, #12]	; (80188b0 <USBD_CDC_GetOtherSpeedCfgDesc+0x1c>)
}
 80188a4:	4618      	mov	r0, r3
 80188a6:	370c      	adds	r7, #12
 80188a8:	46bd      	mov	sp, r7
 80188aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80188ae:	4770      	bx	lr
 80188b0:	200000e8 	.word	0x200000e8

080188b4 <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 80188b4:	b480      	push	{r7}
 80188b6:	b083      	sub	sp, #12
 80188b8:	af00      	add	r7, sp, #0
 80188ba:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 80188bc:	687b      	ldr	r3, [r7, #4]
 80188be:	220a      	movs	r2, #10
 80188c0:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 80188c2:	4b03      	ldr	r3, [pc, #12]	; (80188d0 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 80188c4:	4618      	mov	r0, r3
 80188c6:	370c      	adds	r7, #12
 80188c8:	46bd      	mov	sp, r7
 80188ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80188ce:	4770      	bx	lr
 80188d0:	2000001c 	.word	0x2000001c

080188d4 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 80188d4:	b480      	push	{r7}
 80188d6:	b083      	sub	sp, #12
 80188d8:	af00      	add	r7, sp, #0
 80188da:	6078      	str	r0, [r7, #4]
 80188dc:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 80188de:	683b      	ldr	r3, [r7, #0]
 80188e0:	2b00      	cmp	r3, #0
 80188e2:	d101      	bne.n	80188e8 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 80188e4:	2303      	movs	r3, #3
 80188e6:	e004      	b.n	80188f2 <USBD_CDC_RegisterInterface+0x1e>
  }

  pdev->pUserData = fops;
 80188e8:	687b      	ldr	r3, [r7, #4]
 80188ea:	683a      	ldr	r2, [r7, #0]
 80188ec:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0

  return (uint8_t)USBD_OK;
 80188f0:	2300      	movs	r3, #0
}
 80188f2:	4618      	mov	r0, r3
 80188f4:	370c      	adds	r7, #12
 80188f6:	46bd      	mov	sp, r7
 80188f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80188fc:	4770      	bx	lr

080188fe <USBD_CDC_SetTxBuffer>:
  * @param  pbuff: Tx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 80188fe:	b480      	push	{r7}
 8018900:	b087      	sub	sp, #28
 8018902:	af00      	add	r7, sp, #0
 8018904:	60f8      	str	r0, [r7, #12]
 8018906:	60b9      	str	r1, [r7, #8]
 8018908:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 801890a:	68fb      	ldr	r3, [r7, #12]
 801890c:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018910:	617b      	str	r3, [r7, #20]

  if (hcdc == NULL)
 8018912:	697b      	ldr	r3, [r7, #20]
 8018914:	2b00      	cmp	r3, #0
 8018916:	d101      	bne.n	801891c <USBD_CDC_SetTxBuffer+0x1e>
  {
    return (uint8_t)USBD_FAIL;
 8018918:	2303      	movs	r3, #3
 801891a:	e008      	b.n	801892e <USBD_CDC_SetTxBuffer+0x30>
  }

  hcdc->TxBuffer = pbuff;
 801891c:	697b      	ldr	r3, [r7, #20]
 801891e:	68ba      	ldr	r2, [r7, #8]
 8018920:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 8018924:	697b      	ldr	r3, [r7, #20]
 8018926:	687a      	ldr	r2, [r7, #4]
 8018928:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return (uint8_t)USBD_OK;
 801892c:	2300      	movs	r3, #0
}
 801892e:	4618      	mov	r0, r3
 8018930:	371c      	adds	r7, #28
 8018932:	46bd      	mov	sp, r7
 8018934:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018938:	4770      	bx	lr

0801893a <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 801893a:	b480      	push	{r7}
 801893c:	b085      	sub	sp, #20
 801893e:	af00      	add	r7, sp, #0
 8018940:	6078      	str	r0, [r7, #4]
 8018942:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8018944:	687b      	ldr	r3, [r7, #4]
 8018946:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 801894a:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 801894c:	68fb      	ldr	r3, [r7, #12]
 801894e:	2b00      	cmp	r3, #0
 8018950:	d101      	bne.n	8018956 <USBD_CDC_SetRxBuffer+0x1c>
  {
    return (uint8_t)USBD_FAIL;
 8018952:	2303      	movs	r3, #3
 8018954:	e004      	b.n	8018960 <USBD_CDC_SetRxBuffer+0x26>
  }

  hcdc->RxBuffer = pbuff;
 8018956:	68fb      	ldr	r3, [r7, #12]
 8018958:	683a      	ldr	r2, [r7, #0]
 801895a:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

  return (uint8_t)USBD_OK;
 801895e:	2300      	movs	r3, #0
}
 8018960:	4618      	mov	r0, r3
 8018962:	3714      	adds	r7, #20
 8018964:	46bd      	mov	sp, r7
 8018966:	f85d 7b04 	ldr.w	r7, [sp], #4
 801896a:	4770      	bx	lr

0801896c <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 801896c:	b580      	push	{r7, lr}
 801896e:	b084      	sub	sp, #16
 8018970:	af00      	add	r7, sp, #0
 8018972:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8018974:	687b      	ldr	r3, [r7, #4]
 8018976:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 801897a:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 801897c:	687b      	ldr	r3, [r7, #4]
 801897e:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018982:	2b00      	cmp	r3, #0
 8018984:	d101      	bne.n	801898a <USBD_CDC_ReceivePacket+0x1e>
  {
    return (uint8_t)USBD_FAIL;
 8018986:	2303      	movs	r3, #3
 8018988:	e016      	b.n	80189b8 <USBD_CDC_ReceivePacket+0x4c>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801898a:	687b      	ldr	r3, [r7, #4]
 801898c:	7c1b      	ldrb	r3, [r3, #16]
 801898e:	2b00      	cmp	r3, #0
 8018990:	d109      	bne.n	80189a6 <USBD_CDC_ReceivePacket+0x3a>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8018992:	68fb      	ldr	r3, [r7, #12]
 8018994:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8018998:	f44f 7300 	mov.w	r3, #512	; 0x200
 801899c:	2101      	movs	r1, #1
 801899e:	6878      	ldr	r0, [r7, #4]
 80189a0:	f010 fb59 	bl	8029056 <USBD_LL_PrepareReceive>
 80189a4:	e007      	b.n	80189b6 <USBD_CDC_ReceivePacket+0x4a>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 80189a6:	68fb      	ldr	r3, [r7, #12]
 80189a8:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80189ac:	2340      	movs	r3, #64	; 0x40
 80189ae:	2101      	movs	r1, #1
 80189b0:	6878      	ldr	r0, [r7, #4]
 80189b2:	f010 fb50 	bl	8029056 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 80189b6:	2300      	movs	r3, #0
}
 80189b8:	4618      	mov	r0, r3
 80189ba:	3710      	adds	r7, #16
 80189bc:	46bd      	mov	sp, r7
 80189be:	bd80      	pop	{r7, pc}

080189c0 <USBD_Init>:
  * @param  id: Low level core index
  * @retval None
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 80189c0:	b580      	push	{r7, lr}
 80189c2:	b086      	sub	sp, #24
 80189c4:	af00      	add	r7, sp, #0
 80189c6:	60f8      	str	r0, [r7, #12]
 80189c8:	60b9      	str	r1, [r7, #8]
 80189ca:	4613      	mov	r3, r2
 80189cc:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 80189ce:	68fb      	ldr	r3, [r7, #12]
 80189d0:	2b00      	cmp	r3, #0
 80189d2:	d101      	bne.n	80189d8 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif
    return USBD_FAIL;
 80189d4:	2303      	movs	r3, #3
 80189d6:	e01f      	b.n	8018a18 <USBD_Init+0x58>
  }

  /* Unlink previous class resources */
  pdev->pClass = NULL;
 80189d8:	68fb      	ldr	r3, [r7, #12]
 80189da:	2200      	movs	r2, #0
 80189dc:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  pdev->pUserData = NULL;
 80189e0:	68fb      	ldr	r3, [r7, #12]
 80189e2:	2200      	movs	r2, #0
 80189e4:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
  pdev->pConfDesc = NULL;
 80189e8:	68fb      	ldr	r3, [r7, #12]
 80189ea:	2200      	movs	r2, #0
 80189ec:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 80189f0:	68bb      	ldr	r3, [r7, #8]
 80189f2:	2b00      	cmp	r3, #0
 80189f4:	d003      	beq.n	80189fe <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 80189f6:	68fb      	ldr	r3, [r7, #12]
 80189f8:	68ba      	ldr	r2, [r7, #8]
 80189fa:	f8c3 22b4 	str.w	r2, [r3, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80189fe:	68fb      	ldr	r3, [r7, #12]
 8018a00:	2201      	movs	r2, #1
 8018a02:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->id = id;
 8018a06:	68fb      	ldr	r3, [r7, #12]
 8018a08:	79fa      	ldrb	r2, [r7, #7]
 8018a0a:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8018a0c:	68f8      	ldr	r0, [r7, #12]
 8018a0e:	f010 f9b5 	bl	8028d7c <USBD_LL_Init>
 8018a12:	4603      	mov	r3, r0
 8018a14:	75fb      	strb	r3, [r7, #23]

  return ret;
 8018a16:	7dfb      	ldrb	r3, [r7, #23]
}
 8018a18:	4618      	mov	r0, r3
 8018a1a:	3718      	adds	r7, #24
 8018a1c:	46bd      	mov	sp, r7
 8018a1e:	bd80      	pop	{r7, pc}

08018a20 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8018a20:	b580      	push	{r7, lr}
 8018a22:	b084      	sub	sp, #16
 8018a24:	af00      	add	r7, sp, #0
 8018a26:	6078      	str	r0, [r7, #4]
 8018a28:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8018a2a:	2300      	movs	r3, #0
 8018a2c:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 8018a2e:	683b      	ldr	r3, [r7, #0]
 8018a30:	2b00      	cmp	r3, #0
 8018a32:	d101      	bne.n	8018a38 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    return USBD_FAIL;
 8018a34:	2303      	movs	r3, #3
 8018a36:	e016      	b.n	8018a66 <USBD_RegisterClass+0x46>
  }

  /* link the class to the USB Device handle */
  pdev->pClass = pclass;
 8018a38:	687b      	ldr	r3, [r7, #4]
 8018a3a:	683a      	ldr	r2, [r7, #0]
 8018a3c:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  if (pdev->pClass->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass->GetFSConfigDescriptor != NULL)
 8018a40:	687b      	ldr	r3, [r7, #4]
 8018a42:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018a46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8018a48:	2b00      	cmp	r3, #0
 8018a4a:	d00b      	beq.n	8018a64 <USBD_RegisterClass+0x44>
  {
    pdev->pConfDesc = (void *)pdev->pClass->GetFSConfigDescriptor(&len);
 8018a4c:	687b      	ldr	r3, [r7, #4]
 8018a4e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018a52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8018a54:	f107 020e 	add.w	r2, r7, #14
 8018a58:	4610      	mov	r0, r2
 8018a5a:	4798      	blx	r3
 8018a5c:	4602      	mov	r2, r0
 8018a5e:	687b      	ldr	r3, [r7, #4]
 8018a60:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
  }
#endif /* USE_USB_FS */

  return USBD_OK;
 8018a64:	2300      	movs	r3, #0
}
 8018a66:	4618      	mov	r0, r3
 8018a68:	3710      	adds	r7, #16
 8018a6a:	46bd      	mov	sp, r7
 8018a6c:	bd80      	pop	{r7, pc}

08018a6e <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8018a6e:	b580      	push	{r7, lr}
 8018a70:	b082      	sub	sp, #8
 8018a72:	af00      	add	r7, sp, #0
 8018a74:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8018a76:	6878      	ldr	r0, [r7, #4]
 8018a78:	f010 f9e2 	bl	8028e40 <USBD_LL_Start>
 8018a7c:	4603      	mov	r3, r0
}
 8018a7e:	4618      	mov	r0, r3
 8018a80:	3708      	adds	r7, #8
 8018a82:	46bd      	mov	sp, r7
 8018a84:	bd80      	pop	{r7, pc}

08018a86 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef  *pdev)
{
 8018a86:	b480      	push	{r7}
 8018a88:	b083      	sub	sp, #12
 8018a8a:	af00      	add	r7, sp, #0
 8018a8c:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8018a8e:	2300      	movs	r3, #0
}
 8018a90:	4618      	mov	r0, r3
 8018a92:	370c      	adds	r7, #12
 8018a94:	46bd      	mov	sp, r7
 8018a96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a9a:	4770      	bx	lr

08018a9c <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8018a9c:	b580      	push	{r7, lr}
 8018a9e:	b084      	sub	sp, #16
 8018aa0:	af00      	add	r7, sp, #0
 8018aa2:	6078      	str	r0, [r7, #4]
 8018aa4:	460b      	mov	r3, r1
 8018aa6:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_FAIL;
 8018aa8:	2303      	movs	r3, #3
 8018aaa:	73fb      	strb	r3, [r7, #15]

  if (pdev->pClass != NULL)
 8018aac:	687b      	ldr	r3, [r7, #4]
 8018aae:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018ab2:	2b00      	cmp	r3, #0
 8018ab4:	d009      	beq.n	8018aca <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass->Init(pdev, cfgidx);
 8018ab6:	687b      	ldr	r3, [r7, #4]
 8018ab8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018abc:	681b      	ldr	r3, [r3, #0]
 8018abe:	78fa      	ldrb	r2, [r7, #3]
 8018ac0:	4611      	mov	r1, r2
 8018ac2:	6878      	ldr	r0, [r7, #4]
 8018ac4:	4798      	blx	r3
 8018ac6:	4603      	mov	r3, r0
 8018ac8:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 8018aca:	7bfb      	ldrb	r3, [r7, #15]
}
 8018acc:	4618      	mov	r0, r3
 8018ace:	3710      	adds	r7, #16
 8018ad0:	46bd      	mov	sp, r7
 8018ad2:	bd80      	pop	{r7, pc}

08018ad4 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8018ad4:	b580      	push	{r7, lr}
 8018ad6:	b082      	sub	sp, #8
 8018ad8:	af00      	add	r7, sp, #0
 8018ada:	6078      	str	r0, [r7, #4]
 8018adc:	460b      	mov	r3, r1
 8018ade:	70fb      	strb	r3, [r7, #3]
  /* Clear configuration and De-initialize the Class process */
  if (pdev->pClass != NULL)
 8018ae0:	687b      	ldr	r3, [r7, #4]
 8018ae2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018ae6:	2b00      	cmp	r3, #0
 8018ae8:	d007      	beq.n	8018afa <USBD_ClrClassConfig+0x26>
  {
    pdev->pClass->DeInit(pdev, cfgidx);
 8018aea:	687b      	ldr	r3, [r7, #4]
 8018aec:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018af0:	685b      	ldr	r3, [r3, #4]
 8018af2:	78fa      	ldrb	r2, [r7, #3]
 8018af4:	4611      	mov	r1, r2
 8018af6:	6878      	ldr	r0, [r7, #4]
 8018af8:	4798      	blx	r3
  }

  return USBD_OK;
 8018afa:	2300      	movs	r3, #0
}
 8018afc:	4618      	mov	r0, r3
 8018afe:	3708      	adds	r7, #8
 8018b00:	46bd      	mov	sp, r7
 8018b02:	bd80      	pop	{r7, pc}

08018b04 <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8018b04:	b580      	push	{r7, lr}
 8018b06:	b084      	sub	sp, #16
 8018b08:	af00      	add	r7, sp, #0
 8018b0a:	6078      	str	r0, [r7, #4]
 8018b0c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8018b0e:	687b      	ldr	r3, [r7, #4]
 8018b10:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8018b14:	6839      	ldr	r1, [r7, #0]
 8018b16:	4618      	mov	r0, r3
 8018b18:	f000 ff46 	bl	80199a8 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8018b1c:	687b      	ldr	r3, [r7, #4]
 8018b1e:	2201      	movs	r2, #1
 8018b20:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 8018b24:	687b      	ldr	r3, [r7, #4]
 8018b26:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	; 0x2b0
 8018b2a:	461a      	mov	r2, r3
 8018b2c:	687b      	ldr	r3, [r7, #4]
 8018b2e:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 8018b32:	687b      	ldr	r3, [r7, #4]
 8018b34:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 8018b38:	f003 031f 	and.w	r3, r3, #31
 8018b3c:	2b02      	cmp	r3, #2
 8018b3e:	d01a      	beq.n	8018b76 <USBD_LL_SetupStage+0x72>
 8018b40:	2b02      	cmp	r3, #2
 8018b42:	d822      	bhi.n	8018b8a <USBD_LL_SetupStage+0x86>
 8018b44:	2b00      	cmp	r3, #0
 8018b46:	d002      	beq.n	8018b4e <USBD_LL_SetupStage+0x4a>
 8018b48:	2b01      	cmp	r3, #1
 8018b4a:	d00a      	beq.n	8018b62 <USBD_LL_SetupStage+0x5e>
 8018b4c:	e01d      	b.n	8018b8a <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8018b4e:	687b      	ldr	r3, [r7, #4]
 8018b50:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8018b54:	4619      	mov	r1, r3
 8018b56:	6878      	ldr	r0, [r7, #4]
 8018b58:	f000 f9ee 	bl	8018f38 <USBD_StdDevReq>
 8018b5c:	4603      	mov	r3, r0
 8018b5e:	73fb      	strb	r3, [r7, #15]
      break;
 8018b60:	e020      	b.n	8018ba4 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8018b62:	687b      	ldr	r3, [r7, #4]
 8018b64:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8018b68:	4619      	mov	r1, r3
 8018b6a:	6878      	ldr	r0, [r7, #4]
 8018b6c:	f000 fa52 	bl	8019014 <USBD_StdItfReq>
 8018b70:	4603      	mov	r3, r0
 8018b72:	73fb      	strb	r3, [r7, #15]
      break;
 8018b74:	e016      	b.n	8018ba4 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8018b76:	687b      	ldr	r3, [r7, #4]
 8018b78:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8018b7c:	4619      	mov	r1, r3
 8018b7e:	6878      	ldr	r0, [r7, #4]
 8018b80:	f000 fa91 	bl	80190a6 <USBD_StdEPReq>
 8018b84:	4603      	mov	r3, r0
 8018b86:	73fb      	strb	r3, [r7, #15]
      break;
 8018b88:	e00c      	b.n	8018ba4 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8018b8a:	687b      	ldr	r3, [r7, #4]
 8018b8c:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 8018b90:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8018b94:	b2db      	uxtb	r3, r3
 8018b96:	4619      	mov	r1, r3
 8018b98:	6878      	ldr	r0, [r7, #4]
 8018b9a:	f010 f9b1 	bl	8028f00 <USBD_LL_StallEP>
 8018b9e:	4603      	mov	r3, r0
 8018ba0:	73fb      	strb	r3, [r7, #15]
      break;
 8018ba2:	bf00      	nop
  }

  return ret;
 8018ba4:	7bfb      	ldrb	r3, [r7, #15]
}
 8018ba6:	4618      	mov	r0, r3
 8018ba8:	3710      	adds	r7, #16
 8018baa:	46bd      	mov	sp, r7
 8018bac:	bd80      	pop	{r7, pc}

08018bae <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8018bae:	b580      	push	{r7, lr}
 8018bb0:	b086      	sub	sp, #24
 8018bb2:	af00      	add	r7, sp, #0
 8018bb4:	60f8      	str	r0, [r7, #12]
 8018bb6:	460b      	mov	r3, r1
 8018bb8:	607a      	str	r2, [r7, #4]
 8018bba:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 8018bbc:	7afb      	ldrb	r3, [r7, #11]
 8018bbe:	2b00      	cmp	r3, #0
 8018bc0:	d138      	bne.n	8018c34 <USBD_LL_DataOutStage+0x86>
  {
    pep = &pdev->ep_out[0];
 8018bc2:	68fb      	ldr	r3, [r7, #12]
 8018bc4:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 8018bc8:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8018bca:	68fb      	ldr	r3, [r7, #12]
 8018bcc:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8018bd0:	2b03      	cmp	r3, #3
 8018bd2:	d14a      	bne.n	8018c6a <USBD_LL_DataOutStage+0xbc>
    {
      if (pep->rem_length > pep->maxpacket)
 8018bd4:	693b      	ldr	r3, [r7, #16]
 8018bd6:	689a      	ldr	r2, [r3, #8]
 8018bd8:	693b      	ldr	r3, [r7, #16]
 8018bda:	68db      	ldr	r3, [r3, #12]
 8018bdc:	429a      	cmp	r2, r3
 8018bde:	d913      	bls.n	8018c08 <USBD_LL_DataOutStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 8018be0:	693b      	ldr	r3, [r7, #16]
 8018be2:	689a      	ldr	r2, [r3, #8]
 8018be4:	693b      	ldr	r3, [r7, #16]
 8018be6:	68db      	ldr	r3, [r3, #12]
 8018be8:	1ad2      	subs	r2, r2, r3
 8018bea:	693b      	ldr	r3, [r7, #16]
 8018bec:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 8018bee:	693b      	ldr	r3, [r7, #16]
 8018bf0:	68da      	ldr	r2, [r3, #12]
 8018bf2:	693b      	ldr	r3, [r7, #16]
 8018bf4:	689b      	ldr	r3, [r3, #8]
 8018bf6:	4293      	cmp	r3, r2
 8018bf8:	bf28      	it	cs
 8018bfa:	4613      	movcs	r3, r2
 8018bfc:	461a      	mov	r2, r3
 8018bfe:	6879      	ldr	r1, [r7, #4]
 8018c00:	68f8      	ldr	r0, [r7, #12]
 8018c02:	f000 ffc5 	bl	8019b90 <USBD_CtlContinueRx>
 8018c06:	e030      	b.n	8018c6a <USBD_LL_DataOutStage+0xbc>
      }
      else
      {
        if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018c08:	68fb      	ldr	r3, [r7, #12]
 8018c0a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018c0e:	b2db      	uxtb	r3, r3
 8018c10:	2b03      	cmp	r3, #3
 8018c12:	d10b      	bne.n	8018c2c <USBD_LL_DataOutStage+0x7e>
        {
          if (pdev->pClass->EP0_RxReady != NULL)
 8018c14:	68fb      	ldr	r3, [r7, #12]
 8018c16:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018c1a:	691b      	ldr	r3, [r3, #16]
 8018c1c:	2b00      	cmp	r3, #0
 8018c1e:	d005      	beq.n	8018c2c <USBD_LL_DataOutStage+0x7e>
          {
            pdev->pClass->EP0_RxReady(pdev);
 8018c20:	68fb      	ldr	r3, [r7, #12]
 8018c22:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018c26:	691b      	ldr	r3, [r3, #16]
 8018c28:	68f8      	ldr	r0, [r7, #12]
 8018c2a:	4798      	blx	r3
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 8018c2c:	68f8      	ldr	r0, [r7, #12]
 8018c2e:	f000 ffc0 	bl	8019bb2 <USBD_CtlSendStatus>
 8018c32:	e01a      	b.n	8018c6a <USBD_LL_DataOutStage+0xbc>
#endif
    }
  }
  else
  {
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018c34:	68fb      	ldr	r3, [r7, #12]
 8018c36:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018c3a:	b2db      	uxtb	r3, r3
 8018c3c:	2b03      	cmp	r3, #3
 8018c3e:	d114      	bne.n	8018c6a <USBD_LL_DataOutStage+0xbc>
    {
      if (pdev->pClass->DataOut != NULL)
 8018c40:	68fb      	ldr	r3, [r7, #12]
 8018c42:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018c46:	699b      	ldr	r3, [r3, #24]
 8018c48:	2b00      	cmp	r3, #0
 8018c4a:	d00e      	beq.n	8018c6a <USBD_LL_DataOutStage+0xbc>
      {
        ret = (USBD_StatusTypeDef)pdev->pClass->DataOut(pdev, epnum);
 8018c4c:	68fb      	ldr	r3, [r7, #12]
 8018c4e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018c52:	699b      	ldr	r3, [r3, #24]
 8018c54:	7afa      	ldrb	r2, [r7, #11]
 8018c56:	4611      	mov	r1, r2
 8018c58:	68f8      	ldr	r0, [r7, #12]
 8018c5a:	4798      	blx	r3
 8018c5c:	4603      	mov	r3, r0
 8018c5e:	75fb      	strb	r3, [r7, #23]

        if (ret != USBD_OK)
 8018c60:	7dfb      	ldrb	r3, [r7, #23]
 8018c62:	2b00      	cmp	r3, #0
 8018c64:	d001      	beq.n	8018c6a <USBD_LL_DataOutStage+0xbc>
        {
          return ret;
 8018c66:	7dfb      	ldrb	r3, [r7, #23]
 8018c68:	e000      	b.n	8018c6c <USBD_LL_DataOutStage+0xbe>
        }
      }
    }
  }

  return USBD_OK;
 8018c6a:	2300      	movs	r3, #0
}
 8018c6c:	4618      	mov	r0, r3
 8018c6e:	3718      	adds	r7, #24
 8018c70:	46bd      	mov	sp, r7
 8018c72:	bd80      	pop	{r7, pc}

08018c74 <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8018c74:	b580      	push	{r7, lr}
 8018c76:	b086      	sub	sp, #24
 8018c78:	af00      	add	r7, sp, #0
 8018c7a:	60f8      	str	r0, [r7, #12]
 8018c7c:	460b      	mov	r3, r1
 8018c7e:	607a      	str	r2, [r7, #4]
 8018c80:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 8018c82:	7afb      	ldrb	r3, [r7, #11]
 8018c84:	2b00      	cmp	r3, #0
 8018c86:	d16b      	bne.n	8018d60 <USBD_LL_DataInStage+0xec>
  {
    pep = &pdev->ep_in[0];
 8018c88:	68fb      	ldr	r3, [r7, #12]
 8018c8a:	3314      	adds	r3, #20
 8018c8c:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 8018c8e:	68fb      	ldr	r3, [r7, #12]
 8018c90:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8018c94:	2b02      	cmp	r3, #2
 8018c96:	d156      	bne.n	8018d46 <USBD_LL_DataInStage+0xd2>
    {
      if (pep->rem_length > pep->maxpacket)
 8018c98:	693b      	ldr	r3, [r7, #16]
 8018c9a:	689a      	ldr	r2, [r3, #8]
 8018c9c:	693b      	ldr	r3, [r7, #16]
 8018c9e:	68db      	ldr	r3, [r3, #12]
 8018ca0:	429a      	cmp	r2, r3
 8018ca2:	d914      	bls.n	8018cce <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 8018ca4:	693b      	ldr	r3, [r7, #16]
 8018ca6:	689a      	ldr	r2, [r3, #8]
 8018ca8:	693b      	ldr	r3, [r7, #16]
 8018caa:	68db      	ldr	r3, [r3, #12]
 8018cac:	1ad2      	subs	r2, r2, r3
 8018cae:	693b      	ldr	r3, [r7, #16]
 8018cb0:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 8018cb2:	693b      	ldr	r3, [r7, #16]
 8018cb4:	689b      	ldr	r3, [r3, #8]
 8018cb6:	461a      	mov	r2, r3
 8018cb8:	6879      	ldr	r1, [r7, #4]
 8018cba:	68f8      	ldr	r0, [r7, #12]
 8018cbc:	f000 ff3a 	bl	8019b34 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8018cc0:	2300      	movs	r3, #0
 8018cc2:	2200      	movs	r2, #0
 8018cc4:	2100      	movs	r1, #0
 8018cc6:	68f8      	ldr	r0, [r7, #12]
 8018cc8:	f010 f9c5 	bl	8029056 <USBD_LL_PrepareReceive>
 8018ccc:	e03b      	b.n	8018d46 <USBD_LL_DataInStage+0xd2>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 8018cce:	693b      	ldr	r3, [r7, #16]
 8018cd0:	68da      	ldr	r2, [r3, #12]
 8018cd2:	693b      	ldr	r3, [r7, #16]
 8018cd4:	689b      	ldr	r3, [r3, #8]
 8018cd6:	429a      	cmp	r2, r3
 8018cd8:	d11c      	bne.n	8018d14 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 8018cda:	693b      	ldr	r3, [r7, #16]
 8018cdc:	685a      	ldr	r2, [r3, #4]
 8018cde:	693b      	ldr	r3, [r7, #16]
 8018ce0:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 8018ce2:	429a      	cmp	r2, r3
 8018ce4:	d316      	bcc.n	8018d14 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 8018ce6:	693b      	ldr	r3, [r7, #16]
 8018ce8:	685a      	ldr	r2, [r3, #4]
 8018cea:	68fb      	ldr	r3, [r7, #12]
 8018cec:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 8018cf0:	429a      	cmp	r2, r3
 8018cf2:	d20f      	bcs.n	8018d14 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 8018cf4:	2200      	movs	r2, #0
 8018cf6:	2100      	movs	r1, #0
 8018cf8:	68f8      	ldr	r0, [r7, #12]
 8018cfa:	f000 ff1b 	bl	8019b34 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 8018cfe:	68fb      	ldr	r3, [r7, #12]
 8018d00:	2200      	movs	r2, #0
 8018d02:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8018d06:	2300      	movs	r3, #0
 8018d08:	2200      	movs	r2, #0
 8018d0a:	2100      	movs	r1, #0
 8018d0c:	68f8      	ldr	r0, [r7, #12]
 8018d0e:	f010 f9a2 	bl	8029056 <USBD_LL_PrepareReceive>
 8018d12:	e018      	b.n	8018d46 <USBD_LL_DataInStage+0xd2>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018d14:	68fb      	ldr	r3, [r7, #12]
 8018d16:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018d1a:	b2db      	uxtb	r3, r3
 8018d1c:	2b03      	cmp	r3, #3
 8018d1e:	d10b      	bne.n	8018d38 <USBD_LL_DataInStage+0xc4>
          {
            if (pdev->pClass->EP0_TxSent != NULL)
 8018d20:	68fb      	ldr	r3, [r7, #12]
 8018d22:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018d26:	68db      	ldr	r3, [r3, #12]
 8018d28:	2b00      	cmp	r3, #0
 8018d2a:	d005      	beq.n	8018d38 <USBD_LL_DataInStage+0xc4>
            {
              pdev->pClass->EP0_TxSent(pdev);
 8018d2c:	68fb      	ldr	r3, [r7, #12]
 8018d2e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018d32:	68db      	ldr	r3, [r3, #12]
 8018d34:	68f8      	ldr	r0, [r7, #12]
 8018d36:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8018d38:	2180      	movs	r1, #128	; 0x80
 8018d3a:	68f8      	ldr	r0, [r7, #12]
 8018d3c:	f010 f8e0 	bl	8028f00 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 8018d40:	68f8      	ldr	r0, [r7, #12]
 8018d42:	f000 ff49 	bl	8019bd8 <USBD_CtlReceiveStatus>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode == 1U)
 8018d46:	68fb      	ldr	r3, [r7, #12]
 8018d48:	f893 32a0 	ldrb.w	r3, [r3, #672]	; 0x2a0
 8018d4c:	2b01      	cmp	r3, #1
 8018d4e:	d122      	bne.n	8018d96 <USBD_LL_DataInStage+0x122>
    {
      (void)USBD_RunTestMode(pdev);
 8018d50:	68f8      	ldr	r0, [r7, #12]
 8018d52:	f7ff fe98 	bl	8018a86 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 8018d56:	68fb      	ldr	r3, [r7, #12]
 8018d58:	2200      	movs	r2, #0
 8018d5a:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
 8018d5e:	e01a      	b.n	8018d96 <USBD_LL_DataInStage+0x122>
    }
  }
  else
  {
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018d60:	68fb      	ldr	r3, [r7, #12]
 8018d62:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018d66:	b2db      	uxtb	r3, r3
 8018d68:	2b03      	cmp	r3, #3
 8018d6a:	d114      	bne.n	8018d96 <USBD_LL_DataInStage+0x122>
    {
      if (pdev->pClass->DataIn != NULL)
 8018d6c:	68fb      	ldr	r3, [r7, #12]
 8018d6e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018d72:	695b      	ldr	r3, [r3, #20]
 8018d74:	2b00      	cmp	r3, #0
 8018d76:	d00e      	beq.n	8018d96 <USBD_LL_DataInStage+0x122>
      {
        ret = (USBD_StatusTypeDef)pdev->pClass->DataIn(pdev, epnum);
 8018d78:	68fb      	ldr	r3, [r7, #12]
 8018d7a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018d7e:	695b      	ldr	r3, [r3, #20]
 8018d80:	7afa      	ldrb	r2, [r7, #11]
 8018d82:	4611      	mov	r1, r2
 8018d84:	68f8      	ldr	r0, [r7, #12]
 8018d86:	4798      	blx	r3
 8018d88:	4603      	mov	r3, r0
 8018d8a:	75fb      	strb	r3, [r7, #23]

        if (ret != USBD_OK)
 8018d8c:	7dfb      	ldrb	r3, [r7, #23]
 8018d8e:	2b00      	cmp	r3, #0
 8018d90:	d001      	beq.n	8018d96 <USBD_LL_DataInStage+0x122>
        {
          return ret;
 8018d92:	7dfb      	ldrb	r3, [r7, #23]
 8018d94:	e000      	b.n	8018d98 <USBD_LL_DataInStage+0x124>
        }
      }
    }
  }

  return USBD_OK;
 8018d96:	2300      	movs	r3, #0
}
 8018d98:	4618      	mov	r0, r3
 8018d9a:	3718      	adds	r7, #24
 8018d9c:	46bd      	mov	sp, r7
 8018d9e:	bd80      	pop	{r7, pc}

08018da0 <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8018da0:	b580      	push	{r7, lr}
 8018da2:	b082      	sub	sp, #8
 8018da4:	af00      	add	r7, sp, #0
 8018da6:	6078      	str	r0, [r7, #4]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8018da8:	687b      	ldr	r3, [r7, #4]
 8018daa:	2201      	movs	r2, #1
 8018dac:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 8018db0:	687b      	ldr	r3, [r7, #4]
 8018db2:	2200      	movs	r2, #0
 8018db4:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->dev_config = 0U;
 8018db8:	687b      	ldr	r3, [r7, #4]
 8018dba:	2200      	movs	r2, #0
 8018dbc:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 8018dbe:	687b      	ldr	r3, [r7, #4]
 8018dc0:	2200      	movs	r2, #0
 8018dc2:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4

  if (pdev->pClass == NULL)
 8018dc6:	687b      	ldr	r3, [r7, #4]
 8018dc8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018dcc:	2b00      	cmp	r3, #0
 8018dce:	d101      	bne.n	8018dd4 <USBD_LL_Reset+0x34>
  {
    return USBD_FAIL;
 8018dd0:	2303      	movs	r3, #3
 8018dd2:	e02f      	b.n	8018e34 <USBD_LL_Reset+0x94>
  }

  if (pdev->pClassData != NULL)
 8018dd4:	687b      	ldr	r3, [r7, #4]
 8018dd6:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8018dda:	2b00      	cmp	r3, #0
 8018ddc:	d00f      	beq.n	8018dfe <USBD_LL_Reset+0x5e>
  {
    if (pdev->pClass->DeInit != NULL)
 8018dde:	687b      	ldr	r3, [r7, #4]
 8018de0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018de4:	685b      	ldr	r3, [r3, #4]
 8018de6:	2b00      	cmp	r3, #0
 8018de8:	d009      	beq.n	8018dfe <USBD_LL_Reset+0x5e>
    {
      (void)pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8018dea:	687b      	ldr	r3, [r7, #4]
 8018dec:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018df0:	685b      	ldr	r3, [r3, #4]
 8018df2:	687a      	ldr	r2, [r7, #4]
 8018df4:	6852      	ldr	r2, [r2, #4]
 8018df6:	b2d2      	uxtb	r2, r2
 8018df8:	4611      	mov	r1, r2
 8018dfa:	6878      	ldr	r0, [r7, #4]
 8018dfc:	4798      	blx	r3
    }
  }

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8018dfe:	2340      	movs	r3, #64	; 0x40
 8018e00:	2200      	movs	r2, #0
 8018e02:	2100      	movs	r1, #0
 8018e04:	6878      	ldr	r0, [r7, #4]
 8018e06:	f010 f836 	bl	8028e76 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8018e0a:	687b      	ldr	r3, [r7, #4]
 8018e0c:	2201      	movs	r2, #1
 8018e0e:	f8a3 2164 	strh.w	r2, [r3, #356]	; 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8018e12:	687b      	ldr	r3, [r7, #4]
 8018e14:	2240      	movs	r2, #64	; 0x40
 8018e16:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8018e1a:	2340      	movs	r3, #64	; 0x40
 8018e1c:	2200      	movs	r2, #0
 8018e1e:	2180      	movs	r1, #128	; 0x80
 8018e20:	6878      	ldr	r0, [r7, #4]
 8018e22:	f010 f828 	bl	8028e76 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8018e26:	687b      	ldr	r3, [r7, #4]
 8018e28:	2201      	movs	r2, #1
 8018e2a:	849a      	strh	r2, [r3, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8018e2c:	687b      	ldr	r3, [r7, #4]
 8018e2e:	2240      	movs	r2, #64	; 0x40
 8018e30:	621a      	str	r2, [r3, #32]

  return USBD_OK;
 8018e32:	2300      	movs	r3, #0
}
 8018e34:	4618      	mov	r0, r3
 8018e36:	3708      	adds	r7, #8
 8018e38:	46bd      	mov	sp, r7
 8018e3a:	bd80      	pop	{r7, pc}

08018e3c <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 8018e3c:	b480      	push	{r7}
 8018e3e:	b083      	sub	sp, #12
 8018e40:	af00      	add	r7, sp, #0
 8018e42:	6078      	str	r0, [r7, #4]
 8018e44:	460b      	mov	r3, r1
 8018e46:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8018e48:	687b      	ldr	r3, [r7, #4]
 8018e4a:	78fa      	ldrb	r2, [r7, #3]
 8018e4c:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 8018e4e:	2300      	movs	r3, #0
}
 8018e50:	4618      	mov	r0, r3
 8018e52:	370c      	adds	r7, #12
 8018e54:	46bd      	mov	sp, r7
 8018e56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018e5a:	4770      	bx	lr

08018e5c <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 8018e5c:	b480      	push	{r7}
 8018e5e:	b083      	sub	sp, #12
 8018e60:	af00      	add	r7, sp, #0
 8018e62:	6078      	str	r0, [r7, #4]
  pdev->dev_old_state = pdev->dev_state;
 8018e64:	687b      	ldr	r3, [r7, #4]
 8018e66:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018e6a:	b2da      	uxtb	r2, r3
 8018e6c:	687b      	ldr	r3, [r7, #4]
 8018e6e:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
  pdev->dev_state = USBD_STATE_SUSPENDED;
 8018e72:	687b      	ldr	r3, [r7, #4]
 8018e74:	2204      	movs	r2, #4
 8018e76:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c

  return USBD_OK;
 8018e7a:	2300      	movs	r3, #0
}
 8018e7c:	4618      	mov	r0, r3
 8018e7e:	370c      	adds	r7, #12
 8018e80:	46bd      	mov	sp, r7
 8018e82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018e86:	4770      	bx	lr

08018e88 <USBD_LL_Resume>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 8018e88:	b480      	push	{r7}
 8018e8a:	b083      	sub	sp, #12
 8018e8c:	af00      	add	r7, sp, #0
 8018e8e:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8018e90:	687b      	ldr	r3, [r7, #4]
 8018e92:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018e96:	b2db      	uxtb	r3, r3
 8018e98:	2b04      	cmp	r3, #4
 8018e9a:	d106      	bne.n	8018eaa <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 8018e9c:	687b      	ldr	r3, [r7, #4]
 8018e9e:	f893 329d 	ldrb.w	r3, [r3, #669]	; 0x29d
 8018ea2:	b2da      	uxtb	r2, r3
 8018ea4:	687b      	ldr	r3, [r7, #4]
 8018ea6:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  }

  return USBD_OK;
 8018eaa:	2300      	movs	r3, #0
}
 8018eac:	4618      	mov	r0, r3
 8018eae:	370c      	adds	r7, #12
 8018eb0:	46bd      	mov	sp, r7
 8018eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018eb6:	4770      	bx	lr

08018eb8 <USBD_LL_SOF>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8018eb8:	b580      	push	{r7, lr}
 8018eba:	b082      	sub	sp, #8
 8018ebc:	af00      	add	r7, sp, #0
 8018ebe:	6078      	str	r0, [r7, #4]
  if (pdev->pClass == NULL)
 8018ec0:	687b      	ldr	r3, [r7, #4]
 8018ec2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018ec6:	2b00      	cmp	r3, #0
 8018ec8:	d101      	bne.n	8018ece <USBD_LL_SOF+0x16>
  {
    return USBD_FAIL;
 8018eca:	2303      	movs	r3, #3
 8018ecc:	e012      	b.n	8018ef4 <USBD_LL_SOF+0x3c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8018ece:	687b      	ldr	r3, [r7, #4]
 8018ed0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8018ed4:	b2db      	uxtb	r3, r3
 8018ed6:	2b03      	cmp	r3, #3
 8018ed8:	d10b      	bne.n	8018ef2 <USBD_LL_SOF+0x3a>
  {
    if (pdev->pClass->SOF != NULL)
 8018eda:	687b      	ldr	r3, [r7, #4]
 8018edc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018ee0:	69db      	ldr	r3, [r3, #28]
 8018ee2:	2b00      	cmp	r3, #0
 8018ee4:	d005      	beq.n	8018ef2 <USBD_LL_SOF+0x3a>
    {
      (void)pdev->pClass->SOF(pdev);
 8018ee6:	687b      	ldr	r3, [r7, #4]
 8018ee8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018eec:	69db      	ldr	r3, [r3, #28]
 8018eee:	6878      	ldr	r0, [r7, #4]
 8018ef0:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8018ef2:	2300      	movs	r3, #0
}
 8018ef4:	4618      	mov	r0, r3
 8018ef6:	3708      	adds	r7, #8
 8018ef8:	46bd      	mov	sp, r7
 8018efa:	bd80      	pop	{r7, pc}

08018efc <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 8018efc:	b480      	push	{r7}
 8018efe:	b087      	sub	sp, #28
 8018f00:	af00      	add	r7, sp, #0
 8018f02:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal, _Byte1, _Byte2;
  uint8_t *_pbuff = addr;
 8018f04:	687b      	ldr	r3, [r7, #4]
 8018f06:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8018f08:	697b      	ldr	r3, [r7, #20]
 8018f0a:	781b      	ldrb	r3, [r3, #0]
 8018f0c:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 8018f0e:	697b      	ldr	r3, [r7, #20]
 8018f10:	3301      	adds	r3, #1
 8018f12:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8018f14:	697b      	ldr	r3, [r7, #20]
 8018f16:	781b      	ldrb	r3, [r3, #0]
 8018f18:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8018f1a:	8a3b      	ldrh	r3, [r7, #16]
 8018f1c:	021b      	lsls	r3, r3, #8
 8018f1e:	b21a      	sxth	r2, r3
 8018f20:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018f24:	4313      	orrs	r3, r2
 8018f26:	b21b      	sxth	r3, r3
 8018f28:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8018f2a:	89fb      	ldrh	r3, [r7, #14]
}
 8018f2c:	4618      	mov	r0, r3
 8018f2e:	371c      	adds	r7, #28
 8018f30:	46bd      	mov	sp, r7
 8018f32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018f36:	4770      	bx	lr

08018f38 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8018f38:	b580      	push	{r7, lr}
 8018f3a:	b084      	sub	sp, #16
 8018f3c:	af00      	add	r7, sp, #0
 8018f3e:	6078      	str	r0, [r7, #4]
 8018f40:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8018f42:	2300      	movs	r3, #0
 8018f44:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8018f46:	683b      	ldr	r3, [r7, #0]
 8018f48:	781b      	ldrb	r3, [r3, #0]
 8018f4a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8018f4e:	2b40      	cmp	r3, #64	; 0x40
 8018f50:	d005      	beq.n	8018f5e <USBD_StdDevReq+0x26>
 8018f52:	2b40      	cmp	r3, #64	; 0x40
 8018f54:	d853      	bhi.n	8018ffe <USBD_StdDevReq+0xc6>
 8018f56:	2b00      	cmp	r3, #0
 8018f58:	d00b      	beq.n	8018f72 <USBD_StdDevReq+0x3a>
 8018f5a:	2b20      	cmp	r3, #32
 8018f5c:	d14f      	bne.n	8018ffe <USBD_StdDevReq+0xc6>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8018f5e:	687b      	ldr	r3, [r7, #4]
 8018f60:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8018f64:	689b      	ldr	r3, [r3, #8]
 8018f66:	6839      	ldr	r1, [r7, #0]
 8018f68:	6878      	ldr	r0, [r7, #4]
 8018f6a:	4798      	blx	r3
 8018f6c:	4603      	mov	r3, r0
 8018f6e:	73fb      	strb	r3, [r7, #15]
      break;
 8018f70:	e04a      	b.n	8019008 <USBD_StdDevReq+0xd0>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8018f72:	683b      	ldr	r3, [r7, #0]
 8018f74:	785b      	ldrb	r3, [r3, #1]
 8018f76:	2b09      	cmp	r3, #9
 8018f78:	d83b      	bhi.n	8018ff2 <USBD_StdDevReq+0xba>
 8018f7a:	a201      	add	r2, pc, #4	; (adr r2, 8018f80 <USBD_StdDevReq+0x48>)
 8018f7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018f80:	08018fd5 	.word	0x08018fd5
 8018f84:	08018fe9 	.word	0x08018fe9
 8018f88:	08018ff3 	.word	0x08018ff3
 8018f8c:	08018fdf 	.word	0x08018fdf
 8018f90:	08018ff3 	.word	0x08018ff3
 8018f94:	08018fb3 	.word	0x08018fb3
 8018f98:	08018fa9 	.word	0x08018fa9
 8018f9c:	08018ff3 	.word	0x08018ff3
 8018fa0:	08018fcb 	.word	0x08018fcb
 8018fa4:	08018fbd 	.word	0x08018fbd
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 8018fa8:	6839      	ldr	r1, [r7, #0]
 8018faa:	6878      	ldr	r0, [r7, #4]
 8018fac:	f000 f9de 	bl	801936c <USBD_GetDescriptor>
          break;
 8018fb0:	e024      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 8018fb2:	6839      	ldr	r1, [r7, #0]
 8018fb4:	6878      	ldr	r0, [r7, #4]
 8018fb6:	f000 fb6d 	bl	8019694 <USBD_SetAddress>
          break;
 8018fba:	e01f      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 8018fbc:	6839      	ldr	r1, [r7, #0]
 8018fbe:	6878      	ldr	r0, [r7, #4]
 8018fc0:	f000 fbac 	bl	801971c <USBD_SetConfig>
 8018fc4:	4603      	mov	r3, r0
 8018fc6:	73fb      	strb	r3, [r7, #15]
          break;
 8018fc8:	e018      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 8018fca:	6839      	ldr	r1, [r7, #0]
 8018fcc:	6878      	ldr	r0, [r7, #4]
 8018fce:	f000 fc4b 	bl	8019868 <USBD_GetConfig>
          break;
 8018fd2:	e013      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 8018fd4:	6839      	ldr	r1, [r7, #0]
 8018fd6:	6878      	ldr	r0, [r7, #4]
 8018fd8:	f000 fc7c 	bl	80198d4 <USBD_GetStatus>
          break;
 8018fdc:	e00e      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 8018fde:	6839      	ldr	r1, [r7, #0]
 8018fe0:	6878      	ldr	r0, [r7, #4]
 8018fe2:	f000 fcab 	bl	801993c <USBD_SetFeature>
          break;
 8018fe6:	e009      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8018fe8:	6839      	ldr	r1, [r7, #0]
 8018fea:	6878      	ldr	r0, [r7, #4]
 8018fec:	f000 fcba 	bl	8019964 <USBD_ClrFeature>
          break;
 8018ff0:	e004      	b.n	8018ffc <USBD_StdDevReq+0xc4>

        default:
          USBD_CtlError(pdev, req);
 8018ff2:	6839      	ldr	r1, [r7, #0]
 8018ff4:	6878      	ldr	r0, [r7, #4]
 8018ff6:	f000 fd11 	bl	8019a1c <USBD_CtlError>
          break;
 8018ffa:	bf00      	nop
      }
      break;
 8018ffc:	e004      	b.n	8019008 <USBD_StdDevReq+0xd0>

    default:
      USBD_CtlError(pdev, req);
 8018ffe:	6839      	ldr	r1, [r7, #0]
 8019000:	6878      	ldr	r0, [r7, #4]
 8019002:	f000 fd0b 	bl	8019a1c <USBD_CtlError>
      break;
 8019006:	bf00      	nop
  }

  return ret;
 8019008:	7bfb      	ldrb	r3, [r7, #15]
}
 801900a:	4618      	mov	r0, r3
 801900c:	3710      	adds	r7, #16
 801900e:	46bd      	mov	sp, r7
 8019010:	bd80      	pop	{r7, pc}
 8019012:	bf00      	nop

08019014 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019014:	b580      	push	{r7, lr}
 8019016:	b084      	sub	sp, #16
 8019018:	af00      	add	r7, sp, #0
 801901a:	6078      	str	r0, [r7, #4]
 801901c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801901e:	2300      	movs	r3, #0
 8019020:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8019022:	683b      	ldr	r3, [r7, #0]
 8019024:	781b      	ldrb	r3, [r3, #0]
 8019026:	f003 0360 	and.w	r3, r3, #96	; 0x60
 801902a:	2b40      	cmp	r3, #64	; 0x40
 801902c:	d005      	beq.n	801903a <USBD_StdItfReq+0x26>
 801902e:	2b40      	cmp	r3, #64	; 0x40
 8019030:	d82f      	bhi.n	8019092 <USBD_StdItfReq+0x7e>
 8019032:	2b00      	cmp	r3, #0
 8019034:	d001      	beq.n	801903a <USBD_StdItfReq+0x26>
 8019036:	2b20      	cmp	r3, #32
 8019038:	d12b      	bne.n	8019092 <USBD_StdItfReq+0x7e>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 801903a:	687b      	ldr	r3, [r7, #4]
 801903c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8019040:	b2db      	uxtb	r3, r3
 8019042:	3b01      	subs	r3, #1
 8019044:	2b02      	cmp	r3, #2
 8019046:	d81d      	bhi.n	8019084 <USBD_StdItfReq+0x70>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8019048:	683b      	ldr	r3, [r7, #0]
 801904a:	889b      	ldrh	r3, [r3, #4]
 801904c:	b2db      	uxtb	r3, r3
 801904e:	2b01      	cmp	r3, #1
 8019050:	d813      	bhi.n	801907a <USBD_StdItfReq+0x66>
          {
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8019052:	687b      	ldr	r3, [r7, #4]
 8019054:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8019058:	689b      	ldr	r3, [r3, #8]
 801905a:	6839      	ldr	r1, [r7, #0]
 801905c:	6878      	ldr	r0, [r7, #4]
 801905e:	4798      	blx	r3
 8019060:	4603      	mov	r3, r0
 8019062:	73fb      	strb	r3, [r7, #15]

            if ((req->wLength == 0U) && (ret == USBD_OK))
 8019064:	683b      	ldr	r3, [r7, #0]
 8019066:	88db      	ldrh	r3, [r3, #6]
 8019068:	2b00      	cmp	r3, #0
 801906a:	d110      	bne.n	801908e <USBD_StdItfReq+0x7a>
 801906c:	7bfb      	ldrb	r3, [r7, #15]
 801906e:	2b00      	cmp	r3, #0
 8019070:	d10d      	bne.n	801908e <USBD_StdItfReq+0x7a>
            {
              (void)USBD_CtlSendStatus(pdev);
 8019072:	6878      	ldr	r0, [r7, #4]
 8019074:	f000 fd9d 	bl	8019bb2 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 8019078:	e009      	b.n	801908e <USBD_StdItfReq+0x7a>
            USBD_CtlError(pdev, req);
 801907a:	6839      	ldr	r1, [r7, #0]
 801907c:	6878      	ldr	r0, [r7, #4]
 801907e:	f000 fccd 	bl	8019a1c <USBD_CtlError>
          break;
 8019082:	e004      	b.n	801908e <USBD_StdItfReq+0x7a>

        default:
          USBD_CtlError(pdev, req);
 8019084:	6839      	ldr	r1, [r7, #0]
 8019086:	6878      	ldr	r0, [r7, #4]
 8019088:	f000 fcc8 	bl	8019a1c <USBD_CtlError>
          break;
 801908c:	e000      	b.n	8019090 <USBD_StdItfReq+0x7c>
          break;
 801908e:	bf00      	nop
      }
      break;
 8019090:	e004      	b.n	801909c <USBD_StdItfReq+0x88>

    default:
      USBD_CtlError(pdev, req);
 8019092:	6839      	ldr	r1, [r7, #0]
 8019094:	6878      	ldr	r0, [r7, #4]
 8019096:	f000 fcc1 	bl	8019a1c <USBD_CtlError>
      break;
 801909a:	bf00      	nop
  }

  return ret;
 801909c:	7bfb      	ldrb	r3, [r7, #15]
}
 801909e:	4618      	mov	r0, r3
 80190a0:	3710      	adds	r7, #16
 80190a2:	46bd      	mov	sp, r7
 80190a4:	bd80      	pop	{r7, pc}

080190a6 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80190a6:	b580      	push	{r7, lr}
 80190a8:	b084      	sub	sp, #16
 80190aa:	af00      	add	r7, sp, #0
 80190ac:	6078      	str	r0, [r7, #4]
 80190ae:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  USBD_StatusTypeDef ret = USBD_OK;
 80190b0:	2300      	movs	r3, #0
 80190b2:	73fb      	strb	r3, [r7, #15]
  ep_addr = LOBYTE(req->wIndex);
 80190b4:	683b      	ldr	r3, [r7, #0]
 80190b6:	889b      	ldrh	r3, [r3, #4]
 80190b8:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80190ba:	683b      	ldr	r3, [r7, #0]
 80190bc:	781b      	ldrb	r3, [r3, #0]
 80190be:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80190c2:	2b40      	cmp	r3, #64	; 0x40
 80190c4:	d007      	beq.n	80190d6 <USBD_StdEPReq+0x30>
 80190c6:	2b40      	cmp	r3, #64	; 0x40
 80190c8:	f200 8145 	bhi.w	8019356 <USBD_StdEPReq+0x2b0>
 80190cc:	2b00      	cmp	r3, #0
 80190ce:	d00c      	beq.n	80190ea <USBD_StdEPReq+0x44>
 80190d0:	2b20      	cmp	r3, #32
 80190d2:	f040 8140 	bne.w	8019356 <USBD_StdEPReq+0x2b0>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80190d6:	687b      	ldr	r3, [r7, #4]
 80190d8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80190dc:	689b      	ldr	r3, [r3, #8]
 80190de:	6839      	ldr	r1, [r7, #0]
 80190e0:	6878      	ldr	r0, [r7, #4]
 80190e2:	4798      	blx	r3
 80190e4:	4603      	mov	r3, r0
 80190e6:	73fb      	strb	r3, [r7, #15]
      break;
 80190e8:	e13a      	b.n	8019360 <USBD_StdEPReq+0x2ba>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80190ea:	683b      	ldr	r3, [r7, #0]
 80190ec:	785b      	ldrb	r3, [r3, #1]
 80190ee:	2b03      	cmp	r3, #3
 80190f0:	d007      	beq.n	8019102 <USBD_StdEPReq+0x5c>
 80190f2:	2b03      	cmp	r3, #3
 80190f4:	f300 8129 	bgt.w	801934a <USBD_StdEPReq+0x2a4>
 80190f8:	2b00      	cmp	r3, #0
 80190fa:	d07f      	beq.n	80191fc <USBD_StdEPReq+0x156>
 80190fc:	2b01      	cmp	r3, #1
 80190fe:	d03c      	beq.n	801917a <USBD_StdEPReq+0xd4>
 8019100:	e123      	b.n	801934a <USBD_StdEPReq+0x2a4>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 8019102:	687b      	ldr	r3, [r7, #4]
 8019104:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8019108:	b2db      	uxtb	r3, r3
 801910a:	2b02      	cmp	r3, #2
 801910c:	d002      	beq.n	8019114 <USBD_StdEPReq+0x6e>
 801910e:	2b03      	cmp	r3, #3
 8019110:	d016      	beq.n	8019140 <USBD_StdEPReq+0x9a>
 8019112:	e02c      	b.n	801916e <USBD_StdEPReq+0xc8>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8019114:	7bbb      	ldrb	r3, [r7, #14]
 8019116:	2b00      	cmp	r3, #0
 8019118:	d00d      	beq.n	8019136 <USBD_StdEPReq+0x90>
 801911a:	7bbb      	ldrb	r3, [r7, #14]
 801911c:	2b80      	cmp	r3, #128	; 0x80
 801911e:	d00a      	beq.n	8019136 <USBD_StdEPReq+0x90>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8019120:	7bbb      	ldrb	r3, [r7, #14]
 8019122:	4619      	mov	r1, r3
 8019124:	6878      	ldr	r0, [r7, #4]
 8019126:	f00f feeb 	bl	8028f00 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 801912a:	2180      	movs	r1, #128	; 0x80
 801912c:	6878      	ldr	r0, [r7, #4]
 801912e:	f00f fee7 	bl	8028f00 <USBD_LL_StallEP>
 8019132:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8019134:	e020      	b.n	8019178 <USBD_StdEPReq+0xd2>
                USBD_CtlError(pdev, req);
 8019136:	6839      	ldr	r1, [r7, #0]
 8019138:	6878      	ldr	r0, [r7, #4]
 801913a:	f000 fc6f 	bl	8019a1c <USBD_CtlError>
              break;
 801913e:	e01b      	b.n	8019178 <USBD_StdEPReq+0xd2>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8019140:	683b      	ldr	r3, [r7, #0]
 8019142:	885b      	ldrh	r3, [r3, #2]
 8019144:	2b00      	cmp	r3, #0
 8019146:	d10e      	bne.n	8019166 <USBD_StdEPReq+0xc0>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8019148:	7bbb      	ldrb	r3, [r7, #14]
 801914a:	2b00      	cmp	r3, #0
 801914c:	d00b      	beq.n	8019166 <USBD_StdEPReq+0xc0>
 801914e:	7bbb      	ldrb	r3, [r7, #14]
 8019150:	2b80      	cmp	r3, #128	; 0x80
 8019152:	d008      	beq.n	8019166 <USBD_StdEPReq+0xc0>
 8019154:	683b      	ldr	r3, [r7, #0]
 8019156:	88db      	ldrh	r3, [r3, #6]
 8019158:	2b00      	cmp	r3, #0
 801915a:	d104      	bne.n	8019166 <USBD_StdEPReq+0xc0>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 801915c:	7bbb      	ldrb	r3, [r7, #14]
 801915e:	4619      	mov	r1, r3
 8019160:	6878      	ldr	r0, [r7, #4]
 8019162:	f00f fecd 	bl	8028f00 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8019166:	6878      	ldr	r0, [r7, #4]
 8019168:	f000 fd23 	bl	8019bb2 <USBD_CtlSendStatus>

              break;
 801916c:	e004      	b.n	8019178 <USBD_StdEPReq+0xd2>

            default:
              USBD_CtlError(pdev, req);
 801916e:	6839      	ldr	r1, [r7, #0]
 8019170:	6878      	ldr	r0, [r7, #4]
 8019172:	f000 fc53 	bl	8019a1c <USBD_CtlError>
              break;
 8019176:	bf00      	nop
          }
          break;
 8019178:	e0ec      	b.n	8019354 <USBD_StdEPReq+0x2ae>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 801917a:	687b      	ldr	r3, [r7, #4]
 801917c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8019180:	b2db      	uxtb	r3, r3
 8019182:	2b02      	cmp	r3, #2
 8019184:	d002      	beq.n	801918c <USBD_StdEPReq+0xe6>
 8019186:	2b03      	cmp	r3, #3
 8019188:	d016      	beq.n	80191b8 <USBD_StdEPReq+0x112>
 801918a:	e030      	b.n	80191ee <USBD_StdEPReq+0x148>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801918c:	7bbb      	ldrb	r3, [r7, #14]
 801918e:	2b00      	cmp	r3, #0
 8019190:	d00d      	beq.n	80191ae <USBD_StdEPReq+0x108>
 8019192:	7bbb      	ldrb	r3, [r7, #14]
 8019194:	2b80      	cmp	r3, #128	; 0x80
 8019196:	d00a      	beq.n	80191ae <USBD_StdEPReq+0x108>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8019198:	7bbb      	ldrb	r3, [r7, #14]
 801919a:	4619      	mov	r1, r3
 801919c:	6878      	ldr	r0, [r7, #4]
 801919e:	f00f feaf 	bl	8028f00 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 80191a2:	2180      	movs	r1, #128	; 0x80
 80191a4:	6878      	ldr	r0, [r7, #4]
 80191a6:	f00f feab 	bl	8028f00 <USBD_LL_StallEP>
 80191aa:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 80191ac:	e025      	b.n	80191fa <USBD_StdEPReq+0x154>
                USBD_CtlError(pdev, req);
 80191ae:	6839      	ldr	r1, [r7, #0]
 80191b0:	6878      	ldr	r0, [r7, #4]
 80191b2:	f000 fc33 	bl	8019a1c <USBD_CtlError>
              break;
 80191b6:	e020      	b.n	80191fa <USBD_StdEPReq+0x154>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 80191b8:	683b      	ldr	r3, [r7, #0]
 80191ba:	885b      	ldrh	r3, [r3, #2]
 80191bc:	2b00      	cmp	r3, #0
 80191be:	d11b      	bne.n	80191f8 <USBD_StdEPReq+0x152>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 80191c0:	7bbb      	ldrb	r3, [r7, #14]
 80191c2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80191c6:	2b00      	cmp	r3, #0
 80191c8:	d004      	beq.n	80191d4 <USBD_StdEPReq+0x12e>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 80191ca:	7bbb      	ldrb	r3, [r7, #14]
 80191cc:	4619      	mov	r1, r3
 80191ce:	6878      	ldr	r0, [r7, #4]
 80191d0:	f00f feb5 	bl	8028f3e <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 80191d4:	6878      	ldr	r0, [r7, #4]
 80191d6:	f000 fcec 	bl	8019bb2 <USBD_CtlSendStatus>
                ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80191da:	687b      	ldr	r3, [r7, #4]
 80191dc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80191e0:	689b      	ldr	r3, [r3, #8]
 80191e2:	6839      	ldr	r1, [r7, #0]
 80191e4:	6878      	ldr	r0, [r7, #4]
 80191e6:	4798      	blx	r3
 80191e8:	4603      	mov	r3, r0
 80191ea:	73fb      	strb	r3, [r7, #15]
              }
              break;
 80191ec:	e004      	b.n	80191f8 <USBD_StdEPReq+0x152>

            default:
              USBD_CtlError(pdev, req);
 80191ee:	6839      	ldr	r1, [r7, #0]
 80191f0:	6878      	ldr	r0, [r7, #4]
 80191f2:	f000 fc13 	bl	8019a1c <USBD_CtlError>
              break;
 80191f6:	e000      	b.n	80191fa <USBD_StdEPReq+0x154>
              break;
 80191f8:	bf00      	nop
          }
          break;
 80191fa:	e0ab      	b.n	8019354 <USBD_StdEPReq+0x2ae>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 80191fc:	687b      	ldr	r3, [r7, #4]
 80191fe:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8019202:	b2db      	uxtb	r3, r3
 8019204:	2b02      	cmp	r3, #2
 8019206:	d002      	beq.n	801920e <USBD_StdEPReq+0x168>
 8019208:	2b03      	cmp	r3, #3
 801920a:	d032      	beq.n	8019272 <USBD_StdEPReq+0x1cc>
 801920c:	e097      	b.n	801933e <USBD_StdEPReq+0x298>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801920e:	7bbb      	ldrb	r3, [r7, #14]
 8019210:	2b00      	cmp	r3, #0
 8019212:	d007      	beq.n	8019224 <USBD_StdEPReq+0x17e>
 8019214:	7bbb      	ldrb	r3, [r7, #14]
 8019216:	2b80      	cmp	r3, #128	; 0x80
 8019218:	d004      	beq.n	8019224 <USBD_StdEPReq+0x17e>
              {
                USBD_CtlError(pdev, req);
 801921a:	6839      	ldr	r1, [r7, #0]
 801921c:	6878      	ldr	r0, [r7, #4]
 801921e:	f000 fbfd 	bl	8019a1c <USBD_CtlError>
                break;
 8019222:	e091      	b.n	8019348 <USBD_StdEPReq+0x2a2>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8019224:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8019228:	2b00      	cmp	r3, #0
 801922a:	da0b      	bge.n	8019244 <USBD_StdEPReq+0x19e>
 801922c:	7bbb      	ldrb	r3, [r7, #14]
 801922e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8019232:	4613      	mov	r3, r2
 8019234:	009b      	lsls	r3, r3, #2
 8019236:	4413      	add	r3, r2
 8019238:	009b      	lsls	r3, r3, #2
 801923a:	3310      	adds	r3, #16
 801923c:	687a      	ldr	r2, [r7, #4]
 801923e:	4413      	add	r3, r2
 8019240:	3304      	adds	r3, #4
 8019242:	e00b      	b.n	801925c <USBD_StdEPReq+0x1b6>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8019244:	7bbb      	ldrb	r3, [r7, #14]
 8019246:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801924a:	4613      	mov	r3, r2
 801924c:	009b      	lsls	r3, r3, #2
 801924e:	4413      	add	r3, r2
 8019250:	009b      	lsls	r3, r3, #2
 8019252:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8019256:	687a      	ldr	r2, [r7, #4]
 8019258:	4413      	add	r3, r2
 801925a:	3304      	adds	r3, #4
 801925c:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 801925e:	68bb      	ldr	r3, [r7, #8]
 8019260:	2200      	movs	r2, #0
 8019262:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8019264:	68bb      	ldr	r3, [r7, #8]
 8019266:	2202      	movs	r2, #2
 8019268:	4619      	mov	r1, r3
 801926a:	6878      	ldr	r0, [r7, #4]
 801926c:	f000 fc47 	bl	8019afe <USBD_CtlSendData>
              break;
 8019270:	e06a      	b.n	8019348 <USBD_StdEPReq+0x2a2>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 8019272:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8019276:	2b00      	cmp	r3, #0
 8019278:	da11      	bge.n	801929e <USBD_StdEPReq+0x1f8>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801927a:	7bbb      	ldrb	r3, [r7, #14]
 801927c:	f003 020f 	and.w	r2, r3, #15
 8019280:	6879      	ldr	r1, [r7, #4]
 8019282:	4613      	mov	r3, r2
 8019284:	009b      	lsls	r3, r3, #2
 8019286:	4413      	add	r3, r2
 8019288:	009b      	lsls	r3, r3, #2
 801928a:	440b      	add	r3, r1
 801928c:	3324      	adds	r3, #36	; 0x24
 801928e:	881b      	ldrh	r3, [r3, #0]
 8019290:	2b00      	cmp	r3, #0
 8019292:	d117      	bne.n	80192c4 <USBD_StdEPReq+0x21e>
                {
                  USBD_CtlError(pdev, req);
 8019294:	6839      	ldr	r1, [r7, #0]
 8019296:	6878      	ldr	r0, [r7, #4]
 8019298:	f000 fbc0 	bl	8019a1c <USBD_CtlError>
                  break;
 801929c:	e054      	b.n	8019348 <USBD_StdEPReq+0x2a2>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 801929e:	7bbb      	ldrb	r3, [r7, #14]
 80192a0:	f003 020f 	and.w	r2, r3, #15
 80192a4:	6879      	ldr	r1, [r7, #4]
 80192a6:	4613      	mov	r3, r2
 80192a8:	009b      	lsls	r3, r3, #2
 80192aa:	4413      	add	r3, r2
 80192ac:	009b      	lsls	r3, r3, #2
 80192ae:	440b      	add	r3, r1
 80192b0:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 80192b4:	881b      	ldrh	r3, [r3, #0]
 80192b6:	2b00      	cmp	r3, #0
 80192b8:	d104      	bne.n	80192c4 <USBD_StdEPReq+0x21e>
                {
                  USBD_CtlError(pdev, req);
 80192ba:	6839      	ldr	r1, [r7, #0]
 80192bc:	6878      	ldr	r0, [r7, #4]
 80192be:	f000 fbad 	bl	8019a1c <USBD_CtlError>
                  break;
 80192c2:	e041      	b.n	8019348 <USBD_StdEPReq+0x2a2>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80192c4:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80192c8:	2b00      	cmp	r3, #0
 80192ca:	da0b      	bge.n	80192e4 <USBD_StdEPReq+0x23e>
 80192cc:	7bbb      	ldrb	r3, [r7, #14]
 80192ce:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80192d2:	4613      	mov	r3, r2
 80192d4:	009b      	lsls	r3, r3, #2
 80192d6:	4413      	add	r3, r2
 80192d8:	009b      	lsls	r3, r3, #2
 80192da:	3310      	adds	r3, #16
 80192dc:	687a      	ldr	r2, [r7, #4]
 80192de:	4413      	add	r3, r2
 80192e0:	3304      	adds	r3, #4
 80192e2:	e00b      	b.n	80192fc <USBD_StdEPReq+0x256>
                    &pdev->ep_out[ep_addr & 0x7FU];
 80192e4:	7bbb      	ldrb	r3, [r7, #14]
 80192e6:	f003 027f 	and.w	r2, r3, #127	; 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80192ea:	4613      	mov	r3, r2
 80192ec:	009b      	lsls	r3, r3, #2
 80192ee:	4413      	add	r3, r2
 80192f0:	009b      	lsls	r3, r3, #2
 80192f2:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 80192f6:	687a      	ldr	r2, [r7, #4]
 80192f8:	4413      	add	r3, r2
 80192fa:	3304      	adds	r3, #4
 80192fc:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 80192fe:	7bbb      	ldrb	r3, [r7, #14]
 8019300:	2b00      	cmp	r3, #0
 8019302:	d002      	beq.n	801930a <USBD_StdEPReq+0x264>
 8019304:	7bbb      	ldrb	r3, [r7, #14]
 8019306:	2b80      	cmp	r3, #128	; 0x80
 8019308:	d103      	bne.n	8019312 <USBD_StdEPReq+0x26c>
              {
                pep->status = 0x0000U;
 801930a:	68bb      	ldr	r3, [r7, #8]
 801930c:	2200      	movs	r2, #0
 801930e:	601a      	str	r2, [r3, #0]
 8019310:	e00e      	b.n	8019330 <USBD_StdEPReq+0x28a>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8019312:	7bbb      	ldrb	r3, [r7, #14]
 8019314:	4619      	mov	r1, r3
 8019316:	6878      	ldr	r0, [r7, #4]
 8019318:	f00f fe30 	bl	8028f7c <USBD_LL_IsStallEP>
 801931c:	4603      	mov	r3, r0
 801931e:	2b00      	cmp	r3, #0
 8019320:	d003      	beq.n	801932a <USBD_StdEPReq+0x284>
              {
                pep->status = 0x0001U;
 8019322:	68bb      	ldr	r3, [r7, #8]
 8019324:	2201      	movs	r2, #1
 8019326:	601a      	str	r2, [r3, #0]
 8019328:	e002      	b.n	8019330 <USBD_StdEPReq+0x28a>
              }
              else
              {
                pep->status = 0x0000U;
 801932a:	68bb      	ldr	r3, [r7, #8]
 801932c:	2200      	movs	r2, #0
 801932e:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8019330:	68bb      	ldr	r3, [r7, #8]
 8019332:	2202      	movs	r2, #2
 8019334:	4619      	mov	r1, r3
 8019336:	6878      	ldr	r0, [r7, #4]
 8019338:	f000 fbe1 	bl	8019afe <USBD_CtlSendData>
              break;
 801933c:	e004      	b.n	8019348 <USBD_StdEPReq+0x2a2>

            default:
              USBD_CtlError(pdev, req);
 801933e:	6839      	ldr	r1, [r7, #0]
 8019340:	6878      	ldr	r0, [r7, #4]
 8019342:	f000 fb6b 	bl	8019a1c <USBD_CtlError>
              break;
 8019346:	bf00      	nop
          }
          break;
 8019348:	e004      	b.n	8019354 <USBD_StdEPReq+0x2ae>

        default:
          USBD_CtlError(pdev, req);
 801934a:	6839      	ldr	r1, [r7, #0]
 801934c:	6878      	ldr	r0, [r7, #4]
 801934e:	f000 fb65 	bl	8019a1c <USBD_CtlError>
          break;
 8019352:	bf00      	nop
      }
      break;
 8019354:	e004      	b.n	8019360 <USBD_StdEPReq+0x2ba>

    default:
      USBD_CtlError(pdev, req);
 8019356:	6839      	ldr	r1, [r7, #0]
 8019358:	6878      	ldr	r0, [r7, #4]
 801935a:	f000 fb5f 	bl	8019a1c <USBD_CtlError>
      break;
 801935e:	bf00      	nop
  }

  return ret;
 8019360:	7bfb      	ldrb	r3, [r7, #15]
}
 8019362:	4618      	mov	r0, r3
 8019364:	3710      	adds	r7, #16
 8019366:	46bd      	mov	sp, r7
 8019368:	bd80      	pop	{r7, pc}
	...

0801936c <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801936c:	b580      	push	{r7, lr}
 801936e:	b084      	sub	sp, #16
 8019370:	af00      	add	r7, sp, #0
 8019372:	6078      	str	r0, [r7, #4]
 8019374:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8019376:	2300      	movs	r3, #0
 8019378:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 801937a:	2300      	movs	r3, #0
 801937c:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 801937e:	2300      	movs	r3, #0
 8019380:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 8019382:	683b      	ldr	r3, [r7, #0]
 8019384:	885b      	ldrh	r3, [r3, #2]
 8019386:	0a1b      	lsrs	r3, r3, #8
 8019388:	b29b      	uxth	r3, r3
 801938a:	3b01      	subs	r3, #1
 801938c:	2b0e      	cmp	r3, #14
 801938e:	f200 8152 	bhi.w	8019636 <USBD_GetDescriptor+0x2ca>
 8019392:	a201      	add	r2, pc, #4	; (adr r2, 8019398 <USBD_GetDescriptor+0x2c>)
 8019394:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019398:	08019409 	.word	0x08019409
 801939c:	08019421 	.word	0x08019421
 80193a0:	08019461 	.word	0x08019461
 80193a4:	08019637 	.word	0x08019637
 80193a8:	08019637 	.word	0x08019637
 80193ac:	080195d7 	.word	0x080195d7
 80193b0:	08019603 	.word	0x08019603
 80193b4:	08019637 	.word	0x08019637
 80193b8:	08019637 	.word	0x08019637
 80193bc:	08019637 	.word	0x08019637
 80193c0:	08019637 	.word	0x08019637
 80193c4:	08019637 	.word	0x08019637
 80193c8:	08019637 	.word	0x08019637
 80193cc:	08019637 	.word	0x08019637
 80193d0:	080193d5 	.word	0x080193d5
  {
#if ((USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U))
    case USB_DESC_TYPE_BOS:
      if (pdev->pDesc->GetBOSDescriptor != NULL)
 80193d4:	687b      	ldr	r3, [r7, #4]
 80193d6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80193da:	69db      	ldr	r3, [r3, #28]
 80193dc:	2b00      	cmp	r3, #0
 80193de:	d00b      	beq.n	80193f8 <USBD_GetDescriptor+0x8c>
      {
        pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 80193e0:	687b      	ldr	r3, [r7, #4]
 80193e2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80193e6:	69db      	ldr	r3, [r3, #28]
 80193e8:	687a      	ldr	r2, [r7, #4]
 80193ea:	7c12      	ldrb	r2, [r2, #16]
 80193ec:	f107 0108 	add.w	r1, r7, #8
 80193f0:	4610      	mov	r0, r2
 80193f2:	4798      	blx	r3
 80193f4:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 80193f6:	e126      	b.n	8019646 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 80193f8:	6839      	ldr	r1, [r7, #0]
 80193fa:	6878      	ldr	r0, [r7, #4]
 80193fc:	f000 fb0e 	bl	8019a1c <USBD_CtlError>
        err++;
 8019400:	7afb      	ldrb	r3, [r7, #11]
 8019402:	3301      	adds	r3, #1
 8019404:	72fb      	strb	r3, [r7, #11]
      break;
 8019406:	e11e      	b.n	8019646 <USBD_GetDescriptor+0x2da>
#endif
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8019408:	687b      	ldr	r3, [r7, #4]
 801940a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 801940e:	681b      	ldr	r3, [r3, #0]
 8019410:	687a      	ldr	r2, [r7, #4]
 8019412:	7c12      	ldrb	r2, [r2, #16]
 8019414:	f107 0108 	add.w	r1, r7, #8
 8019418:	4610      	mov	r0, r2
 801941a:	4798      	blx	r3
 801941c:	60f8      	str	r0, [r7, #12]
      break;
 801941e:	e112      	b.n	8019646 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8019420:	687b      	ldr	r3, [r7, #4]
 8019422:	7c1b      	ldrb	r3, [r3, #16]
 8019424:	2b00      	cmp	r3, #0
 8019426:	d10d      	bne.n	8019444 <USBD_GetDescriptor+0xd8>
      {
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 8019428:	687b      	ldr	r3, [r7, #4]
 801942a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801942e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019430:	f107 0208 	add.w	r2, r7, #8
 8019434:	4610      	mov	r0, r2
 8019436:	4798      	blx	r3
 8019438:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801943a:	68fb      	ldr	r3, [r7, #12]
 801943c:	3301      	adds	r3, #1
 801943e:	2202      	movs	r2, #2
 8019440:	701a      	strb	r2, [r3, #0]
      else
      {
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 8019442:	e100      	b.n	8019646 <USBD_GetDescriptor+0x2da>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 8019444:	687b      	ldr	r3, [r7, #4]
 8019446:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 801944a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801944c:	f107 0208 	add.w	r2, r7, #8
 8019450:	4610      	mov	r0, r2
 8019452:	4798      	blx	r3
 8019454:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8019456:	68fb      	ldr	r3, [r7, #12]
 8019458:	3301      	adds	r3, #1
 801945a:	2202      	movs	r2, #2
 801945c:	701a      	strb	r2, [r3, #0]
      break;
 801945e:	e0f2      	b.n	8019646 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 8019460:	683b      	ldr	r3, [r7, #0]
 8019462:	885b      	ldrh	r3, [r3, #2]
 8019464:	b2db      	uxtb	r3, r3
 8019466:	2b05      	cmp	r3, #5
 8019468:	f200 80ac 	bhi.w	80195c4 <USBD_GetDescriptor+0x258>
 801946c:	a201      	add	r2, pc, #4	; (adr r2, 8019474 <USBD_GetDescriptor+0x108>)
 801946e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019472:	bf00      	nop
 8019474:	0801948d 	.word	0x0801948d
 8019478:	080194c1 	.word	0x080194c1
 801947c:	080194f5 	.word	0x080194f5
 8019480:	08019529 	.word	0x08019529
 8019484:	0801955d 	.word	0x0801955d
 8019488:	08019591 	.word	0x08019591
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 801948c:	687b      	ldr	r3, [r7, #4]
 801948e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8019492:	685b      	ldr	r3, [r3, #4]
 8019494:	2b00      	cmp	r3, #0
 8019496:	d00b      	beq.n	80194b0 <USBD_GetDescriptor+0x144>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8019498:	687b      	ldr	r3, [r7, #4]
 801949a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 801949e:	685b      	ldr	r3, [r3, #4]
 80194a0:	687a      	ldr	r2, [r7, #4]
 80194a2:	7c12      	ldrb	r2, [r2, #16]
 80194a4:	f107 0108 	add.w	r1, r7, #8
 80194a8:	4610      	mov	r0, r2
 80194aa:	4798      	blx	r3
 80194ac:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80194ae:	e091      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 80194b0:	6839      	ldr	r1, [r7, #0]
 80194b2:	6878      	ldr	r0, [r7, #4]
 80194b4:	f000 fab2 	bl	8019a1c <USBD_CtlError>
            err++;
 80194b8:	7afb      	ldrb	r3, [r7, #11]
 80194ba:	3301      	adds	r3, #1
 80194bc:	72fb      	strb	r3, [r7, #11]
          break;
 80194be:	e089      	b.n	80195d4 <USBD_GetDescriptor+0x268>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 80194c0:	687b      	ldr	r3, [r7, #4]
 80194c2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80194c6:	689b      	ldr	r3, [r3, #8]
 80194c8:	2b00      	cmp	r3, #0
 80194ca:	d00b      	beq.n	80194e4 <USBD_GetDescriptor+0x178>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 80194cc:	687b      	ldr	r3, [r7, #4]
 80194ce:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80194d2:	689b      	ldr	r3, [r3, #8]
 80194d4:	687a      	ldr	r2, [r7, #4]
 80194d6:	7c12      	ldrb	r2, [r2, #16]
 80194d8:	f107 0108 	add.w	r1, r7, #8
 80194dc:	4610      	mov	r0, r2
 80194de:	4798      	blx	r3
 80194e0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80194e2:	e077      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 80194e4:	6839      	ldr	r1, [r7, #0]
 80194e6:	6878      	ldr	r0, [r7, #4]
 80194e8:	f000 fa98 	bl	8019a1c <USBD_CtlError>
            err++;
 80194ec:	7afb      	ldrb	r3, [r7, #11]
 80194ee:	3301      	adds	r3, #1
 80194f0:	72fb      	strb	r3, [r7, #11]
          break;
 80194f2:	e06f      	b.n	80195d4 <USBD_GetDescriptor+0x268>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 80194f4:	687b      	ldr	r3, [r7, #4]
 80194f6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80194fa:	68db      	ldr	r3, [r3, #12]
 80194fc:	2b00      	cmp	r3, #0
 80194fe:	d00b      	beq.n	8019518 <USBD_GetDescriptor+0x1ac>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8019500:	687b      	ldr	r3, [r7, #4]
 8019502:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8019506:	68db      	ldr	r3, [r3, #12]
 8019508:	687a      	ldr	r2, [r7, #4]
 801950a:	7c12      	ldrb	r2, [r2, #16]
 801950c:	f107 0108 	add.w	r1, r7, #8
 8019510:	4610      	mov	r0, r2
 8019512:	4798      	blx	r3
 8019514:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8019516:	e05d      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8019518:	6839      	ldr	r1, [r7, #0]
 801951a:	6878      	ldr	r0, [r7, #4]
 801951c:	f000 fa7e 	bl	8019a1c <USBD_CtlError>
            err++;
 8019520:	7afb      	ldrb	r3, [r7, #11]
 8019522:	3301      	adds	r3, #1
 8019524:	72fb      	strb	r3, [r7, #11]
          break;
 8019526:	e055      	b.n	80195d4 <USBD_GetDescriptor+0x268>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8019528:	687b      	ldr	r3, [r7, #4]
 801952a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 801952e:	691b      	ldr	r3, [r3, #16]
 8019530:	2b00      	cmp	r3, #0
 8019532:	d00b      	beq.n	801954c <USBD_GetDescriptor+0x1e0>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8019534:	687b      	ldr	r3, [r7, #4]
 8019536:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 801953a:	691b      	ldr	r3, [r3, #16]
 801953c:	687a      	ldr	r2, [r7, #4]
 801953e:	7c12      	ldrb	r2, [r2, #16]
 8019540:	f107 0108 	add.w	r1, r7, #8
 8019544:	4610      	mov	r0, r2
 8019546:	4798      	blx	r3
 8019548:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801954a:	e043      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 801954c:	6839      	ldr	r1, [r7, #0]
 801954e:	6878      	ldr	r0, [r7, #4]
 8019550:	f000 fa64 	bl	8019a1c <USBD_CtlError>
            err++;
 8019554:	7afb      	ldrb	r3, [r7, #11]
 8019556:	3301      	adds	r3, #1
 8019558:	72fb      	strb	r3, [r7, #11]
          break;
 801955a:	e03b      	b.n	80195d4 <USBD_GetDescriptor+0x268>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 801955c:	687b      	ldr	r3, [r7, #4]
 801955e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8019562:	695b      	ldr	r3, [r3, #20]
 8019564:	2b00      	cmp	r3, #0
 8019566:	d00b      	beq.n	8019580 <USBD_GetDescriptor+0x214>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8019568:	687b      	ldr	r3, [r7, #4]
 801956a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 801956e:	695b      	ldr	r3, [r3, #20]
 8019570:	687a      	ldr	r2, [r7, #4]
 8019572:	7c12      	ldrb	r2, [r2, #16]
 8019574:	f107 0108 	add.w	r1, r7, #8
 8019578:	4610      	mov	r0, r2
 801957a:	4798      	blx	r3
 801957c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801957e:	e029      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8019580:	6839      	ldr	r1, [r7, #0]
 8019582:	6878      	ldr	r0, [r7, #4]
 8019584:	f000 fa4a 	bl	8019a1c <USBD_CtlError>
            err++;
 8019588:	7afb      	ldrb	r3, [r7, #11]
 801958a:	3301      	adds	r3, #1
 801958c:	72fb      	strb	r3, [r7, #11]
          break;
 801958e:	e021      	b.n	80195d4 <USBD_GetDescriptor+0x268>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8019590:	687b      	ldr	r3, [r7, #4]
 8019592:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8019596:	699b      	ldr	r3, [r3, #24]
 8019598:	2b00      	cmp	r3, #0
 801959a:	d00b      	beq.n	80195b4 <USBD_GetDescriptor+0x248>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 801959c:	687b      	ldr	r3, [r7, #4]
 801959e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 80195a2:	699b      	ldr	r3, [r3, #24]
 80195a4:	687a      	ldr	r2, [r7, #4]
 80195a6:	7c12      	ldrb	r2, [r2, #16]
 80195a8:	f107 0108 	add.w	r1, r7, #8
 80195ac:	4610      	mov	r0, r2
 80195ae:	4798      	blx	r3
 80195b0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 80195b2:	e00f      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 80195b4:	6839      	ldr	r1, [r7, #0]
 80195b6:	6878      	ldr	r0, [r7, #4]
 80195b8:	f000 fa30 	bl	8019a1c <USBD_CtlError>
            err++;
 80195bc:	7afb      	ldrb	r3, [r7, #11]
 80195be:	3301      	adds	r3, #1
 80195c0:	72fb      	strb	r3, [r7, #11]
          break;
 80195c2:	e007      	b.n	80195d4 <USBD_GetDescriptor+0x268>
            err++;
          }
#endif

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 80195c4:	6839      	ldr	r1, [r7, #0]
 80195c6:	6878      	ldr	r0, [r7, #4]
 80195c8:	f000 fa28 	bl	8019a1c <USBD_CtlError>
          err++;
 80195cc:	7afb      	ldrb	r3, [r7, #11]
 80195ce:	3301      	adds	r3, #1
 80195d0:	72fb      	strb	r3, [r7, #11]
#endif
          break;
 80195d2:	bf00      	nop
      }
      break;
 80195d4:	e037      	b.n	8019646 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80195d6:	687b      	ldr	r3, [r7, #4]
 80195d8:	7c1b      	ldrb	r3, [r3, #16]
 80195da:	2b00      	cmp	r3, #0
 80195dc:	d109      	bne.n	80195f2 <USBD_GetDescriptor+0x286>
      {
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 80195de:	687b      	ldr	r3, [r7, #4]
 80195e0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80195e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80195e6:	f107 0208 	add.w	r2, r7, #8
 80195ea:	4610      	mov	r0, r2
 80195ec:	4798      	blx	r3
 80195ee:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 80195f0:	e029      	b.n	8019646 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 80195f2:	6839      	ldr	r1, [r7, #0]
 80195f4:	6878      	ldr	r0, [r7, #4]
 80195f6:	f000 fa11 	bl	8019a1c <USBD_CtlError>
        err++;
 80195fa:	7afb      	ldrb	r3, [r7, #11]
 80195fc:	3301      	adds	r3, #1
 80195fe:	72fb      	strb	r3, [r7, #11]
      break;
 8019600:	e021      	b.n	8019646 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8019602:	687b      	ldr	r3, [r7, #4]
 8019604:	7c1b      	ldrb	r3, [r3, #16]
 8019606:	2b00      	cmp	r3, #0
 8019608:	d10d      	bne.n	8019626 <USBD_GetDescriptor+0x2ba>
      {
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 801960a:	687b      	ldr	r3, [r7, #4]
 801960c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8019610:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8019612:	f107 0208 	add.w	r2, r7, #8
 8019616:	4610      	mov	r0, r2
 8019618:	4798      	blx	r3
 801961a:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 801961c:	68fb      	ldr	r3, [r7, #12]
 801961e:	3301      	adds	r3, #1
 8019620:	2207      	movs	r2, #7
 8019622:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8019624:	e00f      	b.n	8019646 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 8019626:	6839      	ldr	r1, [r7, #0]
 8019628:	6878      	ldr	r0, [r7, #4]
 801962a:	f000 f9f7 	bl	8019a1c <USBD_CtlError>
        err++;
 801962e:	7afb      	ldrb	r3, [r7, #11]
 8019630:	3301      	adds	r3, #1
 8019632:	72fb      	strb	r3, [r7, #11]
      break;
 8019634:	e007      	b.n	8019646 <USBD_GetDescriptor+0x2da>

    default:
      USBD_CtlError(pdev, req);
 8019636:	6839      	ldr	r1, [r7, #0]
 8019638:	6878      	ldr	r0, [r7, #4]
 801963a:	f000 f9ef 	bl	8019a1c <USBD_CtlError>
      err++;
 801963e:	7afb      	ldrb	r3, [r7, #11]
 8019640:	3301      	adds	r3, #1
 8019642:	72fb      	strb	r3, [r7, #11]
      break;
 8019644:	bf00      	nop
  }

  if (err != 0U)
 8019646:	7afb      	ldrb	r3, [r7, #11]
 8019648:	2b00      	cmp	r3, #0
 801964a:	d11e      	bne.n	801968a <USBD_GetDescriptor+0x31e>
  {
    return;
  }

  if (req->wLength != 0U)
 801964c:	683b      	ldr	r3, [r7, #0]
 801964e:	88db      	ldrh	r3, [r3, #6]
 8019650:	2b00      	cmp	r3, #0
 8019652:	d016      	beq.n	8019682 <USBD_GetDescriptor+0x316>
  {
    if (len != 0U)
 8019654:	893b      	ldrh	r3, [r7, #8]
 8019656:	2b00      	cmp	r3, #0
 8019658:	d00e      	beq.n	8019678 <USBD_GetDescriptor+0x30c>
    {
      len = MIN(len, req->wLength);
 801965a:	683b      	ldr	r3, [r7, #0]
 801965c:	88da      	ldrh	r2, [r3, #6]
 801965e:	893b      	ldrh	r3, [r7, #8]
 8019660:	4293      	cmp	r3, r2
 8019662:	bf28      	it	cs
 8019664:	4613      	movcs	r3, r2
 8019666:	b29b      	uxth	r3, r3
 8019668:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 801966a:	893b      	ldrh	r3, [r7, #8]
 801966c:	461a      	mov	r2, r3
 801966e:	68f9      	ldr	r1, [r7, #12]
 8019670:	6878      	ldr	r0, [r7, #4]
 8019672:	f000 fa44 	bl	8019afe <USBD_CtlSendData>
 8019676:	e009      	b.n	801968c <USBD_GetDescriptor+0x320>
    }
    else
    {
      USBD_CtlError(pdev, req);
 8019678:	6839      	ldr	r1, [r7, #0]
 801967a:	6878      	ldr	r0, [r7, #4]
 801967c:	f000 f9ce 	bl	8019a1c <USBD_CtlError>
 8019680:	e004      	b.n	801968c <USBD_GetDescriptor+0x320>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 8019682:	6878      	ldr	r0, [r7, #4]
 8019684:	f000 fa95 	bl	8019bb2 <USBD_CtlSendStatus>
 8019688:	e000      	b.n	801968c <USBD_GetDescriptor+0x320>
    return;
 801968a:	bf00      	nop
  }
}
 801968c:	3710      	adds	r7, #16
 801968e:	46bd      	mov	sp, r7
 8019690:	bd80      	pop	{r7, pc}
 8019692:	bf00      	nop

08019694 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019694:	b580      	push	{r7, lr}
 8019696:	b084      	sub	sp, #16
 8019698:	af00      	add	r7, sp, #0
 801969a:	6078      	str	r0, [r7, #4]
 801969c:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 801969e:	683b      	ldr	r3, [r7, #0]
 80196a0:	889b      	ldrh	r3, [r3, #4]
 80196a2:	2b00      	cmp	r3, #0
 80196a4:	d131      	bne.n	801970a <USBD_SetAddress+0x76>
 80196a6:	683b      	ldr	r3, [r7, #0]
 80196a8:	88db      	ldrh	r3, [r3, #6]
 80196aa:	2b00      	cmp	r3, #0
 80196ac:	d12d      	bne.n	801970a <USBD_SetAddress+0x76>
 80196ae:	683b      	ldr	r3, [r7, #0]
 80196b0:	885b      	ldrh	r3, [r3, #2]
 80196b2:	2b7f      	cmp	r3, #127	; 0x7f
 80196b4:	d829      	bhi.n	801970a <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 80196b6:	683b      	ldr	r3, [r7, #0]
 80196b8:	885b      	ldrh	r3, [r3, #2]
 80196ba:	b2db      	uxtb	r3, r3
 80196bc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80196c0:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80196c2:	687b      	ldr	r3, [r7, #4]
 80196c4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80196c8:	b2db      	uxtb	r3, r3
 80196ca:	2b03      	cmp	r3, #3
 80196cc:	d104      	bne.n	80196d8 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 80196ce:	6839      	ldr	r1, [r7, #0]
 80196d0:	6878      	ldr	r0, [r7, #4]
 80196d2:	f000 f9a3 	bl	8019a1c <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80196d6:	e01d      	b.n	8019714 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 80196d8:	687b      	ldr	r3, [r7, #4]
 80196da:	7bfa      	ldrb	r2, [r7, #15]
 80196dc:	f883 229e 	strb.w	r2, [r3, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 80196e0:	7bfb      	ldrb	r3, [r7, #15]
 80196e2:	4619      	mov	r1, r3
 80196e4:	6878      	ldr	r0, [r7, #4]
 80196e6:	f00f fc76 	bl	8028fd6 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 80196ea:	6878      	ldr	r0, [r7, #4]
 80196ec:	f000 fa61 	bl	8019bb2 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 80196f0:	7bfb      	ldrb	r3, [r7, #15]
 80196f2:	2b00      	cmp	r3, #0
 80196f4:	d004      	beq.n	8019700 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80196f6:	687b      	ldr	r3, [r7, #4]
 80196f8:	2202      	movs	r2, #2
 80196fa:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80196fe:	e009      	b.n	8019714 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8019700:	687b      	ldr	r3, [r7, #4]
 8019702:	2201      	movs	r2, #1
 8019704:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8019708:	e004      	b.n	8019714 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 801970a:	6839      	ldr	r1, [r7, #0]
 801970c:	6878      	ldr	r0, [r7, #4]
 801970e:	f000 f985 	bl	8019a1c <USBD_CtlError>
  }
}
 8019712:	bf00      	nop
 8019714:	bf00      	nop
 8019716:	3710      	adds	r7, #16
 8019718:	46bd      	mov	sp, r7
 801971a:	bd80      	pop	{r7, pc}

0801971c <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801971c:	b580      	push	{r7, lr}
 801971e:	b084      	sub	sp, #16
 8019720:	af00      	add	r7, sp, #0
 8019722:	6078      	str	r0, [r7, #4]
 8019724:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8019726:	2300      	movs	r3, #0
 8019728:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 801972a:	683b      	ldr	r3, [r7, #0]
 801972c:	885b      	ldrh	r3, [r3, #2]
 801972e:	b2da      	uxtb	r2, r3
 8019730:	4b4c      	ldr	r3, [pc, #304]	; (8019864 <USBD_SetConfig+0x148>)
 8019732:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8019734:	4b4b      	ldr	r3, [pc, #300]	; (8019864 <USBD_SetConfig+0x148>)
 8019736:	781b      	ldrb	r3, [r3, #0]
 8019738:	2b01      	cmp	r3, #1
 801973a:	d905      	bls.n	8019748 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 801973c:	6839      	ldr	r1, [r7, #0]
 801973e:	6878      	ldr	r0, [r7, #4]
 8019740:	f000 f96c 	bl	8019a1c <USBD_CtlError>
    return USBD_FAIL;
 8019744:	2303      	movs	r3, #3
 8019746:	e088      	b.n	801985a <USBD_SetConfig+0x13e>
  }

  switch (pdev->dev_state)
 8019748:	687b      	ldr	r3, [r7, #4]
 801974a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 801974e:	b2db      	uxtb	r3, r3
 8019750:	2b02      	cmp	r3, #2
 8019752:	d002      	beq.n	801975a <USBD_SetConfig+0x3e>
 8019754:	2b03      	cmp	r3, #3
 8019756:	d025      	beq.n	80197a4 <USBD_SetConfig+0x88>
 8019758:	e071      	b.n	801983e <USBD_SetConfig+0x122>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 801975a:	4b42      	ldr	r3, [pc, #264]	; (8019864 <USBD_SetConfig+0x148>)
 801975c:	781b      	ldrb	r3, [r3, #0]
 801975e:	2b00      	cmp	r3, #0
 8019760:	d01c      	beq.n	801979c <USBD_SetConfig+0x80>
      {
        pdev->dev_config = cfgidx;
 8019762:	4b40      	ldr	r3, [pc, #256]	; (8019864 <USBD_SetConfig+0x148>)
 8019764:	781b      	ldrb	r3, [r3, #0]
 8019766:	461a      	mov	r2, r3
 8019768:	687b      	ldr	r3, [r7, #4]
 801976a:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 801976c:	4b3d      	ldr	r3, [pc, #244]	; (8019864 <USBD_SetConfig+0x148>)
 801976e:	781b      	ldrb	r3, [r3, #0]
 8019770:	4619      	mov	r1, r3
 8019772:	6878      	ldr	r0, [r7, #4]
 8019774:	f7ff f992 	bl	8018a9c <USBD_SetClassConfig>
 8019778:	4603      	mov	r3, r0
 801977a:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 801977c:	7bfb      	ldrb	r3, [r7, #15]
 801977e:	2b00      	cmp	r3, #0
 8019780:	d004      	beq.n	801978c <USBD_SetConfig+0x70>
        {
          USBD_CtlError(pdev, req);
 8019782:	6839      	ldr	r1, [r7, #0]
 8019784:	6878      	ldr	r0, [r7, #4]
 8019786:	f000 f949 	bl	8019a1c <USBD_CtlError>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 801978a:	e065      	b.n	8019858 <USBD_SetConfig+0x13c>
          (void)USBD_CtlSendStatus(pdev);
 801978c:	6878      	ldr	r0, [r7, #4]
 801978e:	f000 fa10 	bl	8019bb2 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8019792:	687b      	ldr	r3, [r7, #4]
 8019794:	2203      	movs	r2, #3
 8019796:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 801979a:	e05d      	b.n	8019858 <USBD_SetConfig+0x13c>
        (void)USBD_CtlSendStatus(pdev);
 801979c:	6878      	ldr	r0, [r7, #4]
 801979e:	f000 fa08 	bl	8019bb2 <USBD_CtlSendStatus>
      break;
 80197a2:	e059      	b.n	8019858 <USBD_SetConfig+0x13c>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 80197a4:	4b2f      	ldr	r3, [pc, #188]	; (8019864 <USBD_SetConfig+0x148>)
 80197a6:	781b      	ldrb	r3, [r3, #0]
 80197a8:	2b00      	cmp	r3, #0
 80197aa:	d112      	bne.n	80197d2 <USBD_SetConfig+0xb6>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80197ac:	687b      	ldr	r3, [r7, #4]
 80197ae:	2202      	movs	r2, #2
 80197b0:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
        pdev->dev_config = cfgidx;
 80197b4:	4b2b      	ldr	r3, [pc, #172]	; (8019864 <USBD_SetConfig+0x148>)
 80197b6:	781b      	ldrb	r3, [r3, #0]
 80197b8:	461a      	mov	r2, r3
 80197ba:	687b      	ldr	r3, [r7, #4]
 80197bc:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 80197be:	4b29      	ldr	r3, [pc, #164]	; (8019864 <USBD_SetConfig+0x148>)
 80197c0:	781b      	ldrb	r3, [r3, #0]
 80197c2:	4619      	mov	r1, r3
 80197c4:	6878      	ldr	r0, [r7, #4]
 80197c6:	f7ff f985 	bl	8018ad4 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 80197ca:	6878      	ldr	r0, [r7, #4]
 80197cc:	f000 f9f1 	bl	8019bb2 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 80197d0:	e042      	b.n	8019858 <USBD_SetConfig+0x13c>
      else if (cfgidx != pdev->dev_config)
 80197d2:	4b24      	ldr	r3, [pc, #144]	; (8019864 <USBD_SetConfig+0x148>)
 80197d4:	781b      	ldrb	r3, [r3, #0]
 80197d6:	461a      	mov	r2, r3
 80197d8:	687b      	ldr	r3, [r7, #4]
 80197da:	685b      	ldr	r3, [r3, #4]
 80197dc:	429a      	cmp	r2, r3
 80197de:	d02a      	beq.n	8019836 <USBD_SetConfig+0x11a>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80197e0:	687b      	ldr	r3, [r7, #4]
 80197e2:	685b      	ldr	r3, [r3, #4]
 80197e4:	b2db      	uxtb	r3, r3
 80197e6:	4619      	mov	r1, r3
 80197e8:	6878      	ldr	r0, [r7, #4]
 80197ea:	f7ff f973 	bl	8018ad4 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 80197ee:	4b1d      	ldr	r3, [pc, #116]	; (8019864 <USBD_SetConfig+0x148>)
 80197f0:	781b      	ldrb	r3, [r3, #0]
 80197f2:	461a      	mov	r2, r3
 80197f4:	687b      	ldr	r3, [r7, #4]
 80197f6:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80197f8:	4b1a      	ldr	r3, [pc, #104]	; (8019864 <USBD_SetConfig+0x148>)
 80197fa:	781b      	ldrb	r3, [r3, #0]
 80197fc:	4619      	mov	r1, r3
 80197fe:	6878      	ldr	r0, [r7, #4]
 8019800:	f7ff f94c 	bl	8018a9c <USBD_SetClassConfig>
 8019804:	4603      	mov	r3, r0
 8019806:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 8019808:	7bfb      	ldrb	r3, [r7, #15]
 801980a:	2b00      	cmp	r3, #0
 801980c:	d00f      	beq.n	801982e <USBD_SetConfig+0x112>
          USBD_CtlError(pdev, req);
 801980e:	6839      	ldr	r1, [r7, #0]
 8019810:	6878      	ldr	r0, [r7, #4]
 8019812:	f000 f903 	bl	8019a1c <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8019816:	687b      	ldr	r3, [r7, #4]
 8019818:	685b      	ldr	r3, [r3, #4]
 801981a:	b2db      	uxtb	r3, r3
 801981c:	4619      	mov	r1, r3
 801981e:	6878      	ldr	r0, [r7, #4]
 8019820:	f7ff f958 	bl	8018ad4 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8019824:	687b      	ldr	r3, [r7, #4]
 8019826:	2202      	movs	r2, #2
 8019828:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      break;
 801982c:	e014      	b.n	8019858 <USBD_SetConfig+0x13c>
          (void)USBD_CtlSendStatus(pdev);
 801982e:	6878      	ldr	r0, [r7, #4]
 8019830:	f000 f9bf 	bl	8019bb2 <USBD_CtlSendStatus>
      break;
 8019834:	e010      	b.n	8019858 <USBD_SetConfig+0x13c>
        (void)USBD_CtlSendStatus(pdev);
 8019836:	6878      	ldr	r0, [r7, #4]
 8019838:	f000 f9bb 	bl	8019bb2 <USBD_CtlSendStatus>
      break;
 801983c:	e00c      	b.n	8019858 <USBD_SetConfig+0x13c>

    default:
      USBD_CtlError(pdev, req);
 801983e:	6839      	ldr	r1, [r7, #0]
 8019840:	6878      	ldr	r0, [r7, #4]
 8019842:	f000 f8eb 	bl	8019a1c <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 8019846:	4b07      	ldr	r3, [pc, #28]	; (8019864 <USBD_SetConfig+0x148>)
 8019848:	781b      	ldrb	r3, [r3, #0]
 801984a:	4619      	mov	r1, r3
 801984c:	6878      	ldr	r0, [r7, #4]
 801984e:	f7ff f941 	bl	8018ad4 <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 8019852:	2303      	movs	r3, #3
 8019854:	73fb      	strb	r3, [r7, #15]
      break;
 8019856:	bf00      	nop
  }

  return ret;
 8019858:	7bfb      	ldrb	r3, [r7, #15]
}
 801985a:	4618      	mov	r0, r3
 801985c:	3710      	adds	r7, #16
 801985e:	46bd      	mov	sp, r7
 8019860:	bd80      	pop	{r7, pc}
 8019862:	bf00      	nop
 8019864:	20002a5c 	.word	0x20002a5c

08019868 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019868:	b580      	push	{r7, lr}
 801986a:	b082      	sub	sp, #8
 801986c:	af00      	add	r7, sp, #0
 801986e:	6078      	str	r0, [r7, #4]
 8019870:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 8019872:	683b      	ldr	r3, [r7, #0]
 8019874:	88db      	ldrh	r3, [r3, #6]
 8019876:	2b01      	cmp	r3, #1
 8019878:	d004      	beq.n	8019884 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 801987a:	6839      	ldr	r1, [r7, #0]
 801987c:	6878      	ldr	r0, [r7, #4]
 801987e:	f000 f8cd 	bl	8019a1c <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 8019882:	e023      	b.n	80198cc <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 8019884:	687b      	ldr	r3, [r7, #4]
 8019886:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 801988a:	b2db      	uxtb	r3, r3
 801988c:	2b02      	cmp	r3, #2
 801988e:	dc02      	bgt.n	8019896 <USBD_GetConfig+0x2e>
 8019890:	2b00      	cmp	r3, #0
 8019892:	dc03      	bgt.n	801989c <USBD_GetConfig+0x34>
 8019894:	e015      	b.n	80198c2 <USBD_GetConfig+0x5a>
 8019896:	2b03      	cmp	r3, #3
 8019898:	d00b      	beq.n	80198b2 <USBD_GetConfig+0x4a>
 801989a:	e012      	b.n	80198c2 <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 801989c:	687b      	ldr	r3, [r7, #4]
 801989e:	2200      	movs	r2, #0
 80198a0:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80198a2:	687b      	ldr	r3, [r7, #4]
 80198a4:	3308      	adds	r3, #8
 80198a6:	2201      	movs	r2, #1
 80198a8:	4619      	mov	r1, r3
 80198aa:	6878      	ldr	r0, [r7, #4]
 80198ac:	f000 f927 	bl	8019afe <USBD_CtlSendData>
        break;
 80198b0:	e00c      	b.n	80198cc <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 80198b2:	687b      	ldr	r3, [r7, #4]
 80198b4:	3304      	adds	r3, #4
 80198b6:	2201      	movs	r2, #1
 80198b8:	4619      	mov	r1, r3
 80198ba:	6878      	ldr	r0, [r7, #4]
 80198bc:	f000 f91f 	bl	8019afe <USBD_CtlSendData>
        break;
 80198c0:	e004      	b.n	80198cc <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 80198c2:	6839      	ldr	r1, [r7, #0]
 80198c4:	6878      	ldr	r0, [r7, #4]
 80198c6:	f000 f8a9 	bl	8019a1c <USBD_CtlError>
        break;
 80198ca:	bf00      	nop
}
 80198cc:	bf00      	nop
 80198ce:	3708      	adds	r7, #8
 80198d0:	46bd      	mov	sp, r7
 80198d2:	bd80      	pop	{r7, pc}

080198d4 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80198d4:	b580      	push	{r7, lr}
 80198d6:	b082      	sub	sp, #8
 80198d8:	af00      	add	r7, sp, #0
 80198da:	6078      	str	r0, [r7, #4]
 80198dc:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80198de:	687b      	ldr	r3, [r7, #4]
 80198e0:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80198e4:	b2db      	uxtb	r3, r3
 80198e6:	3b01      	subs	r3, #1
 80198e8:	2b02      	cmp	r3, #2
 80198ea:	d81e      	bhi.n	801992a <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 80198ec:	683b      	ldr	r3, [r7, #0]
 80198ee:	88db      	ldrh	r3, [r3, #6]
 80198f0:	2b02      	cmp	r3, #2
 80198f2:	d004      	beq.n	80198fe <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 80198f4:	6839      	ldr	r1, [r7, #0]
 80198f6:	6878      	ldr	r0, [r7, #4]
 80198f8:	f000 f890 	bl	8019a1c <USBD_CtlError>
        break;
 80198fc:	e01a      	b.n	8019934 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80198fe:	687b      	ldr	r3, [r7, #4]
 8019900:	2201      	movs	r2, #1
 8019902:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif

      if (pdev->dev_remote_wakeup != 0U)
 8019904:	687b      	ldr	r3, [r7, #4]
 8019906:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 801990a:	2b00      	cmp	r3, #0
 801990c:	d005      	beq.n	801991a <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 801990e:	687b      	ldr	r3, [r7, #4]
 8019910:	68db      	ldr	r3, [r3, #12]
 8019912:	f043 0202 	orr.w	r2, r3, #2
 8019916:	687b      	ldr	r3, [r7, #4]
 8019918:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 801991a:	687b      	ldr	r3, [r7, #4]
 801991c:	330c      	adds	r3, #12
 801991e:	2202      	movs	r2, #2
 8019920:	4619      	mov	r1, r3
 8019922:	6878      	ldr	r0, [r7, #4]
 8019924:	f000 f8eb 	bl	8019afe <USBD_CtlSendData>
      break;
 8019928:	e004      	b.n	8019934 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 801992a:	6839      	ldr	r1, [r7, #0]
 801992c:	6878      	ldr	r0, [r7, #4]
 801992e:	f000 f875 	bl	8019a1c <USBD_CtlError>
      break;
 8019932:	bf00      	nop
  }
}
 8019934:	bf00      	nop
 8019936:	3708      	adds	r7, #8
 8019938:	46bd      	mov	sp, r7
 801993a:	bd80      	pop	{r7, pc}

0801993c <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801993c:	b580      	push	{r7, lr}
 801993e:	b082      	sub	sp, #8
 8019940:	af00      	add	r7, sp, #0
 8019942:	6078      	str	r0, [r7, #4]
 8019944:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8019946:	683b      	ldr	r3, [r7, #0]
 8019948:	885b      	ldrh	r3, [r3, #2]
 801994a:	2b01      	cmp	r3, #1
 801994c:	d106      	bne.n	801995c <USBD_SetFeature+0x20>
  {
    pdev->dev_remote_wakeup = 1U;
 801994e:	687b      	ldr	r3, [r7, #4]
 8019950:	2201      	movs	r2, #1
 8019952:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 8019956:	6878      	ldr	r0, [r7, #4]
 8019958:	f000 f92b 	bl	8019bb2 <USBD_CtlSendStatus>
  }
}
 801995c:	bf00      	nop
 801995e:	3708      	adds	r7, #8
 8019960:	46bd      	mov	sp, r7
 8019962:	bd80      	pop	{r7, pc}

08019964 <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019964:	b580      	push	{r7, lr}
 8019966:	b082      	sub	sp, #8
 8019968:	af00      	add	r7, sp, #0
 801996a:	6078      	str	r0, [r7, #4]
 801996c:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 801996e:	687b      	ldr	r3, [r7, #4]
 8019970:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8019974:	b2db      	uxtb	r3, r3
 8019976:	3b01      	subs	r3, #1
 8019978:	2b02      	cmp	r3, #2
 801997a:	d80b      	bhi.n	8019994 <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801997c:	683b      	ldr	r3, [r7, #0]
 801997e:	885b      	ldrh	r3, [r3, #2]
 8019980:	2b01      	cmp	r3, #1
 8019982:	d10c      	bne.n	801999e <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 8019984:	687b      	ldr	r3, [r7, #4]
 8019986:	2200      	movs	r2, #0
 8019988:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 801998c:	6878      	ldr	r0, [r7, #4]
 801998e:	f000 f910 	bl	8019bb2 <USBD_CtlSendStatus>
      }
      break;
 8019992:	e004      	b.n	801999e <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 8019994:	6839      	ldr	r1, [r7, #0]
 8019996:	6878      	ldr	r0, [r7, #4]
 8019998:	f000 f840 	bl	8019a1c <USBD_CtlError>
      break;
 801999c:	e000      	b.n	80199a0 <USBD_ClrFeature+0x3c>
      break;
 801999e:	bf00      	nop
  }
}
 80199a0:	bf00      	nop
 80199a2:	3708      	adds	r7, #8
 80199a4:	46bd      	mov	sp, r7
 80199a6:	bd80      	pop	{r7, pc}

080199a8 <USBD_ParseSetupRequest>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 80199a8:	b580      	push	{r7, lr}
 80199aa:	b084      	sub	sp, #16
 80199ac:	af00      	add	r7, sp, #0
 80199ae:	6078      	str	r0, [r7, #4]
 80199b0:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 80199b2:	683b      	ldr	r3, [r7, #0]
 80199b4:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 80199b6:	68fb      	ldr	r3, [r7, #12]
 80199b8:	781a      	ldrb	r2, [r3, #0]
 80199ba:	687b      	ldr	r3, [r7, #4]
 80199bc:	701a      	strb	r2, [r3, #0]

  pbuff++;
 80199be:	68fb      	ldr	r3, [r7, #12]
 80199c0:	3301      	adds	r3, #1
 80199c2:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 80199c4:	68fb      	ldr	r3, [r7, #12]
 80199c6:	781a      	ldrb	r2, [r3, #0]
 80199c8:	687b      	ldr	r3, [r7, #4]
 80199ca:	705a      	strb	r2, [r3, #1]

  pbuff++;
 80199cc:	68fb      	ldr	r3, [r7, #12]
 80199ce:	3301      	adds	r3, #1
 80199d0:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 80199d2:	68f8      	ldr	r0, [r7, #12]
 80199d4:	f7ff fa92 	bl	8018efc <SWAPBYTE>
 80199d8:	4603      	mov	r3, r0
 80199da:	461a      	mov	r2, r3
 80199dc:	687b      	ldr	r3, [r7, #4]
 80199de:	805a      	strh	r2, [r3, #2]

  pbuff++;
 80199e0:	68fb      	ldr	r3, [r7, #12]
 80199e2:	3301      	adds	r3, #1
 80199e4:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80199e6:	68fb      	ldr	r3, [r7, #12]
 80199e8:	3301      	adds	r3, #1
 80199ea:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 80199ec:	68f8      	ldr	r0, [r7, #12]
 80199ee:	f7ff fa85 	bl	8018efc <SWAPBYTE>
 80199f2:	4603      	mov	r3, r0
 80199f4:	461a      	mov	r2, r3
 80199f6:	687b      	ldr	r3, [r7, #4]
 80199f8:	809a      	strh	r2, [r3, #4]

  pbuff++;
 80199fa:	68fb      	ldr	r3, [r7, #12]
 80199fc:	3301      	adds	r3, #1
 80199fe:	60fb      	str	r3, [r7, #12]
  pbuff++;
 8019a00:	68fb      	ldr	r3, [r7, #12]
 8019a02:	3301      	adds	r3, #1
 8019a04:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 8019a06:	68f8      	ldr	r0, [r7, #12]
 8019a08:	f7ff fa78 	bl	8018efc <SWAPBYTE>
 8019a0c:	4603      	mov	r3, r0
 8019a0e:	461a      	mov	r2, r3
 8019a10:	687b      	ldr	r3, [r7, #4]
 8019a12:	80da      	strh	r2, [r3, #6]
}
 8019a14:	bf00      	nop
 8019a16:	3710      	adds	r7, #16
 8019a18:	46bd      	mov	sp, r7
 8019a1a:	bd80      	pop	{r7, pc}

08019a1c <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019a1c:	b580      	push	{r7, lr}
 8019a1e:	b082      	sub	sp, #8
 8019a20:	af00      	add	r7, sp, #0
 8019a22:	6078      	str	r0, [r7, #4]
 8019a24:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 8019a26:	2180      	movs	r1, #128	; 0x80
 8019a28:	6878      	ldr	r0, [r7, #4]
 8019a2a:	f00f fa69 	bl	8028f00 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8019a2e:	2100      	movs	r1, #0
 8019a30:	6878      	ldr	r0, [r7, #4]
 8019a32:	f00f fa65 	bl	8028f00 <USBD_LL_StallEP>
}
 8019a36:	bf00      	nop
 8019a38:	3708      	adds	r7, #8
 8019a3a:	46bd      	mov	sp, r7
 8019a3c:	bd80      	pop	{r7, pc}

08019a3e <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8019a3e:	b580      	push	{r7, lr}
 8019a40:	b086      	sub	sp, #24
 8019a42:	af00      	add	r7, sp, #0
 8019a44:	60f8      	str	r0, [r7, #12]
 8019a46:	60b9      	str	r1, [r7, #8]
 8019a48:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 8019a4a:	2300      	movs	r3, #0
 8019a4c:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 8019a4e:	68fb      	ldr	r3, [r7, #12]
 8019a50:	2b00      	cmp	r3, #0
 8019a52:	d036      	beq.n	8019ac2 <USBD_GetString+0x84>
  {
    return;
  }

  pdesc = desc;
 8019a54:	68fb      	ldr	r3, [r7, #12]
 8019a56:	613b      	str	r3, [r7, #16]
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 8019a58:	6938      	ldr	r0, [r7, #16]
 8019a5a:	f000 f836 	bl	8019aca <USBD_GetLen>
 8019a5e:	4603      	mov	r3, r0
 8019a60:	3301      	adds	r3, #1
 8019a62:	b29b      	uxth	r3, r3
 8019a64:	005b      	lsls	r3, r3, #1
 8019a66:	b29a      	uxth	r2, r3
 8019a68:	687b      	ldr	r3, [r7, #4]
 8019a6a:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 8019a6c:	7dfb      	ldrb	r3, [r7, #23]
 8019a6e:	68ba      	ldr	r2, [r7, #8]
 8019a70:	4413      	add	r3, r2
 8019a72:	687a      	ldr	r2, [r7, #4]
 8019a74:	7812      	ldrb	r2, [r2, #0]
 8019a76:	701a      	strb	r2, [r3, #0]
  idx++;
 8019a78:	7dfb      	ldrb	r3, [r7, #23]
 8019a7a:	3301      	adds	r3, #1
 8019a7c:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8019a7e:	7dfb      	ldrb	r3, [r7, #23]
 8019a80:	68ba      	ldr	r2, [r7, #8]
 8019a82:	4413      	add	r3, r2
 8019a84:	2203      	movs	r2, #3
 8019a86:	701a      	strb	r2, [r3, #0]
  idx++;
 8019a88:	7dfb      	ldrb	r3, [r7, #23]
 8019a8a:	3301      	adds	r3, #1
 8019a8c:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 8019a8e:	e013      	b.n	8019ab8 <USBD_GetString+0x7a>
  {
    unicode[idx] = *pdesc;
 8019a90:	7dfb      	ldrb	r3, [r7, #23]
 8019a92:	68ba      	ldr	r2, [r7, #8]
 8019a94:	4413      	add	r3, r2
 8019a96:	693a      	ldr	r2, [r7, #16]
 8019a98:	7812      	ldrb	r2, [r2, #0]
 8019a9a:	701a      	strb	r2, [r3, #0]
    pdesc++;
 8019a9c:	693b      	ldr	r3, [r7, #16]
 8019a9e:	3301      	adds	r3, #1
 8019aa0:	613b      	str	r3, [r7, #16]
    idx++;
 8019aa2:	7dfb      	ldrb	r3, [r7, #23]
 8019aa4:	3301      	adds	r3, #1
 8019aa6:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 8019aa8:	7dfb      	ldrb	r3, [r7, #23]
 8019aaa:	68ba      	ldr	r2, [r7, #8]
 8019aac:	4413      	add	r3, r2
 8019aae:	2200      	movs	r2, #0
 8019ab0:	701a      	strb	r2, [r3, #0]
    idx++;
 8019ab2:	7dfb      	ldrb	r3, [r7, #23]
 8019ab4:	3301      	adds	r3, #1
 8019ab6:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 8019ab8:	693b      	ldr	r3, [r7, #16]
 8019aba:	781b      	ldrb	r3, [r3, #0]
 8019abc:	2b00      	cmp	r3, #0
 8019abe:	d1e7      	bne.n	8019a90 <USBD_GetString+0x52>
 8019ac0:	e000      	b.n	8019ac4 <USBD_GetString+0x86>
    return;
 8019ac2:	bf00      	nop
  }
}
 8019ac4:	3718      	adds	r7, #24
 8019ac6:	46bd      	mov	sp, r7
 8019ac8:	bd80      	pop	{r7, pc}

08019aca <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 8019aca:	b480      	push	{r7}
 8019acc:	b085      	sub	sp, #20
 8019ace:	af00      	add	r7, sp, #0
 8019ad0:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 8019ad2:	2300      	movs	r3, #0
 8019ad4:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 8019ad6:	687b      	ldr	r3, [r7, #4]
 8019ad8:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 8019ada:	e005      	b.n	8019ae8 <USBD_GetLen+0x1e>
  {
    len++;
 8019adc:	7bfb      	ldrb	r3, [r7, #15]
 8019ade:	3301      	adds	r3, #1
 8019ae0:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 8019ae2:	68bb      	ldr	r3, [r7, #8]
 8019ae4:	3301      	adds	r3, #1
 8019ae6:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 8019ae8:	68bb      	ldr	r3, [r7, #8]
 8019aea:	781b      	ldrb	r3, [r3, #0]
 8019aec:	2b00      	cmp	r3, #0
 8019aee:	d1f5      	bne.n	8019adc <USBD_GetLen+0x12>
  }

  return len;
 8019af0:	7bfb      	ldrb	r3, [r7, #15]
}
 8019af2:	4618      	mov	r0, r3
 8019af4:	3714      	adds	r7, #20
 8019af6:	46bd      	mov	sp, r7
 8019af8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019afc:	4770      	bx	lr

08019afe <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8019afe:	b580      	push	{r7, lr}
 8019b00:	b084      	sub	sp, #16
 8019b02:	af00      	add	r7, sp, #0
 8019b04:	60f8      	str	r0, [r7, #12]
 8019b06:	60b9      	str	r1, [r7, #8]
 8019b08:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8019b0a:	68fb      	ldr	r3, [r7, #12]
 8019b0c:	2202      	movs	r2, #2
 8019b0e:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 8019b12:	68fb      	ldr	r3, [r7, #12]
 8019b14:	687a      	ldr	r2, [r7, #4]
 8019b16:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 8019b18:	68fb      	ldr	r3, [r7, #12]
 8019b1a:	687a      	ldr	r2, [r7, #4]
 8019b1c:	61da      	str	r2, [r3, #28]
#endif

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8019b1e:	687b      	ldr	r3, [r7, #4]
 8019b20:	68ba      	ldr	r2, [r7, #8]
 8019b22:	2100      	movs	r1, #0
 8019b24:	68f8      	ldr	r0, [r7, #12]
 8019b26:	f00f fa75 	bl	8029014 <USBD_LL_Transmit>

  return USBD_OK;
 8019b2a:	2300      	movs	r3, #0
}
 8019b2c:	4618      	mov	r0, r3
 8019b2e:	3710      	adds	r7, #16
 8019b30:	46bd      	mov	sp, r7
 8019b32:	bd80      	pop	{r7, pc}

08019b34 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 8019b34:	b580      	push	{r7, lr}
 8019b36:	b084      	sub	sp, #16
 8019b38:	af00      	add	r7, sp, #0
 8019b3a:	60f8      	str	r0, [r7, #12]
 8019b3c:	60b9      	str	r1, [r7, #8]
 8019b3e:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8019b40:	687b      	ldr	r3, [r7, #4]
 8019b42:	68ba      	ldr	r2, [r7, #8]
 8019b44:	2100      	movs	r1, #0
 8019b46:	68f8      	ldr	r0, [r7, #12]
 8019b48:	f00f fa64 	bl	8029014 <USBD_LL_Transmit>

  return USBD_OK;
 8019b4c:	2300      	movs	r3, #0
}
 8019b4e:	4618      	mov	r0, r3
 8019b50:	3710      	adds	r7, #16
 8019b52:	46bd      	mov	sp, r7
 8019b54:	bd80      	pop	{r7, pc}

08019b56 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 8019b56:	b580      	push	{r7, lr}
 8019b58:	b084      	sub	sp, #16
 8019b5a:	af00      	add	r7, sp, #0
 8019b5c:	60f8      	str	r0, [r7, #12]
 8019b5e:	60b9      	str	r1, [r7, #8]
 8019b60:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8019b62:	68fb      	ldr	r3, [r7, #12]
 8019b64:	2203      	movs	r2, #3
 8019b66:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_out[0].total_length = len;
 8019b6a:	68fb      	ldr	r3, [r7, #12]
 8019b6c:	687a      	ldr	r2, [r7, #4]
 8019b6e:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8019b72:	68fb      	ldr	r3, [r7, #12]
 8019b74:	687a      	ldr	r2, [r7, #4]
 8019b76:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
#endif

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8019b7a:	687b      	ldr	r3, [r7, #4]
 8019b7c:	68ba      	ldr	r2, [r7, #8]
 8019b7e:	2100      	movs	r1, #0
 8019b80:	68f8      	ldr	r0, [r7, #12]
 8019b82:	f00f fa68 	bl	8029056 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8019b86:	2300      	movs	r3, #0
}
 8019b88:	4618      	mov	r0, r3
 8019b8a:	3710      	adds	r7, #16
 8019b8c:	46bd      	mov	sp, r7
 8019b8e:	bd80      	pop	{r7, pc}

08019b90 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8019b90:	b580      	push	{r7, lr}
 8019b92:	b084      	sub	sp, #16
 8019b94:	af00      	add	r7, sp, #0
 8019b96:	60f8      	str	r0, [r7, #12]
 8019b98:	60b9      	str	r1, [r7, #8]
 8019b9a:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8019b9c:	687b      	ldr	r3, [r7, #4]
 8019b9e:	68ba      	ldr	r2, [r7, #8]
 8019ba0:	2100      	movs	r1, #0
 8019ba2:	68f8      	ldr	r0, [r7, #12]
 8019ba4:	f00f fa57 	bl	8029056 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8019ba8:	2300      	movs	r3, #0
}
 8019baa:	4618      	mov	r0, r3
 8019bac:	3710      	adds	r7, #16
 8019bae:	46bd      	mov	sp, r7
 8019bb0:	bd80      	pop	{r7, pc}

08019bb2 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8019bb2:	b580      	push	{r7, lr}
 8019bb4:	b082      	sub	sp, #8
 8019bb6:	af00      	add	r7, sp, #0
 8019bb8:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8019bba:	687b      	ldr	r3, [r7, #4]
 8019bbc:	2204      	movs	r2, #4
 8019bbe:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8019bc2:	2300      	movs	r3, #0
 8019bc4:	2200      	movs	r2, #0
 8019bc6:	2100      	movs	r1, #0
 8019bc8:	6878      	ldr	r0, [r7, #4]
 8019bca:	f00f fa23 	bl	8029014 <USBD_LL_Transmit>

  return USBD_OK;
 8019bce:	2300      	movs	r3, #0
}
 8019bd0:	4618      	mov	r0, r3
 8019bd2:	3708      	adds	r7, #8
 8019bd4:	46bd      	mov	sp, r7
 8019bd6:	bd80      	pop	{r7, pc}

08019bd8 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 8019bd8:	b580      	push	{r7, lr}
 8019bda:	b082      	sub	sp, #8
 8019bdc:	af00      	add	r7, sp, #0
 8019bde:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8019be0:	687b      	ldr	r3, [r7, #4]
 8019be2:	2205      	movs	r2, #5
 8019be4:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8019be8:	2300      	movs	r3, #0
 8019bea:	2200      	movs	r2, #0
 8019bec:	2100      	movs	r1, #0
 8019bee:	6878      	ldr	r0, [r7, #4]
 8019bf0:	f00f fa31 	bl	8029056 <USBD_LL_PrepareReceive>

  return USBD_OK;
 8019bf4:	2300      	movs	r3, #0
}
 8019bf6:	4618      	mov	r0, r3
 8019bf8:	3708      	adds	r7, #8
 8019bfa:	46bd      	mov	sp, r7
 8019bfc:	bd80      	pop	{r7, pc}

08019bfe <aci_gap_set_non_discoverable>:
 */

#include "ble_gap_aci.h"

tBleStatus aci_gap_set_non_discoverable( void )
{
 8019bfe:	b580      	push	{r7, lr}
 8019c00:	b088      	sub	sp, #32
 8019c02:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 8019c04:	2300      	movs	r3, #0
 8019c06:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8019c08:	f107 0308 	add.w	r3, r7, #8
 8019c0c:	2218      	movs	r2, #24
 8019c0e:	2100      	movs	r1, #0
 8019c10:	4618      	mov	r0, r3
 8019c12:	f001 f8b6 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 8019c16:	233f      	movs	r3, #63	; 0x3f
 8019c18:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x081;
 8019c1a:	2381      	movs	r3, #129	; 0x81
 8019c1c:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 8019c1e:	1dfb      	adds	r3, r7, #7
 8019c20:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 8019c22:	2301      	movs	r3, #1
 8019c24:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 8019c26:	f107 0308 	add.w	r3, r7, #8
 8019c2a:	2100      	movs	r1, #0
 8019c2c:	4618      	mov	r0, r3
 8019c2e:	f001 fc53 	bl	801b4d8 <hci_send_req>
 8019c32:	4603      	mov	r3, r0
 8019c34:	2b00      	cmp	r3, #0
 8019c36:	da01      	bge.n	8019c3c <aci_gap_set_non_discoverable+0x3e>
    return BLE_STATUS_TIMEOUT;
 8019c38:	23ff      	movs	r3, #255	; 0xff
 8019c3a:	e000      	b.n	8019c3e <aci_gap_set_non_discoverable+0x40>
  return status;
 8019c3c:	79fb      	ldrb	r3, [r7, #7]
}
 8019c3e:	4618      	mov	r0, r3
 8019c40:	3720      	adds	r7, #32
 8019c42:	46bd      	mov	sp, r7
 8019c44:	bd80      	pop	{r7, pc}

08019c46 <aci_gap_set_discoverable>:
                                     const uint8_t* Local_Name,
                                     uint8_t Service_Uuid_length,
                                     const uint8_t* Service_Uuid_List,
                                     uint16_t Slave_Conn_Interval_Min,
                                     uint16_t Slave_Conn_Interval_Max )
{
 8019c46:	b5b0      	push	{r4, r5, r7, lr}
 8019c48:	b0ce      	sub	sp, #312	; 0x138
 8019c4a:	af00      	add	r7, sp, #0
 8019c4c:	4605      	mov	r5, r0
 8019c4e:	460c      	mov	r4, r1
 8019c50:	4610      	mov	r0, r2
 8019c52:	4619      	mov	r1, r3
 8019c54:	1dfb      	adds	r3, r7, #7
 8019c56:	462a      	mov	r2, r5
 8019c58:	701a      	strb	r2, [r3, #0]
 8019c5a:	1d3b      	adds	r3, r7, #4
 8019c5c:	4622      	mov	r2, r4
 8019c5e:	801a      	strh	r2, [r3, #0]
 8019c60:	1cbb      	adds	r3, r7, #2
 8019c62:	4602      	mov	r2, r0
 8019c64:	801a      	strh	r2, [r3, #0]
 8019c66:	1dbb      	adds	r3, r7, #6
 8019c68:	460a      	mov	r2, r1
 8019c6a:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_discoverable_cp0 *cp0 = (aci_gap_set_discoverable_cp0*)(cmd_buffer);
 8019c6c:	f107 0310 	add.w	r3, r7, #16
 8019c70:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
  aci_gap_set_discoverable_cp1 *cp1 = (aci_gap_set_discoverable_cp1*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)));
 8019c74:	f897 314c 	ldrb.w	r3, [r7, #332]	; 0x14c
 8019c78:	3308      	adds	r3, #8
 8019c7a:	f107 0210 	add.w	r2, r7, #16
 8019c7e:	4413      	add	r3, r2
 8019c80:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  aci_gap_set_discoverable_cp2 *cp2 = (aci_gap_set_discoverable_cp2*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)) + 1 + Service_Uuid_length * (sizeof(uint8_t)));
 8019c84:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 8019c88:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 8019c8c:	4413      	add	r3, r2
 8019c8e:	3309      	adds	r3, #9
 8019c90:	f107 0210 	add.w	r2, r7, #16
 8019c94:	4413      	add	r3, r2
 8019c96:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8019c9a:	f107 030f 	add.w	r3, r7, #15
 8019c9e:	2200      	movs	r2, #0
 8019ca0:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8019ca2:	2300      	movs	r3, #0
 8019ca4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Type = Advertising_Type;
 8019ca8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019cac:	1dfa      	adds	r2, r7, #7
 8019cae:	7812      	ldrb	r2, [r2, #0]
 8019cb0:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8019cb2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019cb6:	3301      	adds	r3, #1
 8019cb8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Interval_Min = Advertising_Interval_Min;
 8019cbc:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019cc0:	1d3a      	adds	r2, r7, #4
 8019cc2:	8812      	ldrh	r2, [r2, #0]
 8019cc4:	f8a3 2001 	strh.w	r2, [r3, #1]
  index_input += 2;
 8019cc8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019ccc:	3302      	adds	r3, #2
 8019cce:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Interval_Max = Advertising_Interval_Max;
 8019cd2:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019cd6:	1cba      	adds	r2, r7, #2
 8019cd8:	8812      	ldrh	r2, [r2, #0]
 8019cda:	f8a3 2003 	strh.w	r2, [r3, #3]
  index_input += 2;
 8019cde:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019ce2:	3302      	adds	r3, #2
 8019ce4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Own_Address_Type = Own_Address_Type;
 8019ce8:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019cec:	1dba      	adds	r2, r7, #6
 8019cee:	7812      	ldrb	r2, [r2, #0]
 8019cf0:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 8019cf2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019cf6:	3301      	adds	r3, #1
 8019cf8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Filter_Policy = Advertising_Filter_Policy;
 8019cfc:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019d00:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 8019d04:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 8019d06:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019d0a:	3301      	adds	r3, #1
 8019d0c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Local_Name_Length = Local_Name_Length;
 8019d10:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019d14:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 8019d18:	71da      	strb	r2, [r3, #7]
  index_input += 1;
 8019d1a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019d1e:	3301      	adds	r3, #1
 8019d20:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  /* var_len_data input */
  {
    Osal_MemCpy( (void*)&cp0->Local_Name, (const void*)Local_Name, Local_Name_Length );
 8019d24:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8019d28:	3308      	adds	r3, #8
 8019d2a:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 8019d2e:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8019d32:	4618      	mov	r0, r3
 8019d34:	f001 f815 	bl	801ad62 <Osal_MemCpy>
    index_input += Local_Name_Length;
 8019d38:	f897 314c 	ldrb.w	r3, [r7, #332]	; 0x14c
 8019d3c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8019d40:	4413      	add	r3, r2
 8019d42:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Service_Uuid_length = Service_Uuid_length;
 8019d46:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8019d4a:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 8019d4e:	701a      	strb	r2, [r3, #0]
    }
    index_input += 1;
 8019d50:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019d54:	3301      	adds	r3, #1
 8019d56:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    Osal_MemCpy( (void*)&cp1->Service_Uuid_List, (const void*)Service_Uuid_List, Service_Uuid_length );
 8019d5a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8019d5e:	3301      	adds	r3, #1
 8019d60:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 8019d64:	f8d7 1158 	ldr.w	r1, [r7, #344]	; 0x158
 8019d68:	4618      	mov	r0, r3
 8019d6a:	f000 fffa 	bl	801ad62 <Osal_MemCpy>
    index_input += Service_Uuid_length;
 8019d6e:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 8019d72:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8019d76:	4413      	add	r3, r2
 8019d78:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp2->Slave_Conn_Interval_Min = Slave_Conn_Interval_Min;
 8019d7c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019d80:	f8b7 215c 	ldrh.w	r2, [r7, #348]	; 0x15c
 8019d84:	801a      	strh	r2, [r3, #0]
    }
    index_input += 2;
 8019d86:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019d8a:	3302      	adds	r3, #2
 8019d8c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp2->Slave_Conn_Interval_Max = Slave_Conn_Interval_Max;
 8019d90:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019d94:	f8b7 2160 	ldrh.w	r2, [r7, #352]	; 0x160
 8019d98:	805a      	strh	r2, [r3, #2]
    }
    index_input += 2;
 8019d9a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019d9e:	3302      	adds	r3, #2
 8019da0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8019da4:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019da8:	2218      	movs	r2, #24
 8019daa:	2100      	movs	r1, #0
 8019dac:	4618      	mov	r0, r3
 8019dae:	f000 ffe8 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 8019db2:	233f      	movs	r3, #63	; 0x3f
 8019db4:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x083;
 8019db8:	2383      	movs	r3, #131	; 0x83
 8019dba:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8019dbe:	f107 0310 	add.w	r3, r7, #16
 8019dc2:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8019dc6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019dca:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8019dce:	f107 030f 	add.w	r3, r7, #15
 8019dd2:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8019dd6:	2301      	movs	r3, #1
 8019dd8:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8019ddc:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019de0:	2100      	movs	r1, #0
 8019de2:	4618      	mov	r0, r3
 8019de4:	f001 fb78 	bl	801b4d8 <hci_send_req>
 8019de8:	4603      	mov	r3, r0
 8019dea:	2b00      	cmp	r3, #0
 8019dec:	da01      	bge.n	8019df2 <aci_gap_set_discoverable+0x1ac>
    return BLE_STATUS_TIMEOUT;
 8019dee:	23ff      	movs	r3, #255	; 0xff
 8019df0:	e002      	b.n	8019df8 <aci_gap_set_discoverable+0x1b2>
  return status;
 8019df2:	f107 030f 	add.w	r3, r7, #15
 8019df6:	781b      	ldrb	r3, [r3, #0]
}
 8019df8:	4618      	mov	r0, r3
 8019dfa:	f507 779c 	add.w	r7, r7, #312	; 0x138
 8019dfe:	46bd      	mov	sp, r7
 8019e00:	bdb0      	pop	{r4, r5, r7, pc}

08019e02 <aci_gap_set_io_capability>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gap_set_io_capability( uint8_t IO_Capability )
{
 8019e02:	b580      	push	{r7, lr}
 8019e04:	b0cc      	sub	sp, #304	; 0x130
 8019e06:	af00      	add	r7, sp, #0
 8019e08:	4602      	mov	r2, r0
 8019e0a:	1dfb      	adds	r3, r7, #7
 8019e0c:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0*)(cmd_buffer);
 8019e0e:	f107 0310 	add.w	r3, r7, #16
 8019e12:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8019e16:	f107 030f 	add.w	r3, r7, #15
 8019e1a:	2200      	movs	r2, #0
 8019e1c:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8019e1e:	2300      	movs	r3, #0
 8019e20:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->IO_Capability = IO_Capability;
 8019e24:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019e28:	1dfa      	adds	r2, r7, #7
 8019e2a:	7812      	ldrb	r2, [r2, #0]
 8019e2c:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8019e2e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019e32:	3301      	adds	r3, #1
 8019e34:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8019e38:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019e3c:	2218      	movs	r2, #24
 8019e3e:	2100      	movs	r1, #0
 8019e40:	4618      	mov	r0, r3
 8019e42:	f000 ff9e 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 8019e46:	233f      	movs	r3, #63	; 0x3f
 8019e48:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x085;
 8019e4c:	2385      	movs	r3, #133	; 0x85
 8019e4e:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8019e52:	f107 0310 	add.w	r3, r7, #16
 8019e56:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8019e5a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019e5e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8019e62:	f107 030f 	add.w	r3, r7, #15
 8019e66:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8019e6a:	2301      	movs	r3, #1
 8019e6c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8019e70:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019e74:	2100      	movs	r1, #0
 8019e76:	4618      	mov	r0, r3
 8019e78:	f001 fb2e 	bl	801b4d8 <hci_send_req>
 8019e7c:	4603      	mov	r3, r0
 8019e7e:	2b00      	cmp	r3, #0
 8019e80:	da01      	bge.n	8019e86 <aci_gap_set_io_capability+0x84>
    return BLE_STATUS_TIMEOUT;
 8019e82:	23ff      	movs	r3, #255	; 0xff
 8019e84:	e002      	b.n	8019e8c <aci_gap_set_io_capability+0x8a>
  return status;
 8019e86:	f107 030f 	add.w	r3, r7, #15
 8019e8a:	781b      	ldrb	r3, [r3, #0]
}
 8019e8c:	4618      	mov	r0, r3
 8019e8e:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8019e92:	46bd      	mov	sp, r7
 8019e94:	bd80      	pop	{r7, pc}

08019e96 <aci_gap_set_authentication_requirement>:
                                                   uint8_t Min_Encryption_Key_Size,
                                                   uint8_t Max_Encryption_Key_Size,
                                                   uint8_t Use_Fixed_Pin,
                                                   uint32_t Fixed_Pin,
                                                   uint8_t Identity_Address_Type )
{
 8019e96:	b5b0      	push	{r4, r5, r7, lr}
 8019e98:	b0cc      	sub	sp, #304	; 0x130
 8019e9a:	af00      	add	r7, sp, #0
 8019e9c:	4605      	mov	r5, r0
 8019e9e:	460c      	mov	r4, r1
 8019ea0:	4610      	mov	r0, r2
 8019ea2:	4619      	mov	r1, r3
 8019ea4:	1dfb      	adds	r3, r7, #7
 8019ea6:	462a      	mov	r2, r5
 8019ea8:	701a      	strb	r2, [r3, #0]
 8019eaa:	1dbb      	adds	r3, r7, #6
 8019eac:	4622      	mov	r2, r4
 8019eae:	701a      	strb	r2, [r3, #0]
 8019eb0:	1d7b      	adds	r3, r7, #5
 8019eb2:	4602      	mov	r2, r0
 8019eb4:	701a      	strb	r2, [r3, #0]
 8019eb6:	1d3b      	adds	r3, r7, #4
 8019eb8:	460a      	mov	r2, r1
 8019eba:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0*)(cmd_buffer);
 8019ebc:	f107 0310 	add.w	r3, r7, #16
 8019ec0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8019ec4:	f107 030f 	add.w	r3, r7, #15
 8019ec8:	2200      	movs	r2, #0
 8019eca:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8019ecc:	2300      	movs	r3, #0
 8019ece:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Bonding_Mode = Bonding_Mode;
 8019ed2:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019ed6:	1dfa      	adds	r2, r7, #7
 8019ed8:	7812      	ldrb	r2, [r2, #0]
 8019eda:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8019edc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019ee0:	3301      	adds	r3, #1
 8019ee2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->MITM_Mode = MITM_Mode;
 8019ee6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019eea:	1dba      	adds	r2, r7, #6
 8019eec:	7812      	ldrb	r2, [r2, #0]
 8019eee:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8019ef0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019ef4:	3301      	adds	r3, #1
 8019ef6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->SC_Support = SC_Support;
 8019efa:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019efe:	1d7a      	adds	r2, r7, #5
 8019f00:	7812      	ldrb	r2, [r2, #0]
 8019f02:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 8019f04:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f08:	3301      	adds	r3, #1
 8019f0a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->KeyPress_Notification_Support = KeyPress_Notification_Support;
 8019f0e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f12:	1d3a      	adds	r2, r7, #4
 8019f14:	7812      	ldrb	r2, [r2, #0]
 8019f16:	70da      	strb	r2, [r3, #3]
  index_input += 1;
 8019f18:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f1c:	3301      	adds	r3, #1
 8019f1e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Min_Encryption_Key_Size = Min_Encryption_Key_Size;
 8019f22:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f26:	f897 2140 	ldrb.w	r2, [r7, #320]	; 0x140
 8019f2a:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 8019f2c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f30:	3301      	adds	r3, #1
 8019f32:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Max_Encryption_Key_Size = Max_Encryption_Key_Size;
 8019f36:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f3a:	f897 2144 	ldrb.w	r2, [r7, #324]	; 0x144
 8019f3e:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 8019f40:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f44:	3301      	adds	r3, #1
 8019f46:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Use_Fixed_Pin = Use_Fixed_Pin;
 8019f4a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f4e:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 8019f52:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 8019f54:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f58:	3301      	adds	r3, #1
 8019f5a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Fixed_Pin = Fixed_Pin;
 8019f5e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f62:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8019f66:	f8c3 2007 	str.w	r2, [r3, #7]
  index_input += 4;
 8019f6a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f6e:	3304      	adds	r3, #4
 8019f70:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Identity_Address_Type = Identity_Address_Type;
 8019f74:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8019f78:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 8019f7c:	72da      	strb	r2, [r3, #11]
  index_input += 1;
 8019f7e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019f82:	3301      	adds	r3, #1
 8019f84:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8019f88:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019f8c:	2218      	movs	r2, #24
 8019f8e:	2100      	movs	r1, #0
 8019f90:	4618      	mov	r0, r3
 8019f92:	f000 fef6 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 8019f96:	233f      	movs	r3, #63	; 0x3f
 8019f98:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x086;
 8019f9c:	2386      	movs	r3, #134	; 0x86
 8019f9e:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8019fa2:	f107 0310 	add.w	r3, r7, #16
 8019fa6:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8019faa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8019fae:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8019fb2:	f107 030f 	add.w	r3, r7, #15
 8019fb6:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8019fba:	2301      	movs	r3, #1
 8019fbc:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8019fc0:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8019fc4:	2100      	movs	r1, #0
 8019fc6:	4618      	mov	r0, r3
 8019fc8:	f001 fa86 	bl	801b4d8 <hci_send_req>
 8019fcc:	4603      	mov	r3, r0
 8019fce:	2b00      	cmp	r3, #0
 8019fd0:	da01      	bge.n	8019fd6 <aci_gap_set_authentication_requirement+0x140>
    return BLE_STATUS_TIMEOUT;
 8019fd2:	23ff      	movs	r3, #255	; 0xff
 8019fd4:	e002      	b.n	8019fdc <aci_gap_set_authentication_requirement+0x146>
  return status;
 8019fd6:	f107 030f 	add.w	r3, r7, #15
 8019fda:	781b      	ldrb	r3, [r3, #0]
}
 8019fdc:	4618      	mov	r0, r3
 8019fde:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8019fe2:	46bd      	mov	sp, r7
 8019fe4:	bdb0      	pop	{r4, r5, r7, pc}

08019fe6 <aci_gap_init>:
                         uint8_t privacy_enabled,
                         uint8_t device_name_char_len,
                         uint16_t* Service_Handle,
                         uint16_t* Dev_Name_Char_Handle,
                         uint16_t* Appearance_Char_Handle )
{
 8019fe6:	b590      	push	{r4, r7, lr}
 8019fe8:	b0cd      	sub	sp, #308	; 0x134
 8019fea:	af00      	add	r7, sp, #0
 8019fec:	4604      	mov	r4, r0
 8019fee:	4608      	mov	r0, r1
 8019ff0:	4611      	mov	r1, r2
 8019ff2:	463a      	mov	r2, r7
 8019ff4:	6013      	str	r3, [r2, #0]
 8019ff6:	1dfb      	adds	r3, r7, #7
 8019ff8:	4622      	mov	r2, r4
 8019ffa:	701a      	strb	r2, [r3, #0]
 8019ffc:	1dbb      	adds	r3, r7, #6
 8019ffe:	4602      	mov	r2, r0
 801a000:	701a      	strb	r2, [r3, #0]
 801a002:	1d7b      	adds	r3, r7, #5
 801a004:	460a      	mov	r2, r1
 801a006:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0*)(cmd_buffer);
 801a008:	f107 0310 	add.w	r3, r7, #16
 801a00c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  aci_gap_init_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 801a010:	f107 0308 	add.w	r3, r7, #8
 801a014:	2207      	movs	r2, #7
 801a016:	2100      	movs	r1, #0
 801a018:	4618      	mov	r0, r3
 801a01a:	f000 feb2 	bl	801ad82 <Osal_MemSet>
  int index_input = 0;
 801a01e:	2300      	movs	r3, #0
 801a020:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Role = Role;
 801a024:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a028:	1dfa      	adds	r2, r7, #7
 801a02a:	7812      	ldrb	r2, [r2, #0]
 801a02c:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801a02e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a032:	3301      	adds	r3, #1
 801a034:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->privacy_enabled = privacy_enabled;
 801a038:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a03c:	1dba      	adds	r2, r7, #6
 801a03e:	7812      	ldrb	r2, [r2, #0]
 801a040:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 801a042:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a046:	3301      	adds	r3, #1
 801a048:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->device_name_char_len = device_name_char_len;
 801a04c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a050:	1d7a      	adds	r2, r7, #5
 801a052:	7812      	ldrb	r2, [r2, #0]
 801a054:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 801a056:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a05a:	3301      	adds	r3, #1
 801a05c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a060:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a064:	2218      	movs	r2, #24
 801a066:	2100      	movs	r1, #0
 801a068:	4618      	mov	r0, r3
 801a06a:	f000 fe8a 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a06e:	233f      	movs	r3, #63	; 0x3f
 801a070:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x08a;
 801a074:	238a      	movs	r3, #138	; 0x8a
 801a076:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a07a:	f107 0310 	add.w	r3, r7, #16
 801a07e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a082:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a086:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &resp;
 801a08a:	f107 0308 	add.w	r3, r7, #8
 801a08e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = sizeof(resp);
 801a092:	2307      	movs	r3, #7
 801a094:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a098:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a09c:	2100      	movs	r1, #0
 801a09e:	4618      	mov	r0, r3
 801a0a0:	f001 fa1a 	bl	801b4d8 <hci_send_req>
 801a0a4:	4603      	mov	r3, r0
 801a0a6:	2b00      	cmp	r3, #0
 801a0a8:	da01      	bge.n	801a0ae <aci_gap_init+0xc8>
    return BLE_STATUS_TIMEOUT;
 801a0aa:	23ff      	movs	r3, #255	; 0xff
 801a0ac:	e021      	b.n	801a0f2 <aci_gap_init+0x10c>
  if ( resp.Status )
 801a0ae:	f107 0308 	add.w	r3, r7, #8
 801a0b2:	781b      	ldrb	r3, [r3, #0]
 801a0b4:	2b00      	cmp	r3, #0
 801a0b6:	d003      	beq.n	801a0c0 <aci_gap_init+0xda>
    return resp.Status;
 801a0b8:	f107 0308 	add.w	r3, r7, #8
 801a0bc:	781b      	ldrb	r3, [r3, #0]
 801a0be:	e018      	b.n	801a0f2 <aci_gap_init+0x10c>
  *Service_Handle = resp.Service_Handle;
 801a0c0:	f107 0308 	add.w	r3, r7, #8
 801a0c4:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a0c8:	b29a      	uxth	r2, r3
 801a0ca:	463b      	mov	r3, r7
 801a0cc:	681b      	ldr	r3, [r3, #0]
 801a0ce:	801a      	strh	r2, [r3, #0]
  *Dev_Name_Char_Handle = resp.Dev_Name_Char_Handle;
 801a0d0:	f107 0308 	add.w	r3, r7, #8
 801a0d4:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 801a0d8:	b29a      	uxth	r2, r3
 801a0da:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 801a0de:	801a      	strh	r2, [r3, #0]
  *Appearance_Char_Handle = resp.Appearance_Char_Handle;
 801a0e0:	f107 0308 	add.w	r3, r7, #8
 801a0e4:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 801a0e8:	b29a      	uxth	r2, r3
 801a0ea:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 801a0ee:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 801a0f0:	2300      	movs	r3, #0
}
 801a0f2:	4618      	mov	r0, r3
 801a0f4:	f507 779a 	add.w	r7, r7, #308	; 0x134
 801a0f8:	46bd      	mov	sp, r7
 801a0fa:	bd90      	pop	{r4, r7, pc}

0801a0fc <aci_gap_update_adv_data>:
  return status;
}

tBleStatus aci_gap_update_adv_data( uint8_t AdvDataLen,
                                    const uint8_t* AdvData )
{
 801a0fc:	b580      	push	{r7, lr}
 801a0fe:	b0cc      	sub	sp, #304	; 0x130
 801a100:	af00      	add	r7, sp, #0
 801a102:	4602      	mov	r2, r0
 801a104:	463b      	mov	r3, r7
 801a106:	6019      	str	r1, [r3, #0]
 801a108:	1dfb      	adds	r3, r7, #7
 801a10a:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_update_adv_data_cp0 *cp0 = (aci_gap_update_adv_data_cp0*)(cmd_buffer);
 801a10c:	f107 0310 	add.w	r3, r7, #16
 801a110:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a114:	f107 030f 	add.w	r3, r7, #15
 801a118:	2200      	movs	r2, #0
 801a11a:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a11c:	2300      	movs	r3, #0
 801a11e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->AdvDataLen = AdvDataLen;
 801a122:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a126:	1dfa      	adds	r2, r7, #7
 801a128:	7812      	ldrb	r2, [r2, #0]
 801a12a:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801a12c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a130:	3301      	adds	r3, #1
 801a132:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->AdvData, (const void*)AdvData, AdvDataLen );
 801a136:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a13a:	1c58      	adds	r0, r3, #1
 801a13c:	1dfb      	adds	r3, r7, #7
 801a13e:	781a      	ldrb	r2, [r3, #0]
 801a140:	463b      	mov	r3, r7
 801a142:	6819      	ldr	r1, [r3, #0]
 801a144:	f000 fe0d 	bl	801ad62 <Osal_MemCpy>
  index_input += AdvDataLen;
 801a148:	1dfb      	adds	r3, r7, #7
 801a14a:	781b      	ldrb	r3, [r3, #0]
 801a14c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a150:	4413      	add	r3, r2
 801a152:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a156:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a15a:	2218      	movs	r2, #24
 801a15c:	2100      	movs	r1, #0
 801a15e:	4618      	mov	r0, r3
 801a160:	f000 fe0f 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a164:	233f      	movs	r3, #63	; 0x3f
 801a166:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x08e;
 801a16a:	238e      	movs	r3, #142	; 0x8e
 801a16c:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a170:	f107 0310 	add.w	r3, r7, #16
 801a174:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a178:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a17c:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801a180:	f107 030f 	add.w	r3, r7, #15
 801a184:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801a188:	2301      	movs	r3, #1
 801a18a:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a18e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a192:	2100      	movs	r1, #0
 801a194:	4618      	mov	r0, r3
 801a196:	f001 f99f 	bl	801b4d8 <hci_send_req>
 801a19a:	4603      	mov	r3, r0
 801a19c:	2b00      	cmp	r3, #0
 801a19e:	da01      	bge.n	801a1a4 <aci_gap_update_adv_data+0xa8>
    return BLE_STATUS_TIMEOUT;
 801a1a0:	23ff      	movs	r3, #255	; 0xff
 801a1a2:	e002      	b.n	801a1aa <aci_gap_update_adv_data+0xae>
  return status;
 801a1a4:	f107 030f 	add.w	r3, r7, #15
 801a1a8:	781b      	ldrb	r3, [r3, #0]
}
 801a1aa:	4618      	mov	r0, r3
 801a1ac:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801a1b0:	46bd      	mov	sp, r7
 801a1b2:	bd80      	pop	{r7, pc}

0801a1b4 <aci_gap_configure_whitelist>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gap_configure_whitelist( void )
{
 801a1b4:	b580      	push	{r7, lr}
 801a1b6:	b088      	sub	sp, #32
 801a1b8:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 801a1ba:	2300      	movs	r3, #0
 801a1bc:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a1be:	f107 0308 	add.w	r3, r7, #8
 801a1c2:	2218      	movs	r2, #24
 801a1c4:	2100      	movs	r1, #0
 801a1c6:	4618      	mov	r0, r3
 801a1c8:	f000 fddb 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a1cc:	233f      	movs	r3, #63	; 0x3f
 801a1ce:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x092;
 801a1d0:	2392      	movs	r3, #146	; 0x92
 801a1d2:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 801a1d4:	1dfb      	adds	r3, r7, #7
 801a1d6:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 801a1d8:	2301      	movs	r3, #1
 801a1da:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a1dc:	f107 0308 	add.w	r3, r7, #8
 801a1e0:	2100      	movs	r1, #0
 801a1e2:	4618      	mov	r0, r3
 801a1e4:	f001 f978 	bl	801b4d8 <hci_send_req>
 801a1e8:	4603      	mov	r3, r0
 801a1ea:	2b00      	cmp	r3, #0
 801a1ec:	da01      	bge.n	801a1f2 <aci_gap_configure_whitelist+0x3e>
    return BLE_STATUS_TIMEOUT;
 801a1ee:	23ff      	movs	r3, #255	; 0xff
 801a1f0:	e000      	b.n	801a1f4 <aci_gap_configure_whitelist+0x40>
  return status;
 801a1f2:	79fb      	ldrb	r3, [r7, #7]
}
 801a1f4:	4618      	mov	r0, r3
 801a1f6:	3720      	adds	r7, #32
 801a1f8:	46bd      	mov	sp, r7
 801a1fa:	bd80      	pop	{r7, pc}

0801a1fc <aci_gatt_init>:
 */

#include "ble_gatt_aci.h"

tBleStatus aci_gatt_init( void )
{
 801a1fc:	b580      	push	{r7, lr}
 801a1fe:	b088      	sub	sp, #32
 801a200:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 801a202:	2300      	movs	r3, #0
 801a204:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a206:	f107 0308 	add.w	r3, r7, #8
 801a20a:	2218      	movs	r2, #24
 801a20c:	2100      	movs	r1, #0
 801a20e:	4618      	mov	r0, r3
 801a210:	f000 fdb7 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a214:	233f      	movs	r3, #63	; 0x3f
 801a216:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x101;
 801a218:	f240 1301 	movw	r3, #257	; 0x101
 801a21c:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 801a21e:	1dfb      	adds	r3, r7, #7
 801a220:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 801a222:	2301      	movs	r3, #1
 801a224:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a226:	f107 0308 	add.w	r3, r7, #8
 801a22a:	2100      	movs	r1, #0
 801a22c:	4618      	mov	r0, r3
 801a22e:	f001 f953 	bl	801b4d8 <hci_send_req>
 801a232:	4603      	mov	r3, r0
 801a234:	2b00      	cmp	r3, #0
 801a236:	da01      	bge.n	801a23c <aci_gatt_init+0x40>
    return BLE_STATUS_TIMEOUT;
 801a238:	23ff      	movs	r3, #255	; 0xff
 801a23a:	e000      	b.n	801a23e <aci_gatt_init+0x42>
  return status;
 801a23c:	79fb      	ldrb	r3, [r7, #7]
}
 801a23e:	4618      	mov	r0, r3
 801a240:	3720      	adds	r7, #32
 801a242:	46bd      	mov	sp, r7
 801a244:	bd80      	pop	{r7, pc}

0801a246 <aci_gatt_add_service>:
tBleStatus aci_gatt_add_service( uint8_t Service_UUID_Type,
                                 const Service_UUID_t* Service_UUID,
                                 uint8_t Service_Type,
                                 uint8_t Max_Attribute_Records,
                                 uint16_t* Service_Handle )
{
 801a246:	b590      	push	{r4, r7, lr}
 801a248:	b0cf      	sub	sp, #316	; 0x13c
 801a24a:	af00      	add	r7, sp, #0
 801a24c:	4604      	mov	r4, r0
 801a24e:	4638      	mov	r0, r7
 801a250:	6001      	str	r1, [r0, #0]
 801a252:	4610      	mov	r0, r2
 801a254:	4619      	mov	r1, r3
 801a256:	1dfb      	adds	r3, r7, #7
 801a258:	4622      	mov	r2, r4
 801a25a:	701a      	strb	r2, [r3, #0]
 801a25c:	1dbb      	adds	r3, r7, #6
 801a25e:	4602      	mov	r2, r0
 801a260:	701a      	strb	r2, [r3, #0]
 801a262:	1d7b      	adds	r3, r7, #5
 801a264:	460a      	mov	r2, r1
 801a266:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_service_cp0 *cp0 = (aci_gatt_add_service_cp0*)(cmd_buffer);
 801a268:	f107 0310 	add.w	r3, r7, #16
 801a26c:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  aci_gatt_add_service_cp1 *cp1 = (aci_gatt_add_service_cp1*)(cmd_buffer + 1 + (Service_UUID_Type == 1 ? 2 : (Service_UUID_Type == 2 ? 16 : 0)));
 801a270:	1dfb      	adds	r3, r7, #7
 801a272:	781b      	ldrb	r3, [r3, #0]
 801a274:	2b01      	cmp	r3, #1
 801a276:	d007      	beq.n	801a288 <aci_gatt_add_service+0x42>
 801a278:	1dfb      	adds	r3, r7, #7
 801a27a:	781b      	ldrb	r3, [r3, #0]
 801a27c:	2b02      	cmp	r3, #2
 801a27e:	d101      	bne.n	801a284 <aci_gatt_add_service+0x3e>
 801a280:	2311      	movs	r3, #17
 801a282:	e002      	b.n	801a28a <aci_gatt_add_service+0x44>
 801a284:	2301      	movs	r3, #1
 801a286:	e000      	b.n	801a28a <aci_gatt_add_service+0x44>
 801a288:	2303      	movs	r3, #3
 801a28a:	f107 0210 	add.w	r2, r7, #16
 801a28e:	4413      	add	r3, r2
 801a290:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  aci_gatt_add_service_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 801a294:	f107 030c 	add.w	r3, r7, #12
 801a298:	2203      	movs	r2, #3
 801a29a:	2100      	movs	r1, #0
 801a29c:	4618      	mov	r0, r3
 801a29e:	f000 fd70 	bl	801ad82 <Osal_MemSet>
  int index_input = 0;
 801a2a2:	2300      	movs	r3, #0
 801a2a4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Service_UUID_Type = Service_UUID_Type;
 801a2a8:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a2ac:	1dfa      	adds	r2, r7, #7
 801a2ae:	7812      	ldrb	r2, [r2, #0]
 801a2b0:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801a2b2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a2b6:	3301      	adds	r3, #1
 801a2b8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Service_UUID_Type )
 801a2bc:	1dfb      	adds	r3, r7, #7
 801a2be:	781b      	ldrb	r3, [r3, #0]
 801a2c0:	2b01      	cmp	r3, #1
 801a2c2:	d002      	beq.n	801a2ca <aci_gatt_add_service+0x84>
 801a2c4:	2b02      	cmp	r3, #2
 801a2c6:	d004      	beq.n	801a2d2 <aci_gatt_add_service+0x8c>
 801a2c8:	e007      	b.n	801a2da <aci_gatt_add_service+0x94>
    {
      case 1: size = 2; break;
 801a2ca:	2302      	movs	r3, #2
 801a2cc:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 801a2d0:	e005      	b.n	801a2de <aci_gatt_add_service+0x98>
      case 2: size = 16; break;
 801a2d2:	2310      	movs	r3, #16
 801a2d4:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 801a2d8:	e001      	b.n	801a2de <aci_gatt_add_service+0x98>
      default: return BLE_STATUS_ERROR;
 801a2da:	2397      	movs	r3, #151	; 0x97
 801a2dc:	e05d      	b.n	801a39a <aci_gatt_add_service+0x154>
    }
    Osal_MemCpy( (void*)&cp0->Service_UUID, (const void*)Service_UUID, size );
 801a2de:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a2e2:	1c58      	adds	r0, r3, #1
 801a2e4:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 801a2e8:	463b      	mov	r3, r7
 801a2ea:	6819      	ldr	r1, [r3, #0]
 801a2ec:	f000 fd39 	bl	801ad62 <Osal_MemCpy>
    index_input += size;
 801a2f0:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 801a2f4:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a2f8:	4413      	add	r3, r2
 801a2fa:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Service_Type = Service_Type;
 801a2fe:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a302:	1dba      	adds	r2, r7, #6
 801a304:	7812      	ldrb	r2, [r2, #0]
 801a306:	701a      	strb	r2, [r3, #0]
    }
    index_input += 1;
 801a308:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a30c:	3301      	adds	r3, #1
 801a30e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Max_Attribute_Records = Max_Attribute_Records;
 801a312:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a316:	1d7a      	adds	r2, r7, #5
 801a318:	7812      	ldrb	r2, [r2, #0]
 801a31a:	705a      	strb	r2, [r3, #1]
    }
    index_input += 1;
 801a31c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a320:	3301      	adds	r3, #1
 801a322:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a326:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a32a:	2218      	movs	r2, #24
 801a32c:	2100      	movs	r1, #0
 801a32e:	4618      	mov	r0, r3
 801a330:	f000 fd27 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a334:	233f      	movs	r3, #63	; 0x3f
 801a336:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x102;
 801a33a:	f44f 7381 	mov.w	r3, #258	; 0x102
 801a33e:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a342:	f107 0310 	add.w	r3, r7, #16
 801a346:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a34a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a34e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &resp;
 801a352:	f107 030c 	add.w	r3, r7, #12
 801a356:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = sizeof(resp);
 801a35a:	2303      	movs	r3, #3
 801a35c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a360:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a364:	2100      	movs	r1, #0
 801a366:	4618      	mov	r0, r3
 801a368:	f001 f8b6 	bl	801b4d8 <hci_send_req>
 801a36c:	4603      	mov	r3, r0
 801a36e:	2b00      	cmp	r3, #0
 801a370:	da01      	bge.n	801a376 <aci_gatt_add_service+0x130>
    return BLE_STATUS_TIMEOUT;
 801a372:	23ff      	movs	r3, #255	; 0xff
 801a374:	e011      	b.n	801a39a <aci_gatt_add_service+0x154>
  if ( resp.Status )
 801a376:	f107 030c 	add.w	r3, r7, #12
 801a37a:	781b      	ldrb	r3, [r3, #0]
 801a37c:	2b00      	cmp	r3, #0
 801a37e:	d003      	beq.n	801a388 <aci_gatt_add_service+0x142>
    return resp.Status;
 801a380:	f107 030c 	add.w	r3, r7, #12
 801a384:	781b      	ldrb	r3, [r3, #0]
 801a386:	e008      	b.n	801a39a <aci_gatt_add_service+0x154>
  *Service_Handle = resp.Service_Handle;
 801a388:	f107 030c 	add.w	r3, r7, #12
 801a38c:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a390:	b29a      	uxth	r2, r3
 801a392:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801a396:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 801a398:	2300      	movs	r3, #0
}
 801a39a:	4618      	mov	r0, r3
 801a39c:	f507 779e 	add.w	r7, r7, #316	; 0x13c
 801a3a0:	46bd      	mov	sp, r7
 801a3a2:	bd90      	pop	{r4, r7, pc}

0801a3a4 <aci_gatt_add_char>:
                              uint8_t Security_Permissions,
                              uint8_t GATT_Evt_Mask,
                              uint8_t Enc_Key_Size,
                              uint8_t Is_Variable,
                              uint16_t* Char_Handle )
{
 801a3a4:	b590      	push	{r4, r7, lr}
 801a3a6:	b0d1      	sub	sp, #324	; 0x144
 801a3a8:	af00      	add	r7, sp, #0
 801a3aa:	4604      	mov	r4, r0
 801a3ac:	4608      	mov	r0, r1
 801a3ae:	f107 0108 	add.w	r1, r7, #8
 801a3b2:	600a      	str	r2, [r1, #0]
 801a3b4:	4619      	mov	r1, r3
 801a3b6:	f107 030e 	add.w	r3, r7, #14
 801a3ba:	4622      	mov	r2, r4
 801a3bc:	801a      	strh	r2, [r3, #0]
 801a3be:	f107 030d 	add.w	r3, r7, #13
 801a3c2:	4602      	mov	r2, r0
 801a3c4:	701a      	strb	r2, [r3, #0]
 801a3c6:	1dbb      	adds	r3, r7, #6
 801a3c8:	460a      	mov	r2, r1
 801a3ca:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_char_cp0 *cp0 = (aci_gatt_add_char_cp0*)(cmd_buffer);
 801a3cc:	f107 0318 	add.w	r3, r7, #24
 801a3d0:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
  aci_gatt_add_char_cp1 *cp1 = (aci_gatt_add_char_cp1*)(cmd_buffer + 2 + 1 + (Char_UUID_Type == 1 ? 2 : (Char_UUID_Type == 2 ? 16 : 0)));
 801a3d4:	f107 030d 	add.w	r3, r7, #13
 801a3d8:	781b      	ldrb	r3, [r3, #0]
 801a3da:	2b01      	cmp	r3, #1
 801a3dc:	d008      	beq.n	801a3f0 <aci_gatt_add_char+0x4c>
 801a3de:	f107 030d 	add.w	r3, r7, #13
 801a3e2:	781b      	ldrb	r3, [r3, #0]
 801a3e4:	2b02      	cmp	r3, #2
 801a3e6:	d101      	bne.n	801a3ec <aci_gatt_add_char+0x48>
 801a3e8:	2313      	movs	r3, #19
 801a3ea:	e002      	b.n	801a3f2 <aci_gatt_add_char+0x4e>
 801a3ec:	2303      	movs	r3, #3
 801a3ee:	e000      	b.n	801a3f2 <aci_gatt_add_char+0x4e>
 801a3f0:	2305      	movs	r3, #5
 801a3f2:	f107 0218 	add.w	r2, r7, #24
 801a3f6:	4413      	add	r3, r2
 801a3f8:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
  aci_gatt_add_char_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 801a3fc:	f107 0314 	add.w	r3, r7, #20
 801a400:	2203      	movs	r2, #3
 801a402:	2100      	movs	r1, #0
 801a404:	4618      	mov	r0, r3
 801a406:	f000 fcbc 	bl	801ad82 <Osal_MemSet>
  int index_input = 0;
 801a40a:	2300      	movs	r3, #0
 801a40c:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  cp0->Service_Handle = Service_Handle;
 801a410:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801a414:	f107 020e 	add.w	r2, r7, #14
 801a418:	8812      	ldrh	r2, [r2, #0]
 801a41a:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801a41c:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a420:	3302      	adds	r3, #2
 801a422:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  cp0->Char_UUID_Type = Char_UUID_Type;
 801a426:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801a42a:	f107 020d 	add.w	r2, r7, #13
 801a42e:	7812      	ldrb	r2, [r2, #0]
 801a430:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 801a432:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a436:	3301      	adds	r3, #1
 801a438:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Char_UUID_Type )
 801a43c:	f107 030d 	add.w	r3, r7, #13
 801a440:	781b      	ldrb	r3, [r3, #0]
 801a442:	2b01      	cmp	r3, #1
 801a444:	d002      	beq.n	801a44c <aci_gatt_add_char+0xa8>
 801a446:	2b02      	cmp	r3, #2
 801a448:	d004      	beq.n	801a454 <aci_gatt_add_char+0xb0>
 801a44a:	e007      	b.n	801a45c <aci_gatt_add_char+0xb8>
    {
      case 1: size = 2; break;
 801a44c:	2302      	movs	r3, #2
 801a44e:	f887 313f 	strb.w	r3, [r7, #319]	; 0x13f
 801a452:	e005      	b.n	801a460 <aci_gatt_add_char+0xbc>
      case 2: size = 16; break;
 801a454:	2310      	movs	r3, #16
 801a456:	f887 313f 	strb.w	r3, [r7, #319]	; 0x13f
 801a45a:	e001      	b.n	801a460 <aci_gatt_add_char+0xbc>
      default: return BLE_STATUS_ERROR;
 801a45c:	2397      	movs	r3, #151	; 0x97
 801a45e:	e086      	b.n	801a56e <aci_gatt_add_char+0x1ca>
    }
    Osal_MemCpy( (void*)&cp0->Char_UUID, (const void*)Char_UUID, size );
 801a460:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801a464:	1cd8      	adds	r0, r3, #3
 801a466:	f897 213f 	ldrb.w	r2, [r7, #319]	; 0x13f
 801a46a:	f107 0308 	add.w	r3, r7, #8
 801a46e:	6819      	ldr	r1, [r3, #0]
 801a470:	f000 fc77 	bl	801ad62 <Osal_MemCpy>
    index_input += size;
 801a474:	f897 313f 	ldrb.w	r3, [r7, #319]	; 0x13f
 801a478:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 801a47c:	4413      	add	r3, r2
 801a47e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Char_Value_Length = Char_Value_Length;
 801a482:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a486:	1dba      	adds	r2, r7, #6
 801a488:	8812      	ldrh	r2, [r2, #0]
 801a48a:	801a      	strh	r2, [r3, #0]
    }
    index_input += 2;
 801a48c:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a490:	3302      	adds	r3, #2
 801a492:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Char_Properties = Char_Properties;
 801a496:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a49a:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 801a49e:	709a      	strb	r2, [r3, #2]
    }
    index_input += 1;
 801a4a0:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a4a4:	3301      	adds	r3, #1
 801a4a6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Security_Permissions = Security_Permissions;
 801a4aa:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a4ae:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 801a4b2:	70da      	strb	r2, [r3, #3]
    }
    index_input += 1;
 801a4b4:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a4b8:	3301      	adds	r3, #1
 801a4ba:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->GATT_Evt_Mask = GATT_Evt_Mask;
 801a4be:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a4c2:	f897 2158 	ldrb.w	r2, [r7, #344]	; 0x158
 801a4c6:	711a      	strb	r2, [r3, #4]
    }
    index_input += 1;
 801a4c8:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a4cc:	3301      	adds	r3, #1
 801a4ce:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Enc_Key_Size = Enc_Key_Size;
 801a4d2:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a4d6:	f897 215c 	ldrb.w	r2, [r7, #348]	; 0x15c
 801a4da:	715a      	strb	r2, [r3, #5]
    }
    index_input += 1;
 801a4dc:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a4e0:	3301      	adds	r3, #1
 801a4e2:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Is_Variable = Is_Variable;
 801a4e6:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801a4ea:	f897 2160 	ldrb.w	r2, [r7, #352]	; 0x160
 801a4ee:	719a      	strb	r2, [r3, #6]
    }
    index_input += 1;
 801a4f0:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a4f4:	3301      	adds	r3, #1
 801a4f6:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a4fa:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801a4fe:	2218      	movs	r2, #24
 801a500:	2100      	movs	r1, #0
 801a502:	4618      	mov	r0, r3
 801a504:	f000 fc3d 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a508:	233f      	movs	r3, #63	; 0x3f
 801a50a:	f8a7 3118 	strh.w	r3, [r7, #280]	; 0x118
  rq.ocf = 0x104;
 801a50e:	f44f 7382 	mov.w	r3, #260	; 0x104
 801a512:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
  rq.cparam = cmd_buffer;
 801a516:	f107 0318 	add.w	r3, r7, #24
 801a51a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.clen = index_input;
 801a51e:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801a522:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  rq.rparam = &resp;
 801a526:	f107 0314 	add.w	r3, r7, #20
 801a52a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  rq.rlen = sizeof(resp);
 801a52e:	2303      	movs	r3, #3
 801a530:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a534:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801a538:	2100      	movs	r1, #0
 801a53a:	4618      	mov	r0, r3
 801a53c:	f000 ffcc 	bl	801b4d8 <hci_send_req>
 801a540:	4603      	mov	r3, r0
 801a542:	2b00      	cmp	r3, #0
 801a544:	da01      	bge.n	801a54a <aci_gatt_add_char+0x1a6>
    return BLE_STATUS_TIMEOUT;
 801a546:	23ff      	movs	r3, #255	; 0xff
 801a548:	e011      	b.n	801a56e <aci_gatt_add_char+0x1ca>
  if ( resp.Status )
 801a54a:	f107 0314 	add.w	r3, r7, #20
 801a54e:	781b      	ldrb	r3, [r3, #0]
 801a550:	2b00      	cmp	r3, #0
 801a552:	d003      	beq.n	801a55c <aci_gatt_add_char+0x1b8>
    return resp.Status;
 801a554:	f107 0314 	add.w	r3, r7, #20
 801a558:	781b      	ldrb	r3, [r3, #0]
 801a55a:	e008      	b.n	801a56e <aci_gatt_add_char+0x1ca>
  *Char_Handle = resp.Char_Handle;
 801a55c:	f107 0314 	add.w	r3, r7, #20
 801a560:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801a564:	b29a      	uxth	r2, r3
 801a566:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801a56a:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 801a56c:	2300      	movs	r3, #0
}
 801a56e:	4618      	mov	r0, r3
 801a570:	f507 77a2 	add.w	r7, r7, #324	; 0x144
 801a574:	46bd      	mov	sp, r7
 801a576:	bd90      	pop	{r4, r7, pc}

0801a578 <aci_gatt_update_char_value>:
tBleStatus aci_gatt_update_char_value( uint16_t Service_Handle,
                                       uint16_t Char_Handle,
                                       uint8_t Val_Offset,
                                       uint8_t Char_Value_Length,
                                       const uint8_t* Char_Value )
{
 801a578:	b5b0      	push	{r4, r5, r7, lr}
 801a57a:	b0cc      	sub	sp, #304	; 0x130
 801a57c:	af00      	add	r7, sp, #0
 801a57e:	4605      	mov	r5, r0
 801a580:	460c      	mov	r4, r1
 801a582:	4610      	mov	r0, r2
 801a584:	4619      	mov	r1, r3
 801a586:	1dbb      	adds	r3, r7, #6
 801a588:	462a      	mov	r2, r5
 801a58a:	801a      	strh	r2, [r3, #0]
 801a58c:	1d3b      	adds	r3, r7, #4
 801a58e:	4622      	mov	r2, r4
 801a590:	801a      	strh	r2, [r3, #0]
 801a592:	1cfb      	adds	r3, r7, #3
 801a594:	4602      	mov	r2, r0
 801a596:	701a      	strb	r2, [r3, #0]
 801a598:	1cbb      	adds	r3, r7, #2
 801a59a:	460a      	mov	r2, r1
 801a59c:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_update_char_value_cp0 *cp0 = (aci_gatt_update_char_value_cp0*)(cmd_buffer);
 801a59e:	f107 0310 	add.w	r3, r7, #16
 801a5a2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a5a6:	f107 030f 	add.w	r3, r7, #15
 801a5aa:	2200      	movs	r2, #0
 801a5ac:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a5ae:	2300      	movs	r3, #0
 801a5b0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Service_Handle = Service_Handle;
 801a5b4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a5b8:	1dba      	adds	r2, r7, #6
 801a5ba:	8812      	ldrh	r2, [r2, #0]
 801a5bc:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801a5be:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a5c2:	3302      	adds	r3, #2
 801a5c4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Handle = Char_Handle;
 801a5c8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a5cc:	1d3a      	adds	r2, r7, #4
 801a5ce:	8812      	ldrh	r2, [r2, #0]
 801a5d0:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 801a5d2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a5d6:	3302      	adds	r3, #2
 801a5d8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Val_Offset = Val_Offset;
 801a5dc:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a5e0:	1cfa      	adds	r2, r7, #3
 801a5e2:	7812      	ldrb	r2, [r2, #0]
 801a5e4:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 801a5e6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a5ea:	3301      	adds	r3, #1
 801a5ec:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Value_Length = Char_Value_Length;
 801a5f0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a5f4:	1cba      	adds	r2, r7, #2
 801a5f6:	7812      	ldrb	r2, [r2, #0]
 801a5f8:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 801a5fa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a5fe:	3301      	adds	r3, #1
 801a600:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Char_Value, (const void*)Char_Value, Char_Value_Length );
 801a604:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a608:	1d98      	adds	r0, r3, #6
 801a60a:	1cbb      	adds	r3, r7, #2
 801a60c:	781b      	ldrb	r3, [r3, #0]
 801a60e:	461a      	mov	r2, r3
 801a610:	f8d7 1140 	ldr.w	r1, [r7, #320]	; 0x140
 801a614:	f000 fba5 	bl	801ad62 <Osal_MemCpy>
  index_input += Char_Value_Length;
 801a618:	1cbb      	adds	r3, r7, #2
 801a61a:	781b      	ldrb	r3, [r3, #0]
 801a61c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a620:	4413      	add	r3, r2
 801a622:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a626:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a62a:	2218      	movs	r2, #24
 801a62c:	2100      	movs	r1, #0
 801a62e:	4618      	mov	r0, r3
 801a630:	f000 fba7 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a634:	233f      	movs	r3, #63	; 0x3f
 801a636:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x106;
 801a63a:	f44f 7383 	mov.w	r3, #262	; 0x106
 801a63e:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a642:	f107 0310 	add.w	r3, r7, #16
 801a646:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a64a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a64e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801a652:	f107 030f 	add.w	r3, r7, #15
 801a656:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801a65a:	2301      	movs	r3, #1
 801a65c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a660:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a664:	2100      	movs	r1, #0
 801a666:	4618      	mov	r0, r3
 801a668:	f000 ff36 	bl	801b4d8 <hci_send_req>
 801a66c:	4603      	mov	r3, r0
 801a66e:	2b00      	cmp	r3, #0
 801a670:	da01      	bge.n	801a676 <aci_gatt_update_char_value+0xfe>
    return BLE_STATUS_TIMEOUT;
 801a672:	23ff      	movs	r3, #255	; 0xff
 801a674:	e002      	b.n	801a67c <aci_gatt_update_char_value+0x104>
  return status;
 801a676:	f107 030f 	add.w	r3, r7, #15
 801a67a:	781b      	ldrb	r3, [r3, #0]
}
 801a67c:	4618      	mov	r0, r3
 801a67e:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801a682:	46bd      	mov	sp, r7
 801a684:	bdb0      	pop	{r4, r5, r7, pc}

0801a686 <aci_gatt_write_resp>:
                                uint16_t Attr_Handle,
                                uint8_t Write_status,
                                uint8_t Error_Code,
                                uint8_t Attribute_Val_Length,
                                const uint8_t* Attribute_Val )
{
 801a686:	b5b0      	push	{r4, r5, r7, lr}
 801a688:	b0cc      	sub	sp, #304	; 0x130
 801a68a:	af00      	add	r7, sp, #0
 801a68c:	4605      	mov	r5, r0
 801a68e:	460c      	mov	r4, r1
 801a690:	4610      	mov	r0, r2
 801a692:	4619      	mov	r1, r3
 801a694:	1dbb      	adds	r3, r7, #6
 801a696:	462a      	mov	r2, r5
 801a698:	801a      	strh	r2, [r3, #0]
 801a69a:	1d3b      	adds	r3, r7, #4
 801a69c:	4622      	mov	r2, r4
 801a69e:	801a      	strh	r2, [r3, #0]
 801a6a0:	1cfb      	adds	r3, r7, #3
 801a6a2:	4602      	mov	r2, r0
 801a6a4:	701a      	strb	r2, [r3, #0]
 801a6a6:	1cbb      	adds	r3, r7, #2
 801a6a8:	460a      	mov	r2, r1
 801a6aa:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_write_resp_cp0 *cp0 = (aci_gatt_write_resp_cp0*)(cmd_buffer);
 801a6ac:	f107 0310 	add.w	r3, r7, #16
 801a6b0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a6b4:	f107 030f 	add.w	r3, r7, #15
 801a6b8:	2200      	movs	r2, #0
 801a6ba:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a6bc:	2300      	movs	r3, #0
 801a6be:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Connection_Handle = Connection_Handle;
 801a6c2:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a6c6:	1dba      	adds	r2, r7, #6
 801a6c8:	8812      	ldrh	r2, [r2, #0]
 801a6ca:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801a6cc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a6d0:	3302      	adds	r3, #2
 801a6d2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Attr_Handle = Attr_Handle;
 801a6d6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a6da:	1d3a      	adds	r2, r7, #4
 801a6dc:	8812      	ldrh	r2, [r2, #0]
 801a6de:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 801a6e0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a6e4:	3302      	adds	r3, #2
 801a6e6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Write_status = Write_status;
 801a6ea:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a6ee:	1cfa      	adds	r2, r7, #3
 801a6f0:	7812      	ldrb	r2, [r2, #0]
 801a6f2:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 801a6f4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a6f8:	3301      	adds	r3, #1
 801a6fa:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Error_Code = Error_Code;
 801a6fe:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a702:	1cba      	adds	r2, r7, #2
 801a704:	7812      	ldrb	r2, [r2, #0]
 801a706:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 801a708:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a70c:	3301      	adds	r3, #1
 801a70e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Attribute_Val_Length = Attribute_Val_Length;
 801a712:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a716:	f897 2140 	ldrb.w	r2, [r7, #320]	; 0x140
 801a71a:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 801a71c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a720:	3301      	adds	r3, #1
 801a722:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Attribute_Val, (const void*)Attribute_Val, Attribute_Val_Length );
 801a726:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a72a:	3307      	adds	r3, #7
 801a72c:	f897 2140 	ldrb.w	r2, [r7, #320]	; 0x140
 801a730:	f8d7 1144 	ldr.w	r1, [r7, #324]	; 0x144
 801a734:	4618      	mov	r0, r3
 801a736:	f000 fb14 	bl	801ad62 <Osal_MemCpy>
  index_input += Attribute_Val_Length;
 801a73a:	f897 3140 	ldrb.w	r3, [r7, #320]	; 0x140
 801a73e:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a742:	4413      	add	r3, r2
 801a744:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a748:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a74c:	2218      	movs	r2, #24
 801a74e:	2100      	movs	r1, #0
 801a750:	4618      	mov	r0, r3
 801a752:	f000 fb16 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a756:	233f      	movs	r3, #63	; 0x3f
 801a758:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x126;
 801a75c:	f44f 7393 	mov.w	r3, #294	; 0x126
 801a760:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a764:	f107 0310 	add.w	r3, r7, #16
 801a768:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a76c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a770:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801a774:	f107 030f 	add.w	r3, r7, #15
 801a778:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801a77c:	2301      	movs	r3, #1
 801a77e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a782:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a786:	2100      	movs	r1, #0
 801a788:	4618      	mov	r0, r3
 801a78a:	f000 fea5 	bl	801b4d8 <hci_send_req>
 801a78e:	4603      	mov	r3, r0
 801a790:	2b00      	cmp	r3, #0
 801a792:	da01      	bge.n	801a798 <aci_gatt_write_resp+0x112>
    return BLE_STATUS_TIMEOUT;
 801a794:	23ff      	movs	r3, #255	; 0xff
 801a796:	e002      	b.n	801a79e <aci_gatt_write_resp+0x118>
  return status;
 801a798:	f107 030f 	add.w	r3, r7, #15
 801a79c:	781b      	ldrb	r3, [r3, #0]
}
 801a79e:	4618      	mov	r0, r3
 801a7a0:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801a7a4:	46bd      	mov	sp, r7
 801a7a6:	bdb0      	pop	{r4, r5, r7, pc}

0801a7a8 <aci_gatt_update_char_value_ext>:
                                           uint8_t Update_Type,
                                           uint16_t Char_Length,
                                           uint16_t Value_Offset,
                                           uint8_t Value_Length,
                                           const uint8_t* Value )
{
 801a7a8:	b5b0      	push	{r4, r5, r7, lr}
 801a7aa:	b0cc      	sub	sp, #304	; 0x130
 801a7ac:	af00      	add	r7, sp, #0
 801a7ae:	4605      	mov	r5, r0
 801a7b0:	460c      	mov	r4, r1
 801a7b2:	4610      	mov	r0, r2
 801a7b4:	4619      	mov	r1, r3
 801a7b6:	1dbb      	adds	r3, r7, #6
 801a7b8:	462a      	mov	r2, r5
 801a7ba:	801a      	strh	r2, [r3, #0]
 801a7bc:	1d3b      	adds	r3, r7, #4
 801a7be:	4622      	mov	r2, r4
 801a7c0:	801a      	strh	r2, [r3, #0]
 801a7c2:	1cbb      	adds	r3, r7, #2
 801a7c4:	4602      	mov	r2, r0
 801a7c6:	801a      	strh	r2, [r3, #0]
 801a7c8:	1c7b      	adds	r3, r7, #1
 801a7ca:	460a      	mov	r2, r1
 801a7cc:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_update_char_value_ext_cp0 *cp0 = (aci_gatt_update_char_value_ext_cp0*)(cmd_buffer);
 801a7ce:	f107 0310 	add.w	r3, r7, #16
 801a7d2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a7d6:	f107 030f 	add.w	r3, r7, #15
 801a7da:	2200      	movs	r2, #0
 801a7dc:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a7de:	2300      	movs	r3, #0
 801a7e0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Conn_Handle_To_Notify = Conn_Handle_To_Notify;
 801a7e4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a7e8:	1dba      	adds	r2, r7, #6
 801a7ea:	8812      	ldrh	r2, [r2, #0]
 801a7ec:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801a7ee:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a7f2:	3302      	adds	r3, #2
 801a7f4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Service_Handle = Service_Handle;
 801a7f8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a7fc:	1d3a      	adds	r2, r7, #4
 801a7fe:	8812      	ldrh	r2, [r2, #0]
 801a800:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 801a802:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a806:	3302      	adds	r3, #2
 801a808:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Handle = Char_Handle;
 801a80c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a810:	1cba      	adds	r2, r7, #2
 801a812:	8812      	ldrh	r2, [r2, #0]
 801a814:	809a      	strh	r2, [r3, #4]
  index_input += 2;
 801a816:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a81a:	3302      	adds	r3, #2
 801a81c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Update_Type = Update_Type;
 801a820:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a824:	1c7a      	adds	r2, r7, #1
 801a826:	7812      	ldrb	r2, [r2, #0]
 801a828:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 801a82a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a82e:	3301      	adds	r3, #1
 801a830:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Length = Char_Length;
 801a834:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a838:	f8b7 2140 	ldrh.w	r2, [r7, #320]	; 0x140
 801a83c:	f8a3 2007 	strh.w	r2, [r3, #7]
  index_input += 2;
 801a840:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a844:	3302      	adds	r3, #2
 801a846:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Value_Offset = Value_Offset;
 801a84a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a84e:	f8b7 2144 	ldrh.w	r2, [r7, #324]	; 0x144
 801a852:	f8a3 2009 	strh.w	r2, [r3, #9]
  index_input += 2;
 801a856:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a85a:	3302      	adds	r3, #2
 801a85c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Value_Length = Value_Length;
 801a860:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a864:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 801a868:	72da      	strb	r2, [r3, #11]
  index_input += 1;
 801a86a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a86e:	3301      	adds	r3, #1
 801a870:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Value, (const void*)Value, Value_Length );
 801a874:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a878:	330c      	adds	r3, #12
 801a87a:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 801a87e:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 801a882:	4618      	mov	r0, r3
 801a884:	f000 fa6d 	bl	801ad62 <Osal_MemCpy>
  index_input += Value_Length;
 801a888:	f897 3148 	ldrb.w	r3, [r7, #328]	; 0x148
 801a88c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a890:	4413      	add	r3, r2
 801a892:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a896:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a89a:	2218      	movs	r2, #24
 801a89c:	2100      	movs	r1, #0
 801a89e:	4618      	mov	r0, r3
 801a8a0:	f000 fa6f 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a8a4:	233f      	movs	r3, #63	; 0x3f
 801a8a6:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x12c;
 801a8aa:	f44f 7396 	mov.w	r3, #300	; 0x12c
 801a8ae:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a8b2:	f107 0310 	add.w	r3, r7, #16
 801a8b6:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a8ba:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a8be:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801a8c2:	f107 030f 	add.w	r3, r7, #15
 801a8c6:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801a8ca:	2301      	movs	r3, #1
 801a8cc:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a8d0:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a8d4:	2100      	movs	r1, #0
 801a8d6:	4618      	mov	r0, r3
 801a8d8:	f000 fdfe 	bl	801b4d8 <hci_send_req>
 801a8dc:	4603      	mov	r3, r0
 801a8de:	2b00      	cmp	r3, #0
 801a8e0:	da01      	bge.n	801a8e6 <aci_gatt_update_char_value_ext+0x13e>
    return BLE_STATUS_TIMEOUT;
 801a8e2:	23ff      	movs	r3, #255	; 0xff
 801a8e4:	e002      	b.n	801a8ec <aci_gatt_update_char_value_ext+0x144>
  return status;
 801a8e6:	f107 030f 	add.w	r3, r7, #15
 801a8ea:	781b      	ldrb	r3, [r3, #0]
}
 801a8ec:	4618      	mov	r0, r3
 801a8ee:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801a8f2:	46bd      	mov	sp, r7
 801a8f4:	bdb0      	pop	{r4, r5, r7, pc}

0801a8f6 <aci_hal_write_config_data>:
}

tBleStatus aci_hal_write_config_data( uint8_t Offset,
                                      uint8_t Length,
                                      const uint8_t* Value )
{
 801a8f6:	b580      	push	{r7, lr}
 801a8f8:	b0cc      	sub	sp, #304	; 0x130
 801a8fa:	af00      	add	r7, sp, #0
 801a8fc:	463b      	mov	r3, r7
 801a8fe:	601a      	str	r2, [r3, #0]
 801a900:	1dfb      	adds	r3, r7, #7
 801a902:	4602      	mov	r2, r0
 801a904:	701a      	strb	r2, [r3, #0]
 801a906:	1dbb      	adds	r3, r7, #6
 801a908:	460a      	mov	r2, r1
 801a90a:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0*)(cmd_buffer);
 801a90c:	f107 0310 	add.w	r3, r7, #16
 801a910:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a914:	f107 030f 	add.w	r3, r7, #15
 801a918:	2200      	movs	r2, #0
 801a91a:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a91c:	2300      	movs	r3, #0
 801a91e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Offset = Offset;
 801a922:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a926:	1dfa      	adds	r2, r7, #7
 801a928:	7812      	ldrb	r2, [r2, #0]
 801a92a:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801a92c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a930:	3301      	adds	r3, #1
 801a932:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Length = Length;
 801a936:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a93a:	1dba      	adds	r2, r7, #6
 801a93c:	7812      	ldrb	r2, [r2, #0]
 801a93e:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 801a940:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a944:	3301      	adds	r3, #1
 801a946:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Value, (const void*)Value, Length );
 801a94a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a94e:	1c98      	adds	r0, r3, #2
 801a950:	1dbb      	adds	r3, r7, #6
 801a952:	781a      	ldrb	r2, [r3, #0]
 801a954:	463b      	mov	r3, r7
 801a956:	6819      	ldr	r1, [r3, #0]
 801a958:	f000 fa03 	bl	801ad62 <Osal_MemCpy>
  index_input += Length;
 801a95c:	1dbb      	adds	r3, r7, #6
 801a95e:	781b      	ldrb	r3, [r3, #0]
 801a960:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801a964:	4413      	add	r3, r2
 801a966:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801a96a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a96e:	2218      	movs	r2, #24
 801a970:	2100      	movs	r1, #0
 801a972:	4618      	mov	r0, r3
 801a974:	f000 fa05 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801a978:	233f      	movs	r3, #63	; 0x3f
 801a97a:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x00c;
 801a97e:	230c      	movs	r3, #12
 801a980:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801a984:	f107 0310 	add.w	r3, r7, #16
 801a988:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801a98c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a990:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801a994:	f107 030f 	add.w	r3, r7, #15
 801a998:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801a99c:	2301      	movs	r3, #1
 801a99e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801a9a2:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801a9a6:	2100      	movs	r1, #0
 801a9a8:	4618      	mov	r0, r3
 801a9aa:	f000 fd95 	bl	801b4d8 <hci_send_req>
 801a9ae:	4603      	mov	r3, r0
 801a9b0:	2b00      	cmp	r3, #0
 801a9b2:	da01      	bge.n	801a9b8 <aci_hal_write_config_data+0xc2>
    return BLE_STATUS_TIMEOUT;
 801a9b4:	23ff      	movs	r3, #255	; 0xff
 801a9b6:	e002      	b.n	801a9be <aci_hal_write_config_data+0xc8>
  return status;
 801a9b8:	f107 030f 	add.w	r3, r7, #15
 801a9bc:	781b      	ldrb	r3, [r3, #0]
}
 801a9be:	4618      	mov	r0, r3
 801a9c0:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801a9c4:	46bd      	mov	sp, r7
 801a9c6:	bd80      	pop	{r7, pc}

0801a9c8 <aci_hal_set_tx_power_level>:
  return BLE_STATUS_SUCCESS;
}

tBleStatus aci_hal_set_tx_power_level( uint8_t En_High_Power,
                                       uint8_t PA_Level )
{
 801a9c8:	b580      	push	{r7, lr}
 801a9ca:	b0cc      	sub	sp, #304	; 0x130
 801a9cc:	af00      	add	r7, sp, #0
 801a9ce:	4602      	mov	r2, r0
 801a9d0:	1dfb      	adds	r3, r7, #7
 801a9d2:	701a      	strb	r2, [r3, #0]
 801a9d4:	1dbb      	adds	r3, r7, #6
 801a9d6:	460a      	mov	r2, r1
 801a9d8:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0*)(cmd_buffer);
 801a9da:	f107 0310 	add.w	r3, r7, #16
 801a9de:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801a9e2:	f107 030f 	add.w	r3, r7, #15
 801a9e6:	2200      	movs	r2, #0
 801a9e8:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801a9ea:	2300      	movs	r3, #0
 801a9ec:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->En_High_Power = En_High_Power;
 801a9f0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801a9f4:	1dfa      	adds	r2, r7, #7
 801a9f6:	7812      	ldrb	r2, [r2, #0]
 801a9f8:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801a9fa:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801a9fe:	3301      	adds	r3, #1
 801aa00:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->PA_Level = PA_Level;
 801aa04:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801aa08:	1dba      	adds	r2, r7, #6
 801aa0a:	7812      	ldrb	r2, [r2, #0]
 801aa0c:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 801aa0e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801aa12:	3301      	adds	r3, #1
 801aa14:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801aa18:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801aa1c:	2218      	movs	r2, #24
 801aa1e:	2100      	movs	r1, #0
 801aa20:	4618      	mov	r0, r3
 801aa22:	f000 f9ae 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801aa26:	233f      	movs	r3, #63	; 0x3f
 801aa28:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x00f;
 801aa2c:	230f      	movs	r3, #15
 801aa2e:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801aa32:	f107 0310 	add.w	r3, r7, #16
 801aa36:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801aa3a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801aa3e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801aa42:	f107 030f 	add.w	r3, r7, #15
 801aa46:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801aa4a:	2301      	movs	r3, #1
 801aa4c:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801aa50:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801aa54:	2100      	movs	r1, #0
 801aa56:	4618      	mov	r0, r3
 801aa58:	f000 fd3e 	bl	801b4d8 <hci_send_req>
 801aa5c:	4603      	mov	r3, r0
 801aa5e:	2b00      	cmp	r3, #0
 801aa60:	da01      	bge.n	801aa66 <aci_hal_set_tx_power_level+0x9e>
    return BLE_STATUS_TIMEOUT;
 801aa62:	23ff      	movs	r3, #255	; 0xff
 801aa64:	e002      	b.n	801aa6c <aci_hal_set_tx_power_level+0xa4>
  return status;
 801aa66:	f107 030f 	add.w	r3, r7, #15
 801aa6a:	781b      	ldrb	r3, [r3, #0]
}
 801aa6c:	4618      	mov	r0, r3
 801aa6e:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801aa72:	46bd      	mov	sp, r7
 801aa74:	bd80      	pop	{r7, pc}

0801aa76 <hci_reset>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus hci_reset( void )
{
 801aa76:	b580      	push	{r7, lr}
 801aa78:	b088      	sub	sp, #32
 801aa7a:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 801aa7c:	2300      	movs	r3, #0
 801aa7e:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801aa80:	f107 0308 	add.w	r3, r7, #8
 801aa84:	2218      	movs	r2, #24
 801aa86:	2100      	movs	r1, #0
 801aa88:	4618      	mov	r0, r3
 801aa8a:	f000 f97a 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x03;
 801aa8e:	2303      	movs	r3, #3
 801aa90:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x003;
 801aa92:	2303      	movs	r3, #3
 801aa94:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 801aa96:	1dfb      	adds	r3, r7, #7
 801aa98:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 801aa9a:	2301      	movs	r3, #1
 801aa9c:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 801aa9e:	f107 0308 	add.w	r3, r7, #8
 801aaa2:	2100      	movs	r1, #0
 801aaa4:	4618      	mov	r0, r3
 801aaa6:	f000 fd17 	bl	801b4d8 <hci_send_req>
 801aaaa:	4603      	mov	r3, r0
 801aaac:	2b00      	cmp	r3, #0
 801aaae:	da01      	bge.n	801aab4 <hci_reset+0x3e>
    return BLE_STATUS_TIMEOUT;
 801aab0:	23ff      	movs	r3, #255	; 0xff
 801aab2:	e000      	b.n	801aab6 <hci_reset+0x40>
  return status;
 801aab4:	79fb      	ldrb	r3, [r7, #7]
}
 801aab6:	4618      	mov	r0, r3
 801aab8:	3720      	adds	r7, #32
 801aaba:	46bd      	mov	sp, r7
 801aabc:	bd80      	pop	{r7, pc}

0801aabe <hci_le_read_phy>:
}

tBleStatus hci_le_read_phy( uint16_t Connection_Handle,
                            uint8_t* TX_PHY,
                            uint8_t* RX_PHY )
{
 801aabe:	b580      	push	{r7, lr}
 801aac0:	b0ce      	sub	sp, #312	; 0x138
 801aac2:	af00      	add	r7, sp, #0
 801aac4:	f107 0308 	add.w	r3, r7, #8
 801aac8:	6019      	str	r1, [r3, #0]
 801aaca:	1d3b      	adds	r3, r7, #4
 801aacc:	601a      	str	r2, [r3, #0]
 801aace:	f107 030e 	add.w	r3, r7, #14
 801aad2:	4602      	mov	r2, r0
 801aad4:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_read_phy_cp0 *cp0 = (hci_le_read_phy_cp0*)(cmd_buffer);
 801aad6:	f107 0318 	add.w	r3, r7, #24
 801aada:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
  hci_le_read_phy_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 801aade:	f107 0310 	add.w	r3, r7, #16
 801aae2:	2205      	movs	r2, #5
 801aae4:	2100      	movs	r1, #0
 801aae6:	4618      	mov	r0, r3
 801aae8:	f000 f94b 	bl	801ad82 <Osal_MemSet>
  int index_input = 0;
 801aaec:	2300      	movs	r3, #0
 801aaee:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  cp0->Connection_Handle = Connection_Handle;
 801aaf2:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801aaf6:	f107 020e 	add.w	r2, r7, #14
 801aafa:	8812      	ldrh	r2, [r2, #0]
 801aafc:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801aafe:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801ab02:	3302      	adds	r3, #2
 801ab04:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801ab08:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801ab0c:	2218      	movs	r2, #24
 801ab0e:	2100      	movs	r1, #0
 801ab10:	4618      	mov	r0, r3
 801ab12:	f000 f936 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x08;
 801ab16:	2308      	movs	r3, #8
 801ab18:	f8a7 3118 	strh.w	r3, [r7, #280]	; 0x118
  rq.ocf = 0x030;
 801ab1c:	2330      	movs	r3, #48	; 0x30
 801ab1e:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
  rq.cparam = cmd_buffer;
 801ab22:	f107 0318 	add.w	r3, r7, #24
 801ab26:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.clen = index_input;
 801ab2a:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801ab2e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  rq.rparam = &resp;
 801ab32:	f107 0310 	add.w	r3, r7, #16
 801ab36:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  rq.rlen = sizeof(resp);
 801ab3a:	2305      	movs	r3, #5
 801ab3c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  if ( hci_send_req(&rq, FALSE) < 0 )
 801ab40:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801ab44:	2100      	movs	r1, #0
 801ab46:	4618      	mov	r0, r3
 801ab48:	f000 fcc6 	bl	801b4d8 <hci_send_req>
 801ab4c:	4603      	mov	r3, r0
 801ab4e:	2b00      	cmp	r3, #0
 801ab50:	da01      	bge.n	801ab56 <hci_le_read_phy+0x98>
    return BLE_STATUS_TIMEOUT;
 801ab52:	23ff      	movs	r3, #255	; 0xff
 801ab54:	e016      	b.n	801ab84 <hci_le_read_phy+0xc6>
  if ( resp.Status )
 801ab56:	f107 0310 	add.w	r3, r7, #16
 801ab5a:	781b      	ldrb	r3, [r3, #0]
 801ab5c:	2b00      	cmp	r3, #0
 801ab5e:	d003      	beq.n	801ab68 <hci_le_read_phy+0xaa>
    return resp.Status;
 801ab60:	f107 0310 	add.w	r3, r7, #16
 801ab64:	781b      	ldrb	r3, [r3, #0]
 801ab66:	e00d      	b.n	801ab84 <hci_le_read_phy+0xc6>
  *TX_PHY = resp.TX_PHY;
 801ab68:	f107 0310 	add.w	r3, r7, #16
 801ab6c:	78da      	ldrb	r2, [r3, #3]
 801ab6e:	f107 0308 	add.w	r3, r7, #8
 801ab72:	681b      	ldr	r3, [r3, #0]
 801ab74:	701a      	strb	r2, [r3, #0]
  *RX_PHY = resp.RX_PHY;
 801ab76:	f107 0310 	add.w	r3, r7, #16
 801ab7a:	791a      	ldrb	r2, [r3, #4]
 801ab7c:	1d3b      	adds	r3, r7, #4
 801ab7e:	681b      	ldr	r3, [r3, #0]
 801ab80:	701a      	strb	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 801ab82:	2300      	movs	r3, #0
}
 801ab84:	4618      	mov	r0, r3
 801ab86:	f507 779c 	add.w	r7, r7, #312	; 0x138
 801ab8a:	46bd      	mov	sp, r7
 801ab8c:	bd80      	pop	{r7, pc}

0801ab8e <hci_le_set_default_phy>:

tBleStatus hci_le_set_default_phy( uint8_t ALL_PHYS,
                                   uint8_t TX_PHYS,
                                   uint8_t RX_PHYS )
{
 801ab8e:	b590      	push	{r4, r7, lr}
 801ab90:	b0cd      	sub	sp, #308	; 0x134
 801ab92:	af00      	add	r7, sp, #0
 801ab94:	4604      	mov	r4, r0
 801ab96:	4608      	mov	r0, r1
 801ab98:	4611      	mov	r1, r2
 801ab9a:	1dfb      	adds	r3, r7, #7
 801ab9c:	4622      	mov	r2, r4
 801ab9e:	701a      	strb	r2, [r3, #0]
 801aba0:	1dbb      	adds	r3, r7, #6
 801aba2:	4602      	mov	r2, r0
 801aba4:	701a      	strb	r2, [r3, #0]
 801aba6:	1d7b      	adds	r3, r7, #5
 801aba8:	460a      	mov	r2, r1
 801abaa:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_set_default_phy_cp0 *cp0 = (hci_le_set_default_phy_cp0*)(cmd_buffer);
 801abac:	f107 0310 	add.w	r3, r7, #16
 801abb0:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801abb4:	f107 030f 	add.w	r3, r7, #15
 801abb8:	2200      	movs	r2, #0
 801abba:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801abbc:	2300      	movs	r3, #0
 801abbe:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->ALL_PHYS = ALL_PHYS;
 801abc2:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801abc6:	1dfa      	adds	r2, r7, #7
 801abc8:	7812      	ldrb	r2, [r2, #0]
 801abca:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801abcc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801abd0:	3301      	adds	r3, #1
 801abd2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->TX_PHYS = TX_PHYS;
 801abd6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801abda:	1dba      	adds	r2, r7, #6
 801abdc:	7812      	ldrb	r2, [r2, #0]
 801abde:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 801abe0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801abe4:	3301      	adds	r3, #1
 801abe6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->RX_PHYS = RX_PHYS;
 801abea:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801abee:	1d7a      	adds	r2, r7, #5
 801abf0:	7812      	ldrb	r2, [r2, #0]
 801abf2:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 801abf4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801abf8:	3301      	adds	r3, #1
 801abfa:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801abfe:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801ac02:	2218      	movs	r2, #24
 801ac04:	2100      	movs	r1, #0
 801ac06:	4618      	mov	r0, r3
 801ac08:	f000 f8bb 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x08;
 801ac0c:	2308      	movs	r3, #8
 801ac0e:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x031;
 801ac12:	2331      	movs	r3, #49	; 0x31
 801ac14:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801ac18:	f107 0310 	add.w	r3, r7, #16
 801ac1c:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801ac20:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801ac24:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801ac28:	f107 030f 	add.w	r3, r7, #15
 801ac2c:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801ac30:	2301      	movs	r3, #1
 801ac32:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801ac36:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801ac3a:	2100      	movs	r1, #0
 801ac3c:	4618      	mov	r0, r3
 801ac3e:	f000 fc4b 	bl	801b4d8 <hci_send_req>
 801ac42:	4603      	mov	r3, r0
 801ac44:	2b00      	cmp	r3, #0
 801ac46:	da01      	bge.n	801ac4c <hci_le_set_default_phy+0xbe>
    return BLE_STATUS_TIMEOUT;
 801ac48:	23ff      	movs	r3, #255	; 0xff
 801ac4a:	e002      	b.n	801ac52 <hci_le_set_default_phy+0xc4>
  return status;
 801ac4c:	f107 030f 	add.w	r3, r7, #15
 801ac50:	781b      	ldrb	r3, [r3, #0]
}
 801ac52:	4618      	mov	r0, r3
 801ac54:	f507 779a 	add.w	r7, r7, #308	; 0x134
 801ac58:	46bd      	mov	sp, r7
 801ac5a:	bd90      	pop	{r4, r7, pc}

0801ac5c <aci_l2cap_connection_parameter_update_req>:
tBleStatus aci_l2cap_connection_parameter_update_req( uint16_t Connection_Handle,
                                                      uint16_t Conn_Interval_Min,
                                                      uint16_t Conn_Interval_Max,
                                                      uint16_t Slave_latency,
                                                      uint16_t Timeout_Multiplier )
{
 801ac5c:	b5b0      	push	{r4, r5, r7, lr}
 801ac5e:	b0cc      	sub	sp, #304	; 0x130
 801ac60:	af00      	add	r7, sp, #0
 801ac62:	4605      	mov	r5, r0
 801ac64:	460c      	mov	r4, r1
 801ac66:	4610      	mov	r0, r2
 801ac68:	4619      	mov	r1, r3
 801ac6a:	1dbb      	adds	r3, r7, #6
 801ac6c:	462a      	mov	r2, r5
 801ac6e:	801a      	strh	r2, [r3, #0]
 801ac70:	1d3b      	adds	r3, r7, #4
 801ac72:	4622      	mov	r2, r4
 801ac74:	801a      	strh	r2, [r3, #0]
 801ac76:	1cbb      	adds	r3, r7, #2
 801ac78:	4602      	mov	r2, r0
 801ac7a:	801a      	strh	r2, [r3, #0]
 801ac7c:	463b      	mov	r3, r7
 801ac7e:	460a      	mov	r2, r1
 801ac80:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_l2cap_connection_parameter_update_req_cp0 *cp0 = (aci_l2cap_connection_parameter_update_req_cp0*)(cmd_buffer);
 801ac82:	f107 0310 	add.w	r3, r7, #16
 801ac86:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801ac8a:	f107 030f 	add.w	r3, r7, #15
 801ac8e:	2200      	movs	r2, #0
 801ac90:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 801ac92:	2300      	movs	r3, #0
 801ac94:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Connection_Handle = Connection_Handle;
 801ac98:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801ac9c:	1dba      	adds	r2, r7, #6
 801ac9e:	8812      	ldrh	r2, [r2, #0]
 801aca0:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 801aca2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801aca6:	3302      	adds	r3, #2
 801aca8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Conn_Interval_Min = Conn_Interval_Min;
 801acac:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801acb0:	1d3a      	adds	r2, r7, #4
 801acb2:	8812      	ldrh	r2, [r2, #0]
 801acb4:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 801acb6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801acba:	3302      	adds	r3, #2
 801acbc:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Conn_Interval_Max = Conn_Interval_Max;
 801acc0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801acc4:	1cba      	adds	r2, r7, #2
 801acc6:	8812      	ldrh	r2, [r2, #0]
 801acc8:	809a      	strh	r2, [r3, #4]
  index_input += 2;
 801acca:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801acce:	3302      	adds	r3, #2
 801acd0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Slave_latency = Slave_latency;
 801acd4:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801acd8:	463a      	mov	r2, r7
 801acda:	8812      	ldrh	r2, [r2, #0]
 801acdc:	80da      	strh	r2, [r3, #6]
  index_input += 2;
 801acde:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801ace2:	3302      	adds	r3, #2
 801ace4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Timeout_Multiplier = Timeout_Multiplier;
 801ace8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801acec:	f8b7 2140 	ldrh.w	r2, [r7, #320]	; 0x140
 801acf0:	811a      	strh	r2, [r3, #8]
  index_input += 2;
 801acf2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801acf6:	3302      	adds	r3, #2
 801acf8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801acfc:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801ad00:	2218      	movs	r2, #24
 801ad02:	2100      	movs	r1, #0
 801ad04:	4618      	mov	r0, r3
 801ad06:	f000 f83c 	bl	801ad82 <Osal_MemSet>
  rq.ogf = 0x3f;
 801ad0a:	233f      	movs	r3, #63	; 0x3f
 801ad0c:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x181;
 801ad10:	f240 1381 	movw	r3, #385	; 0x181
 801ad14:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.event = 0x0F;
 801ad18:	230f      	movs	r3, #15
 801ad1a:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
  rq.cparam = cmd_buffer;
 801ad1e:	f107 0310 	add.w	r3, r7, #16
 801ad22:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801ad26:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801ad2a:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801ad2e:	f107 030f 	add.w	r3, r7, #15
 801ad32:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801ad36:	2301      	movs	r3, #1
 801ad38:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801ad3c:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801ad40:	2100      	movs	r1, #0
 801ad42:	4618      	mov	r0, r3
 801ad44:	f000 fbc8 	bl	801b4d8 <hci_send_req>
 801ad48:	4603      	mov	r3, r0
 801ad4a:	2b00      	cmp	r3, #0
 801ad4c:	da01      	bge.n	801ad52 <aci_l2cap_connection_parameter_update_req+0xf6>
    return BLE_STATUS_TIMEOUT;
 801ad4e:	23ff      	movs	r3, #255	; 0xff
 801ad50:	e002      	b.n	801ad58 <aci_l2cap_connection_parameter_update_req+0xfc>
  return status;
 801ad52:	f107 030f 	add.w	r3, r7, #15
 801ad56:	781b      	ldrb	r3, [r3, #0]
}
 801ad58:	4618      	mov	r0, r3
 801ad5a:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801ad5e:	46bd      	mov	sp, r7
 801ad60:	bdb0      	pop	{r4, r5, r7, pc}

0801ad62 <Osal_MemCpy>:
 * Osal_MemCpy
 * 
 */
 
void* Osal_MemCpy( void *dest, const void *src, unsigned int size )
{
 801ad62:	b580      	push	{r7, lr}
 801ad64:	b084      	sub	sp, #16
 801ad66:	af00      	add	r7, sp, #0
 801ad68:	60f8      	str	r0, [r7, #12]
 801ad6a:	60b9      	str	r1, [r7, #8]
 801ad6c:	607a      	str	r2, [r7, #4]
  return memcpy( dest, src, size ); 
 801ad6e:	687a      	ldr	r2, [r7, #4]
 801ad70:	68b9      	ldr	r1, [r7, #8]
 801ad72:	68f8      	ldr	r0, [r7, #12]
 801ad74:	f011 f9b4 	bl	802c0e0 <memcpy>
 801ad78:	4603      	mov	r3, r0
}
 801ad7a:	4618      	mov	r0, r3
 801ad7c:	3710      	adds	r7, #16
 801ad7e:	46bd      	mov	sp, r7
 801ad80:	bd80      	pop	{r7, pc}

0801ad82 <Osal_MemSet>:
 * Osal_MemSet
 * 
 */
 
void* Osal_MemSet( void *ptr, int value, unsigned int size )
{
 801ad82:	b580      	push	{r7, lr}
 801ad84:	b084      	sub	sp, #16
 801ad86:	af00      	add	r7, sp, #0
 801ad88:	60f8      	str	r0, [r7, #12]
 801ad8a:	60b9      	str	r1, [r7, #8]
 801ad8c:	607a      	str	r2, [r7, #4]
  return memset( ptr, value, size );
 801ad8e:	687a      	ldr	r2, [r7, #4]
 801ad90:	68b9      	ldr	r1, [r7, #8]
 801ad92:	68f8      	ldr	r0, [r7, #12]
 801ad94:	f011 f9b2 	bl	802c0fc <memset>
 801ad98:	4603      	mov	r3, r0
}
 801ad9a:	4618      	mov	r0, r3
 801ad9c:	3710      	adds	r7, #16
 801ad9e:	46bd      	mov	sp, r7
 801ada0:	bd80      	pop	{r7, pc}
	...

0801ada4 <DIS_Init>:
 * @brief  Service initialization
 * @param  None
 * @retval None
 */
void DIS_Init(void)
{
 801ada4:	b580      	push	{r7, lr}
 801ada6:	b088      	sub	sp, #32
 801ada8:	af06      	add	r7, sp, #24
  uint16_t uuid;
  tBleStatus hciCmdResult;

  memset ( &DIS_Context, 0, sizeof(DIS_Context_t) );
 801adaa:	2204      	movs	r2, #4
 801adac:	2100      	movs	r1, #0
 801adae:	4816      	ldr	r0, [pc, #88]	; (801ae08 <DIS_Init+0x64>)
 801adb0:	f011 f9a4 	bl	802c0fc <memset>
   */

  /**
   *  Add Device Information Service
   */
  uuid = DEVICE_INFORMATION_SERVICE_UUID;
 801adb4:	f641 030a 	movw	r3, #6154	; 0x180a
 801adb8:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_service(UUID_TYPE_16,
 801adba:	1d39      	adds	r1, r7, #4
 801adbc:	4b12      	ldr	r3, [pc, #72]	; (801ae08 <DIS_Init+0x64>)
 801adbe:	9300      	str	r3, [sp, #0]
 801adc0:	2303      	movs	r3, #3
 801adc2:	2201      	movs	r2, #1
 801adc4:	2001      	movs	r0, #1
 801adc6:	f7ff fa3e 	bl	801a246 <aci_gatt_add_service>
 801adca:	4603      	mov	r3, r0
 801adcc:	71fb      	strb	r3, [r7, #7]

#if (BLE_CFG_DIS_MANUFACTURER_NAME_STRING != 0)
  /**
   *  Add Manufacturer Name String Characteristic
   */
  uuid = MANUFACTURER_NAME_UUID;
 801adce:	f642 2329 	movw	r3, #10793	; 0x2a29
 801add2:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_char(DIS_Context.DeviceInformationSvcHdle,
 801add4:	4b0c      	ldr	r3, [pc, #48]	; (801ae08 <DIS_Init+0x64>)
 801add6:	8818      	ldrh	r0, [r3, #0]
 801add8:	1d3a      	adds	r2, r7, #4
 801adda:	4b0c      	ldr	r3, [pc, #48]	; (801ae0c <DIS_Init+0x68>)
 801addc:	9305      	str	r3, [sp, #20]
 801adde:	2301      	movs	r3, #1
 801ade0:	9304      	str	r3, [sp, #16]
 801ade2:	230a      	movs	r3, #10
 801ade4:	9303      	str	r3, [sp, #12]
 801ade6:	2300      	movs	r3, #0
 801ade8:	9302      	str	r3, [sp, #8]
 801adea:	2300      	movs	r3, #0
 801adec:	9301      	str	r3, [sp, #4]
 801adee:	2302      	movs	r3, #2
 801adf0:	9300      	str	r3, [sp, #0]
 801adf2:	2320      	movs	r3, #32
 801adf4:	2101      	movs	r1, #1
 801adf6:	f7ff fad5 	bl	801a3a4 <aci_gatt_add_char>
 801adfa:	4603      	mov	r3, r0
 801adfc:	71fb      	strb	r3, [r7, #7]
    BLE_DBG_DIS_MSG ("FAILED to add PNP ID Characteristic, Error: %02X !!\n", 
                hciCmdResult);
  }
#endif
      
  return;
 801adfe:	bf00      	nop
}
 801ae00:	3708      	adds	r7, #8
 801ae02:	46bd      	mov	sp, r7
 801ae04:	bd80      	pop	{r7, pc}
 801ae06:	bf00      	nop
 801ae08:	200002b4 	.word	0x200002b4
 801ae0c:	200002b6 	.word	0x200002b6

0801ae10 <HeartRate_Event_Handler>:
 * @brief  Event handler
 * @param  Event: Address of the buffer holding the Event
 * @retval Ack: Return whether the Event has been managed or not
 */
static SVCCTL_EvtAckStatus_t HeartRate_Event_Handler(void *Event)
{
 801ae10:	b580      	push	{r7, lr}
 801ae12:	b08e      	sub	sp, #56	; 0x38
 801ae14:	af02      	add	r7, sp, #8
 801ae16:	6078      	str	r0, [r7, #4]
  hci_event_pckt *event_pckt;
  evt_blecore_aci *blecore_evt;
  aci_gatt_attribute_modified_event_rp0    * attribute_modified;
  HRS_App_Notification_evt_t Notification;
  
  return_value = SVCCTL_EvtNotAck;
 801ae18:	2300      	movs	r3, #0
 801ae1a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  event_pckt = (hci_event_pckt *)(((hci_uart_pckt*)Event)->data);
 801ae1e:	687b      	ldr	r3, [r7, #4]
 801ae20:	3301      	adds	r3, #1
 801ae22:	62bb      	str	r3, [r7, #40]	; 0x28

  switch(event_pckt->evt)
 801ae24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ae26:	781b      	ldrb	r3, [r3, #0]
 801ae28:	2bff      	cmp	r3, #255	; 0xff
 801ae2a:	d174      	bne.n	801af16 <HeartRate_Event_Handler+0x106>
  {
    case HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE:
    {
      blecore_evt = (evt_blecore_aci*)event_pckt->data;
 801ae2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ae2e:	3302      	adds	r3, #2
 801ae30:	627b      	str	r3, [r7, #36]	; 0x24
      switch(blecore_evt->ecode)
 801ae32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ae34:	881b      	ldrh	r3, [r3, #0]
 801ae36:	b29b      	uxth	r3, r3
 801ae38:	f640 4201 	movw	r2, #3073	; 0xc01
 801ae3c:	4293      	cmp	r3, r2
 801ae3e:	d03f      	beq.n	801aec0 <HeartRate_Event_Handler+0xb0>
 801ae40:	f640 4213 	movw	r2, #3091	; 0xc13
 801ae44:	4293      	cmp	r3, r2
 801ae46:	d160      	bne.n	801af0a <HeartRate_Event_Handler+0xfa>
        case ACI_GATT_WRITE_PERMIT_REQ_VSEVT_CODE:
        {
          aci_gatt_write_permit_req_event_rp0 * write_perm_req;

          BLE_DBG_HRS_MSG("ACI_GATT_WRITE_PERMIT_REQ_VSEVT_CODE\n");
          write_perm_req = (aci_gatt_write_permit_req_event_rp0*)blecore_evt->data;
 801ae48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ae4a:	3302      	adds	r3, #2
 801ae4c:	623b      	str	r3, [r7, #32]

          if(write_perm_req->Attribute_Handle == (HRS_Context.ControlPointCharHdle + 1))
 801ae4e:	6a3b      	ldr	r3, [r7, #32]
 801ae50:	885b      	ldrh	r3, [r3, #2]
 801ae52:	b29b      	uxth	r3, r3
 801ae54:	461a      	mov	r2, r3
 801ae56:	4b33      	ldr	r3, [pc, #204]	; (801af24 <HeartRate_Event_Handler+0x114>)
 801ae58:	88db      	ldrh	r3, [r3, #6]
 801ae5a:	3301      	adds	r3, #1
 801ae5c:	429a      	cmp	r2, r3
 801ae5e:	d156      	bne.n	801af0e <HeartRate_Event_Handler+0xfe>
          {
            return_value = SVCCTL_EvtAckFlowEnable;
 801ae60:	2301      	movs	r3, #1
 801ae62:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

            if (write_perm_req->Data[0] == HRS_CNTL_POINT_RESET_ENERGY_EXPENDED)
 801ae66:	6a3b      	ldr	r3, [r7, #32]
 801ae68:	795b      	ldrb	r3, [r3, #5]
 801ae6a:	2b01      	cmp	r3, #1
 801ae6c:	d117      	bne.n	801ae9e <HeartRate_Event_Handler+0x8e>
            {
              /* received a correct value for HRM control point char */
              aci_gatt_write_resp(write_perm_req->Connection_Handle,
 801ae6e:	6a3b      	ldr	r3, [r7, #32]
 801ae70:	881b      	ldrh	r3, [r3, #0]
 801ae72:	b298      	uxth	r0, r3
 801ae74:	6a3b      	ldr	r3, [r7, #32]
 801ae76:	885b      	ldrh	r3, [r3, #2]
 801ae78:	b299      	uxth	r1, r3
 801ae7a:	6a3b      	ldr	r3, [r7, #32]
 801ae7c:	791b      	ldrb	r3, [r3, #4]
                                      write_perm_req->Attribute_Handle,
                                      0x00, /* write_status = 0 (no error))*/
                                      (uint8_t)HRS_CNTL_POINT_VALUE_IS_SUPPORTED, /* err_code */
                                      write_perm_req->Data_Length,
                                      (uint8_t *)&write_perm_req->Data[0]);
 801ae7e:	6a3a      	ldr	r2, [r7, #32]
 801ae80:	3205      	adds	r2, #5
              aci_gatt_write_resp(write_perm_req->Connection_Handle,
 801ae82:	9201      	str	r2, [sp, #4]
 801ae84:	9300      	str	r3, [sp, #0]
 801ae86:	2300      	movs	r3, #0
 801ae88:	2200      	movs	r2, #0
 801ae8a:	f7ff fbfc 	bl	801a686 <aci_gatt_write_resp>

              /**
               * Notify the application to Reset The Energy Expended Value
               */
              Notification.HRS_Evt_Opcode = HRS_RESET_ENERGY_EXPENDED_EVT;
 801ae8e:	2300      	movs	r3, #0
 801ae90:	733b      	strb	r3, [r7, #12]
              HRS_Notification(&Notification);
 801ae92:	f107 030c 	add.w	r3, r7, #12
 801ae96:	4618      	mov	r0, r3
 801ae98:	f00d f9fb 	bl	8028292 <HRS_Notification>
                                      write_perm_req->Data_Length,
                                      (uint8_t *)&write_perm_req->Data[0]);
            }
          }
        }
        break;
 801ae9c:	e037      	b.n	801af0e <HeartRate_Event_Handler+0xfe>
              aci_gatt_write_resp(write_perm_req->Connection_Handle,
 801ae9e:	6a3b      	ldr	r3, [r7, #32]
 801aea0:	881b      	ldrh	r3, [r3, #0]
 801aea2:	b298      	uxth	r0, r3
 801aea4:	6a3b      	ldr	r3, [r7, #32]
 801aea6:	885b      	ldrh	r3, [r3, #2]
 801aea8:	b299      	uxth	r1, r3
 801aeaa:	6a3b      	ldr	r3, [r7, #32]
 801aeac:	791b      	ldrb	r3, [r3, #4]
                                      (uint8_t *)&write_perm_req->Data[0]);
 801aeae:	6a3a      	ldr	r2, [r7, #32]
 801aeb0:	3205      	adds	r2, #5
              aci_gatt_write_resp(write_perm_req->Connection_Handle,
 801aeb2:	9201      	str	r2, [sp, #4]
 801aeb4:	9300      	str	r3, [sp, #0]
 801aeb6:	2380      	movs	r3, #128	; 0x80
 801aeb8:	2201      	movs	r2, #1
 801aeba:	f7ff fbe4 	bl	801a686 <aci_gatt_write_resp>
        break;
 801aebe:	e026      	b.n	801af0e <HeartRate_Event_Handler+0xfe>
#endif

        case ACI_GATT_ATTRIBUTE_MODIFIED_VSEVT_CODE:
        {
          attribute_modified = (aci_gatt_attribute_modified_event_rp0*)blecore_evt->data;
 801aec0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aec2:	3302      	adds	r3, #2
 801aec4:	61fb      	str	r3, [r7, #28]
          if(attribute_modified->Attr_Handle == (HRS_Context.HeartRatemeasurementCharHdle + 2))
 801aec6:	69fb      	ldr	r3, [r7, #28]
 801aec8:	885b      	ldrh	r3, [r3, #2]
 801aeca:	b29b      	uxth	r3, r3
 801aecc:	461a      	mov	r2, r3
 801aece:	4b15      	ldr	r3, [pc, #84]	; (801af24 <HeartRate_Event_Handler+0x114>)
 801aed0:	885b      	ldrh	r3, [r3, #2]
 801aed2:	3302      	adds	r3, #2
 801aed4:	429a      	cmp	r2, r3
 801aed6:	d11c      	bne.n	801af12 <HeartRate_Event_Handler+0x102>
          {
            return_value = SVCCTL_EvtAckFlowEnable;
 801aed8:	2301      	movs	r3, #1
 801aeda:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

            /**
             * Notify the application to start measurement
             */
            if(attribute_modified->Attr_Data[0] & COMSVC_Notification)
 801aede:	69fb      	ldr	r3, [r7, #28]
 801aee0:	7a1b      	ldrb	r3, [r3, #8]
 801aee2:	f003 0301 	and.w	r3, r3, #1
 801aee6:	2b00      	cmp	r3, #0
 801aee8:	d007      	beq.n	801aefa <HeartRate_Event_Handler+0xea>
            {
              BLE_DBG_HRS_MSG("ACI_GATT_ATTRIBUTE_MODIFIED_VSEVT_CODE HRS_NOTIFICATION_ENABLED\n");
              Notification.HRS_Evt_Opcode =HRS_NOTIFICATION_ENABLED;
 801aeea:	2301      	movs	r3, #1
 801aeec:	733b      	strb	r3, [r7, #12]
              HRS_Notification(&Notification);
 801aeee:	f107 030c 	add.w	r3, r7, #12
 801aef2:	4618      	mov	r0, r3
 801aef4:	f00d f9cd 	bl	8028292 <HRS_Notification>
              Notification.DataTransfered.pPayload=attribute_modified->Attr_Data;
              HRS_Notification(&Notification);
            }
#endif         
        }
        break;
 801aef8:	e00b      	b.n	801af12 <HeartRate_Event_Handler+0x102>
              Notification.HRS_Evt_Opcode =HRS_NOTIFICATION_DISABLED;
 801aefa:	2302      	movs	r3, #2
 801aefc:	733b      	strb	r3, [r7, #12]
              HRS_Notification(&Notification);
 801aefe:	f107 030c 	add.w	r3, r7, #12
 801af02:	4618      	mov	r0, r3
 801af04:	f00d f9c5 	bl	8028292 <HRS_Notification>
        break;
 801af08:	e003      	b.n	801af12 <HeartRate_Event_Handler+0x102>

        default:
          break;
 801af0a:	bf00      	nop
 801af0c:	e004      	b.n	801af18 <HeartRate_Event_Handler+0x108>
        break;
 801af0e:	bf00      	nop
 801af10:	e002      	b.n	801af18 <HeartRate_Event_Handler+0x108>
        break;
 801af12:	bf00      	nop
      }
    }
    break; /* HCI_HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE_SPECIFIC */
 801af14:	e000      	b.n	801af18 <HeartRate_Event_Handler+0x108>

    default:
      break;
 801af16:	bf00      	nop
  }

  return(return_value);
 801af18:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}/* end HeartRate_Event_Handler */
 801af1c:	4618      	mov	r0, r3
 801af1e:	3730      	adds	r7, #48	; 0x30
 801af20:	46bd      	mov	sp, r7
 801af22:	bd80      	pop	{r7, pc}
 801af24:	200002b8 	.word	0x200002b8

0801af28 <HRS_Init>:
 * @brief  Service initialization
 * @param  None
 * @retval None
 */
void HRS_Init(void)
{
 801af28:	b580      	push	{r7, lr}
 801af2a:	b088      	sub	sp, #32
 801af2c:	af06      	add	r7, sp, #24
  uint16_t uuid;
  tBleStatus hciCmdResult = BLE_STATUS_SUCCESS;
 801af2e:	2300      	movs	r3, #0
 801af30:	71fb      	strb	r3, [r7, #7]

  /**
   *	Register the event handler to the BLE controller
   */
  SVCCTL_RegisterSvcHandler(HeartRate_Event_Handler);
 801af32:	482e      	ldr	r0, [pc, #184]	; (801afec <HRS_Init+0xc4>)
 801af34:	f000 f906 	bl	801b144 <SVCCTL_RegisterSvcHandler>
   *                                2 for hear rate measurement characteristic +
   *                                1 for client char configuration descriptor +
   *                                2 for body sensor location characteristic +
   *                                2 for control point characteristic
   */
  uuid = HEART_RATE_SERVICE_UUID;
 801af38:	f641 030d 	movw	r3, #6157	; 0x180d
 801af3c:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_service(UUID_TYPE_16,
 801af3e:	1d39      	adds	r1, r7, #4
 801af40:	4b2b      	ldr	r3, [pc, #172]	; (801aff0 <HRS_Init+0xc8>)
 801af42:	9300      	str	r3, [sp, #0]
 801af44:	2308      	movs	r3, #8
 801af46:	2201      	movs	r2, #1
 801af48:	2001      	movs	r0, #1
 801af4a:	f7ff f97c 	bl	801a246 <aci_gatt_add_service>
 801af4e:	4603      	mov	r3, r0
 801af50:	71fb      	strb	r3, [r7, #7]
  }

  /**
   *  Add Heart Rate Measurement Characteristic
   */
  uuid = HEART_RATE_MEASURMENT_UUID;
 801af52:	f642 2337 	movw	r3, #10807	; 0x2a37
 801af56:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_char(HRS_Context.HeartRateSvcHdle,
 801af58:	4b25      	ldr	r3, [pc, #148]	; (801aff0 <HRS_Init+0xc8>)
 801af5a:	8818      	ldrh	r0, [r3, #0]
 801af5c:	1d3a      	adds	r2, r7, #4
 801af5e:	4b25      	ldr	r3, [pc, #148]	; (801aff4 <HRS_Init+0xcc>)
 801af60:	9305      	str	r3, [sp, #20]
 801af62:	2301      	movs	r3, #1
 801af64:	9304      	str	r3, [sp, #16]
 801af66:	230a      	movs	r3, #10
 801af68:	9303      	str	r3, [sp, #12]
 801af6a:	2300      	movs	r3, #0
 801af6c:	9302      	str	r3, [sp, #8]
 801af6e:	2300      	movs	r3, #0
 801af70:	9301      	str	r3, [sp, #4]
 801af72:	2310      	movs	r3, #16
 801af74:	9300      	str	r3, [sp, #0]
 801af76:	2307      	movs	r3, #7
 801af78:	2101      	movs	r1, #1
 801af7a:	f7ff fa13 	bl	801a3a4 <aci_gatt_add_char>
 801af7e:	4603      	mov	r3, r0
 801af80:	71fb      	strb	r3, [r7, #7]

#if (BLE_CFG_HRS_BODY_SENSOR_LOCATION_CHAR != 0)
  /**
   *  Add Body Sensor Location Characteristic
   */
  uuid = SENSOR_LOCATION_UUID;
 801af82:	f642 2338 	movw	r3, #10808	; 0x2a38
 801af86:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_char(HRS_Context.HeartRateSvcHdle,
 801af88:	4b19      	ldr	r3, [pc, #100]	; (801aff0 <HRS_Init+0xc8>)
 801af8a:	8818      	ldrh	r0, [r3, #0]
 801af8c:	1d3a      	adds	r2, r7, #4
 801af8e:	4b1a      	ldr	r3, [pc, #104]	; (801aff8 <HRS_Init+0xd0>)
 801af90:	9305      	str	r3, [sp, #20]
 801af92:	2300      	movs	r3, #0
 801af94:	9304      	str	r3, [sp, #16]
 801af96:	230a      	movs	r3, #10
 801af98:	9303      	str	r3, [sp, #12]
 801af9a:	2300      	movs	r3, #0
 801af9c:	9302      	str	r3, [sp, #8]
 801af9e:	2300      	movs	r3, #0
 801afa0:	9301      	str	r3, [sp, #4]
 801afa2:	2302      	movs	r3, #2
 801afa4:	9300      	str	r3, [sp, #0]
 801afa6:	2301      	movs	r3, #1
 801afa8:	2101      	movs	r1, #1
 801afaa:	f7ff f9fb 	bl	801a3a4 <aci_gatt_add_char>
 801afae:	4603      	mov	r3, r0
 801afb0:	71fb      	strb	r3, [r7, #7]
  }

#endif

#if (BLE_CFG_HRS_ENERGY_EXPENDED_INFO_FLAG != 0)
  uuid = CONTROL_POINT_UUID;
 801afb2:	f642 2339 	movw	r3, #10809	; 0x2a39
 801afb6:	80bb      	strh	r3, [r7, #4]
  hciCmdResult = aci_gatt_add_char(HRS_Context.HeartRateSvcHdle,
 801afb8:	4b0d      	ldr	r3, [pc, #52]	; (801aff0 <HRS_Init+0xc8>)
 801afba:	8818      	ldrh	r0, [r3, #0]
 801afbc:	1d3a      	adds	r2, r7, #4
 801afbe:	4b0f      	ldr	r3, [pc, #60]	; (801affc <HRS_Init+0xd4>)
 801afc0:	9305      	str	r3, [sp, #20]
 801afc2:	2300      	movs	r3, #0
 801afc4:	9304      	str	r3, [sp, #16]
 801afc6:	230a      	movs	r3, #10
 801afc8:	9303      	str	r3, [sp, #12]
 801afca:	2302      	movs	r3, #2
 801afcc:	9302      	str	r3, [sp, #8]
 801afce:	2300      	movs	r3, #0
 801afd0:	9301      	str	r3, [sp, #4]
 801afd2:	2308      	movs	r3, #8
 801afd4:	9300      	str	r3, [sp, #0]
 801afd6:	2301      	movs	r3, #1
 801afd8:	2101      	movs	r1, #1
 801afda:	f7ff f9e3 	bl	801a3a4 <aci_gatt_add_char>
 801afde:	4603      	mov	r3, r0
 801afe0:	71fb      	strb	r3, [r7, #7]
  }
#endif
  
  
  
  return;
 801afe2:	bf00      	nop
}
 801afe4:	3708      	adds	r7, #8
 801afe6:	46bd      	mov	sp, r7
 801afe8:	bd80      	pop	{r7, pc}
 801afea:	bf00      	nop
 801afec:	0801ae11 	.word	0x0801ae11
 801aff0:	200002b8 	.word	0x200002b8
 801aff4:	200002ba 	.word	0x200002ba
 801aff8:	200002bc 	.word	0x200002bc
 801affc:	200002be 	.word	0x200002be

0801b000 <BAS_Init>:
/* Private functions ----------------------------------------------------------*/
/* Weak functions ----------------------------------------------------------*/
void BVOPUS_STM_Init(void);

__WEAK void BAS_Init( void )
{
 801b000:	b480      	push	{r7}
 801b002:	af00      	add	r7, sp, #0
  return;
 801b004:	bf00      	nop
}
 801b006:	46bd      	mov	sp, r7
 801b008:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b00c:	4770      	bx	lr

0801b00e <BLS_Init>:

__WEAK void BLS_Init( void )
{
 801b00e:	b480      	push	{r7}
 801b010:	af00      	add	r7, sp, #0
  return;
 801b012:	bf00      	nop
}
 801b014:	46bd      	mov	sp, r7
 801b016:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b01a:	4770      	bx	lr

0801b01c <CRS_STM_Init>:
__WEAK void CRS_STM_Init( void )
{
 801b01c:	b480      	push	{r7}
 801b01e:	af00      	add	r7, sp, #0
  return;
 801b020:	bf00      	nop
}
 801b022:	46bd      	mov	sp, r7
 801b024:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b028:	4770      	bx	lr

0801b02a <EDS_STM_Init>:
__WEAK void DIS_Init( void )
{
  return;
}
__WEAK void EDS_STM_Init( void )
{
 801b02a:	b480      	push	{r7}
 801b02c:	af00      	add	r7, sp, #0
  return;
 801b02e:	bf00      	nop
}
 801b030:	46bd      	mov	sp, r7
 801b032:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b036:	4770      	bx	lr

0801b038 <HIDS_Init>:
__WEAK void HIDS_Init( void )
{
 801b038:	b480      	push	{r7}
 801b03a:	af00      	add	r7, sp, #0
  return;
 801b03c:	bf00      	nop
}
 801b03e:	46bd      	mov	sp, r7
 801b040:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b044:	4770      	bx	lr

0801b046 <HTS_Init>:
__WEAK void HRS_Init( void )
{
  return;
}
__WEAK void HTS_Init( void )
{
 801b046:	b480      	push	{r7}
 801b048:	af00      	add	r7, sp, #0
  return;
 801b04a:	bf00      	nop
}
 801b04c:	46bd      	mov	sp, r7
 801b04e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b052:	4770      	bx	lr

0801b054 <IAS_Init>:
__WEAK void IAS_Init( void )
{
 801b054:	b480      	push	{r7}
 801b056:	af00      	add	r7, sp, #0
  return;
 801b058:	bf00      	nop
}
 801b05a:	46bd      	mov	sp, r7
 801b05c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b060:	4770      	bx	lr

0801b062 <LLS_Init>:
__WEAK void LLS_Init( void )
{
 801b062:	b480      	push	{r7}
 801b064:	af00      	add	r7, sp, #0
  return;
 801b066:	bf00      	nop
}
 801b068:	46bd      	mov	sp, r7
 801b06a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b06e:	4770      	bx	lr

0801b070 <TPS_Init>:
__WEAK void TPS_Init( void )
{
 801b070:	b480      	push	{r7}
 801b072:	af00      	add	r7, sp, #0
  return;
 801b074:	bf00      	nop
}
 801b076:	46bd      	mov	sp, r7
 801b078:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b07c:	4770      	bx	lr

0801b07e <MOTENV_STM_Init>:
__WEAK void MOTENV_STM_Init( void )
{
 801b07e:	b480      	push	{r7}
 801b080:	af00      	add	r7, sp, #0
  return;
 801b082:	bf00      	nop
}
 801b084:	46bd      	mov	sp, r7
 801b086:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b08a:	4770      	bx	lr

0801b08c <P2PS_STM_Init>:
__WEAK void P2PS_STM_Init( void )
{
 801b08c:	b480      	push	{r7}
 801b08e:	af00      	add	r7, sp, #0
  return;
 801b090:	bf00      	nop
}
 801b092:	46bd      	mov	sp, r7
 801b094:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b098:	4770      	bx	lr

0801b09a <ZDD_STM_Init>:
__WEAK void ZDD_STM_Init( void )
{
 801b09a:	b480      	push	{r7}
 801b09c:	af00      	add	r7, sp, #0
  return;
 801b09e:	bf00      	nop
}
 801b0a0:	46bd      	mov	sp, r7
 801b0a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b0a6:	4770      	bx	lr

0801b0a8 <OTAS_STM_Init>:
__WEAK void OTAS_STM_Init( void )
{
 801b0a8:	b480      	push	{r7}
 801b0aa:	af00      	add	r7, sp, #0
  return;
 801b0ac:	bf00      	nop
}
 801b0ae:	46bd      	mov	sp, r7
 801b0b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b0b4:	4770      	bx	lr

0801b0b6 <MESH_Init>:
__WEAK void MESH_Init( void )
{
 801b0b6:	b480      	push	{r7}
 801b0b8:	af00      	add	r7, sp, #0
  return;
 801b0ba:	bf00      	nop
}
 801b0bc:	46bd      	mov	sp, r7
 801b0be:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b0c2:	4770      	bx	lr

0801b0c4 <BVOPUS_STM_Init>:
__WEAK void BVOPUS_STM_Init( void )
{
 801b0c4:	b480      	push	{r7}
 801b0c6:	af00      	add	r7, sp, #0
  return;
 801b0c8:	bf00      	nop
}
 801b0ca:	46bd      	mov	sp, r7
 801b0cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b0d0:	4770      	bx	lr
	...

0801b0d4 <SVCCTL_Init>:
}

/* Functions Definition ------------------------------------------------------*/

void SVCCTL_Init( void )
{
 801b0d4:	b580      	push	{r7, lr}
 801b0d6:	af00      	add	r7, sp, #0
 
  /**
   * Initialize the number of registered Handler
   */
  SVCCTL_EvtHandler.NbreOfRegisteredHandler = 0;
 801b0d8:	4b04      	ldr	r3, [pc, #16]	; (801b0ec <SVCCTL_Init+0x18>)
 801b0da:	2200      	movs	r2, #0
 801b0dc:	771a      	strb	r2, [r3, #28]
  SVCCTL_CltHandler.NbreOfRegisteredHandler = 0;
 801b0de:	4b04      	ldr	r3, [pc, #16]	; (801b0f0 <SVCCTL_Init+0x1c>)
 801b0e0:	2200      	movs	r2, #0
 801b0e2:	701a      	strb	r2, [r3, #0]

  /**
   * Add and Initialize requested services
   */
  SVCCTL_SvcInit();
 801b0e4:	f000 f806 	bl	801b0f4 <SVCCTL_SvcInit>

  return;
 801b0e8:	bf00      	nop
}
 801b0ea:	bd80      	pop	{r7, pc}
 801b0ec:	200002c0 	.word	0x200002c0
 801b0f0:	200002e0 	.word	0x200002e0

0801b0f4 <SVCCTL_SvcInit>:

__WEAK void SVCCTL_SvcInit(void)
{
 801b0f4:	b580      	push	{r7, lr}
 801b0f6:	af00      	add	r7, sp, #0
  BAS_Init();
 801b0f8:	f7ff ff82 	bl	801b000 <BAS_Init>

  BLS_Init();
 801b0fc:	f7ff ff87 	bl	801b00e <BLS_Init>

  CRS_STM_Init();
 801b100:	f7ff ff8c 	bl	801b01c <CRS_STM_Init>

  DIS_Init();
 801b104:	f7ff fe4e 	bl	801ada4 <DIS_Init>

  EDS_STM_Init();
 801b108:	f7ff ff8f 	bl	801b02a <EDS_STM_Init>

  HIDS_Init();
 801b10c:	f7ff ff94 	bl	801b038 <HIDS_Init>

  HRS_Init();
 801b110:	f7ff ff0a 	bl	801af28 <HRS_Init>

  HTS_Init();
 801b114:	f7ff ff97 	bl	801b046 <HTS_Init>

  IAS_Init();
 801b118:	f7ff ff9c 	bl	801b054 <IAS_Init>

  LLS_Init();
 801b11c:	f7ff ffa1 	bl	801b062 <LLS_Init>

  TPS_Init();
 801b120:	f7ff ffa6 	bl	801b070 <TPS_Init>

  MOTENV_STM_Init();
 801b124:	f7ff ffab 	bl	801b07e <MOTENV_STM_Init>

  P2PS_STM_Init();
 801b128:	f7ff ffb0 	bl	801b08c <P2PS_STM_Init>

  ZDD_STM_Init();
 801b12c:	f7ff ffb5 	bl	801b09a <ZDD_STM_Init>

  OTAS_STM_Init();
 801b130:	f7ff ffba 	bl	801b0a8 <OTAS_STM_Init>
  
  BVOPUS_STM_Init();
 801b134:	f7ff ffc6 	bl	801b0c4 <BVOPUS_STM_Init>

  MESH_Init();
 801b138:	f7ff ffbd 	bl	801b0b6 <MESH_Init>

  SVCCTL_InitCustomSvc();
 801b13c:	f00c fe7c 	bl	8027e38 <SVCCTL_InitCustomSvc>
  
  return;
 801b140:	bf00      	nop
}
 801b142:	bd80      	pop	{r7, pc}

0801b144 <SVCCTL_RegisterSvcHandler>:
 * @brief  BLE Controller initialization
 * @param  None
 * @retval None
 */
void SVCCTL_RegisterSvcHandler( SVC_CTL_p_EvtHandler_t pfBLE_SVC_Service_Event_Handler )
{
 801b144:	b480      	push	{r7}
 801b146:	b083      	sub	sp, #12
 801b148:	af00      	add	r7, sp, #0
 801b14a:	6078      	str	r0, [r7, #4]
#if (BLE_CFG_SVC_MAX_NBR_CB > 0)
  SVCCTL_EvtHandler.SVCCTL__SvcHandlerTab[SVCCTL_EvtHandler.NbreOfRegisteredHandler] = pfBLE_SVC_Service_Event_Handler;
 801b14c:	4b09      	ldr	r3, [pc, #36]	; (801b174 <SVCCTL_RegisterSvcHandler+0x30>)
 801b14e:	7f1b      	ldrb	r3, [r3, #28]
 801b150:	4619      	mov	r1, r3
 801b152:	4a08      	ldr	r2, [pc, #32]	; (801b174 <SVCCTL_RegisterSvcHandler+0x30>)
 801b154:	687b      	ldr	r3, [r7, #4]
 801b156:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  SVCCTL_EvtHandler.NbreOfRegisteredHandler++;
 801b15a:	4b06      	ldr	r3, [pc, #24]	; (801b174 <SVCCTL_RegisterSvcHandler+0x30>)
 801b15c:	7f1b      	ldrb	r3, [r3, #28]
 801b15e:	3301      	adds	r3, #1
 801b160:	b2da      	uxtb	r2, r3
 801b162:	4b04      	ldr	r3, [pc, #16]	; (801b174 <SVCCTL_RegisterSvcHandler+0x30>)
 801b164:	771a      	strb	r2, [r3, #28]
#else
  (void)(pfBLE_SVC_Service_Event_Handler);
#endif

  return;
 801b166:	bf00      	nop
}
 801b168:	370c      	adds	r7, #12
 801b16a:	46bd      	mov	sp, r7
 801b16c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b170:	4770      	bx	lr
 801b172:	bf00      	nop
 801b174:	200002c0 	.word	0x200002c0

0801b178 <SVCCTL_UserEvtRx>:

  return;
}

__WEAK SVCCTL_UserEvtFlowStatus_t SVCCTL_UserEvtRx( void *pckt )
{
 801b178:	b580      	push	{r7, lr}
 801b17a:	b086      	sub	sp, #24
 801b17c:	af00      	add	r7, sp, #0
 801b17e:	6078      	str	r0, [r7, #4]
  evt_blecore_aci *blecore_evt;
  SVCCTL_EvtAckStatus_t event_notification_status;
  SVCCTL_UserEvtFlowStatus_t return_status;
  uint8_t index;

  event_pckt = (hci_event_pckt*) ((hci_uart_pckt *) pckt)->data;
 801b180:	687b      	ldr	r3, [r7, #4]
 801b182:	3301      	adds	r3, #1
 801b184:	613b      	str	r3, [r7, #16]
  event_notification_status = SVCCTL_EvtNotAck;
 801b186:	2300      	movs	r3, #0
 801b188:	75fb      	strb	r3, [r7, #23]

  switch (event_pckt->evt)
 801b18a:	693b      	ldr	r3, [r7, #16]
 801b18c:	781b      	ldrb	r3, [r3, #0]
 801b18e:	2bff      	cmp	r3, #255	; 0xff
 801b190:	d125      	bne.n	801b1de <SVCCTL_UserEvtRx+0x66>
  {
    case HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE:
    {
      blecore_evt = (evt_blecore_aci*) event_pckt->data;
 801b192:	693b      	ldr	r3, [r7, #16]
 801b194:	3302      	adds	r3, #2
 801b196:	60fb      	str	r3, [r7, #12]

      switch ((blecore_evt->ecode) & SVCCTL_EGID_EVT_MASK)
 801b198:	68fb      	ldr	r3, [r7, #12]
 801b19a:	881b      	ldrh	r3, [r3, #0]
 801b19c:	b29b      	uxth	r3, r3
 801b19e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 801b1a2:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 801b1a6:	d118      	bne.n	801b1da <SVCCTL_UserEvtRx+0x62>
      {
        case SVCCTL_GATT_EVT_TYPE:
#if (BLE_CFG_SVC_MAX_NBR_CB > 0)
          /* For Service event handler */
          for (index = 0; index < SVCCTL_EvtHandler.NbreOfRegisteredHandler; index++)
 801b1a8:	2300      	movs	r3, #0
 801b1aa:	757b      	strb	r3, [r7, #21]
 801b1ac:	e00d      	b.n	801b1ca <SVCCTL_UserEvtRx+0x52>
          {
            event_notification_status = SVCCTL_EvtHandler.SVCCTL__SvcHandlerTab[index](pckt);
 801b1ae:	7d7b      	ldrb	r3, [r7, #21]
 801b1b0:	4a1a      	ldr	r2, [pc, #104]	; (801b21c <SVCCTL_UserEvtRx+0xa4>)
 801b1b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801b1b6:	6878      	ldr	r0, [r7, #4]
 801b1b8:	4798      	blx	r3
 801b1ba:	4603      	mov	r3, r0
 801b1bc:	75fb      	strb	r3, [r7, #23]
            /**
             * When a GATT event has been acknowledged by a Service, there is no need to call the other registered handlers
             * a GATT event is relevant for only one Service
             */
            if (event_notification_status != SVCCTL_EvtNotAck)
 801b1be:	7dfb      	ldrb	r3, [r7, #23]
 801b1c0:	2b00      	cmp	r3, #0
 801b1c2:	d108      	bne.n	801b1d6 <SVCCTL_UserEvtRx+0x5e>
          for (index = 0; index < SVCCTL_EvtHandler.NbreOfRegisteredHandler; index++)
 801b1c4:	7d7b      	ldrb	r3, [r7, #21]
 801b1c6:	3301      	adds	r3, #1
 801b1c8:	757b      	strb	r3, [r7, #21]
 801b1ca:	4b14      	ldr	r3, [pc, #80]	; (801b21c <SVCCTL_UserEvtRx+0xa4>)
 801b1cc:	7f1b      	ldrb	r3, [r3, #28]
 801b1ce:	7d7a      	ldrb	r2, [r7, #21]
 801b1d0:	429a      	cmp	r2, r3
 801b1d2:	d3ec      	bcc.n	801b1ae <SVCCTL_UserEvtRx+0x36>
               */
              break;
            }
          }
#endif
          break;
 801b1d4:	e002      	b.n	801b1dc <SVCCTL_UserEvtRx+0x64>
              break;
 801b1d6:	bf00      	nop
          break;
 801b1d8:	e000      	b.n	801b1dc <SVCCTL_UserEvtRx+0x64>

        default:
          break;
 801b1da:	bf00      	nop
      }
    }
      break; /* HCI_HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE_SPECIFIC */
 801b1dc:	e000      	b.n	801b1e0 <SVCCTL_UserEvtRx+0x68>

    default:
      break;
 801b1de:	bf00      	nop

  /**
   * When no registered handlers (either Service or Client) has acknowledged the GATT event, it is reported to the application
   * a GAP event is always reported to the applicaiton.
   */
  switch (event_notification_status)
 801b1e0:	7dfb      	ldrb	r3, [r7, #23]
 801b1e2:	2b02      	cmp	r3, #2
 801b1e4:	d00f      	beq.n	801b206 <SVCCTL_UserEvtRx+0x8e>
 801b1e6:	2b02      	cmp	r3, #2
 801b1e8:	dc10      	bgt.n	801b20c <SVCCTL_UserEvtRx+0x94>
 801b1ea:	2b00      	cmp	r3, #0
 801b1ec:	d002      	beq.n	801b1f4 <SVCCTL_UserEvtRx+0x7c>
 801b1ee:	2b01      	cmp	r3, #1
 801b1f0:	d006      	beq.n	801b200 <SVCCTL_UserEvtRx+0x88>
 801b1f2:	e00b      	b.n	801b20c <SVCCTL_UserEvtRx+0x94>
    case SVCCTL_EvtNotAck:
      /**
       *  The event has NOT been managed.
       *  It shall be passed to the application for processing
       */
      return_status = SVCCTL_App_Notification(pckt);
 801b1f4:	6878      	ldr	r0, [r7, #4]
 801b1f6:	f00c fb01 	bl	80277fc <SVCCTL_App_Notification>
 801b1fa:	4603      	mov	r3, r0
 801b1fc:	75bb      	strb	r3, [r7, #22]
      break;
 801b1fe:	e008      	b.n	801b212 <SVCCTL_UserEvtRx+0x9a>

    case SVCCTL_EvtAckFlowEnable:
      return_status = SVCCTL_UserEvtFlowEnable;
 801b200:	2301      	movs	r3, #1
 801b202:	75bb      	strb	r3, [r7, #22]
      break;
 801b204:	e005      	b.n	801b212 <SVCCTL_UserEvtRx+0x9a>

    case SVCCTL_EvtAckFlowDisable:
      return_status = SVCCTL_UserEvtFlowDisable;
 801b206:	2300      	movs	r3, #0
 801b208:	75bb      	strb	r3, [r7, #22]
      break;
 801b20a:	e002      	b.n	801b212 <SVCCTL_UserEvtRx+0x9a>

    default:
      return_status = SVCCTL_UserEvtFlowEnable;
 801b20c:	2301      	movs	r3, #1
 801b20e:	75bb      	strb	r3, [r7, #22]
      break;
 801b210:	bf00      	nop
  }

  return (return_status);
 801b212:	7dbb      	ldrb	r3, [r7, #22]
}
 801b214:	4618      	mov	r0, r3
 801b216:	3718      	adds	r7, #24
 801b218:	46bd      	mov	sp, r7
 801b21a:	bd80      	pop	{r7, pc}
 801b21c:	200002c0 	.word	0x200002c0

0801b220 <SHCI_C2_BLE_Init>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_BLE_Init( SHCI_C2_Ble_Init_Cmd_Packet_t *pCmdPacket )
{
 801b220:	b580      	push	{r7, lr}
 801b222:	b088      	sub	sp, #32
 801b224:	af00      	add	r7, sp, #0
 801b226:	6078      	str	r0, [r7, #4]
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 801b228:	f107 030c 	add.w	r3, r7, #12
 801b22c:	61fb      	str	r3, [r7, #28]

 shci_send( SHCI_OPCODE_C2_BLE_INIT,
            sizeof( SHCI_C2_Ble_Init_Cmd_Param_t ),
            (uint8_t*)&pCmdPacket->Param,
 801b22e:	687b      	ldr	r3, [r7, #4]
 801b230:	f103 020c 	add.w	r2, r3, #12
 shci_send( SHCI_OPCODE_C2_BLE_INIT,
 801b234:	69fb      	ldr	r3, [r7, #28]
 801b236:	2125      	movs	r1, #37	; 0x25
 801b238:	f64f 4066 	movw	r0, #64614	; 0xfc66
 801b23c:	f000 fae2 	bl	801b804 <shci_send>
            p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 801b240:	69fb      	ldr	r3, [r7, #28]
 801b242:	330b      	adds	r3, #11
 801b244:	78db      	ldrb	r3, [r3, #3]
}
 801b246:	4618      	mov	r0, r3
 801b248:	3720      	adds	r7, #32
 801b24a:	46bd      	mov	sp, r7
 801b24c:	bd80      	pop	{r7, pc}

0801b24e <SHCI_C2_DEBUG_Init>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_DEBUG_Init( SHCI_C2_DEBUG_Init_Cmd_Packet_t *pCmdPacket  )
{
 801b24e:	b580      	push	{r7, lr}
 801b250:	b088      	sub	sp, #32
 801b252:	af00      	add	r7, sp, #0
 801b254:	6078      	str	r0, [r7, #4]
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 801b256:	f107 030c 	add.w	r3, r7, #12
 801b25a:	61fb      	str	r3, [r7, #28]

  shci_send( SHCI_OPCODE_C2_DEBUG_INIT,
             sizeof( SHCI_C2_DEBUG_init_Cmd_Param_t ),
             (uint8_t*)&pCmdPacket->Param,
 801b25c:	687b      	ldr	r3, [r7, #4]
 801b25e:	f103 020c 	add.w	r2, r3, #12
  shci_send( SHCI_OPCODE_C2_DEBUG_INIT,
 801b262:	69fb      	ldr	r3, [r7, #28]
 801b264:	210f      	movs	r1, #15
 801b266:	f64f 4068 	movw	r0, #64616	; 0xfc68
 801b26a:	f000 facb 	bl	801b804 <shci_send>
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 801b26e:	69fb      	ldr	r3, [r7, #28]
 801b270:	330b      	adds	r3, #11
 801b272:	78db      	ldrb	r3, [r3, #3]
}
 801b274:	4618      	mov	r0, r3
 801b276:	3720      	adds	r7, #32
 801b278:	46bd      	mov	sp, r7
 801b27a:	bd80      	pop	{r7, pc}

0801b27c <SHCI_C2_Config>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_Config(SHCI_C2_CONFIG_Cmd_Param_t *pCmdPacket)
{
 801b27c:	b580      	push	{r7, lr}
 801b27e:	b088      	sub	sp, #32
 801b280:	af00      	add	r7, sp, #0
 801b282:	6078      	str	r0, [r7, #4]
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 801b284:	f107 030c 	add.w	r3, r7, #12
 801b288:	61fb      	str	r3, [r7, #28]

  shci_send( SHCI_OPCODE_C2_CONFIG,
 801b28a:	69fb      	ldr	r3, [r7, #28]
 801b28c:	687a      	ldr	r2, [r7, #4]
 801b28e:	210e      	movs	r1, #14
 801b290:	f64f 4075 	movw	r0, #64629	; 0xfc75
 801b294:	f000 fab6 	bl	801b804 <shci_send>
             sizeof(SHCI_C2_CONFIG_Cmd_Param_t),
             (uint8_t*)pCmdPacket,
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 801b298:	69fb      	ldr	r3, [r7, #28]
 801b29a:	330b      	adds	r3, #11
 801b29c:	78db      	ldrb	r3, [r3, #3]
}
 801b29e:	4618      	mov	r0, r3
 801b2a0:	3720      	adds	r7, #32
 801b2a2:	46bd      	mov	sp, r7
 801b2a4:	bd80      	pop	{r7, pc}
	...

0801b2a8 <SHCI_GetWirelessFwInfo>:
 *  Local System COMMAND
 *  These commands are NOT sent to the CPU2
 */

SHCI_CmdStatus_t SHCI_GetWirelessFwInfo( WirelessFwInfo_t* pWirelessInfo )
{
 801b2a8:	b480      	push	{r7}
 801b2aa:	b08b      	sub	sp, #44	; 0x2c
 801b2ac:	af00      	add	r7, sp, #0
 801b2ae:	6078      	str	r0, [r7, #4]
  uint32_t ipccdba = 0;
 801b2b0:	2300      	movs	r3, #0
 801b2b2:	613b      	str	r3, [r7, #16]
  MB_RefTable_t * p_RefTable = NULL;
 801b2b4:	2300      	movs	r3, #0
 801b2b6:	60fb      	str	r3, [r7, #12]
  uint32_t wireless_firmware_version = 0;
 801b2b8:	2300      	movs	r3, #0
 801b2ba:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t wireless_firmware_memorySize = 0;
 801b2bc:	2300      	movs	r3, #0
 801b2be:	623b      	str	r3, [r7, #32]
  uint32_t wireless_firmware_infoStack = 0;
 801b2c0:	2300      	movs	r3, #0
 801b2c2:	61fb      	str	r3, [r7, #28]
  MB_FUS_DeviceInfoTable_t * p_fus_device_info_table = NULL;
 801b2c4:	2300      	movs	r3, #0
 801b2c6:	60bb      	str	r3, [r7, #8]
  uint32_t fus_version = 0;
 801b2c8:	2300      	movs	r3, #0
 801b2ca:	61bb      	str	r3, [r7, #24]
  uint32_t fus_memorySize = 0;
 801b2cc:	2300      	movs	r3, #0
 801b2ce:	617b      	str	r3, [r7, #20]

  ipccdba = READ_BIT( FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA );
 801b2d0:	4b4a      	ldr	r3, [pc, #296]	; (801b3fc <SHCI_GetWirelessFwInfo+0x154>)
 801b2d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801b2d4:	f3c3 030d 	ubfx	r3, r3, #0, #14
 801b2d8:	613b      	str	r3, [r7, #16]
  /**
   * The Device Info Table mapping depends on which firmware is running on CPU2.
   * If the FUS is running on CPU2, FUS_DEVICE_INFO_TABLE_VALIDITY_KEYWORD shall be written in the table.
   * Otherwise, it means the Wireless Firmware is running on the CPU2
   */
  p_fus_device_info_table = (MB_FUS_DeviceInfoTable_t*)(*(uint32_t*)((ipccdba<<2) + SRAM2A_BASE));
 801b2da:	693b      	ldr	r3, [r7, #16]
 801b2dc:	009b      	lsls	r3, r3, #2
 801b2de:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 801b2e2:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 801b2e6:	681b      	ldr	r3, [r3, #0]
 801b2e8:	60bb      	str	r3, [r7, #8]

  if(p_fus_device_info_table->DeviceInfoTableState == FUS_DEVICE_INFO_TABLE_VALIDITY_KEYWORD)
 801b2ea:	68bb      	ldr	r3, [r7, #8]
 801b2ec:	681b      	ldr	r3, [r3, #0]
 801b2ee:	4a44      	ldr	r2, [pc, #272]	; (801b400 <SHCI_GetWirelessFwInfo+0x158>)
 801b2f0:	4293      	cmp	r3, r2
 801b2f2:	d10f      	bne.n	801b314 <SHCI_GetWirelessFwInfo+0x6c>
    /* The FUS is running on CPU2 */
    /**
     *  Retrieve the WirelessFwInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    wireless_firmware_version =  p_fus_device_info_table->WirelessStackVersion;
 801b2f4:	68bb      	ldr	r3, [r7, #8]
 801b2f6:	695b      	ldr	r3, [r3, #20]
 801b2f8:	627b      	str	r3, [r7, #36]	; 0x24
    wireless_firmware_memorySize =  p_fus_device_info_table->WirelessStackMemorySize;
 801b2fa:	68bb      	ldr	r3, [r7, #8]
 801b2fc:	699b      	ldr	r3, [r3, #24]
 801b2fe:	623b      	str	r3, [r7, #32]
    wireless_firmware_infoStack =  p_fus_device_info_table->WirelessFirmwareBleInfo;
 801b300:	68bb      	ldr	r3, [r7, #8]
 801b302:	69db      	ldr	r3, [r3, #28]
 801b304:	61fb      	str	r3, [r7, #28]

    /**
     *  Retrieve the FusInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    fus_version =  p_fus_device_info_table->FusVersion;
 801b306:	68bb      	ldr	r3, [r7, #8]
 801b308:	68db      	ldr	r3, [r3, #12]
 801b30a:	61bb      	str	r3, [r7, #24]
    fus_memorySize =  p_fus_device_info_table->FusMemorySize;
 801b30c:	68bb      	ldr	r3, [r7, #8]
 801b30e:	691b      	ldr	r3, [r3, #16]
 801b310:	617b      	str	r3, [r7, #20]
 801b312:	e01a      	b.n	801b34a <SHCI_GetWirelessFwInfo+0xa2>
  }
  else
  {
    /* The Wireless Firmware is running on CPU2 */
    p_RefTable = (MB_RefTable_t*)((ipccdba<<2) + SRAM2A_BASE);
 801b314:	693b      	ldr	r3, [r7, #16]
 801b316:	009b      	lsls	r3, r3, #2
 801b318:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 801b31c:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 801b320:	60fb      	str	r3, [r7, #12]

    /**
     *  Retrieve the WirelessFwInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    wireless_firmware_version =  p_RefTable->p_device_info_table->WirelessFwInfoTable.Version;
 801b322:	68fb      	ldr	r3, [r7, #12]
 801b324:	681b      	ldr	r3, [r3, #0]
 801b326:	691b      	ldr	r3, [r3, #16]
 801b328:	627b      	str	r3, [r7, #36]	; 0x24
    wireless_firmware_memorySize =  p_RefTable->p_device_info_table->WirelessFwInfoTable.MemorySize;
 801b32a:	68fb      	ldr	r3, [r7, #12]
 801b32c:	681b      	ldr	r3, [r3, #0]
 801b32e:	695b      	ldr	r3, [r3, #20]
 801b330:	623b      	str	r3, [r7, #32]
    wireless_firmware_infoStack =  p_RefTable->p_device_info_table->WirelessFwInfoTable.InfoStack;
 801b332:	68fb      	ldr	r3, [r7, #12]
 801b334:	681b      	ldr	r3, [r3, #0]
 801b336:	699b      	ldr	r3, [r3, #24]
 801b338:	61fb      	str	r3, [r7, #28]

    /**
     *  Retrieve the FusInfoTable
     *  This table is stored in RAM at startup during the TL (transport layer) initialization
     */
    fus_version =  p_RefTable->p_device_info_table->FusInfoTable.Version;
 801b33a:	68fb      	ldr	r3, [r7, #12]
 801b33c:	681b      	ldr	r3, [r3, #0]
 801b33e:	685b      	ldr	r3, [r3, #4]
 801b340:	61bb      	str	r3, [r7, #24]
    fus_memorySize =  p_RefTable->p_device_info_table->FusInfoTable.MemorySize;
 801b342:	68fb      	ldr	r3, [r7, #12]
 801b344:	681b      	ldr	r3, [r3, #0]
 801b346:	689b      	ldr	r3, [r3, #8]
 801b348:	617b      	str	r3, [r7, #20]

  /**
   *  Retrieve the WirelessFwInfoTable
   *  This table is stored in RAM at startup during the TL (transport layer) initialization
   */
  pWirelessInfo->VersionMajor       = ((wireless_firmware_version & INFO_VERSION_MAJOR_MASK) >> INFO_VERSION_MAJOR_OFFSET);
 801b34a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b34c:	0e1b      	lsrs	r3, r3, #24
 801b34e:	b2da      	uxtb	r2, r3
 801b350:	687b      	ldr	r3, [r7, #4]
 801b352:	701a      	strb	r2, [r3, #0]
  pWirelessInfo->VersionMinor       = ((wireless_firmware_version & INFO_VERSION_MINOR_MASK) >> INFO_VERSION_MINOR_OFFSET);
 801b354:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b356:	0c1b      	lsrs	r3, r3, #16
 801b358:	b2da      	uxtb	r2, r3
 801b35a:	687b      	ldr	r3, [r7, #4]
 801b35c:	705a      	strb	r2, [r3, #1]
  pWirelessInfo->VersionSub         = ((wireless_firmware_version & INFO_VERSION_SUB_MASK) >> INFO_VERSION_SUB_OFFSET);
 801b35e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b360:	0a1b      	lsrs	r3, r3, #8
 801b362:	b2da      	uxtb	r2, r3
 801b364:	687b      	ldr	r3, [r7, #4]
 801b366:	709a      	strb	r2, [r3, #2]
  pWirelessInfo->VersionBranch      = ((wireless_firmware_version & INFO_VERSION_BRANCH_MASK) >> INFO_VERSION_BRANCH_OFFSET);
 801b368:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b36a:	091b      	lsrs	r3, r3, #4
 801b36c:	b2db      	uxtb	r3, r3
 801b36e:	f003 030f 	and.w	r3, r3, #15
 801b372:	b2da      	uxtb	r2, r3
 801b374:	687b      	ldr	r3, [r7, #4]
 801b376:	70da      	strb	r2, [r3, #3]
  pWirelessInfo->VersionReleaseType = ((wireless_firmware_version & INFO_VERSION_TYPE_MASK) >> INFO_VERSION_TYPE_OFFSET);
 801b378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b37a:	b2db      	uxtb	r3, r3
 801b37c:	f003 030f 	and.w	r3, r3, #15
 801b380:	b2da      	uxtb	r2, r3
 801b382:	687b      	ldr	r3, [r7, #4]
 801b384:	711a      	strb	r2, [r3, #4]

  pWirelessInfo->MemorySizeSram2B   = ((wireless_firmware_memorySize & INFO_SIZE_SRAM2B_MASK) >> INFO_SIZE_SRAM2B_OFFSET);
 801b386:	6a3b      	ldr	r3, [r7, #32]
 801b388:	0e1b      	lsrs	r3, r3, #24
 801b38a:	b2da      	uxtb	r2, r3
 801b38c:	687b      	ldr	r3, [r7, #4]
 801b38e:	715a      	strb	r2, [r3, #5]
  pWirelessInfo->MemorySizeSram2A   = ((wireless_firmware_memorySize & INFO_SIZE_SRAM2A_MASK) >> INFO_SIZE_SRAM2A_OFFSET);
 801b390:	6a3b      	ldr	r3, [r7, #32]
 801b392:	0c1b      	lsrs	r3, r3, #16
 801b394:	b2da      	uxtb	r2, r3
 801b396:	687b      	ldr	r3, [r7, #4]
 801b398:	719a      	strb	r2, [r3, #6]
  pWirelessInfo->MemorySizeSram1    = ((wireless_firmware_memorySize & INFO_SIZE_SRAM1_MASK) >> INFO_SIZE_SRAM1_OFFSET);
 801b39a:	6a3b      	ldr	r3, [r7, #32]
 801b39c:	0a1b      	lsrs	r3, r3, #8
 801b39e:	b2da      	uxtb	r2, r3
 801b3a0:	687b      	ldr	r3, [r7, #4]
 801b3a2:	71da      	strb	r2, [r3, #7]
  pWirelessInfo->MemorySizeFlash    = ((wireless_firmware_memorySize & INFO_SIZE_FLASH_MASK) >> INFO_SIZE_FLASH_OFFSET);
 801b3a4:	6a3b      	ldr	r3, [r7, #32]
 801b3a6:	b2da      	uxtb	r2, r3
 801b3a8:	687b      	ldr	r3, [r7, #4]
 801b3aa:	721a      	strb	r2, [r3, #8]

  pWirelessInfo->StackType          = ((wireless_firmware_infoStack & INFO_STACK_TYPE_MASK) >> INFO_STACK_TYPE_OFFSET);
 801b3ac:	69fb      	ldr	r3, [r7, #28]
 801b3ae:	b2da      	uxtb	r2, r3
 801b3b0:	687b      	ldr	r3, [r7, #4]
 801b3b2:	725a      	strb	r2, [r3, #9]

  /**
   *  Retrieve the FusInfoTable
   *  This table is stored in RAM at startup during the TL (transport layer) initialization
   */
  pWirelessInfo->FusVersionMajor       = ((fus_version & INFO_VERSION_MAJOR_MASK) >> INFO_VERSION_MAJOR_OFFSET);
 801b3b4:	69bb      	ldr	r3, [r7, #24]
 801b3b6:	0e1b      	lsrs	r3, r3, #24
 801b3b8:	b2da      	uxtb	r2, r3
 801b3ba:	687b      	ldr	r3, [r7, #4]
 801b3bc:	729a      	strb	r2, [r3, #10]
  pWirelessInfo->FusVersionMinor       = ((fus_version & INFO_VERSION_MINOR_MASK) >> INFO_VERSION_MINOR_OFFSET);
 801b3be:	69bb      	ldr	r3, [r7, #24]
 801b3c0:	0c1b      	lsrs	r3, r3, #16
 801b3c2:	b2da      	uxtb	r2, r3
 801b3c4:	687b      	ldr	r3, [r7, #4]
 801b3c6:	72da      	strb	r2, [r3, #11]
  pWirelessInfo->FusVersionSub         = ((fus_version & INFO_VERSION_SUB_MASK) >> INFO_VERSION_SUB_OFFSET);
 801b3c8:	69bb      	ldr	r3, [r7, #24]
 801b3ca:	0a1b      	lsrs	r3, r3, #8
 801b3cc:	b2da      	uxtb	r2, r3
 801b3ce:	687b      	ldr	r3, [r7, #4]
 801b3d0:	731a      	strb	r2, [r3, #12]

  pWirelessInfo->FusMemorySizeSram2B   = ((fus_memorySize & INFO_SIZE_SRAM2B_MASK) >> INFO_SIZE_SRAM2B_OFFSET);
 801b3d2:	697b      	ldr	r3, [r7, #20]
 801b3d4:	0e1b      	lsrs	r3, r3, #24
 801b3d6:	b2da      	uxtb	r2, r3
 801b3d8:	687b      	ldr	r3, [r7, #4]
 801b3da:	735a      	strb	r2, [r3, #13]
  pWirelessInfo->FusMemorySizeSram2A   = ((fus_memorySize & INFO_SIZE_SRAM2A_MASK) >> INFO_SIZE_SRAM2A_OFFSET);
 801b3dc:	697b      	ldr	r3, [r7, #20]
 801b3de:	0c1b      	lsrs	r3, r3, #16
 801b3e0:	b2da      	uxtb	r2, r3
 801b3e2:	687b      	ldr	r3, [r7, #4]
 801b3e4:	739a      	strb	r2, [r3, #14]
  pWirelessInfo->FusMemorySizeFlash    = ((fus_memorySize & INFO_SIZE_FLASH_MASK) >> INFO_SIZE_FLASH_OFFSET);
 801b3e6:	697b      	ldr	r3, [r7, #20]
 801b3e8:	b2da      	uxtb	r2, r3
 801b3ea:	687b      	ldr	r3, [r7, #4]
 801b3ec:	73da      	strb	r2, [r3, #15]

  return (SHCI_Success);
 801b3ee:	2300      	movs	r3, #0
}
 801b3f0:	4618      	mov	r0, r3
 801b3f2:	372c      	adds	r7, #44	; 0x2c
 801b3f4:	46bd      	mov	sp, r7
 801b3f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b3fa:	4770      	bx	lr
 801b3fc:	58004000 	.word	0x58004000
 801b400:	a94656b9 	.word	0xa94656b9

0801b404 <hci_init>:
static void TlEvtReceived(TL_EvtPacket_t *hcievt);
static void TlInit( TL_CmdPacket_t * p_cmdbuffer );

/* Interface ------- ---------------------------------------------------------*/
void hci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 801b404:	b580      	push	{r7, lr}
 801b406:	b082      	sub	sp, #8
 801b408:	af00      	add	r7, sp, #0
 801b40a:	6078      	str	r0, [r7, #4]
 801b40c:	6039      	str	r1, [r7, #0]
  StatusNotCallBackFunction = ((HCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 801b40e:	683b      	ldr	r3, [r7, #0]
 801b410:	685b      	ldr	r3, [r3, #4]
 801b412:	4a08      	ldr	r2, [pc, #32]	; (801b434 <hci_init+0x30>)
 801b414:	6013      	str	r3, [r2, #0]
  hciContext.UserEvtRx = UserEvtRx;
 801b416:	4a08      	ldr	r2, [pc, #32]	; (801b438 <hci_init+0x34>)
 801b418:	687b      	ldr	r3, [r7, #4]
 801b41a:	61d3      	str	r3, [r2, #28]

  hci_register_io_bus (&hciContext.io);
 801b41c:	4806      	ldr	r0, [pc, #24]	; (801b438 <hci_init+0x34>)
 801b41e:	f000 f973 	bl	801b708 <hci_register_io_bus>

  TlInit((TL_CmdPacket_t *)(((HCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 801b422:	683b      	ldr	r3, [r7, #0]
 801b424:	681b      	ldr	r3, [r3, #0]
 801b426:	4618      	mov	r0, r3
 801b428:	f000 f8d4 	bl	801b5d4 <TlInit>

  return;
 801b42c:	bf00      	nop
}
 801b42e:	3708      	adds	r7, #8
 801b430:	46bd      	mov	sp, r7
 801b432:	bd80      	pop	{r7, pc}
 801b434:	20002a88 	.word	0x20002a88
 801b438:	20002a60 	.word	0x20002a60

0801b43c <hci_user_evt_proc>:

void hci_user_evt_proc(void)
{
 801b43c:	b580      	push	{r7, lr}
 801b43e:	b084      	sub	sp, #16
 801b440:	af00      	add	r7, sp, #0
  /**
   * It is more secure to use LST_remove_head()/LST_insert_head() compare to LST_get_next_node()/LST_remove_node()
   * in case the user overwrite the header where the next/prev pointers are located
   */

  if((LST_is_empty(&HciAsynchEventQueue) == FALSE) && (UserEventFlow != HCI_TL_UserEventFlow_Disable))
 801b442:	4822      	ldr	r0, [pc, #136]	; (801b4cc <hci_user_evt_proc+0x90>)
 801b444:	f000 fd28 	bl	801be98 <LST_is_empty>
 801b448:	4603      	mov	r3, r0
 801b44a:	2b00      	cmp	r3, #0
 801b44c:	d12b      	bne.n	801b4a6 <hci_user_evt_proc+0x6a>
 801b44e:	4b20      	ldr	r3, [pc, #128]	; (801b4d0 <hci_user_evt_proc+0x94>)
 801b450:	781b      	ldrb	r3, [r3, #0]
 801b452:	2b00      	cmp	r3, #0
 801b454:	d027      	beq.n	801b4a6 <hci_user_evt_proc+0x6a>
  {
    LST_remove_head ( &HciAsynchEventQueue, (tListNode **)&phcievtbuffer );
 801b456:	f107 030c 	add.w	r3, r7, #12
 801b45a:	4619      	mov	r1, r3
 801b45c:	481b      	ldr	r0, [pc, #108]	; (801b4cc <hci_user_evt_proc+0x90>)
 801b45e:	f000 fdaa 	bl	801bfb6 <LST_remove_head>

    if (hciContext.UserEvtRx != NULL)
 801b462:	4b1c      	ldr	r3, [pc, #112]	; (801b4d4 <hci_user_evt_proc+0x98>)
 801b464:	69db      	ldr	r3, [r3, #28]
 801b466:	2b00      	cmp	r3, #0
 801b468:	d00c      	beq.n	801b484 <hci_user_evt_proc+0x48>
    {
      UserEvtRxParam.pckt = phcievtbuffer;
 801b46a:	68fb      	ldr	r3, [r7, #12]
 801b46c:	60bb      	str	r3, [r7, #8]
      UserEvtRxParam.status = HCI_TL_UserEventFlow_Enable;
 801b46e:	2301      	movs	r3, #1
 801b470:	713b      	strb	r3, [r7, #4]
      hciContext.UserEvtRx((void *)&UserEvtRxParam);
 801b472:	4b18      	ldr	r3, [pc, #96]	; (801b4d4 <hci_user_evt_proc+0x98>)
 801b474:	69db      	ldr	r3, [r3, #28]
 801b476:	1d3a      	adds	r2, r7, #4
 801b478:	4610      	mov	r0, r2
 801b47a:	4798      	blx	r3
      UserEventFlow = UserEvtRxParam.status;
 801b47c:	793a      	ldrb	r2, [r7, #4]
 801b47e:	4b14      	ldr	r3, [pc, #80]	; (801b4d0 <hci_user_evt_proc+0x94>)
 801b480:	701a      	strb	r2, [r3, #0]
 801b482:	e002      	b.n	801b48a <hci_user_evt_proc+0x4e>
    }
    else
    {
      UserEventFlow = HCI_TL_UserEventFlow_Enable;
 801b484:	4b12      	ldr	r3, [pc, #72]	; (801b4d0 <hci_user_evt_proc+0x94>)
 801b486:	2201      	movs	r2, #1
 801b488:	701a      	strb	r2, [r3, #0]
    }

    if(UserEventFlow != HCI_TL_UserEventFlow_Disable)
 801b48a:	4b11      	ldr	r3, [pc, #68]	; (801b4d0 <hci_user_evt_proc+0x94>)
 801b48c:	781b      	ldrb	r3, [r3, #0]
 801b48e:	2b00      	cmp	r3, #0
 801b490:	d004      	beq.n	801b49c <hci_user_evt_proc+0x60>
    {
      TL_MM_EvtDone( phcievtbuffer );
 801b492:	68fb      	ldr	r3, [r7, #12]
 801b494:	4618      	mov	r0, r3
 801b496:	f000 fc03 	bl	801bca0 <TL_MM_EvtDone>
 801b49a:	e004      	b.n	801b4a6 <hci_user_evt_proc+0x6a>
    else
    {
      /**
       * put back the event in the queue
       */
      LST_insert_head ( &HciAsynchEventQueue, (tListNode *)phcievtbuffer );
 801b49c:	68fb      	ldr	r3, [r7, #12]
 801b49e:	4619      	mov	r1, r3
 801b4a0:	480a      	ldr	r0, [pc, #40]	; (801b4cc <hci_user_evt_proc+0x90>)
 801b4a2:	f000 fd1b 	bl	801bedc <LST_insert_head>
    }
  }

  if((LST_is_empty(&HciAsynchEventQueue) == FALSE) && (UserEventFlow != HCI_TL_UserEventFlow_Disable))
 801b4a6:	4809      	ldr	r0, [pc, #36]	; (801b4cc <hci_user_evt_proc+0x90>)
 801b4a8:	f000 fcf6 	bl	801be98 <LST_is_empty>
 801b4ac:	4603      	mov	r3, r0
 801b4ae:	2b00      	cmp	r3, #0
 801b4b0:	d107      	bne.n	801b4c2 <hci_user_evt_proc+0x86>
 801b4b2:	4b07      	ldr	r3, [pc, #28]	; (801b4d0 <hci_user_evt_proc+0x94>)
 801b4b4:	781b      	ldrb	r3, [r3, #0]
 801b4b6:	2b00      	cmp	r3, #0
 801b4b8:	d003      	beq.n	801b4c2 <hci_user_evt_proc+0x86>
  {
    hci_notify_asynch_evt((void*) &HciAsynchEventQueue);
 801b4ba:	4804      	ldr	r0, [pc, #16]	; (801b4cc <hci_user_evt_proc+0x90>)
 801b4bc:	f00c fc4e 	bl	8027d5c <hci_notify_asynch_evt>
  }


  return;
 801b4c0:	bf00      	nop
 801b4c2:	bf00      	nop
}
 801b4c4:	3710      	adds	r7, #16
 801b4c6:	46bd      	mov	sp, r7
 801b4c8:	bd80      	pop	{r7, pc}
 801b4ca:	bf00      	nop
 801b4cc:	200002e8 	.word	0x200002e8
 801b4d0:	200002f4 	.word	0x200002f4
 801b4d4:	20002a60 	.word	0x20002a60

0801b4d8 <hci_send_req>:

  return;
}

int hci_send_req(struct hci_request *p_cmd, uint8_t async)
{
 801b4d8:	b580      	push	{r7, lr}
 801b4da:	b088      	sub	sp, #32
 801b4dc:	af00      	add	r7, sp, #0
 801b4de:	6078      	str	r0, [r7, #4]
 801b4e0:	460b      	mov	r3, r1
 801b4e2:	70fb      	strb	r3, [r7, #3]
  TL_CsEvt_t    *pcommand_status_event;
  TL_EvtPacket_t *pevtpacket;
  uint8_t hci_cmd_complete_return_parameters_length;
  HCI_TL_CmdStatus_t local_cmd_status;

  NotifyCmdStatus(HCI_TL_CmdBusy);
 801b4e4:	2000      	movs	r0, #0
 801b4e6:	f000 f8cb 	bl	801b680 <NotifyCmdStatus>
  local_cmd_status = HCI_TL_CmdBusy;
 801b4ea:	2300      	movs	r3, #0
 801b4ec:	77fb      	strb	r3, [r7, #31]
  opcode = ((p_cmd->ocf) & 0x03ff) | ((p_cmd->ogf) << 10);
 801b4ee:	687b      	ldr	r3, [r7, #4]
 801b4f0:	885b      	ldrh	r3, [r3, #2]
 801b4f2:	b21b      	sxth	r3, r3
 801b4f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b4f8:	b21a      	sxth	r2, r3
 801b4fa:	687b      	ldr	r3, [r7, #4]
 801b4fc:	881b      	ldrh	r3, [r3, #0]
 801b4fe:	029b      	lsls	r3, r3, #10
 801b500:	b21b      	sxth	r3, r3
 801b502:	4313      	orrs	r3, r2
 801b504:	b21b      	sxth	r3, r3
 801b506:	83bb      	strh	r3, [r7, #28]
  SendCmd(opcode, p_cmd->clen, p_cmd->cparam);
 801b508:	687b      	ldr	r3, [r7, #4]
 801b50a:	68db      	ldr	r3, [r3, #12]
 801b50c:	b2d9      	uxtb	r1, r3
 801b50e:	687b      	ldr	r3, [r7, #4]
 801b510:	689a      	ldr	r2, [r3, #8]
 801b512:	8bbb      	ldrh	r3, [r7, #28]
 801b514:	4618      	mov	r0, r3
 801b516:	f000 f88d 	bl	801b634 <SendCmd>

  while(local_cmd_status == HCI_TL_CmdBusy)
 801b51a:	e04e      	b.n	801b5ba <hci_send_req+0xe2>
  {
    hci_cmd_resp_wait(HCI_TL_DEFAULT_TIMEOUT);
 801b51c:	f248 00e8 	movw	r0, #33000	; 0x80e8
 801b520:	f00c fc3c 	bl	8027d9c <hci_cmd_resp_wait>

    /**
     * Process Cmd Event
     */
    while(LST_is_empty(&HciCmdEventQueue) == FALSE)
 801b524:	e043      	b.n	801b5ae <hci_send_req+0xd6>
    {
      LST_remove_head (&HciCmdEventQueue, (tListNode **)&pevtpacket);
 801b526:	f107 030c 	add.w	r3, r7, #12
 801b52a:	4619      	mov	r1, r3
 801b52c:	4828      	ldr	r0, [pc, #160]	; (801b5d0 <hci_send_req+0xf8>)
 801b52e:	f000 fd42 	bl	801bfb6 <LST_remove_head>

      if(pevtpacket->evtserial.evt.evtcode == TL_BLEEVT_CS_OPCODE)
 801b532:	68fb      	ldr	r3, [r7, #12]
 801b534:	7a5b      	ldrb	r3, [r3, #9]
 801b536:	2b0f      	cmp	r3, #15
 801b538:	d114      	bne.n	801b564 <hci_send_req+0x8c>
      {
        pcommand_status_event = (TL_CsEvt_t*)pevtpacket->evtserial.evt.payload;
 801b53a:	68fb      	ldr	r3, [r7, #12]
 801b53c:	330b      	adds	r3, #11
 801b53e:	613b      	str	r3, [r7, #16]
        if(pcommand_status_event->cmdcode == opcode)
 801b540:	693b      	ldr	r3, [r7, #16]
 801b542:	885b      	ldrh	r3, [r3, #2]
 801b544:	b29b      	uxth	r3, r3
 801b546:	8bba      	ldrh	r2, [r7, #28]
 801b548:	429a      	cmp	r2, r3
 801b54a:	d104      	bne.n	801b556 <hci_send_req+0x7e>
        {
          *(uint8_t *)(p_cmd->rparam) = pcommand_status_event->status;
 801b54c:	687b      	ldr	r3, [r7, #4]
 801b54e:	691b      	ldr	r3, [r3, #16]
 801b550:	693a      	ldr	r2, [r7, #16]
 801b552:	7812      	ldrb	r2, [r2, #0]
 801b554:	701a      	strb	r2, [r3, #0]
        }

        if(pcommand_status_event->numcmd != 0)
 801b556:	693b      	ldr	r3, [r7, #16]
 801b558:	785b      	ldrb	r3, [r3, #1]
 801b55a:	2b00      	cmp	r3, #0
 801b55c:	d027      	beq.n	801b5ae <hci_send_req+0xd6>
        {
          local_cmd_status = HCI_TL_CmdAvailable;
 801b55e:	2301      	movs	r3, #1
 801b560:	77fb      	strb	r3, [r7, #31]
 801b562:	e024      	b.n	801b5ae <hci_send_req+0xd6>
        }
      }
      else
      {
        pcommand_complete_event = (TL_CcEvt_t*)pevtpacket->evtserial.evt.payload;
 801b564:	68fb      	ldr	r3, [r7, #12]
 801b566:	330b      	adds	r3, #11
 801b568:	61bb      	str	r3, [r7, #24]

        if(pcommand_complete_event->cmdcode == opcode)
 801b56a:	69bb      	ldr	r3, [r7, #24]
 801b56c:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801b570:	b29b      	uxth	r3, r3
 801b572:	8bba      	ldrh	r2, [r7, #28]
 801b574:	429a      	cmp	r2, r3
 801b576:	d114      	bne.n	801b5a2 <hci_send_req+0xca>
        {
          hci_cmd_complete_return_parameters_length = pevtpacket->evtserial.evt.plen - TL_EVT_HDR_SIZE;
 801b578:	68fb      	ldr	r3, [r7, #12]
 801b57a:	7a9b      	ldrb	r3, [r3, #10]
 801b57c:	3b03      	subs	r3, #3
 801b57e:	75fb      	strb	r3, [r7, #23]
          p_cmd->rlen = MIN(hci_cmd_complete_return_parameters_length, p_cmd->rlen);
 801b580:	687b      	ldr	r3, [r7, #4]
 801b582:	695a      	ldr	r2, [r3, #20]
 801b584:	7dfb      	ldrb	r3, [r7, #23]
 801b586:	429a      	cmp	r2, r3
 801b588:	bfa8      	it	ge
 801b58a:	461a      	movge	r2, r3
 801b58c:	687b      	ldr	r3, [r7, #4]
 801b58e:	615a      	str	r2, [r3, #20]
          memcpy(p_cmd->rparam, pcommand_complete_event->payload, p_cmd->rlen);
 801b590:	687b      	ldr	r3, [r7, #4]
 801b592:	6918      	ldr	r0, [r3, #16]
 801b594:	69bb      	ldr	r3, [r7, #24]
 801b596:	1cd9      	adds	r1, r3, #3
 801b598:	687b      	ldr	r3, [r7, #4]
 801b59a:	695b      	ldr	r3, [r3, #20]
 801b59c:	461a      	mov	r2, r3
 801b59e:	f010 fd9f 	bl	802c0e0 <memcpy>
        }

        if(pcommand_complete_event->numcmd != 0)
 801b5a2:	69bb      	ldr	r3, [r7, #24]
 801b5a4:	781b      	ldrb	r3, [r3, #0]
 801b5a6:	2b00      	cmp	r3, #0
 801b5a8:	d001      	beq.n	801b5ae <hci_send_req+0xd6>
        {
          local_cmd_status = HCI_TL_CmdAvailable;
 801b5aa:	2301      	movs	r3, #1
 801b5ac:	77fb      	strb	r3, [r7, #31]
    while(LST_is_empty(&HciCmdEventQueue) == FALSE)
 801b5ae:	4808      	ldr	r0, [pc, #32]	; (801b5d0 <hci_send_req+0xf8>)
 801b5b0:	f000 fc72 	bl	801be98 <LST_is_empty>
 801b5b4:	4603      	mov	r3, r0
 801b5b6:	2b00      	cmp	r3, #0
 801b5b8:	d0b5      	beq.n	801b526 <hci_send_req+0x4e>
  while(local_cmd_status == HCI_TL_CmdBusy)
 801b5ba:	7ffb      	ldrb	r3, [r7, #31]
 801b5bc:	2b00      	cmp	r3, #0
 801b5be:	d0ad      	beq.n	801b51c <hci_send_req+0x44>
        }
      }
    }
  }

  NotifyCmdStatus(HCI_TL_CmdAvailable);
 801b5c0:	2001      	movs	r0, #1
 801b5c2:	f000 f85d 	bl	801b680 <NotifyCmdStatus>

  return 0;
 801b5c6:	2300      	movs	r3, #0
}
 801b5c8:	4618      	mov	r0, r3
 801b5ca:	3720      	adds	r7, #32
 801b5cc:	46bd      	mov	sp, r7
 801b5ce:	bd80      	pop	{r7, pc}
 801b5d0:	20002a80 	.word	0x20002a80

0801b5d4 <TlInit>:

/* Private functions ---------------------------------------------------------*/
static void TlInit( TL_CmdPacket_t * p_cmdbuffer )
{
 801b5d4:	b580      	push	{r7, lr}
 801b5d6:	b086      	sub	sp, #24
 801b5d8:	af00      	add	r7, sp, #0
 801b5da:	6078      	str	r0, [r7, #4]
  TL_BLE_InitConf_t Conf;

  /**
   * Always initialize the command event queue
   */
  LST_init_head (&HciCmdEventQueue);
 801b5dc:	480f      	ldr	r0, [pc, #60]	; (801b61c <TlInit+0x48>)
 801b5de:	f000 fc4b 	bl	801be78 <LST_init_head>

  pCmdBuffer = p_cmdbuffer;
 801b5e2:	4a0f      	ldr	r2, [pc, #60]	; (801b620 <TlInit+0x4c>)
 801b5e4:	687b      	ldr	r3, [r7, #4]
 801b5e6:	6013      	str	r3, [r2, #0]

  LST_init_head (&HciAsynchEventQueue);
 801b5e8:	480e      	ldr	r0, [pc, #56]	; (801b624 <TlInit+0x50>)
 801b5ea:	f000 fc45 	bl	801be78 <LST_init_head>

  UserEventFlow = HCI_TL_UserEventFlow_Enable;
 801b5ee:	4b0e      	ldr	r3, [pc, #56]	; (801b628 <TlInit+0x54>)
 801b5f0:	2201      	movs	r2, #1
 801b5f2:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  if (hciContext.io.Init)
 801b5f4:	4b0d      	ldr	r3, [pc, #52]	; (801b62c <TlInit+0x58>)
 801b5f6:	681b      	ldr	r3, [r3, #0]
 801b5f8:	2b00      	cmp	r3, #0
 801b5fa:	d00a      	beq.n	801b612 <TlInit+0x3e>
  {

    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 801b5fc:	687b      	ldr	r3, [r7, #4]
 801b5fe:	613b      	str	r3, [r7, #16]
    Conf.IoBusEvtCallBack = TlEvtReceived;
 801b600:	4b0b      	ldr	r3, [pc, #44]	; (801b630 <TlInit+0x5c>)
 801b602:	60bb      	str	r3, [r7, #8]
    hciContext.io.Init(&Conf);
 801b604:	4b09      	ldr	r3, [pc, #36]	; (801b62c <TlInit+0x58>)
 801b606:	681b      	ldr	r3, [r3, #0]
 801b608:	f107 0208 	add.w	r2, r7, #8
 801b60c:	4610      	mov	r0, r2
 801b60e:	4798      	blx	r3
  }

  return;
 801b610:	bf00      	nop
 801b612:	bf00      	nop
}
 801b614:	3718      	adds	r7, #24
 801b616:	46bd      	mov	sp, r7
 801b618:	bd80      	pop	{r7, pc}
 801b61a:	bf00      	nop
 801b61c:	20002a80 	.word	0x20002a80
 801b620:	200002f0 	.word	0x200002f0
 801b624:	200002e8 	.word	0x200002e8
 801b628:	200002f4 	.word	0x200002f4
 801b62c:	20002a60 	.word	0x20002a60
 801b630:	0801b6c1 	.word	0x0801b6c1

0801b634 <SendCmd>:

static void SendCmd(uint16_t opcode, uint8_t plen, void *param)
{
 801b634:	b580      	push	{r7, lr}
 801b636:	b082      	sub	sp, #8
 801b638:	af00      	add	r7, sp, #0
 801b63a:	4603      	mov	r3, r0
 801b63c:	603a      	str	r2, [r7, #0]
 801b63e:	80fb      	strh	r3, [r7, #6]
 801b640:	460b      	mov	r3, r1
 801b642:	717b      	strb	r3, [r7, #5]
  pCmdBuffer->cmdserial.cmd.cmdcode = opcode;
 801b644:	4b0c      	ldr	r3, [pc, #48]	; (801b678 <SendCmd+0x44>)
 801b646:	681b      	ldr	r3, [r3, #0]
 801b648:	88fa      	ldrh	r2, [r7, #6]
 801b64a:	f8a3 2009 	strh.w	r2, [r3, #9]
  pCmdBuffer->cmdserial.cmd.plen = plen;
 801b64e:	4b0a      	ldr	r3, [pc, #40]	; (801b678 <SendCmd+0x44>)
 801b650:	681b      	ldr	r3, [r3, #0]
 801b652:	797a      	ldrb	r2, [r7, #5]
 801b654:	72da      	strb	r2, [r3, #11]
  memcpy( pCmdBuffer->cmdserial.cmd.payload, param, plen );
 801b656:	4b08      	ldr	r3, [pc, #32]	; (801b678 <SendCmd+0x44>)
 801b658:	681b      	ldr	r3, [r3, #0]
 801b65a:	330c      	adds	r3, #12
 801b65c:	797a      	ldrb	r2, [r7, #5]
 801b65e:	6839      	ldr	r1, [r7, #0]
 801b660:	4618      	mov	r0, r3
 801b662:	f010 fd3d 	bl	802c0e0 <memcpy>

  hciContext.io.Send(0,0);
 801b666:	4b05      	ldr	r3, [pc, #20]	; (801b67c <SendCmd+0x48>)
 801b668:	691b      	ldr	r3, [r3, #16]
 801b66a:	2100      	movs	r1, #0
 801b66c:	2000      	movs	r0, #0
 801b66e:	4798      	blx	r3

  return;
 801b670:	bf00      	nop
}
 801b672:	3708      	adds	r7, #8
 801b674:	46bd      	mov	sp, r7
 801b676:	bd80      	pop	{r7, pc}
 801b678:	200002f0 	.word	0x200002f0
 801b67c:	20002a60 	.word	0x20002a60

0801b680 <NotifyCmdStatus>:

static void NotifyCmdStatus(HCI_TL_CmdStatus_t hcicmdstatus)
{
 801b680:	b580      	push	{r7, lr}
 801b682:	b082      	sub	sp, #8
 801b684:	af00      	add	r7, sp, #0
 801b686:	4603      	mov	r3, r0
 801b688:	71fb      	strb	r3, [r7, #7]
  if(hcicmdstatus == HCI_TL_CmdBusy)
 801b68a:	79fb      	ldrb	r3, [r7, #7]
 801b68c:	2b00      	cmp	r3, #0
 801b68e:	d108      	bne.n	801b6a2 <NotifyCmdStatus+0x22>
  {
    if(StatusNotCallBackFunction != 0)
 801b690:	4b0a      	ldr	r3, [pc, #40]	; (801b6bc <NotifyCmdStatus+0x3c>)
 801b692:	681b      	ldr	r3, [r3, #0]
 801b694:	2b00      	cmp	r3, #0
 801b696:	d00d      	beq.n	801b6b4 <NotifyCmdStatus+0x34>
    {
      StatusNotCallBackFunction(HCI_TL_CmdBusy);
 801b698:	4b08      	ldr	r3, [pc, #32]	; (801b6bc <NotifyCmdStatus+0x3c>)
 801b69a:	681b      	ldr	r3, [r3, #0]
 801b69c:	2000      	movs	r0, #0
 801b69e:	4798      	blx	r3
    {
      StatusNotCallBackFunction(HCI_TL_CmdAvailable);
    }
  }

  return;
 801b6a0:	e008      	b.n	801b6b4 <NotifyCmdStatus+0x34>
    if(StatusNotCallBackFunction != 0)
 801b6a2:	4b06      	ldr	r3, [pc, #24]	; (801b6bc <NotifyCmdStatus+0x3c>)
 801b6a4:	681b      	ldr	r3, [r3, #0]
 801b6a6:	2b00      	cmp	r3, #0
 801b6a8:	d004      	beq.n	801b6b4 <NotifyCmdStatus+0x34>
      StatusNotCallBackFunction(HCI_TL_CmdAvailable);
 801b6aa:	4b04      	ldr	r3, [pc, #16]	; (801b6bc <NotifyCmdStatus+0x3c>)
 801b6ac:	681b      	ldr	r3, [r3, #0]
 801b6ae:	2001      	movs	r0, #1
 801b6b0:	4798      	blx	r3
  return;
 801b6b2:	bf00      	nop
 801b6b4:	bf00      	nop
}
 801b6b6:	3708      	adds	r7, #8
 801b6b8:	46bd      	mov	sp, r7
 801b6ba:	bd80      	pop	{r7, pc}
 801b6bc:	20002a88 	.word	0x20002a88

0801b6c0 <TlEvtReceived>:

static void TlEvtReceived(TL_EvtPacket_t *hcievt)
{
 801b6c0:	b580      	push	{r7, lr}
 801b6c2:	b082      	sub	sp, #8
 801b6c4:	af00      	add	r7, sp, #0
 801b6c6:	6078      	str	r0, [r7, #4]
  if ( ((hcievt->evtserial.evt.evtcode) == TL_BLEEVT_CS_OPCODE) || ((hcievt->evtserial.evt.evtcode) == TL_BLEEVT_CC_OPCODE ) )
 801b6c8:	687b      	ldr	r3, [r7, #4]
 801b6ca:	7a5b      	ldrb	r3, [r3, #9]
 801b6cc:	2b0f      	cmp	r3, #15
 801b6ce:	d003      	beq.n	801b6d8 <TlEvtReceived+0x18>
 801b6d0:	687b      	ldr	r3, [r7, #4]
 801b6d2:	7a5b      	ldrb	r3, [r3, #9]
 801b6d4:	2b0e      	cmp	r3, #14
 801b6d6:	d107      	bne.n	801b6e8 <TlEvtReceived+0x28>
  {
    LST_insert_tail(&HciCmdEventQueue, (tListNode *)hcievt);
 801b6d8:	6879      	ldr	r1, [r7, #4]
 801b6da:	4809      	ldr	r0, [pc, #36]	; (801b700 <TlEvtReceived+0x40>)
 801b6dc:	f000 fc24 	bl	801bf28 <LST_insert_tail>
    hci_cmd_resp_release(0); /**< Notify the application a full Cmd Event has been received */
 801b6e0:	2000      	movs	r0, #0
 801b6e2:	f00c fb4b 	bl	8027d7c <hci_cmd_resp_release>
 801b6e6:	e006      	b.n	801b6f6 <TlEvtReceived+0x36>
  }
  else
  {
    LST_insert_tail(&HciAsynchEventQueue, (tListNode *)hcievt);
 801b6e8:	6879      	ldr	r1, [r7, #4]
 801b6ea:	4806      	ldr	r0, [pc, #24]	; (801b704 <TlEvtReceived+0x44>)
 801b6ec:	f000 fc1c 	bl	801bf28 <LST_insert_tail>
    hci_notify_asynch_evt((void*) &HciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 801b6f0:	4804      	ldr	r0, [pc, #16]	; (801b704 <TlEvtReceived+0x44>)
 801b6f2:	f00c fb33 	bl	8027d5c <hci_notify_asynch_evt>
  }

  return;
 801b6f6:	bf00      	nop
}
 801b6f8:	3708      	adds	r7, #8
 801b6fa:	46bd      	mov	sp, r7
 801b6fc:	bd80      	pop	{r7, pc}
 801b6fe:	bf00      	nop
 801b700:	20002a80 	.word	0x20002a80
 801b704:	200002e8 	.word	0x200002e8

0801b708 <hci_register_io_bus>:
#include "hci_tl.h"
#include "tl.h"


void hci_register_io_bus(tHciIO* fops)
{
 801b708:	b480      	push	{r7}
 801b70a:	b083      	sub	sp, #12
 801b70c:	af00      	add	r7, sp, #0
 801b70e:	6078      	str	r0, [r7, #4]
  /* Register IO bus services */
  fops->Init    = TL_BLE_Init;
 801b710:	687b      	ldr	r3, [r7, #4]
 801b712:	4a05      	ldr	r2, [pc, #20]	; (801b728 <hci_register_io_bus+0x20>)
 801b714:	601a      	str	r2, [r3, #0]
  fops->Send    = TL_BLE_SendCmd;
 801b716:	687b      	ldr	r3, [r7, #4]
 801b718:	4a04      	ldr	r2, [pc, #16]	; (801b72c <hci_register_io_bus+0x24>)
 801b71a:	611a      	str	r2, [r3, #16]

  return;
 801b71c:	bf00      	nop
}
 801b71e:	370c      	adds	r7, #12
 801b720:	46bd      	mov	sp, r7
 801b722:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b726:	4770      	bx	lr
 801b728:	0801ba19 	.word	0x0801ba19
 801b72c:	0801ba81 	.word	0x0801ba81

0801b730 <shci_init>:
static void TlUserEvtReceived(TL_EvtPacket_t *shcievt);
static void TlInit( TL_CmdPacket_t * p_cmdbuffer );

/* Interface ------- ---------------------------------------------------------*/
void shci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 801b730:	b580      	push	{r7, lr}
 801b732:	b082      	sub	sp, #8
 801b734:	af00      	add	r7, sp, #0
 801b736:	6078      	str	r0, [r7, #4]
 801b738:	6039      	str	r1, [r7, #0]
  StatusNotCallBackFunction = ((SHCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 801b73a:	683b      	ldr	r3, [r7, #0]
 801b73c:	685b      	ldr	r3, [r3, #4]
 801b73e:	4a08      	ldr	r2, [pc, #32]	; (801b760 <shci_init+0x30>)
 801b740:	6013      	str	r3, [r2, #0]
  shciContext.UserEvtRx = UserEvtRx;
 801b742:	4a08      	ldr	r2, [pc, #32]	; (801b764 <shci_init+0x34>)
 801b744:	687b      	ldr	r3, [r7, #4]
 801b746:	61d3      	str	r3, [r2, #28]

  shci_register_io_bus (&shciContext.io);
 801b748:	4806      	ldr	r0, [pc, #24]	; (801b764 <shci_init+0x34>)
 801b74a:	f000 f911 	bl	801b970 <shci_register_io_bus>

  TlInit((TL_CmdPacket_t *)(((SHCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 801b74e:	683b      	ldr	r3, [r7, #0]
 801b750:	681b      	ldr	r3, [r3, #0]
 801b752:	4618      	mov	r0, r3
 801b754:	f000 f894 	bl	801b880 <TlInit>

  return;
 801b758:	bf00      	nop
}
 801b75a:	3708      	adds	r7, #8
 801b75c:	46bd      	mov	sp, r7
 801b75e:	bd80      	pop	{r7, pc}
 801b760:	20002aac 	.word	0x20002aac
 801b764:	20002a8c 	.word	0x20002a8c

0801b768 <shci_user_evt_proc>:

void shci_user_evt_proc(void)
{
 801b768:	b580      	push	{r7, lr}
 801b76a:	b084      	sub	sp, #16
 801b76c:	af00      	add	r7, sp, #0

  /**
   * It is more secure to use LST_remove_head()/LST_insert_head() compare to LST_get_next_node()/LST_remove_node()
   * in case the user overwrite the header where the next/prev pointers are located
   */
  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 801b76e:	4822      	ldr	r0, [pc, #136]	; (801b7f8 <shci_user_evt_proc+0x90>)
 801b770:	f000 fb92 	bl	801be98 <LST_is_empty>
 801b774:	4603      	mov	r3, r0
 801b776:	2b00      	cmp	r3, #0
 801b778:	d12b      	bne.n	801b7d2 <shci_user_evt_proc+0x6a>
 801b77a:	4b20      	ldr	r3, [pc, #128]	; (801b7fc <shci_user_evt_proc+0x94>)
 801b77c:	781b      	ldrb	r3, [r3, #0]
 801b77e:	2b00      	cmp	r3, #0
 801b780:	d027      	beq.n	801b7d2 <shci_user_evt_proc+0x6a>
  {
    LST_remove_head ( &SHciAsynchEventQueue, (tListNode **)&phcievtbuffer );
 801b782:	f107 030c 	add.w	r3, r7, #12
 801b786:	4619      	mov	r1, r3
 801b788:	481b      	ldr	r0, [pc, #108]	; (801b7f8 <shci_user_evt_proc+0x90>)
 801b78a:	f000 fc14 	bl	801bfb6 <LST_remove_head>

    if (shciContext.UserEvtRx != NULL)
 801b78e:	4b1c      	ldr	r3, [pc, #112]	; (801b800 <shci_user_evt_proc+0x98>)
 801b790:	69db      	ldr	r3, [r3, #28]
 801b792:	2b00      	cmp	r3, #0
 801b794:	d00c      	beq.n	801b7b0 <shci_user_evt_proc+0x48>
    {
      UserEvtRxParam.pckt = phcievtbuffer;
 801b796:	68fb      	ldr	r3, [r7, #12]
 801b798:	60bb      	str	r3, [r7, #8]
      UserEvtRxParam.status = SHCI_TL_UserEventFlow_Enable;
 801b79a:	2301      	movs	r3, #1
 801b79c:	713b      	strb	r3, [r7, #4]
      shciContext.UserEvtRx((void *)&UserEvtRxParam);
 801b79e:	4b18      	ldr	r3, [pc, #96]	; (801b800 <shci_user_evt_proc+0x98>)
 801b7a0:	69db      	ldr	r3, [r3, #28]
 801b7a2:	1d3a      	adds	r2, r7, #4
 801b7a4:	4610      	mov	r0, r2
 801b7a6:	4798      	blx	r3
      SHCI_TL_UserEventFlow = UserEvtRxParam.status;
 801b7a8:	793a      	ldrb	r2, [r7, #4]
 801b7aa:	4b14      	ldr	r3, [pc, #80]	; (801b7fc <shci_user_evt_proc+0x94>)
 801b7ac:	701a      	strb	r2, [r3, #0]
 801b7ae:	e002      	b.n	801b7b6 <shci_user_evt_proc+0x4e>
    }
    else
    {
      SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 801b7b0:	4b12      	ldr	r3, [pc, #72]	; (801b7fc <shci_user_evt_proc+0x94>)
 801b7b2:	2201      	movs	r2, #1
 801b7b4:	701a      	strb	r2, [r3, #0]
    }

    if(SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable)
 801b7b6:	4b11      	ldr	r3, [pc, #68]	; (801b7fc <shci_user_evt_proc+0x94>)
 801b7b8:	781b      	ldrb	r3, [r3, #0]
 801b7ba:	2b00      	cmp	r3, #0
 801b7bc:	d004      	beq.n	801b7c8 <shci_user_evt_proc+0x60>
    {
      TL_MM_EvtDone( phcievtbuffer );
 801b7be:	68fb      	ldr	r3, [r7, #12]
 801b7c0:	4618      	mov	r0, r3
 801b7c2:	f000 fa6d 	bl	801bca0 <TL_MM_EvtDone>
 801b7c6:	e004      	b.n	801b7d2 <shci_user_evt_proc+0x6a>
    else
    {
      /**
       * put back the event in the queue
       */
      LST_insert_head ( &SHciAsynchEventQueue, (tListNode *)phcievtbuffer );
 801b7c8:	68fb      	ldr	r3, [r7, #12]
 801b7ca:	4619      	mov	r1, r3
 801b7cc:	480a      	ldr	r0, [pc, #40]	; (801b7f8 <shci_user_evt_proc+0x90>)
 801b7ce:	f000 fb85 	bl	801bedc <LST_insert_head>
    }
  }

  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 801b7d2:	4809      	ldr	r0, [pc, #36]	; (801b7f8 <shci_user_evt_proc+0x90>)
 801b7d4:	f000 fb60 	bl	801be98 <LST_is_empty>
 801b7d8:	4603      	mov	r3, r0
 801b7da:	2b00      	cmp	r3, #0
 801b7dc:	d107      	bne.n	801b7ee <shci_user_evt_proc+0x86>
 801b7de:	4b07      	ldr	r3, [pc, #28]	; (801b7fc <shci_user_evt_proc+0x94>)
 801b7e0:	781b      	ldrb	r3, [r3, #0]
 801b7e2:	2b00      	cmp	r3, #0
 801b7e4:	d003      	beq.n	801b7ee <shci_user_evt_proc+0x86>
  {
    shci_notify_asynch_evt((void*) &SHciAsynchEventQueue);
 801b7e6:	4804      	ldr	r0, [pc, #16]	; (801b7f8 <shci_user_evt_proc+0x90>)
 801b7e8:	f7ed fc0e 	bl	8009008 <shci_notify_asynch_evt>
  }


  return;
 801b7ec:	bf00      	nop
 801b7ee:	bf00      	nop
}
 801b7f0:	3710      	adds	r7, #16
 801b7f2:	46bd      	mov	sp, r7
 801b7f4:	bd80      	pop	{r7, pc}
 801b7f6:	bf00      	nop
 801b7f8:	200002f8 	.word	0x200002f8
 801b7fc:	20000308 	.word	0x20000308
 801b800:	20002a8c 	.word	0x20002a8c

0801b804 <shci_send>:

  return;
}

void shci_send( uint16_t cmd_code, uint8_t len_cmd_payload, uint8_t * p_cmd_payload, TL_EvtPacket_t * p_rsp )
{
 801b804:	b580      	push	{r7, lr}
 801b806:	b084      	sub	sp, #16
 801b808:	af00      	add	r7, sp, #0
 801b80a:	60ba      	str	r2, [r7, #8]
 801b80c:	607b      	str	r3, [r7, #4]
 801b80e:	4603      	mov	r3, r0
 801b810:	81fb      	strh	r3, [r7, #14]
 801b812:	460b      	mov	r3, r1
 801b814:	737b      	strb	r3, [r7, #13]
  Cmd_SetStatus(SHCI_TL_CmdBusy);
 801b816:	2000      	movs	r0, #0
 801b818:	f000 f864 	bl	801b8e4 <Cmd_SetStatus>

  pCmdBuffer->cmdserial.cmd.cmdcode = cmd_code;
 801b81c:	4b16      	ldr	r3, [pc, #88]	; (801b878 <shci_send+0x74>)
 801b81e:	681b      	ldr	r3, [r3, #0]
 801b820:	89fa      	ldrh	r2, [r7, #14]
 801b822:	f8a3 2009 	strh.w	r2, [r3, #9]
  pCmdBuffer->cmdserial.cmd.plen = len_cmd_payload;
 801b826:	4b14      	ldr	r3, [pc, #80]	; (801b878 <shci_send+0x74>)
 801b828:	681b      	ldr	r3, [r3, #0]
 801b82a:	7b7a      	ldrb	r2, [r7, #13]
 801b82c:	72da      	strb	r2, [r3, #11]

  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 801b82e:	4b12      	ldr	r3, [pc, #72]	; (801b878 <shci_send+0x74>)
 801b830:	681b      	ldr	r3, [r3, #0]
 801b832:	330c      	adds	r3, #12
 801b834:	7b7a      	ldrb	r2, [r7, #13]
 801b836:	68b9      	ldr	r1, [r7, #8]
 801b838:	4618      	mov	r0, r3
 801b83a:	f010 fc51 	bl	802c0e0 <memcpy>

  shciContext.io.Send(0,0);
 801b83e:	4b0f      	ldr	r3, [pc, #60]	; (801b87c <shci_send+0x78>)
 801b840:	691b      	ldr	r3, [r3, #16]
 801b842:	2100      	movs	r1, #0
 801b844:	2000      	movs	r0, #0
 801b846:	4798      	blx	r3

  shci_cmd_resp_wait(SHCI_TL_DEFAULT_TIMEOUT);
 801b848:	f248 00e8 	movw	r0, #33000	; 0x80e8
 801b84c:	f7ed fbfc 	bl	8009048 <shci_cmd_resp_wait>

  /**
   * The command complete of a system command does not have the header
   * It starts immediately with the evtserial field
   */
  memcpy( &(p_rsp->evtserial), pCmdBuffer, ((TL_EvtSerial_t*)pCmdBuffer)->evt.plen + TL_EVT_HDR_SIZE );
 801b850:	687b      	ldr	r3, [r7, #4]
 801b852:	f103 0008 	add.w	r0, r3, #8
 801b856:	4b08      	ldr	r3, [pc, #32]	; (801b878 <shci_send+0x74>)
 801b858:	6819      	ldr	r1, [r3, #0]
 801b85a:	4b07      	ldr	r3, [pc, #28]	; (801b878 <shci_send+0x74>)
 801b85c:	681b      	ldr	r3, [r3, #0]
 801b85e:	789b      	ldrb	r3, [r3, #2]
 801b860:	3303      	adds	r3, #3
 801b862:	461a      	mov	r2, r3
 801b864:	f010 fc3c 	bl	802c0e0 <memcpy>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 801b868:	2001      	movs	r0, #1
 801b86a:	f000 f83b 	bl	801b8e4 <Cmd_SetStatus>

  return;
 801b86e:	bf00      	nop
}
 801b870:	3710      	adds	r7, #16
 801b872:	46bd      	mov	sp, r7
 801b874:	bd80      	pop	{r7, pc}
 801b876:	bf00      	nop
 801b878:	20000304 	.word	0x20000304
 801b87c:	20002a8c 	.word	0x20002a8c

0801b880 <TlInit>:

/* Private functions ---------------------------------------------------------*/
static void TlInit( TL_CmdPacket_t * p_cmdbuffer )
{
 801b880:	b580      	push	{r7, lr}
 801b882:	b086      	sub	sp, #24
 801b884:	af00      	add	r7, sp, #0
 801b886:	6078      	str	r0, [r7, #4]
  TL_SYS_InitConf_t Conf;

  pCmdBuffer = p_cmdbuffer;
 801b888:	4a10      	ldr	r2, [pc, #64]	; (801b8cc <TlInit+0x4c>)
 801b88a:	687b      	ldr	r3, [r7, #4]
 801b88c:	6013      	str	r3, [r2, #0]

  LST_init_head (&SHciAsynchEventQueue);
 801b88e:	4810      	ldr	r0, [pc, #64]	; (801b8d0 <TlInit+0x50>)
 801b890:	f000 faf2 	bl	801be78 <LST_init_head>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 801b894:	2001      	movs	r0, #1
 801b896:	f000 f825 	bl	801b8e4 <Cmd_SetStatus>

  SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 801b89a:	4b0e      	ldr	r3, [pc, #56]	; (801b8d4 <TlInit+0x54>)
 801b89c:	2201      	movs	r2, #1
 801b89e:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  if (shciContext.io.Init)
 801b8a0:	4b0d      	ldr	r3, [pc, #52]	; (801b8d8 <TlInit+0x58>)
 801b8a2:	681b      	ldr	r3, [r3, #0]
 801b8a4:	2b00      	cmp	r3, #0
 801b8a6:	d00c      	beq.n	801b8c2 <TlInit+0x42>
  {

    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 801b8a8:	687b      	ldr	r3, [r7, #4]
 801b8aa:	617b      	str	r3, [r7, #20]
    Conf.IoBusCallBackCmdEvt = TlCmdEvtReceived;
 801b8ac:	4b0b      	ldr	r3, [pc, #44]	; (801b8dc <TlInit+0x5c>)
 801b8ae:	60fb      	str	r3, [r7, #12]
    Conf.IoBusCallBackUserEvt = TlUserEvtReceived;
 801b8b0:	4b0b      	ldr	r3, [pc, #44]	; (801b8e0 <TlInit+0x60>)
 801b8b2:	613b      	str	r3, [r7, #16]
    shciContext.io.Init(&Conf);
 801b8b4:	4b08      	ldr	r3, [pc, #32]	; (801b8d8 <TlInit+0x58>)
 801b8b6:	681b      	ldr	r3, [r3, #0]
 801b8b8:	f107 020c 	add.w	r2, r7, #12
 801b8bc:	4610      	mov	r0, r2
 801b8be:	4798      	blx	r3
  }

  return;
 801b8c0:	bf00      	nop
 801b8c2:	bf00      	nop
}
 801b8c4:	3718      	adds	r7, #24
 801b8c6:	46bd      	mov	sp, r7
 801b8c8:	bd80      	pop	{r7, pc}
 801b8ca:	bf00      	nop
 801b8cc:	20000304 	.word	0x20000304
 801b8d0:	200002f8 	.word	0x200002f8
 801b8d4:	20000308 	.word	0x20000308
 801b8d8:	20002a8c 	.word	0x20002a8c
 801b8dc:	0801b935 	.word	0x0801b935
 801b8e0:	0801b94d 	.word	0x0801b94d

0801b8e4 <Cmd_SetStatus>:

static void Cmd_SetStatus(SHCI_TL_CmdStatus_t shcicmdstatus)
{
 801b8e4:	b580      	push	{r7, lr}
 801b8e6:	b082      	sub	sp, #8
 801b8e8:	af00      	add	r7, sp, #0
 801b8ea:	4603      	mov	r3, r0
 801b8ec:	71fb      	strb	r3, [r7, #7]
  if(shcicmdstatus == SHCI_TL_CmdBusy)
 801b8ee:	79fb      	ldrb	r3, [r7, #7]
 801b8f0:	2b00      	cmp	r3, #0
 801b8f2:	d10b      	bne.n	801b90c <Cmd_SetStatus+0x28>
  {
    if(StatusNotCallBackFunction != 0)
 801b8f4:	4b0d      	ldr	r3, [pc, #52]	; (801b92c <Cmd_SetStatus+0x48>)
 801b8f6:	681b      	ldr	r3, [r3, #0]
 801b8f8:	2b00      	cmp	r3, #0
 801b8fa:	d003      	beq.n	801b904 <Cmd_SetStatus+0x20>
    {
      StatusNotCallBackFunction( SHCI_TL_CmdBusy );
 801b8fc:	4b0b      	ldr	r3, [pc, #44]	; (801b92c <Cmd_SetStatus+0x48>)
 801b8fe:	681b      	ldr	r3, [r3, #0]
 801b900:	2000      	movs	r0, #0
 801b902:	4798      	blx	r3
    }
    SHCICmdStatus = SHCI_TL_CmdBusy;
 801b904:	4b0a      	ldr	r3, [pc, #40]	; (801b930 <Cmd_SetStatus+0x4c>)
 801b906:	2200      	movs	r2, #0
 801b908:	701a      	strb	r2, [r3, #0]
    {
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
    }
  }

  return;
 801b90a:	e00b      	b.n	801b924 <Cmd_SetStatus+0x40>
    SHCICmdStatus = SHCI_TL_CmdAvailable;
 801b90c:	4b08      	ldr	r3, [pc, #32]	; (801b930 <Cmd_SetStatus+0x4c>)
 801b90e:	2201      	movs	r2, #1
 801b910:	701a      	strb	r2, [r3, #0]
    if(StatusNotCallBackFunction != 0)
 801b912:	4b06      	ldr	r3, [pc, #24]	; (801b92c <Cmd_SetStatus+0x48>)
 801b914:	681b      	ldr	r3, [r3, #0]
 801b916:	2b00      	cmp	r3, #0
 801b918:	d004      	beq.n	801b924 <Cmd_SetStatus+0x40>
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
 801b91a:	4b04      	ldr	r3, [pc, #16]	; (801b92c <Cmd_SetStatus+0x48>)
 801b91c:	681b      	ldr	r3, [r3, #0]
 801b91e:	2001      	movs	r0, #1
 801b920:	4798      	blx	r3
  return;
 801b922:	bf00      	nop
 801b924:	bf00      	nop
}
 801b926:	3708      	adds	r7, #8
 801b928:	46bd      	mov	sp, r7
 801b92a:	bd80      	pop	{r7, pc}
 801b92c:	20002aac 	.word	0x20002aac
 801b930:	20000300 	.word	0x20000300

0801b934 <TlCmdEvtReceived>:

static void TlCmdEvtReceived(TL_EvtPacket_t *shcievt)
{
 801b934:	b580      	push	{r7, lr}
 801b936:	b082      	sub	sp, #8
 801b938:	af00      	add	r7, sp, #0
 801b93a:	6078      	str	r0, [r7, #4]
  (void)(shcievt);
  shci_cmd_resp_release(0); /**< Notify the application the Cmd response has been received */
 801b93c:	2000      	movs	r0, #0
 801b93e:	f7ed fb73 	bl	8009028 <shci_cmd_resp_release>

  return;
 801b942:	bf00      	nop
}
 801b944:	3708      	adds	r7, #8
 801b946:	46bd      	mov	sp, r7
 801b948:	bd80      	pop	{r7, pc}
	...

0801b94c <TlUserEvtReceived>:

static void TlUserEvtReceived(TL_EvtPacket_t *shcievt)
{
 801b94c:	b580      	push	{r7, lr}
 801b94e:	b082      	sub	sp, #8
 801b950:	af00      	add	r7, sp, #0
 801b952:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&SHciAsynchEventQueue, (tListNode *)shcievt);
 801b954:	6879      	ldr	r1, [r7, #4]
 801b956:	4805      	ldr	r0, [pc, #20]	; (801b96c <TlUserEvtReceived+0x20>)
 801b958:	f000 fae6 	bl	801bf28 <LST_insert_tail>
  shci_notify_asynch_evt((void*) &SHciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 801b95c:	4803      	ldr	r0, [pc, #12]	; (801b96c <TlUserEvtReceived+0x20>)
 801b95e:	f7ed fb53 	bl	8009008 <shci_notify_asynch_evt>

  return;
 801b962:	bf00      	nop
}
 801b964:	3708      	adds	r7, #8
 801b966:	46bd      	mov	sp, r7
 801b968:	bd80      	pop	{r7, pc}
 801b96a:	bf00      	nop
 801b96c:	200002f8 	.word	0x200002f8

0801b970 <shci_register_io_bus>:
#include "shci_tl.h"
#include "tl.h"


void shci_register_io_bus(tSHciIO* fops)
{
 801b970:	b480      	push	{r7}
 801b972:	b083      	sub	sp, #12
 801b974:	af00      	add	r7, sp, #0
 801b976:	6078      	str	r0, [r7, #4]
  /* Register IO bus services */
  fops->Init    = TL_SYS_Init;
 801b978:	687b      	ldr	r3, [r7, #4]
 801b97a:	4a05      	ldr	r2, [pc, #20]	; (801b990 <shci_register_io_bus+0x20>)
 801b97c:	601a      	str	r2, [r3, #0]
  fops->Send    = TL_SYS_SendCmd;
 801b97e:	687b      	ldr	r3, [r7, #4]
 801b980:	4a04      	ldr	r2, [pc, #16]	; (801b994 <shci_register_io_bus+0x24>)
 801b982:	611a      	str	r2, [r3, #16]

  return;
 801b984:	bf00      	nop
}
 801b986:	370c      	adds	r7, #12
 801b988:	46bd      	mov	sp, r7
 801b98a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b98e:	4770      	bx	lr
 801b990:	0801bb2d 	.word	0x0801bb2d
 801b994:	0801bb81 	.word	0x0801bb81

0801b998 <TL_Enable>:

/******************************************************************************
 * GENERAL
 ******************************************************************************/
void TL_Enable( void )
{
 801b998:	b580      	push	{r7, lr}
 801b99a:	af00      	add	r7, sp, #0
  HW_IPCC_Enable();
 801b99c:	f00c fe12 	bl	80285c4 <HW_IPCC_Enable>

  return;
 801b9a0:	bf00      	nop
}
 801b9a2:	bd80      	pop	{r7, pc}

0801b9a4 <TL_Init>:


void TL_Init( void )
{
 801b9a4:	b580      	push	{r7, lr}
 801b9a6:	af00      	add	r7, sp, #0
  TL_RefTable.p_device_info_table = &TL_DeviceInfoTable;
 801b9a8:	4b10      	ldr	r3, [pc, #64]	; (801b9ec <TL_Init+0x48>)
 801b9aa:	4a11      	ldr	r2, [pc, #68]	; (801b9f0 <TL_Init+0x4c>)
 801b9ac:	601a      	str	r2, [r3, #0]
  TL_RefTable.p_ble_table = &TL_BleTable;
 801b9ae:	4b0f      	ldr	r3, [pc, #60]	; (801b9ec <TL_Init+0x48>)
 801b9b0:	4a10      	ldr	r2, [pc, #64]	; (801b9f4 <TL_Init+0x50>)
 801b9b2:	605a      	str	r2, [r3, #4]
  TL_RefTable.p_thread_table = &TL_ThreadTable;
 801b9b4:	4b0d      	ldr	r3, [pc, #52]	; (801b9ec <TL_Init+0x48>)
 801b9b6:	4a10      	ldr	r2, [pc, #64]	; (801b9f8 <TL_Init+0x54>)
 801b9b8:	609a      	str	r2, [r3, #8]
  TL_RefTable.p_lld_tests_table = &TL_LldTestsTable;
 801b9ba:	4b0c      	ldr	r3, [pc, #48]	; (801b9ec <TL_Init+0x48>)
 801b9bc:	4a0f      	ldr	r2, [pc, #60]	; (801b9fc <TL_Init+0x58>)
 801b9be:	621a      	str	r2, [r3, #32]
  TL_RefTable.p_ble_lld_table = &TL_BleLldTable;
 801b9c0:	4b0a      	ldr	r3, [pc, #40]	; (801b9ec <TL_Init+0x48>)
 801b9c2:	4a0f      	ldr	r2, [pc, #60]	; (801ba00 <TL_Init+0x5c>)
 801b9c4:	625a      	str	r2, [r3, #36]	; 0x24
  TL_RefTable.p_sys_table = &TL_SysTable;
 801b9c6:	4b09      	ldr	r3, [pc, #36]	; (801b9ec <TL_Init+0x48>)
 801b9c8:	4a0e      	ldr	r2, [pc, #56]	; (801ba04 <TL_Init+0x60>)
 801b9ca:	60da      	str	r2, [r3, #12]
  TL_RefTable.p_mem_manager_table = &TL_MemManagerTable;
 801b9cc:	4b07      	ldr	r3, [pc, #28]	; (801b9ec <TL_Init+0x48>)
 801b9ce:	4a0e      	ldr	r2, [pc, #56]	; (801ba08 <TL_Init+0x64>)
 801b9d0:	611a      	str	r2, [r3, #16]
  TL_RefTable.p_traces_table = &TL_TracesTable;
 801b9d2:	4b06      	ldr	r3, [pc, #24]	; (801b9ec <TL_Init+0x48>)
 801b9d4:	4a0d      	ldr	r2, [pc, #52]	; (801ba0c <TL_Init+0x68>)
 801b9d6:	615a      	str	r2, [r3, #20]
  TL_RefTable.p_mac_802_15_4_table = &TL_Mac_802_15_4_Table;
 801b9d8:	4b04      	ldr	r3, [pc, #16]	; (801b9ec <TL_Init+0x48>)
 801b9da:	4a0d      	ldr	r2, [pc, #52]	; (801ba10 <TL_Init+0x6c>)
 801b9dc:	619a      	str	r2, [r3, #24]
  TL_RefTable.p_zigbee_table = &TL_Zigbee_Table;
 801b9de:	4b03      	ldr	r3, [pc, #12]	; (801b9ec <TL_Init+0x48>)
 801b9e0:	4a0c      	ldr	r2, [pc, #48]	; (801ba14 <TL_Init+0x70>)
 801b9e2:	61da      	str	r2, [r3, #28]
  HW_IPCC_Init();
 801b9e4:	f00c fe02 	bl	80285ec <HW_IPCC_Init>

  return;
 801b9e8:	bf00      	nop
}
 801b9ea:	bd80      	pop	{r7, pc}
 801b9ec:	20030000 	.word	0x20030000
 801b9f0:	20030028 	.word	0x20030028
 801b9f4:	20030048 	.word	0x20030048
 801b9f8:	20030058 	.word	0x20030058
 801b9fc:	20030064 	.word	0x20030064
 801ba00:	2003006c 	.word	0x2003006c
 801ba04:	20030074 	.word	0x20030074
 801ba08:	2003007c 	.word	0x2003007c
 801ba0c:	20030098 	.word	0x20030098
 801ba10:	2003009c 	.word	0x2003009c
 801ba14:	200300a8 	.word	0x200300a8

0801ba18 <TL_BLE_Init>:

/******************************************************************************
 * BLE
 ******************************************************************************/
int32_t TL_BLE_Init( void* pConf )
{
 801ba18:	b580      	push	{r7, lr}
 801ba1a:	b084      	sub	sp, #16
 801ba1c:	af00      	add	r7, sp, #0
 801ba1e:	6078      	str	r0, [r7, #4]
  MB_BleTable_t  * p_bletable;

  TL_BLE_InitConf_t *pInitHciConf = (TL_BLE_InitConf_t *) pConf;
 801ba20:	687b      	ldr	r3, [r7, #4]
 801ba22:	60fb      	str	r3, [r7, #12]

  LST_init_head (&EvtQueue);
 801ba24:	4811      	ldr	r0, [pc, #68]	; (801ba6c <TL_BLE_Init+0x54>)
 801ba26:	f000 fa27 	bl	801be78 <LST_init_head>

  p_bletable = TL_RefTable.p_ble_table;
 801ba2a:	4b11      	ldr	r3, [pc, #68]	; (801ba70 <TL_BLE_Init+0x58>)
 801ba2c:	685b      	ldr	r3, [r3, #4]
 801ba2e:	60bb      	str	r3, [r7, #8]

  p_bletable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 801ba30:	68fb      	ldr	r3, [r7, #12]
 801ba32:	689a      	ldr	r2, [r3, #8]
 801ba34:	68bb      	ldr	r3, [r7, #8]
 801ba36:	601a      	str	r2, [r3, #0]
  p_bletable->phci_acl_data_buffer = pInitHciConf->p_AclDataBuffer;
 801ba38:	68fb      	ldr	r3, [r7, #12]
 801ba3a:	68da      	ldr	r2, [r3, #12]
 801ba3c:	68bb      	ldr	r3, [r7, #8]
 801ba3e:	60da      	str	r2, [r3, #12]
  p_bletable->pcs_buffer  = (uint8_t*)CsBuffer;
 801ba40:	68bb      	ldr	r3, [r7, #8]
 801ba42:	4a0c      	ldr	r2, [pc, #48]	; (801ba74 <TL_BLE_Init+0x5c>)
 801ba44:	605a      	str	r2, [r3, #4]
  p_bletable->pevt_queue  = (uint8_t*)&EvtQueue;
 801ba46:	68bb      	ldr	r3, [r7, #8]
 801ba48:	4a08      	ldr	r2, [pc, #32]	; (801ba6c <TL_BLE_Init+0x54>)
 801ba4a:	609a      	str	r2, [r3, #8]

  HW_IPCC_BLE_Init();
 801ba4c:	f00c fde4 	bl	8028618 <HW_IPCC_BLE_Init>

  BLE_IoBusEvtCallBackFunction = pInitHciConf->IoBusEvtCallBack;
 801ba50:	68fb      	ldr	r3, [r7, #12]
 801ba52:	681b      	ldr	r3, [r3, #0]
 801ba54:	4a08      	ldr	r2, [pc, #32]	; (801ba78 <TL_BLE_Init+0x60>)
 801ba56:	6013      	str	r3, [r2, #0]
  BLE_IoBusAclDataTxAck = pInitHciConf->IoBusAclDataTxAck;
 801ba58:	68fb      	ldr	r3, [r7, #12]
 801ba5a:	685b      	ldr	r3, [r3, #4]
 801ba5c:	4a07      	ldr	r2, [pc, #28]	; (801ba7c <TL_BLE_Init+0x64>)
 801ba5e:	6013      	str	r3, [r2, #0]

  return 0;
 801ba60:	2300      	movs	r3, #0
}
 801ba62:	4618      	mov	r0, r3
 801ba64:	3710      	adds	r7, #16
 801ba66:	46bd      	mov	sp, r7
 801ba68:	bd80      	pop	{r7, pc}
 801ba6a:	bf00      	nop
 801ba6c:	200300c4 	.word	0x200300c4
 801ba70:	20030000 	.word	0x20030000
 801ba74:	20030a48 	.word	0x20030a48
 801ba78:	20002ab8 	.word	0x20002ab8
 801ba7c:	20002abc 	.word	0x20002abc

0801ba80 <TL_BLE_SendCmd>:

int32_t TL_BLE_SendCmd( uint8_t* buffer, uint16_t size )
{
 801ba80:	b580      	push	{r7, lr}
 801ba82:	b082      	sub	sp, #8
 801ba84:	af00      	add	r7, sp, #0
 801ba86:	6078      	str	r0, [r7, #4]
 801ba88:	460b      	mov	r3, r1
 801ba8a:	807b      	strh	r3, [r7, #2]
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t*)(TL_RefTable.p_ble_table->pcmd_buffer))->cmdserial.type = TL_BLECMD_PKT_TYPE;
 801ba8c:	4b09      	ldr	r3, [pc, #36]	; (801bab4 <TL_BLE_SendCmd+0x34>)
 801ba8e:	685b      	ldr	r3, [r3, #4]
 801ba90:	681b      	ldr	r3, [r3, #0]
 801ba92:	2201      	movs	r2, #1
 801ba94:	721a      	strb	r2, [r3, #8]

  OutputDbgTrace(TL_MB_BLE_CMD, TL_RefTable.p_ble_table->pcmd_buffer);
 801ba96:	4b07      	ldr	r3, [pc, #28]	; (801bab4 <TL_BLE_SendCmd+0x34>)
 801ba98:	685b      	ldr	r3, [r3, #4]
 801ba9a:	681b      	ldr	r3, [r3, #0]
 801ba9c:	4619      	mov	r1, r3
 801ba9e:	2001      	movs	r0, #1
 801baa0:	f000 f96c 	bl	801bd7c <OutputDbgTrace>

  HW_IPCC_BLE_SendCmd();
 801baa4:	f00c fdc2 	bl	802862c <HW_IPCC_BLE_SendCmd>

  return 0;
 801baa8:	2300      	movs	r3, #0
}
 801baaa:	4618      	mov	r0, r3
 801baac:	3708      	adds	r7, #8
 801baae:	46bd      	mov	sp, r7
 801bab0:	bd80      	pop	{r7, pc}
 801bab2:	bf00      	nop
 801bab4:	20030000 	.word	0x20030000

0801bab8 <HW_IPCC_BLE_RxEvtNot>:

void HW_IPCC_BLE_RxEvtNot(void)
{
 801bab8:	b580      	push	{r7, lr}
 801baba:	b082      	sub	sp, #8
 801babc:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&EvtQueue) == FALSE)
 801babe:	e01c      	b.n	801bafa <HW_IPCC_BLE_RxEvtNot+0x42>
  {
    LST_remove_head (&EvtQueue, (tListNode **)&phcievt);
 801bac0:	1d3b      	adds	r3, r7, #4
 801bac2:	4619      	mov	r1, r3
 801bac4:	4812      	ldr	r0, [pc, #72]	; (801bb10 <HW_IPCC_BLE_RxEvtNot+0x58>)
 801bac6:	f000 fa76 	bl	801bfb6 <LST_remove_head>

    if ( ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CS_OPCODE) || ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CC_OPCODE ) )
 801baca:	687b      	ldr	r3, [r7, #4]
 801bacc:	7a5b      	ldrb	r3, [r3, #9]
 801bace:	2b0f      	cmp	r3, #15
 801bad0:	d003      	beq.n	801bada <HW_IPCC_BLE_RxEvtNot+0x22>
 801bad2:	687b      	ldr	r3, [r7, #4]
 801bad4:	7a5b      	ldrb	r3, [r3, #9]
 801bad6:	2b0e      	cmp	r3, #14
 801bad8:	d105      	bne.n	801bae6 <HW_IPCC_BLE_RxEvtNot+0x2e>
    {
      OutputDbgTrace(TL_MB_BLE_CMD_RSP, (uint8_t*)phcievt);
 801bada:	687b      	ldr	r3, [r7, #4]
 801badc:	4619      	mov	r1, r3
 801bade:	2002      	movs	r0, #2
 801bae0:	f000 f94c 	bl	801bd7c <OutputDbgTrace>
 801bae4:	e004      	b.n	801baf0 <HW_IPCC_BLE_RxEvtNot+0x38>
    }
    else
    {
      OutputDbgTrace(TL_MB_BLE_ASYNCH_EVT, (uint8_t*)phcievt);
 801bae6:	687b      	ldr	r3, [r7, #4]
 801bae8:	4619      	mov	r1, r3
 801baea:	2003      	movs	r0, #3
 801baec:	f000 f946 	bl	801bd7c <OutputDbgTrace>
    }

    BLE_IoBusEvtCallBackFunction(phcievt);
 801baf0:	4b08      	ldr	r3, [pc, #32]	; (801bb14 <HW_IPCC_BLE_RxEvtNot+0x5c>)
 801baf2:	681b      	ldr	r3, [r3, #0]
 801baf4:	687a      	ldr	r2, [r7, #4]
 801baf6:	4610      	mov	r0, r2
 801baf8:	4798      	blx	r3
  while(LST_is_empty(&EvtQueue) == FALSE)
 801bafa:	4805      	ldr	r0, [pc, #20]	; (801bb10 <HW_IPCC_BLE_RxEvtNot+0x58>)
 801bafc:	f000 f9cc 	bl	801be98 <LST_is_empty>
 801bb00:	4603      	mov	r3, r0
 801bb02:	2b00      	cmp	r3, #0
 801bb04:	d0dc      	beq.n	801bac0 <HW_IPCC_BLE_RxEvtNot+0x8>
  }

  return;
 801bb06:	bf00      	nop
}
 801bb08:	3708      	adds	r7, #8
 801bb0a:	46bd      	mov	sp, r7
 801bb0c:	bd80      	pop	{r7, pc}
 801bb0e:	bf00      	nop
 801bb10:	200300c4 	.word	0x200300c4
 801bb14:	20002ab8 	.word	0x20002ab8

0801bb18 <HW_IPCC_BLE_AclDataAckNot>:

  return 0;
}

void HW_IPCC_BLE_AclDataAckNot(void)
{
 801bb18:	b580      	push	{r7, lr}
 801bb1a:	af00      	add	r7, sp, #0
  BLE_IoBusAclDataTxAck( );
 801bb1c:	4b02      	ldr	r3, [pc, #8]	; (801bb28 <HW_IPCC_BLE_AclDataAckNot+0x10>)
 801bb1e:	681b      	ldr	r3, [r3, #0]
 801bb20:	4798      	blx	r3

  return;
 801bb22:	bf00      	nop
}
 801bb24:	bd80      	pop	{r7, pc}
 801bb26:	bf00      	nop
 801bb28:	20002abc 	.word	0x20002abc

0801bb2c <TL_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
int32_t TL_SYS_Init( void* pConf  )
{
 801bb2c:	b580      	push	{r7, lr}
 801bb2e:	b084      	sub	sp, #16
 801bb30:	af00      	add	r7, sp, #0
 801bb32:	6078      	str	r0, [r7, #4]
  MB_SysTable_t  * p_systable;

  TL_SYS_InitConf_t *pInitHciConf = (TL_SYS_InitConf_t *) pConf;
 801bb34:	687b      	ldr	r3, [r7, #4]
 801bb36:	60fb      	str	r3, [r7, #12]

  LST_init_head (&SystemEvtQueue);
 801bb38:	480d      	ldr	r0, [pc, #52]	; (801bb70 <TL_SYS_Init+0x44>)
 801bb3a:	f000 f99d 	bl	801be78 <LST_init_head>
  p_systable = TL_RefTable.p_sys_table;
 801bb3e:	4b0d      	ldr	r3, [pc, #52]	; (801bb74 <TL_SYS_Init+0x48>)
 801bb40:	68db      	ldr	r3, [r3, #12]
 801bb42:	60bb      	str	r3, [r7, #8]
  p_systable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 801bb44:	68fb      	ldr	r3, [r7, #12]
 801bb46:	689a      	ldr	r2, [r3, #8]
 801bb48:	68bb      	ldr	r3, [r7, #8]
 801bb4a:	601a      	str	r2, [r3, #0]
  p_systable->sys_queue = (uint8_t*)&SystemEvtQueue;
 801bb4c:	68bb      	ldr	r3, [r7, #8]
 801bb4e:	4a08      	ldr	r2, [pc, #32]	; (801bb70 <TL_SYS_Init+0x44>)
 801bb50:	605a      	str	r2, [r3, #4]

  HW_IPCC_SYS_Init();
 801bb52:	f00c fd8d 	bl	8028670 <HW_IPCC_SYS_Init>

  SYS_CMD_IoBusCallBackFunction = pInitHciConf->IoBusCallBackCmdEvt;
 801bb56:	68fb      	ldr	r3, [r7, #12]
 801bb58:	681b      	ldr	r3, [r3, #0]
 801bb5a:	4a07      	ldr	r2, [pc, #28]	; (801bb78 <TL_SYS_Init+0x4c>)
 801bb5c:	6013      	str	r3, [r2, #0]
  SYS_EVT_IoBusCallBackFunction = pInitHciConf->IoBusCallBackUserEvt;
 801bb5e:	68fb      	ldr	r3, [r7, #12]
 801bb60:	685b      	ldr	r3, [r3, #4]
 801bb62:	4a06      	ldr	r2, [pc, #24]	; (801bb7c <TL_SYS_Init+0x50>)
 801bb64:	6013      	str	r3, [r2, #0]

  return 0;
 801bb66:	2300      	movs	r3, #0
}
 801bb68:	4618      	mov	r0, r3
 801bb6a:	3710      	adds	r7, #16
 801bb6c:	46bd      	mov	sp, r7
 801bb6e:	bd80      	pop	{r7, pc}
 801bb70:	200300cc 	.word	0x200300cc
 801bb74:	20030000 	.word	0x20030000
 801bb78:	20002ac0 	.word	0x20002ac0
 801bb7c:	20002ac4 	.word	0x20002ac4

0801bb80 <TL_SYS_SendCmd>:

int32_t TL_SYS_SendCmd( uint8_t* buffer, uint16_t size )
{
 801bb80:	b580      	push	{r7, lr}
 801bb82:	b082      	sub	sp, #8
 801bb84:	af00      	add	r7, sp, #0
 801bb86:	6078      	str	r0, [r7, #4]
 801bb88:	460b      	mov	r3, r1
 801bb8a:	807b      	strh	r3, [r7, #2]
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t *)(TL_RefTable.p_sys_table->pcmd_buffer))->cmdserial.type = TL_SYSCMD_PKT_TYPE;
 801bb8c:	4b09      	ldr	r3, [pc, #36]	; (801bbb4 <TL_SYS_SendCmd+0x34>)
 801bb8e:	68db      	ldr	r3, [r3, #12]
 801bb90:	681b      	ldr	r3, [r3, #0]
 801bb92:	2210      	movs	r2, #16
 801bb94:	721a      	strb	r2, [r3, #8]

  OutputDbgTrace(TL_MB_SYS_CMD, TL_RefTable.p_sys_table->pcmd_buffer);
 801bb96:	4b07      	ldr	r3, [pc, #28]	; (801bbb4 <TL_SYS_SendCmd+0x34>)
 801bb98:	68db      	ldr	r3, [r3, #12]
 801bb9a:	681b      	ldr	r3, [r3, #0]
 801bb9c:	4619      	mov	r1, r3
 801bb9e:	2004      	movs	r0, #4
 801bba0:	f000 f8ec 	bl	801bd7c <OutputDbgTrace>

  HW_IPCC_SYS_SendCmd();
 801bba4:	f00c fd6e 	bl	8028684 <HW_IPCC_SYS_SendCmd>

  return 0;
 801bba8:	2300      	movs	r3, #0
}
 801bbaa:	4618      	mov	r0, r3
 801bbac:	3708      	adds	r7, #8
 801bbae:	46bd      	mov	sp, r7
 801bbb0:	bd80      	pop	{r7, pc}
 801bbb2:	bf00      	nop
 801bbb4:	20030000 	.word	0x20030000

0801bbb8 <HW_IPCC_SYS_CmdEvtNot>:

void HW_IPCC_SYS_CmdEvtNot(void)
{
 801bbb8:	b580      	push	{r7, lr}
 801bbba:	af00      	add	r7, sp, #0
  OutputDbgTrace(TL_MB_SYS_CMD_RSP, (uint8_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 801bbbc:	4b07      	ldr	r3, [pc, #28]	; (801bbdc <HW_IPCC_SYS_CmdEvtNot+0x24>)
 801bbbe:	68db      	ldr	r3, [r3, #12]
 801bbc0:	681b      	ldr	r3, [r3, #0]
 801bbc2:	4619      	mov	r1, r3
 801bbc4:	2005      	movs	r0, #5
 801bbc6:	f000 f8d9 	bl	801bd7c <OutputDbgTrace>

  SYS_CMD_IoBusCallBackFunction( (TL_EvtPacket_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 801bbca:	4b05      	ldr	r3, [pc, #20]	; (801bbe0 <HW_IPCC_SYS_CmdEvtNot+0x28>)
 801bbcc:	681b      	ldr	r3, [r3, #0]
 801bbce:	4a03      	ldr	r2, [pc, #12]	; (801bbdc <HW_IPCC_SYS_CmdEvtNot+0x24>)
 801bbd0:	68d2      	ldr	r2, [r2, #12]
 801bbd2:	6812      	ldr	r2, [r2, #0]
 801bbd4:	4610      	mov	r0, r2
 801bbd6:	4798      	blx	r3

  return;
 801bbd8:	bf00      	nop
}
 801bbda:	bd80      	pop	{r7, pc}
 801bbdc:	20030000 	.word	0x20030000
 801bbe0:	20002ac0 	.word	0x20002ac0

0801bbe4 <HW_IPCC_SYS_EvtNot>:

void HW_IPCC_SYS_EvtNot( void )
{
 801bbe4:	b580      	push	{r7, lr}
 801bbe6:	b082      	sub	sp, #8
 801bbe8:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *p_evt;

  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 801bbea:	e00e      	b.n	801bc0a <HW_IPCC_SYS_EvtNot+0x26>
  {
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);
 801bbec:	1d3b      	adds	r3, r7, #4
 801bbee:	4619      	mov	r1, r3
 801bbf0:	480b      	ldr	r0, [pc, #44]	; (801bc20 <HW_IPCC_SYS_EvtNot+0x3c>)
 801bbf2:	f000 f9e0 	bl	801bfb6 <LST_remove_head>

    OutputDbgTrace(TL_MB_SYS_ASYNCH_EVT, (uint8_t*)p_evt );
 801bbf6:	687b      	ldr	r3, [r7, #4]
 801bbf8:	4619      	mov	r1, r3
 801bbfa:	2006      	movs	r0, #6
 801bbfc:	f000 f8be 	bl	801bd7c <OutputDbgTrace>

    SYS_EVT_IoBusCallBackFunction( p_evt );
 801bc00:	4b08      	ldr	r3, [pc, #32]	; (801bc24 <HW_IPCC_SYS_EvtNot+0x40>)
 801bc02:	681b      	ldr	r3, [r3, #0]
 801bc04:	687a      	ldr	r2, [r7, #4]
 801bc06:	4610      	mov	r0, r2
 801bc08:	4798      	blx	r3
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 801bc0a:	4805      	ldr	r0, [pc, #20]	; (801bc20 <HW_IPCC_SYS_EvtNot+0x3c>)
 801bc0c:	f000 f944 	bl	801be98 <LST_is_empty>
 801bc10:	4603      	mov	r3, r0
 801bc12:	2b00      	cmp	r3, #0
 801bc14:	d0ea      	beq.n	801bbec <HW_IPCC_SYS_EvtNot+0x8>
  }

  return;
 801bc16:	bf00      	nop
}
 801bc18:	3708      	adds	r7, #8
 801bc1a:	46bd      	mov	sp, r7
 801bc1c:	bd80      	pop	{r7, pc}
 801bc1e:	bf00      	nop
 801bc20:	200300cc 	.word	0x200300cc
 801bc24:	20002ac4 	.word	0x20002ac4

0801bc28 <TL_MM_Init>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void TL_MM_Init( TL_MM_Config_t *p_Config )
{
 801bc28:	b580      	push	{r7, lr}
 801bc2a:	b082      	sub	sp, #8
 801bc2c:	af00      	add	r7, sp, #0
 801bc2e:	6078      	str	r0, [r7, #4]
  static MB_MemManagerTable_t  * p_mem_manager_table;

  LST_init_head (&FreeBufQueue);
 801bc30:	4817      	ldr	r0, [pc, #92]	; (801bc90 <TL_MM_Init+0x68>)
 801bc32:	f000 f921 	bl	801be78 <LST_init_head>
  LST_init_head (&LocalFreeBufQueue);
 801bc36:	4817      	ldr	r0, [pc, #92]	; (801bc94 <TL_MM_Init+0x6c>)
 801bc38:	f000 f91e 	bl	801be78 <LST_init_head>

  p_mem_manager_table = TL_RefTable.p_mem_manager_table;
 801bc3c:	4b16      	ldr	r3, [pc, #88]	; (801bc98 <TL_MM_Init+0x70>)
 801bc3e:	691b      	ldr	r3, [r3, #16]
 801bc40:	4a16      	ldr	r2, [pc, #88]	; (801bc9c <TL_MM_Init+0x74>)
 801bc42:	6013      	str	r3, [r2, #0]

  p_mem_manager_table->blepool = p_Config->p_AsynchEvtPool;
 801bc44:	4b15      	ldr	r3, [pc, #84]	; (801bc9c <TL_MM_Init+0x74>)
 801bc46:	681b      	ldr	r3, [r3, #0]
 801bc48:	687a      	ldr	r2, [r7, #4]
 801bc4a:	6892      	ldr	r2, [r2, #8]
 801bc4c:	609a      	str	r2, [r3, #8]
  p_mem_manager_table->blepoolsize = p_Config->AsynchEvtPoolSize;
 801bc4e:	4b13      	ldr	r3, [pc, #76]	; (801bc9c <TL_MM_Init+0x74>)
 801bc50:	681b      	ldr	r3, [r3, #0]
 801bc52:	687a      	ldr	r2, [r7, #4]
 801bc54:	68d2      	ldr	r2, [r2, #12]
 801bc56:	60da      	str	r2, [r3, #12]
  p_mem_manager_table->pevt_free_buffer_queue = (uint8_t*)&FreeBufQueue;
 801bc58:	4b10      	ldr	r3, [pc, #64]	; (801bc9c <TL_MM_Init+0x74>)
 801bc5a:	681b      	ldr	r3, [r3, #0]
 801bc5c:	4a0c      	ldr	r2, [pc, #48]	; (801bc90 <TL_MM_Init+0x68>)
 801bc5e:	611a      	str	r2, [r3, #16]
  p_mem_manager_table->spare_ble_buffer = p_Config->p_BleSpareEvtBuffer;
 801bc60:	4b0e      	ldr	r3, [pc, #56]	; (801bc9c <TL_MM_Init+0x74>)
 801bc62:	681b      	ldr	r3, [r3, #0]
 801bc64:	687a      	ldr	r2, [r7, #4]
 801bc66:	6812      	ldr	r2, [r2, #0]
 801bc68:	601a      	str	r2, [r3, #0]
  p_mem_manager_table->spare_sys_buffer = p_Config->p_SystemSpareEvtBuffer;
 801bc6a:	4b0c      	ldr	r3, [pc, #48]	; (801bc9c <TL_MM_Init+0x74>)
 801bc6c:	681b      	ldr	r3, [r3, #0]
 801bc6e:	687a      	ldr	r2, [r7, #4]
 801bc70:	6852      	ldr	r2, [r2, #4]
 801bc72:	605a      	str	r2, [r3, #4]
  p_mem_manager_table->traces_evt_pool = p_Config->p_TracesEvtPool;
 801bc74:	4b09      	ldr	r3, [pc, #36]	; (801bc9c <TL_MM_Init+0x74>)
 801bc76:	681b      	ldr	r3, [r3, #0]
 801bc78:	687a      	ldr	r2, [r7, #4]
 801bc7a:	6912      	ldr	r2, [r2, #16]
 801bc7c:	615a      	str	r2, [r3, #20]
  p_mem_manager_table->tracespoolsize = p_Config->TracesEvtPoolSize;
 801bc7e:	4b07      	ldr	r3, [pc, #28]	; (801bc9c <TL_MM_Init+0x74>)
 801bc80:	681b      	ldr	r3, [r3, #0]
 801bc82:	687a      	ldr	r2, [r7, #4]
 801bc84:	6952      	ldr	r2, [r2, #20]
 801bc86:	619a      	str	r2, [r3, #24]

  return;
 801bc88:	bf00      	nop
}
 801bc8a:	3708      	adds	r7, #8
 801bc8c:	46bd      	mov	sp, r7
 801bc8e:	bd80      	pop	{r7, pc}
 801bc90:	200300b4 	.word	0x200300b4
 801bc94:	20002ab0 	.word	0x20002ab0
 801bc98:	20030000 	.word	0x20030000
 801bc9c:	20002ac8 	.word	0x20002ac8

0801bca0 <TL_MM_EvtDone>:

void TL_MM_EvtDone(TL_EvtPacket_t * phcievt)
{
 801bca0:	b580      	push	{r7, lr}
 801bca2:	b082      	sub	sp, #8
 801bca4:	af00      	add	r7, sp, #0
 801bca6:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&LocalFreeBufQueue, (tListNode *)phcievt);
 801bca8:	6879      	ldr	r1, [r7, #4]
 801bcaa:	4807      	ldr	r0, [pc, #28]	; (801bcc8 <TL_MM_EvtDone+0x28>)
 801bcac:	f000 f93c 	bl	801bf28 <LST_insert_tail>

  OutputDbgTrace(TL_MB_MM_RELEASE_BUFFER, (uint8_t*)phcievt);
 801bcb0:	6879      	ldr	r1, [r7, #4]
 801bcb2:	2000      	movs	r0, #0
 801bcb4:	f000 f862 	bl	801bd7c <OutputDbgTrace>

  HW_IPCC_MM_SendFreeBuf( SendFreeBuf );
 801bcb8:	4804      	ldr	r0, [pc, #16]	; (801bccc <TL_MM_EvtDone+0x2c>)
 801bcba:	f00c fd09 	bl	80286d0 <HW_IPCC_MM_SendFreeBuf>

  return;
 801bcbe:	bf00      	nop
}
 801bcc0:	3708      	adds	r7, #8
 801bcc2:	46bd      	mov	sp, r7
 801bcc4:	bd80      	pop	{r7, pc}
 801bcc6:	bf00      	nop
 801bcc8:	20002ab0 	.word	0x20002ab0
 801bccc:	0801bcd1 	.word	0x0801bcd1

0801bcd0 <SendFreeBuf>:

static void SendFreeBuf( void )
{
 801bcd0:	b580      	push	{r7, lr}
 801bcd2:	b082      	sub	sp, #8
 801bcd4:	af00      	add	r7, sp, #0
  tListNode *p_node;

  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 801bcd6:	e00c      	b.n	801bcf2 <SendFreeBuf+0x22>
  {
    LST_remove_head( &LocalFreeBufQueue, (tListNode **)&p_node );
 801bcd8:	1d3b      	adds	r3, r7, #4
 801bcda:	4619      	mov	r1, r3
 801bcdc:	480a      	ldr	r0, [pc, #40]	; (801bd08 <SendFreeBuf+0x38>)
 801bcde:	f000 f96a 	bl	801bfb6 <LST_remove_head>
    LST_insert_tail( (tListNode*)(TL_RefTable.p_mem_manager_table->pevt_free_buffer_queue), p_node );
 801bce2:	4b0a      	ldr	r3, [pc, #40]	; (801bd0c <SendFreeBuf+0x3c>)
 801bce4:	691b      	ldr	r3, [r3, #16]
 801bce6:	691b      	ldr	r3, [r3, #16]
 801bce8:	687a      	ldr	r2, [r7, #4]
 801bcea:	4611      	mov	r1, r2
 801bcec:	4618      	mov	r0, r3
 801bcee:	f000 f91b 	bl	801bf28 <LST_insert_tail>
  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 801bcf2:	4805      	ldr	r0, [pc, #20]	; (801bd08 <SendFreeBuf+0x38>)
 801bcf4:	f000 f8d0 	bl	801be98 <LST_is_empty>
 801bcf8:	4603      	mov	r3, r0
 801bcfa:	2b00      	cmp	r3, #0
 801bcfc:	d0ec      	beq.n	801bcd8 <SendFreeBuf+0x8>
  }

  return;
 801bcfe:	bf00      	nop
}
 801bd00:	3708      	adds	r7, #8
 801bd02:	46bd      	mov	sp, r7
 801bd04:	bd80      	pop	{r7, pc}
 801bd06:	bf00      	nop
 801bd08:	20002ab0 	.word	0x20002ab0
 801bd0c:	20030000 	.word	0x20030000

0801bd10 <TL_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void TL_TRACES_Init( void )
{
 801bd10:	b580      	push	{r7, lr}
 801bd12:	af00      	add	r7, sp, #0
  LST_init_head (&TracesEvtQueue);
 801bd14:	4805      	ldr	r0, [pc, #20]	; (801bd2c <TL_TRACES_Init+0x1c>)
 801bd16:	f000 f8af 	bl	801be78 <LST_init_head>

  TL_RefTable.p_traces_table->traces_queue = (uint8_t*)&TracesEvtQueue;
 801bd1a:	4b05      	ldr	r3, [pc, #20]	; (801bd30 <TL_TRACES_Init+0x20>)
 801bd1c:	695b      	ldr	r3, [r3, #20]
 801bd1e:	4a03      	ldr	r2, [pc, #12]	; (801bd2c <TL_TRACES_Init+0x1c>)
 801bd20:	601a      	str	r2, [r3, #0]

  HW_IPCC_TRACES_Init();
 801bd22:	f00c fd0b 	bl	802873c <HW_IPCC_TRACES_Init>

  return;
 801bd26:	bf00      	nop
}
 801bd28:	bd80      	pop	{r7, pc}
 801bd2a:	bf00      	nop
 801bd2c:	200300bc 	.word	0x200300bc
 801bd30:	20030000 	.word	0x20030000

0801bd34 <HW_IPCC_TRACES_EvtNot>:

void HW_IPCC_TRACES_EvtNot(void)
{
 801bd34:	b580      	push	{r7, lr}
 801bd36:	b082      	sub	sp, #8
 801bd38:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 801bd3a:	e008      	b.n	801bd4e <HW_IPCC_TRACES_EvtNot+0x1a>
  {
    LST_remove_head (&TracesEvtQueue, (tListNode **)&phcievt);
 801bd3c:	1d3b      	adds	r3, r7, #4
 801bd3e:	4619      	mov	r1, r3
 801bd40:	4808      	ldr	r0, [pc, #32]	; (801bd64 <HW_IPCC_TRACES_EvtNot+0x30>)
 801bd42:	f000 f938 	bl	801bfb6 <LST_remove_head>
    TL_TRACES_EvtReceived( phcievt );
 801bd46:	687b      	ldr	r3, [r7, #4]
 801bd48:	4618      	mov	r0, r3
 801bd4a:	f000 f80d 	bl	801bd68 <TL_TRACES_EvtReceived>
  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 801bd4e:	4805      	ldr	r0, [pc, #20]	; (801bd64 <HW_IPCC_TRACES_EvtNot+0x30>)
 801bd50:	f000 f8a2 	bl	801be98 <LST_is_empty>
 801bd54:	4603      	mov	r3, r0
 801bd56:	2b00      	cmp	r3, #0
 801bd58:	d0f0      	beq.n	801bd3c <HW_IPCC_TRACES_EvtNot+0x8>
  }

  return;
 801bd5a:	bf00      	nop
}
 801bd5c:	3708      	adds	r7, #8
 801bd5e:	46bd      	mov	sp, r7
 801bd60:	bd80      	pop	{r7, pc}
 801bd62:	bf00      	nop
 801bd64:	200300bc 	.word	0x200300bc

0801bd68 <TL_TRACES_EvtReceived>:

__WEAK void TL_TRACES_EvtReceived( TL_EvtPacket_t * hcievt )
{
 801bd68:	b480      	push	{r7}
 801bd6a:	b083      	sub	sp, #12
 801bd6c:	af00      	add	r7, sp, #0
 801bd6e:	6078      	str	r0, [r7, #4]
  (void)(hcievt);
}
 801bd70:	bf00      	nop
 801bd72:	370c      	adds	r7, #12
 801bd74:	46bd      	mov	sp, r7
 801bd76:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd7a:	4770      	bx	lr

0801bd7c <OutputDbgTrace>:

/******************************************************************************
 * DEBUG INFORMATION
 ******************************************************************************/
static void OutputDbgTrace(TL_MB_PacketType_t packet_type, uint8_t* buffer)
{
 801bd7c:	b480      	push	{r7}
 801bd7e:	b085      	sub	sp, #20
 801bd80:	af00      	add	r7, sp, #0
 801bd82:	4603      	mov	r3, r0
 801bd84:	6039      	str	r1, [r7, #0]
 801bd86:	71fb      	strb	r3, [r7, #7]
  TL_EvtPacket_t *p_evt_packet;
  TL_CmdPacket_t *p_cmd_packet;

  switch(packet_type)
 801bd88:	79fb      	ldrb	r3, [r7, #7]
 801bd8a:	2b06      	cmp	r3, #6
 801bd8c:	d845      	bhi.n	801be1a <OutputDbgTrace+0x9e>
 801bd8e:	a201      	add	r2, pc, #4	; (adr r2, 801bd94 <OutputDbgTrace+0x18>)
 801bd90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bd94:	0801bdb1 	.word	0x0801bdb1
 801bd98:	0801bdd5 	.word	0x0801bdd5
 801bd9c:	0801bddb 	.word	0x0801bddb
 801bda0:	0801bdef 	.word	0x0801bdef
 801bda4:	0801bdfb 	.word	0x0801bdfb
 801bda8:	0801be01 	.word	0x0801be01
 801bdac:	0801be0f 	.word	0x0801be0f
  {
    case TL_MB_MM_RELEASE_BUFFER:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 801bdb0:	683b      	ldr	r3, [r7, #0]
 801bdb2:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 801bdb4:	68fb      	ldr	r3, [r7, #12]
 801bdb6:	7a5b      	ldrb	r3, [r3, #9]
 801bdb8:	2bff      	cmp	r3, #255	; 0xff
 801bdba:	d005      	beq.n	801bdc8 <OutputDbgTrace+0x4c>
 801bdbc:	2bff      	cmp	r3, #255	; 0xff
 801bdbe:	dc05      	bgt.n	801bdcc <OutputDbgTrace+0x50>
 801bdc0:	2b0e      	cmp	r3, #14
 801bdc2:	d005      	beq.n	801bdd0 <OutputDbgTrace+0x54>
 801bdc4:	2b0f      	cmp	r3, #15
          break;

        default:
          TL_MM_DBG_MSG("mm evt released: 0x%02X", p_evt_packet->evtserial.evt.evtcode);
          TL_MM_DBG_MSG(" buffer addr: 0x%08X", p_evt_packet);
          break;
 801bdc6:	e001      	b.n	801bdcc <OutputDbgTrace+0x50>
          break;
 801bdc8:	bf00      	nop
 801bdca:	e027      	b.n	801be1c <OutputDbgTrace+0xa0>
          break;
 801bdcc:	bf00      	nop
 801bdce:	e025      	b.n	801be1c <OutputDbgTrace+0xa0>
          break;
 801bdd0:	bf00      	nop
      }

      TL_MM_DBG_MSG("\r\n");
      break;
 801bdd2:	e023      	b.n	801be1c <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 801bdd4:	683b      	ldr	r3, [r7, #0]
 801bdd6:	60bb      	str	r3, [r7, #8]
        TL_HCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 801bdd8:	e020      	b.n	801be1c <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 801bdda:	683b      	ldr	r3, [r7, #0]
 801bddc:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 801bdde:	68fb      	ldr	r3, [r7, #12]
 801bde0:	7a5b      	ldrb	r3, [r3, #9]
 801bde2:	2b0e      	cmp	r3, #14
 801bde4:	d001      	beq.n	801bdea <OutputDbgTrace+0x6e>
 801bde6:	2b0f      	cmp	r3, #15
          }
          break;

        default:
          TL_HCI_CMD_DBG_MSG("unknown ble rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 801bde8:	e000      	b.n	801bdec <OutputDbgTrace+0x70>
          break;
 801bdea:	bf00      	nop
      }

      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 801bdec:	e016      	b.n	801be1c <OutputDbgTrace+0xa0>

    case TL_MB_BLE_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 801bdee:	683b      	ldr	r3, [r7, #0]
 801bdf0:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 801bdf2:	68fb      	ldr	r3, [r7, #12]
 801bdf4:	7a5b      	ldrb	r3, [r3, #9]
 801bdf6:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_HCI_EVT_DBG_MSG("\r\n");

      TL_HCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 801bdf8:	e010      	b.n	801be1c <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 801bdfa:	683b      	ldr	r3, [r7, #0]
 801bdfc:	60bb      	str	r3, [r7, #8]
        TL_SHCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 801bdfe:	e00d      	b.n	801be1c <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 801be00:	683b      	ldr	r3, [r7, #0]
 801be02:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 801be04:	68fb      	ldr	r3, [r7, #12]
 801be06:	7a5b      	ldrb	r3, [r3, #9]
 801be08:	2b0e      	cmp	r3, #14
          }
          break;

        default:
          TL_SHCI_CMD_DBG_MSG("unknown sys rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 801be0a:	bf00      	nop
      }

      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 801be0c:	e006      	b.n	801be1c <OutputDbgTrace+0xa0>

    case  TL_MB_SYS_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 801be0e:	683b      	ldr	r3, [r7, #0]
 801be10:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 801be12:	68fb      	ldr	r3, [r7, #12]
 801be14:	7a5b      	ldrb	r3, [r3, #9]
 801be16:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_SHCI_EVT_DBG_MSG("\r\n");

      TL_SHCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 801be18:	e000      	b.n	801be1c <OutputDbgTrace+0xa0>

    default:
      break;
 801be1a:	bf00      	nop
  }

  return;
 801be1c:	bf00      	nop
}
 801be1e:	3714      	adds	r7, #20
 801be20:	46bd      	mov	sp, r7
 801be22:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be26:	4770      	bx	lr

0801be28 <OTP_Read>:
/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/

uint8_t * OTP_Read( uint8_t id )
{
 801be28:	b480      	push	{r7}
 801be2a:	b085      	sub	sp, #20
 801be2c:	af00      	add	r7, sp, #0
 801be2e:	4603      	mov	r3, r0
 801be30:	71fb      	strb	r3, [r7, #7]
  uint8_t *p_id;

  p_id = (uint8_t*)(CFG_OTP_END_ADRESS - 7) ;
 801be32:	4b0f      	ldr	r3, [pc, #60]	; (801be70 <OTP_Read+0x48>)
 801be34:	60fb      	str	r3, [r7, #12]

  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 801be36:	e002      	b.n	801be3e <OTP_Read+0x16>
  {
    p_id -= 8 ;
 801be38:	68fb      	ldr	r3, [r7, #12]
 801be3a:	3b08      	subs	r3, #8
 801be3c:	60fb      	str	r3, [r7, #12]
  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 801be3e:	68fb      	ldr	r3, [r7, #12]
 801be40:	3307      	adds	r3, #7
 801be42:	781b      	ldrb	r3, [r3, #0]
 801be44:	79fa      	ldrb	r2, [r7, #7]
 801be46:	429a      	cmp	r2, r3
 801be48:	d003      	beq.n	801be52 <OTP_Read+0x2a>
 801be4a:	68fb      	ldr	r3, [r7, #12]
 801be4c:	4a09      	ldr	r2, [pc, #36]	; (801be74 <OTP_Read+0x4c>)
 801be4e:	4293      	cmp	r3, r2
 801be50:	d1f2      	bne.n	801be38 <OTP_Read+0x10>
  }

  if((*( p_id + 7 )) != id)
 801be52:	68fb      	ldr	r3, [r7, #12]
 801be54:	3307      	adds	r3, #7
 801be56:	781b      	ldrb	r3, [r3, #0]
 801be58:	79fa      	ldrb	r2, [r7, #7]
 801be5a:	429a      	cmp	r2, r3
 801be5c:	d001      	beq.n	801be62 <OTP_Read+0x3a>
  {
    p_id = 0 ;
 801be5e:	2300      	movs	r3, #0
 801be60:	60fb      	str	r3, [r7, #12]
  }

  return p_id ;
 801be62:	68fb      	ldr	r3, [r7, #12]
}
 801be64:	4618      	mov	r0, r3
 801be66:	3714      	adds	r7, #20
 801be68:	46bd      	mov	sp, r7
 801be6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be6e:	4770      	bx	lr
 801be70:	1fff73f8 	.word	0x1fff73f8
 801be74:	1fff7000 	.word	0x1fff7000

0801be78 <LST_init_head>:

/******************************************************************************
 * Function Definitions 
 ******************************************************************************/
void LST_init_head (tListNode * listHead)
{
 801be78:	b480      	push	{r7}
 801be7a:	b083      	sub	sp, #12
 801be7c:	af00      	add	r7, sp, #0
 801be7e:	6078      	str	r0, [r7, #4]
  listHead->next = listHead;
 801be80:	687b      	ldr	r3, [r7, #4]
 801be82:	687a      	ldr	r2, [r7, #4]
 801be84:	601a      	str	r2, [r3, #0]
  listHead->prev = listHead;
 801be86:	687b      	ldr	r3, [r7, #4]
 801be88:	687a      	ldr	r2, [r7, #4]
 801be8a:	605a      	str	r2, [r3, #4]
}
 801be8c:	bf00      	nop
 801be8e:	370c      	adds	r7, #12
 801be90:	46bd      	mov	sp, r7
 801be92:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be96:	4770      	bx	lr

0801be98 <LST_is_empty>:

uint8_t LST_is_empty (tListNode * listHead)
{
 801be98:	b480      	push	{r7}
 801be9a:	b087      	sub	sp, #28
 801be9c:	af00      	add	r7, sp, #0
 801be9e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801bea0:	f3ef 8310 	mrs	r3, PRIMASK
 801bea4:	60fb      	str	r3, [r7, #12]
  return(result);
 801bea6:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;
  uint8_t return_value;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801bea8:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 801beaa:	b672      	cpsid	i
}
 801beac:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 801beae:	687b      	ldr	r3, [r7, #4]
 801beb0:	681b      	ldr	r3, [r3, #0]
 801beb2:	687a      	ldr	r2, [r7, #4]
 801beb4:	429a      	cmp	r2, r3
 801beb6:	d102      	bne.n	801bebe <LST_is_empty+0x26>
  {
    return_value = TRUE;
 801beb8:	2301      	movs	r3, #1
 801beba:	75fb      	strb	r3, [r7, #23]
 801bebc:	e001      	b.n	801bec2 <LST_is_empty+0x2a>
  }
  else
  {
    return_value = FALSE;
 801bebe:	2300      	movs	r3, #0
 801bec0:	75fb      	strb	r3, [r7, #23]
 801bec2:	693b      	ldr	r3, [r7, #16]
 801bec4:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801bec6:	68bb      	ldr	r3, [r7, #8]
 801bec8:	f383 8810 	msr	PRIMASK, r3
}
 801becc:	bf00      	nop
  }
  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/

  return return_value;
 801bece:	7dfb      	ldrb	r3, [r7, #23]
}
 801bed0:	4618      	mov	r0, r3
 801bed2:	371c      	adds	r7, #28
 801bed4:	46bd      	mov	sp, r7
 801bed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801beda:	4770      	bx	lr

0801bedc <LST_insert_head>:

void LST_insert_head (tListNode * listHead, tListNode * node)
{
 801bedc:	b480      	push	{r7}
 801bede:	b087      	sub	sp, #28
 801bee0:	af00      	add	r7, sp, #0
 801bee2:	6078      	str	r0, [r7, #4]
 801bee4:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801bee6:	f3ef 8310 	mrs	r3, PRIMASK
 801beea:	60fb      	str	r3, [r7, #12]
  return(result);
 801beec:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801beee:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801bef0:	b672      	cpsid	i
}
 801bef2:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead->next;
 801bef4:	687b      	ldr	r3, [r7, #4]
 801bef6:	681a      	ldr	r2, [r3, #0]
 801bef8:	683b      	ldr	r3, [r7, #0]
 801befa:	601a      	str	r2, [r3, #0]
  node->prev = listHead;
 801befc:	683b      	ldr	r3, [r7, #0]
 801befe:	687a      	ldr	r2, [r7, #4]
 801bf00:	605a      	str	r2, [r3, #4]
  listHead->next = node;
 801bf02:	687b      	ldr	r3, [r7, #4]
 801bf04:	683a      	ldr	r2, [r7, #0]
 801bf06:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node;
 801bf08:	683b      	ldr	r3, [r7, #0]
 801bf0a:	681b      	ldr	r3, [r3, #0]
 801bf0c:	683a      	ldr	r2, [r7, #0]
 801bf0e:	605a      	str	r2, [r3, #4]
 801bf10:	697b      	ldr	r3, [r7, #20]
 801bf12:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801bf14:	693b      	ldr	r3, [r7, #16]
 801bf16:	f383 8810 	msr	PRIMASK, r3
}
 801bf1a:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 801bf1c:	bf00      	nop
 801bf1e:	371c      	adds	r7, #28
 801bf20:	46bd      	mov	sp, r7
 801bf22:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf26:	4770      	bx	lr

0801bf28 <LST_insert_tail>:


void LST_insert_tail (tListNode * listHead, tListNode * node)
{
 801bf28:	b480      	push	{r7}
 801bf2a:	b087      	sub	sp, #28
 801bf2c:	af00      	add	r7, sp, #0
 801bf2e:	6078      	str	r0, [r7, #4]
 801bf30:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801bf32:	f3ef 8310 	mrs	r3, PRIMASK
 801bf36:	60fb      	str	r3, [r7, #12]
  return(result);
 801bf38:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801bf3a:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801bf3c:	b672      	cpsid	i
}
 801bf3e:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead;
 801bf40:	683b      	ldr	r3, [r7, #0]
 801bf42:	687a      	ldr	r2, [r7, #4]
 801bf44:	601a      	str	r2, [r3, #0]
  node->prev = listHead->prev;
 801bf46:	687b      	ldr	r3, [r7, #4]
 801bf48:	685a      	ldr	r2, [r3, #4]
 801bf4a:	683b      	ldr	r3, [r7, #0]
 801bf4c:	605a      	str	r2, [r3, #4]
  listHead->prev = node;
 801bf4e:	687b      	ldr	r3, [r7, #4]
 801bf50:	683a      	ldr	r2, [r7, #0]
 801bf52:	605a      	str	r2, [r3, #4]
  (node->prev)->next = node;
 801bf54:	683b      	ldr	r3, [r7, #0]
 801bf56:	685b      	ldr	r3, [r3, #4]
 801bf58:	683a      	ldr	r2, [r7, #0]
 801bf5a:	601a      	str	r2, [r3, #0]
 801bf5c:	697b      	ldr	r3, [r7, #20]
 801bf5e:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801bf60:	693b      	ldr	r3, [r7, #16]
 801bf62:	f383 8810 	msr	PRIMASK, r3
}
 801bf66:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 801bf68:	bf00      	nop
 801bf6a:	371c      	adds	r7, #28
 801bf6c:	46bd      	mov	sp, r7
 801bf6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf72:	4770      	bx	lr

0801bf74 <LST_remove_node>:


void LST_remove_node (tListNode * node)
{
 801bf74:	b480      	push	{r7}
 801bf76:	b087      	sub	sp, #28
 801bf78:	af00      	add	r7, sp, #0
 801bf7a:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801bf7c:	f3ef 8310 	mrs	r3, PRIMASK
 801bf80:	60fb      	str	r3, [r7, #12]
  return(result);
 801bf82:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801bf84:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801bf86:	b672      	cpsid	i
}
 801bf88:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  (node->prev)->next = node->next;
 801bf8a:	687b      	ldr	r3, [r7, #4]
 801bf8c:	685b      	ldr	r3, [r3, #4]
 801bf8e:	687a      	ldr	r2, [r7, #4]
 801bf90:	6812      	ldr	r2, [r2, #0]
 801bf92:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node->prev;
 801bf94:	687b      	ldr	r3, [r7, #4]
 801bf96:	681b      	ldr	r3, [r3, #0]
 801bf98:	687a      	ldr	r2, [r7, #4]
 801bf9a:	6852      	ldr	r2, [r2, #4]
 801bf9c:	605a      	str	r2, [r3, #4]
 801bf9e:	697b      	ldr	r3, [r7, #20]
 801bfa0:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801bfa2:	693b      	ldr	r3, [r7, #16]
 801bfa4:	f383 8810 	msr	PRIMASK, r3
}
 801bfa8:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 801bfaa:	bf00      	nop
 801bfac:	371c      	adds	r7, #28
 801bfae:	46bd      	mov	sp, r7
 801bfb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bfb4:	4770      	bx	lr

0801bfb6 <LST_remove_head>:


void LST_remove_head (tListNode * listHead, tListNode ** node )
{
 801bfb6:	b580      	push	{r7, lr}
 801bfb8:	b086      	sub	sp, #24
 801bfba:	af00      	add	r7, sp, #0
 801bfbc:	6078      	str	r0, [r7, #4]
 801bfbe:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801bfc0:	f3ef 8310 	mrs	r3, PRIMASK
 801bfc4:	60fb      	str	r3, [r7, #12]
  return(result);
 801bfc6:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801bfc8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801bfca:	b672      	cpsid	i
}
 801bfcc:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  *node = listHead->next;
 801bfce:	687b      	ldr	r3, [r7, #4]
 801bfd0:	681a      	ldr	r2, [r3, #0]
 801bfd2:	683b      	ldr	r3, [r7, #0]
 801bfd4:	601a      	str	r2, [r3, #0]
  LST_remove_node (listHead->next);
 801bfd6:	687b      	ldr	r3, [r7, #4]
 801bfd8:	681b      	ldr	r3, [r3, #0]
 801bfda:	4618      	mov	r0, r3
 801bfdc:	f7ff ffca 	bl	801bf74 <LST_remove_node>
 801bfe0:	697b      	ldr	r3, [r7, #20]
 801bfe2:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801bfe4:	693b      	ldr	r3, [r7, #16]
 801bfe6:	f383 8810 	msr	PRIMASK, r3
}
 801bfea:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 801bfec:	bf00      	nop
 801bfee:	3718      	adds	r7, #24
 801bff0:	46bd      	mov	sp, r7
 801bff2:	bd80      	pop	{r7, pc}

0801bff4 <_ZN15Adafruit_AS7341C1Ev>:

/**
 * @brief Construct a new Adafruit_AS7341::Adafruit_AS7341 object
 *
 */
Adafruit_AS7341::Adafruit_AS7341(void) {
 801bff4:	b480      	push	{r7}
 801bff6:	b083      	sub	sp, #12
 801bff8:	af00      	add	r7, sp, #0
 801bffa:	6078      	str	r0, [r7, #4]
 801bffc:	4a09      	ldr	r2, [pc, #36]	; (801c024 <_ZN15Adafruit_AS7341C1Ev+0x30>)
 801bffe:	687b      	ldr	r3, [r7, #4]
 801c000:	601a      	str	r2, [r3, #0]
 801c002:	687b      	ldr	r3, [r7, #4]
 801c004:	2200      	movs	r2, #0
 801c006:	711a      	strb	r2, [r3, #4]
 801c008:	687b      	ldr	r3, [r7, #4]
 801c00a:	2200      	movs	r2, #0
 801c00c:	609a      	str	r2, [r3, #8]
 801c00e:	687b      	ldr	r3, [r7, #4]
 801c010:	2200      	movs	r2, #0
 801c012:	731a      	strb	r2, [r3, #12]
}
 801c014:	687b      	ldr	r3, [r7, #4]
 801c016:	4618      	mov	r0, r3
 801c018:	370c      	adds	r7, #12
 801c01a:	46bd      	mov	sp, r7
 801c01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c020:	4770      	bx	lr
 801c022:	bf00      	nop
 801c024:	0802cb34 	.word	0x0802cb34

0801c028 <_ZN15Adafruit_AS7341D1Ev>:

/**
 * @brief Destroy the Adafruit_AS7341::Adafruit_AS7341 object
 *
 */
Adafruit_AS7341::~Adafruit_AS7341(void) {
 801c028:	b480      	push	{r7}
 801c02a:	b083      	sub	sp, #12
 801c02c:	af00      	add	r7, sp, #0
 801c02e:	6078      	str	r0, [r7, #4]
 801c030:	4a04      	ldr	r2, [pc, #16]	; (801c044 <_ZN15Adafruit_AS7341D1Ev+0x1c>)
 801c032:	687b      	ldr	r3, [r7, #4]
 801c034:	601a      	str	r2, [r3, #0]
	//   if (temp_sensor)
	//     delete temp_sensor;
	//   if (pressure_sensor)
	//     delete pressure_sensor;
}
 801c036:	687b      	ldr	r3, [r7, #4]
 801c038:	4618      	mov	r0, r3
 801c03a:	370c      	adds	r7, #12
 801c03c:	46bd      	mov	sp, r7
 801c03e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c042:	4770      	bx	lr
 801c044:	0802cb34 	.word	0x0802cb34

0801c048 <_ZN15Adafruit_AS73415beginEhP19__I2C_HandleTypeDefl>:
 *    @param  sensor_id
 *            The unique ID to differentiate the sensors from others
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_AS7341::begin(uint8_t i2c_address, I2C_HandleTypeDef *i2c_handle,
		int32_t sensor_id) {
 801c048:	b580      	push	{r7, lr}
 801c04a:	b084      	sub	sp, #16
 801c04c:	af00      	add	r7, sp, #0
 801c04e:	60f8      	str	r0, [r7, #12]
 801c050:	607a      	str	r2, [r7, #4]
 801c052:	603b      	str	r3, [r7, #0]
 801c054:	460b      	mov	r3, r1
 801c056:	72fb      	strb	r3, [r7, #11]

	i2c_han = i2c_handle;
 801c058:	68fb      	ldr	r3, [r7, #12]
 801c05a:	687a      	ldr	r2, [r7, #4]
 801c05c:	609a      	str	r2, [r3, #8]
	i2c_addr = i2c_address << 1;
 801c05e:	7afb      	ldrb	r3, [r7, #11]
 801c060:	005b      	lsls	r3, r3, #1
 801c062:	b2da      	uxtb	r2, r3
 801c064:	68fb      	ldr	r3, [r7, #12]
 801c066:	731a      	strb	r2, [r3, #12]

	return _init(sensor_id);
 801c068:	68fb      	ldr	r3, [r7, #12]
 801c06a:	681b      	ldr	r3, [r3, #0]
 801c06c:	681b      	ldr	r3, [r3, #0]
 801c06e:	6839      	ldr	r1, [r7, #0]
 801c070:	68f8      	ldr	r0, [r7, #12]
 801c072:	4798      	blx	r3
 801c074:	4603      	mov	r3, r0
}
 801c076:	4618      	mov	r0, r3
 801c078:	3710      	adds	r7, #16
 801c07a:	46bd      	mov	sp, r7
 801c07c:	bd80      	pop	{r7, pc}

0801c07e <_ZN15Adafruit_AS73415_initEl>:

/*!  @brief Initializer for post i2c/spi init
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_AS7341::_init(int32_t sensor_id) {
 801c07e:	b580      	push	{r7, lr}
 801c080:	b082      	sub	sp, #8
 801c082:	af00      	add	r7, sp, #0
 801c084:	6078      	str	r0, [r7, #4]
 801c086:	6039      	str	r1, [r7, #0]

	// make sure we're talking to the right chip
	if ((readRegisterByte(AS7341_WHOAMI) & 0xFC) != (AS7341_CHIP_ID << 2)) {
 801c088:	2192      	movs	r1, #146	; 0x92
 801c08a:	6878      	ldr	r0, [r7, #4]
 801c08c:	f000 fc7f 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c090:	4603      	mov	r3, r0
 801c092:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 801c096:	2b24      	cmp	r3, #36	; 0x24
 801c098:	bf14      	ite	ne
 801c09a:	2301      	movne	r3, #1
 801c09c:	2300      	moveq	r3, #0
 801c09e:	b2db      	uxtb	r3, r3
 801c0a0:	2b00      	cmp	r3, #0
 801c0a2:	d001      	beq.n	801c0a8 <_ZN15Adafruit_AS73415_initEl+0x2a>
		return false;
 801c0a4:	2300      	movs	r3, #0
 801c0a6:	e004      	b.n	801c0b2 <_ZN15Adafruit_AS73415_initEl+0x34>
	}

	powerEnable(true);
 801c0a8:	2101      	movs	r1, #1
 801c0aa:	6878      	ldr	r0, [r7, #4]
 801c0ac:	f000 f8c1 	bl	801c232 <_ZN15Adafruit_AS734111powerEnableEb>
	return true;
 801c0b0:	2301      	movs	r3, #1
}
 801c0b2:	4618      	mov	r0, r3
 801c0b4:	3708      	adds	r7, #8
 801c0b6:	46bd      	mov	sp, r7
 801c0b8:	bd80      	pop	{r7, pc}

0801c0ba <_ZN15Adafruit_AS734122getFlickerDetectStatusEv>:
/**
 * @brief Returns the flicker detection status
 *
 * @return int8_t
 */
int8_t Adafruit_AS7341::getFlickerDetectStatus(void) {
 801c0ba:	b580      	push	{r7, lr}
 801c0bc:	b082      	sub	sp, #8
 801c0be:	af00      	add	r7, sp, #0
 801c0c0:	6078      	str	r0, [r7, #4]
	return (int8_t) readRegisterByte(AS7341_FD_STATUS);
 801c0c2:	21db      	movs	r1, #219	; 0xdb
 801c0c4:	6878      	ldr	r0, [r7, #4]
 801c0c6:	f000 fc62 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c0ca:	4603      	mov	r3, r0
 801c0cc:	b25b      	sxtb	r3, r3
}
 801c0ce:	4618      	mov	r0, r3
 801c0d0:	3708      	adds	r7, #8
 801c0d2:	46bd      	mov	sp, r7
 801c0d4:	bd80      	pop	{r7, pc}

0801c0d6 <_ZN15Adafruit_AS734112startReadingEv>:
 * @brief starts the process of getting readings from all channels without using
 * delays
 *
 * @return true: success false: failure (a bit arbitrary)
 */
bool Adafruit_AS7341::startReading(void) {
 801c0d6:	b580      	push	{r7, lr}
 801c0d8:	b082      	sub	sp, #8
 801c0da:	af00      	add	r7, sp, #0
 801c0dc:	6078      	str	r0, [r7, #4]
	_readingState = AS7341_WAITING_START; // Start the measurement please
 801c0de:	687b      	ldr	r3, [r7, #4]
 801c0e0:	2200      	movs	r2, #0
 801c0e2:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	checkReadingProgress();               // Call the check function to start it
 801c0e6:	6878      	ldr	r0, [r7, #4]
 801c0e8:	f000 f805 	bl	801c0f6 <_ZN15Adafruit_AS734120checkReadingProgressEv>
	return true;
 801c0ec:	2301      	movs	r3, #1
}
 801c0ee:	4618      	mov	r0, r3
 801c0f0:	3708      	adds	r7, #8
 801c0f2:	46bd      	mov	sp, r7
 801c0f4:	bd80      	pop	{r7, pc}

0801c0f6 <_ZN15Adafruit_AS734120checkReadingProgressEv>:
 * startReading() to initialise the process Need to call getAllChannels() to
 * transfer the data into an external buffer
 *
 * @return true: reading is complete false: reading is incomplete (or failed)
 */
bool Adafruit_AS7341::checkReadingProgress() {
 801c0f6:	b580      	push	{r7, lr}
 801c0f8:	b082      	sub	sp, #8
 801c0fa:	af00      	add	r7, sp, #0
 801c0fc:	6078      	str	r0, [r7, #4]
	if (_readingState == AS7341_WAITING_START) {
 801c0fe:	687b      	ldr	r3, [r7, #4]
 801c100:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 801c104:	2b00      	cmp	r3, #0
 801c106:	d10d      	bne.n	801c124 <_ZN15Adafruit_AS734120checkReadingProgressEv+0x2e>
		setSMUXLowChannels(true);        // Configure SMUX to read low channels
 801c108:	2101      	movs	r1, #1
 801c10a:	6878      	ldr	r0, [r7, #4]
 801c10c:	f000 f872 	bl	801c1f4 <_ZN15Adafruit_AS734118setSMUXLowChannelsEb>
		enableSpectralMeasurement(true); // Start integration
 801c110:	2101      	movs	r1, #1
 801c112:	6878      	ldr	r0, [r7, #4]
 801c114:	f000 f8b8 	bl	801c288 <_ZN15Adafruit_AS734125enableSpectralMeasurementEb>
		_readingState = AS7341_WAITING_LOW;
 801c118:	687b      	ldr	r3, [r7, #4]
 801c11a:	2201      	movs	r2, #1
 801c11c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		return false;
 801c120:	2300      	movs	r3, #0
 801c122:	e043      	b.n	801c1ac <_ZN15Adafruit_AS734120checkReadingProgressEv+0xb6>
	}

	if (!getIsDataReady() || _readingState == AS7341_WAITING_DONE)
 801c124:	6878      	ldr	r0, [r7, #4]
 801c126:	f000 f935 	bl	801c394 <_ZN15Adafruit_AS734114getIsDataReadyEv>
 801c12a:	4603      	mov	r3, r0
 801c12c:	f083 0301 	eor.w	r3, r3, #1
 801c130:	b2db      	uxtb	r3, r3
 801c132:	2b00      	cmp	r3, #0
 801c134:	d104      	bne.n	801c140 <_ZN15Adafruit_AS734120checkReadingProgressEv+0x4a>
 801c136:	687b      	ldr	r3, [r7, #4]
 801c138:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 801c13c:	2b03      	cmp	r3, #3
 801c13e:	d101      	bne.n	801c144 <_ZN15Adafruit_AS734120checkReadingProgressEv+0x4e>
 801c140:	2301      	movs	r3, #1
 801c142:	e000      	b.n	801c146 <_ZN15Adafruit_AS734120checkReadingProgressEv+0x50>
 801c144:	2300      	movs	r3, #0
 801c146:	2b00      	cmp	r3, #0
 801c148:	d001      	beq.n	801c14e <_ZN15Adafruit_AS734120checkReadingProgressEv+0x58>
		return false;
 801c14a:	2300      	movs	r3, #0
 801c14c:	e02e      	b.n	801c1ac <_ZN15Adafruit_AS734120checkReadingProgressEv+0xb6>

	if (_readingState == AS7341_WAITING_LOW) // Check of getIsDataRead() is already done
 801c14e:	687b      	ldr	r3, [r7, #4]
 801c150:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 801c154:	2b01      	cmp	r3, #1
 801c156:	d115      	bne.n	801c184 <_ZN15Adafruit_AS734120checkReadingProgressEv+0x8e>
			{
		readRegister(AS7341_CH0_DATA_L, (uint8_t*) _channel_readings, 12);
 801c158:	687b      	ldr	r3, [r7, #4]
 801c15a:	f103 020e 	add.w	r2, r3, #14
 801c15e:	230c      	movs	r3, #12
 801c160:	2195      	movs	r1, #149	; 0x95
 801c162:	6878      	ldr	r0, [r7, #4]
 801c164:	f000 fb66 	bl	801c834 <_ZN15Adafruit_AS734112readRegisterEtPht>

		setSMUXLowChannels(false);       // Configure SMUX to read high channels
 801c168:	2100      	movs	r1, #0
 801c16a:	6878      	ldr	r0, [r7, #4]
 801c16c:	f000 f842 	bl	801c1f4 <_ZN15Adafruit_AS734118setSMUXLowChannelsEb>
		enableSpectralMeasurement(true); // Start integration
 801c170:	2101      	movs	r1, #1
 801c172:	6878      	ldr	r0, [r7, #4]
 801c174:	f000 f888 	bl	801c288 <_ZN15Adafruit_AS734125enableSpectralMeasurementEb>
		_readingState = AS7341_WAITING_HIGH;
 801c178:	687b      	ldr	r3, [r7, #4]
 801c17a:	2202      	movs	r2, #2
 801c17c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		return false;
 801c180:	2300      	movs	r3, #0
 801c182:	e013      	b.n	801c1ac <_ZN15Adafruit_AS734120checkReadingProgressEv+0xb6>
	}

	if (_readingState == AS7341_WAITING_HIGH) // Check of getIsDataRead() is already done
 801c184:	687b      	ldr	r3, [r7, #4]
 801c186:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 801c18a:	2b02      	cmp	r3, #2
 801c18c:	d10d      	bne.n	801c1aa <_ZN15Adafruit_AS734120checkReadingProgressEv+0xb4>
			{
		_readingState = AS7341_WAITING_DONE;
 801c18e:	687b      	ldr	r3, [r7, #4]
 801c190:	2203      	movs	r2, #3
 801c192:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		readRegister(AS7341_CH0_DATA_L, (uint8_t*) &_channel_readings[6], 12);
 801c196:	687b      	ldr	r3, [r7, #4]
 801c198:	f103 021a 	add.w	r2, r3, #26
 801c19c:	230c      	movs	r3, #12
 801c19e:	2195      	movs	r1, #149	; 0x95
 801c1a0:	6878      	ldr	r0, [r7, #4]
 801c1a2:	f000 fb47 	bl	801c834 <_ZN15Adafruit_AS734112readRegisterEtPht>
		return true;
 801c1a6:	2301      	movs	r3, #1
 801c1a8:	e000      	b.n	801c1ac <_ZN15Adafruit_AS734120checkReadingProgressEv+0xb6>
	}

	return false;
 801c1aa:	2300      	movs	r3, #0
}
 801c1ac:	4618      	mov	r0, r3
 801c1ae:	3708      	adds	r7, #8
 801c1b0:	46bd      	mov	sp, r7
 801c1b2:	bd80      	pop	{r7, pc}

0801c1b4 <_ZN15Adafruit_AS734114getAllChannelsEPt>:
 * @param readings_buffer Pointer to a buffer of length 12 (THERE IS NO ERROR
 * CHECKING, YE BE WARNED!)
 *
 * @return true: success false: failure
 */
bool Adafruit_AS7341::getAllChannels(uint16_t *readings_buffer) {
 801c1b4:	b480      	push	{r7}
 801c1b6:	b085      	sub	sp, #20
 801c1b8:	af00      	add	r7, sp, #0
 801c1ba:	6078      	str	r0, [r7, #4]
 801c1bc:	6039      	str	r1, [r7, #0]
	for (int i = 0; i < 12; i++)
 801c1be:	2300      	movs	r3, #0
 801c1c0:	60fb      	str	r3, [r7, #12]
 801c1c2:	68fb      	ldr	r3, [r7, #12]
 801c1c4:	2b0b      	cmp	r3, #11
 801c1c6:	dc0e      	bgt.n	801c1e6 <_ZN15Adafruit_AS734114getAllChannelsEPt+0x32>
		readings_buffer[i] = _channel_readings[i];
 801c1c8:	68fb      	ldr	r3, [r7, #12]
 801c1ca:	005b      	lsls	r3, r3, #1
 801c1cc:	683a      	ldr	r2, [r7, #0]
 801c1ce:	441a      	add	r2, r3
 801c1d0:	6879      	ldr	r1, [r7, #4]
 801c1d2:	68fb      	ldr	r3, [r7, #12]
 801c1d4:	3304      	adds	r3, #4
 801c1d6:	005b      	lsls	r3, r3, #1
 801c1d8:	440b      	add	r3, r1
 801c1da:	88db      	ldrh	r3, [r3, #6]
 801c1dc:	8013      	strh	r3, [r2, #0]
	for (int i = 0; i < 12; i++)
 801c1de:	68fb      	ldr	r3, [r7, #12]
 801c1e0:	3301      	adds	r3, #1
 801c1e2:	60fb      	str	r3, [r7, #12]
 801c1e4:	e7ed      	b.n	801c1c2 <_ZN15Adafruit_AS734114getAllChannelsEPt+0xe>
	return true;
 801c1e6:	2301      	movs	r3, #1
}
 801c1e8:	4618      	mov	r0, r3
 801c1ea:	3714      	adds	r7, #20
 801c1ec:	46bd      	mov	sp, r7
 801c1ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c1f2:	4770      	bx	lr

0801c1f4 <_ZN15Adafruit_AS734118setSMUXLowChannelsEb>:
 */
bool Adafruit_AS7341::readAllChannels(void) {
	return readAllChannels(_channel_readings);
}

void Adafruit_AS7341::setSMUXLowChannels(bool f1_f4) {
 801c1f4:	b580      	push	{r7, lr}
 801c1f6:	b082      	sub	sp, #8
 801c1f8:	af00      	add	r7, sp, #0
 801c1fa:	6078      	str	r0, [r7, #4]
 801c1fc:	460b      	mov	r3, r1
 801c1fe:	70fb      	strb	r3, [r7, #3]
	enableSpectralMeasurement(false);
 801c200:	2100      	movs	r1, #0
 801c202:	6878      	ldr	r0, [r7, #4]
 801c204:	f000 f840 	bl	801c288 <_ZN15Adafruit_AS734125enableSpectralMeasurementEb>
	setSMUXCommand(AS7341_SMUX_CMD_WRITE);
 801c208:	2102      	movs	r1, #2
 801c20a:	6878      	ldr	r0, [r7, #4]
 801c20c:	f000 f8af 	bl	801c36e <_ZN15Adafruit_AS734114setSMUXCommandE17as7341_smux_cmd_t>
	if (f1_f4) {
 801c210:	78fb      	ldrb	r3, [r7, #3]
 801c212:	2b00      	cmp	r3, #0
 801c214:	d003      	beq.n	801c21e <_ZN15Adafruit_AS734118setSMUXLowChannelsEb+0x2a>
		setup_F1F4_Clear_NIR();
 801c216:	6878      	ldr	r0, [r7, #4]
 801c218:	f000 f8cf 	bl	801c3ba <_ZN15Adafruit_AS734120setup_F1F4_Clear_NIREv>
 801c21c:	e002      	b.n	801c224 <_ZN15Adafruit_AS734118setSMUXLowChannelsEb+0x30>
	} else {
		setup_F5F8_Clear_NIR();
 801c21e:	6878      	ldr	r0, [r7, #4]
 801c220:	f000 f937 	bl	801c492 <_ZN15Adafruit_AS734120setup_F5F8_Clear_NIREv>
	}
	enableSMUX();
 801c224:	6878      	ldr	r0, [r7, #4]
 801c226:	f000 f84f 	bl	801c2c8 <_ZN15Adafruit_AS734110enableSMUXEv>
}
 801c22a:	bf00      	nop
 801c22c:	3708      	adds	r7, #8
 801c22e:	46bd      	mov	sp, r7
 801c230:	bd80      	pop	{r7, pc}

0801c232 <_ZN15Adafruit_AS734111powerEnableEb>:
/**
 * @brief Sets the power state of the sensor
 *
 * @param enable_power true: on false: off
 */
void Adafruit_AS7341::powerEnable(bool enable_power) {
 801c232:	b580      	push	{r7, lr}
 801c234:	b084      	sub	sp, #16
 801c236:	af00      	add	r7, sp, #0
 801c238:	6078      	str	r0, [r7, #4]
 801c23a:	460b      	mov	r3, r1
 801c23c:	70fb      	strb	r3, [r7, #3]
	uint8_t enable_reg = readRegisterByte(AS7341_ENABLE);
 801c23e:	2180      	movs	r1, #128	; 0x80
 801c240:	6878      	ldr	r0, [r7, #4]
 801c242:	f000 fba4 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c246:	4603      	mov	r3, r0
 801c248:	73fb      	strb	r3, [r7, #15]
	enable_reg = modifyBitInByte(enable_reg, (uint8_t) enable_power, 0);
 801c24a:	78fa      	ldrb	r2, [r7, #3]
 801c24c:	7bf9      	ldrb	r1, [r7, #15]
 801c24e:	2300      	movs	r3, #0
 801c250:	6878      	ldr	r0, [r7, #4]
 801c252:	f000 fac7 	bl	801c7e4 <_ZN15Adafruit_AS734115modifyBitInByteEhhh>
 801c256:	4603      	mov	r3, r0
 801c258:	73fb      	strb	r3, [r7, #15]
	writeRegisterByte(AS7341_ENABLE, enable_reg);
 801c25a:	7bfb      	ldrb	r3, [r7, #15]
 801c25c:	461a      	mov	r2, r3
 801c25e:	2180      	movs	r1, #128	; 0x80
 801c260:	6878      	ldr	r0, [r7, #4]
 801c262:	f000 fa98 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
}
 801c266:	bf00      	nop
 801c268:	3710      	adds	r7, #16
 801c26a:	46bd      	mov	sp, r7
 801c26c:	bd80      	pop	{r7, pc}

0801c26e <_ZN15Adafruit_AS734110disableAllEv>:

/**
 * @brief Disable Spectral reading, flicker detection, and power
 *
 * */
void Adafruit_AS7341::disableAll(void) {
 801c26e:	b580      	push	{r7, lr}
 801c270:	b082      	sub	sp, #8
 801c272:	af00      	add	r7, sp, #0
 801c274:	6078      	str	r0, [r7, #4]
	writeRegisterByte(AS7341_ENABLE, 0);
 801c276:	2200      	movs	r2, #0
 801c278:	2180      	movs	r1, #128	; 0x80
 801c27a:	6878      	ldr	r0, [r7, #4]
 801c27c:	f000 fa8b 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
}
 801c280:	bf00      	nop
 801c282:	3708      	adds	r7, #8
 801c284:	46bd      	mov	sp, r7
 801c286:	bd80      	pop	{r7, pc}

0801c288 <_ZN15Adafruit_AS734125enableSpectralMeasurementEb>:
 * @brief Enables measurement of spectral data
 *
 * @param enable_measurement true: enabled false: disabled
 * @return true: success false: failure
 */
bool Adafruit_AS7341::enableSpectralMeasurement(bool enable_measurement) {
 801c288:	b580      	push	{r7, lr}
 801c28a:	b084      	sub	sp, #16
 801c28c:	af00      	add	r7, sp, #0
 801c28e:	6078      	str	r0, [r7, #4]
 801c290:	460b      	mov	r3, r1
 801c292:	70fb      	strb	r3, [r7, #3]

	uint8_t enable_reg = readRegisterByte(AS7341_ENABLE);
 801c294:	2180      	movs	r1, #128	; 0x80
 801c296:	6878      	ldr	r0, [r7, #4]
 801c298:	f000 fb79 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c29c:	4603      	mov	r3, r0
 801c29e:	73fb      	strb	r3, [r7, #15]
	enable_reg = modifyBitInByte(enable_reg, (uint8_t) enable_measurement, 1);
 801c2a0:	78fa      	ldrb	r2, [r7, #3]
 801c2a2:	7bf9      	ldrb	r1, [r7, #15]
 801c2a4:	2301      	movs	r3, #1
 801c2a6:	6878      	ldr	r0, [r7, #4]
 801c2a8:	f000 fa9c 	bl	801c7e4 <_ZN15Adafruit_AS734115modifyBitInByteEhhh>
 801c2ac:	4603      	mov	r3, r0
 801c2ae:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(AS7341_ENABLE, enable_reg);
 801c2b0:	7bfb      	ldrb	r3, [r7, #15]
 801c2b2:	461a      	mov	r2, r3
 801c2b4:	2180      	movs	r1, #128	; 0x80
 801c2b6:	6878      	ldr	r0, [r7, #4]
 801c2b8:	f000 fa6d 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
 801c2bc:	4603      	mov	r3, r0
}
 801c2be:	4618      	mov	r0, r3
 801c2c0:	3710      	adds	r7, #16
 801c2c2:	46bd      	mov	sp, r7
 801c2c4:	bd80      	pop	{r7, pc}
	...

0801c2c8 <_ZN15Adafruit_AS734110enableSMUXEv>:

bool Adafruit_AS7341::enableSMUX(void) {
 801c2c8:	b580      	push	{r7, lr}
 801c2ca:	b086      	sub	sp, #24
 801c2cc:	af00      	add	r7, sp, #0
 801c2ce:	6078      	str	r0, [r7, #4]
	bool success = modifyRegisterBit(AS7341_ENABLE, true, 4);
 801c2d0:	2304      	movs	r3, #4
 801c2d2:	2201      	movs	r2, #1
 801c2d4:	2180      	movs	r1, #128	; 0x80
 801c2d6:	6878      	ldr	r0, [r7, #4]
 801c2d8:	f000 faee 	bl	801c8b8 <_ZN15Adafruit_AS734117modifyRegisterBitEtbh>
 801c2dc:	4603      	mov	r3, r0
 801c2de:	74fb      	strb	r3, [r7, #19]

	int timeOut = 1000; // Arbitrary value, but if it takes 1000 milliseconds then
 801c2e0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 801c2e4:	60fb      	str	r3, [r7, #12]
											// something is wrong
	int count = 0;
 801c2e6:	2300      	movs	r3, #0
 801c2e8:	617b      	str	r3, [r7, #20]
	while (!checkRegisterBit(AS7341_ENABLE, 4) && count < timeOut) {
 801c2ea:	2204      	movs	r2, #4
 801c2ec:	2180      	movs	r1, #128	; 0x80
 801c2ee:	6878      	ldr	r0, [r7, #4]
 801c2f0:	f000 fac8 	bl	801c884 <_ZN15Adafruit_AS734116checkRegisterBitEth>
 801c2f4:	4603      	mov	r3, r0
 801c2f6:	2b00      	cmp	r3, #0
 801c2f8:	d105      	bne.n	801c306 <_ZN15Adafruit_AS734110enableSMUXEv+0x3e>
 801c2fa:	697a      	ldr	r2, [r7, #20]
 801c2fc:	68fb      	ldr	r3, [r7, #12]
 801c2fe:	429a      	cmp	r2, r3
 801c300:	da01      	bge.n	801c306 <_ZN15Adafruit_AS734110enableSMUXEv+0x3e>
 801c302:	2301      	movs	r3, #1
 801c304:	e000      	b.n	801c308 <_ZN15Adafruit_AS734110enableSMUXEv+0x40>
 801c306:	2300      	movs	r3, #0
 801c308:	2b00      	cmp	r3, #0
 801c30a:	d012      	beq.n	801c332 <_ZN15Adafruit_AS734110enableSMUXEv+0x6a>
		osSemaphoreRelease(messageI2C1_LockHandle);
 801c30c:	4b0e      	ldr	r3, [pc, #56]	; (801c348 <_ZN15Adafruit_AS734110enableSMUXEv+0x80>)
 801c30e:	681b      	ldr	r3, [r3, #0]
 801c310:	4618      	mov	r0, r3
 801c312:	f006 fd63 	bl	8022ddc <osSemaphoreRelease>
		osDelay(1); // SF 2020-08-12 Does this really need to be so long?
 801c316:	2001      	movs	r0, #1
 801c318:	f006 fa67 	bl	80227ea <osDelay>
		osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 801c31c:	4b0a      	ldr	r3, [pc, #40]	; (801c348 <_ZN15Adafruit_AS734110enableSMUXEv+0x80>)
 801c31e:	681b      	ldr	r3, [r3, #0]
 801c320:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801c324:	4618      	mov	r0, r3
 801c326:	f006 fd07 	bl	8022d38 <osSemaphoreAcquire>
		count++;
 801c32a:	697b      	ldr	r3, [r7, #20]
 801c32c:	3301      	adds	r3, #1
 801c32e:	617b      	str	r3, [r7, #20]
	while (!checkRegisterBit(AS7341_ENABLE, 4) && count < timeOut) {
 801c330:	e7db      	b.n	801c2ea <_ZN15Adafruit_AS734110enableSMUXEv+0x22>
	}
	if (count >= timeOut)
 801c332:	697a      	ldr	r2, [r7, #20]
 801c334:	68fb      	ldr	r3, [r7, #12]
 801c336:	429a      	cmp	r2, r3
 801c338:	db01      	blt.n	801c33e <_ZN15Adafruit_AS734110enableSMUXEv+0x76>
		return false;
 801c33a:	2300      	movs	r3, #0
 801c33c:	e000      	b.n	801c340 <_ZN15Adafruit_AS734110enableSMUXEv+0x78>
	else
		return success;
 801c33e:	7cfb      	ldrb	r3, [r7, #19]
}
 801c340:	4618      	mov	r0, r3
 801c342:	3718      	adds	r7, #24
 801c344:	46bd      	mov	sp, r7
 801c346:	bd80      	pop	{r7, pc}
 801c348:	200003dc 	.word	0x200003dc

0801c34c <_ZN15Adafruit_AS734122enableFlickerDetectionEb>:

bool Adafruit_AS7341::enableFlickerDetection(bool enable_fd) {
 801c34c:	b580      	push	{r7, lr}
 801c34e:	b082      	sub	sp, #8
 801c350:	af00      	add	r7, sp, #0
 801c352:	6078      	str	r0, [r7, #4]
 801c354:	460b      	mov	r3, r1
 801c356:	70fb      	strb	r3, [r7, #3]
	return modifyRegisterBit(AS7341_ENABLE, enable_fd, 6);
 801c358:	78fa      	ldrb	r2, [r7, #3]
 801c35a:	2306      	movs	r3, #6
 801c35c:	2180      	movs	r1, #128	; 0x80
 801c35e:	6878      	ldr	r0, [r7, #4]
 801c360:	f000 faaa 	bl	801c8b8 <_ZN15Adafruit_AS734117modifyRegisterBitEtbh>
 801c364:	4603      	mov	r3, r0
}
 801c366:	4618      	mov	r0, r3
 801c368:	3708      	adds	r7, #8
 801c36a:	46bd      	mov	sp, r7
 801c36c:	bd80      	pop	{r7, pc}

0801c36e <_ZN15Adafruit_AS734114setSMUXCommandE17as7341_smux_cmd_t>:
 */
bool Adafruit_AS7341::setGPIOValue(bool gpio_high) {
	return modifyRegisterBit(AS7341_GPIO2, gpio_high, 1);
}

bool Adafruit_AS7341::setSMUXCommand(as7341_smux_cmd_t command) {
 801c36e:	b580      	push	{r7, lr}
 801c370:	b084      	sub	sp, #16
 801c372:	af02      	add	r7, sp, #8
 801c374:	6078      	str	r0, [r7, #4]
 801c376:	460b      	mov	r3, r1
 801c378:	70fb      	strb	r3, [r7, #3]

	return modifyRegisterMultipleBit(AS7341_CFG6, command, 3, 2);
 801c37a:	78fa      	ldrb	r2, [r7, #3]
 801c37c:	2302      	movs	r3, #2
 801c37e:	9300      	str	r3, [sp, #0]
 801c380:	2303      	movs	r3, #3
 801c382:	21af      	movs	r1, #175	; 0xaf
 801c384:	6878      	ldr	r0, [r7, #4]
 801c386:	f000 fabf 	bl	801c908 <_ZN15Adafruit_AS734125modifyRegisterMultipleBitEthhh>
 801c38a:	4603      	mov	r3, r0
}
 801c38c:	4618      	mov	r0, r3
 801c38e:	3708      	adds	r7, #8
 801c390:	46bd      	mov	sp, r7
 801c392:	bd80      	pop	{r7, pc}

0801c394 <_ZN15Adafruit_AS734114getIsDataReadyEv>:
/**
 * @brief
 *
 * @return true: success false: failure
 */
bool Adafruit_AS7341::getIsDataReady() {
 801c394:	b580      	push	{r7, lr}
 801c396:	b082      	sub	sp, #8
 801c398:	af00      	add	r7, sp, #0
 801c39a:	6078      	str	r0, [r7, #4]
	return checkRegisterBit(AS7341_STATUS2, 6);
 801c39c:	2206      	movs	r2, #6
 801c39e:	21a3      	movs	r1, #163	; 0xa3
 801c3a0:	6878      	ldr	r0, [r7, #4]
 801c3a2:	f000 fa6f 	bl	801c884 <_ZN15Adafruit_AS734116checkRegisterBitEth>
 801c3a6:	4603      	mov	r3, r0
 801c3a8:	2b00      	cmp	r3, #0
 801c3aa:	bf14      	ite	ne
 801c3ac:	2301      	movne	r3, #1
 801c3ae:	2300      	moveq	r3, #0
 801c3b0:	b2db      	uxtb	r3, r3
}
 801c3b2:	4618      	mov	r0, r3
 801c3b4:	3708      	adds	r7, #8
 801c3b6:	46bd      	mov	sp, r7
 801c3b8:	bd80      	pop	{r7, pc}

0801c3ba <_ZN15Adafruit_AS734120setup_F1F4_Clear_NIREv>:

/**
 * @brief Configure SMUX for sensors F1-4, Clear and NIR
 *
 */
void Adafruit_AS7341::setup_F1F4_Clear_NIR() {
 801c3ba:	b580      	push	{r7, lr}
 801c3bc:	b082      	sub	sp, #8
 801c3be:	af00      	add	r7, sp, #0
 801c3c0:	6078      	str	r0, [r7, #4]
	// SMUX Config for F1,F2,F3,F4,NIR,Clear
	writeRegisterByte(uint8_t(0x00), uint8_t(0x30)); // F3 left set to ADC2
 801c3c2:	2230      	movs	r2, #48	; 0x30
 801c3c4:	2100      	movs	r1, #0
 801c3c6:	6878      	ldr	r0, [r7, #4]
 801c3c8:	f000 f9e5 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x01), uint8_t(0x01)); // F1 left set to ADC0
 801c3cc:	2201      	movs	r2, #1
 801c3ce:	2101      	movs	r1, #1
 801c3d0:	6878      	ldr	r0, [r7, #4]
 801c3d2:	f000 f9e0 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x02), uint8_t(0x00)); // Reserved or disabled
 801c3d6:	2200      	movs	r2, #0
 801c3d8:	2102      	movs	r1, #2
 801c3da:	6878      	ldr	r0, [r7, #4]
 801c3dc:	f000 f9db 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x03), uint8_t(0x00)); // F8 left disabled
 801c3e0:	2200      	movs	r2, #0
 801c3e2:	2103      	movs	r1, #3
 801c3e4:	6878      	ldr	r0, [r7, #4]
 801c3e6:	f000 f9d6 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x04), uint8_t(0x00)); // F6 left disabled
 801c3ea:	2200      	movs	r2, #0
 801c3ec:	2104      	movs	r1, #4
 801c3ee:	6878      	ldr	r0, [r7, #4]
 801c3f0:	f000 f9d1 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x05), uint8_t(0x42)); // F4 left connected to ADC3/f2 left connected to ADC1
 801c3f4:	2242      	movs	r2, #66	; 0x42
 801c3f6:	2105      	movs	r1, #5
 801c3f8:	6878      	ldr	r0, [r7, #4]
 801c3fa:	f000 f9cc 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x06), uint8_t(0x00)); // F5 left disbled
 801c3fe:	2200      	movs	r2, #0
 801c400:	2106      	movs	r1, #6
 801c402:	6878      	ldr	r0, [r7, #4]
 801c404:	f000 f9c7 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x07), uint8_t(0x00)); // F7 left disbled
 801c408:	2200      	movs	r2, #0
 801c40a:	2107      	movs	r1, #7
 801c40c:	6878      	ldr	r0, [r7, #4]
 801c40e:	f000 f9c2 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x08), uint8_t(0x50)); // CLEAR connected to ADC4
 801c412:	2250      	movs	r2, #80	; 0x50
 801c414:	2108      	movs	r1, #8
 801c416:	6878      	ldr	r0, [r7, #4]
 801c418:	f000 f9bd 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x09), uint8_t(0x00)); // F5 right disabled
 801c41c:	2200      	movs	r2, #0
 801c41e:	2109      	movs	r1, #9
 801c420:	6878      	ldr	r0, [r7, #4]
 801c422:	f000 f9b8 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0A), uint8_t(0x00)); // F7 right disabled
 801c426:	2200      	movs	r2, #0
 801c428:	210a      	movs	r1, #10
 801c42a:	6878      	ldr	r0, [r7, #4]
 801c42c:	f000 f9b3 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0B), uint8_t(0x00)); // Reserved or disabled
 801c430:	2200      	movs	r2, #0
 801c432:	210b      	movs	r1, #11
 801c434:	6878      	ldr	r0, [r7, #4]
 801c436:	f000 f9ae 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0C), uint8_t(0x20)); // F2 right connected to ADC1
 801c43a:	2220      	movs	r2, #32
 801c43c:	210c      	movs	r1, #12
 801c43e:	6878      	ldr	r0, [r7, #4]
 801c440:	f000 f9a9 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0D), uint8_t(0x04)); // F4 right connected to ADC3
 801c444:	2204      	movs	r2, #4
 801c446:	210d      	movs	r1, #13
 801c448:	6878      	ldr	r0, [r7, #4]
 801c44a:	f000 f9a4 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0E), uint8_t(0x00)); // F6/F8 right disabled
 801c44e:	2200      	movs	r2, #0
 801c450:	210e      	movs	r1, #14
 801c452:	6878      	ldr	r0, [r7, #4]
 801c454:	f000 f99f 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0F), uint8_t(0x30)); // F3 right connected to AD2
 801c458:	2230      	movs	r2, #48	; 0x30
 801c45a:	210f      	movs	r1, #15
 801c45c:	6878      	ldr	r0, [r7, #4]
 801c45e:	f000 f99a 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x10), uint8_t(0x01)); // F1 right connected to AD0
 801c462:	2201      	movs	r2, #1
 801c464:	2110      	movs	r1, #16
 801c466:	6878      	ldr	r0, [r7, #4]
 801c468:	f000 f995 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x11), uint8_t(0x50)); // CLEAR right connected to AD4
 801c46c:	2250      	movs	r2, #80	; 0x50
 801c46e:	2111      	movs	r1, #17
 801c470:	6878      	ldr	r0, [r7, #4]
 801c472:	f000 f990 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x12), uint8_t(0x00)); // Reserved or disabled
 801c476:	2200      	movs	r2, #0
 801c478:	2112      	movs	r1, #18
 801c47a:	6878      	ldr	r0, [r7, #4]
 801c47c:	f000 f98b 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x13), uint8_t(0x06)); // NIR connected to ADC5
 801c480:	2206      	movs	r2, #6
 801c482:	2113      	movs	r1, #19
 801c484:	6878      	ldr	r0, [r7, #4]
 801c486:	f000 f986 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
}
 801c48a:	bf00      	nop
 801c48c:	3708      	adds	r7, #8
 801c48e:	46bd      	mov	sp, r7
 801c490:	bd80      	pop	{r7, pc}

0801c492 <_ZN15Adafruit_AS734120setup_F5F8_Clear_NIREv>:

/**
 * @brief Configure SMUX for sensors F5-8, Clear and NIR
 *
 */
void Adafruit_AS7341::setup_F5F8_Clear_NIR() {
 801c492:	b580      	push	{r7, lr}
 801c494:	b082      	sub	sp, #8
 801c496:	af00      	add	r7, sp, #0
 801c498:	6078      	str	r0, [r7, #4]
	// SMUX Config for F5,F6,F7,F8,NIR,Clear
	writeRegisterByte(uint8_t(0x00), uint8_t(0x00)); // F3 left disable
 801c49a:	2200      	movs	r2, #0
 801c49c:	2100      	movs	r1, #0
 801c49e:	6878      	ldr	r0, [r7, #4]
 801c4a0:	f000 f979 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x01), uint8_t(0x00)); // F1 left disable
 801c4a4:	2200      	movs	r2, #0
 801c4a6:	2101      	movs	r1, #1
 801c4a8:	6878      	ldr	r0, [r7, #4]
 801c4aa:	f000 f974 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x02), uint8_t(0x00)); // reserved/disable
 801c4ae:	2200      	movs	r2, #0
 801c4b0:	2102      	movs	r1, #2
 801c4b2:	6878      	ldr	r0, [r7, #4]
 801c4b4:	f000 f96f 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x03), uint8_t(0x40)); // F8 left connected to ADC3
 801c4b8:	2240      	movs	r2, #64	; 0x40
 801c4ba:	2103      	movs	r1, #3
 801c4bc:	6878      	ldr	r0, [r7, #4]
 801c4be:	f000 f96a 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x04), uint8_t(0x02)); // F6 left connected to ADC1
 801c4c2:	2202      	movs	r2, #2
 801c4c4:	2104      	movs	r1, #4
 801c4c6:	6878      	ldr	r0, [r7, #4]
 801c4c8:	f000 f965 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x05), uint8_t(0x00)); // F4/ F2 disabled
 801c4cc:	2200      	movs	r2, #0
 801c4ce:	2105      	movs	r1, #5
 801c4d0:	6878      	ldr	r0, [r7, #4]
 801c4d2:	f000 f960 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x06), uint8_t(0x10)); // F5 left connected to ADC0
 801c4d6:	2210      	movs	r2, #16
 801c4d8:	2106      	movs	r1, #6
 801c4da:	6878      	ldr	r0, [r7, #4]
 801c4dc:	f000 f95b 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x07), uint8_t(0x03)); // F7 left connected to ADC2
 801c4e0:	2203      	movs	r2, #3
 801c4e2:	2107      	movs	r1, #7
 801c4e4:	6878      	ldr	r0, [r7, #4]
 801c4e6:	f000 f956 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x08), uint8_t(0x50)); // CLEAR Connected to ADC4
 801c4ea:	2250      	movs	r2, #80	; 0x50
 801c4ec:	2108      	movs	r1, #8
 801c4ee:	6878      	ldr	r0, [r7, #4]
 801c4f0:	f000 f951 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x09), uint8_t(0x10)); // F5 right connected to ADC0
 801c4f4:	2210      	movs	r2, #16
 801c4f6:	2109      	movs	r1, #9
 801c4f8:	6878      	ldr	r0, [r7, #4]
 801c4fa:	f000 f94c 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0A), uint8_t(0x03)); // F7 right connected to ADC2
 801c4fe:	2203      	movs	r2, #3
 801c500:	210a      	movs	r1, #10
 801c502:	6878      	ldr	r0, [r7, #4]
 801c504:	f000 f947 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0B), uint8_t(0x00)); // Reserved or disabled
 801c508:	2200      	movs	r2, #0
 801c50a:	210b      	movs	r1, #11
 801c50c:	6878      	ldr	r0, [r7, #4]
 801c50e:	f000 f942 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0C), uint8_t(0x00)); // F2 right disabled
 801c512:	2200      	movs	r2, #0
 801c514:	210c      	movs	r1, #12
 801c516:	6878      	ldr	r0, [r7, #4]
 801c518:	f000 f93d 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0D), uint8_t(0x00)); // F4 right disabled
 801c51c:	2200      	movs	r2, #0
 801c51e:	210d      	movs	r1, #13
 801c520:	6878      	ldr	r0, [r7, #4]
 801c522:	f000 f938 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0E), uint8_t(0x24)); // F8 right connected to ADC2/ F6 right connected to ADC1
 801c526:	2224      	movs	r2, #36	; 0x24
 801c528:	210e      	movs	r1, #14
 801c52a:	6878      	ldr	r0, [r7, #4]
 801c52c:	f000 f933 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0F), uint8_t(0x00)); // F3 right disabled
 801c530:	2200      	movs	r2, #0
 801c532:	210f      	movs	r1, #15
 801c534:	6878      	ldr	r0, [r7, #4]
 801c536:	f000 f92e 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x10), uint8_t(0x00)); // F1 right disabled
 801c53a:	2200      	movs	r2, #0
 801c53c:	2110      	movs	r1, #16
 801c53e:	6878      	ldr	r0, [r7, #4]
 801c540:	f000 f929 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x11), uint8_t(0x50)); // CLEAR right connected to AD4
 801c544:	2250      	movs	r2, #80	; 0x50
 801c546:	2111      	movs	r1, #17
 801c548:	6878      	ldr	r0, [r7, #4]
 801c54a:	f000 f924 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x12), uint8_t(0x00)); // Reserved or disabled
 801c54e:	2200      	movs	r2, #0
 801c550:	2112      	movs	r1, #18
 801c552:	6878      	ldr	r0, [r7, #4]
 801c554:	f000 f91f 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x13), uint8_t(0x06)); // NIR connected to ADC5
 801c558:	2206      	movs	r2, #6
 801c55a:	2113      	movs	r1, #19
 801c55c:	6878      	ldr	r0, [r7, #4]
 801c55e:	f000 f91a 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
}
 801c562:	bf00      	nop
 801c564:	3708      	adds	r7, #8
 801c566:	46bd      	mov	sp, r7
 801c568:	bd80      	pop	{r7, pc}

0801c56a <_ZN15Adafruit_AS73418FDConfigEv>:

/**
 * @brief Configure SMUX for flicker detection
 *
 */
void Adafruit_AS7341::FDConfig() {
 801c56a:	b580      	push	{r7, lr}
 801c56c:	b082      	sub	sp, #8
 801c56e:	af00      	add	r7, sp, #0
 801c570:	6078      	str	r0, [r7, #4]
	// SMUX Config for Flicker- register (0x13)left set to ADC6 for flicker
	// detection
	writeRegisterByte(uint8_t(0x00), uint8_t(0x00)); // disabled
 801c572:	2200      	movs	r2, #0
 801c574:	2100      	movs	r1, #0
 801c576:	6878      	ldr	r0, [r7, #4]
 801c578:	f000 f90d 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x01), uint8_t(0x00)); // disabled
 801c57c:	2200      	movs	r2, #0
 801c57e:	2101      	movs	r1, #1
 801c580:	6878      	ldr	r0, [r7, #4]
 801c582:	f000 f908 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x02), uint8_t(0x00)); // reserved/disabled
 801c586:	2200      	movs	r2, #0
 801c588:	2102      	movs	r1, #2
 801c58a:	6878      	ldr	r0, [r7, #4]
 801c58c:	f000 f903 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x03), uint8_t(0x00)); // disabled
 801c590:	2200      	movs	r2, #0
 801c592:	2103      	movs	r1, #3
 801c594:	6878      	ldr	r0, [r7, #4]
 801c596:	f000 f8fe 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x04), uint8_t(0x00)); // disabled
 801c59a:	2200      	movs	r2, #0
 801c59c:	2104      	movs	r1, #4
 801c59e:	6878      	ldr	r0, [r7, #4]
 801c5a0:	f000 f8f9 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x05), uint8_t(0x00)); // disabled
 801c5a4:	2200      	movs	r2, #0
 801c5a6:	2105      	movs	r1, #5
 801c5a8:	6878      	ldr	r0, [r7, #4]
 801c5aa:	f000 f8f4 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x06), uint8_t(0x00)); // disabled
 801c5ae:	2200      	movs	r2, #0
 801c5b0:	2106      	movs	r1, #6
 801c5b2:	6878      	ldr	r0, [r7, #4]
 801c5b4:	f000 f8ef 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x07), uint8_t(0x00)); // disabled
 801c5b8:	2200      	movs	r2, #0
 801c5ba:	2107      	movs	r1, #7
 801c5bc:	6878      	ldr	r0, [r7, #4]
 801c5be:	f000 f8ea 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x08), uint8_t(0x00)); // disabled
 801c5c2:	2200      	movs	r2, #0
 801c5c4:	2108      	movs	r1, #8
 801c5c6:	6878      	ldr	r0, [r7, #4]
 801c5c8:	f000 f8e5 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x09), uint8_t(0x00)); // disabled
 801c5cc:	2200      	movs	r2, #0
 801c5ce:	2109      	movs	r1, #9
 801c5d0:	6878      	ldr	r0, [r7, #4]
 801c5d2:	f000 f8e0 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0A), uint8_t(0x00)); // disabled
 801c5d6:	2200      	movs	r2, #0
 801c5d8:	210a      	movs	r1, #10
 801c5da:	6878      	ldr	r0, [r7, #4]
 801c5dc:	f000 f8db 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0B), uint8_t(0x00)); // Reserved or disabled
 801c5e0:	2200      	movs	r2, #0
 801c5e2:	210b      	movs	r1, #11
 801c5e4:	6878      	ldr	r0, [r7, #4]
 801c5e6:	f000 f8d6 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0C), uint8_t(0x00)); // disabled
 801c5ea:	2200      	movs	r2, #0
 801c5ec:	210c      	movs	r1, #12
 801c5ee:	6878      	ldr	r0, [r7, #4]
 801c5f0:	f000 f8d1 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0D), uint8_t(0x00)); // disabled
 801c5f4:	2200      	movs	r2, #0
 801c5f6:	210d      	movs	r1, #13
 801c5f8:	6878      	ldr	r0, [r7, #4]
 801c5fa:	f000 f8cc 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0E), uint8_t(0x00)); // disabled
 801c5fe:	2200      	movs	r2, #0
 801c600:	210e      	movs	r1, #14
 801c602:	6878      	ldr	r0, [r7, #4]
 801c604:	f000 f8c7 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x0F), uint8_t(0x00)); // disabled
 801c608:	2200      	movs	r2, #0
 801c60a:	210f      	movs	r1, #15
 801c60c:	6878      	ldr	r0, [r7, #4]
 801c60e:	f000 f8c2 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x10), uint8_t(0x00)); // disabled
 801c612:	2200      	movs	r2, #0
 801c614:	2110      	movs	r1, #16
 801c616:	6878      	ldr	r0, [r7, #4]
 801c618:	f000 f8bd 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x11), uint8_t(0x00)); // disabled
 801c61c:	2200      	movs	r2, #0
 801c61e:	2111      	movs	r1, #17
 801c620:	6878      	ldr	r0, [r7, #4]
 801c622:	f000 f8b8 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x12), uint8_t(0x00)); // Reserved or disabled
 801c626:	2200      	movs	r2, #0
 801c628:	2112      	movs	r1, #18
 801c62a:	6878      	ldr	r0, [r7, #4]
 801c62c:	f000 f8b3 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
	writeRegisterByte(uint8_t(0x13), uint8_t(0x60)); // Flicker connected to ADC5 to left of 0x13
 801c630:	2260      	movs	r2, #96	; 0x60
 801c632:	2113      	movs	r1, #19
 801c634:	6878      	ldr	r0, [r7, #4]
 801c636:	f000 f8ae 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
}
 801c63a:	bf00      	nop
 801c63c:	3708      	adds	r7, #8
 801c63e:	46bd      	mov	sp, r7
 801c640:	bd80      	pop	{r7, pc}

0801c642 <_ZN15Adafruit_AS73418setATIMEEh>:
 * Total integration time will be `(ATIME + 1) * (ASTEP + 1) * 2.78S`
 *
 * @param atime_value The integration time step count
 * @return true: success false: failure
 */
bool Adafruit_AS7341::setATIME(uint8_t atime_value) {
 801c642:	b580      	push	{r7, lr}
 801c644:	b082      	sub	sp, #8
 801c646:	af00      	add	r7, sp, #0
 801c648:	6078      	str	r0, [r7, #4]
 801c64a:	460b      	mov	r3, r1
 801c64c:	70fb      	strb	r3, [r7, #3]
	return writeRegisterByte(AS7341_ATIME, atime_value);
 801c64e:	78fb      	ldrb	r3, [r7, #3]
 801c650:	461a      	mov	r2, r3
 801c652:	2181      	movs	r1, #129	; 0x81
 801c654:	6878      	ldr	r0, [r7, #4]
 801c656:	f000 f89e 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
 801c65a:	4603      	mov	r3, r0
}
 801c65c:	4618      	mov	r0, r3
 801c65e:	3708      	adds	r7, #8
 801c660:	46bd      	mov	sp, r7
 801c662:	bd80      	pop	{r7, pc}

0801c664 <_ZN15Adafruit_AS73418setASTEPEt>:
 *
 * @param astep_value Integration time step size in 2.78 microsecon increments
 * Step size is `(astep_value+1) * 2.78 uS`
 * @return true: success false: failure
 */
bool Adafruit_AS7341::setASTEP(uint16_t astep_value) {
 801c664:	b580      	push	{r7, lr}
 801c666:	b082      	sub	sp, #8
 801c668:	af00      	add	r7, sp, #0
 801c66a:	6078      	str	r0, [r7, #4]
 801c66c:	460b      	mov	r3, r1
 801c66e:	807b      	strh	r3, [r7, #2]
	return writeRegister(AS7341_ASTEP_L, (uint8_t*) &astep_value, 2);
 801c670:	1cba      	adds	r2, r7, #2
 801c672:	2302      	movs	r3, #2
 801c674:	21ca      	movs	r1, #202	; 0xca
 801c676:	6878      	ldr	r0, [r7, #4]
 801c678:	f000 f864 	bl	801c744 <_ZN15Adafruit_AS734113writeRegisterEhPht>
 801c67c:	4603      	mov	r3, r0
}
 801c67e:	4618      	mov	r0, r3
 801c680:	3708      	adds	r7, #8
 801c682:	46bd      	mov	sp, r7
 801c684:	bd80      	pop	{r7, pc}

0801c686 <_ZN15Adafruit_AS73417setGainE13as7341_gain_t>:
 * @brief Sets the ADC gain multiplier
 *
 * @param gain_value The gain amount. must be an `as7341_gain_t`
 * @return true: success false: failure
 */
bool Adafruit_AS7341::setGain(as7341_gain_t gain_value) {
 801c686:	b580      	push	{r7, lr}
 801c688:	b082      	sub	sp, #8
 801c68a:	af00      	add	r7, sp, #0
 801c68c:	6078      	str	r0, [r7, #4]
 801c68e:	460b      	mov	r3, r1
 801c690:	70fb      	strb	r3, [r7, #3]

	return writeRegisterByte(AS7341_CFG1, gain_value);
 801c692:	78fb      	ldrb	r3, [r7, #3]
 801c694:	461a      	mov	r2, r3
 801c696:	21aa      	movs	r1, #170	; 0xaa
 801c698:	6878      	ldr	r0, [r7, #4]
 801c69a:	f000 f87c 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
 801c69e:	4603      	mov	r3, r0
	// AGAIN bitfield is only[0:4] but the rest is empty
}
 801c6a0:	4618      	mov	r0, r3
 801c6a2:	3708      	adds	r7, #8
 801c6a4:	46bd      	mov	sp, r7
 801c6a6:	bd80      	pop	{r7, pc}

0801c6a8 <_ZN15Adafruit_AS734115detectFlickerHzEv>:
/**
 * @brief Detect a flickering light
 * @return The frequency of a detected flicker or 1 if a flicker of
 * unknown frequency is detected
 */
uint16_t Adafruit_AS7341::detectFlickerHz(void) {
 801c6a8:	b580      	push	{r7, lr}
 801c6aa:	b084      	sub	sp, #16
 801c6ac:	af00      	add	r7, sp, #0
 801c6ae:	6078      	str	r0, [r7, #4]
//  bool isEnabled = true;
//  bool isFdmeasReady = false;

	// disable everything; Flicker detect, smux, wait, spectral, power
	disableAll();
 801c6b0:	6878      	ldr	r0, [r7, #4]
 801c6b2:	f7ff fddc 	bl	801c26e <_ZN15Adafruit_AS734110disableAllEv>
	// re-enable power
	powerEnable(true);
 801c6b6:	2101      	movs	r1, #1
 801c6b8:	6878      	ldr	r0, [r7, #4]
 801c6ba:	f7ff fdba 	bl	801c232 <_ZN15Adafruit_AS734111powerEnableEb>

	// Write SMUX configuration from RAM to set SMUX chain registers (Write 0x10
	// to CFG6)
	setSMUXCommand(AS7341_SMUX_CMD_WRITE);
 801c6be:	2102      	movs	r1, #2
 801c6c0:	6878      	ldr	r0, [r7, #4]
 801c6c2:	f7ff fe54 	bl	801c36e <_ZN15Adafruit_AS734114setSMUXCommandE17as7341_smux_cmd_t>

	// Write new configuration to all the 20 registers for detecting Flicker
	FDConfig();
 801c6c6:	6878      	ldr	r0, [r7, #4]
 801c6c8:	f7ff ff4f 	bl	801c56a <_ZN15Adafruit_AS73418FDConfigEv>

	// Start SMUX command
	enableSMUX();
 801c6cc:	6878      	ldr	r0, [r7, #4]
 801c6ce:	f7ff fdfb 	bl	801c2c8 <_ZN15Adafruit_AS734110enableSMUXEv>

	// Enable SP_EN bit
	enableSpectralMeasurement(true);
 801c6d2:	2101      	movs	r1, #1
 801c6d4:	6878      	ldr	r0, [r7, #4]
 801c6d6:	f7ff fdd7 	bl	801c288 <_ZN15Adafruit_AS734125enableSpectralMeasurementEb>

	// Enable flicker detection bit
	writeRegisterByte((uint8_t) AS7341_ENABLE, (uint8_t) 0x41);
 801c6da:	2241      	movs	r2, #65	; 0x41
 801c6dc:	2180      	movs	r1, #128	; 0x80
 801c6de:	6878      	ldr	r0, [r7, #4]
 801c6e0:	f000 f859 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>

	osSemaphoreRelease(messageI2C1_LockHandle);
 801c6e4:	4b16      	ldr	r3, [pc, #88]	; (801c740 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x98>)
 801c6e6:	681b      	ldr	r3, [r3, #0]
 801c6e8:	4618      	mov	r0, r3
 801c6ea:	f006 fb77 	bl	8022ddc <osSemaphoreRelease>
	osDelay(500); // SF 2020-08-12 Does this really need to be so long?
 801c6ee:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 801c6f2:	f006 f87a 	bl	80227ea <osDelay>
	osSemaphoreAcquire(messageI2C1_LockHandle, osWaitForever);
 801c6f6:	4b12      	ldr	r3, [pc, #72]	; (801c740 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x98>)
 801c6f8:	681b      	ldr	r3, [r3, #0]
 801c6fa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 801c6fe:	4618      	mov	r0, r3
 801c700:	f006 fb1a 	bl	8022d38 <osSemaphoreAcquire>

	uint16_t flicker_status = getFlickerDetectStatus();
 801c704:	6878      	ldr	r0, [r7, #4]
 801c706:	f7ff fcd8 	bl	801c0ba <_ZN15Adafruit_AS734122getFlickerDetectStatusEv>
 801c70a:	4603      	mov	r3, r0
 801c70c:	81fb      	strh	r3, [r7, #14]
	enableFlickerDetection(false);
 801c70e:	2100      	movs	r1, #0
 801c710:	6878      	ldr	r0, [r7, #4]
 801c712:	f7ff fe1b 	bl	801c34c <_ZN15Adafruit_AS734122enableFlickerDetectionEb>
	switch (flicker_status) {
 801c716:	89fb      	ldrh	r3, [r7, #14]
 801c718:	2b2e      	cmp	r3, #46	; 0x2e
 801c71a:	d00a      	beq.n	801c732 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x8a>
 801c71c:	2b2e      	cmp	r3, #46	; 0x2e
 801c71e:	dc0a      	bgt.n	801c736 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x8e>
 801c720:	2b2c      	cmp	r3, #44	; 0x2c
 801c722:	d002      	beq.n	801c72a <_ZN15Adafruit_AS734115detectFlickerHzEv+0x82>
 801c724:	2b2d      	cmp	r3, #45	; 0x2d
 801c726:	d002      	beq.n	801c72e <_ZN15Adafruit_AS734115detectFlickerHzEv+0x86>
 801c728:	e005      	b.n	801c736 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x8e>
	case 44:
		return 1;
 801c72a:	2301      	movs	r3, #1
 801c72c:	e004      	b.n	801c738 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x90>
	case 45:
		return 100;
 801c72e:	2364      	movs	r3, #100	; 0x64
 801c730:	e002      	b.n	801c738 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x90>
	case 46:
		return 120;
 801c732:	2378      	movs	r3, #120	; 0x78
 801c734:	e000      	b.n	801c738 <_ZN15Adafruit_AS734115detectFlickerHzEv+0x90>
	default:
		return 0;
 801c736:	2300      	movs	r3, #0
	}
}
 801c738:	4618      	mov	r0, r3
 801c73a:	3710      	adds	r7, #16
 801c73c:	46bd      	mov	sp, r7
 801c73e:	bd80      	pop	{r7, pc}
 801c740:	200003dc 	.word	0x200003dc

0801c744 <_ZN15Adafruit_AS734113writeRegisterEhPht>:
 *
 * @param addr Register address
 * @param val The value to set the register to
 */
bool Adafruit_AS7341::writeRegister(uint8_t mem_addr, uint8_t *val,
		uint16_t size) {
 801c744:	b580      	push	{r7, lr}
 801c746:	b088      	sub	sp, #32
 801c748:	af04      	add	r7, sp, #16
 801c74a:	60f8      	str	r0, [r7, #12]
 801c74c:	607a      	str	r2, [r7, #4]
 801c74e:	461a      	mov	r2, r3
 801c750:	460b      	mov	r3, r1
 801c752:	72fb      	strb	r3, [r7, #11]
 801c754:	4613      	mov	r3, r2
 801c756:	813b      	strh	r3, [r7, #8]
	if (HAL_OK
			== HAL_I2C_Mem_Write(i2c_han, i2c_addr, mem_addr, 1, val, size, 10)) {
 801c758:	68fb      	ldr	r3, [r7, #12]
 801c75a:	6898      	ldr	r0, [r3, #8]
 801c75c:	68fb      	ldr	r3, [r7, #12]
 801c75e:	7b1b      	ldrb	r3, [r3, #12]
 801c760:	b299      	uxth	r1, r3
 801c762:	7afb      	ldrb	r3, [r7, #11]
 801c764:	b29a      	uxth	r2, r3
 801c766:	230a      	movs	r3, #10
 801c768:	9302      	str	r3, [sp, #8]
 801c76a:	893b      	ldrh	r3, [r7, #8]
 801c76c:	9301      	str	r3, [sp, #4]
 801c76e:	687b      	ldr	r3, [r7, #4]
 801c770:	9300      	str	r3, [sp, #0]
 801c772:	2301      	movs	r3, #1
 801c774:	f7f1 ffae 	bl	800e6d4 <HAL_I2C_Mem_Write>
 801c778:	4603      	mov	r3, r0
 801c77a:	2b00      	cmp	r3, #0
 801c77c:	bf0c      	ite	eq
 801c77e:	2301      	moveq	r3, #1
 801c780:	2300      	movne	r3, #0
 801c782:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801c784:	2b00      	cmp	r3, #0
 801c786:	d001      	beq.n	801c78c <_ZN15Adafruit_AS734113writeRegisterEhPht+0x48>
		return true;
 801c788:	2301      	movs	r3, #1
 801c78a:	e000      	b.n	801c78e <_ZN15Adafruit_AS734113writeRegisterEhPht+0x4a>
	} else {
		return false;
 801c78c:	2300      	movs	r3, #0
	}
}
 801c78e:	4618      	mov	r0, r3
 801c790:	3710      	adds	r7, #16
 801c792:	46bd      	mov	sp, r7
 801c794:	bd80      	pop	{r7, pc}

0801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>:

bool Adafruit_AS7341::writeRegisterByte(uint8_t mem_addr, uint8_t val) {
 801c796:	b580      	push	{r7, lr}
 801c798:	b086      	sub	sp, #24
 801c79a:	af04      	add	r7, sp, #16
 801c79c:	6078      	str	r0, [r7, #4]
 801c79e:	460b      	mov	r3, r1
 801c7a0:	70fb      	strb	r3, [r7, #3]
 801c7a2:	4613      	mov	r3, r2
 801c7a4:	70bb      	strb	r3, [r7, #2]
	if (HAL_OK
			== HAL_I2C_Mem_Write(i2c_han, i2c_addr, mem_addr, 1, &val, 1, 10)) {
 801c7a6:	687b      	ldr	r3, [r7, #4]
 801c7a8:	6898      	ldr	r0, [r3, #8]
 801c7aa:	687b      	ldr	r3, [r7, #4]
 801c7ac:	7b1b      	ldrb	r3, [r3, #12]
 801c7ae:	b299      	uxth	r1, r3
 801c7b0:	78fb      	ldrb	r3, [r7, #3]
 801c7b2:	b29a      	uxth	r2, r3
 801c7b4:	230a      	movs	r3, #10
 801c7b6:	9302      	str	r3, [sp, #8]
 801c7b8:	2301      	movs	r3, #1
 801c7ba:	9301      	str	r3, [sp, #4]
 801c7bc:	1cbb      	adds	r3, r7, #2
 801c7be:	9300      	str	r3, [sp, #0]
 801c7c0:	2301      	movs	r3, #1
 801c7c2:	f7f1 ff87 	bl	800e6d4 <HAL_I2C_Mem_Write>
 801c7c6:	4603      	mov	r3, r0
 801c7c8:	2b00      	cmp	r3, #0
 801c7ca:	bf0c      	ite	eq
 801c7cc:	2301      	moveq	r3, #1
 801c7ce:	2300      	movne	r3, #0
 801c7d0:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801c7d2:	2b00      	cmp	r3, #0
 801c7d4:	d001      	beq.n	801c7da <_ZN15Adafruit_AS734117writeRegisterByteEhh+0x44>
		return true;
 801c7d6:	2301      	movs	r3, #1
 801c7d8:	e000      	b.n	801c7dc <_ZN15Adafruit_AS734117writeRegisterByteEhh+0x46>
	} else {
		return false;
 801c7da:	2300      	movs	r3, #0
	}
}
 801c7dc:	4618      	mov	r0, r3
 801c7de:	3708      	adds	r7, #8
 801c7e0:	46bd      	mov	sp, r7
 801c7e2:	bd80      	pop	{r7, pc}

0801c7e4 <_ZN15Adafruit_AS734115modifyBitInByteEhhh>:

uint8_t Adafruit_AS7341::modifyBitInByte(uint8_t var, uint8_t value,
		uint8_t pos) {
 801c7e4:	b480      	push	{r7}
 801c7e6:	b085      	sub	sp, #20
 801c7e8:	af00      	add	r7, sp, #0
 801c7ea:	6078      	str	r0, [r7, #4]
 801c7ec:	4608      	mov	r0, r1
 801c7ee:	4611      	mov	r1, r2
 801c7f0:	461a      	mov	r2, r3
 801c7f2:	4603      	mov	r3, r0
 801c7f4:	70fb      	strb	r3, [r7, #3]
 801c7f6:	460b      	mov	r3, r1
 801c7f8:	70bb      	strb	r3, [r7, #2]
 801c7fa:	4613      	mov	r3, r2
 801c7fc:	707b      	strb	r3, [r7, #1]
	uint8_t mask = 1 << pos;
 801c7fe:	787b      	ldrb	r3, [r7, #1]
 801c800:	2201      	movs	r2, #1
 801c802:	fa02 f303 	lsl.w	r3, r2, r3
 801c806:	73fb      	strb	r3, [r7, #15]
	return ((var & ~mask) | (value << pos));
 801c808:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801c80c:	43db      	mvns	r3, r3
 801c80e:	b25a      	sxtb	r2, r3
 801c810:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801c814:	4013      	ands	r3, r2
 801c816:	b25a      	sxtb	r2, r3
 801c818:	78b9      	ldrb	r1, [r7, #2]
 801c81a:	787b      	ldrb	r3, [r7, #1]
 801c81c:	fa01 f303 	lsl.w	r3, r1, r3
 801c820:	b25b      	sxtb	r3, r3
 801c822:	4313      	orrs	r3, r2
 801c824:	b25b      	sxtb	r3, r3
 801c826:	b2db      	uxtb	r3, r3
}
 801c828:	4618      	mov	r0, r3
 801c82a:	3714      	adds	r7, #20
 801c82c:	46bd      	mov	sp, r7
 801c82e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c832:	4770      	bx	lr

0801c834 <_ZN15Adafruit_AS734112readRegisterEtPht>:

bool Adafruit_AS7341::readRegister(uint16_t mem_addr, uint8_t *dest,
		uint16_t size) {
 801c834:	b580      	push	{r7, lr}
 801c836:	b088      	sub	sp, #32
 801c838:	af04      	add	r7, sp, #16
 801c83a:	60f8      	str	r0, [r7, #12]
 801c83c:	607a      	str	r2, [r7, #4]
 801c83e:	461a      	mov	r2, r3
 801c840:	460b      	mov	r3, r1
 801c842:	817b      	strh	r3, [r7, #10]
 801c844:	4613      	mov	r3, r2
 801c846:	813b      	strh	r3, [r7, #8]
	if (HAL_OK
			== HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, dest, size, 10)) {
 801c848:	68fb      	ldr	r3, [r7, #12]
 801c84a:	6898      	ldr	r0, [r3, #8]
 801c84c:	68fb      	ldr	r3, [r7, #12]
 801c84e:	7b1b      	ldrb	r3, [r3, #12]
 801c850:	b299      	uxth	r1, r3
 801c852:	897a      	ldrh	r2, [r7, #10]
 801c854:	230a      	movs	r3, #10
 801c856:	9302      	str	r3, [sp, #8]
 801c858:	893b      	ldrh	r3, [r7, #8]
 801c85a:	9301      	str	r3, [sp, #4]
 801c85c:	687b      	ldr	r3, [r7, #4]
 801c85e:	9300      	str	r3, [sp, #0]
 801c860:	2301      	movs	r3, #1
 801c862:	f7f2 f84b 	bl	800e8fc <HAL_I2C_Mem_Read>
 801c866:	4603      	mov	r3, r0
 801c868:	2b00      	cmp	r3, #0
 801c86a:	bf0c      	ite	eq
 801c86c:	2301      	moveq	r3, #1
 801c86e:	2300      	movne	r3, #0
 801c870:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801c872:	2b00      	cmp	r3, #0
 801c874:	d001      	beq.n	801c87a <_ZN15Adafruit_AS734112readRegisterEtPht+0x46>
		return true;
 801c876:	2301      	movs	r3, #1
 801c878:	e000      	b.n	801c87c <_ZN15Adafruit_AS734112readRegisterEtPht+0x48>
	} else {
		return false;
 801c87a:	2300      	movs	r3, #0
	}
}
 801c87c:	4618      	mov	r0, r3
 801c87e:	3710      	adds	r7, #16
 801c880:	46bd      	mov	sp, r7
 801c882:	bd80      	pop	{r7, pc}

0801c884 <_ZN15Adafruit_AS734116checkRegisterBitEth>:

uint8_t Adafruit_AS7341::checkRegisterBit(uint16_t reg, uint8_t pos) {
 801c884:	b580      	push	{r7, lr}
 801c886:	b082      	sub	sp, #8
 801c888:	af00      	add	r7, sp, #0
 801c88a:	6078      	str	r0, [r7, #4]
 801c88c:	460b      	mov	r3, r1
 801c88e:	807b      	strh	r3, [r7, #2]
 801c890:	4613      	mov	r3, r2
 801c892:	707b      	strb	r3, [r7, #1]
	return (uint8_t) ((readRegisterByte(reg) >> pos) & 0x01);
 801c894:	887b      	ldrh	r3, [r7, #2]
 801c896:	4619      	mov	r1, r3
 801c898:	6878      	ldr	r0, [r7, #4]
 801c89a:	f000 f878 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c89e:	4603      	mov	r3, r0
 801c8a0:	461a      	mov	r2, r3
 801c8a2:	787b      	ldrb	r3, [r7, #1]
 801c8a4:	fa42 f303 	asr.w	r3, r2, r3
 801c8a8:	b2db      	uxtb	r3, r3
 801c8aa:	f003 0301 	and.w	r3, r3, #1
 801c8ae:	b2db      	uxtb	r3, r3
}
 801c8b0:	4618      	mov	r0, r3
 801c8b2:	3708      	adds	r7, #8
 801c8b4:	46bd      	mov	sp, r7
 801c8b6:	bd80      	pop	{r7, pc}

0801c8b8 <_ZN15Adafruit_AS734117modifyRegisterBitEtbh>:

bool Adafruit_AS7341::modifyRegisterBit(uint16_t reg, bool value, uint8_t pos) {
 801c8b8:	b580      	push	{r7, lr}
 801c8ba:	b084      	sub	sp, #16
 801c8bc:	af00      	add	r7, sp, #0
 801c8be:	6078      	str	r0, [r7, #4]
 801c8c0:	4608      	mov	r0, r1
 801c8c2:	4611      	mov	r1, r2
 801c8c4:	461a      	mov	r2, r3
 801c8c6:	4603      	mov	r3, r0
 801c8c8:	807b      	strh	r3, [r7, #2]
 801c8ca:	460b      	mov	r3, r1
 801c8cc:	707b      	strb	r3, [r7, #1]
 801c8ce:	4613      	mov	r3, r2
 801c8d0:	703b      	strb	r3, [r7, #0]
	uint8_t register_value = readRegisterByte(reg);
 801c8d2:	887b      	ldrh	r3, [r7, #2]
 801c8d4:	4619      	mov	r1, r3
 801c8d6:	6878      	ldr	r0, [r7, #4]
 801c8d8:	f000 f859 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c8dc:	4603      	mov	r3, r0
 801c8de:	73fb      	strb	r3, [r7, #15]
	register_value = modifyBitInByte(register_value, (uint8_t) value, pos);
 801c8e0:	787a      	ldrb	r2, [r7, #1]
 801c8e2:	783b      	ldrb	r3, [r7, #0]
 801c8e4:	7bf9      	ldrb	r1, [r7, #15]
 801c8e6:	6878      	ldr	r0, [r7, #4]
 801c8e8:	f7ff ff7c 	bl	801c7e4 <_ZN15Adafruit_AS734115modifyBitInByteEhhh>
 801c8ec:	4603      	mov	r3, r0
 801c8ee:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(reg, register_value);
 801c8f0:	887b      	ldrh	r3, [r7, #2]
 801c8f2:	b2db      	uxtb	r3, r3
 801c8f4:	7bfa      	ldrb	r2, [r7, #15]
 801c8f6:	4619      	mov	r1, r3
 801c8f8:	6878      	ldr	r0, [r7, #4]
 801c8fa:	f7ff ff4c 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
 801c8fe:	4603      	mov	r3, r0
}
 801c900:	4618      	mov	r0, r3
 801c902:	3710      	adds	r7, #16
 801c904:	46bd      	mov	sp, r7
 801c906:	bd80      	pop	{r7, pc}

0801c908 <_ZN15Adafruit_AS734125modifyRegisterMultipleBitEthhh>:

bool Adafruit_AS7341::modifyRegisterMultipleBit(uint16_t reg, uint8_t value,
		uint8_t pos, uint8_t bits) {
 801c908:	b580      	push	{r7, lr}
 801c90a:	b084      	sub	sp, #16
 801c90c:	af00      	add	r7, sp, #0
 801c90e:	6078      	str	r0, [r7, #4]
 801c910:	4608      	mov	r0, r1
 801c912:	4611      	mov	r1, r2
 801c914:	461a      	mov	r2, r3
 801c916:	4603      	mov	r3, r0
 801c918:	807b      	strh	r3, [r7, #2]
 801c91a:	460b      	mov	r3, r1
 801c91c:	707b      	strb	r3, [r7, #1]
 801c91e:	4613      	mov	r3, r2
 801c920:	703b      	strb	r3, [r7, #0]
	uint8_t register_value = readRegisterByte(reg);
 801c922:	887b      	ldrh	r3, [r7, #2]
 801c924:	4619      	mov	r1, r3
 801c926:	6878      	ldr	r0, [r7, #4]
 801c928:	f000 f831 	bl	801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>
 801c92c:	4603      	mov	r3, r0
 801c92e:	73fb      	strb	r3, [r7, #15]

	uint8_t mask = (1 << (bits)) - 1;
 801c930:	7e3b      	ldrb	r3, [r7, #24]
 801c932:	2201      	movs	r2, #1
 801c934:	fa02 f303 	lsl.w	r3, r2, r3
 801c938:	b2db      	uxtb	r3, r3
 801c93a:	3b01      	subs	r3, #1
 801c93c:	73bb      	strb	r3, [r7, #14]
	value &= mask;
 801c93e:	787a      	ldrb	r2, [r7, #1]
 801c940:	7bbb      	ldrb	r3, [r7, #14]
 801c942:	4013      	ands	r3, r2
 801c944:	707b      	strb	r3, [r7, #1]

	mask <<= pos;
 801c946:	7bba      	ldrb	r2, [r7, #14]
 801c948:	783b      	ldrb	r3, [r7, #0]
 801c94a:	fa02 f303 	lsl.w	r3, r2, r3
 801c94e:	73bb      	strb	r3, [r7, #14]
	register_value &= ~mask;          // remove the current data at that spot
 801c950:	f997 300e 	ldrsb.w	r3, [r7, #14]
 801c954:	43db      	mvns	r3, r3
 801c956:	b25a      	sxtb	r2, r3
 801c958:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801c95c:	4013      	ands	r3, r2
 801c95e:	b25b      	sxtb	r3, r3
 801c960:	73fb      	strb	r3, [r7, #15]
	register_value |= value << pos; // and add in the new data
 801c962:	787a      	ldrb	r2, [r7, #1]
 801c964:	783b      	ldrb	r3, [r7, #0]
 801c966:	fa02 f303 	lsl.w	r3, r2, r3
 801c96a:	b25a      	sxtb	r2, r3
 801c96c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801c970:	4313      	orrs	r3, r2
 801c972:	b25b      	sxtb	r3, r3
 801c974:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(reg, register_value);
 801c976:	887b      	ldrh	r3, [r7, #2]
 801c978:	b2db      	uxtb	r3, r3
 801c97a:	7bfa      	ldrb	r2, [r7, #15]
 801c97c:	4619      	mov	r1, r3
 801c97e:	6878      	ldr	r0, [r7, #4]
 801c980:	f7ff ff09 	bl	801c796 <_ZN15Adafruit_AS734117writeRegisterByteEhh>
 801c984:	4603      	mov	r3, r0
}
 801c986:	4618      	mov	r0, r3
 801c988:	3710      	adds	r7, #16
 801c98a:	46bd      	mov	sp, r7
 801c98c:	bd80      	pop	{r7, pc}

0801c98e <_ZN15Adafruit_AS734116readRegisterByteEt>:

uint8_t Adafruit_AS7341::readRegisterByte(uint16_t mem_addr) {
 801c98e:	b580      	push	{r7, lr}
 801c990:	b088      	sub	sp, #32
 801c992:	af04      	add	r7, sp, #16
 801c994:	6078      	str	r0, [r7, #4]
 801c996:	460b      	mov	r3, r1
 801c998:	807b      	strh	r3, [r7, #2]
	uint8_t data;
	HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, &data, 1, 10);
 801c99a:	687b      	ldr	r3, [r7, #4]
 801c99c:	6898      	ldr	r0, [r3, #8]
 801c99e:	687b      	ldr	r3, [r7, #4]
 801c9a0:	7b1b      	ldrb	r3, [r3, #12]
 801c9a2:	b299      	uxth	r1, r3
 801c9a4:	887a      	ldrh	r2, [r7, #2]
 801c9a6:	230a      	movs	r3, #10
 801c9a8:	9302      	str	r3, [sp, #8]
 801c9aa:	2301      	movs	r3, #1
 801c9ac:	9301      	str	r3, [sp, #4]
 801c9ae:	f107 030f 	add.w	r3, r7, #15
 801c9b2:	9300      	str	r3, [sp, #0]
 801c9b4:	2301      	movs	r3, #1
 801c9b6:	f7f1 ffa1 	bl	800e8fc <HAL_I2C_Mem_Read>
	return data;
 801c9ba:	7bfb      	ldrb	r3, [r7, #15]
}
 801c9bc:	4618      	mov	r0, r3
 801c9be:	3710      	adds	r7, #16
 801c9c0:	46bd      	mov	sp, r7
 801c9c2:	bd80      	pop	{r7, pc}

0801c9c4 <_ZN15Adafruit_BME680C1Ev>:
/*!
 *  @brief  Instantiates sensor with i2c.
 *  @param  *theWire
 *          optional Wire object
 */
Adafruit_BME680::Adafruit_BME680(void)
 801c9c4:	b480      	push	{r7}
 801c9c6:	b083      	sub	sp, #12
 801c9c8:	af00      	add	r7, sp, #0
 801c9ca:	6078      	str	r0, [r7, #4]
    : _meas_start(0), _meas_period(0) {
 801c9cc:	687b      	ldr	r3, [r7, #4]
 801c9ce:	2200      	movs	r2, #0
 801c9d0:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
 801c9d4:	687b      	ldr	r3, [r7, #4]
 801c9d6:	2200      	movs	r2, #0
 801c9d8:	f883 2164 	strb.w	r2, [r3, #356]	; 0x164
 801c9dc:	687b      	ldr	r3, [r7, #4]
 801c9de:	2200      	movs	r2, #0
 801c9e0:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
 801c9e4:	687b      	ldr	r3, [r7, #4]
 801c9e6:	2200      	movs	r2, #0
 801c9e8:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178
}
 801c9ec:	687b      	ldr	r3, [r7, #4]
 801c9ee:	4618      	mov	r0, r3
 801c9f0:	370c      	adds	r7, #12
 801c9f2:	46bd      	mov	sp, r7
 801c9f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c9f8:	4770      	bx	lr
	...

0801c9fc <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb>:
 *  @param  initSettings
 *          Optional parameter for initializing the sensor settings.
 *          Default is true.
 *  @return True on sensor initialization success. False on failure.
 */
bool Adafruit_BME680::begin(uint8_t i2c_address, I2C_HandleTypeDef *i2c_handle, bool initSettings) {
 801c9fc:	b580      	push	{r7, lr}
 801c9fe:	b086      	sub	sp, #24
 801ca00:	af00      	add	r7, sp, #0
 801ca02:	60f8      	str	r0, [r7, #12]
 801ca04:	607a      	str	r2, [r7, #4]
 801ca06:	461a      	mov	r2, r3
 801ca08:	460b      	mov	r3, r1
 801ca0a:	72fb      	strb	r3, [r7, #11]
 801ca0c:	4613      	mov	r3, r2
 801ca0e:	72bb      	strb	r3, [r7, #10]

	i2c_han = i2c_handle;
 801ca10:	68fb      	ldr	r3, [r7, #12]
 801ca12:	687a      	ldr	r2, [r7, #4]
 801ca14:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	i2c_addr = i2c_address << 1;
 801ca18:	7afb      	ldrb	r3, [r7, #11]
 801ca1a:	005b      	lsls	r3, r3, #1
 801ca1c:	b2da      	uxtb	r2, r3
 801ca1e:	68fb      	ldr	r3, [r7, #12]
 801ca20:	f883 2164 	strb.w	r2, [r3, #356]	; 0x164

	i2c_dev.i2c_han = i2c_han;
 801ca24:	68fb      	ldr	r3, [r7, #12]
 801ca26:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
 801ca2a:	68fb      	ldr	r3, [r7, #12]
 801ca2c:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
	i2c_dev.i2c_addr = i2c_addr;
 801ca30:	68fb      	ldr	r3, [r7, #12]
 801ca32:	f893 2164 	ldrb.w	r2, [r3, #356]	; 0x164
 801ca36:	68fb      	ldr	r3, [r7, #12]
 801ca38:	f883 216c 	strb.w	r2, [r3, #364]	; 0x16c

  int8_t rslt;

  extTempOffset = 0.0f;
 801ca3c:	68fb      	ldr	r3, [r7, #12]
 801ca3e:	f04f 0200 	mov.w	r2, #0
 801ca42:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c

	gas_sensor.chip_id = i2c_addr;
 801ca46:	68fb      	ldr	r3, [r7, #12]
 801ca48:	f893 2164 	ldrb.w	r2, [r3, #356]	; 0x164
 801ca4c:	68fb      	ldr	r3, [r7, #12]
 801ca4e:	f883 2184 	strb.w	r2, [r3, #388]	; 0x184
	gas_sensor.intf = BME68X_I2C_INTF;
 801ca52:	68fb      	ldr	r3, [r7, #12]
 801ca54:	2201      	movs	r2, #1
 801ca56:	f883 2190 	strb.w	r2, [r3, #400]	; 0x190
	gas_sensor.intf_ptr = &i2c_dev;
 801ca5a:	68fb      	ldr	r3, [r7, #12]
 801ca5c:	f503 72b4 	add.w	r2, r3, #360	; 0x168
 801ca60:	68fb      	ldr	r3, [r7, #12]
 801ca62:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
	gas_sensor.read = i2c_read;
 801ca66:	68fb      	ldr	r3, [r7, #12]
 801ca68:	4a2c      	ldr	r2, [pc, #176]	; (801cb1c <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x120>)
 801ca6a:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
	gas_sensor.write = i2c_write;
 801ca6e:	68fb      	ldr	r3, [r7, #12]
 801ca70:	4a2b      	ldr	r2, [pc, #172]	; (801cb20 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x124>)
 801ca72:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8

  gas_sensor.amb_temp = 25; /* The ambient temperature in deg C is used for
 801ca76:	68fb      	ldr	r3, [r7, #12]
 801ca78:	2219      	movs	r2, #25
 801ca7a:	f883 2192 	strb.w	r2, [r3, #402]	; 0x192
                               defining the heater temperature */
  gas_sensor.delay_us = delay_usec;
 801ca7e:	68fb      	ldr	r3, [r7, #12]
 801ca80:	4a28      	ldr	r2, [pc, #160]	; (801cb24 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x128>)
 801ca82:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc

  rslt = bme68x_init(&gas_sensor);
 801ca86:	68fb      	ldr	r3, [r7, #12]
 801ca88:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801ca8c:	4618      	mov	r0, r3
 801ca8e:	f000 fe0f 	bl	801d6b0 <bme68x_init>
 801ca92:	4603      	mov	r3, r0
 801ca94:	75fb      	strb	r3, [r7, #23]
#ifdef BME680_DEBUG
  Serial.print(F("Init Result: "));
  Serial.println(rslt);
#endif

  if (rslt != BME68X_OK)
 801ca96:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801ca9a:	2b00      	cmp	r3, #0
 801ca9c:	d001      	beq.n	801caa2 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0xa6>
    return false;
 801ca9e:	2300      	movs	r3, #0
 801caa0:	e038      	b.n	801cb14 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x118>
//  }
  // don't do anything till we request a reading
//  rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &gas_sensor);

  // Initialize BSEC library before further use
  status = bsec_init();
 801caa2:	f7e3 fb77 	bl	8000194 <bsec_init>
 801caa6:	4603      	mov	r3, r0
 801caa8:	461a      	mov	r2, r3
 801caaa:	68fb      	ldr	r3, [r7, #12]
 801caac:	751a      	strb	r2, [r3, #20]
  if (status != BSEC_OK)
 801caae:	68fb      	ldr	r3, [r7, #12]
 801cab0:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cab4:	2b00      	cmp	r3, #0
 801cab6:	d001      	beq.n	801cabc <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0xc0>
	  return false;
 801cab8:	2300      	movs	r3, #0
 801caba:	e02b      	b.n	801cb14 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x118>

  status = bsec_get_version(&version);
 801cabc:	68fb      	ldr	r3, [r7, #12]
 801cabe:	3310      	adds	r3, #16
 801cac0:	4618      	mov	r0, r3
 801cac2:	f7e3 fb5d 	bl	8000180 <bsec_get_version>
 801cac6:	4603      	mov	r3, r0
 801cac8:	461a      	mov	r2, r3
 801caca:	68fb      	ldr	r3, [r7, #12]
 801cacc:	751a      	strb	r2, [r3, #20]
	if (status != BSEC_OK)
 801cace:	68fb      	ldr	r3, [r7, #12]
 801cad0:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cad4:	2b00      	cmp	r3, #0
 801cad6:	d001      	beq.n	801cadc <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0xe0>
	 return false;
 801cad8:	2300      	movs	r3, #0
 801cada:	e01b      	b.n	801cb14 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x118>

	memset(&bmeConf, 0, sizeof(bmeConf));
 801cadc:	68fb      	ldr	r3, [r7, #12]
 801cade:	3378      	adds	r3, #120	; 0x78
 801cae0:	2240      	movs	r2, #64	; 0x40
 801cae2:	2100      	movs	r1, #0
 801cae4:	4618      	mov	r0, r3
 801cae6:	f00f fb09 	bl	802c0fc <memset>
	memset(&outputs, 0, sizeof(outputs));
 801caea:	68fb      	ldr	r3, [r7, #12]
 801caec:	33b8      	adds	r3, #184	; 0xb8
 801caee:	22a8      	movs	r2, #168	; 0xa8
 801caf0:	2100      	movs	r1, #0
 801caf2:	4618      	mov	r0, r3
 801caf4:	f00f fb02 	bl	802c0fc <memset>
	memset(&heatrConf, 0, sizeof(heatrConf));
 801caf8:	68fb      	ldr	r3, [r7, #12]
 801cafa:	3318      	adds	r3, #24
 801cafc:	2214      	movs	r2, #20
 801cafe:	2100      	movs	r1, #0
 801cb00:	4618      	mov	r0, r3
 801cb02:	f00f fafb 	bl	802c0fc <memset>
#ifdef BME680_DEBUG
  Serial.print(F("Opmode Result: "));
  Serial.println(rslt);
#endif

  if (rslt != BME68X_OK)
 801cb06:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801cb0a:	2b00      	cmp	r3, #0
 801cb0c:	d001      	beq.n	801cb12 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x116>
    return false;
 801cb0e:	2300      	movs	r3, #0
 801cb10:	e000      	b.n	801cb14 <_ZN15Adafruit_BME6805beginEhP19__I2C_HandleTypeDefb+0x118>

  return true;
 801cb12:	2301      	movs	r3, #1
}
 801cb14:	4618      	mov	r0, r3
 801cb16:	3718      	adds	r7, #24
 801cb18:	46bd      	mov	sp, r7
 801cb1a:	bd80      	pop	{r7, pc}
 801cb1c:	0801cd4b 	.word	0x0801cd4b
 801cb20:	0801cda1 	.word	0x0801cda1
 801cb24:	0801cdf7 	.word	0x0801cdf7

0801cb28 <_ZN15Adafruit_BME68013bsecSubscribeEv>:

bool Adafruit_BME680::bsecSubscribe(void) {
 801cb28:	b580      	push	{r7, lr}
 801cb2a:	b0ac      	sub	sp, #176	; 0xb0
 801cb2c:	af00      	add	r7, sp, #0
 801cb2e:	6078      	str	r0, [r7, #4]
    bsecSensor sensorList[] = {
 801cb30:	4a26      	ldr	r2, [pc, #152]	; (801cbcc <_ZN15Adafruit_BME68013bsecSubscribeEv+0xa4>)
 801cb32:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 801cb36:	ca07      	ldmia	r2, {r0, r1, r2}
 801cb38:	c303      	stmia	r3!, {r0, r1}
 801cb3a:	701a      	strb	r2, [r3, #0]
//			BSEC_OUTPUT_GAS_ESTIMATE_1,
//			BSEC_OUTPUT_GAS_ESTIMATE_2
    };

    bsec_sensor_configuration_t virtualSensors[BSEC_NUMBER_OUTPUTS], sensorSettings[BSEC_MAX_PHYSICAL_SENSOR];
    uint8_t nSensorSettings = BSEC_MAX_PHYSICAL_SENSOR;
 801cb3c:	2308      	movs	r3, #8
 801cb3e:	73fb      	strb	r3, [r7, #15]
    uint16_t nSensors = ARRAY_LEN(sensorList);
 801cb40:	2309      	movs	r3, #9
 801cb42:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac

    for (uint8_t i = 0; i < nSensors; i++)
 801cb46:	2300      	movs	r3, #0
 801cb48:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
 801cb4c:	f897 20af 	ldrb.w	r2, [r7, #175]	; 0xaf
 801cb50:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 801cb54:	429a      	cmp	r2, r3
 801cb56:	da1d      	bge.n	801cb94 <_ZN15Adafruit_BME68013bsecSubscribeEv+0x6c>
    {
        virtualSensors[i].sensor_id = sensorList[i];
 801cb58:	f897 20af 	ldrb.w	r2, [r7, #175]	; 0xaf
 801cb5c:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 801cb60:	f107 01b0 	add.w	r1, r7, #176	; 0xb0
 801cb64:	440a      	add	r2, r1
 801cb66:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 801cb6a:	00db      	lsls	r3, r3, #3
 801cb6c:	f107 01b0 	add.w	r1, r7, #176	; 0xb0
 801cb70:	440b      	add	r3, r1
 801cb72:	f803 2c5c 	strb.w	r2, [r3, #-92]
//        virtualSensors[i].sample_rate = BSEC_SAMPLE_RATE_CONT;
		virtualSensors[i].sample_rate = BSEC_SAMPLE_RATE_LP;
 801cb76:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 801cb7a:	00db      	lsls	r3, r3, #3
 801cb7c:	f107 02b0 	add.w	r2, r7, #176	; 0xb0
 801cb80:	4413      	add	r3, r2
 801cb82:	3b60      	subs	r3, #96	; 0x60
 801cb84:	4a12      	ldr	r2, [pc, #72]	; (801cbd0 <_ZN15Adafruit_BME68013bsecSubscribeEv+0xa8>)
 801cb86:	601a      	str	r2, [r3, #0]
    for (uint8_t i = 0; i < nSensors; i++)
 801cb88:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 801cb8c:	3301      	adds	r3, #1
 801cb8e:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
 801cb92:	e7db      	b.n	801cb4c <_ZN15Adafruit_BME68013bsecSubscribeEv+0x24>
//		virtualSensors[i].sample_rate = BSEC_SAMPLE_RATE_SCAN;
    }

    status = bsec_update_subscription(virtualSensors, nSensors, sensorSettings, &nSensorSettings);
 801cb94:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 801cb98:	b2d9      	uxtb	r1, r3
 801cb9a:	f107 030f 	add.w	r3, r7, #15
 801cb9e:	f107 0210 	add.w	r2, r7, #16
 801cba2:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801cba6:	f7e3 fb03 	bl	80001b0 <bsec_update_subscription>
 801cbaa:	4603      	mov	r3, r0
 801cbac:	461a      	mov	r2, r3
 801cbae:	687b      	ldr	r3, [r7, #4]
 801cbb0:	751a      	strb	r2, [r3, #20]
    if (status != BSEC_OK){
 801cbb2:	687b      	ldr	r3, [r7, #4]
 801cbb4:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cbb8:	2b00      	cmp	r3, #0
 801cbba:	d001      	beq.n	801cbc0 <_ZN15Adafruit_BME68013bsecSubscribeEv+0x98>
        return false;
 801cbbc:	2300      	movs	r3, #0
 801cbbe:	e000      	b.n	801cbc2 <_ZN15Adafruit_BME68013bsecSubscribeEv+0x9a>
    }
    else{
    	return true;
 801cbc0:	2301      	movs	r3, #1
    }
}
 801cbc2:	4618      	mov	r0, r3
 801cbc4:	37b0      	adds	r7, #176	; 0xb0
 801cbc6:	46bd      	mov	sp, r7
 801cbc8:	bd80      	pop	{r7, pc}
 801cbca:	bf00      	nop
 801cbcc:	0802c56c 	.word	0x0802c56c
 801cbd0:	3eaaaa3b 	.word	0x3eaaaa3b

0801cbd4 <_ZN15Adafruit_BME6809fetchDataEv>:

/**
 * @brief Function to fetch data from the sensor into the local buffer
 */
uint8_t Adafruit_BME680::fetchData(void)
{
 801cbd4:	b580      	push	{r7, lr}
 801cbd6:	b082      	sub	sp, #8
 801cbd8:	af00      	add	r7, sp, #0
 801cbda:	6078      	str	r0, [r7, #4]
	nFields = 0;
 801cbdc:	687b      	ldr	r3, [r7, #4]
 801cbde:	2200      	movs	r2, #0
 801cbe0:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
	bme68xStatus = bme68x_get_data(lastOpMode, sensorData, &nFields, &gas_sensor);
 801cbe4:	687b      	ldr	r3, [r7, #4]
 801cbe6:	f893 0076 	ldrb.w	r0, [r3, #118]	; 0x76
 801cbea:	687b      	ldr	r3, [r7, #4]
 801cbec:	f103 012c 	add.w	r1, r3, #44	; 0x2c
 801cbf0:	687b      	ldr	r3, [r7, #4]
 801cbf2:	f103 0274 	add.w	r2, r3, #116	; 0x74
 801cbf6:	687b      	ldr	r3, [r7, #4]
 801cbf8:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801cbfc:	f001 f8ec 	bl	801ddd8 <bme68x_get_data>
 801cc00:	4603      	mov	r3, r0
 801cc02:	461a      	mov	r2, r3
 801cc04:	687b      	ldr	r3, [r7, #4]
 801cc06:	755a      	strb	r2, [r3, #21]
	iFields = 0;
 801cc08:	687b      	ldr	r3, [r7, #4]
 801cc0a:	2200      	movs	r2, #0
 801cc0c:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75

	return nFields;
 801cc10:	687b      	ldr	r3, [r7, #4]
 801cc12:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
}
 801cc16:	4618      	mov	r0, r3
 801cc18:	3708      	adds	r7, #8
 801cc1a:	46bd      	mov	sp, r7
 801cc1c:	bd80      	pop	{r7, pc}

0801cc1e <_ZN15Adafruit_BME6807getDataER11bme68x_data>:

/**
 * @brief Function to get a single data field
 */
uint8_t Adafruit_BME680::getData(bme68xData &data)
{
 801cc1e:	b4b0      	push	{r4, r5, r7}
 801cc20:	b083      	sub	sp, #12
 801cc22:	af00      	add	r7, sp, #0
 801cc24:	6078      	str	r0, [r7, #4]
 801cc26:	6039      	str	r1, [r7, #0]
	if (lastOpMode == BME68X_FORCED_MODE)
 801cc28:	687b      	ldr	r3, [r7, #4]
 801cc2a:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
 801cc2e:	2b01      	cmp	r3, #1
 801cc30:	d10b      	bne.n	801cc4a <_ZN15Adafruit_BME6807getDataER11bme68x_data+0x2c>
	{
		data = sensorData[0];
 801cc32:	683a      	ldr	r2, [r7, #0]
 801cc34:	687b      	ldr	r3, [r7, #4]
 801cc36:	4615      	mov	r5, r2
 801cc38:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 801cc3c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801cc3e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801cc40:	e894 0003 	ldmia.w	r4, {r0, r1}
 801cc44:	e885 0003 	stmia.w	r5, {r0, r1}
 801cc48:	e03b      	b.n	801ccc2 <_ZN15Adafruit_BME6807getDataER11bme68x_data+0xa4>
	} else
	{
		if (nFields)
 801cc4a:	687b      	ldr	r3, [r7, #4]
 801cc4c:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 801cc50:	2b00      	cmp	r3, #0
 801cc52:	d036      	beq.n	801ccc2 <_ZN15Adafruit_BME6807getDataER11bme68x_data+0xa4>
		{
			/* iFields spans from 0-2 while nFields spans from
			 * 0-3, where 0 means that there is no new data
			 */
			data = sensorData[iFields];
 801cc54:	687b      	ldr	r3, [r7, #4]
 801cc56:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 801cc5a:	4619      	mov	r1, r3
 801cc5c:	6838      	ldr	r0, [r7, #0]
 801cc5e:	687a      	ldr	r2, [r7, #4]
 801cc60:	460b      	mov	r3, r1
 801cc62:	005b      	lsls	r3, r3, #1
 801cc64:	440b      	add	r3, r1
 801cc66:	00db      	lsls	r3, r3, #3
 801cc68:	4413      	add	r3, r2
 801cc6a:	3328      	adds	r3, #40	; 0x28
 801cc6c:	4605      	mov	r5, r0
 801cc6e:	1d1c      	adds	r4, r3, #4
 801cc70:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801cc72:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801cc74:	e894 0003 	ldmia.w	r4, {r0, r1}
 801cc78:	e885 0003 	stmia.w	r5, {r0, r1}
			iFields++;
 801cc7c:	687b      	ldr	r3, [r7, #4]
 801cc7e:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 801cc82:	3301      	adds	r3, #1
 801cc84:	b2da      	uxtb	r2, r3
 801cc86:	687b      	ldr	r3, [r7, #4]
 801cc88:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75

			/* Limit reading continuously to the last fields read */
			if (iFields >= nFields)
 801cc8c:	687b      	ldr	r3, [r7, #4]
 801cc8e:	f893 2075 	ldrb.w	r2, [r3, #117]	; 0x75
 801cc92:	687b      	ldr	r3, [r7, #4]
 801cc94:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 801cc98:	429a      	cmp	r2, r3
 801cc9a:	d309      	bcc.n	801ccb0 <_ZN15Adafruit_BME6807getDataER11bme68x_data+0x92>
			{
				iFields = nFields - 1;
 801cc9c:	687b      	ldr	r3, [r7, #4]
 801cc9e:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 801cca2:	3b01      	subs	r3, #1
 801cca4:	b2da      	uxtb	r2, r3
 801cca6:	687b      	ldr	r3, [r7, #4]
 801cca8:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
				return 0;
 801ccac:	2300      	movs	r3, #0
 801ccae:	e009      	b.n	801ccc4 <_ZN15Adafruit_BME6807getDataER11bme68x_data+0xa6>
			}

			/* Indicate if there is something left to read */
			return nFields - iFields;
 801ccb0:	687b      	ldr	r3, [r7, #4]
 801ccb2:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 801ccb6:	687b      	ldr	r3, [r7, #4]
 801ccb8:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 801ccbc:	1ad3      	subs	r3, r2, r3
 801ccbe:	b2db      	uxtb	r3, r3
 801ccc0:	e000      	b.n	801ccc4 <_ZN15Adafruit_BME6807getDataER11bme68x_data+0xa6>
		}
	}

	return 0;
 801ccc2:	2300      	movs	r3, #0
}
 801ccc4:	4618      	mov	r0, r3
 801ccc6:	370c      	adds	r7, #12
 801ccc8:	46bd      	mov	sp, r7
 801ccca:	bcb0      	pop	{r4, r5, r7}
 801cccc:	4770      	bx	lr

0801ccce <_ZN15Adafruit_BME6806setTPHEhhh>:

/**
 * @brief Function to set the Temperature, Pressure and Humidity over-sampling
 */
void Adafruit_BME680::setTPH(uint8_t osTemp, uint8_t osPres, uint8_t osHum)
{
 801ccce:	b580      	push	{r7, lr}
 801ccd0:	b082      	sub	sp, #8
 801ccd2:	af00      	add	r7, sp, #0
 801ccd4:	6078      	str	r0, [r7, #4]
 801ccd6:	4608      	mov	r0, r1
 801ccd8:	4611      	mov	r1, r2
 801ccda:	461a      	mov	r2, r3
 801ccdc:	4603      	mov	r3, r0
 801ccde:	70fb      	strb	r3, [r7, #3]
 801cce0:	460b      	mov	r3, r1
 801cce2:	70bb      	strb	r3, [r7, #2]
 801cce4:	4613      	mov	r3, r2
 801cce6:	707b      	strb	r3, [r7, #1]
	bme68xStatus = bme68x_get_conf(&gas_conf, &gas_sensor);
 801cce8:	687b      	ldr	r3, [r7, #4]
 801ccea:	f503 72ea 	add.w	r2, r3, #468	; 0x1d4
 801ccee:	687b      	ldr	r3, [r7, #4]
 801ccf0:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801ccf4:	4619      	mov	r1, r3
 801ccf6:	4610      	mov	r0, r2
 801ccf8:	f000 ff2c 	bl	801db54 <bme68x_get_conf>
 801ccfc:	4603      	mov	r3, r0
 801ccfe:	461a      	mov	r2, r3
 801cd00:	687b      	ldr	r3, [r7, #4]
 801cd02:	755a      	strb	r2, [r3, #21]

	if (bme68xStatus == BME68X_OK)
 801cd04:	687b      	ldr	r3, [r7, #4]
 801cd06:	f993 3015 	ldrsb.w	r3, [r3, #21]
 801cd0a:	2b00      	cmp	r3, #0
 801cd0c:	d119      	bne.n	801cd42 <_ZN15Adafruit_BME6806setTPHEhhh+0x74>
	{
		gas_conf.os_hum = osHum;
 801cd0e:	687b      	ldr	r3, [r7, #4]
 801cd10:	787a      	ldrb	r2, [r7, #1]
 801cd12:	f883 21d4 	strb.w	r2, [r3, #468]	; 0x1d4
		gas_conf.os_temp = osTemp;
 801cd16:	687b      	ldr	r3, [r7, #4]
 801cd18:	78fa      	ldrb	r2, [r7, #3]
 801cd1a:	f883 21d5 	strb.w	r2, [r3, #469]	; 0x1d5
		gas_conf.os_pres = osPres;
 801cd1e:	687b      	ldr	r3, [r7, #4]
 801cd20:	78ba      	ldrb	r2, [r7, #2]
 801cd22:	f883 21d6 	strb.w	r2, [r3, #470]	; 0x1d6

		bme68xStatus = bme68x_set_conf(&gas_conf, &gas_sensor);
 801cd26:	687b      	ldr	r3, [r7, #4]
 801cd28:	f503 72ea 	add.w	r2, r3, #468	; 0x1d4
 801cd2c:	687b      	ldr	r3, [r7, #4]
 801cd2e:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801cd32:	4619      	mov	r1, r3
 801cd34:	4610      	mov	r0, r2
 801cd36:	f000 fe09 	bl	801d94c <bme68x_set_conf>
 801cd3a:	4603      	mov	r3, r0
 801cd3c:	461a      	mov	r2, r3
 801cd3e:	687b      	ldr	r3, [r7, #4]
 801cd40:	755a      	strb	r2, [r3, #21]
	}
}
 801cd42:	bf00      	nop
 801cd44:	3708      	adds	r7, #8
 801cd46:	46bd      	mov	sp, r7
 801cd48:	bd80      	pop	{r7, pc}

0801cd4a <_ZL8i2c_readhPhmPv>:
}

/*!
 *  @brief  Reads 8 bit values over I2C
 */
int8_t i2c_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf) {
 801cd4a:	b590      	push	{r4, r7, lr}
 801cd4c:	b08b      	sub	sp, #44	; 0x2c
 801cd4e:	af04      	add	r7, sp, #16
 801cd50:	60b9      	str	r1, [r7, #8]
 801cd52:	607a      	str	r2, [r7, #4]
 801cd54:	603b      	str	r3, [r7, #0]
 801cd56:	4603      	mov	r3, r0
 801cd58:	73fb      	strb	r3, [r7, #15]

	i2c_interface *_dev = (i2c_interface *)intf;
 801cd5a:	683b      	ldr	r3, [r7, #0]
 801cd5c:	617b      	str	r3, [r7, #20]

	if (HAL_OK
			== HAL_I2C_Mem_Read(_dev->i2c_han, _dev->i2c_addr, reg_addr, 1, reg_data, len, 10)) {
 801cd5e:	697b      	ldr	r3, [r7, #20]
 801cd60:	6818      	ldr	r0, [r3, #0]
 801cd62:	697b      	ldr	r3, [r7, #20]
 801cd64:	791b      	ldrb	r3, [r3, #4]
 801cd66:	b299      	uxth	r1, r3
 801cd68:	7bfb      	ldrb	r3, [r7, #15]
 801cd6a:	b29a      	uxth	r2, r3
 801cd6c:	687b      	ldr	r3, [r7, #4]
 801cd6e:	b29b      	uxth	r3, r3
 801cd70:	240a      	movs	r4, #10
 801cd72:	9402      	str	r4, [sp, #8]
 801cd74:	9301      	str	r3, [sp, #4]
 801cd76:	68bb      	ldr	r3, [r7, #8]
 801cd78:	9300      	str	r3, [sp, #0]
 801cd7a:	2301      	movs	r3, #1
 801cd7c:	f7f1 fdbe 	bl	800e8fc <HAL_I2C_Mem_Read>
 801cd80:	4603      	mov	r3, r0
 801cd82:	2b00      	cmp	r3, #0
 801cd84:	bf0c      	ite	eq
 801cd86:	2301      	moveq	r3, #1
 801cd88:	2300      	movne	r3, #0
 801cd8a:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801cd8c:	2b00      	cmp	r3, #0
 801cd8e:	d001      	beq.n	801cd94 <_ZL8i2c_readhPhmPv+0x4a>
		return 0;
 801cd90:	2300      	movs	r3, #0
 801cd92:	e001      	b.n	801cd98 <_ZL8i2c_readhPhmPv+0x4e>
	} else {
		return -1;
 801cd94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	}
}
 801cd98:	4618      	mov	r0, r3
 801cd9a:	371c      	adds	r7, #28
 801cd9c:	46bd      	mov	sp, r7
 801cd9e:	bd90      	pop	{r4, r7, pc}

0801cda0 <_ZL9i2c_writehPKhmPv>:

/*!
 *  @brief  Writes 8 bit values over I2C
 */
int8_t i2c_write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len,
                 void *intf) {
 801cda0:	b590      	push	{r4, r7, lr}
 801cda2:	b08b      	sub	sp, #44	; 0x2c
 801cda4:	af04      	add	r7, sp, #16
 801cda6:	60b9      	str	r1, [r7, #8]
 801cda8:	607a      	str	r2, [r7, #4]
 801cdaa:	603b      	str	r3, [r7, #0]
 801cdac:	4603      	mov	r3, r0
 801cdae:	73fb      	strb	r3, [r7, #15]
	i2c_interface *_dev = (i2c_interface *)intf;
 801cdb0:	683b      	ldr	r3, [r7, #0]
 801cdb2:	617b      	str	r3, [r7, #20]

	if (HAL_OK
			== HAL_I2C_Mem_Write(_dev->i2c_han, _dev->i2c_addr, reg_addr, 1, const_cast <uint8_t *>(reg_data), len, 10)) {
 801cdb4:	697b      	ldr	r3, [r7, #20]
 801cdb6:	6818      	ldr	r0, [r3, #0]
 801cdb8:	697b      	ldr	r3, [r7, #20]
 801cdba:	791b      	ldrb	r3, [r3, #4]
 801cdbc:	b299      	uxth	r1, r3
 801cdbe:	7bfb      	ldrb	r3, [r7, #15]
 801cdc0:	b29a      	uxth	r2, r3
 801cdc2:	687b      	ldr	r3, [r7, #4]
 801cdc4:	b29b      	uxth	r3, r3
 801cdc6:	240a      	movs	r4, #10
 801cdc8:	9402      	str	r4, [sp, #8]
 801cdca:	9301      	str	r3, [sp, #4]
 801cdcc:	68bb      	ldr	r3, [r7, #8]
 801cdce:	9300      	str	r3, [sp, #0]
 801cdd0:	2301      	movs	r3, #1
 801cdd2:	f7f1 fc7f 	bl	800e6d4 <HAL_I2C_Mem_Write>
 801cdd6:	4603      	mov	r3, r0
 801cdd8:	2b00      	cmp	r3, #0
 801cdda:	bf0c      	ite	eq
 801cddc:	2301      	moveq	r3, #1
 801cdde:	2300      	movne	r3, #0
 801cde0:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801cde2:	2b00      	cmp	r3, #0
 801cde4:	d001      	beq.n	801cdea <_ZL9i2c_writehPKhmPv+0x4a>
		return 0;
 801cde6:	2300      	movs	r3, #0
 801cde8:	e001      	b.n	801cdee <_ZL9i2c_writehPKhmPv+0x4e>
	} else {
		return -1;
 801cdea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	}
}
 801cdee:	4618      	mov	r0, r3
 801cdf0:	371c      	adds	r7, #28
 801cdf2:	46bd      	mov	sp, r7
 801cdf4:	bd90      	pop	{r4, r7, pc}

0801cdf6 <_ZL10delay_usecmPv>:

static void delay_usec(uint32_t t, void *intf_ptr)
{
 801cdf6:	b580      	push	{r7, lr}
 801cdf8:	b084      	sub	sp, #16
 801cdfa:	af00      	add	r7, sp, #0
 801cdfc:	6078      	str	r0, [r7, #4]
 801cdfe:	6039      	str	r1, [r7, #0]
  uint32_t start, end;
  start = GetMicros();
 801ce00:	f000 f831 	bl	801ce66 <_Z9GetMicrosv>
 801ce04:	60f8      	str	r0, [r7, #12]
  end = start + t;
 801ce06:	68fa      	ldr	r2, [r7, #12]
 801ce08:	687b      	ldr	r3, [r7, #4]
 801ce0a:	4413      	add	r3, r2
 801ce0c:	60bb      	str	r3, [r7, #8]
  if (start < end) {
 801ce0e:	68fa      	ldr	r2, [r7, #12]
 801ce10:	68bb      	ldr	r3, [r7, #8]
 801ce12:	429a      	cmp	r2, r3
 801ce14:	d211      	bcs.n	801ce3a <_ZL10delay_usecmPv+0x44>
  	while ((GetMicros() >= start) && (GetMicros() < end)) {
 801ce16:	f000 f826 	bl	801ce66 <_Z9GetMicrosv>
 801ce1a:	4602      	mov	r2, r0
 801ce1c:	68fb      	ldr	r3, [r7, #12]
 801ce1e:	4293      	cmp	r3, r2
 801ce20:	d807      	bhi.n	801ce32 <_ZL10delay_usecmPv+0x3c>
 801ce22:	f000 f820 	bl	801ce66 <_Z9GetMicrosv>
 801ce26:	4602      	mov	r2, r0
 801ce28:	68bb      	ldr	r3, [r7, #8]
 801ce2a:	4293      	cmp	r3, r2
 801ce2c:	d901      	bls.n	801ce32 <_ZL10delay_usecmPv+0x3c>
 801ce2e:	2301      	movs	r3, #1
 801ce30:	e000      	b.n	801ce34 <_ZL10delay_usecmPv+0x3e>
 801ce32:	2300      	movs	r3, #0
 801ce34:	2b00      	cmp	r3, #0
 801ce36:	d012      	beq.n	801ce5e <_ZL10delay_usecmPv+0x68>
 801ce38:	e7ed      	b.n	801ce16 <_ZL10delay_usecmPv+0x20>
  	  // do nothing
  	}
  } else {
    while ((GetMicros() >= start) || (GetMicros() < end)) {
 801ce3a:	f000 f814 	bl	801ce66 <_Z9GetMicrosv>
 801ce3e:	4602      	mov	r2, r0
 801ce40:	68fb      	ldr	r3, [r7, #12]
 801ce42:	4293      	cmp	r3, r2
 801ce44:	d905      	bls.n	801ce52 <_ZL10delay_usecmPv+0x5c>
 801ce46:	f000 f80e 	bl	801ce66 <_Z9GetMicrosv>
 801ce4a:	4602      	mov	r2, r0
 801ce4c:	68bb      	ldr	r3, [r7, #8]
 801ce4e:	4293      	cmp	r3, r2
 801ce50:	d901      	bls.n	801ce56 <_ZL10delay_usecmPv+0x60>
 801ce52:	2301      	movs	r3, #1
 801ce54:	e000      	b.n	801ce58 <_ZL10delay_usecmPv+0x62>
 801ce56:	2300      	movs	r3, #0
 801ce58:	2b00      	cmp	r3, #0
 801ce5a:	d000      	beq.n	801ce5e <_ZL10delay_usecmPv+0x68>
 801ce5c:	e7ed      	b.n	801ce3a <_ZL10delay_usecmPv+0x44>
      // do nothing
    };
  }
//  osDelay(ceil(t/1000.0));

};
 801ce5e:	bf00      	nop
 801ce60:	3710      	adds	r7, #16
 801ce62:	46bd      	mov	sp, r7
 801ce64:	bd80      	pop	{r7, pc}

0801ce66 <_Z9GetMicrosv>:

uint32_t GetMicros(void){
 801ce66:	b580      	push	{r7, lr}
 801ce68:	af00      	add	r7, sp, #0
	return HAL_GetTick() * 1000;
 801ce6a:	f7ef fe0d 	bl	800ca88 <HAL_GetTick>
 801ce6e:	4603      	mov	r3, r0
 801ce70:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801ce74:	fb02 f303 	mul.w	r3, r2, r3
}
 801ce78:	4618      	mov	r0, r3
 801ce7a:	bd80      	pop	{r7, pc}

0801ce7c <_ZN15Adafruit_BME68013bsecGetConfigEPhPm>:

bool Adafruit_BME680::bsecGetConfig(uint8_t *config, uint32_t *n_serialized_settings){
 801ce7c:	b580      	push	{r7, lr}
 801ce7e:	b086      	sub	sp, #24
 801ce80:	af02      	add	r7, sp, #8
 801ce82:	60f8      	str	r0, [r7, #12]
 801ce84:	60b9      	str	r1, [r7, #8]
 801ce86:	607a      	str	r2, [r7, #4]
	status = bsec_get_configuration(0, config, BSEC_MAX_PROPERTY_BLOB_SIZE, workBuffer, BSEC_MAX_WORKBUFFER_SIZE, n_serialized_settings);
 801ce88:	687b      	ldr	r3, [r7, #4]
 801ce8a:	9301      	str	r3, [sp, #4]
 801ce8c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801ce90:	9300      	str	r3, [sp, #0]
 801ce92:	4b0b      	ldr	r3, [pc, #44]	; (801cec0 <_ZN15Adafruit_BME68013bsecGetConfigEPhPm+0x44>)
 801ce94:	f640 02ed 	movw	r2, #2285	; 0x8ed
 801ce98:	68b9      	ldr	r1, [r7, #8]
 801ce9a:	2000      	movs	r0, #0
 801ce9c:	f7e3 f9cc 	bl	8000238 <bsec_get_configuration>
 801cea0:	4603      	mov	r3, r0
 801cea2:	461a      	mov	r2, r3
 801cea4:	68fb      	ldr	r3, [r7, #12]
 801cea6:	751a      	strb	r2, [r3, #20]

	if (status != BSEC_OK)
 801cea8:	68fb      	ldr	r3, [r7, #12]
 801ceaa:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801ceae:	2b00      	cmp	r3, #0
 801ceb0:	d001      	beq.n	801ceb6 <_ZN15Adafruit_BME68013bsecGetConfigEPhPm+0x3a>
		return false;
 801ceb2:	2300      	movs	r3, #0
 801ceb4:	e000      	b.n	801ceb8 <_ZN15Adafruit_BME68013bsecGetConfigEPhPm+0x3c>

	return true;
 801ceb6:	2301      	movs	r3, #1
}
 801ceb8:	4618      	mov	r0, r3
 801ceba:	3710      	adds	r7, #16
 801cebc:	46bd      	mov	sp, r7
 801cebe:	bd80      	pop	{r7, pc}
 801cec0:	20002acc 	.word	0x20002acc

0801cec4 <_ZN15Adafruit_BME68012bsecGetStateEPhPm>:

bool Adafruit_BME680::bsecGetState(uint8_t *state, uint32_t *n_serialized_state){
 801cec4:	b580      	push	{r7, lr}
 801cec6:	b086      	sub	sp, #24
 801cec8:	af02      	add	r7, sp, #8
 801ceca:	60f8      	str	r0, [r7, #12]
 801cecc:	60b9      	str	r1, [r7, #8]
 801cece:	607a      	str	r2, [r7, #4]
	status = bsec_get_state(0, state, BSEC_MAX_STATE_BLOB_SIZE, workBuffer, BSEC_MAX_WORKBUFFER_SIZE, n_serialized_state);
 801ced0:	687b      	ldr	r3, [r7, #4]
 801ced2:	9301      	str	r3, [sp, #4]
 801ced4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801ced8:	9300      	str	r3, [sp, #0]
 801ceda:	4b0b      	ldr	r3, [pc, #44]	; (801cf08 <_ZN15Adafruit_BME68012bsecGetStateEPhPm+0x44>)
 801cedc:	22d5      	movs	r2, #213	; 0xd5
 801cede:	68b9      	ldr	r1, [r7, #8]
 801cee0:	2000      	movs	r0, #0
 801cee2:	f7e3 f9c5 	bl	8000270 <bsec_get_state>
 801cee6:	4603      	mov	r3, r0
 801cee8:	461a      	mov	r2, r3
 801ceea:	68fb      	ldr	r3, [r7, #12]
 801ceec:	751a      	strb	r2, [r3, #20]

	if (status != BSEC_OK)
 801ceee:	68fb      	ldr	r3, [r7, #12]
 801cef0:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cef4:	2b00      	cmp	r3, #0
 801cef6:	d001      	beq.n	801cefc <_ZN15Adafruit_BME68012bsecGetStateEPhPm+0x38>
		return false;
 801cef8:	2300      	movs	r3, #0
 801cefa:	e000      	b.n	801cefe <_ZN15Adafruit_BME68012bsecGetStateEPhPm+0x3a>

	return true;
 801cefc:	2301      	movs	r3, #1
}
 801cefe:	4618      	mov	r0, r3
 801cf00:	3710      	adds	r7, #16
 801cf02:	46bd      	mov	sp, r7
 801cf04:	bd80      	pop	{r7, pc}
 801cf06:	bf00      	nop
 801cf08:	20002acc 	.word	0x20002acc

0801cf0c <_ZN15Adafruit_BME68013bsecSetConfigEPKh>:


bool Adafruit_BME680::bsecSetConfig(const uint8_t *config)
{
 801cf0c:	b580      	push	{r7, lr}
 801cf0e:	b082      	sub	sp, #8
 801cf10:	af00      	add	r7, sp, #0
 801cf12:	6078      	str	r0, [r7, #4]
 801cf14:	6039      	str	r1, [r7, #0]
    status = bsec_set_configuration(config, BSEC_MAX_PROPERTY_BLOB_SIZE, workBuffer, BSEC_MAX_WORKBUFFER_SIZE);
 801cf16:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801cf1a:	4a0e      	ldr	r2, [pc, #56]	; (801cf54 <_ZN15Adafruit_BME68013bsecSetConfigEPKh+0x48>)
 801cf1c:	f640 01ed 	movw	r1, #2285	; 0x8ed
 801cf20:	6838      	ldr	r0, [r7, #0]
 801cf22:	f7e3 f969 	bl	80001f8 <bsec_set_configuration>
 801cf26:	4603      	mov	r3, r0
 801cf28:	461a      	mov	r2, r3
 801cf2a:	687b      	ldr	r3, [r7, #4]
 801cf2c:	751a      	strb	r2, [r3, #20]
    if (status != BSEC_OK)
 801cf2e:	687b      	ldr	r3, [r7, #4]
 801cf30:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cf34:	2b00      	cmp	r3, #0
 801cf36:	d001      	beq.n	801cf3c <_ZN15Adafruit_BME68013bsecSetConfigEPKh+0x30>
        return false;
 801cf38:	2300      	movs	r3, #0
 801cf3a:	e007      	b.n	801cf4c <_ZN15Adafruit_BME68013bsecSetConfigEPKh+0x40>

    memset(&bmeConf, 0, sizeof(bmeConf));
 801cf3c:	687b      	ldr	r3, [r7, #4]
 801cf3e:	3378      	adds	r3, #120	; 0x78
 801cf40:	2240      	movs	r2, #64	; 0x40
 801cf42:	2100      	movs	r1, #0
 801cf44:	4618      	mov	r0, r3
 801cf46:	f00f f8d9 	bl	802c0fc <memset>

    return true;
 801cf4a:	2301      	movs	r3, #1
}
 801cf4c:	4618      	mov	r0, r3
 801cf4e:	3708      	adds	r7, #8
 801cf50:	46bd      	mov	sp, r7
 801cf52:	bd80      	pop	{r7, pc}
 801cf54:	20002acc 	.word	0x20002acc

0801cf58 <_ZN15Adafruit_BME68012bsecSetStateEPKh>:


bool Adafruit_BME680::bsecSetState(const uint8_t *state){
 801cf58:	b580      	push	{r7, lr}
 801cf5a:	b082      	sub	sp, #8
 801cf5c:	af00      	add	r7, sp, #0
 801cf5e:	6078      	str	r0, [r7, #4]
 801cf60:	6039      	str	r1, [r7, #0]
    status = bsec_set_state(state, BSEC_MAX_STATE_BLOB_SIZE, workBuffer, BSEC_MAX_WORKBUFFER_SIZE);
 801cf62:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801cf66:	4a0a      	ldr	r2, [pc, #40]	; (801cf90 <_ZN15Adafruit_BME68012bsecSetStateEPKh+0x38>)
 801cf68:	21d5      	movs	r1, #213	; 0xd5
 801cf6a:	6838      	ldr	r0, [r7, #0]
 801cf6c:	f7e3 f954 	bl	8000218 <bsec_set_state>
 801cf70:	4603      	mov	r3, r0
 801cf72:	461a      	mov	r2, r3
 801cf74:	687b      	ldr	r3, [r7, #4]
 801cf76:	751a      	strb	r2, [r3, #20]
    if (status != BSEC_OK)
 801cf78:	687b      	ldr	r3, [r7, #4]
 801cf7a:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801cf7e:	2b00      	cmp	r3, #0
 801cf80:	d001      	beq.n	801cf86 <_ZN15Adafruit_BME68012bsecSetStateEPKh+0x2e>
        return false;
 801cf82:	2300      	movs	r3, #0
 801cf84:	e000      	b.n	801cf88 <_ZN15Adafruit_BME68012bsecSetStateEPKh+0x30>

    return true;
 801cf86:	2301      	movs	r3, #1
}
 801cf88:	4618      	mov	r0, r3
 801cf8a:	3708      	adds	r7, #8
 801cf8c:	46bd      	mov	sp, r7
 801cf8e:	bd80      	pop	{r7, pc}
 801cf90:	20002acc 	.word	0x20002acc

0801cf94 <_ZN15Adafruit_BME6807bsecRunEv>:

bool Adafruit_BME680::bsecRun(void)
{
 801cf94:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801cf98:	b08e      	sub	sp, #56	; 0x38
 801cf9a:	af02      	add	r7, sp, #8
 801cf9c:	6078      	str	r0, [r7, #4]
    uint8_t nFieldsLeft = 0;
 801cf9e:	2300      	movs	r3, #0
 801cfa0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    bme68xData data;
    int64_t currTimeNs = HAL_GetTick() * INT64_C(1000000);
 801cfa4:	f7ef fd70 	bl	800ca88 <HAL_GetTick>
 801cfa8:	4603      	mov	r3, r0
 801cfaa:	461c      	mov	r4, r3
 801cfac:	f04f 0500 	mov.w	r5, #0
 801cfb0:	4622      	mov	r2, r4
 801cfb2:	462b      	mov	r3, r5
 801cfb4:	f04f 0000 	mov.w	r0, #0
 801cfb8:	f04f 0100 	mov.w	r1, #0
 801cfbc:	0159      	lsls	r1, r3, #5
 801cfbe:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 801cfc2:	0150      	lsls	r0, r2, #5
 801cfc4:	4602      	mov	r2, r0
 801cfc6:	460b      	mov	r3, r1
 801cfc8:	1b12      	subs	r2, r2, r4
 801cfca:	eb63 0305 	sbc.w	r3, r3, r5
 801cfce:	f04f 0000 	mov.w	r0, #0
 801cfd2:	f04f 0100 	mov.w	r1, #0
 801cfd6:	0259      	lsls	r1, r3, #9
 801cfd8:	ea41 51d2 	orr.w	r1, r1, r2, lsr #23
 801cfdc:	0250      	lsls	r0, r2, #9
 801cfde:	4602      	mov	r2, r0
 801cfe0:	460b      	mov	r3, r1
 801cfe2:	1912      	adds	r2, r2, r4
 801cfe4:	eb45 0303 	adc.w	r3, r5, r3
 801cfe8:	f04f 0000 	mov.w	r0, #0
 801cfec:	f04f 0100 	mov.w	r1, #0
 801cff0:	0199      	lsls	r1, r3, #6
 801cff2:	ea41 6192 	orr.w	r1, r1, r2, lsr #26
 801cff6:	0190      	lsls	r0, r2, #6
 801cff8:	1a80      	subs	r0, r0, r2
 801cffa:	eb61 0103 	sbc.w	r1, r1, r3
 801cffe:	eb10 0804 	adds.w	r8, r0, r4
 801d002:	eb41 0905 	adc.w	r9, r1, r5
 801d006:	e9c7 8908 	strd	r8, r9, [r7, #32]
    opMode = bmeConf.op_mode;
 801d00a:	687b      	ldr	r3, [r7, #4]
 801d00c:	f893 20b6 	ldrb.w	r2, [r3, #182]	; 0xb6
 801d010:	687b      	ldr	r3, [r7, #4]
 801d012:	f883 2180 	strb.w	r2, [r3, #384]	; 0x180



    if (currTimeNs >= bmeConf.next_call)
 801d016:	687b      	ldr	r3, [r7, #4]
 801d018:	e9d3 231e 	ldrd	r2, r3, [r3, #120]	; 0x78
 801d01c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801d020:	4290      	cmp	r0, r2
 801d022:	eb71 0303 	sbcs.w	r3, r1, r3
 801d026:	f2c0 8087 	blt.w	801d138 <_ZN15Adafruit_BME6807bsecRunEv+0x1a4>
    {
        /* Provides the information about the current sensor configuration that is
           necessary to fulfill the input requirements, eg: operation mode, timestamp
           at which the sensor data shall be fetched etc */
        status = bsec_sensor_control(currTimeNs, &bmeConf);
 801d02a:	687b      	ldr	r3, [r7, #4]
 801d02c:	3378      	adds	r3, #120	; 0x78
 801d02e:	461a      	mov	r2, r3
 801d030:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 801d034:	f7e3 f938 	bl	80002a8 <bsec_sensor_control>
 801d038:	4603      	mov	r3, r0
 801d03a:	461a      	mov	r2, r3
 801d03c:	687b      	ldr	r3, [r7, #4]
 801d03e:	751a      	strb	r2, [r3, #20]

        if (status != BSEC_OK)
 801d040:	687b      	ldr	r3, [r7, #4]
 801d042:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801d046:	2b00      	cmp	r3, #0
 801d048:	d001      	beq.n	801d04e <_ZN15Adafruit_BME6807bsecRunEv+0xba>
            return false;
 801d04a:	2300      	movs	r3, #0
 801d04c:	e077      	b.n	801d13e <_ZN15Adafruit_BME6807bsecRunEv+0x1aa>

        switch (bmeConf.op_mode)
 801d04e:	687b      	ldr	r3, [r7, #4]
 801d050:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
 801d054:	2b02      	cmp	r3, #2
 801d056:	d009      	beq.n	801d06c <_ZN15Adafruit_BME6807bsecRunEv+0xd8>
 801d058:	2b02      	cmp	r3, #2
 801d05a:	dc27      	bgt.n	801d0ac <_ZN15Adafruit_BME6807bsecRunEv+0x118>
 801d05c:	2b00      	cmp	r3, #0
 801d05e:	d011      	beq.n	801d084 <_ZN15Adafruit_BME6807bsecRunEv+0xf0>
 801d060:	2b01      	cmp	r3, #1
 801d062:	d123      	bne.n	801d0ac <_ZN15Adafruit_BME6807bsecRunEv+0x118>
        {
        case BME68X_FORCED_MODE:
            setBme68xConfigForced();
 801d064:	6878      	ldr	r0, [r7, #4]
 801d066:	f000 f9c9 	bl	801d3fc <_ZN15Adafruit_BME68021setBme68xConfigForcedEv>
            break;
 801d06a:	e01f      	b.n	801d0ac <_ZN15Adafruit_BME6807bsecRunEv+0x118>
        case BME68X_PARALLEL_MODE:
            if (opMode != bmeConf.op_mode)
 801d06c:	687b      	ldr	r3, [r7, #4]
 801d06e:	f893 2180 	ldrb.w	r2, [r3, #384]	; 0x180
 801d072:	687b      	ldr	r3, [r7, #4]
 801d074:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
 801d078:	429a      	cmp	r2, r3
 801d07a:	d014      	beq.n	801d0a6 <_ZN15Adafruit_BME6807bsecRunEv+0x112>
            {
                setBme68xConfigParallel();
 801d07c:	6878      	ldr	r0, [r7, #4]
 801d07e:	f000 fa0d 	bl	801d49c <_ZN15Adafruit_BME68023setBme68xConfigParallelEv>
            }
            break;
 801d082:	e010      	b.n	801d0a6 <_ZN15Adafruit_BME6807bsecRunEv+0x112>

        case BME68X_SLEEP_MODE:
            if (opMode != bmeConf.op_mode)
 801d084:	687b      	ldr	r3, [r7, #4]
 801d086:	f893 2180 	ldrb.w	r2, [r3, #384]	; 0x180
 801d08a:	687b      	ldr	r3, [r7, #4]
 801d08c:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
 801d090:	429a      	cmp	r2, r3
 801d092:	d00a      	beq.n	801d0aa <_ZN15Adafruit_BME6807bsecRunEv+0x116>
            {
                setOpMode(BME68X_SLEEP_MODE);
 801d094:	2100      	movs	r1, #0
 801d096:	6878      	ldr	r0, [r7, #4]
 801d098:	f000 fae8 	bl	801d66c <_ZN15Adafruit_BME6809setOpModeEh>
                opMode = BME68X_SLEEP_MODE;
 801d09c:	687b      	ldr	r3, [r7, #4]
 801d09e:	2200      	movs	r2, #0
 801d0a0:	f883 2180 	strb.w	r2, [r3, #384]	; 0x180
            }
            break;
 801d0a4:	e001      	b.n	801d0aa <_ZN15Adafruit_BME6807bsecRunEv+0x116>
            break;
 801d0a6:	bf00      	nop
 801d0a8:	e000      	b.n	801d0ac <_ZN15Adafruit_BME6807bsecRunEv+0x118>
            break;
 801d0aa:	bf00      	nop
        }

        if (checkStatus() == BME68X_ERROR)
 801d0ac:	6878      	ldr	r0, [r7, #4]
 801d0ae:	f000 fa5b 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d0b2:	4603      	mov	r3, r0
 801d0b4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d0b8:	bf0c      	ite	eq
 801d0ba:	2301      	moveq	r3, #1
 801d0bc:	2300      	movne	r3, #0
 801d0be:	b2db      	uxtb	r3, r3
 801d0c0:	2b00      	cmp	r3, #0
 801d0c2:	d001      	beq.n	801d0c8 <_ZN15Adafruit_BME6807bsecRunEv+0x134>
            return false;
 801d0c4:	2300      	movs	r3, #0
 801d0c6:	e03a      	b.n	801d13e <_ZN15Adafruit_BME6807bsecRunEv+0x1aa>

        if (bmeConf.trigger_measurement && bmeConf.op_mode != BME68X_SLEEP_MODE)
 801d0c8:	687b      	ldr	r3, [r7, #4]
 801d0ca:	f893 30b5 	ldrb.w	r3, [r3, #181]	; 0xb5
 801d0ce:	2b00      	cmp	r3, #0
 801d0d0:	d034      	beq.n	801d13c <_ZN15Adafruit_BME6807bsecRunEv+0x1a8>
 801d0d2:	687b      	ldr	r3, [r7, #4]
 801d0d4:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
 801d0d8:	2b00      	cmp	r3, #0
 801d0da:	d02f      	beq.n	801d13c <_ZN15Adafruit_BME6807bsecRunEv+0x1a8>
        {
            if (fetchData())
 801d0dc:	6878      	ldr	r0, [r7, #4]
 801d0de:	f7ff fd79 	bl	801cbd4 <_ZN15Adafruit_BME6809fetchDataEv>
 801d0e2:	4603      	mov	r3, r0
 801d0e4:	2b00      	cmp	r3, #0
 801d0e6:	bf14      	ite	ne
 801d0e8:	2301      	movne	r3, #1
 801d0ea:	2300      	moveq	r3, #0
 801d0ec:	b2db      	uxtb	r3, r3
 801d0ee:	2b00      	cmp	r3, #0
 801d0f0:	d024      	beq.n	801d13c <_ZN15Adafruit_BME6807bsecRunEv+0x1a8>
            {
                do
                {
                    nFieldsLeft = getData(data);
 801d0f2:	f107 0308 	add.w	r3, r7, #8
 801d0f6:	4619      	mov	r1, r3
 801d0f8:	6878      	ldr	r0, [r7, #4]
 801d0fa:	f7ff fd90 	bl	801cc1e <_ZN15Adafruit_BME6807getDataER11bme68x_data>
 801d0fe:	4603      	mov	r3, r0
 801d100:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                    /* check for valid gas data */
                    if (data.status & BME68X_GASM_VALID_MSK)
 801d104:	7a3b      	ldrb	r3, [r7, #8]
 801d106:	f003 0320 	and.w	r3, r3, #32
 801d10a:	2b00      	cmp	r3, #0
 801d10c:	d00f      	beq.n	801d12e <_ZN15Adafruit_BME6807bsecRunEv+0x19a>
                    {
                        if (!bsecProcessData(currTimeNs, data))
 801d10e:	f107 0308 	add.w	r3, r7, #8
 801d112:	9300      	str	r3, [sp, #0]
 801d114:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 801d118:	6878      	ldr	r0, [r7, #4]
 801d11a:	f000 f815 	bl	801d148 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data>
 801d11e:	4603      	mov	r3, r0
 801d120:	f083 0301 	eor.w	r3, r3, #1
 801d124:	b2db      	uxtb	r3, r3
 801d126:	2b00      	cmp	r3, #0
 801d128:	d001      	beq.n	801d12e <_ZN15Adafruit_BME6807bsecRunEv+0x19a>
                        {
                            return false;
 801d12a:	2300      	movs	r3, #0
 801d12c:	e007      	b.n	801d13e <_ZN15Adafruit_BME6807bsecRunEv+0x1aa>
                        }
                    }
                } while (nFieldsLeft);
 801d12e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801d132:	2b00      	cmp	r3, #0
 801d134:	d002      	beq.n	801d13c <_ZN15Adafruit_BME6807bsecRunEv+0x1a8>
                do
 801d136:	e7dc      	b.n	801d0f2 <_ZN15Adafruit_BME6807bsecRunEv+0x15e>
    } else{
//        uint32_t timeLeft_ms = floor( (bmeConf.next_call - currTimeNs) / 1000000);
//        if ( timeLeft_ms > 0){
//        	osDelay(timeLeft_ms);
//        }
    	return false;
 801d138:	2300      	movs	r3, #0
 801d13a:	e000      	b.n	801d13e <_ZN15Adafruit_BME6807bsecRunEv+0x1aa>
    }
    return true;
 801d13c:	2301      	movs	r3, #1
}
 801d13e:	4618      	mov	r0, r3
 801d140:	3730      	adds	r7, #48	; 0x30
 801d142:	46bd      	mov	sp, r7
 801d144:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0801d148 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data>:

/**
 * @brief Reads data from the BME68X sensor and process it
 */
bool Adafruit_BME680::bsecProcessData(int64_t currTimeNs, const bme68xData &data)
{
 801d148:	b580      	push	{r7, lr}
 801d14a:	b0a6      	sub	sp, #152	; 0x98
 801d14c:	af00      	add	r7, sp, #0
 801d14e:	60f8      	str	r0, [r7, #12]
 801d150:	e9c7 2300 	strd	r2, r3, [r7]
    bsec_input_t inputs[BSEC_MAX_PHYSICAL_SENSOR]; /* Temp, Pres, Hum & Gas */
    uint8_t nInputs = 0;
 801d154:	2300      	movs	r3, #0
 801d156:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    /* Checks all the required sensor inputs, required for the BSEC library for the requested outputs */
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_HEATSOURCE))
 801d15a:	68fb      	ldr	r3, [r7, #12]
 801d15c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d160:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801d164:	2b00      	cmp	r3, #0
 801d166:	d024      	beq.n	801d1b2 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x6a>
    {
        inputs[nInputs].sensor_id = BSEC_INPUT_HEATSOURCE;
 801d168:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d16c:	011b      	lsls	r3, r3, #4
 801d16e:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d172:	4413      	add	r3, r2
 801d174:	3b7b      	subs	r3, #123	; 0x7b
 801d176:	220e      	movs	r2, #14
 801d178:	701a      	strb	r2, [r3, #0]
        inputs[nInputs].signal = extTempOffset;
 801d17a:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d17e:	68fa      	ldr	r2, [r7, #12]
 801d180:	f8d2 217c 	ldr.w	r2, [r2, #380]	; 0x17c
 801d184:	011b      	lsls	r3, r3, #4
 801d186:	f107 0198 	add.w	r1, r7, #152	; 0x98
 801d18a:	440b      	add	r3, r1
 801d18c:	3b80      	subs	r3, #128	; 0x80
 801d18e:	601a      	str	r2, [r3, #0]
        inputs[nInputs].time_stamp = currTimeNs;
 801d190:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d194:	011b      	lsls	r3, r3, #4
 801d196:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d19a:	4413      	add	r3, r2
 801d19c:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d1a0:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d1a4:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d1a8:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d1ac:	3301      	adds	r3, #1
 801d1ae:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_TEMPERATURE))
 801d1b2:	68fb      	ldr	r3, [r7, #12]
 801d1b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d1b8:	f003 0304 	and.w	r3, r3, #4
 801d1bc:	2b00      	cmp	r3, #0
 801d1be:	d024      	beq.n	801d20a <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0xc2>
    {
#ifdef BME68X_USE_FPU
        inputs[nInputs].sensor_id = BSEC_INPUT_TEMPERATURE;
 801d1c0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d1c4:	011b      	lsls	r3, r3, #4
 801d1c6:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d1ca:	4413      	add	r3, r2
 801d1cc:	3b7b      	subs	r3, #123	; 0x7b
 801d1ce:	2203      	movs	r2, #3
 801d1d0:	701a      	strb	r2, [r3, #0]
#else
        inputs[nInputs].sensor_id = BSEC_INPUT_TEMPERATURE / 100.0f;
#endif
        inputs[nInputs].signal = data.temperature;
 801d1d2:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d1d6:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801d1da:	6892      	ldr	r2, [r2, #8]
 801d1dc:	011b      	lsls	r3, r3, #4
 801d1de:	f107 0198 	add.w	r1, r7, #152	; 0x98
 801d1e2:	440b      	add	r3, r1
 801d1e4:	3b80      	subs	r3, #128	; 0x80
 801d1e6:	601a      	str	r2, [r3, #0]
        inputs[nInputs].time_stamp = currTimeNs;
 801d1e8:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d1ec:	011b      	lsls	r3, r3, #4
 801d1ee:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d1f2:	4413      	add	r3, r2
 801d1f4:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d1f8:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d1fc:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d200:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d204:	3301      	adds	r3, #1
 801d206:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_HUMIDITY))
 801d20a:	68fb      	ldr	r3, [r7, #12]
 801d20c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d210:	f003 0302 	and.w	r3, r3, #2
 801d214:	2b00      	cmp	r3, #0
 801d216:	d024      	beq.n	801d262 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x11a>
    {
#ifdef BME68X_USE_FPU
        inputs[nInputs].sensor_id = BSEC_INPUT_HUMIDITY;
 801d218:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d21c:	011b      	lsls	r3, r3, #4
 801d21e:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d222:	4413      	add	r3, r2
 801d224:	3b7b      	subs	r3, #123	; 0x7b
 801d226:	2202      	movs	r2, #2
 801d228:	701a      	strb	r2, [r3, #0]
#else
        inputs[nInputs].sensor_id = BSEC_INPUT_HUMIDITY / 1000.0f;
#endif
        inputs[nInputs].signal = data.humidity;
 801d22a:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d22e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801d232:	6912      	ldr	r2, [r2, #16]
 801d234:	011b      	lsls	r3, r3, #4
 801d236:	f107 0198 	add.w	r1, r7, #152	; 0x98
 801d23a:	440b      	add	r3, r1
 801d23c:	3b80      	subs	r3, #128	; 0x80
 801d23e:	601a      	str	r2, [r3, #0]
        inputs[nInputs].time_stamp = currTimeNs;
 801d240:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d244:	011b      	lsls	r3, r3, #4
 801d246:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d24a:	4413      	add	r3, r2
 801d24c:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d250:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d254:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d258:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d25c:	3301      	adds	r3, #1
 801d25e:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_PRESSURE))
 801d262:	68fb      	ldr	r3, [r7, #12]
 801d264:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d268:	f003 0301 	and.w	r3, r3, #1
 801d26c:	2b00      	cmp	r3, #0
 801d26e:	d024      	beq.n	801d2ba <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x172>
    {
        inputs[nInputs].sensor_id = BSEC_INPUT_PRESSURE;
 801d270:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d274:	011b      	lsls	r3, r3, #4
 801d276:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d27a:	4413      	add	r3, r2
 801d27c:	3b7b      	subs	r3, #123	; 0x7b
 801d27e:	2201      	movs	r2, #1
 801d280:	701a      	strb	r2, [r3, #0]
        inputs[nInputs].signal = data.pressure;
 801d282:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d286:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801d28a:	68d2      	ldr	r2, [r2, #12]
 801d28c:	011b      	lsls	r3, r3, #4
 801d28e:	f107 0198 	add.w	r1, r7, #152	; 0x98
 801d292:	440b      	add	r3, r1
 801d294:	3b80      	subs	r3, #128	; 0x80
 801d296:	601a      	str	r2, [r3, #0]
        inputs[nInputs].time_stamp = currTimeNs;
 801d298:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d29c:	011b      	lsls	r3, r3, #4
 801d29e:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d2a2:	4413      	add	r3, r2
 801d2a4:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d2a8:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d2ac:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d2b0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d2b4:	3301      	adds	r3, #1
 801d2b6:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_GASRESISTOR) &&
 801d2ba:	68fb      	ldr	r3, [r7, #12]
 801d2bc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d2c0:	f003 0308 	and.w	r3, r3, #8
 801d2c4:	2b00      	cmp	r3, #0
 801d2c6:	d02b      	beq.n	801d320 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x1d8>
            (data.status & BME68X_GASM_VALID_MSK))
 801d2c8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801d2cc:	781b      	ldrb	r3, [r3, #0]
 801d2ce:	f003 0320 	and.w	r3, r3, #32
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_GASRESISTOR) &&
 801d2d2:	2b00      	cmp	r3, #0
 801d2d4:	d024      	beq.n	801d320 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x1d8>
    {
        inputs[nInputs].sensor_id = BSEC_INPUT_GASRESISTOR;
 801d2d6:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d2da:	011b      	lsls	r3, r3, #4
 801d2dc:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d2e0:	4413      	add	r3, r2
 801d2e2:	3b7b      	subs	r3, #123	; 0x7b
 801d2e4:	2204      	movs	r2, #4
 801d2e6:	701a      	strb	r2, [r3, #0]
        inputs[nInputs].signal = data.gas_resistance;
 801d2e8:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d2ec:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801d2f0:	6952      	ldr	r2, [r2, #20]
 801d2f2:	011b      	lsls	r3, r3, #4
 801d2f4:	f107 0198 	add.w	r1, r7, #152	; 0x98
 801d2f8:	440b      	add	r3, r1
 801d2fa:	3b80      	subs	r3, #128	; 0x80
 801d2fc:	601a      	str	r2, [r3, #0]
        inputs[nInputs].time_stamp = currTimeNs;
 801d2fe:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d302:	011b      	lsls	r3, r3, #4
 801d304:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d308:	4413      	add	r3, r2
 801d30a:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d30e:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d312:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d316:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d31a:	3301      	adds	r3, #1
 801d31c:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_PROFILE_PART) &&
 801d320:	68fb      	ldr	r3, [r7, #12]
 801d322:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801d326:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 801d32a:	2b00      	cmp	r3, #0
 801d32c:	d038      	beq.n	801d3a0 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x258>
            (data.status & BME68X_GASM_VALID_MSK))
 801d32e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801d332:	781b      	ldrb	r3, [r3, #0]
 801d334:	f003 0320 	and.w	r3, r3, #32
    if (BSEC_CHECK_INPUT(bmeConf.process_data, BSEC_INPUT_PROFILE_PART) &&
 801d338:	2b00      	cmp	r3, #0
 801d33a:	d031      	beq.n	801d3a0 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x258>
    {
        inputs[nInputs].sensor_id = BSEC_INPUT_PROFILE_PART;
 801d33c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d340:	011b      	lsls	r3, r3, #4
 801d342:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d346:	4413      	add	r3, r2
 801d348:	3b7b      	subs	r3, #123	; 0x7b
 801d34a:	2218      	movs	r2, #24
 801d34c:	701a      	strb	r2, [r3, #0]
        inputs[nInputs].signal = (opMode == BME68X_FORCED_MODE) ? 0 : data.gas_index;
 801d34e:	68fb      	ldr	r3, [r7, #12]
 801d350:	f893 3180 	ldrb.w	r3, [r3, #384]	; 0x180
 801d354:	2b01      	cmp	r3, #1
 801d356:	d007      	beq.n	801d368 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x220>
 801d358:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801d35c:	785b      	ldrb	r3, [r3, #1]
 801d35e:	ee07 3a90 	vmov	s15, r3
 801d362:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801d366:	e001      	b.n	801d36c <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x224>
 801d368:	eddf 7a23 	vldr	s15, [pc, #140]	; 801d3f8 <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x2b0>
 801d36c:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d370:	011b      	lsls	r3, r3, #4
 801d372:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d376:	4413      	add	r3, r2
 801d378:	3b80      	subs	r3, #128	; 0x80
 801d37a:	edc3 7a00 	vstr	s15, [r3]
        inputs[nInputs].time_stamp = currTimeNs;
 801d37e:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d382:	011b      	lsls	r3, r3, #4
 801d384:	f107 0298 	add.w	r2, r7, #152	; 0x98
 801d388:	4413      	add	r3, r2
 801d38a:	f1a3 0188 	sub.w	r1, r3, #136	; 0x88
 801d38e:	e9d7 2300 	ldrd	r2, r3, [r7]
 801d392:	e9c1 2300 	strd	r2, r3, [r1]
        nInputs++;
 801d396:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d39a:	3301      	adds	r3, #1
 801d39c:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
    }

    if (nInputs > 0)
 801d3a0:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
 801d3a4:	2b00      	cmp	r3, #0
 801d3a6:	d021      	beq.n	801d3ec <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x2a4>
    {

        outputs.nOutputs = BSEC_NUMBER_OUTPUTS;
 801d3a8:	68fb      	ldr	r3, [r7, #12]
 801d3aa:	220a      	movs	r2, #10
 801d3ac:	f883 2158 	strb.w	r2, [r3, #344]	; 0x158
        memset(outputs.output, 0, sizeof(outputs.output));
 801d3b0:	68fb      	ldr	r3, [r7, #12]
 801d3b2:	33b8      	adds	r3, #184	; 0xb8
 801d3b4:	22a0      	movs	r2, #160	; 0xa0
 801d3b6:	2100      	movs	r1, #0
 801d3b8:	4618      	mov	r0, r3
 801d3ba:	f00e fe9f 	bl	802c0fc <memset>

        /* Processing of the input signals and returning of output samples is performed by bsec_do_steps() */
        status = bsec_do_steps(inputs, nInputs, outputs.output, &outputs.nOutputs);
 801d3be:	68fb      	ldr	r3, [r7, #12]
 801d3c0:	f103 02b8 	add.w	r2, r3, #184	; 0xb8
 801d3c4:	68fb      	ldr	r3, [r7, #12]
 801d3c6:	f503 73ac 	add.w	r3, r3, #344	; 0x158
 801d3ca:	f897 1097 	ldrb.w	r1, [r7, #151]	; 0x97
 801d3ce:	f107 0010 	add.w	r0, r7, #16
 801d3d2:	f7e2 feff 	bl	80001d4 <bsec_do_steps>
 801d3d6:	4603      	mov	r3, r0
 801d3d8:	461a      	mov	r2, r3
 801d3da:	68fb      	ldr	r3, [r7, #12]
 801d3dc:	751a      	strb	r2, [r3, #20]

        if (status != BSEC_OK)
 801d3de:	68fb      	ldr	r3, [r7, #12]
 801d3e0:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801d3e4:	2b00      	cmp	r3, #0
 801d3e6:	d001      	beq.n	801d3ec <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x2a4>
            return false;
 801d3e8:	2300      	movs	r3, #0
 801d3ea:	e000      	b.n	801d3ee <_ZN15Adafruit_BME68015bsecProcessDataExRK11bme68x_data+0x2a6>

//        if(bsecDataAvailable)
//		bsecDataAvailable(data, outputs);
    }
    return true;
 801d3ec:	2301      	movs	r3, #1
}
 801d3ee:	4618      	mov	r0, r3
 801d3f0:	3798      	adds	r7, #152	; 0x98
 801d3f2:	46bd      	mov	sp, r7
 801d3f4:	bd80      	pop	{r7, pc}
 801d3f6:	bf00      	nop
 801d3f8:	00000000 	.word	0x00000000

0801d3fc <_ZN15Adafruit_BME68021setBme68xConfigForcedEv>:

/**
 * @brief Set the BME68X sensor configuration to forced mode
 */
void Adafruit_BME680::setBme68xConfigForced(void)
{
 801d3fc:	b580      	push	{r7, lr}
 801d3fe:	b082      	sub	sp, #8
 801d400:	af00      	add	r7, sp, #0
 801d402:	6078      	str	r0, [r7, #4]
    /* Set the filter, odr, temperature, pressure and humidity settings */
    setTPH(bmeConf.temperature_oversampling, bmeConf.pressure_oversampling, bmeConf.humidity_oversampling);
 801d404:	687b      	ldr	r3, [r7, #4]
 801d406:	f893 10b3 	ldrb.w	r1, [r3, #179]	; 0xb3
 801d40a:	687b      	ldr	r3, [r7, #4]
 801d40c:	f893 20b2 	ldrb.w	r2, [r3, #178]	; 0xb2
 801d410:	687b      	ldr	r3, [r7, #4]
 801d412:	f893 30b4 	ldrb.w	r3, [r3, #180]	; 0xb4
 801d416:	6878      	ldr	r0, [r7, #4]
 801d418:	f7ff fc59 	bl	801ccce <_ZN15Adafruit_BME6806setTPHEhhh>

    if (checkStatus() == BME68X_ERROR)
 801d41c:	6878      	ldr	r0, [r7, #4]
 801d41e:	f000 f8a3 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d422:	4603      	mov	r3, r0
 801d424:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d428:	bf0c      	ite	eq
 801d42a:	2301      	moveq	r3, #1
 801d42c:	2300      	movne	r3, #0
 801d42e:	b2db      	uxtb	r3, r3
 801d430:	2b00      	cmp	r3, #0
 801d432:	d12a      	bne.n	801d48a <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x8e>
        return;

    setHeaterProf(bmeConf.heater_temperature, bmeConf.heater_duration);
 801d434:	687b      	ldr	r3, [r7, #4]
 801d436:	f8b3 1084 	ldrh.w	r1, [r3, #132]	; 0x84
 801d43a:	687b      	ldr	r3, [r7, #4]
 801d43c:	f8b3 3086 	ldrh.w	r3, [r3, #134]	; 0x86
 801d440:	461a      	mov	r2, r3
 801d442:	6878      	ldr	r0, [r7, #4]
 801d444:	f000 f8c6 	bl	801d5d4 <_ZN15Adafruit_BME68013setHeaterProfEtt>

    if (checkStatus() == BME68X_ERROR)
 801d448:	6878      	ldr	r0, [r7, #4]
 801d44a:	f000 f88d 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d44e:	4603      	mov	r3, r0
 801d450:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d454:	bf0c      	ite	eq
 801d456:	2301      	moveq	r3, #1
 801d458:	2300      	movne	r3, #0
 801d45a:	b2db      	uxtb	r3, r3
 801d45c:	2b00      	cmp	r3, #0
 801d45e:	d116      	bne.n	801d48e <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x92>
        return;

   setOpMode(BME68X_FORCED_MODE);
 801d460:	2101      	movs	r1, #1
 801d462:	6878      	ldr	r0, [r7, #4]
 801d464:	f000 f902 	bl	801d66c <_ZN15Adafruit_BME6809setOpModeEh>
    if (checkStatus() == BME68X_ERROR)
 801d468:	6878      	ldr	r0, [r7, #4]
 801d46a:	f000 f87d 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d46e:	4603      	mov	r3, r0
 801d470:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d474:	bf0c      	ite	eq
 801d476:	2301      	moveq	r3, #1
 801d478:	2300      	movne	r3, #0
 801d47a:	b2db      	uxtb	r3, r3
 801d47c:	2b00      	cmp	r3, #0
 801d47e:	d108      	bne.n	801d492 <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x96>
        return;

    opMode = BME68X_FORCED_MODE;
 801d480:	687b      	ldr	r3, [r7, #4]
 801d482:	2201      	movs	r2, #1
 801d484:	f883 2180 	strb.w	r2, [r3, #384]	; 0x180
 801d488:	e004      	b.n	801d494 <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x98>
        return;
 801d48a:	bf00      	nop
 801d48c:	e002      	b.n	801d494 <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x98>
        return;
 801d48e:	bf00      	nop
 801d490:	e000      	b.n	801d494 <_ZN15Adafruit_BME68021setBme68xConfigForcedEv+0x98>
        return;
 801d492:	bf00      	nop
}
 801d494:	3708      	adds	r7, #8
 801d496:	46bd      	mov	sp, r7
 801d498:	bd80      	pop	{r7, pc}
	...

0801d49c <_ZN15Adafruit_BME68023setBme68xConfigParallelEv>:

/**
 * @brief Set the BME68X sensor configuration to parallel mode
 */
void Adafruit_BME680::setBme68xConfigParallel(void)
{
 801d49c:	b580      	push	{r7, lr}
 801d49e:	b086      	sub	sp, #24
 801d4a0:	af02      	add	r7, sp, #8
 801d4a2:	6078      	str	r0, [r7, #4]
    uint16_t sharedHeaterDur = 0;
 801d4a4:	2300      	movs	r3, #0
 801d4a6:	81fb      	strh	r3, [r7, #14]

    /* Set the filter, odr, temperature, pressure and humidity settings */
    setTPH(bmeConf.temperature_oversampling, bmeConf.pressure_oversampling, bmeConf.humidity_oversampling);
 801d4a8:	687b      	ldr	r3, [r7, #4]
 801d4aa:	f893 10b3 	ldrb.w	r1, [r3, #179]	; 0xb3
 801d4ae:	687b      	ldr	r3, [r7, #4]
 801d4b0:	f893 20b2 	ldrb.w	r2, [r3, #178]	; 0xb2
 801d4b4:	687b      	ldr	r3, [r7, #4]
 801d4b6:	f893 30b4 	ldrb.w	r3, [r3, #180]	; 0xb4
 801d4ba:	6878      	ldr	r0, [r7, #4]
 801d4bc:	f7ff fc07 	bl	801ccce <_ZN15Adafruit_BME6806setTPHEhhh>

    if (checkStatus() == BME68X_ERROR)
 801d4c0:	6878      	ldr	r0, [r7, #4]
 801d4c2:	f000 f851 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d4c6:	4603      	mov	r3, r0
 801d4c8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d4cc:	bf0c      	ite	eq
 801d4ce:	2301      	moveq	r3, #1
 801d4d0:	2300      	movne	r3, #0
 801d4d2:	b2db      	uxtb	r3, r3
 801d4d4:	2b00      	cmp	r3, #0
 801d4d6:	d13c      	bne.n	801d552 <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xb6>
        return;

    sharedHeaterDur = BSEC_TOTAL_HEAT_DUR - (getMeasDur(BME68X_PARALLEL_MODE) / INT64_C(1000));
 801d4d8:	2102      	movs	r1, #2
 801d4da:	6878      	ldr	r0, [r7, #4]
 801d4dc:	f000 f85e 	bl	801d59c <_ZN15Adafruit_BME68010getMeasDurEh>
 801d4e0:	4603      	mov	r3, r0
 801d4e2:	4a20      	ldr	r2, [pc, #128]	; (801d564 <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xc8>)
 801d4e4:	fba2 2303 	umull	r2, r3, r2, r3
 801d4e8:	099b      	lsrs	r3, r3, #6
 801d4ea:	b29b      	uxth	r3, r3
 801d4ec:	f1c3 038c 	rsb	r3, r3, #140	; 0x8c
 801d4f0:	81fb      	strh	r3, [r7, #14]

    setHeaterProf(bmeConf.heater_temperature_profile, bmeConf.heater_duration_profile, sharedHeaterDur,
 801d4f2:	687b      	ldr	r3, [r7, #4]
 801d4f4:	f103 0188 	add.w	r1, r3, #136	; 0x88
 801d4f8:	687b      	ldr	r3, [r7, #4]
 801d4fa:	f103 029c 	add.w	r2, r3, #156	; 0x9c
 801d4fe:	687b      	ldr	r3, [r7, #4]
 801d500:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 801d504:	89f8      	ldrh	r0, [r7, #14]
 801d506:	9300      	str	r3, [sp, #0]
 801d508:	4603      	mov	r3, r0
 801d50a:	6878      	ldr	r0, [r7, #4]
 801d50c:	f000 f885 	bl	801d61a <_ZN15Adafruit_BME68013setHeaterProfEPtS0_th>
            bmeConf.heater_profile_len);

    if (checkStatus() == BME68X_ERROR)
 801d510:	6878      	ldr	r0, [r7, #4]
 801d512:	f000 f829 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d516:	4603      	mov	r3, r0
 801d518:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d51c:	bf0c      	ite	eq
 801d51e:	2301      	moveq	r3, #1
 801d520:	2300      	movne	r3, #0
 801d522:	b2db      	uxtb	r3, r3
 801d524:	2b00      	cmp	r3, #0
 801d526:	d116      	bne.n	801d556 <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xba>
        return;

    setOpMode(BME68X_PARALLEL_MODE);
 801d528:	2102      	movs	r1, #2
 801d52a:	6878      	ldr	r0, [r7, #4]
 801d52c:	f000 f89e 	bl	801d66c <_ZN15Adafruit_BME6809setOpModeEh>

    if (checkStatus() == BME68X_ERROR)
 801d530:	6878      	ldr	r0, [r7, #4]
 801d532:	f000 f819 	bl	801d568 <_ZN15Adafruit_BME68011checkStatusEv>
 801d536:	4603      	mov	r3, r0
 801d538:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 801d53c:	bf0c      	ite	eq
 801d53e:	2301      	moveq	r3, #1
 801d540:	2300      	movne	r3, #0
 801d542:	b2db      	uxtb	r3, r3
 801d544:	2b00      	cmp	r3, #0
 801d546:	d108      	bne.n	801d55a <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xbe>
        return;

    opMode = BME68X_PARALLEL_MODE;
 801d548:	687b      	ldr	r3, [r7, #4]
 801d54a:	2202      	movs	r2, #2
 801d54c:	f883 2180 	strb.w	r2, [r3, #384]	; 0x180
 801d550:	e004      	b.n	801d55c <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xc0>
        return;
 801d552:	bf00      	nop
 801d554:	e002      	b.n	801d55c <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xc0>
        return;
 801d556:	bf00      	nop
 801d558:	e000      	b.n	801d55c <_ZN15Adafruit_BME68023setBme68xConfigParallelEv+0xc0>
        return;
 801d55a:	bf00      	nop
}
 801d55c:	3710      	adds	r7, #16
 801d55e:	46bd      	mov	sp, r7
 801d560:	bd80      	pop	{r7, pc}
 801d562:	bf00      	nop
 801d564:	10624dd3 	.word	0x10624dd3

0801d568 <_ZN15Adafruit_BME68011checkStatusEv>:

/**
 * @brief Function to check if an error / warning has occurred
 */
int8_t Adafruit_BME680::checkStatus(void)
{
 801d568:	b480      	push	{r7}
 801d56a:	b083      	sub	sp, #12
 801d56c:	af00      	add	r7, sp, #0
 801d56e:	6078      	str	r0, [r7, #4]
	if (bme68xStatus < BME68X_OK)
 801d570:	687b      	ldr	r3, [r7, #4]
 801d572:	f993 3015 	ldrsb.w	r3, [r3, #21]
 801d576:	2b00      	cmp	r3, #0
 801d578:	da02      	bge.n	801d580 <_ZN15Adafruit_BME68011checkStatusEv+0x18>
	{
		return BME68X_ERROR;
 801d57a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 801d57e:	e007      	b.n	801d590 <_ZN15Adafruit_BME68011checkStatusEv+0x28>
	}
	else if(bme68xStatus > BME68X_OK)
 801d580:	687b      	ldr	r3, [r7, #4]
 801d582:	f993 3015 	ldrsb.w	r3, [r3, #21]
 801d586:	2b00      	cmp	r3, #0
 801d588:	dd01      	ble.n	801d58e <_ZN15Adafruit_BME68011checkStatusEv+0x26>
	{
		return BME68X_WARNING;
 801d58a:	2301      	movs	r3, #1
 801d58c:	e000      	b.n	801d590 <_ZN15Adafruit_BME68011checkStatusEv+0x28>
	}
	else
	{
		return BME68X_OK;
 801d58e:	2300      	movs	r3, #0
	}
}
 801d590:	4618      	mov	r0, r3
 801d592:	370c      	adds	r7, #12
 801d594:	46bd      	mov	sp, r7
 801d596:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d59a:	4770      	bx	lr

0801d59c <_ZN15Adafruit_BME68010getMeasDurEh>:

/**
 * @brief Function to get the measurement duration in microseconds
 */
uint32_t Adafruit_BME680::getMeasDur(uint8_t opMode)
{
 801d59c:	b580      	push	{r7, lr}
 801d59e:	b082      	sub	sp, #8
 801d5a0:	af00      	add	r7, sp, #0
 801d5a2:	6078      	str	r0, [r7, #4]
 801d5a4:	460b      	mov	r3, r1
 801d5a6:	70fb      	strb	r3, [r7, #3]
	if (opMode == BME68X_SLEEP_MODE)
 801d5a8:	78fb      	ldrb	r3, [r7, #3]
 801d5aa:	2b00      	cmp	r3, #0
 801d5ac:	d103      	bne.n	801d5b6 <_ZN15Adafruit_BME68010getMeasDurEh+0x1a>
		opMode = lastOpMode;
 801d5ae:	687b      	ldr	r3, [r7, #4]
 801d5b0:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
 801d5b4:	70fb      	strb	r3, [r7, #3]

	return bme68x_get_meas_dur(opMode, &gas_conf, &gas_sensor);
 801d5b6:	687b      	ldr	r3, [r7, #4]
 801d5b8:	f503 71ea 	add.w	r1, r3, #468	; 0x1d4
 801d5bc:	687b      	ldr	r3, [r7, #4]
 801d5be:	f503 72c2 	add.w	r2, r3, #388	; 0x184
 801d5c2:	78fb      	ldrb	r3, [r7, #3]
 801d5c4:	4618      	mov	r0, r3
 801d5c6:	f000 fb8f 	bl	801dce8 <bme68x_get_meas_dur>
 801d5ca:	4603      	mov	r3, r0
}
 801d5cc:	4618      	mov	r0, r3
 801d5ce:	3708      	adds	r7, #8
 801d5d0:	46bd      	mov	sp, r7
 801d5d2:	bd80      	pop	{r7, pc}

0801d5d4 <_ZN15Adafruit_BME68013setHeaterProfEtt>:

/**
 * @brief Function to set the heater profile for Forced mode
 */
void Adafruit_BME680::setHeaterProf(uint16_t temp, uint16_t dur)
{
 801d5d4:	b580      	push	{r7, lr}
 801d5d6:	b082      	sub	sp, #8
 801d5d8:	af00      	add	r7, sp, #0
 801d5da:	6078      	str	r0, [r7, #4]
 801d5dc:	460b      	mov	r3, r1
 801d5de:	807b      	strh	r3, [r7, #2]
 801d5e0:	4613      	mov	r3, r2
 801d5e2:	803b      	strh	r3, [r7, #0]
	heatrConf.enable = BME68X_ENABLE;
 801d5e4:	687b      	ldr	r3, [r7, #4]
 801d5e6:	2201      	movs	r2, #1
 801d5e8:	761a      	strb	r2, [r3, #24]
	heatrConf.heatr_temp = temp;
 801d5ea:	687b      	ldr	r3, [r7, #4]
 801d5ec:	887a      	ldrh	r2, [r7, #2]
 801d5ee:	835a      	strh	r2, [r3, #26]
	heatrConf.heatr_dur = dur;
 801d5f0:	687b      	ldr	r3, [r7, #4]
 801d5f2:	883a      	ldrh	r2, [r7, #0]
 801d5f4:	839a      	strh	r2, [r3, #28]

	bme68xStatus = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatrConf, &gas_sensor);
 801d5f6:	687b      	ldr	r3, [r7, #4]
 801d5f8:	f103 0118 	add.w	r1, r3, #24
 801d5fc:	687b      	ldr	r3, [r7, #4]
 801d5fe:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801d602:	461a      	mov	r2, r3
 801d604:	2001      	movs	r0, #1
 801d606:	f000 fce7 	bl	801dfd8 <bme68x_set_heatr_conf>
 801d60a:	4603      	mov	r3, r0
 801d60c:	461a      	mov	r2, r3
 801d60e:	687b      	ldr	r3, [r7, #4]
 801d610:	755a      	strb	r2, [r3, #21]
}
 801d612:	bf00      	nop
 801d614:	3708      	adds	r7, #8
 801d616:	46bd      	mov	sp, r7
 801d618:	bd80      	pop	{r7, pc}

0801d61a <_ZN15Adafruit_BME68013setHeaterProfEPtS0_th>:

/**
 * @brief Function to set the heater profile for Parallel mode
 */
void Adafruit_BME680::setHeaterProf(uint16_t *temp, uint16_t *mul, uint16_t sharedHeatrDur, uint8_t profileLen)
{
 801d61a:	b580      	push	{r7, lr}
 801d61c:	b084      	sub	sp, #16
 801d61e:	af00      	add	r7, sp, #0
 801d620:	60f8      	str	r0, [r7, #12]
 801d622:	60b9      	str	r1, [r7, #8]
 801d624:	607a      	str	r2, [r7, #4]
 801d626:	807b      	strh	r3, [r7, #2]
	heatrConf.enable = BME68X_ENABLE;
 801d628:	68fb      	ldr	r3, [r7, #12]
 801d62a:	2201      	movs	r2, #1
 801d62c:	761a      	strb	r2, [r3, #24]
	heatrConf.heatr_temp_prof = temp;
 801d62e:	68fb      	ldr	r3, [r7, #12]
 801d630:	68ba      	ldr	r2, [r7, #8]
 801d632:	621a      	str	r2, [r3, #32]
	heatrConf.heatr_dur_prof = mul;
 801d634:	68fb      	ldr	r3, [r7, #12]
 801d636:	687a      	ldr	r2, [r7, #4]
 801d638:	625a      	str	r2, [r3, #36]	; 0x24
	heatrConf.shared_heatr_dur = sharedHeatrDur;
 801d63a:	68fb      	ldr	r3, [r7, #12]
 801d63c:	887a      	ldrh	r2, [r7, #2]
 801d63e:	855a      	strh	r2, [r3, #42]	; 0x2a
	heatrConf.profile_len = profileLen;
 801d640:	68fb      	ldr	r3, [r7, #12]
 801d642:	7e3a      	ldrb	r2, [r7, #24]
 801d644:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

	bme68xStatus = bme68x_set_heatr_conf(BME68X_PARALLEL_MODE, &heatrConf, &gas_sensor);
 801d648:	68fb      	ldr	r3, [r7, #12]
 801d64a:	f103 0118 	add.w	r1, r3, #24
 801d64e:	68fb      	ldr	r3, [r7, #12]
 801d650:	f503 73c2 	add.w	r3, r3, #388	; 0x184
 801d654:	461a      	mov	r2, r3
 801d656:	2002      	movs	r0, #2
 801d658:	f000 fcbe 	bl	801dfd8 <bme68x_set_heatr_conf>
 801d65c:	4603      	mov	r3, r0
 801d65e:	461a      	mov	r2, r3
 801d660:	68fb      	ldr	r3, [r7, #12]
 801d662:	755a      	strb	r2, [r3, #21]
}
 801d664:	bf00      	nop
 801d666:	3710      	adds	r7, #16
 801d668:	46bd      	mov	sp, r7
 801d66a:	bd80      	pop	{r7, pc}

0801d66c <_ZN15Adafruit_BME6809setOpModeEh>:

/**
 * @brief Function to set the operation mode
 */
void Adafruit_BME680::setOpMode(uint8_t opMode)
{
 801d66c:	b580      	push	{r7, lr}
 801d66e:	b082      	sub	sp, #8
 801d670:	af00      	add	r7, sp, #0
 801d672:	6078      	str	r0, [r7, #4]
 801d674:	460b      	mov	r3, r1
 801d676:	70fb      	strb	r3, [r7, #3]
	bme68xStatus = bme68x_set_op_mode(opMode, &gas_sensor);
 801d678:	687b      	ldr	r3, [r7, #4]
 801d67a:	f503 72c2 	add.w	r2, r3, #388	; 0x184
 801d67e:	78fb      	ldrb	r3, [r7, #3]
 801d680:	4611      	mov	r1, r2
 801d682:	4618      	mov	r0, r3
 801d684:	f000 faae 	bl	801dbe4 <bme68x_set_op_mode>
 801d688:	4603      	mov	r3, r0
 801d68a:	461a      	mov	r2, r3
 801d68c:	687b      	ldr	r3, [r7, #4]
 801d68e:	755a      	strb	r2, [r3, #21]
	if ((bme68xStatus == BME68X_OK) && (opMode != BME68X_SLEEP_MODE))
 801d690:	687b      	ldr	r3, [r7, #4]
 801d692:	f993 3015 	ldrsb.w	r3, [r3, #21]
 801d696:	2b00      	cmp	r3, #0
 801d698:	d106      	bne.n	801d6a8 <_ZN15Adafruit_BME6809setOpModeEh+0x3c>
 801d69a:	78fb      	ldrb	r3, [r7, #3]
 801d69c:	2b00      	cmp	r3, #0
 801d69e:	d003      	beq.n	801d6a8 <_ZN15Adafruit_BME6809setOpModeEh+0x3c>
		lastOpMode = opMode;
 801d6a0:	687b      	ldr	r3, [r7, #4]
 801d6a2:	78fa      	ldrb	r2, [r7, #3]
 801d6a4:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
}
 801d6a8:	bf00      	nop
 801d6aa:	3708      	adds	r7, #8
 801d6ac:	46bd      	mov	sp, r7
 801d6ae:	bd80      	pop	{r7, pc}

0801d6b0 <bme68x_init>:
/* @brief This API reads the chip-id of the sensor which is the first step to
* verify the sensor and also calibrates the sensor
* As this API is the entry point, call this API before using other APIs.
*/
int8_t bme68x_init(struct bme68x_dev *dev)
{
 801d6b0:	b580      	push	{r7, lr}
 801d6b2:	b084      	sub	sp, #16
 801d6b4:	af00      	add	r7, sp, #0
 801d6b6:	6078      	str	r0, [r7, #4]
    int8_t rslt;

    rslt = bme68x_soft_reset(dev);
 801d6b8:	6878      	ldr	r0, [r7, #4]
 801d6ba:	f000 f904 	bl	801d8c6 <bme68x_soft_reset>
 801d6be:	4603      	mov	r3, r0
 801d6c0:	73fb      	strb	r3, [r7, #15]
    if (rslt == BME68X_OK)
 801d6c2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d6c6:	2b00      	cmp	r3, #0
 801d6c8:	d120      	bne.n	801d70c <bme68x_init+0x5c>
    {
        rslt = bme68x_get_regs(BME68X_REG_CHIP_ID, &dev->chip_id, 1, dev);
 801d6ca:	6879      	ldr	r1, [r7, #4]
 801d6cc:	687b      	ldr	r3, [r7, #4]
 801d6ce:	2201      	movs	r2, #1
 801d6d0:	20d0      	movs	r0, #208	; 0xd0
 801d6d2:	f000 f8b4 	bl	801d83e <bme68x_get_regs>
 801d6d6:	4603      	mov	r3, r0
 801d6d8:	73fb      	strb	r3, [r7, #15]
        if (rslt == BME68X_OK)
 801d6da:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d6de:	2b00      	cmp	r3, #0
 801d6e0:	d114      	bne.n	801d70c <bme68x_init+0x5c>
        {
            if (dev->chip_id == BME68X_CHIP_ID)
 801d6e2:	687b      	ldr	r3, [r7, #4]
 801d6e4:	781b      	ldrb	r3, [r3, #0]
 801d6e6:	2b61      	cmp	r3, #97	; 0x61
 801d6e8:	d10e      	bne.n	801d708 <bme68x_init+0x58>
            {
                /* Read Variant ID */
                rslt = read_variant_id(dev);
 801d6ea:	6878      	ldr	r0, [r7, #4]
 801d6ec:	f002 f8c4 	bl	801f878 <read_variant_id>
 801d6f0:	4603      	mov	r3, r0
 801d6f2:	73fb      	strb	r3, [r7, #15]

                if (rslt == BME68X_OK)
 801d6f4:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d6f8:	2b00      	cmp	r3, #0
 801d6fa:	d107      	bne.n	801d70c <bme68x_init+0x5c>
                {
                    /* Get the Calibration data */
                    rslt = get_calib_data(dev);
 801d6fc:	6878      	ldr	r0, [r7, #4]
 801d6fe:	f001 ffb7 	bl	801f670 <get_calib_data>
 801d702:	4603      	mov	r3, r0
 801d704:	73fb      	strb	r3, [r7, #15]
 801d706:	e001      	b.n	801d70c <bme68x_init+0x5c>
                }
            }
            else
            {
                rslt = BME68X_E_DEV_NOT_FOUND;
 801d708:	23fd      	movs	r3, #253	; 0xfd
 801d70a:	73fb      	strb	r3, [r7, #15]
            }
        }
    }

    return rslt;
 801d70c:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801d710:	4618      	mov	r0, r3
 801d712:	3710      	adds	r7, #16
 801d714:	46bd      	mov	sp, r7
 801d716:	bd80      	pop	{r7, pc}

0801d718 <bme68x_set_regs>:

/*
 * @brief This API writes the given data to the register address of the sensor
 */
int8_t bme68x_set_regs(const uint8_t *reg_addr, const uint8_t *reg_data, uint32_t len, struct bme68x_dev *dev)
{
 801d718:	b5b0      	push	{r4, r5, r7, lr}
 801d71a:	b08a      	sub	sp, #40	; 0x28
 801d71c:	af00      	add	r7, sp, #0
 801d71e:	60f8      	str	r0, [r7, #12]
 801d720:	60b9      	str	r1, [r7, #8]
 801d722:	607a      	str	r2, [r7, #4]
 801d724:	603b      	str	r3, [r7, #0]
    int8_t rslt;

    /* Length of the temporary buffer is 2*(length of register)*/
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
 801d726:	2300      	movs	r3, #0
 801d728:	613b      	str	r3, [r7, #16]
 801d72a:	f107 0314 	add.w	r3, r7, #20
 801d72e:	2200      	movs	r2, #0
 801d730:	601a      	str	r2, [r3, #0]
 801d732:	605a      	str	r2, [r3, #4]
 801d734:	609a      	str	r2, [r3, #8]
 801d736:	60da      	str	r2, [r3, #12]
    uint16_t index;

    /* Check for null pointer in the device structure*/
    rslt = null_ptr_check(dev);
 801d738:	6838      	ldr	r0, [r7, #0]
 801d73a:	f001 fd70 	bl	801f21e <null_ptr_check>
 801d73e:	4603      	mov	r3, r0
 801d740:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if ((rslt == BME68X_OK) && reg_addr && reg_data)
 801d744:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801d748:	2b00      	cmp	r3, #0
 801d74a:	d16f      	bne.n	801d82c <bme68x_set_regs+0x114>
 801d74c:	68fb      	ldr	r3, [r7, #12]
 801d74e:	2b00      	cmp	r3, #0
 801d750:	d06c      	beq.n	801d82c <bme68x_set_regs+0x114>
 801d752:	68bb      	ldr	r3, [r7, #8]
 801d754:	2b00      	cmp	r3, #0
 801d756:	d069      	beq.n	801d82c <bme68x_set_regs+0x114>
    {
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
 801d758:	687b      	ldr	r3, [r7, #4]
 801d75a:	2b00      	cmp	r3, #0
 801d75c:	d060      	beq.n	801d820 <bme68x_set_regs+0x108>
 801d75e:	687b      	ldr	r3, [r7, #4]
 801d760:	2b0a      	cmp	r3, #10
 801d762:	d85d      	bhi.n	801d820 <bme68x_set_regs+0x108>
        {
            /* Interleave the 2 arrays */
            for (index = 0; index < len; index++)
 801d764:	2300      	movs	r3, #0
 801d766:	84bb      	strh	r3, [r7, #36]	; 0x24
 801d768:	e037      	b.n	801d7da <bme68x_set_regs+0xc2>
            {
                if (dev->intf == BME68X_SPI_INTF)
 801d76a:	683b      	ldr	r3, [r7, #0]
 801d76c:	7b1b      	ldrb	r3, [r3, #12]
 801d76e:	2b00      	cmp	r3, #0
 801d770:	d119      	bne.n	801d7a6 <bme68x_set_regs+0x8e>
                {
                    /* Set the memory page */
                    rslt = set_mem_page(reg_addr[index], dev);
 801d772:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d774:	68fa      	ldr	r2, [r7, #12]
 801d776:	4413      	add	r3, r2
 801d778:	781b      	ldrb	r3, [r3, #0]
 801d77a:	6839      	ldr	r1, [r7, #0]
 801d77c:	4618      	mov	r0, r3
 801d77e:	f001 fc8d 	bl	801f09c <set_mem_page>
 801d782:	4603      	mov	r3, r0
 801d784:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
 801d788:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d78a:	68fa      	ldr	r2, [r7, #12]
 801d78c:	4413      	add	r3, r2
 801d78e:	781a      	ldrb	r2, [r3, #0]
 801d790:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d792:	005b      	lsls	r3, r3, #1
 801d794:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 801d798:	b2d2      	uxtb	r2, r2
 801d79a:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801d79e:	440b      	add	r3, r1
 801d7a0:	f803 2c18 	strb.w	r2, [r3, #-24]
 801d7a4:	e00a      	b.n	801d7bc <bme68x_set_regs+0xa4>
                }
                else
                {
                    tmp_buff[(2 * index)] = reg_addr[index];
 801d7a6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7a8:	68fa      	ldr	r2, [r7, #12]
 801d7aa:	441a      	add	r2, r3
 801d7ac:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7ae:	005b      	lsls	r3, r3, #1
 801d7b0:	7812      	ldrb	r2, [r2, #0]
 801d7b2:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801d7b6:	440b      	add	r3, r1
 801d7b8:	f803 2c18 	strb.w	r2, [r3, #-24]
                }

                tmp_buff[(2 * index) + 1] = reg_data[index];
 801d7bc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7be:	68ba      	ldr	r2, [r7, #8]
 801d7c0:	441a      	add	r2, r3
 801d7c2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7c4:	005b      	lsls	r3, r3, #1
 801d7c6:	3301      	adds	r3, #1
 801d7c8:	7812      	ldrb	r2, [r2, #0]
 801d7ca:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801d7ce:	440b      	add	r3, r1
 801d7d0:	f803 2c18 	strb.w	r2, [r3, #-24]
            for (index = 0; index < len; index++)
 801d7d4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7d6:	3301      	adds	r3, #1
 801d7d8:	84bb      	strh	r3, [r7, #36]	; 0x24
 801d7da:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801d7dc:	687a      	ldr	r2, [r7, #4]
 801d7de:	429a      	cmp	r2, r3
 801d7e0:	d8c3      	bhi.n	801d76a <bme68x_set_regs+0x52>
            }

            /* Write the interleaved array */
            if (rslt == BME68X_OK)
 801d7e2:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801d7e6:	2b00      	cmp	r3, #0
 801d7e8:	d11e      	bne.n	801d828 <bme68x_set_regs+0x110>
            {
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
 801d7ea:	683b      	ldr	r3, [r7, #0]
 801d7ec:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 801d7ee:	7c38      	ldrb	r0, [r7, #16]
 801d7f0:	687b      	ldr	r3, [r7, #4]
 801d7f2:	005b      	lsls	r3, r3, #1
 801d7f4:	1e5a      	subs	r2, r3, #1
 801d7f6:	683b      	ldr	r3, [r7, #0]
 801d7f8:	685d      	ldr	r5, [r3, #4]
 801d7fa:	f107 0310 	add.w	r3, r7, #16
 801d7fe:	1c59      	adds	r1, r3, #1
 801d800:	462b      	mov	r3, r5
 801d802:	47a0      	blx	r4
 801d804:	4603      	mov	r3, r0
 801d806:	461a      	mov	r2, r3
 801d808:	683b      	ldr	r3, [r7, #0]
 801d80a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
                if (dev->intf_rslt != 0)
 801d80e:	683b      	ldr	r3, [r7, #0]
 801d810:	f993 304c 	ldrsb.w	r3, [r3, #76]	; 0x4c
 801d814:	2b00      	cmp	r3, #0
 801d816:	d007      	beq.n	801d828 <bme68x_set_regs+0x110>
                {
                    rslt = BME68X_E_COM_FAIL;
 801d818:	23fe      	movs	r3, #254	; 0xfe
 801d81a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
            if (rslt == BME68X_OK)
 801d81e:	e003      	b.n	801d828 <bme68x_set_regs+0x110>
                }
            }
        }
        else
        {
            rslt = BME68X_E_INVALID_LENGTH;
 801d820:	23fc      	movs	r3, #252	; 0xfc
 801d822:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
 801d826:	e004      	b.n	801d832 <bme68x_set_regs+0x11a>
            if (rslt == BME68X_OK)
 801d828:	bf00      	nop
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
 801d82a:	e002      	b.n	801d832 <bme68x_set_regs+0x11a>
        }
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801d82c:	23ff      	movs	r3, #255	; 0xff
 801d82e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }

    return rslt;
 801d832:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
}
 801d836:	4618      	mov	r0, r3
 801d838:	3728      	adds	r7, #40	; 0x28
 801d83a:	46bd      	mov	sp, r7
 801d83c:	bdb0      	pop	{r4, r5, r7, pc}

0801d83e <bme68x_get_regs>:

/*
 * @brief This API reads the data from the given register address of sensor.
 */
int8_t bme68x_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, struct bme68x_dev *dev)
{
 801d83e:	b590      	push	{r4, r7, lr}
 801d840:	b087      	sub	sp, #28
 801d842:	af00      	add	r7, sp, #0
 801d844:	60b9      	str	r1, [r7, #8]
 801d846:	607a      	str	r2, [r7, #4]
 801d848:	603b      	str	r3, [r7, #0]
 801d84a:	4603      	mov	r3, r0
 801d84c:	73fb      	strb	r3, [r7, #15]
    int8_t rslt;

    /* Check for null pointer in the device structure*/
    rslt = null_ptr_check(dev);
 801d84e:	6838      	ldr	r0, [r7, #0]
 801d850:	f001 fce5 	bl	801f21e <null_ptr_check>
 801d854:	4603      	mov	r3, r0
 801d856:	75fb      	strb	r3, [r7, #23]
    if ((rslt == BME68X_OK) && reg_data)
 801d858:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d85c:	2b00      	cmp	r3, #0
 801d85e:	d12a      	bne.n	801d8b6 <bme68x_get_regs+0x78>
 801d860:	68bb      	ldr	r3, [r7, #8]
 801d862:	2b00      	cmp	r3, #0
 801d864:	d027      	beq.n	801d8b6 <bme68x_get_regs+0x78>
    {
        if (dev->intf == BME68X_SPI_INTF)
 801d866:	683b      	ldr	r3, [r7, #0]
 801d868:	7b1b      	ldrb	r3, [r3, #12]
 801d86a:	2b00      	cmp	r3, #0
 801d86c:	d10e      	bne.n	801d88c <bme68x_get_regs+0x4e>
        {
            /* Set the memory page */
            rslt = set_mem_page(reg_addr, dev);
 801d86e:	7bfb      	ldrb	r3, [r7, #15]
 801d870:	6839      	ldr	r1, [r7, #0]
 801d872:	4618      	mov	r0, r3
 801d874:	f001 fc12 	bl	801f09c <set_mem_page>
 801d878:	4603      	mov	r3, r0
 801d87a:	75fb      	strb	r3, [r7, #23]
            if (rslt == BME68X_OK)
 801d87c:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d880:	2b00      	cmp	r3, #0
 801d882:	d103      	bne.n	801d88c <bme68x_get_regs+0x4e>
            {
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
 801d884:	7bfb      	ldrb	r3, [r7, #15]
 801d886:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801d88a:	73fb      	strb	r3, [r7, #15]
            }
        }

        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
 801d88c:	683b      	ldr	r3, [r7, #0]
 801d88e:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801d890:	683b      	ldr	r3, [r7, #0]
 801d892:	685b      	ldr	r3, [r3, #4]
 801d894:	7bf8      	ldrb	r0, [r7, #15]
 801d896:	687a      	ldr	r2, [r7, #4]
 801d898:	68b9      	ldr	r1, [r7, #8]
 801d89a:	47a0      	blx	r4
 801d89c:	4603      	mov	r3, r0
 801d89e:	461a      	mov	r2, r3
 801d8a0:	683b      	ldr	r3, [r7, #0]
 801d8a2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
        if (dev->intf_rslt != 0)
 801d8a6:	683b      	ldr	r3, [r7, #0]
 801d8a8:	f993 304c 	ldrsb.w	r3, [r3, #76]	; 0x4c
 801d8ac:	2b00      	cmp	r3, #0
 801d8ae:	d004      	beq.n	801d8ba <bme68x_get_regs+0x7c>
        {
            rslt = BME68X_E_COM_FAIL;
 801d8b0:	23fe      	movs	r3, #254	; 0xfe
 801d8b2:	75fb      	strb	r3, [r7, #23]
        if (dev->intf_rslt != 0)
 801d8b4:	e001      	b.n	801d8ba <bme68x_get_regs+0x7c>
        }
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801d8b6:	23ff      	movs	r3, #255	; 0xff
 801d8b8:	75fb      	strb	r3, [r7, #23]
    }

    return rslt;
 801d8ba:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 801d8be:	4618      	mov	r0, r3
 801d8c0:	371c      	adds	r7, #28
 801d8c2:	46bd      	mov	sp, r7
 801d8c4:	bd90      	pop	{r4, r7, pc}

0801d8c6 <bme68x_soft_reset>:

/*
 * @brief This API soft-resets the sensor.
 */
int8_t bme68x_soft_reset(struct bme68x_dev *dev)
{
 801d8c6:	b580      	push	{r7, lr}
 801d8c8:	b084      	sub	sp, #16
 801d8ca:	af00      	add	r7, sp, #0
 801d8cc:	6078      	str	r0, [r7, #4]
    int8_t rslt;
    uint8_t reg_addr = BME68X_REG_SOFT_RESET;
 801d8ce:	23e0      	movs	r3, #224	; 0xe0
 801d8d0:	73bb      	strb	r3, [r7, #14]

    /* 0xb6 is the soft reset command */
    uint8_t soft_rst_cmd = BME68X_SOFT_RESET_CMD;
 801d8d2:	23b6      	movs	r3, #182	; 0xb6
 801d8d4:	737b      	strb	r3, [r7, #13]

    /* Check for null pointer in the device structure*/
    rslt = null_ptr_check(dev);
 801d8d6:	6878      	ldr	r0, [r7, #4]
 801d8d8:	f001 fca1 	bl	801f21e <null_ptr_check>
 801d8dc:	4603      	mov	r3, r0
 801d8de:	73fb      	strb	r3, [r7, #15]
    if (rslt == BME68X_OK)
 801d8e0:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d8e4:	2b00      	cmp	r3, #0
 801d8e6:	d12b      	bne.n	801d940 <bme68x_soft_reset+0x7a>
    {
        if (dev->intf == BME68X_SPI_INTF)
 801d8e8:	687b      	ldr	r3, [r7, #4]
 801d8ea:	7b1b      	ldrb	r3, [r3, #12]
 801d8ec:	2b00      	cmp	r3, #0
 801d8ee:	d104      	bne.n	801d8fa <bme68x_soft_reset+0x34>
        {
            rslt = get_mem_page(dev);
 801d8f0:	6878      	ldr	r0, [r7, #4]
 801d8f2:	f001 fc38 	bl	801f166 <get_mem_page>
 801d8f6:	4603      	mov	r3, r0
 801d8f8:	73fb      	strb	r3, [r7, #15]
        }

        /* Reset the device */
        if (rslt == BME68X_OK)
 801d8fa:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d8fe:	2b00      	cmp	r3, #0
 801d900:	d11e      	bne.n	801d940 <bme68x_soft_reset+0x7a>
        {
            rslt = bme68x_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
 801d902:	f107 010d 	add.w	r1, r7, #13
 801d906:	f107 000e 	add.w	r0, r7, #14
 801d90a:	687b      	ldr	r3, [r7, #4]
 801d90c:	2201      	movs	r2, #1
 801d90e:	f7ff ff03 	bl	801d718 <bme68x_set_regs>
 801d912:	4603      	mov	r3, r0
 801d914:	73fb      	strb	r3, [r7, #15]

            /* Wait for 5ms */
            dev->delay_us(BME68X_PERIOD_RESET, dev->intf_ptr);
 801d916:	687b      	ldr	r3, [r7, #4]
 801d918:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d91a:	687a      	ldr	r2, [r7, #4]
 801d91c:	6852      	ldr	r2, [r2, #4]
 801d91e:	4611      	mov	r1, r2
 801d920:	f242 7010 	movw	r0, #10000	; 0x2710
 801d924:	4798      	blx	r3
            if (rslt == BME68X_OK)
 801d926:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d92a:	2b00      	cmp	r3, #0
 801d92c:	d108      	bne.n	801d940 <bme68x_soft_reset+0x7a>
            {
                /* After reset get the memory page */
                if (dev->intf == BME68X_SPI_INTF)
 801d92e:	687b      	ldr	r3, [r7, #4]
 801d930:	7b1b      	ldrb	r3, [r3, #12]
 801d932:	2b00      	cmp	r3, #0
 801d934:	d104      	bne.n	801d940 <bme68x_soft_reset+0x7a>
                {
                    rslt = get_mem_page(dev);
 801d936:	6878      	ldr	r0, [r7, #4]
 801d938:	f001 fc15 	bl	801f166 <get_mem_page>
 801d93c:	4603      	mov	r3, r0
 801d93e:	73fb      	strb	r3, [r7, #15]
                }
            }
        }
    }

    return rslt;
 801d940:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801d944:	4618      	mov	r0, r3
 801d946:	3710      	adds	r7, #16
 801d948:	46bd      	mov	sp, r7
 801d94a:	bd80      	pop	{r7, pc}

0801d94c <bme68x_set_conf>:

/*
 * @brief This API is used to set the oversampling, filter and odr configuration
 */
int8_t bme68x_set_conf(struct bme68x_conf *conf, struct bme68x_dev *dev)
{
 801d94c:	b580      	push	{r7, lr}
 801d94e:	b088      	sub	sp, #32
 801d950:	af00      	add	r7, sp, #0
 801d952:	6078      	str	r0, [r7, #4]
 801d954:	6039      	str	r1, [r7, #0]
    int8_t rslt;
    uint8_t odr20 = 0, odr3 = 1;
 801d956:	2300      	movs	r3, #0
 801d958:	77bb      	strb	r3, [r7, #30]
 801d95a:	2301      	movs	r3, #1
 801d95c:	777b      	strb	r3, [r7, #29]
    uint8_t current_op_mode;

    /* Register data starting from BME68X_REG_CTRL_GAS_1(0x71) up to BME68X_REG_CONFIG(0x75) */
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
 801d95e:	4a7c      	ldr	r2, [pc, #496]	; (801db50 <bme68x_set_conf+0x204>)
 801d960:	f107 0314 	add.w	r3, r7, #20
 801d964:	e892 0003 	ldmia.w	r2, {r0, r1}
 801d968:	6018      	str	r0, [r3, #0]
 801d96a:	3304      	adds	r3, #4
 801d96c:	7019      	strb	r1, [r3, #0]
    uint8_t data_array[BME68X_LEN_CONFIG] = { 0 };
 801d96e:	2300      	movs	r3, #0
 801d970:	60fb      	str	r3, [r7, #12]
 801d972:	2300      	movs	r3, #0
 801d974:	743b      	strb	r3, [r7, #16]

    rslt = bme68x_get_op_mode(&current_op_mode, dev);
 801d976:	f107 031c 	add.w	r3, r7, #28
 801d97a:	6839      	ldr	r1, [r7, #0]
 801d97c:	4618      	mov	r0, r3
 801d97e:	f000 f992 	bl	801dca6 <bme68x_get_op_mode>
 801d982:	4603      	mov	r3, r0
 801d984:	77fb      	strb	r3, [r7, #31]
    if (rslt == BME68X_OK)
 801d986:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801d98a:	2b00      	cmp	r3, #0
 801d98c:	d105      	bne.n	801d99a <bme68x_set_conf+0x4e>
    {
        /* Configure only in the sleep mode */
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 801d98e:	6839      	ldr	r1, [r7, #0]
 801d990:	2000      	movs	r0, #0
 801d992:	f000 f927 	bl	801dbe4 <bme68x_set_op_mode>
 801d996:	4603      	mov	r3, r0
 801d998:	77fb      	strb	r3, [r7, #31]
    }

    if (conf == NULL)
 801d99a:	687b      	ldr	r3, [r7, #4]
 801d99c:	2b00      	cmp	r3, #0
 801d99e:	d102      	bne.n	801d9a6 <bme68x_set_conf+0x5a>
    {
        rslt = BME68X_E_NULL_PTR;
 801d9a0:	23ff      	movs	r3, #255	; 0xff
 801d9a2:	77fb      	strb	r3, [r7, #31]
 801d9a4:	e0b2      	b.n	801db0c <bme68x_set_conf+0x1c0>
    }
    else if (rslt == BME68X_OK)
 801d9a6:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801d9aa:	2b00      	cmp	r3, #0
 801d9ac:	f040 80ae 	bne.w	801db0c <bme68x_set_conf+0x1c0>
    {
        /* Read the whole configuration and write it back once later */
        rslt = bme68x_get_regs(reg_array[0], data_array, BME68X_LEN_CONFIG, dev);
 801d9b0:	7d38      	ldrb	r0, [r7, #20]
 801d9b2:	f107 010c 	add.w	r1, r7, #12
 801d9b6:	683b      	ldr	r3, [r7, #0]
 801d9b8:	2205      	movs	r2, #5
 801d9ba:	f7ff ff40 	bl	801d83e <bme68x_get_regs>
 801d9be:	4603      	mov	r3, r0
 801d9c0:	77fb      	strb	r3, [r7, #31]
        dev->info_msg = BME68X_OK;
 801d9c2:	683b      	ldr	r3, [r7, #0]
 801d9c4:	2200      	movs	r2, #0
 801d9c6:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
        if (rslt == BME68X_OK)
 801d9ca:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801d9ce:	2b00      	cmp	r3, #0
 801d9d0:	d108      	bne.n	801d9e4 <bme68x_set_conf+0x98>
        {
            rslt = boundary_check(&conf->filter, BME68X_FILTER_SIZE_127, dev);
 801d9d2:	687b      	ldr	r3, [r7, #4]
 801d9d4:	3303      	adds	r3, #3
 801d9d6:	683a      	ldr	r2, [r7, #0]
 801d9d8:	2107      	movs	r1, #7
 801d9da:	4618      	mov	r0, r3
 801d9dc:	f001 fbf2 	bl	801f1c4 <boundary_check>
 801d9e0:	4603      	mov	r3, r0
 801d9e2:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801d9e4:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801d9e8:	2b00      	cmp	r3, #0
 801d9ea:	d108      	bne.n	801d9fe <bme68x_set_conf+0xb2>
        {
            rslt = boundary_check(&conf->os_temp, BME68X_OS_16X, dev);
 801d9ec:	687b      	ldr	r3, [r7, #4]
 801d9ee:	3301      	adds	r3, #1
 801d9f0:	683a      	ldr	r2, [r7, #0]
 801d9f2:	2105      	movs	r1, #5
 801d9f4:	4618      	mov	r0, r3
 801d9f6:	f001 fbe5 	bl	801f1c4 <boundary_check>
 801d9fa:	4603      	mov	r3, r0
 801d9fc:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801d9fe:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801da02:	2b00      	cmp	r3, #0
 801da04:	d108      	bne.n	801da18 <bme68x_set_conf+0xcc>
        {
            rslt = boundary_check(&conf->os_pres, BME68X_OS_16X, dev);
 801da06:	687b      	ldr	r3, [r7, #4]
 801da08:	3302      	adds	r3, #2
 801da0a:	683a      	ldr	r2, [r7, #0]
 801da0c:	2105      	movs	r1, #5
 801da0e:	4618      	mov	r0, r3
 801da10:	f001 fbd8 	bl	801f1c4 <boundary_check>
 801da14:	4603      	mov	r3, r0
 801da16:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801da18:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801da1c:	2b00      	cmp	r3, #0
 801da1e:	d107      	bne.n	801da30 <bme68x_set_conf+0xe4>
        {
            rslt = boundary_check(&conf->os_hum, BME68X_OS_16X, dev);
 801da20:	687b      	ldr	r3, [r7, #4]
 801da22:	683a      	ldr	r2, [r7, #0]
 801da24:	2105      	movs	r1, #5
 801da26:	4618      	mov	r0, r3
 801da28:	f001 fbcc 	bl	801f1c4 <boundary_check>
 801da2c:	4603      	mov	r3, r0
 801da2e:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801da30:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801da34:	2b00      	cmp	r3, #0
 801da36:	d108      	bne.n	801da4a <bme68x_set_conf+0xfe>
        {
            rslt = boundary_check(&conf->odr, BME68X_ODR_NONE, dev);
 801da38:	687b      	ldr	r3, [r7, #4]
 801da3a:	3304      	adds	r3, #4
 801da3c:	683a      	ldr	r2, [r7, #0]
 801da3e:	2108      	movs	r1, #8
 801da40:	4618      	mov	r0, r3
 801da42:	f001 fbbf 	bl	801f1c4 <boundary_check>
 801da46:	4603      	mov	r3, r0
 801da48:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801da4a:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801da4e:	2b00      	cmp	r3, #0
 801da50:	d15c      	bne.n	801db0c <bme68x_set_conf+0x1c0>
        {
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
 801da52:	7c3b      	ldrb	r3, [r7, #16]
 801da54:	b25b      	sxtb	r3, r3
 801da56:	f023 031c 	bic.w	r3, r3, #28
 801da5a:	b25a      	sxtb	r2, r3
 801da5c:	687b      	ldr	r3, [r7, #4]
 801da5e:	78db      	ldrb	r3, [r3, #3]
 801da60:	009b      	lsls	r3, r3, #2
 801da62:	b25b      	sxtb	r3, r3
 801da64:	f003 031c 	and.w	r3, r3, #28
 801da68:	b25b      	sxtb	r3, r3
 801da6a:	4313      	orrs	r3, r2
 801da6c:	b25b      	sxtb	r3, r3
 801da6e:	b2db      	uxtb	r3, r3
 801da70:	743b      	strb	r3, [r7, #16]
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OST, conf->os_temp);
 801da72:	7bfb      	ldrb	r3, [r7, #15]
 801da74:	b25b      	sxtb	r3, r3
 801da76:	f003 031f 	and.w	r3, r3, #31
 801da7a:	b25a      	sxtb	r2, r3
 801da7c:	687b      	ldr	r3, [r7, #4]
 801da7e:	785b      	ldrb	r3, [r3, #1]
 801da80:	015b      	lsls	r3, r3, #5
 801da82:	b25b      	sxtb	r3, r3
 801da84:	4313      	orrs	r3, r2
 801da86:	b25b      	sxtb	r3, r3
 801da88:	b2db      	uxtb	r3, r3
 801da8a:	73fb      	strb	r3, [r7, #15]
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OSP, conf->os_pres);
 801da8c:	7bfb      	ldrb	r3, [r7, #15]
 801da8e:	b25b      	sxtb	r3, r3
 801da90:	f023 031c 	bic.w	r3, r3, #28
 801da94:	b25a      	sxtb	r2, r3
 801da96:	687b      	ldr	r3, [r7, #4]
 801da98:	789b      	ldrb	r3, [r3, #2]
 801da9a:	009b      	lsls	r3, r3, #2
 801da9c:	b25b      	sxtb	r3, r3
 801da9e:	f003 031c 	and.w	r3, r3, #28
 801daa2:	b25b      	sxtb	r3, r3
 801daa4:	4313      	orrs	r3, r2
 801daa6:	b25b      	sxtb	r3, r3
 801daa8:	b2db      	uxtb	r3, r3
 801daaa:	73fb      	strb	r3, [r7, #15]
            data_array[1] = BME68X_SET_BITS_POS_0(data_array[1], BME68X_OSH, conf->os_hum);
 801daac:	7b7b      	ldrb	r3, [r7, #13]
 801daae:	b25b      	sxtb	r3, r3
 801dab0:	f023 0307 	bic.w	r3, r3, #7
 801dab4:	b25a      	sxtb	r2, r3
 801dab6:	687b      	ldr	r3, [r7, #4]
 801dab8:	781b      	ldrb	r3, [r3, #0]
 801daba:	b25b      	sxtb	r3, r3
 801dabc:	f003 0307 	and.w	r3, r3, #7
 801dac0:	b25b      	sxtb	r3, r3
 801dac2:	4313      	orrs	r3, r2
 801dac4:	b25b      	sxtb	r3, r3
 801dac6:	b2db      	uxtb	r3, r3
 801dac8:	737b      	strb	r3, [r7, #13]
            if (conf->odr != BME68X_ODR_NONE)
 801daca:	687b      	ldr	r3, [r7, #4]
 801dacc:	791b      	ldrb	r3, [r3, #4]
 801dace:	2b08      	cmp	r3, #8
 801dad0:	d004      	beq.n	801dadc <bme68x_set_conf+0x190>
            {
                odr20 = conf->odr;
 801dad2:	687b      	ldr	r3, [r7, #4]
 801dad4:	791b      	ldrb	r3, [r3, #4]
 801dad6:	77bb      	strb	r3, [r7, #30]
                odr3 = 0;
 801dad8:	2300      	movs	r3, #0
 801dada:	777b      	strb	r3, [r7, #29]
            }

            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_ODR20, odr20);
 801dadc:	7c3b      	ldrb	r3, [r7, #16]
 801dade:	b25b      	sxtb	r3, r3
 801dae0:	f003 031f 	and.w	r3, r3, #31
 801dae4:	b25a      	sxtb	r2, r3
 801dae6:	7fbb      	ldrb	r3, [r7, #30]
 801dae8:	015b      	lsls	r3, r3, #5
 801daea:	b25b      	sxtb	r3, r3
 801daec:	4313      	orrs	r3, r2
 801daee:	b25b      	sxtb	r3, r3
 801daf0:	b2db      	uxtb	r3, r3
 801daf2:	743b      	strb	r3, [r7, #16]
            data_array[0] = BME68X_SET_BITS(data_array[0], BME68X_ODR3, odr3);
 801daf4:	7b3b      	ldrb	r3, [r7, #12]
 801daf6:	b25b      	sxtb	r3, r3
 801daf8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801dafc:	b25a      	sxtb	r2, r3
 801dafe:	7f7b      	ldrb	r3, [r7, #29]
 801db00:	01db      	lsls	r3, r3, #7
 801db02:	b25b      	sxtb	r3, r3
 801db04:	4313      	orrs	r3, r2
 801db06:	b25b      	sxtb	r3, r3
 801db08:	b2db      	uxtb	r3, r3
 801db0a:	733b      	strb	r3, [r7, #12]
        }
    }

    if (rslt == BME68X_OK)
 801db0c:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801db10:	2b00      	cmp	r3, #0
 801db12:	d109      	bne.n	801db28 <bme68x_set_conf+0x1dc>
    {
        rslt = bme68x_set_regs(reg_array, data_array, BME68X_LEN_CONFIG, dev);
 801db14:	f107 010c 	add.w	r1, r7, #12
 801db18:	f107 0014 	add.w	r0, r7, #20
 801db1c:	683b      	ldr	r3, [r7, #0]
 801db1e:	2205      	movs	r2, #5
 801db20:	f7ff fdfa 	bl	801d718 <bme68x_set_regs>
 801db24:	4603      	mov	r3, r0
 801db26:	77fb      	strb	r3, [r7, #31]
    }

    if ((current_op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
 801db28:	7f3b      	ldrb	r3, [r7, #28]
 801db2a:	2b00      	cmp	r3, #0
 801db2c:	d00a      	beq.n	801db44 <bme68x_set_conf+0x1f8>
 801db2e:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801db32:	2b00      	cmp	r3, #0
 801db34:	d106      	bne.n	801db44 <bme68x_set_conf+0x1f8>
    {
        rslt = bme68x_set_op_mode(current_op_mode, dev);
 801db36:	7f3b      	ldrb	r3, [r7, #28]
 801db38:	6839      	ldr	r1, [r7, #0]
 801db3a:	4618      	mov	r0, r3
 801db3c:	f000 f852 	bl	801dbe4 <bme68x_set_op_mode>
 801db40:	4603      	mov	r3, r0
 801db42:	77fb      	strb	r3, [r7, #31]
    }

    return rslt;
 801db44:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 801db48:	4618      	mov	r0, r3
 801db4a:	3720      	adds	r7, #32
 801db4c:	46bd      	mov	sp, r7
 801db4e:	bd80      	pop	{r7, pc}
 801db50:	0802c578 	.word	0x0802c578

0801db54 <bme68x_get_conf>:

/*
 * @brief This API is used to get the oversampling, filter and odr
 */
int8_t bme68x_get_conf(struct bme68x_conf *conf, struct bme68x_dev *dev)
{
 801db54:	b580      	push	{r7, lr}
 801db56:	b084      	sub	sp, #16
 801db58:	af00      	add	r7, sp, #0
 801db5a:	6078      	str	r0, [r7, #4]
 801db5c:	6039      	str	r1, [r7, #0]
    int8_t rslt;

    /* starting address of the register array for burst read*/
    uint8_t reg_addr = BME68X_REG_CTRL_GAS_1;
 801db5e:	2371      	movs	r3, #113	; 0x71
 801db60:	73bb      	strb	r3, [r7, #14]
    uint8_t data_array[BME68X_LEN_CONFIG];

    rslt = bme68x_get_regs(reg_addr, data_array, 5, dev);
 801db62:	f107 0108 	add.w	r1, r7, #8
 801db66:	7bb8      	ldrb	r0, [r7, #14]
 801db68:	683b      	ldr	r3, [r7, #0]
 801db6a:	2205      	movs	r2, #5
 801db6c:	f7ff fe67 	bl	801d83e <bme68x_get_regs>
 801db70:	4603      	mov	r3, r0
 801db72:	73fb      	strb	r3, [r7, #15]
    if (!conf)
 801db74:	687b      	ldr	r3, [r7, #4]
 801db76:	2b00      	cmp	r3, #0
 801db78:	d102      	bne.n	801db80 <bme68x_get_conf+0x2c>
    {
        rslt = BME68X_E_NULL_PTR;
 801db7a:	23ff      	movs	r3, #255	; 0xff
 801db7c:	73fb      	strb	r3, [r7, #15]
 801db7e:	e02b      	b.n	801dbd8 <bme68x_get_conf+0x84>
    }
    else if (rslt == BME68X_OK)
 801db80:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801db84:	2b00      	cmp	r3, #0
 801db86:	d127      	bne.n	801dbd8 <bme68x_get_conf+0x84>
    {
        conf->os_hum = BME68X_GET_BITS_POS_0(data_array[1], BME68X_OSH);
 801db88:	7a7b      	ldrb	r3, [r7, #9]
 801db8a:	f003 0307 	and.w	r3, r3, #7
 801db8e:	b2da      	uxtb	r2, r3
 801db90:	687b      	ldr	r3, [r7, #4]
 801db92:	701a      	strb	r2, [r3, #0]
        conf->filter = BME68X_GET_BITS(data_array[4], BME68X_FILTER);
 801db94:	7b3b      	ldrb	r3, [r7, #12]
 801db96:	109b      	asrs	r3, r3, #2
 801db98:	b2db      	uxtb	r3, r3
 801db9a:	f003 0307 	and.w	r3, r3, #7
 801db9e:	b2da      	uxtb	r2, r3
 801dba0:	687b      	ldr	r3, [r7, #4]
 801dba2:	70da      	strb	r2, [r3, #3]
        conf->os_temp = BME68X_GET_BITS(data_array[3], BME68X_OST);
 801dba4:	7afb      	ldrb	r3, [r7, #11]
 801dba6:	095b      	lsrs	r3, r3, #5
 801dba8:	b2da      	uxtb	r2, r3
 801dbaa:	687b      	ldr	r3, [r7, #4]
 801dbac:	705a      	strb	r2, [r3, #1]
        conf->os_pres = BME68X_GET_BITS(data_array[3], BME68X_OSP);
 801dbae:	7afb      	ldrb	r3, [r7, #11]
 801dbb0:	109b      	asrs	r3, r3, #2
 801dbb2:	b2db      	uxtb	r3, r3
 801dbb4:	f003 0307 	and.w	r3, r3, #7
 801dbb8:	b2da      	uxtb	r2, r3
 801dbba:	687b      	ldr	r3, [r7, #4]
 801dbbc:	709a      	strb	r2, [r3, #2]
        if (BME68X_GET_BITS(data_array[0], BME68X_ODR3))
 801dbbe:	7a3b      	ldrb	r3, [r7, #8]
 801dbc0:	b25b      	sxtb	r3, r3
 801dbc2:	2b00      	cmp	r3, #0
 801dbc4:	da03      	bge.n	801dbce <bme68x_get_conf+0x7a>
        {
            conf->odr = BME68X_ODR_NONE;
 801dbc6:	687b      	ldr	r3, [r7, #4]
 801dbc8:	2208      	movs	r2, #8
 801dbca:	711a      	strb	r2, [r3, #4]
 801dbcc:	e004      	b.n	801dbd8 <bme68x_get_conf+0x84>
        }
        else
        {
            conf->odr = BME68X_GET_BITS(data_array[4], BME68X_ODR20);
 801dbce:	7b3b      	ldrb	r3, [r7, #12]
 801dbd0:	095b      	lsrs	r3, r3, #5
 801dbd2:	b2da      	uxtb	r2, r3
 801dbd4:	687b      	ldr	r3, [r7, #4]
 801dbd6:	711a      	strb	r2, [r3, #4]
        }
    }

    return rslt;
 801dbd8:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801dbdc:	4618      	mov	r0, r3
 801dbde:	3710      	adds	r7, #16
 801dbe0:	46bd      	mov	sp, r7
 801dbe2:	bd80      	pop	{r7, pc}

0801dbe4 <bme68x_set_op_mode>:

/*
 * @brief This API is used to set the operation mode of the sensor
 */
int8_t bme68x_set_op_mode(const uint8_t op_mode, struct bme68x_dev *dev)
{
 801dbe4:	b580      	push	{r7, lr}
 801dbe6:	b084      	sub	sp, #16
 801dbe8:	af00      	add	r7, sp, #0
 801dbea:	4603      	mov	r3, r0
 801dbec:	6039      	str	r1, [r7, #0]
 801dbee:	71fb      	strb	r3, [r7, #7]
    int8_t rslt;
    uint8_t tmp_pow_mode;
    uint8_t pow_mode = 0;
 801dbf0:	2300      	movs	r3, #0
 801dbf2:	73bb      	strb	r3, [r7, #14]
    uint8_t reg_addr = BME68X_REG_CTRL_MEAS;
 801dbf4:	2374      	movs	r3, #116	; 0x74
 801dbf6:	733b      	strb	r3, [r7, #12]

    /* Call until in sleep */
    do
    {
        rslt = bme68x_get_regs(BME68X_REG_CTRL_MEAS, &tmp_pow_mode, 1, dev);
 801dbf8:	f107 010d 	add.w	r1, r7, #13
 801dbfc:	683b      	ldr	r3, [r7, #0]
 801dbfe:	2201      	movs	r2, #1
 801dc00:	2074      	movs	r0, #116	; 0x74
 801dc02:	f7ff fe1c 	bl	801d83e <bme68x_get_regs>
 801dc06:	4603      	mov	r3, r0
 801dc08:	73fb      	strb	r3, [r7, #15]
        if (rslt == BME68X_OK)
 801dc0a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801dc0e:	2b00      	cmp	r3, #0
 801dc10:	d11d      	bne.n	801dc4e <bme68x_set_op_mode+0x6a>
        {
            /* Put to sleep before changing mode */
            pow_mode = (tmp_pow_mode & BME68X_MODE_MSK);
 801dc12:	7b7b      	ldrb	r3, [r7, #13]
 801dc14:	f003 0303 	and.w	r3, r3, #3
 801dc18:	73bb      	strb	r3, [r7, #14]
            if (pow_mode != BME68X_SLEEP_MODE)
 801dc1a:	7bbb      	ldrb	r3, [r7, #14]
 801dc1c:	2b00      	cmp	r3, #0
 801dc1e:	d016      	beq.n	801dc4e <bme68x_set_op_mode+0x6a>
            {
                tmp_pow_mode &= ~BME68X_MODE_MSK; /* Set to sleep */
 801dc20:	7b7b      	ldrb	r3, [r7, #13]
 801dc22:	f023 0303 	bic.w	r3, r3, #3
 801dc26:	b2db      	uxtb	r3, r3
 801dc28:	737b      	strb	r3, [r7, #13]
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 801dc2a:	f107 010d 	add.w	r1, r7, #13
 801dc2e:	f107 000c 	add.w	r0, r7, #12
 801dc32:	683b      	ldr	r3, [r7, #0]
 801dc34:	2201      	movs	r2, #1
 801dc36:	f7ff fd6f 	bl	801d718 <bme68x_set_regs>
 801dc3a:	4603      	mov	r3, r0
 801dc3c:	73fb      	strb	r3, [r7, #15]
                dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 801dc3e:	683b      	ldr	r3, [r7, #0]
 801dc40:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801dc42:	683a      	ldr	r2, [r7, #0]
 801dc44:	6852      	ldr	r2, [r2, #4]
 801dc46:	4611      	mov	r1, r2
 801dc48:	f242 7010 	movw	r0, #10000	; 0x2710
 801dc4c:	4798      	blx	r3
            }
        }
    } while ((pow_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK));
 801dc4e:	7bbb      	ldrb	r3, [r7, #14]
 801dc50:	2b00      	cmp	r3, #0
 801dc52:	d003      	beq.n	801dc5c <bme68x_set_op_mode+0x78>
 801dc54:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801dc58:	2b00      	cmp	r3, #0
 801dc5a:	d0cd      	beq.n	801dbf8 <bme68x_set_op_mode+0x14>

    /* Already in sleep */
    if ((op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
 801dc5c:	79fb      	ldrb	r3, [r7, #7]
 801dc5e:	2b00      	cmp	r3, #0
 801dc60:	d01b      	beq.n	801dc9a <bme68x_set_op_mode+0xb6>
 801dc62:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801dc66:	2b00      	cmp	r3, #0
 801dc68:	d117      	bne.n	801dc9a <bme68x_set_op_mode+0xb6>
    {
        tmp_pow_mode = (tmp_pow_mode & ~BME68X_MODE_MSK) | (op_mode & BME68X_MODE_MSK);
 801dc6a:	7b7b      	ldrb	r3, [r7, #13]
 801dc6c:	b25b      	sxtb	r3, r3
 801dc6e:	f023 0303 	bic.w	r3, r3, #3
 801dc72:	b25a      	sxtb	r2, r3
 801dc74:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801dc78:	f003 0303 	and.w	r3, r3, #3
 801dc7c:	b25b      	sxtb	r3, r3
 801dc7e:	4313      	orrs	r3, r2
 801dc80:	b25b      	sxtb	r3, r3
 801dc82:	b2db      	uxtb	r3, r3
 801dc84:	737b      	strb	r3, [r7, #13]
        rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
 801dc86:	f107 010d 	add.w	r1, r7, #13
 801dc8a:	f107 000c 	add.w	r0, r7, #12
 801dc8e:	683b      	ldr	r3, [r7, #0]
 801dc90:	2201      	movs	r2, #1
 801dc92:	f7ff fd41 	bl	801d718 <bme68x_set_regs>
 801dc96:	4603      	mov	r3, r0
 801dc98:	73fb      	strb	r3, [r7, #15]
    }

    return rslt;
 801dc9a:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801dc9e:	4618      	mov	r0, r3
 801dca0:	3710      	adds	r7, #16
 801dca2:	46bd      	mov	sp, r7
 801dca4:	bd80      	pop	{r7, pc}

0801dca6 <bme68x_get_op_mode>:

/*
 * @brief This API is used to get the operation mode of the sensor.
 */
int8_t bme68x_get_op_mode(uint8_t *op_mode, struct bme68x_dev *dev)
{
 801dca6:	b580      	push	{r7, lr}
 801dca8:	b084      	sub	sp, #16
 801dcaa:	af00      	add	r7, sp, #0
 801dcac:	6078      	str	r0, [r7, #4]
 801dcae:	6039      	str	r1, [r7, #0]
    int8_t rslt;
    uint8_t mode;

    if (op_mode)
 801dcb0:	687b      	ldr	r3, [r7, #4]
 801dcb2:	2b00      	cmp	r3, #0
 801dcb4:	d00f      	beq.n	801dcd6 <bme68x_get_op_mode+0x30>
    {
        rslt = bme68x_get_regs(BME68X_REG_CTRL_MEAS, &mode, 1, dev);
 801dcb6:	f107 010e 	add.w	r1, r7, #14
 801dcba:	683b      	ldr	r3, [r7, #0]
 801dcbc:	2201      	movs	r2, #1
 801dcbe:	2074      	movs	r0, #116	; 0x74
 801dcc0:	f7ff fdbd 	bl	801d83e <bme68x_get_regs>
 801dcc4:	4603      	mov	r3, r0
 801dcc6:	73fb      	strb	r3, [r7, #15]

        /* Masking the other register bit info*/
        *op_mode = mode & BME68X_MODE_MSK;
 801dcc8:	7bbb      	ldrb	r3, [r7, #14]
 801dcca:	f003 0303 	and.w	r3, r3, #3
 801dcce:	b2da      	uxtb	r2, r3
 801dcd0:	687b      	ldr	r3, [r7, #4]
 801dcd2:	701a      	strb	r2, [r3, #0]
 801dcd4:	e001      	b.n	801dcda <bme68x_get_op_mode+0x34>
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801dcd6:	23ff      	movs	r3, #255	; 0xff
 801dcd8:	73fb      	strb	r3, [r7, #15]
    }

    return rslt;
 801dcda:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801dcde:	4618      	mov	r0, r3
 801dce0:	3710      	adds	r7, #16
 801dce2:	46bd      	mov	sp, r7
 801dce4:	bd80      	pop	{r7, pc}
	...

0801dce8 <bme68x_get_meas_dur>:

/*
 * @brief This API is used to get the remaining duration that can be used for heating.
 */
uint32_t bme68x_get_meas_dur(const uint8_t op_mode, struct bme68x_conf *conf, struct bme68x_dev *dev)
{
 801dce8:	b580      	push	{r7, lr}
 801dcea:	b08a      	sub	sp, #40	; 0x28
 801dcec:	af00      	add	r7, sp, #0
 801dcee:	4603      	mov	r3, r0
 801dcf0:	60b9      	str	r1, [r7, #8]
 801dcf2:	607a      	str	r2, [r7, #4]
 801dcf4:	73fb      	strb	r3, [r7, #15]
    int8_t rslt;
    uint32_t meas_dur = 0; /* Calculate in us */
 801dcf6:	2300      	movs	r3, #0
 801dcf8:	623b      	str	r3, [r7, #32]
    uint32_t meas_cycles;
    uint8_t os_to_meas_cycles[6] = { 0, 1, 2, 4, 8, 16 };
 801dcfa:	4a36      	ldr	r2, [pc, #216]	; (801ddd4 <bme68x_get_meas_dur+0xec>)
 801dcfc:	f107 0314 	add.w	r3, r7, #20
 801dd00:	e892 0003 	ldmia.w	r2, {r0, r1}
 801dd04:	6018      	str	r0, [r3, #0]
 801dd06:	3304      	adds	r3, #4
 801dd08:	8019      	strh	r1, [r3, #0]

    if (conf != NULL)
 801dd0a:	68bb      	ldr	r3, [r7, #8]
 801dd0c:	2b00      	cmp	r3, #0
 801dd0e:	d05b      	beq.n	801ddc8 <bme68x_get_meas_dur+0xe0>
    {
        /* Boundary check for temperature oversampling */
        rslt = boundary_check(&conf->os_temp, BME68X_OS_16X, dev);
 801dd10:	68bb      	ldr	r3, [r7, #8]
 801dd12:	3301      	adds	r3, #1
 801dd14:	687a      	ldr	r2, [r7, #4]
 801dd16:	2105      	movs	r1, #5
 801dd18:	4618      	mov	r0, r3
 801dd1a:	f001 fa53 	bl	801f1c4 <boundary_check>
 801dd1e:	4603      	mov	r3, r0
 801dd20:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

        if (rslt == BME68X_OK)
 801dd24:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801dd28:	2b00      	cmp	r3, #0
 801dd2a:	d109      	bne.n	801dd40 <bme68x_get_meas_dur+0x58>
        {
            /* Boundary check for pressure oversampling */
            rslt = boundary_check(&conf->os_pres, BME68X_OS_16X, dev);
 801dd2c:	68bb      	ldr	r3, [r7, #8]
 801dd2e:	3302      	adds	r3, #2
 801dd30:	687a      	ldr	r2, [r7, #4]
 801dd32:	2105      	movs	r1, #5
 801dd34:	4618      	mov	r0, r3
 801dd36:	f001 fa45 	bl	801f1c4 <boundary_check>
 801dd3a:	4603      	mov	r3, r0
 801dd3c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        }

        if (rslt == BME68X_OK)
 801dd40:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801dd44:	2b00      	cmp	r3, #0
 801dd46:	d108      	bne.n	801dd5a <bme68x_get_meas_dur+0x72>
        {
            /* Boundary check for humidity oversampling */
            rslt = boundary_check(&conf->os_hum, BME68X_OS_16X, dev);
 801dd48:	68bb      	ldr	r3, [r7, #8]
 801dd4a:	687a      	ldr	r2, [r7, #4]
 801dd4c:	2105      	movs	r1, #5
 801dd4e:	4618      	mov	r0, r3
 801dd50:	f001 fa38 	bl	801f1c4 <boundary_check>
 801dd54:	4603      	mov	r3, r0
 801dd56:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        }

        if (rslt == BME68X_OK)
 801dd5a:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801dd5e:	2b00      	cmp	r3, #0
 801dd60:	d132      	bne.n	801ddc8 <bme68x_get_meas_dur+0xe0>
        {
            meas_cycles = os_to_meas_cycles[conf->os_temp];
 801dd62:	68bb      	ldr	r3, [r7, #8]
 801dd64:	785b      	ldrb	r3, [r3, #1]
 801dd66:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801dd6a:	4413      	add	r3, r2
 801dd6c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
 801dd70:	61fb      	str	r3, [r7, #28]
            meas_cycles += os_to_meas_cycles[conf->os_pres];
 801dd72:	68bb      	ldr	r3, [r7, #8]
 801dd74:	789b      	ldrb	r3, [r3, #2]
 801dd76:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801dd7a:	4413      	add	r3, r2
 801dd7c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
 801dd80:	461a      	mov	r2, r3
 801dd82:	69fb      	ldr	r3, [r7, #28]
 801dd84:	4413      	add	r3, r2
 801dd86:	61fb      	str	r3, [r7, #28]
            meas_cycles += os_to_meas_cycles[conf->os_hum];
 801dd88:	68bb      	ldr	r3, [r7, #8]
 801dd8a:	781b      	ldrb	r3, [r3, #0]
 801dd8c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 801dd90:	4413      	add	r3, r2
 801dd92:	f813 3c14 	ldrb.w	r3, [r3, #-20]
 801dd96:	461a      	mov	r2, r3
 801dd98:	69fb      	ldr	r3, [r7, #28]
 801dd9a:	4413      	add	r3, r2
 801dd9c:	61fb      	str	r3, [r7, #28]

            /* TPH measurement duration */
            meas_dur = meas_cycles * UINT32_C(1963);
 801dd9e:	69fb      	ldr	r3, [r7, #28]
 801dda0:	f240 72ab 	movw	r2, #1963	; 0x7ab
 801dda4:	fb02 f303 	mul.w	r3, r2, r3
 801dda8:	623b      	str	r3, [r7, #32]
            meas_dur += UINT32_C(477 * 4); /* TPH switching duration */
 801ddaa:	6a3b      	ldr	r3, [r7, #32]
 801ddac:	f203 7374 	addw	r3, r3, #1908	; 0x774
 801ddb0:	623b      	str	r3, [r7, #32]
            meas_dur += UINT32_C(477 * 5); /* Gas measurement duration */
 801ddb2:	6a3b      	ldr	r3, [r7, #32]
 801ddb4:	f603 1351 	addw	r3, r3, #2385	; 0x951
 801ddb8:	623b      	str	r3, [r7, #32]

            if (op_mode != BME68X_PARALLEL_MODE)
 801ddba:	7bfb      	ldrb	r3, [r7, #15]
 801ddbc:	2b02      	cmp	r3, #2
 801ddbe:	d003      	beq.n	801ddc8 <bme68x_get_meas_dur+0xe0>
            {
                meas_dur += UINT32_C(1000); /* Wake up duration of 1ms */
 801ddc0:	6a3b      	ldr	r3, [r7, #32]
 801ddc2:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 801ddc6:	623b      	str	r3, [r7, #32]
            }
        }
    }

    return meas_dur;
 801ddc8:	6a3b      	ldr	r3, [r7, #32]
}
 801ddca:	4618      	mov	r0, r3
 801ddcc:	3728      	adds	r7, #40	; 0x28
 801ddce:	46bd      	mov	sp, r7
 801ddd0:	bd80      	pop	{r7, pc}
 801ddd2:	bf00      	nop
 801ddd4:	0802c580 	.word	0x0802c580

0801ddd8 <bme68x_get_data>:
 * @brief This API reads the pressure, temperature and humidity and gas data
 * from the sensor, compensates the data and store it in the bme68x_data
 * structure instance passed by the user.
 */
int8_t bme68x_get_data(uint8_t op_mode, struct bme68x_data *data, uint8_t *n_data, struct bme68x_dev *dev)
{
 801ddd8:	b5b0      	push	{r4, r5, r7, lr}
 801ddda:	b09a      	sub	sp, #104	; 0x68
 801dddc:	af00      	add	r7, sp, #0
 801ddde:	60b9      	str	r1, [r7, #8]
 801dde0:	607a      	str	r2, [r7, #4]
 801dde2:	603b      	str	r3, [r7, #0]
 801dde4:	4603      	mov	r3, r0
 801dde6:	73fb      	strb	r3, [r7, #15]
    int8_t rslt;
    uint8_t i = 0, j = 0, new_fields = 0;
 801dde8:	2300      	movs	r3, #0
 801ddea:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801ddee:	2300      	movs	r3, #0
 801ddf0:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 801ddf4:	2300      	movs	r3, #0
 801ddf6:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
    struct bme68x_data *field_ptr[3] = { 0 };
 801ddfa:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801ddfe:	2200      	movs	r2, #0
 801de00:	601a      	str	r2, [r3, #0]
 801de02:	605a      	str	r2, [r3, #4]
 801de04:	609a      	str	r2, [r3, #8]
    struct bme68x_data field_data[3] = { { 0 } };
 801de06:	f107 0310 	add.w	r3, r7, #16
 801de0a:	2248      	movs	r2, #72	; 0x48
 801de0c:	2100      	movs	r1, #0
 801de0e:	4618      	mov	r0, r3
 801de10:	f00e f974 	bl	802c0fc <memset>

    field_ptr[0] = &field_data[0];
 801de14:	f107 0310 	add.w	r3, r7, #16
 801de18:	65bb      	str	r3, [r7, #88]	; 0x58
    field_ptr[1] = &field_data[1];
 801de1a:	f107 0310 	add.w	r3, r7, #16
 801de1e:	3318      	adds	r3, #24
 801de20:	65fb      	str	r3, [r7, #92]	; 0x5c
    field_ptr[2] = &field_data[2];
 801de22:	f107 0310 	add.w	r3, r7, #16
 801de26:	3330      	adds	r3, #48	; 0x30
 801de28:	663b      	str	r3, [r7, #96]	; 0x60

    rslt = null_ptr_check(dev);
 801de2a:	6838      	ldr	r0, [r7, #0]
 801de2c:	f001 f9f7 	bl	801f21e <null_ptr_check>
 801de30:	4603      	mov	r3, r0
 801de32:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
    if ((rslt == BME68X_OK) && (data != NULL))
 801de36:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
 801de3a:	2b00      	cmp	r3, #0
 801de3c:	f040 80c3 	bne.w	801dfc6 <bme68x_get_data+0x1ee>
 801de40:	68bb      	ldr	r3, [r7, #8]
 801de42:	2b00      	cmp	r3, #0
 801de44:	f000 80bf 	beq.w	801dfc6 <bme68x_get_data+0x1ee>
    {
        /* Reading the sensor data in forced mode only */
        if (op_mode == BME68X_FORCED_MODE)
 801de48:	7bfb      	ldrb	r3, [r7, #15]
 801de4a:	2b01      	cmp	r3, #1
 801de4c:	d11c      	bne.n	801de88 <bme68x_get_data+0xb0>
        {
            rslt = read_field_data(0, data, dev);
 801de4e:	683a      	ldr	r2, [r7, #0]
 801de50:	68b9      	ldr	r1, [r7, #8]
 801de52:	2000      	movs	r0, #0
 801de54:	f000 fd8f 	bl	801e976 <read_field_data>
 801de58:	4603      	mov	r3, r0
 801de5a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
            if (rslt == BME68X_OK)
 801de5e:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
 801de62:	2b00      	cmp	r3, #0
 801de64:	f040 80a3 	bne.w	801dfae <bme68x_get_data+0x1d6>
            {
                if (data->status & BME68X_NEW_DATA_MSK)
 801de68:	68bb      	ldr	r3, [r7, #8]
 801de6a:	781b      	ldrb	r3, [r3, #0]
 801de6c:	b25b      	sxtb	r3, r3
 801de6e:	2b00      	cmp	r3, #0
 801de70:	da03      	bge.n	801de7a <bme68x_get_data+0xa2>
                {
                    new_fields = 1;
 801de72:	2301      	movs	r3, #1
 801de74:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
 801de78:	e099      	b.n	801dfae <bme68x_get_data+0x1d6>
                }
                else
                {
                    new_fields = 0;
 801de7a:	2300      	movs	r3, #0
 801de7c:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
                    rslt = BME68X_W_NO_NEW_DATA;
 801de80:	2302      	movs	r3, #2
 801de82:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 801de86:	e092      	b.n	801dfae <bme68x_get_data+0x1d6>
                }
            }
        }
        else if ((op_mode == BME68X_PARALLEL_MODE) || (op_mode == BME68X_SEQUENTIAL_MODE))
 801de88:	7bfb      	ldrb	r3, [r7, #15]
 801de8a:	2b02      	cmp	r3, #2
 801de8c:	d003      	beq.n	801de96 <bme68x_get_data+0xbe>
 801de8e:	7bfb      	ldrb	r3, [r7, #15]
 801de90:	2b03      	cmp	r3, #3
 801de92:	f040 8089 	bne.w	801dfa8 <bme68x_get_data+0x1d0>
        {
            /* Read the 3 fields and count the number of new data fields */
            rslt = read_all_field_data(field_ptr, dev);
 801de96:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801de9a:	6839      	ldr	r1, [r7, #0]
 801de9c:	4618      	mov	r0, r3
 801de9e:	f000 feb4 	bl	801ec0a <read_all_field_data>
 801dea2:	4603      	mov	r3, r0
 801dea4:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

            new_fields = 0;
 801dea8:	2300      	movs	r3, #0
 801deaa:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
            for (i = 0; (i < 3) && (rslt == BME68X_OK); i++)
 801deae:	2300      	movs	r3, #0
 801deb0:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801deb4:	e015      	b.n	801dee2 <bme68x_get_data+0x10a>
            {
                if (field_ptr[i]->status & BME68X_NEW_DATA_MSK)
 801deb6:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801deba:	009b      	lsls	r3, r3, #2
 801debc:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801dec0:	4413      	add	r3, r2
 801dec2:	f853 3c10 	ldr.w	r3, [r3, #-16]
 801dec6:	781b      	ldrb	r3, [r3, #0]
 801dec8:	b25b      	sxtb	r3, r3
 801deca:	2b00      	cmp	r3, #0
 801decc:	da04      	bge.n	801ded8 <bme68x_get_data+0x100>
                {
                    new_fields++;
 801dece:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 801ded2:	3301      	adds	r3, #1
 801ded4:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
            for (i = 0; (i < 3) && (rslt == BME68X_OK); i++)
 801ded8:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801dedc:	3301      	adds	r3, #1
 801dede:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801dee2:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801dee6:	2b02      	cmp	r3, #2
 801dee8:	d803      	bhi.n	801def2 <bme68x_get_data+0x11a>
 801deea:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
 801deee:	2b00      	cmp	r3, #0
 801def0:	d0e1      	beq.n	801deb6 <bme68x_get_data+0xde>
                }
            }

            /* Sort the sensor data in parallel & sequential modes*/
            for (i = 0; (i < 2) && (rslt == BME68X_OK); i++)
 801def2:	2300      	movs	r3, #0
 801def4:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801def8:	e01c      	b.n	801df34 <bme68x_get_data+0x15c>
            {
                for (j = i + 1; j < 3; j++)
 801defa:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801defe:	3301      	adds	r3, #1
 801df00:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 801df04:	e00d      	b.n	801df22 <bme68x_get_data+0x14a>
                {
                    sort_sensor_data(i, j, field_ptr);
 801df06:	f107 0258 	add.w	r2, r7, #88	; 0x58
 801df0a:	f897 1065 	ldrb.w	r1, [r7, #101]	; 0x65
 801df0e:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df12:	4618      	mov	r0, r3
 801df14:	f001 fb32 	bl	801f57c <sort_sensor_data>
                for (j = i + 1; j < 3; j++)
 801df18:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 801df1c:	3301      	adds	r3, #1
 801df1e:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 801df22:	f897 3065 	ldrb.w	r3, [r7, #101]	; 0x65
 801df26:	2b02      	cmp	r3, #2
 801df28:	d9ed      	bls.n	801df06 <bme68x_get_data+0x12e>
            for (i = 0; (i < 2) && (rslt == BME68X_OK); i++)
 801df2a:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df2e:	3301      	adds	r3, #1
 801df30:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801df34:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df38:	2b01      	cmp	r3, #1
 801df3a:	d803      	bhi.n	801df44 <bme68x_get_data+0x16c>
 801df3c:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
 801df40:	2b00      	cmp	r3, #0
 801df42:	d0da      	beq.n	801defa <bme68x_get_data+0x122>
                }
            }

            /* Copy the sorted data */
            for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 801df44:	2300      	movs	r3, #0
 801df46:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801df4a:	e01d      	b.n	801df88 <bme68x_get_data+0x1b0>
            {
                data[i] = *field_ptr[i];
 801df4c:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df50:	009b      	lsls	r3, r3, #2
 801df52:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801df56:	4413      	add	r3, r2
 801df58:	f853 1c10 	ldr.w	r1, [r3, #-16]
 801df5c:	f897 2066 	ldrb.w	r2, [r7, #102]	; 0x66
 801df60:	4613      	mov	r3, r2
 801df62:	005b      	lsls	r3, r3, #1
 801df64:	4413      	add	r3, r2
 801df66:	00db      	lsls	r3, r3, #3
 801df68:	461a      	mov	r2, r3
 801df6a:	68bb      	ldr	r3, [r7, #8]
 801df6c:	4413      	add	r3, r2
 801df6e:	461c      	mov	r4, r3
 801df70:	460d      	mov	r5, r1
 801df72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801df74:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801df76:	e895 0003 	ldmia.w	r5, {r0, r1}
 801df7a:	e884 0003 	stmia.w	r4, {r0, r1}
            for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 801df7e:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df82:	3301      	adds	r3, #1
 801df84:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
 801df88:	f897 3066 	ldrb.w	r3, [r7, #102]	; 0x66
 801df8c:	2b02      	cmp	r3, #2
 801df8e:	d803      	bhi.n	801df98 <bme68x_get_data+0x1c0>
 801df90:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
 801df94:	2b00      	cmp	r3, #0
 801df96:	d0d9      	beq.n	801df4c <bme68x_get_data+0x174>
            }

            if (new_fields == 0)
 801df98:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 801df9c:	2b00      	cmp	r3, #0
 801df9e:	d106      	bne.n	801dfae <bme68x_get_data+0x1d6>
            {
                rslt = BME68X_W_NO_NEW_DATA;
 801dfa0:	2302      	movs	r3, #2
 801dfa2:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
            if (new_fields == 0)
 801dfa6:	e002      	b.n	801dfae <bme68x_get_data+0x1d6>
            }
        }
        else
        {
            rslt = BME68X_W_DEFINE_OP_MODE;
 801dfa8:	2301      	movs	r3, #1
 801dfaa:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
        }

        if (n_data == NULL)
 801dfae:	687b      	ldr	r3, [r7, #4]
 801dfb0:	2b00      	cmp	r3, #0
 801dfb2:	d103      	bne.n	801dfbc <bme68x_get_data+0x1e4>
        {
            rslt = BME68X_E_NULL_PTR;
 801dfb4:	23ff      	movs	r3, #255	; 0xff
 801dfb6:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
        if (n_data == NULL)
 801dfba:	e007      	b.n	801dfcc <bme68x_get_data+0x1f4>
        }
        else
        {
            *n_data = new_fields;
 801dfbc:	687b      	ldr	r3, [r7, #4]
 801dfbe:	f897 2064 	ldrb.w	r2, [r7, #100]	; 0x64
 801dfc2:	701a      	strb	r2, [r3, #0]
        if (n_data == NULL)
 801dfc4:	e002      	b.n	801dfcc <bme68x_get_data+0x1f4>
        }
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801dfc6:	23ff      	movs	r3, #255	; 0xff
 801dfc8:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
    }

    return rslt;
 801dfcc:	f997 3067 	ldrsb.w	r3, [r7, #103]	; 0x67
}
 801dfd0:	4618      	mov	r0, r3
 801dfd2:	3768      	adds	r7, #104	; 0x68
 801dfd4:	46bd      	mov	sp, r7
 801dfd6:	bdb0      	pop	{r4, r5, r7, pc}

0801dfd8 <bme68x_set_heatr_conf>:

/*
 * @brief This API is used to set the gas configuration of the sensor.
 */
int8_t bme68x_set_heatr_conf(uint8_t op_mode, const struct bme68x_heatr_conf *conf, struct bme68x_dev *dev)
{
 801dfd8:	b580      	push	{r7, lr}
 801dfda:	b088      	sub	sp, #32
 801dfdc:	af00      	add	r7, sp, #0
 801dfde:	4603      	mov	r3, r0
 801dfe0:	60b9      	str	r1, [r7, #8]
 801dfe2:	607a      	str	r2, [r7, #4]
 801dfe4:	73fb      	strb	r3, [r7, #15]
    int8_t rslt;
    uint8_t nb_conv = 0;
 801dfe6:	2300      	movs	r3, #0
 801dfe8:	773b      	strb	r3, [r7, #28]
    uint8_t hctrl, run_gas = 0;
 801dfea:	2300      	movs	r3, #0
 801dfec:	777b      	strb	r3, [r7, #29]
    uint8_t ctrl_gas_data[2];
    uint8_t ctrl_gas_addr[2] = { BME68X_REG_CTRL_GAS_0, BME68X_REG_CTRL_GAS_1 };
 801dfee:	f247 1370 	movw	r3, #29040	; 0x7170
 801dff2:	82bb      	strh	r3, [r7, #20]

    if (conf != NULL)
 801dff4:	68bb      	ldr	r3, [r7, #8]
 801dff6:	2b00      	cmp	r3, #0
 801dff8:	d06e      	beq.n	801e0d8 <bme68x_set_heatr_conf+0x100>
    {
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
 801dffa:	6879      	ldr	r1, [r7, #4]
 801dffc:	2000      	movs	r0, #0
 801dffe:	f7ff fdf1 	bl	801dbe4 <bme68x_set_op_mode>
 801e002:	4603      	mov	r3, r0
 801e004:	77fb      	strb	r3, [r7, #31]
        if (rslt == BME68X_OK)
 801e006:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801e00a:	2b00      	cmp	r3, #0
 801e00c:	d108      	bne.n	801e020 <bme68x_set_heatr_conf+0x48>
        {
            rslt = set_conf(conf, op_mode, &nb_conv, dev);
 801e00e:	f107 021c 	add.w	r2, r7, #28
 801e012:	7bf9      	ldrb	r1, [r7, #15]
 801e014:	687b      	ldr	r3, [r7, #4]
 801e016:	68b8      	ldr	r0, [r7, #8]
 801e018:	f001 f920 	bl	801f25c <set_conf>
 801e01c:	4603      	mov	r3, r0
 801e01e:	77fb      	strb	r3, [r7, #31]
        }

        if (rslt == BME68X_OK)
 801e020:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801e024:	2b00      	cmp	r3, #0
 801e026:	d159      	bne.n	801e0dc <bme68x_set_heatr_conf+0x104>
        {
            rslt = bme68x_get_regs(BME68X_REG_CTRL_GAS_0, ctrl_gas_data, 2, dev);
 801e028:	f107 0118 	add.w	r1, r7, #24
 801e02c:	687b      	ldr	r3, [r7, #4]
 801e02e:	2202      	movs	r2, #2
 801e030:	2070      	movs	r0, #112	; 0x70
 801e032:	f7ff fc04 	bl	801d83e <bme68x_get_regs>
 801e036:	4603      	mov	r3, r0
 801e038:	77fb      	strb	r3, [r7, #31]
            if (rslt == BME68X_OK)
 801e03a:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801e03e:	2b00      	cmp	r3, #0
 801e040:	d14c      	bne.n	801e0dc <bme68x_set_heatr_conf+0x104>
            {
                if (conf->enable == BME68X_ENABLE)
 801e042:	68bb      	ldr	r3, [r7, #8]
 801e044:	781b      	ldrb	r3, [r3, #0]
 801e046:	2b01      	cmp	r3, #1
 801e048:	d10b      	bne.n	801e062 <bme68x_set_heatr_conf+0x8a>
                {
                    hctrl = BME68X_ENABLE_HEATER;
 801e04a:	2300      	movs	r3, #0
 801e04c:	77bb      	strb	r3, [r7, #30]
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 801e04e:	687b      	ldr	r3, [r7, #4]
 801e050:	689b      	ldr	r3, [r3, #8]
 801e052:	2b01      	cmp	r3, #1
 801e054:	d102      	bne.n	801e05c <bme68x_set_heatr_conf+0x84>
                    {
                        run_gas = BME68X_ENABLE_GAS_MEAS_H;
 801e056:	2302      	movs	r3, #2
 801e058:	777b      	strb	r3, [r7, #29]
 801e05a:	e006      	b.n	801e06a <bme68x_set_heatr_conf+0x92>
                    }
                    else
                    {
                        run_gas = BME68X_ENABLE_GAS_MEAS_L;
 801e05c:	2301      	movs	r3, #1
 801e05e:	777b      	strb	r3, [r7, #29]
 801e060:	e003      	b.n	801e06a <bme68x_set_heatr_conf+0x92>
                    }
                }
                else
                {
                    hctrl = BME68X_DISABLE_HEATER;
 801e062:	2301      	movs	r3, #1
 801e064:	77bb      	strb	r3, [r7, #30]
                    run_gas = BME68X_DISABLE_GAS_MEAS;
 801e066:	2300      	movs	r3, #0
 801e068:	777b      	strb	r3, [r7, #29]
                }

                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
 801e06a:	7e3b      	ldrb	r3, [r7, #24]
 801e06c:	b25b      	sxtb	r3, r3
 801e06e:	f023 0308 	bic.w	r3, r3, #8
 801e072:	b25a      	sxtb	r2, r3
 801e074:	7fbb      	ldrb	r3, [r7, #30]
 801e076:	00db      	lsls	r3, r3, #3
 801e078:	b25b      	sxtb	r3, r3
 801e07a:	f003 0308 	and.w	r3, r3, #8
 801e07e:	b25b      	sxtb	r3, r3
 801e080:	4313      	orrs	r3, r2
 801e082:	b25b      	sxtb	r3, r3
 801e084:	b2db      	uxtb	r3, r3
 801e086:	763b      	strb	r3, [r7, #24]
                ctrl_gas_data[1] = BME68X_SET_BITS_POS_0(ctrl_gas_data[1], BME68X_NBCONV, nb_conv);
 801e088:	7e7b      	ldrb	r3, [r7, #25]
 801e08a:	b25b      	sxtb	r3, r3
 801e08c:	f023 030f 	bic.w	r3, r3, #15
 801e090:	b25a      	sxtb	r2, r3
 801e092:	7f3b      	ldrb	r3, [r7, #28]
 801e094:	b25b      	sxtb	r3, r3
 801e096:	f003 030f 	and.w	r3, r3, #15
 801e09a:	b25b      	sxtb	r3, r3
 801e09c:	4313      	orrs	r3, r2
 801e09e:	b25b      	sxtb	r3, r3
 801e0a0:	b2db      	uxtb	r3, r3
 801e0a2:	767b      	strb	r3, [r7, #25]
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
 801e0a4:	7e7b      	ldrb	r3, [r7, #25]
 801e0a6:	b25b      	sxtb	r3, r3
 801e0a8:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 801e0ac:	b25a      	sxtb	r2, r3
 801e0ae:	7f7b      	ldrb	r3, [r7, #29]
 801e0b0:	011b      	lsls	r3, r3, #4
 801e0b2:	b25b      	sxtb	r3, r3
 801e0b4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801e0b8:	b25b      	sxtb	r3, r3
 801e0ba:	4313      	orrs	r3, r2
 801e0bc:	b25b      	sxtb	r3, r3
 801e0be:	b2db      	uxtb	r3, r3
 801e0c0:	767b      	strb	r3, [r7, #25]
                rslt = bme68x_set_regs(ctrl_gas_addr, ctrl_gas_data, 2, dev);
 801e0c2:	f107 0118 	add.w	r1, r7, #24
 801e0c6:	f107 0014 	add.w	r0, r7, #20
 801e0ca:	687b      	ldr	r3, [r7, #4]
 801e0cc:	2202      	movs	r2, #2
 801e0ce:	f7ff fb23 	bl	801d718 <bme68x_set_regs>
 801e0d2:	4603      	mov	r3, r0
 801e0d4:	77fb      	strb	r3, [r7, #31]
 801e0d6:	e001      	b.n	801e0dc <bme68x_set_heatr_conf+0x104>
            }
        }
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801e0d8:	23ff      	movs	r3, #255	; 0xff
 801e0da:	77fb      	strb	r3, [r7, #31]
    }

    return rslt;
 801e0dc:	f997 301f 	ldrsb.w	r3, [r7, #31]
}
 801e0e0:	4618      	mov	r0, r3
 801e0e2:	3720      	adds	r7, #32
 801e0e4:	46bd      	mov	sp, r7
 801e0e6:	bd80      	pop	{r7, pc}

0801e0e8 <calc_temperature>:

#else

/* @brief This internal API is used to calculate the temperature value. */
static float calc_temperature(uint32_t temp_adc, struct bme68x_dev *dev)
{
 801e0e8:	b480      	push	{r7}
 801e0ea:	b087      	sub	sp, #28
 801e0ec:	af00      	add	r7, sp, #0
 801e0ee:	6078      	str	r0, [r7, #4]
 801e0f0:	6039      	str	r1, [r7, #0]
    float var1;
    float var2;
    float calc_temp;

    /* calculate var1 data */
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
 801e0f2:	687b      	ldr	r3, [r7, #4]
 801e0f4:	ee07 3a90 	vmov	s15, r3
 801e0f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e0fc:	eddf 6a38 	vldr	s13, [pc, #224]	; 801e1e0 <calc_temperature+0xf8>
 801e100:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e104:	683b      	ldr	r3, [r7, #0]
 801e106:	8bdb      	ldrh	r3, [r3, #30]
 801e108:	ee07 3a90 	vmov	s15, r3
 801e10c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801e110:	ed9f 6a34 	vldr	s12, [pc, #208]	; 801e1e4 <calc_temperature+0xfc>
 801e114:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e118:	ee37 7a67 	vsub.f32	s14, s14, s15
 801e11c:	683b      	ldr	r3, [r7, #0]
 801e11e:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 801e122:	ee07 3a90 	vmov	s15, r3
 801e126:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e12a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e12e:	edc7 7a05 	vstr	s15, [r7, #20]

    /* calculate var2 data */
    var2 =
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
 801e132:	687b      	ldr	r3, [r7, #4]
 801e134:	ee07 3a90 	vmov	s15, r3
 801e138:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e13c:	eddf 6a2a 	vldr	s13, [pc, #168]	; 801e1e8 <calc_temperature+0x100>
 801e140:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e144:	683b      	ldr	r3, [r7, #0]
 801e146:	8bdb      	ldrh	r3, [r3, #30]
 801e148:	ee07 3a90 	vmov	s15, r3
 801e14c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801e150:	ed9f 6a26 	vldr	s12, [pc, #152]	; 801e1ec <calc_temperature+0x104>
 801e154:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e158:	ee37 7a67 	vsub.f32	s14, s14, s15
          (((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) * ((float)dev->calib.par_t3 * 16.0f));
 801e15c:	687b      	ldr	r3, [r7, #4]
 801e15e:	ee07 3a90 	vmov	s15, r3
 801e162:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e166:	ed9f 6a20 	vldr	s12, [pc, #128]	; 801e1e8 <calc_temperature+0x100>
 801e16a:	eec7 6a86 	vdiv.f32	s13, s15, s12
 801e16e:	683b      	ldr	r3, [r7, #0]
 801e170:	8bdb      	ldrh	r3, [r3, #30]
 801e172:	ee07 3a90 	vmov	s15, r3
 801e176:	eeb8 6a67 	vcvt.f32.u32	s12, s15
 801e17a:	eddf 5a1c 	vldr	s11, [pc, #112]	; 801e1ec <calc_temperature+0x104>
 801e17e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 801e182:	ee76 7ae7 	vsub.f32	s15, s13, s15
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
 801e186:	ee27 7a27 	vmul.f32	s14, s14, s15
          (((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) * ((float)dev->calib.par_t3 * 16.0f));
 801e18a:	683b      	ldr	r3, [r7, #0]
 801e18c:	f993 3022 	ldrsb.w	r3, [r3, #34]	; 0x22
 801e190:	ee07 3a90 	vmov	s15, r3
 801e194:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e198:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 801e19c:	ee67 7aa6 	vmul.f32	s15, s15, s13
    var2 =
 801e1a0:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e1a4:	edc7 7a04 	vstr	s15, [r7, #16]

    /* t_fine value*/
    dev->calib.t_fine = (var1 + var2);
 801e1a8:	ed97 7a05 	vldr	s14, [r7, #20]
 801e1ac:	edd7 7a04 	vldr	s15, [r7, #16]
 801e1b0:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e1b4:	683b      	ldr	r3, [r7, #0]
 801e1b6:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38

    /* compensated temperature data*/
    calc_temp = ((dev->calib.t_fine) / 5120.0f);
 801e1ba:	683b      	ldr	r3, [r7, #0]
 801e1bc:	ed93 7a0e 	vldr	s14, [r3, #56]	; 0x38
 801e1c0:	eddf 6a0b 	vldr	s13, [pc, #44]	; 801e1f0 <calc_temperature+0x108>
 801e1c4:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e1c8:	edc7 7a03 	vstr	s15, [r7, #12]

    return calc_temp;
 801e1cc:	68fb      	ldr	r3, [r7, #12]
 801e1ce:	ee07 3a90 	vmov	s15, r3
}
 801e1d2:	eeb0 0a67 	vmov.f32	s0, s15
 801e1d6:	371c      	adds	r7, #28
 801e1d8:	46bd      	mov	sp, r7
 801e1da:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e1de:	4770      	bx	lr
 801e1e0:	46800000 	.word	0x46800000
 801e1e4:	44800000 	.word	0x44800000
 801e1e8:	48000000 	.word	0x48000000
 801e1ec:	46000000 	.word	0x46000000
 801e1f0:	45a00000 	.word	0x45a00000

0801e1f4 <calc_pressure>:

/* @brief This internal API is used to calculate the pressure value. */
static float calc_pressure(uint32_t pres_adc, const struct bme68x_dev *dev)
{
 801e1f4:	b480      	push	{r7}
 801e1f6:	b087      	sub	sp, #28
 801e1f8:	af00      	add	r7, sp, #0
 801e1fa:	6078      	str	r0, [r7, #4]
 801e1fc:	6039      	str	r1, [r7, #0]
    float var1;
    float var2;
    float var3;
    float calc_pres;

    var1 = (((float)dev->calib.t_fine / 2.0f) - 64000.0f);
 801e1fe:	683b      	ldr	r3, [r7, #0]
 801e200:	ed93 7a0e 	vldr	s14, [r3, #56]	; 0x38
 801e204:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 801e208:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e20c:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 801e448 <calc_pressure+0x254>
 801e210:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801e214:	edc7 7a04 	vstr	s15, [r7, #16]
    var2 = var1 * var1 * (((float)dev->calib.par_p6) / (131072.0f));
 801e218:	edd7 7a04 	vldr	s15, [r7, #16]
 801e21c:	ee27 7aa7 	vmul.f32	s14, s15, s15
 801e220:	683b      	ldr	r3, [r7, #0]
 801e222:	f993 302e 	ldrsb.w	r3, [r3, #46]	; 0x2e
 801e226:	ee07 3a90 	vmov	s15, r3
 801e22a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801e22e:	ed9f 6a87 	vldr	s12, [pc, #540]	; 801e44c <calc_pressure+0x258>
 801e232:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e236:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e23a:	edc7 7a03 	vstr	s15, [r7, #12]
    var2 = var2 + (var1 * ((float)dev->calib.par_p5) * 2.0f);
 801e23e:	683b      	ldr	r3, [r7, #0]
 801e240:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 801e244:	ee07 3a90 	vmov	s15, r3
 801e248:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e24c:	edd7 7a04 	vldr	s15, [r7, #16]
 801e250:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e254:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801e258:	ed97 7a03 	vldr	s14, [r7, #12]
 801e25c:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e260:	edc7 7a03 	vstr	s15, [r7, #12]
    var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
 801e264:	edd7 7a03 	vldr	s15, [r7, #12]
 801e268:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 801e26c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e270:	683b      	ldr	r3, [r7, #0]
 801e272:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 801e276:	ee07 3a90 	vmov	s15, r3
 801e27a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e27e:	eddf 6a74 	vldr	s13, [pc, #464]	; 801e450 <calc_pressure+0x25c>
 801e282:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801e286:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e28a:	edc7 7a03 	vstr	s15, [r7, #12]
    var1 = (((((float)dev->calib.par_p3 * var1 * var1) / 16384.0f) + ((float)dev->calib.par_p2 * var1)) / 524288.0f);
 801e28e:	683b      	ldr	r3, [r7, #0]
 801e290:	f993 3028 	ldrsb.w	r3, [r3, #40]	; 0x28
 801e294:	ee07 3a90 	vmov	s15, r3
 801e298:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e29c:	edd7 7a04 	vldr	s15, [r7, #16]
 801e2a0:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e2a4:	edd7 7a04 	vldr	s15, [r7, #16]
 801e2a8:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e2ac:	eddf 6a69 	vldr	s13, [pc, #420]	; 801e454 <calc_pressure+0x260>
 801e2b0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e2b4:	683b      	ldr	r3, [r7, #0]
 801e2b6:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 801e2ba:	ee07 3a90 	vmov	s15, r3
 801e2be:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801e2c2:	edd7 7a04 	vldr	s15, [r7, #16]
 801e2c6:	ee66 7aa7 	vmul.f32	s15, s13, s15
 801e2ca:	ee37 7a27 	vadd.f32	s14, s14, s15
 801e2ce:	eddf 6a62 	vldr	s13, [pc, #392]	; 801e458 <calc_pressure+0x264>
 801e2d2:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e2d6:	edc7 7a04 	vstr	s15, [r7, #16]
    var1 = ((1.0f + (var1 / 32768.0f)) * ((float)dev->calib.par_p1));
 801e2da:	ed97 7a04 	vldr	s14, [r7, #16]
 801e2de:	eddf 6a5f 	vldr	s13, [pc, #380]	; 801e45c <calc_pressure+0x268>
 801e2e2:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e2e6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801e2ea:	ee37 7a87 	vadd.f32	s14, s15, s14
 801e2ee:	683b      	ldr	r3, [r7, #0]
 801e2f0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 801e2f2:	ee07 3a90 	vmov	s15, r3
 801e2f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e2fa:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e2fe:	edc7 7a04 	vstr	s15, [r7, #16]
    calc_pres = (1048576.0f - ((float)pres_adc));
 801e302:	687b      	ldr	r3, [r7, #4]
 801e304:	ee07 3a90 	vmov	s15, r3
 801e308:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e30c:	ed9f 7a54 	vldr	s14, [pc, #336]	; 801e460 <calc_pressure+0x26c>
 801e310:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e314:	edc7 7a05 	vstr	s15, [r7, #20]

    /* Avoid exception caused by division by zero */
    if ((int)var1 != 0)
 801e318:	edd7 7a04 	vldr	s15, [r7, #16]
 801e31c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801e320:	ee17 3a90 	vmov	r3, s15
 801e324:	2b00      	cmp	r3, #0
 801e326:	f000 8081 	beq.w	801e42c <calc_pressure+0x238>
    {
        calc_pres = (((calc_pres - (var2 / 4096.0f)) * 6250.0f) / var1);
 801e32a:	ed97 7a03 	vldr	s14, [r7, #12]
 801e32e:	eddf 6a4d 	vldr	s13, [pc, #308]	; 801e464 <calc_pressure+0x270>
 801e332:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e336:	ed97 7a05 	vldr	s14, [r7, #20]
 801e33a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e33e:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 801e468 <calc_pressure+0x274>
 801e342:	ee67 6a87 	vmul.f32	s13, s15, s14
 801e346:	ed97 7a04 	vldr	s14, [r7, #16]
 801e34a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801e34e:	edc7 7a05 	vstr	s15, [r7, #20]
        var1 = (((float)dev->calib.par_p9) * calc_pres * calc_pres) / 2147483648.0f;
 801e352:	683b      	ldr	r3, [r7, #0]
 801e354:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 801e358:	ee07 3a90 	vmov	s15, r3
 801e35c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e360:	edd7 7a05 	vldr	s15, [r7, #20]
 801e364:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e368:	edd7 7a05 	vldr	s15, [r7, #20]
 801e36c:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e370:	eddf 6a3e 	vldr	s13, [pc, #248]	; 801e46c <calc_pressure+0x278>
 801e374:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e378:	edc7 7a04 	vstr	s15, [r7, #16]
        var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f);
 801e37c:	683b      	ldr	r3, [r7, #0]
 801e37e:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 801e382:	ee07 3a90 	vmov	s15, r3
 801e386:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e38a:	eddf 6a34 	vldr	s13, [pc, #208]	; 801e45c <calc_pressure+0x268>
 801e38e:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e392:	ed97 7a05 	vldr	s14, [r7, #20]
 801e396:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e39a:	edc7 7a03 	vstr	s15, [r7, #12]
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
 801e39e:	edd7 7a05 	vldr	s15, [r7, #20]
 801e3a2:	eddf 6a33 	vldr	s13, [pc, #204]	; 801e470 <calc_pressure+0x27c>
 801e3a6:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 801e3aa:	edd7 6a05 	vldr	s13, [r7, #20]
 801e3ae:	ed9f 6a30 	vldr	s12, [pc, #192]	; 801e470 <calc_pressure+0x27c>
 801e3b2:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e3b6:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e3ba:	edd7 6a05 	vldr	s13, [r7, #20]
 801e3be:	ed9f 6a2c 	vldr	s12, [pc, #176]	; 801e470 <calc_pressure+0x27c>
 801e3c2:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e3c6:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e3ca:	683b      	ldr	r3, [r7, #0]
 801e3cc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801e3d0:	ee07 3a90 	vmov	s15, r3
 801e3d4:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801e3d8:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 801e44c <calc_pressure+0x258>
 801e3dc:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801e3e0:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e3e4:	edc7 7a02 	vstr	s15, [r7, #8]
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
 801e3e8:	ed97 7a04 	vldr	s14, [r7, #16]
 801e3ec:	edd7 7a03 	vldr	s15, [r7, #12]
 801e3f0:	ee37 7a27 	vadd.f32	s14, s14, s15
 801e3f4:	edd7 7a02 	vldr	s15, [r7, #8]
 801e3f8:	ee37 7a27 	vadd.f32	s14, s14, s15
 801e3fc:	683b      	ldr	r3, [r7, #0]
 801e3fe:	f993 302f 	ldrsb.w	r3, [r3, #47]	; 0x2f
 801e402:	ee07 3a90 	vmov	s15, r3
 801e406:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e40a:	eddf 6a1a 	vldr	s13, [pc, #104]	; 801e474 <calc_pressure+0x280>
 801e40e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801e412:	ee37 7a27 	vadd.f32	s14, s14, s15
 801e416:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 801e41a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e41e:	ed97 7a05 	vldr	s14, [r7, #20]
 801e422:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e426:	edc7 7a05 	vstr	s15, [r7, #20]
 801e42a:	e002      	b.n	801e432 <calc_pressure+0x23e>
    }
    else
    {
        calc_pres = 0;
 801e42c:	f04f 0300 	mov.w	r3, #0
 801e430:	617b      	str	r3, [r7, #20]
    }

    return calc_pres;
 801e432:	697b      	ldr	r3, [r7, #20]
 801e434:	ee07 3a90 	vmov	s15, r3
}
 801e438:	eeb0 0a67 	vmov.f32	s0, s15
 801e43c:	371c      	adds	r7, #28
 801e43e:	46bd      	mov	sp, r7
 801e440:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e444:	4770      	bx	lr
 801e446:	bf00      	nop
 801e448:	477a0000 	.word	0x477a0000
 801e44c:	48000000 	.word	0x48000000
 801e450:	47800000 	.word	0x47800000
 801e454:	46800000 	.word	0x46800000
 801e458:	49000000 	.word	0x49000000
 801e45c:	47000000 	.word	0x47000000
 801e460:	49800000 	.word	0x49800000
 801e464:	45800000 	.word	0x45800000
 801e468:	45c35000 	.word	0x45c35000
 801e46c:	4f000000 	.word	0x4f000000
 801e470:	43800000 	.word	0x43800000
 801e474:	43000000 	.word	0x43000000

0801e478 <calc_humidity>:

/* This internal API is used to calculate the humidity in integer */
static float calc_humidity(uint16_t hum_adc, const struct bme68x_dev *dev)
{
 801e478:	b480      	push	{r7}
 801e47a:	b089      	sub	sp, #36	; 0x24
 801e47c:	af00      	add	r7, sp, #0
 801e47e:	4603      	mov	r3, r0
 801e480:	6039      	str	r1, [r7, #0]
 801e482:	80fb      	strh	r3, [r7, #6]
    float var3;
    float var4;
    float temp_comp;

    /* compensated temperature data*/
    temp_comp = ((dev->calib.t_fine) / 5120.0f);
 801e484:	683b      	ldr	r3, [r7, #0]
 801e486:	ed93 7a0e 	vldr	s14, [r3, #56]	; 0x38
 801e48a:	eddf 6a5a 	vldr	s13, [pc, #360]	; 801e5f4 <calc_humidity+0x17c>
 801e48e:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e492:	edc7 7a06 	vstr	s15, [r7, #24]
    var1 = (float)((float)hum_adc) -
 801e496:	88fb      	ldrh	r3, [r7, #6]
 801e498:	ee07 3a90 	vmov	s15, r3
 801e49c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
           (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f) * temp_comp));
 801e4a0:	683b      	ldr	r3, [r7, #0]
 801e4a2:	8a1b      	ldrh	r3, [r3, #16]
 801e4a4:	ee07 3a90 	vmov	s15, r3
 801e4a8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e4ac:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 801e4b0:	ee67 6aa6 	vmul.f32	s13, s15, s13
 801e4b4:	683b      	ldr	r3, [r7, #0]
 801e4b6:	f993 3014 	ldrsb.w	r3, [r3, #20]
 801e4ba:	ee07 3a90 	vmov	s15, r3
 801e4be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e4c2:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 801e4c6:	ee87 6aa5 	vdiv.f32	s12, s15, s11
 801e4ca:	edd7 7a06 	vldr	s15, [r7, #24]
 801e4ce:	ee66 7a27 	vmul.f32	s15, s12, s15
 801e4d2:	ee76 7aa7 	vadd.f32	s15, s13, s15
    var1 = (float)((float)hum_adc) -
 801e4d6:	ee77 7a67 	vsub.f32	s15, s14, s15
 801e4da:	edc7 7a05 	vstr	s15, [r7, #20]
    var2 = var1 *
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
 801e4de:	683b      	ldr	r3, [r7, #0]
 801e4e0:	8a5b      	ldrh	r3, [r3, #18]
 801e4e2:	ee07 3a90 	vmov	s15, r3
 801e4e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e4ea:	eddf 6a43 	vldr	s13, [pc, #268]	; 801e5f8 <calc_humidity+0x180>
 801e4ee:	ee87 7aa6 	vdiv.f32	s14, s15, s13
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
 801e4f2:	683b      	ldr	r3, [r7, #0]
 801e4f4:	f993 3015 	ldrsb.w	r3, [r3, #21]
 801e4f8:	ee07 3a90 	vmov	s15, r3
 801e4fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e500:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 801e5fc <calc_humidity+0x184>
 801e504:	eec7 6a86 	vdiv.f32	s13, s15, s12
 801e508:	edd7 7a06 	vldr	s15, [r7, #24]
 801e50c:	ee66 7aa7 	vmul.f32	s15, s13, s15
 801e510:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801e514:	ee77 6aa6 	vadd.f32	s13, s15, s13
                     (((float)dev->calib.par_h5 / 1048576.0f) * temp_comp * temp_comp))));
 801e518:	683b      	ldr	r3, [r7, #0]
 801e51a:	f993 3016 	ldrsb.w	r3, [r3, #22]
 801e51e:	ee07 3a90 	vmov	s15, r3
 801e522:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e526:	eddf 5a36 	vldr	s11, [pc, #216]	; 801e600 <calc_humidity+0x188>
 801e52a:	ee87 6aa5 	vdiv.f32	s12, s15, s11
 801e52e:	edd7 7a06 	vldr	s15, [r7, #24]
 801e532:	ee26 6a27 	vmul.f32	s12, s12, s15
 801e536:	edd7 7a06 	vldr	s15, [r7, #24]
 801e53a:	ee66 7a27 	vmul.f32	s15, s12, s15
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
 801e53e:	ee76 7aa7 	vadd.f32	s15, s13, s15
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
 801e542:	ee67 7a27 	vmul.f32	s15, s14, s15
    var2 = var1 *
 801e546:	ed97 7a05 	vldr	s14, [r7, #20]
 801e54a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e54e:	edc7 7a04 	vstr	s15, [r7, #16]
    var3 = (float)dev->calib.par_h6 / 16384.0f;
 801e552:	683b      	ldr	r3, [r7, #0]
 801e554:	7ddb      	ldrb	r3, [r3, #23]
 801e556:	ee07 3a90 	vmov	s15, r3
 801e55a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801e55e:	eddf 6a27 	vldr	s13, [pc, #156]	; 801e5fc <calc_humidity+0x184>
 801e562:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e566:	edc7 7a03 	vstr	s15, [r7, #12]
    var4 = (float)dev->calib.par_h7 / 2097152.0f;
 801e56a:	683b      	ldr	r3, [r7, #0]
 801e56c:	f993 3018 	ldrsb.w	r3, [r3, #24]
 801e570:	ee07 3a90 	vmov	s15, r3
 801e574:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e578:	eddf 6a22 	vldr	s13, [pc, #136]	; 801e604 <calc_humidity+0x18c>
 801e57c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e580:	edc7 7a02 	vstr	s15, [r7, #8]
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
 801e584:	ed97 7a02 	vldr	s14, [r7, #8]
 801e588:	edd7 7a06 	vldr	s15, [r7, #24]
 801e58c:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e590:	edd7 7a03 	vldr	s15, [r7, #12]
 801e594:	ee37 7a27 	vadd.f32	s14, s14, s15
 801e598:	edd7 7a04 	vldr	s15, [r7, #16]
 801e59c:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e5a0:	edd7 7a04 	vldr	s15, [r7, #16]
 801e5a4:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e5a8:	ed97 7a04 	vldr	s14, [r7, #16]
 801e5ac:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e5b0:	edc7 7a07 	vstr	s15, [r7, #28]
    if (calc_hum > 100.0f)
 801e5b4:	edd7 7a07 	vldr	s15, [r7, #28]
 801e5b8:	ed9f 7a13 	vldr	s14, [pc, #76]	; 801e608 <calc_humidity+0x190>
 801e5bc:	eef4 7ac7 	vcmpe.f32	s15, s14
 801e5c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e5c4:	dd02      	ble.n	801e5cc <calc_humidity+0x154>
    {
        calc_hum = 100.0f;
 801e5c6:	4b11      	ldr	r3, [pc, #68]	; (801e60c <calc_humidity+0x194>)
 801e5c8:	61fb      	str	r3, [r7, #28]
 801e5ca:	e009      	b.n	801e5e0 <calc_humidity+0x168>
    }
    else if (calc_hum < 0.0f)
 801e5cc:	edd7 7a07 	vldr	s15, [r7, #28]
 801e5d0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801e5d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e5d8:	d502      	bpl.n	801e5e0 <calc_humidity+0x168>
    {
        calc_hum = 0.0f;
 801e5da:	f04f 0300 	mov.w	r3, #0
 801e5de:	61fb      	str	r3, [r7, #28]
    }

    return calc_hum;
 801e5e0:	69fb      	ldr	r3, [r7, #28]
 801e5e2:	ee07 3a90 	vmov	s15, r3
}
 801e5e6:	eeb0 0a67 	vmov.f32	s0, s15
 801e5ea:	3724      	adds	r7, #36	; 0x24
 801e5ec:	46bd      	mov	sp, r7
 801e5ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5f2:	4770      	bx	lr
 801e5f4:	45a00000 	.word	0x45a00000
 801e5f8:	48800000 	.word	0x48800000
 801e5fc:	46800000 	.word	0x46800000
 801e600:	49800000 	.word	0x49800000
 801e604:	4a000000 	.word	0x4a000000
 801e608:	42c80000 	.word	0x42c80000
 801e60c:	42c80000 	.word	0x42c80000

0801e610 <calc_gas_resistance_low>:

/* This internal API is used to calculate the gas resistance low value in float */
static float calc_gas_resistance_low(uint16_t gas_res_adc, uint8_t gas_range, const struct bme68x_dev *dev)
{
 801e610:	b4b0      	push	{r4, r5, r7}
 801e612:	b0a9      	sub	sp, #164	; 0xa4
 801e614:	af00      	add	r7, sp, #0
 801e616:	4603      	mov	r3, r0
 801e618:	603a      	str	r2, [r7, #0]
 801e61a:	80fb      	strh	r3, [r7, #6]
 801e61c:	460b      	mov	r3, r1
 801e61e:	717b      	strb	r3, [r7, #5]
    float calc_gas_res;
    float var1;
    float var2;
    float var3;
    float gas_res_f = gas_res_adc;
 801e620:	88fb      	ldrh	r3, [r7, #6]
 801e622:	ee07 3a90 	vmov	s15, r3
 801e626:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e62a:	edc7 7a27 	vstr	s15, [r7, #156]	; 0x9c
    float gas_range_f = (1U << gas_range); /*lint !e790 / Suspicious truncation, integral to float */
 801e62e:	797b      	ldrb	r3, [r7, #5]
 801e630:	2201      	movs	r2, #1
 801e632:	fa02 f303 	lsl.w	r3, r2, r3
 801e636:	ee07 3a90 	vmov	s15, r3
 801e63a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e63e:	edc7 7a26 	vstr	s15, [r7, #152]	; 0x98
    const float lookup_k1_range[16] = {
 801e642:	4b3f      	ldr	r3, [pc, #252]	; (801e740 <calc_gas_resistance_low+0x130>)
 801e644:	f107 0448 	add.w	r4, r7, #72	; 0x48
 801e648:	461d      	mov	r5, r3
 801e64a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e64c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e64e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e650:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e652:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e654:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e656:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 801e65a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        0.0f, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f, -0.8f, 0.0f, 0.0f, -0.2f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f
    };
    const float lookup_k2_range[16] = {
 801e65e:	4b39      	ldr	r3, [pc, #228]	; (801e744 <calc_gas_resistance_low+0x134>)
 801e660:	f107 0408 	add.w	r4, r7, #8
 801e664:	461d      	mov	r5, r3
 801e666:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e668:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e66a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e66c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e66e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e670:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e672:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 801e676:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        0.0f, 0.0f, 0.0f, 0.0f, 0.1f, 0.7f, 0.0f, -0.8f, -0.1f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f
    };

    var1 = (1340.0f + (5.0f * dev->calib.range_sw_err));
 801e67a:	683b      	ldr	r3, [r7, #0]
 801e67c:	f993 303e 	ldrsb.w	r3, [r3, #62]	; 0x3e
 801e680:	ee07 3a90 	vmov	s15, r3
 801e684:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e688:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
 801e68c:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e690:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 801e748 <calc_gas_resistance_low+0x138>
 801e694:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e698:	edc7 7a25 	vstr	s15, [r7, #148]	; 0x94
    var2 = (var1) * (1.0f + lookup_k1_range[gas_range] / 100.0f);
 801e69c:	797b      	ldrb	r3, [r7, #5]
 801e69e:	009b      	lsls	r3, r3, #2
 801e6a0:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801e6a4:	4413      	add	r3, r2
 801e6a6:	3b58      	subs	r3, #88	; 0x58
 801e6a8:	ed93 7a00 	vldr	s14, [r3]
 801e6ac:	eddf 6a27 	vldr	s13, [pc, #156]	; 801e74c <calc_gas_resistance_low+0x13c>
 801e6b0:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e6b4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801e6b8:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e6bc:	ed97 7a25 	vldr	s14, [r7, #148]	; 0x94
 801e6c0:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e6c4:	edc7 7a24 	vstr	s15, [r7, #144]	; 0x90
    var3 = 1.0f + (lookup_k2_range[gas_range] / 100.0f);
 801e6c8:	797b      	ldrb	r3, [r7, #5]
 801e6ca:	009b      	lsls	r3, r3, #2
 801e6cc:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801e6d0:	4413      	add	r3, r2
 801e6d2:	3b98      	subs	r3, #152	; 0x98
 801e6d4:	ed93 7a00 	vldr	s14, [r3]
 801e6d8:	eddf 6a1c 	vldr	s13, [pc, #112]	; 801e74c <calc_gas_resistance_low+0x13c>
 801e6dc:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e6e0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801e6e4:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e6e8:	edc7 7a23 	vstr	s15, [r7, #140]	; 0x8c
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
 801e6ec:	edd7 7a23 	vldr	s15, [r7, #140]	; 0x8c
 801e6f0:	ed9f 7a17 	vldr	s14, [pc, #92]	; 801e750 <calc_gas_resistance_low+0x140>
 801e6f4:	ee27 7a87 	vmul.f32	s14, s15, s14
 801e6f8:	edd7 7a26 	vldr	s15, [r7, #152]	; 0x98
 801e6fc:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e700:	edd7 7a27 	vldr	s15, [r7, #156]	; 0x9c
 801e704:	eddf 6a13 	vldr	s13, [pc, #76]	; 801e754 <calc_gas_resistance_low+0x144>
 801e708:	ee37 6ae6 	vsub.f32	s12, s15, s13
 801e70c:	edd7 6a24 	vldr	s13, [r7, #144]	; 0x90
 801e710:	eec6 7a26 	vdiv.f32	s15, s12, s13
 801e714:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801e718:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801e71c:	ee27 7a27 	vmul.f32	s14, s14, s15
 801e720:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801e724:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801e728:	edc7 7a22 	vstr	s15, [r7, #136]	; 0x88

    return calc_gas_res;
 801e72c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801e730:	ee07 3a90 	vmov	s15, r3
}
 801e734:	eeb0 0a67 	vmov.f32	s0, s15
 801e738:	37a4      	adds	r7, #164	; 0xa4
 801e73a:	46bd      	mov	sp, r7
 801e73c:	bcb0      	pop	{r4, r5, r7}
 801e73e:	4770      	bx	lr
 801e740:	0802c588 	.word	0x0802c588
 801e744:	0802c5c8 	.word	0x0802c5c8
 801e748:	44a78000 	.word	0x44a78000
 801e74c:	42c80000 	.word	0x42c80000
 801e750:	340637bd 	.word	0x340637bd
 801e754:	44000000 	.word	0x44000000

0801e758 <calc_gas_resistance_high>:

/* This internal API is used to calculate the gas resistance value in float */
static float calc_gas_resistance_high(uint16_t gas_res_adc, uint8_t gas_range)
{
 801e758:	b480      	push	{r7}
 801e75a:	b087      	sub	sp, #28
 801e75c:	af00      	add	r7, sp, #0
 801e75e:	4603      	mov	r3, r0
 801e760:	460a      	mov	r2, r1
 801e762:	80fb      	strh	r3, [r7, #6]
 801e764:	4613      	mov	r3, r2
 801e766:	717b      	strb	r3, [r7, #5]
    float calc_gas_res;
    uint32_t var1 = UINT32_C(262144) >> gas_range;
 801e768:	797b      	ldrb	r3, [r7, #5]
 801e76a:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 801e76e:	fa22 f303 	lsr.w	r3, r2, r3
 801e772:	617b      	str	r3, [r7, #20]
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
 801e774:	88fb      	ldrh	r3, [r7, #6]
 801e776:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
 801e77a:	613b      	str	r3, [r7, #16]

    var2 *= INT32_C(3);
 801e77c:	693a      	ldr	r2, [r7, #16]
 801e77e:	4613      	mov	r3, r2
 801e780:	005b      	lsls	r3, r3, #1
 801e782:	4413      	add	r3, r2
 801e784:	613b      	str	r3, [r7, #16]
    var2 = INT32_C(4096) + var2;
 801e786:	693b      	ldr	r3, [r7, #16]
 801e788:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 801e78c:	613b      	str	r3, [r7, #16]

    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
 801e78e:	697b      	ldr	r3, [r7, #20]
 801e790:	ee07 3a90 	vmov	s15, r3
 801e794:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e798:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 801e7c8 <calc_gas_resistance_high+0x70>
 801e79c:	ee67 6a87 	vmul.f32	s13, s15, s14
 801e7a0:	693b      	ldr	r3, [r7, #16]
 801e7a2:	ee07 3a90 	vmov	s15, r3
 801e7a6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e7aa:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801e7ae:	edc7 7a03 	vstr	s15, [r7, #12]

    return calc_gas_res;
 801e7b2:	68fb      	ldr	r3, [r7, #12]
 801e7b4:	ee07 3a90 	vmov	s15, r3
}
 801e7b8:	eeb0 0a67 	vmov.f32	s0, s15
 801e7bc:	371c      	adds	r7, #28
 801e7be:	46bd      	mov	sp, r7
 801e7c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e7c4:	4770      	bx	lr
 801e7c6:	bf00      	nop
 801e7c8:	49742400 	.word	0x49742400

0801e7cc <calc_res_heat>:

/* This internal API is used to calculate the heater resistance value */
static uint8_t calc_res_heat(uint16_t temp, const struct bme68x_dev *dev)
{
 801e7cc:	b480      	push	{r7}
 801e7ce:	b08b      	sub	sp, #44	; 0x2c
 801e7d0:	af00      	add	r7, sp, #0
 801e7d2:	4603      	mov	r3, r0
 801e7d4:	60b9      	str	r1, [r7, #8]
 801e7d6:	81fb      	strh	r3, [r7, #14]
    float var3;
    float var4;
    float var5;
    uint8_t res_heat;

    if (temp > 400) /* Cap temperature */
 801e7d8:	89fb      	ldrh	r3, [r7, #14]
 801e7da:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 801e7de:	d902      	bls.n	801e7e6 <calc_res_heat+0x1a>
    {
        temp = 400;
 801e7e0:	f44f 73c8 	mov.w	r3, #400	; 0x190
 801e7e4:	81fb      	strh	r3, [r7, #14]
    }

    var1 = (((float)dev->calib.par_gh1 / (16.0f)) + 49.0f);
 801e7e6:	68bb      	ldr	r3, [r7, #8]
 801e7e8:	f993 3019 	ldrsb.w	r3, [r3, #25]
 801e7ec:	ee07 3a90 	vmov	s15, r3
 801e7f0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e7f4:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 801e7f8:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e7fc:	ed9f 7a44 	vldr	s14, [pc, #272]	; 801e910 <calc_res_heat+0x144>
 801e800:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e804:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f);
 801e808:	68bb      	ldr	r3, [r7, #8]
 801e80a:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801e80e:	ee07 3a90 	vmov	s15, r3
 801e812:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e816:	eddf 6a3f 	vldr	s13, [pc, #252]	; 801e914 <calc_res_heat+0x148>
 801e81a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e81e:	ed9f 7a3e 	vldr	s14, [pc, #248]	; 801e918 <calc_res_heat+0x14c>
 801e822:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e826:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 801e91c <calc_res_heat+0x150>
 801e82a:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e82e:	edc7 7a08 	vstr	s15, [r7, #32]
    var3 = ((float)dev->calib.par_gh3 / (1024.0f));
 801e832:	68bb      	ldr	r3, [r7, #8]
 801e834:	f993 301c 	ldrsb.w	r3, [r3, #28]
 801e838:	ee07 3a90 	vmov	s15, r3
 801e83c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e840:	eddf 6a37 	vldr	s13, [pc, #220]	; 801e920 <calc_res_heat+0x154>
 801e844:	eec7 7a26 	vdiv.f32	s15, s14, s13
 801e848:	edc7 7a07 	vstr	s15, [r7, #28]
    var4 = (var1 * (1.0f + (var2 * (float)temp)));
 801e84c:	89fb      	ldrh	r3, [r7, #14]
 801e84e:	ee07 3a90 	vmov	s15, r3
 801e852:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801e856:	edd7 7a08 	vldr	s15, [r7, #32]
 801e85a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e85e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801e862:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e866:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 801e86a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e86e:	edc7 7a06 	vstr	s15, [r7, #24]
    var5 = (var4 + (var3 * (float)dev->amb_temp));
 801e872:	68bb      	ldr	r3, [r7, #8]
 801e874:	f993 300e 	ldrsb.w	r3, [r3, #14]
 801e878:	ee07 3a90 	vmov	s15, r3
 801e87c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801e880:	edd7 7a07 	vldr	s15, [r7, #28]
 801e884:	ee67 7a27 	vmul.f32	s15, s14, s15
 801e888:	ed97 7a06 	vldr	s14, [r7, #24]
 801e88c:	ee77 7a27 	vadd.f32	s15, s14, s15
 801e890:	edc7 7a05 	vstr	s15, [r7, #20]
    res_heat =
        (uint8_t)(3.4f *
                  ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
 801e894:	68bb      	ldr	r3, [r7, #8]
 801e896:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 801e89a:	ee07 3a90 	vmov	s15, r3
 801e89e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801e8a2:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 801e8a6:	ee77 7a87 	vadd.f32	s15, s15, s14
 801e8aa:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 801e8ae:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801e8b2:	edd7 7a05 	vldr	s15, [r7, #20]
 801e8b6:	ee27 7a27 	vmul.f32	s14, s14, s15
                    (1 / (1 + ((float)dev->calib.res_heat_val * 0.002f)))) -
 801e8ba:	68bb      	ldr	r3, [r7, #8]
 801e8bc:	f993 303d 	ldrsb.w	r3, [r3, #61]	; 0x3d
 801e8c0:	ee07 3a90 	vmov	s15, r3
 801e8c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801e8c8:	eddf 6a16 	vldr	s13, [pc, #88]	; 801e924 <calc_res_heat+0x158>
 801e8cc:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801e8d0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801e8d4:	ee77 6aa6 	vadd.f32	s13, s15, s13
 801e8d8:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801e8dc:	eec6 7a26 	vdiv.f32	s15, s12, s13
                  ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
 801e8e0:	ee67 7a27 	vmul.f32	s15, s14, s15
                    (1 / (1 + ((float)dev->calib.res_heat_val * 0.002f)))) -
 801e8e4:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 801e8e8:	ee77 7ac7 	vsub.f32	s15, s15, s14
        (uint8_t)(3.4f *
 801e8ec:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 801e928 <calc_res_heat+0x15c>
 801e8f0:	ee67 7a87 	vmul.f32	s15, s15, s14
    res_heat =
 801e8f4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801e8f8:	edc7 7a01 	vstr	s15, [r7, #4]
 801e8fc:	793b      	ldrb	r3, [r7, #4]
 801e8fe:	74fb      	strb	r3, [r7, #19]
                   25));

    return res_heat;
 801e900:	7cfb      	ldrb	r3, [r7, #19]
}
 801e902:	4618      	mov	r0, r3
 801e904:	372c      	adds	r7, #44	; 0x2c
 801e906:	46bd      	mov	sp, r7
 801e908:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e90c:	4770      	bx	lr
 801e90e:	bf00      	nop
 801e910:	42440000 	.word	0x42440000
 801e914:	47000000 	.word	0x47000000
 801e918:	3a03126f 	.word	0x3a03126f
 801e91c:	3b1a0275 	.word	0x3b1a0275
 801e920:	44800000 	.word	0x44800000
 801e924:	3b03126f 	.word	0x3b03126f
 801e928:	4059999a 	.word	0x4059999a

0801e92c <calc_gas_wait>:

#endif

/* This internal API is used to calculate the gas wait */
static uint8_t calc_gas_wait(uint16_t dur)
{
 801e92c:	b480      	push	{r7}
 801e92e:	b085      	sub	sp, #20
 801e930:	af00      	add	r7, sp, #0
 801e932:	4603      	mov	r3, r0
 801e934:	80fb      	strh	r3, [r7, #6]
    uint8_t factor = 0;
 801e936:	2300      	movs	r3, #0
 801e938:	73fb      	strb	r3, [r7, #15]
    uint8_t durval;

    if (dur >= 0xfc0)
 801e93a:	88fb      	ldrh	r3, [r7, #6]
 801e93c:	f5b3 6f7c 	cmp.w	r3, #4032	; 0xfc0
 801e940:	d308      	bcc.n	801e954 <calc_gas_wait+0x28>
    {
        durval = 0xff; /* Max duration*/
 801e942:	23ff      	movs	r3, #255	; 0xff
 801e944:	73bb      	strb	r3, [r7, #14]
 801e946:	e00f      	b.n	801e968 <calc_gas_wait+0x3c>
    }
    else
    {
        while (dur > 0x3F)
        {
            dur = dur / 4;
 801e948:	88fb      	ldrh	r3, [r7, #6]
 801e94a:	089b      	lsrs	r3, r3, #2
 801e94c:	80fb      	strh	r3, [r7, #6]
            factor += 1;
 801e94e:	7bfb      	ldrb	r3, [r7, #15]
 801e950:	3301      	adds	r3, #1
 801e952:	73fb      	strb	r3, [r7, #15]
        while (dur > 0x3F)
 801e954:	88fb      	ldrh	r3, [r7, #6]
 801e956:	2b3f      	cmp	r3, #63	; 0x3f
 801e958:	d8f6      	bhi.n	801e948 <calc_gas_wait+0x1c>
        }

        durval = (uint8_t)(dur + (factor * 64));
 801e95a:	88fb      	ldrh	r3, [r7, #6]
 801e95c:	b2da      	uxtb	r2, r3
 801e95e:	7bfb      	ldrb	r3, [r7, #15]
 801e960:	019b      	lsls	r3, r3, #6
 801e962:	b2db      	uxtb	r3, r3
 801e964:	4413      	add	r3, r2
 801e966:	73bb      	strb	r3, [r7, #14]
    }

    return durval;
 801e968:	7bbb      	ldrb	r3, [r7, #14]
}
 801e96a:	4618      	mov	r0, r3
 801e96c:	3714      	adds	r7, #20
 801e96e:	46bd      	mov	sp, r7
 801e970:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e974:	4770      	bx	lr

0801e976 <read_field_data>:

/* This internal API is used to read a single data of the sensor */
static int8_t read_field_data(uint8_t index, struct bme68x_data *data, struct bme68x_dev *dev)
{
 801e976:	b580      	push	{r7, lr}
 801e978:	b08e      	sub	sp, #56	; 0x38
 801e97a:	af00      	add	r7, sp, #0
 801e97c:	4603      	mov	r3, r0
 801e97e:	60b9      	str	r1, [r7, #8]
 801e980:	607a      	str	r2, [r7, #4]
 801e982:	73fb      	strb	r3, [r7, #15]
    int8_t rslt = BME68X_OK;
 801e984:	2300      	movs	r3, #0
 801e986:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint8_t buff[BME68X_LEN_FIELD] = { 0 };
 801e98a:	2300      	movs	r3, #0
 801e98c:	613b      	str	r3, [r7, #16]
 801e98e:	f107 0314 	add.w	r3, r7, #20
 801e992:	2200      	movs	r2, #0
 801e994:	601a      	str	r2, [r3, #0]
 801e996:	605a      	str	r2, [r3, #4]
 801e998:	609a      	str	r2, [r3, #8]
 801e99a:	731a      	strb	r2, [r3, #12]
    uint8_t gas_range_l, gas_range_h;
    uint32_t adc_temp;
    uint32_t adc_pres;
    uint16_t adc_hum;
    uint16_t adc_gas_res_low, adc_gas_res_high;
    uint8_t tries = 5;
 801e99c:	2305      	movs	r3, #5
 801e99e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

    while ((tries) && (rslt == BME68X_OK))
 801e9a2:	e123      	b.n	801ebec <read_field_data+0x276>
    {
        rslt = bme68x_get_regs(((uint8_t)(BME68X_REG_FIELD0 + (index * BME68X_LEN_FIELD_OFFSET))),
 801e9a4:	7bfb      	ldrb	r3, [r7, #15]
 801e9a6:	461a      	mov	r2, r3
 801e9a8:	0112      	lsls	r2, r2, #4
 801e9aa:	4413      	add	r3, r2
 801e9ac:	b2db      	uxtb	r3, r3
 801e9ae:	331d      	adds	r3, #29
 801e9b0:	b2d8      	uxtb	r0, r3
 801e9b2:	f107 0110 	add.w	r1, r7, #16
 801e9b6:	687b      	ldr	r3, [r7, #4]
 801e9b8:	2211      	movs	r2, #17
 801e9ba:	f7fe ff40 	bl	801d83e <bme68x_get_regs>
 801e9be:	4603      	mov	r3, r0
 801e9c0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                               buff,
                               (uint16_t)BME68X_LEN_FIELD,
                               dev);
        if (!data)
 801e9c4:	68bb      	ldr	r3, [r7, #8]
 801e9c6:	2b00      	cmp	r3, #0
 801e9c8:	d103      	bne.n	801e9d2 <read_field_data+0x5c>
        {
            rslt = BME68X_E_NULL_PTR;
 801e9ca:	23ff      	movs	r3, #255	; 0xff
 801e9cc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            break;
 801e9d0:	e115      	b.n	801ebfe <read_field_data+0x288>
        }

        data->status = buff[0] & BME68X_NEW_DATA_MSK;
 801e9d2:	7c3b      	ldrb	r3, [r7, #16]
 801e9d4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801e9d8:	b2da      	uxtb	r2, r3
 801e9da:	68bb      	ldr	r3, [r7, #8]
 801e9dc:	701a      	strb	r2, [r3, #0]
        data->gas_index = buff[0] & BME68X_GAS_INDEX_MSK;
 801e9de:	7c3b      	ldrb	r3, [r7, #16]
 801e9e0:	f003 030f 	and.w	r3, r3, #15
 801e9e4:	b2da      	uxtb	r2, r3
 801e9e6:	68bb      	ldr	r3, [r7, #8]
 801e9e8:	705a      	strb	r2, [r3, #1]
        data->meas_index = buff[1];
 801e9ea:	7c7a      	ldrb	r2, [r7, #17]
 801e9ec:	68bb      	ldr	r3, [r7, #8]
 801e9ee:	709a      	strb	r2, [r3, #2]

        /* read the raw data from the sensor */
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
 801e9f0:	7cbb      	ldrb	r3, [r7, #18]
 801e9f2:	031a      	lsls	r2, r3, #12
 801e9f4:	7cfb      	ldrb	r3, [r7, #19]
 801e9f6:	011b      	lsls	r3, r3, #4
 801e9f8:	4313      	orrs	r3, r2
 801e9fa:	7d3a      	ldrb	r2, [r7, #20]
 801e9fc:	0912      	lsrs	r2, r2, #4
 801e9fe:	b2d2      	uxtb	r2, r2
 801ea00:	4313      	orrs	r3, r2
 801ea02:	633b      	str	r3, [r7, #48]	; 0x30
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
 801ea04:	7d7b      	ldrb	r3, [r7, #21]
 801ea06:	031a      	lsls	r2, r3, #12
 801ea08:	7dbb      	ldrb	r3, [r7, #22]
 801ea0a:	011b      	lsls	r3, r3, #4
 801ea0c:	4313      	orrs	r3, r2
 801ea0e:	7dfa      	ldrb	r2, [r7, #23]
 801ea10:	0912      	lsrs	r2, r2, #4
 801ea12:	b2d2      	uxtb	r2, r2
 801ea14:	4313      	orrs	r3, r2
 801ea16:	62fb      	str	r3, [r7, #44]	; 0x2c
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
 801ea18:	7e3b      	ldrb	r3, [r7, #24]
 801ea1a:	b29b      	uxth	r3, r3
 801ea1c:	021b      	lsls	r3, r3, #8
 801ea1e:	b29a      	uxth	r2, r3
 801ea20:	7e7b      	ldrb	r3, [r7, #25]
 801ea22:	b29b      	uxth	r3, r3
 801ea24:	4313      	orrs	r3, r2
 801ea26:	857b      	strh	r3, [r7, #42]	; 0x2a
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
 801ea28:	7f7b      	ldrb	r3, [r7, #29]
 801ea2a:	b29b      	uxth	r3, r3
 801ea2c:	009b      	lsls	r3, r3, #2
 801ea2e:	b29a      	uxth	r2, r3
 801ea30:	7fbb      	ldrb	r3, [r7, #30]
 801ea32:	099b      	lsrs	r3, r3, #6
 801ea34:	b2db      	uxtb	r3, r3
 801ea36:	b29b      	uxth	r3, r3
 801ea38:	4313      	orrs	r3, r2
 801ea3a:	853b      	strh	r3, [r7, #40]	; 0x28
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
 801ea3c:	7ffb      	ldrb	r3, [r7, #31]
 801ea3e:	b29b      	uxth	r3, r3
 801ea40:	009b      	lsls	r3, r3, #2
 801ea42:	b29a      	uxth	r2, r3
 801ea44:	f897 3020 	ldrb.w	r3, [r7, #32]
 801ea48:	099b      	lsrs	r3, r3, #6
 801ea4a:	b2db      	uxtb	r3, r3
 801ea4c:	b29b      	uxth	r3, r3
 801ea4e:	4313      	orrs	r3, r2
 801ea50:	84fb      	strh	r3, [r7, #38]	; 0x26
        gas_range_l = buff[14] & BME68X_GAS_RANGE_MSK;
 801ea52:	7fbb      	ldrb	r3, [r7, #30]
 801ea54:	f003 030f 	and.w	r3, r3, #15
 801ea58:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        gas_range_h = buff[16] & BME68X_GAS_RANGE_MSK;
 801ea5c:	f897 3020 	ldrb.w	r3, [r7, #32]
 801ea60:	f003 030f 	and.w	r3, r3, #15
 801ea64:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 801ea68:	687b      	ldr	r3, [r7, #4]
 801ea6a:	689b      	ldr	r3, [r3, #8]
 801ea6c:	2b01      	cmp	r3, #1
 801ea6e:	d11c      	bne.n	801eaaa <read_field_data+0x134>
        {
            data->status |= buff[16] & BME68X_GASM_VALID_MSK;
 801ea70:	68bb      	ldr	r3, [r7, #8]
 801ea72:	781b      	ldrb	r3, [r3, #0]
 801ea74:	b25a      	sxtb	r2, r3
 801ea76:	f897 3020 	ldrb.w	r3, [r7, #32]
 801ea7a:	b25b      	sxtb	r3, r3
 801ea7c:	f003 0320 	and.w	r3, r3, #32
 801ea80:	b25b      	sxtb	r3, r3
 801ea82:	4313      	orrs	r3, r2
 801ea84:	b25b      	sxtb	r3, r3
 801ea86:	b2da      	uxtb	r2, r3
 801ea88:	68bb      	ldr	r3, [r7, #8]
 801ea8a:	701a      	strb	r2, [r3, #0]
            data->status |= buff[16] & BME68X_HEAT_STAB_MSK;
 801ea8c:	68bb      	ldr	r3, [r7, #8]
 801ea8e:	781b      	ldrb	r3, [r3, #0]
 801ea90:	b25a      	sxtb	r2, r3
 801ea92:	f897 3020 	ldrb.w	r3, [r7, #32]
 801ea96:	b25b      	sxtb	r3, r3
 801ea98:	f003 0310 	and.w	r3, r3, #16
 801ea9c:	b25b      	sxtb	r3, r3
 801ea9e:	4313      	orrs	r3, r2
 801eaa0:	b25b      	sxtb	r3, r3
 801eaa2:	b2da      	uxtb	r2, r3
 801eaa4:	68bb      	ldr	r3, [r7, #8]
 801eaa6:	701a      	strb	r2, [r3, #0]
 801eaa8:	e019      	b.n	801eade <read_field_data+0x168>
        }
        else
        {
            data->status |= buff[14] & BME68X_GASM_VALID_MSK;
 801eaaa:	68bb      	ldr	r3, [r7, #8]
 801eaac:	781b      	ldrb	r3, [r3, #0]
 801eaae:	b25a      	sxtb	r2, r3
 801eab0:	7fbb      	ldrb	r3, [r7, #30]
 801eab2:	b25b      	sxtb	r3, r3
 801eab4:	f003 0320 	and.w	r3, r3, #32
 801eab8:	b25b      	sxtb	r3, r3
 801eaba:	4313      	orrs	r3, r2
 801eabc:	b25b      	sxtb	r3, r3
 801eabe:	b2da      	uxtb	r2, r3
 801eac0:	68bb      	ldr	r3, [r7, #8]
 801eac2:	701a      	strb	r2, [r3, #0]
            data->status |= buff[14] & BME68X_HEAT_STAB_MSK;
 801eac4:	68bb      	ldr	r3, [r7, #8]
 801eac6:	781b      	ldrb	r3, [r3, #0]
 801eac8:	b25a      	sxtb	r2, r3
 801eaca:	7fbb      	ldrb	r3, [r7, #30]
 801eacc:	b25b      	sxtb	r3, r3
 801eace:	f003 0310 	and.w	r3, r3, #16
 801ead2:	b25b      	sxtb	r3, r3
 801ead4:	4313      	orrs	r3, r2
 801ead6:	b25b      	sxtb	r3, r3
 801ead8:	b2da      	uxtb	r2, r3
 801eada:	68bb      	ldr	r3, [r7, #8]
 801eadc:	701a      	strb	r2, [r3, #0]
        }

        if ((data->status & BME68X_NEW_DATA_MSK) && (rslt == BME68X_OK))
 801eade:	68bb      	ldr	r3, [r7, #8]
 801eae0:	781b      	ldrb	r3, [r3, #0]
 801eae2:	b25b      	sxtb	r3, r3
 801eae4:	2b00      	cmp	r3, #0
 801eae6:	da70      	bge.n	801ebca <read_field_data+0x254>
 801eae8:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801eaec:	2b00      	cmp	r3, #0
 801eaee:	d16c      	bne.n	801ebca <read_field_data+0x254>
        {
            rslt = bme68x_get_regs(BME68X_REG_RES_HEAT0 + data->gas_index, &data->res_heat, 1, dev);
 801eaf0:	68bb      	ldr	r3, [r7, #8]
 801eaf2:	785b      	ldrb	r3, [r3, #1]
 801eaf4:	335a      	adds	r3, #90	; 0x5a
 801eaf6:	b2d8      	uxtb	r0, r3
 801eaf8:	68bb      	ldr	r3, [r7, #8]
 801eafa:	1cd9      	adds	r1, r3, #3
 801eafc:	687b      	ldr	r3, [r7, #4]
 801eafe:	2201      	movs	r2, #1
 801eb00:	f7fe fe9d 	bl	801d83e <bme68x_get_regs>
 801eb04:	4603      	mov	r3, r0
 801eb06:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            if (rslt == BME68X_OK)
 801eb0a:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801eb0e:	2b00      	cmp	r3, #0
 801eb10:	d10c      	bne.n	801eb2c <read_field_data+0x1b6>
            {
                rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0 + data->gas_index, &data->idac, 1, dev);
 801eb12:	68bb      	ldr	r3, [r7, #8]
 801eb14:	785b      	ldrb	r3, [r3, #1]
 801eb16:	3350      	adds	r3, #80	; 0x50
 801eb18:	b2d8      	uxtb	r0, r3
 801eb1a:	68bb      	ldr	r3, [r7, #8]
 801eb1c:	1d19      	adds	r1, r3, #4
 801eb1e:	687b      	ldr	r3, [r7, #4]
 801eb20:	2201      	movs	r2, #1
 801eb22:	f7fe fe8c 	bl	801d83e <bme68x_get_regs>
 801eb26:	4603      	mov	r3, r0
 801eb28:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            }

            if (rslt == BME68X_OK)
 801eb2c:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801eb30:	2b00      	cmp	r3, #0
 801eb32:	d10c      	bne.n	801eb4e <read_field_data+0x1d8>
            {
                rslt = bme68x_get_regs(BME68X_REG_GAS_WAIT0 + data->gas_index, &data->gas_wait, 1, dev);
 801eb34:	68bb      	ldr	r3, [r7, #8]
 801eb36:	785b      	ldrb	r3, [r3, #1]
 801eb38:	3364      	adds	r3, #100	; 0x64
 801eb3a:	b2d8      	uxtb	r0, r3
 801eb3c:	68bb      	ldr	r3, [r7, #8]
 801eb3e:	1d59      	adds	r1, r3, #5
 801eb40:	687b      	ldr	r3, [r7, #4]
 801eb42:	2201      	movs	r2, #1
 801eb44:	f7fe fe7b 	bl	801d83e <bme68x_get_regs>
 801eb48:	4603      	mov	r3, r0
 801eb4a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            }

            if (rslt == BME68X_OK)
 801eb4e:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801eb52:	2b00      	cmp	r3, #0
 801eb54:	d139      	bne.n	801ebca <read_field_data+0x254>
            {
                data->temperature = calc_temperature(adc_temp, dev);
 801eb56:	6879      	ldr	r1, [r7, #4]
 801eb58:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801eb5a:	f7ff fac5 	bl	801e0e8 <calc_temperature>
 801eb5e:	eef0 7a40 	vmov.f32	s15, s0
 801eb62:	68bb      	ldr	r3, [r7, #8]
 801eb64:	edc3 7a02 	vstr	s15, [r3, #8]
                data->pressure = calc_pressure(adc_pres, dev);
 801eb68:	6879      	ldr	r1, [r7, #4]
 801eb6a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801eb6c:	f7ff fb42 	bl	801e1f4 <calc_pressure>
 801eb70:	eef0 7a40 	vmov.f32	s15, s0
 801eb74:	68bb      	ldr	r3, [r7, #8]
 801eb76:	edc3 7a03 	vstr	s15, [r3, #12]
                data->humidity = calc_humidity(adc_hum, dev);
 801eb7a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801eb7c:	6879      	ldr	r1, [r7, #4]
 801eb7e:	4618      	mov	r0, r3
 801eb80:	f7ff fc7a 	bl	801e478 <calc_humidity>
 801eb84:	eef0 7a40 	vmov.f32	s15, s0
 801eb88:	68bb      	ldr	r3, [r7, #8]
 801eb8a:	edc3 7a04 	vstr	s15, [r3, #16]
                if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 801eb8e:	687b      	ldr	r3, [r7, #4]
 801eb90:	689b      	ldr	r3, [r3, #8]
 801eb92:	2b01      	cmp	r3, #1
 801eb94:	d10c      	bne.n	801ebb0 <read_field_data+0x23a>
                {
                    data->gas_resistance = calc_gas_resistance_high(adc_gas_res_high, gas_range_h);
 801eb96:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 801eb9a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801eb9c:	4611      	mov	r1, r2
 801eb9e:	4618      	mov	r0, r3
 801eba0:	f7ff fdda 	bl	801e758 <calc_gas_resistance_high>
 801eba4:	eef0 7a40 	vmov.f32	s15, s0
 801eba8:	68bb      	ldr	r3, [r7, #8]
 801ebaa:	edc3 7a05 	vstr	s15, [r3, #20]
                else
                {
                    data->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
                }

                break;
 801ebae:	e026      	b.n	801ebfe <read_field_data+0x288>
                    data->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
 801ebb0:	f897 1025 	ldrb.w	r1, [r7, #37]	; 0x25
 801ebb4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801ebb6:	687a      	ldr	r2, [r7, #4]
 801ebb8:	4618      	mov	r0, r3
 801ebba:	f7ff fd29 	bl	801e610 <calc_gas_resistance_low>
 801ebbe:	eef0 7a40 	vmov.f32	s15, s0
 801ebc2:	68bb      	ldr	r3, [r7, #8]
 801ebc4:	edc3 7a05 	vstr	s15, [r3, #20]
                break;
 801ebc8:	e019      	b.n	801ebfe <read_field_data+0x288>
            }
        }

        if (rslt == BME68X_OK)
 801ebca:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801ebce:	2b00      	cmp	r3, #0
 801ebd0:	d107      	bne.n	801ebe2 <read_field_data+0x26c>
        {
            dev->delay_us(BME68X_PERIOD_POLL, dev->intf_ptr);
 801ebd2:	687b      	ldr	r3, [r7, #4]
 801ebd4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ebd6:	687a      	ldr	r2, [r7, #4]
 801ebd8:	6852      	ldr	r2, [r2, #4]
 801ebda:	4611      	mov	r1, r2
 801ebdc:	f242 7010 	movw	r0, #10000	; 0x2710
 801ebe0:	4798      	blx	r3
        }

        tries--;
 801ebe2:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801ebe6:	3b01      	subs	r3, #1
 801ebe8:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    while ((tries) && (rslt == BME68X_OK))
 801ebec:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801ebf0:	2b00      	cmp	r3, #0
 801ebf2:	d004      	beq.n	801ebfe <read_field_data+0x288>
 801ebf4:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801ebf8:	2b00      	cmp	r3, #0
 801ebfa:	f43f aed3 	beq.w	801e9a4 <read_field_data+0x2e>
    }

    return rslt;
 801ebfe:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
}
 801ec02:	4618      	mov	r0, r3
 801ec04:	3738      	adds	r7, #56	; 0x38
 801ec06:	46bd      	mov	sp, r7
 801ec08:	bd80      	pop	{r7, pc}

0801ec0a <read_all_field_data>:

/* This internal API is used to read all data fields of the sensor */
static int8_t read_all_field_data(struct bme68x_data * const data[], struct bme68x_dev *dev)
{
 801ec0a:	b590      	push	{r4, r7, lr}
 801ec0c:	b09d      	sub	sp, #116	; 0x74
 801ec0e:	af00      	add	r7, sp, #0
 801ec10:	6078      	str	r0, [r7, #4]
 801ec12:	6039      	str	r1, [r7, #0]
    int8_t rslt = BME68X_OK;
 801ec14:	2300      	movs	r3, #0
 801ec16:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
    uint8_t buff[BME68X_LEN_FIELD * 3] = { 0 };
 801ec1a:	2300      	movs	r3, #0
 801ec1c:	62bb      	str	r3, [r7, #40]	; 0x28
 801ec1e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801ec22:	222f      	movs	r2, #47	; 0x2f
 801ec24:	2100      	movs	r1, #0
 801ec26:	4618      	mov	r0, r3
 801ec28:	f00d fa68 	bl	802c0fc <memset>
    uint32_t adc_temp;
    uint32_t adc_pres;
    uint16_t adc_hum;
    uint16_t adc_gas_res_low, adc_gas_res_high;
    uint8_t off;
    uint8_t set_val[30] = { 0 }; /* idac, res_heat, gas_wait */
 801ec2c:	2300      	movs	r3, #0
 801ec2e:	60bb      	str	r3, [r7, #8]
 801ec30:	f107 030c 	add.w	r3, r7, #12
 801ec34:	2200      	movs	r2, #0
 801ec36:	601a      	str	r2, [r3, #0]
 801ec38:	605a      	str	r2, [r3, #4]
 801ec3a:	609a      	str	r2, [r3, #8]
 801ec3c:	60da      	str	r2, [r3, #12]
 801ec3e:	611a      	str	r2, [r3, #16]
 801ec40:	615a      	str	r2, [r3, #20]
 801ec42:	831a      	strh	r2, [r3, #24]
    uint8_t i;

    if (!data[0] && !data[1] && !data[2])
 801ec44:	687b      	ldr	r3, [r7, #4]
 801ec46:	681b      	ldr	r3, [r3, #0]
 801ec48:	2b00      	cmp	r3, #0
 801ec4a:	d10c      	bne.n	801ec66 <read_all_field_data+0x5c>
 801ec4c:	687b      	ldr	r3, [r7, #4]
 801ec4e:	3304      	adds	r3, #4
 801ec50:	681b      	ldr	r3, [r3, #0]
 801ec52:	2b00      	cmp	r3, #0
 801ec54:	d107      	bne.n	801ec66 <read_all_field_data+0x5c>
 801ec56:	687b      	ldr	r3, [r7, #4]
 801ec58:	3308      	adds	r3, #8
 801ec5a:	681b      	ldr	r3, [r3, #0]
 801ec5c:	2b00      	cmp	r3, #0
 801ec5e:	d102      	bne.n	801ec66 <read_all_field_data+0x5c>
    {
        rslt = BME68X_E_NULL_PTR;
 801ec60:	23ff      	movs	r3, #255	; 0xff
 801ec62:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
    }

    if (rslt == BME68X_OK)
 801ec66:	f997 306f 	ldrsb.w	r3, [r7, #111]	; 0x6f
 801ec6a:	2b00      	cmp	r3, #0
 801ec6c:	d109      	bne.n	801ec82 <read_all_field_data+0x78>
    {
        rslt = bme68x_get_regs(BME68X_REG_FIELD0, buff, (uint32_t) BME68X_LEN_FIELD * 3, dev);
 801ec6e:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801ec72:	683b      	ldr	r3, [r7, #0]
 801ec74:	2233      	movs	r2, #51	; 0x33
 801ec76:	201d      	movs	r0, #29
 801ec78:	f7fe fde1 	bl	801d83e <bme68x_get_regs>
 801ec7c:	4603      	mov	r3, r0
 801ec7e:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
    }

    if (rslt == BME68X_OK)
 801ec82:	f997 306f 	ldrsb.w	r3, [r7, #111]	; 0x6f
 801ec86:	2b00      	cmp	r3, #0
 801ec88:	d109      	bne.n	801ec9e <read_all_field_data+0x94>
    {
        rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0, set_val, 30, dev);
 801ec8a:	f107 0108 	add.w	r1, r7, #8
 801ec8e:	683b      	ldr	r3, [r7, #0]
 801ec90:	221e      	movs	r2, #30
 801ec92:	2050      	movs	r0, #80	; 0x50
 801ec94:	f7fe fdd3 	bl	801d83e <bme68x_get_regs>
 801ec98:	4603      	mov	r3, r0
 801ec9a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
    }

    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 801ec9e:	2300      	movs	r3, #0
 801eca0:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
 801eca4:	e1eb      	b.n	801f07e <read_all_field_data+0x474>
    {
        off = (uint8_t)(i * BME68X_LEN_FIELD);
 801eca6:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ecaa:	461a      	mov	r2, r3
 801ecac:	0112      	lsls	r2, r2, #4
 801ecae:	4413      	add	r3, r2
 801ecb0:	f887 306d 	strb.w	r3, [r7, #109]	; 0x6d
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
 801ecb4:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ecb8:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ecbc:	4413      	add	r3, r2
 801ecbe:	f813 2c48 	ldrb.w	r2, [r3, #-72]
 801ecc2:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ecc6:	009b      	lsls	r3, r3, #2
 801ecc8:	6879      	ldr	r1, [r7, #4]
 801ecca:	440b      	add	r3, r1
 801eccc:	681b      	ldr	r3, [r3, #0]
 801ecce:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 801ecd2:	b2d2      	uxtb	r2, r2
 801ecd4:	701a      	strb	r2, [r3, #0]
        data[i]->gas_index = buff[off] & BME68X_GAS_INDEX_MSK;
 801ecd6:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ecda:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ecde:	4413      	add	r3, r2
 801ece0:	f813 2c48 	ldrb.w	r2, [r3, #-72]
 801ece4:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ece8:	009b      	lsls	r3, r3, #2
 801ecea:	6879      	ldr	r1, [r7, #4]
 801ecec:	440b      	add	r3, r1
 801ecee:	681b      	ldr	r3, [r3, #0]
 801ecf0:	f002 020f 	and.w	r2, r2, #15
 801ecf4:	b2d2      	uxtb	r2, r2
 801ecf6:	705a      	strb	r2, [r3, #1]
        data[i]->meas_index = buff[off + 1];
 801ecf8:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ecfc:	1c5a      	adds	r2, r3, #1
 801ecfe:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ed02:	009b      	lsls	r3, r3, #2
 801ed04:	6879      	ldr	r1, [r7, #4]
 801ed06:	440b      	add	r3, r1
 801ed08:	681b      	ldr	r3, [r3, #0]
 801ed0a:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ed0e:	440a      	add	r2, r1
 801ed10:	f812 2c48 	ldrb.w	r2, [r2, #-72]
 801ed14:	709a      	strb	r2, [r3, #2]

        /* read the raw data from the sensor */
        adc_pres =
            (uint32_t) (((uint32_t) buff[off + 2] * 4096) | ((uint32_t) buff[off + 3] * 16) |
 801ed16:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ed1a:	3302      	adds	r3, #2
 801ed1c:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ed20:	4413      	add	r3, r2
 801ed22:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ed26:	031a      	lsls	r2, r3, #12
 801ed28:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ed2c:	3303      	adds	r3, #3
 801ed2e:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ed32:	440b      	add	r3, r1
 801ed34:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ed38:	011b      	lsls	r3, r3, #4
 801ed3a:	4313      	orrs	r3, r2
                        ((uint32_t) buff[off + 4] / 16));
 801ed3c:	f897 206d 	ldrb.w	r2, [r7, #109]	; 0x6d
 801ed40:	3204      	adds	r2, #4
 801ed42:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ed46:	440a      	add	r2, r1
 801ed48:	f812 2c48 	ldrb.w	r2, [r2, #-72]
 801ed4c:	0912      	lsrs	r2, r2, #4
 801ed4e:	b2d2      	uxtb	r2, r2
        adc_pres =
 801ed50:	4313      	orrs	r3, r2
 801ed52:	66bb      	str	r3, [r7, #104]	; 0x68
        adc_temp =
            (uint32_t) (((uint32_t) buff[off + 5] * 4096) | ((uint32_t) buff[off + 6] * 16) |
 801ed54:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ed58:	3305      	adds	r3, #5
 801ed5a:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ed5e:	4413      	add	r3, r2
 801ed60:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ed64:	031a      	lsls	r2, r3, #12
 801ed66:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ed6a:	3306      	adds	r3, #6
 801ed6c:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ed70:	440b      	add	r3, r1
 801ed72:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ed76:	011b      	lsls	r3, r3, #4
 801ed78:	4313      	orrs	r3, r2
                        ((uint32_t) buff[off + 7] / 16));
 801ed7a:	f897 206d 	ldrb.w	r2, [r7, #109]	; 0x6d
 801ed7e:	3207      	adds	r2, #7
 801ed80:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ed84:	440a      	add	r2, r1
 801ed86:	f812 2c48 	ldrb.w	r2, [r2, #-72]
 801ed8a:	0912      	lsrs	r2, r2, #4
 801ed8c:	b2d2      	uxtb	r2, r2
        adc_temp =
 801ed8e:	4313      	orrs	r3, r2
 801ed90:	667b      	str	r3, [r7, #100]	; 0x64
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
 801ed92:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ed96:	3308      	adds	r3, #8
 801ed98:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ed9c:	4413      	add	r3, r2
 801ed9e:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801eda2:	b29b      	uxth	r3, r3
 801eda4:	021b      	lsls	r3, r3, #8
 801eda6:	b29a      	uxth	r2, r3
 801eda8:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801edac:	3309      	adds	r3, #9
 801edae:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801edb2:	440b      	add	r3, r1
 801edb4:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801edb8:	b29b      	uxth	r3, r3
 801edba:	4313      	orrs	r3, r2
 801edbc:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
 801edc0:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801edc4:	330d      	adds	r3, #13
 801edc6:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801edca:	4413      	add	r3, r2
 801edcc:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801edd0:	b29b      	uxth	r3, r3
 801edd2:	009b      	lsls	r3, r3, #2
 801edd4:	b29a      	uxth	r2, r3
 801edd6:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801edda:	330e      	adds	r3, #14
 801eddc:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ede0:	440b      	add	r3, r1
 801ede2:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ede6:	099b      	lsrs	r3, r3, #6
 801ede8:	b2db      	uxtb	r3, r3
 801edea:	b29b      	uxth	r3, r3
 801edec:	4313      	orrs	r3, r2
 801edee:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
 801edf2:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801edf6:	330f      	adds	r3, #15
 801edf8:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801edfc:	4413      	add	r3, r2
 801edfe:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ee02:	b29b      	uxth	r3, r3
 801ee04:	009b      	lsls	r3, r3, #2
 801ee06:	b29a      	uxth	r2, r3
 801ee08:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ee0c:	3310      	adds	r3, #16
 801ee0e:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ee12:	440b      	add	r3, r1
 801ee14:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ee18:	099b      	lsrs	r3, r3, #6
 801ee1a:	b2db      	uxtb	r3, r3
 801ee1c:	b29b      	uxth	r3, r3
 801ee1e:	4313      	orrs	r3, r2
 801ee20:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
        gas_range_l = buff[off + 14] & BME68X_GAS_RANGE_MSK;
 801ee24:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ee28:	330e      	adds	r3, #14
 801ee2a:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ee2e:	4413      	add	r3, r2
 801ee30:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ee34:	f003 030f 	and.w	r3, r3, #15
 801ee38:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
        gas_range_h = buff[off + 16] & BME68X_GAS_RANGE_MSK;
 801ee3c:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ee40:	3310      	adds	r3, #16
 801ee42:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ee46:	4413      	add	r3, r2
 801ee48:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ee4c:	f003 030f 	and.w	r3, r3, #15
 801ee50:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 801ee54:	683b      	ldr	r3, [r7, #0]
 801ee56:	689b      	ldr	r3, [r3, #8]
 801ee58:	2b01      	cmp	r3, #1
 801ee5a:	d13c      	bne.n	801eed6 <read_all_field_data+0x2cc>
        {
            data[i]->status |= buff[off + 16] & BME68X_GASM_VALID_MSK;
 801ee5c:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ee60:	009b      	lsls	r3, r3, #2
 801ee62:	687a      	ldr	r2, [r7, #4]
 801ee64:	4413      	add	r3, r2
 801ee66:	681b      	ldr	r3, [r3, #0]
 801ee68:	781b      	ldrb	r3, [r3, #0]
 801ee6a:	b25a      	sxtb	r2, r3
 801ee6c:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ee70:	3310      	adds	r3, #16
 801ee72:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ee76:	440b      	add	r3, r1
 801ee78:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ee7c:	b25b      	sxtb	r3, r3
 801ee7e:	f003 0320 	and.w	r3, r3, #32
 801ee82:	b25b      	sxtb	r3, r3
 801ee84:	4313      	orrs	r3, r2
 801ee86:	b259      	sxtb	r1, r3
 801ee88:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ee8c:	009b      	lsls	r3, r3, #2
 801ee8e:	687a      	ldr	r2, [r7, #4]
 801ee90:	4413      	add	r3, r2
 801ee92:	681b      	ldr	r3, [r3, #0]
 801ee94:	b2ca      	uxtb	r2, r1
 801ee96:	701a      	strb	r2, [r3, #0]
            data[i]->status |= buff[off + 16] & BME68X_HEAT_STAB_MSK;
 801ee98:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ee9c:	009b      	lsls	r3, r3, #2
 801ee9e:	687a      	ldr	r2, [r7, #4]
 801eea0:	4413      	add	r3, r2
 801eea2:	681b      	ldr	r3, [r3, #0]
 801eea4:	781b      	ldrb	r3, [r3, #0]
 801eea6:	b25a      	sxtb	r2, r3
 801eea8:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801eeac:	3310      	adds	r3, #16
 801eeae:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801eeb2:	440b      	add	r3, r1
 801eeb4:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801eeb8:	b25b      	sxtb	r3, r3
 801eeba:	f003 0310 	and.w	r3, r3, #16
 801eebe:	b25b      	sxtb	r3, r3
 801eec0:	4313      	orrs	r3, r2
 801eec2:	b259      	sxtb	r1, r3
 801eec4:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801eec8:	009b      	lsls	r3, r3, #2
 801eeca:	687a      	ldr	r2, [r7, #4]
 801eecc:	4413      	add	r3, r2
 801eece:	681b      	ldr	r3, [r3, #0]
 801eed0:	b2ca      	uxtb	r2, r1
 801eed2:	701a      	strb	r2, [r3, #0]
 801eed4:	e03b      	b.n	801ef4e <read_all_field_data+0x344>
        }
        else
        {
            data[i]->status |= buff[off + 14] & BME68X_GASM_VALID_MSK;
 801eed6:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801eeda:	009b      	lsls	r3, r3, #2
 801eedc:	687a      	ldr	r2, [r7, #4]
 801eede:	4413      	add	r3, r2
 801eee0:	681b      	ldr	r3, [r3, #0]
 801eee2:	781b      	ldrb	r3, [r3, #0]
 801eee4:	b25a      	sxtb	r2, r3
 801eee6:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801eeea:	330e      	adds	r3, #14
 801eeec:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801eef0:	440b      	add	r3, r1
 801eef2:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801eef6:	b25b      	sxtb	r3, r3
 801eef8:	f003 0320 	and.w	r3, r3, #32
 801eefc:	b25b      	sxtb	r3, r3
 801eefe:	4313      	orrs	r3, r2
 801ef00:	b259      	sxtb	r1, r3
 801ef02:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef06:	009b      	lsls	r3, r3, #2
 801ef08:	687a      	ldr	r2, [r7, #4]
 801ef0a:	4413      	add	r3, r2
 801ef0c:	681b      	ldr	r3, [r3, #0]
 801ef0e:	b2ca      	uxtb	r2, r1
 801ef10:	701a      	strb	r2, [r3, #0]
            data[i]->status |= buff[off + 14] & BME68X_HEAT_STAB_MSK;
 801ef12:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef16:	009b      	lsls	r3, r3, #2
 801ef18:	687a      	ldr	r2, [r7, #4]
 801ef1a:	4413      	add	r3, r2
 801ef1c:	681b      	ldr	r3, [r3, #0]
 801ef1e:	781b      	ldrb	r3, [r3, #0]
 801ef20:	b25a      	sxtb	r2, r3
 801ef22:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 801ef26:	330e      	adds	r3, #14
 801ef28:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ef2c:	440b      	add	r3, r1
 801ef2e:	f813 3c48 	ldrb.w	r3, [r3, #-72]
 801ef32:	b25b      	sxtb	r3, r3
 801ef34:	f003 0310 	and.w	r3, r3, #16
 801ef38:	b25b      	sxtb	r3, r3
 801ef3a:	4313      	orrs	r3, r2
 801ef3c:	b259      	sxtb	r1, r3
 801ef3e:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef42:	009b      	lsls	r3, r3, #2
 801ef44:	687a      	ldr	r2, [r7, #4]
 801ef46:	4413      	add	r3, r2
 801ef48:	681b      	ldr	r3, [r3, #0]
 801ef4a:	b2ca      	uxtb	r2, r1
 801ef4c:	701a      	strb	r2, [r3, #0]
        }

        data[i]->idac = set_val[data[i]->gas_index];
 801ef4e:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef52:	009b      	lsls	r3, r3, #2
 801ef54:	687a      	ldr	r2, [r7, #4]
 801ef56:	4413      	add	r3, r2
 801ef58:	681b      	ldr	r3, [r3, #0]
 801ef5a:	785b      	ldrb	r3, [r3, #1]
 801ef5c:	4619      	mov	r1, r3
 801ef5e:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef62:	009b      	lsls	r3, r3, #2
 801ef64:	687a      	ldr	r2, [r7, #4]
 801ef66:	4413      	add	r3, r2
 801ef68:	681b      	ldr	r3, [r3, #0]
 801ef6a:	f107 0270 	add.w	r2, r7, #112	; 0x70
 801ef6e:	440a      	add	r2, r1
 801ef70:	f812 2c68 	ldrb.w	r2, [r2, #-104]
 801ef74:	711a      	strb	r2, [r3, #4]
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
 801ef76:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef7a:	009b      	lsls	r3, r3, #2
 801ef7c:	687a      	ldr	r2, [r7, #4]
 801ef7e:	4413      	add	r3, r2
 801ef80:	681b      	ldr	r3, [r3, #0]
 801ef82:	785b      	ldrb	r3, [r3, #1]
 801ef84:	f103 020a 	add.w	r2, r3, #10
 801ef88:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801ef8c:	009b      	lsls	r3, r3, #2
 801ef8e:	6879      	ldr	r1, [r7, #4]
 801ef90:	440b      	add	r3, r1
 801ef92:	681b      	ldr	r3, [r3, #0]
 801ef94:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801ef98:	440a      	add	r2, r1
 801ef9a:	f812 2c68 	ldrb.w	r2, [r2, #-104]
 801ef9e:	70da      	strb	r2, [r3, #3]
        data[i]->gas_wait = set_val[20 + data[i]->gas_index];
 801efa0:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801efa4:	009b      	lsls	r3, r3, #2
 801efa6:	687a      	ldr	r2, [r7, #4]
 801efa8:	4413      	add	r3, r2
 801efaa:	681b      	ldr	r3, [r3, #0]
 801efac:	785b      	ldrb	r3, [r3, #1]
 801efae:	f103 0214 	add.w	r2, r3, #20
 801efb2:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801efb6:	009b      	lsls	r3, r3, #2
 801efb8:	6879      	ldr	r1, [r7, #4]
 801efba:	440b      	add	r3, r1
 801efbc:	681b      	ldr	r3, [r3, #0]
 801efbe:	f107 0170 	add.w	r1, r7, #112	; 0x70
 801efc2:	440a      	add	r2, r1
 801efc4:	f812 2c68 	ldrb.w	r2, [r2, #-104]
 801efc8:	715a      	strb	r2, [r3, #5]
        data[i]->temperature = calc_temperature(adc_temp, dev);
 801efca:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801efce:	009b      	lsls	r3, r3, #2
 801efd0:	687a      	ldr	r2, [r7, #4]
 801efd2:	4413      	add	r3, r2
 801efd4:	681c      	ldr	r4, [r3, #0]
 801efd6:	6839      	ldr	r1, [r7, #0]
 801efd8:	6e78      	ldr	r0, [r7, #100]	; 0x64
 801efda:	f7ff f885 	bl	801e0e8 <calc_temperature>
 801efde:	eef0 7a40 	vmov.f32	s15, s0
 801efe2:	edc4 7a02 	vstr	s15, [r4, #8]
        data[i]->pressure = calc_pressure(adc_pres, dev);
 801efe6:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801efea:	009b      	lsls	r3, r3, #2
 801efec:	687a      	ldr	r2, [r7, #4]
 801efee:	4413      	add	r3, r2
 801eff0:	681c      	ldr	r4, [r3, #0]
 801eff2:	6839      	ldr	r1, [r7, #0]
 801eff4:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 801eff6:	f7ff f8fd 	bl	801e1f4 <calc_pressure>
 801effa:	eef0 7a40 	vmov.f32	s15, s0
 801effe:	edc4 7a03 	vstr	s15, [r4, #12]
        data[i]->humidity = calc_humidity(adc_hum, dev);
 801f002:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801f006:	009b      	lsls	r3, r3, #2
 801f008:	687a      	ldr	r2, [r7, #4]
 801f00a:	4413      	add	r3, r2
 801f00c:	681c      	ldr	r4, [r3, #0]
 801f00e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801f012:	6839      	ldr	r1, [r7, #0]
 801f014:	4618      	mov	r0, r3
 801f016:	f7ff fa2f 	bl	801e478 <calc_humidity>
 801f01a:	eef0 7a40 	vmov.f32	s15, s0
 801f01e:	edc4 7a04 	vstr	s15, [r4, #16]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
 801f022:	683b      	ldr	r3, [r7, #0]
 801f024:	689b      	ldr	r3, [r3, #8]
 801f026:	2b01      	cmp	r3, #1
 801f028:	d112      	bne.n	801f050 <read_all_field_data+0x446>
        {
            data[i]->gas_resistance = calc_gas_resistance_high(adc_gas_res_high, gas_range_h);
 801f02a:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801f02e:	009b      	lsls	r3, r3, #2
 801f030:	687a      	ldr	r2, [r7, #4]
 801f032:	4413      	add	r3, r2
 801f034:	681c      	ldr	r4, [r3, #0]
 801f036:	f897 205c 	ldrb.w	r2, [r7, #92]	; 0x5c
 801f03a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f03e:	4611      	mov	r1, r2
 801f040:	4618      	mov	r0, r3
 801f042:	f7ff fb89 	bl	801e758 <calc_gas_resistance_high>
 801f046:	eef0 7a40 	vmov.f32	s15, s0
 801f04a:	edc4 7a05 	vstr	s15, [r4, #20]
 801f04e:	e011      	b.n	801f074 <read_all_field_data+0x46a>
        }
        else
        {
            data[i]->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
 801f050:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801f054:	009b      	lsls	r3, r3, #2
 801f056:	687a      	ldr	r2, [r7, #4]
 801f058:	4413      	add	r3, r2
 801f05a:	681c      	ldr	r4, [r3, #0]
 801f05c:	f897 105d 	ldrb.w	r1, [r7, #93]	; 0x5d
 801f060:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801f064:	683a      	ldr	r2, [r7, #0]
 801f066:	4618      	mov	r0, r3
 801f068:	f7ff fad2 	bl	801e610 <calc_gas_resistance_low>
 801f06c:	eef0 7a40 	vmov.f32	s15, s0
 801f070:	edc4 7a05 	vstr	s15, [r4, #20]
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
 801f074:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801f078:	3301      	adds	r3, #1
 801f07a:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
 801f07e:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 801f082:	2b02      	cmp	r3, #2
 801f084:	d804      	bhi.n	801f090 <read_all_field_data+0x486>
 801f086:	f997 306f 	ldrsb.w	r3, [r7, #111]	; 0x6f
 801f08a:	2b00      	cmp	r3, #0
 801f08c:	f43f ae0b 	beq.w	801eca6 <read_all_field_data+0x9c>
        }
    }

    return rslt;
 801f090:	f997 306f 	ldrsb.w	r3, [r7, #111]	; 0x6f
}
 801f094:	4618      	mov	r0, r3
 801f096:	3774      	adds	r7, #116	; 0x74
 801f098:	46bd      	mov	sp, r7
 801f09a:	bd90      	pop	{r4, r7, pc}

0801f09c <set_mem_page>:

/* This internal API is used to switch between SPI memory pages */
static int8_t set_mem_page(uint8_t reg_addr, struct bme68x_dev *dev)
{
 801f09c:	b590      	push	{r4, r7, lr}
 801f09e:	b085      	sub	sp, #20
 801f0a0:	af00      	add	r7, sp, #0
 801f0a2:	4603      	mov	r3, r0
 801f0a4:	6039      	str	r1, [r7, #0]
 801f0a6:	71fb      	strb	r3, [r7, #7]
    int8_t rslt;
    uint8_t reg;
    uint8_t mem_page;

    /* Check for null pointers in the device structure*/
    rslt = null_ptr_check(dev);
 801f0a8:	6838      	ldr	r0, [r7, #0]
 801f0aa:	f000 f8b8 	bl	801f21e <null_ptr_check>
 801f0ae:	4603      	mov	r3, r0
 801f0b0:	73fb      	strb	r3, [r7, #15]
    if (rslt == BME68X_OK)
 801f0b2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801f0b6:	2b00      	cmp	r3, #0
 801f0b8:	d14f      	bne.n	801f15a <set_mem_page+0xbe>
    {
        if (reg_addr > 0x7f)
 801f0ba:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801f0be:	2b00      	cmp	r3, #0
 801f0c0:	da02      	bge.n	801f0c8 <set_mem_page+0x2c>
        {
            mem_page = BME68X_MEM_PAGE1;
 801f0c2:	2300      	movs	r3, #0
 801f0c4:	73bb      	strb	r3, [r7, #14]
 801f0c6:	e001      	b.n	801f0cc <set_mem_page+0x30>
        }
        else
        {
            mem_page = BME68X_MEM_PAGE0;
 801f0c8:	2310      	movs	r3, #16
 801f0ca:	73bb      	strb	r3, [r7, #14]
        }

        if (mem_page != dev->mem_page)
 801f0cc:	683b      	ldr	r3, [r7, #0]
 801f0ce:	7b5b      	ldrb	r3, [r3, #13]
 801f0d0:	7bba      	ldrb	r2, [r7, #14]
 801f0d2:	429a      	cmp	r2, r3
 801f0d4:	d041      	beq.n	801f15a <set_mem_page+0xbe>
        {
            dev->mem_page = mem_page;
 801f0d6:	683b      	ldr	r3, [r7, #0]
 801f0d8:	7bba      	ldrb	r2, [r7, #14]
 801f0da:	735a      	strb	r2, [r3, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 801f0dc:	683b      	ldr	r3, [r7, #0]
 801f0de:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801f0e0:	683b      	ldr	r3, [r7, #0]
 801f0e2:	685b      	ldr	r3, [r3, #4]
 801f0e4:	f107 010d 	add.w	r1, r7, #13
 801f0e8:	2201      	movs	r2, #1
 801f0ea:	20f3      	movs	r0, #243	; 0xf3
 801f0ec:	47a0      	blx	r4
 801f0ee:	4603      	mov	r3, r0
 801f0f0:	461a      	mov	r2, r3
 801f0f2:	683b      	ldr	r3, [r7, #0]
 801f0f4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
            if (dev->intf_rslt != 0)
 801f0f8:	683b      	ldr	r3, [r7, #0]
 801f0fa:	f993 304c 	ldrsb.w	r3, [r3, #76]	; 0x4c
 801f0fe:	2b00      	cmp	r3, #0
 801f100:	d001      	beq.n	801f106 <set_mem_page+0x6a>
            {
                rslt = BME68X_E_COM_FAIL;
 801f102:	23fe      	movs	r3, #254	; 0xfe
 801f104:	73fb      	strb	r3, [r7, #15]
            }

            if (rslt == BME68X_OK)
 801f106:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801f10a:	2b00      	cmp	r3, #0
 801f10c:	d125      	bne.n	801f15a <set_mem_page+0xbe>
            {
                reg = reg & (~BME68X_MEM_PAGE_MSK);
 801f10e:	7b7b      	ldrb	r3, [r7, #13]
 801f110:	f023 0310 	bic.w	r3, r3, #16
 801f114:	b2db      	uxtb	r3, r3
 801f116:	737b      	strb	r3, [r7, #13]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
 801f118:	683b      	ldr	r3, [r7, #0]
 801f11a:	7b5b      	ldrb	r3, [r3, #13]
 801f11c:	b25b      	sxtb	r3, r3
 801f11e:	f003 0310 	and.w	r3, r3, #16
 801f122:	b25a      	sxtb	r2, r3
 801f124:	7b7b      	ldrb	r3, [r7, #13]
 801f126:	b25b      	sxtb	r3, r3
 801f128:	4313      	orrs	r3, r2
 801f12a:	b25b      	sxtb	r3, r3
 801f12c:	b2db      	uxtb	r3, r3
 801f12e:	737b      	strb	r3, [r7, #13]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
 801f130:	683b      	ldr	r3, [r7, #0]
 801f132:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 801f134:	683b      	ldr	r3, [r7, #0]
 801f136:	685b      	ldr	r3, [r3, #4]
 801f138:	f107 010d 	add.w	r1, r7, #13
 801f13c:	2201      	movs	r2, #1
 801f13e:	2073      	movs	r0, #115	; 0x73
 801f140:	47a0      	blx	r4
 801f142:	4603      	mov	r3, r0
 801f144:	461a      	mov	r2, r3
 801f146:	683b      	ldr	r3, [r7, #0]
 801f148:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
                if (dev->intf_rslt != 0)
 801f14c:	683b      	ldr	r3, [r7, #0]
 801f14e:	f993 304c 	ldrsb.w	r3, [r3, #76]	; 0x4c
 801f152:	2b00      	cmp	r3, #0
 801f154:	d001      	beq.n	801f15a <set_mem_page+0xbe>
                {
                    rslt = BME68X_E_COM_FAIL;
 801f156:	23fe      	movs	r3, #254	; 0xfe
 801f158:	73fb      	strb	r3, [r7, #15]
                }
            }
        }
    }

    return rslt;
 801f15a:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801f15e:	4618      	mov	r0, r3
 801f160:	3714      	adds	r7, #20
 801f162:	46bd      	mov	sp, r7
 801f164:	bd90      	pop	{r4, r7, pc}

0801f166 <get_mem_page>:

/* This internal API is used to get the current SPI memory page */
static int8_t get_mem_page(struct bme68x_dev *dev)
{
 801f166:	b590      	push	{r4, r7, lr}
 801f168:	b085      	sub	sp, #20
 801f16a:	af00      	add	r7, sp, #0
 801f16c:	6078      	str	r0, [r7, #4]
    int8_t rslt;
    uint8_t reg;

    /* Check for null pointer in the device structure*/
    rslt = null_ptr_check(dev);
 801f16e:	6878      	ldr	r0, [r7, #4]
 801f170:	f000 f855 	bl	801f21e <null_ptr_check>
 801f174:	4603      	mov	r3, r0
 801f176:	73fb      	strb	r3, [r7, #15]
    if (rslt == BME68X_OK)
 801f178:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801f17c:	2b00      	cmp	r3, #0
 801f17e:	d11b      	bne.n	801f1b8 <get_mem_page+0x52>
    {
        dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
 801f180:	687b      	ldr	r3, [r7, #4]
 801f182:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801f184:	687b      	ldr	r3, [r7, #4]
 801f186:	685b      	ldr	r3, [r3, #4]
 801f188:	f107 010e 	add.w	r1, r7, #14
 801f18c:	2201      	movs	r2, #1
 801f18e:	20f3      	movs	r0, #243	; 0xf3
 801f190:	47a0      	blx	r4
 801f192:	4603      	mov	r3, r0
 801f194:	461a      	mov	r2, r3
 801f196:	687b      	ldr	r3, [r7, #4]
 801f198:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
        if (dev->intf_rslt != 0)
 801f19c:	687b      	ldr	r3, [r7, #4]
 801f19e:	f993 304c 	ldrsb.w	r3, [r3, #76]	; 0x4c
 801f1a2:	2b00      	cmp	r3, #0
 801f1a4:	d002      	beq.n	801f1ac <get_mem_page+0x46>
        {
            rslt = BME68X_E_COM_FAIL;
 801f1a6:	23fe      	movs	r3, #254	; 0xfe
 801f1a8:	73fb      	strb	r3, [r7, #15]
 801f1aa:	e005      	b.n	801f1b8 <get_mem_page+0x52>
        }
        else
        {
            dev->mem_page = reg & BME68X_MEM_PAGE_MSK;
 801f1ac:	7bbb      	ldrb	r3, [r7, #14]
 801f1ae:	f003 0310 	and.w	r3, r3, #16
 801f1b2:	b2da      	uxtb	r2, r3
 801f1b4:	687b      	ldr	r3, [r7, #4]
 801f1b6:	735a      	strb	r2, [r3, #13]
        }
    }

    return rslt;
 801f1b8:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801f1bc:	4618      	mov	r0, r3
 801f1be:	3714      	adds	r7, #20
 801f1c0:	46bd      	mov	sp, r7
 801f1c2:	bd90      	pop	{r4, r7, pc}

0801f1c4 <boundary_check>:

/* This internal API is used to limit the max value of a parameter */
static int8_t boundary_check(uint8_t *value, uint8_t max, struct bme68x_dev *dev)
{
 801f1c4:	b580      	push	{r7, lr}
 801f1c6:	b086      	sub	sp, #24
 801f1c8:	af00      	add	r7, sp, #0
 801f1ca:	60f8      	str	r0, [r7, #12]
 801f1cc:	460b      	mov	r3, r1
 801f1ce:	607a      	str	r2, [r7, #4]
 801f1d0:	72fb      	strb	r3, [r7, #11]
    int8_t rslt;

    rslt = null_ptr_check(dev);
 801f1d2:	6878      	ldr	r0, [r7, #4]
 801f1d4:	f000 f823 	bl	801f21e <null_ptr_check>
 801f1d8:	4603      	mov	r3, r0
 801f1da:	75fb      	strb	r3, [r7, #23]
    if ((value != NULL) && (rslt == BME68X_OK))
 801f1dc:	68fb      	ldr	r3, [r7, #12]
 801f1de:	2b00      	cmp	r3, #0
 801f1e0:	d015      	beq.n	801f20e <boundary_check+0x4a>
 801f1e2:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801f1e6:	2b00      	cmp	r3, #0
 801f1e8:	d111      	bne.n	801f20e <boundary_check+0x4a>
    {
        /* Check if value is above maximum value */
        if (*value > max)
 801f1ea:	68fb      	ldr	r3, [r7, #12]
 801f1ec:	781b      	ldrb	r3, [r3, #0]
 801f1ee:	7afa      	ldrb	r2, [r7, #11]
 801f1f0:	429a      	cmp	r2, r3
 801f1f2:	d20e      	bcs.n	801f212 <boundary_check+0x4e>
        {
            /* Auto correct the invalid value to maximum value */
            *value = max;
 801f1f4:	68fb      	ldr	r3, [r7, #12]
 801f1f6:	7afa      	ldrb	r2, [r7, #11]
 801f1f8:	701a      	strb	r2, [r3, #0]
            dev->info_msg |= BME68X_I_PARAM_CORR;
 801f1fa:	687b      	ldr	r3, [r7, #4]
 801f1fc:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 801f200:	f043 0301 	orr.w	r3, r3, #1
 801f204:	b2da      	uxtb	r2, r3
 801f206:	687b      	ldr	r3, [r7, #4]
 801f208:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
        if (*value > max)
 801f20c:	e001      	b.n	801f212 <boundary_check+0x4e>
        }
    }
    else
    {
        rslt = BME68X_E_NULL_PTR;
 801f20e:	23ff      	movs	r3, #255	; 0xff
 801f210:	75fb      	strb	r3, [r7, #23]
    }

    return rslt;
 801f212:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 801f216:	4618      	mov	r0, r3
 801f218:	3718      	adds	r7, #24
 801f21a:	46bd      	mov	sp, r7
 801f21c:	bd80      	pop	{r7, pc}

0801f21e <null_ptr_check>:

/* This internal API is used to check the bme68x_dev for null pointers */
static int8_t null_ptr_check(const struct bme68x_dev *dev)
{
 801f21e:	b480      	push	{r7}
 801f220:	b085      	sub	sp, #20
 801f222:	af00      	add	r7, sp, #0
 801f224:	6078      	str	r0, [r7, #4]
    int8_t rslt = BME68X_OK;
 801f226:	2300      	movs	r3, #0
 801f228:	73fb      	strb	r3, [r7, #15]

    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_us == NULL))
 801f22a:	687b      	ldr	r3, [r7, #4]
 801f22c:	2b00      	cmp	r3, #0
 801f22e:	d00b      	beq.n	801f248 <null_ptr_check+0x2a>
 801f230:	687b      	ldr	r3, [r7, #4]
 801f232:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801f234:	2b00      	cmp	r3, #0
 801f236:	d007      	beq.n	801f248 <null_ptr_check+0x2a>
 801f238:	687b      	ldr	r3, [r7, #4]
 801f23a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801f23c:	2b00      	cmp	r3, #0
 801f23e:	d003      	beq.n	801f248 <null_ptr_check+0x2a>
 801f240:	687b      	ldr	r3, [r7, #4]
 801f242:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801f244:	2b00      	cmp	r3, #0
 801f246:	d101      	bne.n	801f24c <null_ptr_check+0x2e>
    {
        /* Device structure pointer is not valid */
        rslt = BME68X_E_NULL_PTR;
 801f248:	23ff      	movs	r3, #255	; 0xff
 801f24a:	73fb      	strb	r3, [r7, #15]
    }

    return rslt;
 801f24c:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801f250:	4618      	mov	r0, r3
 801f252:	3714      	adds	r7, #20
 801f254:	46bd      	mov	sp, r7
 801f256:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f25a:	4770      	bx	lr

0801f25c <set_conf>:

/* This internal API is used to set heater configurations */
static int8_t set_conf(const struct bme68x_heatr_conf *conf, uint8_t op_mode, uint8_t *nb_conv, struct bme68x_dev *dev)
{
 801f25c:	b590      	push	{r4, r7, lr}
 801f25e:	b093      	sub	sp, #76	; 0x4c
 801f260:	af00      	add	r7, sp, #0
 801f262:	60f8      	str	r0, [r7, #12]
 801f264:	607a      	str	r2, [r7, #4]
 801f266:	603b      	str	r3, [r7, #0]
 801f268:	460b      	mov	r3, r1
 801f26a:	72fb      	strb	r3, [r7, #11]
    int8_t rslt = BME68X_OK;
 801f26c:	2300      	movs	r3, #0
 801f26e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    uint8_t i;
    uint8_t shared_dur;
    uint8_t write_len = 0;
 801f272:	2300      	movs	r3, #0
 801f274:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
    uint8_t heater_dur_shared_addr = BME68X_REG_SHD_HEATR_DUR;
 801f278:	236e      	movs	r3, #110	; 0x6e
 801f27a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 801f27e:	4aa3      	ldr	r2, [pc, #652]	; (801f50c <set_conf+0x2b0>)
 801f280:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801f284:	ca07      	ldmia	r2, {r0, r1, r2}
 801f286:	c303      	stmia	r3!, {r0, r1}
 801f288:	801a      	strh	r2, [r3, #0]
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 801f28a:	4aa0      	ldr	r2, [pc, #640]	; (801f50c <set_conf+0x2b0>)
 801f28c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801f290:	ca07      	ldmia	r2, {r0, r1, r2}
 801f292:	c303      	stmia	r3!, {r0, r1}
 801f294:	801a      	strh	r2, [r3, #0]
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 801f296:	4a9d      	ldr	r2, [pc, #628]	; (801f50c <set_conf+0x2b0>)
 801f298:	f107 0320 	add.w	r3, r7, #32
 801f29c:	ca07      	ldmia	r2, {r0, r1, r2}
 801f29e:	c303      	stmia	r3!, {r0, r1}
 801f2a0:	801a      	strh	r2, [r3, #0]
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 801f2a2:	4a9a      	ldr	r2, [pc, #616]	; (801f50c <set_conf+0x2b0>)
 801f2a4:	f107 0314 	add.w	r3, r7, #20
 801f2a8:	ca07      	ldmia	r2, {r0, r1, r2}
 801f2aa:	c303      	stmia	r3!, {r0, r1}
 801f2ac:	801a      	strh	r2, [r3, #0]

    switch (op_mode)
 801f2ae:	7afb      	ldrb	r3, [r7, #11]
 801f2b0:	2b03      	cmp	r3, #3
 801f2b2:	d024      	beq.n	801f2fe <set_conf+0xa2>
 801f2b4:	2b03      	cmp	r3, #3
 801f2b6:	f300 80fe 	bgt.w	801f4b6 <set_conf+0x25a>
 801f2ba:	2b01      	cmp	r3, #1
 801f2bc:	d002      	beq.n	801f2c4 <set_conf+0x68>
 801f2be:	2b02      	cmp	r3, #2
 801f2c0:	d07e      	beq.n	801f3c0 <set_conf+0x164>
 801f2c2:	e0f8      	b.n	801f4b6 <set_conf+0x25a>
    {
        case BME68X_FORCED_MODE:
            rh_reg_addr[0] = BME68X_REG_RES_HEAT0;
 801f2c4:	235a      	movs	r3, #90	; 0x5a
 801f2c6:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
            rh_reg_data[0] = calc_res_heat(conf->heatr_temp, dev);
 801f2ca:	68fb      	ldr	r3, [r7, #12]
 801f2cc:	885b      	ldrh	r3, [r3, #2]
 801f2ce:	6839      	ldr	r1, [r7, #0]
 801f2d0:	4618      	mov	r0, r3
 801f2d2:	f7ff fa7b 	bl	801e7cc <calc_res_heat>
 801f2d6:	4603      	mov	r3, r0
 801f2d8:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
 801f2dc:	2364      	movs	r3, #100	; 0x64
 801f2de:	f887 3020 	strb.w	r3, [r7, #32]
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
 801f2e2:	68fb      	ldr	r3, [r7, #12]
 801f2e4:	889b      	ldrh	r3, [r3, #4]
 801f2e6:	4618      	mov	r0, r3
 801f2e8:	f7ff fb20 	bl	801e92c <calc_gas_wait>
 801f2ec:	4603      	mov	r3, r0
 801f2ee:	753b      	strb	r3, [r7, #20]
            (*nb_conv) = 0;
 801f2f0:	687b      	ldr	r3, [r7, #4]
 801f2f2:	2200      	movs	r2, #0
 801f2f4:	701a      	strb	r2, [r3, #0]
            write_len = 1;
 801f2f6:	2301      	movs	r3, #1
 801f2f8:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
            break;
 801f2fc:	e0e0      	b.n	801f4c0 <set_conf+0x264>
        case BME68X_SEQUENTIAL_MODE:
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
 801f2fe:	68fb      	ldr	r3, [r7, #12]
 801f300:	68db      	ldr	r3, [r3, #12]
 801f302:	2b00      	cmp	r3, #0
 801f304:	d003      	beq.n	801f30e <set_conf+0xb2>
 801f306:	68fb      	ldr	r3, [r7, #12]
 801f308:	689b      	ldr	r3, [r3, #8]
 801f30a:	2b00      	cmp	r3, #0
 801f30c:	d103      	bne.n	801f316 <set_conf+0xba>
            {
                rslt = BME68X_E_NULL_PTR;
 801f30e:	23ff      	movs	r3, #255	; 0xff
 801f310:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                break;
 801f314:	e0d4      	b.n	801f4c0 <set_conf+0x264>
            }

            for (i = 0; i < conf->profile_len; i++)
 801f316:	2300      	movs	r3, #0
 801f318:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 801f31c:	e041      	b.n	801f3a2 <set_conf+0x146>
            {
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 801f31e:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f322:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f326:	325a      	adds	r2, #90	; 0x5a
 801f328:	b2d2      	uxtb	r2, r2
 801f32a:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801f32e:	440b      	add	r3, r1
 801f330:	f803 2c10 	strb.w	r2, [r3, #-16]
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
 801f334:	68fb      	ldr	r3, [r7, #12]
 801f336:	689a      	ldr	r2, [r3, #8]
 801f338:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f33c:	005b      	lsls	r3, r3, #1
 801f33e:	4413      	add	r3, r2
 801f340:	881b      	ldrh	r3, [r3, #0]
 801f342:	f897 4046 	ldrb.w	r4, [r7, #70]	; 0x46
 801f346:	6839      	ldr	r1, [r7, #0]
 801f348:	4618      	mov	r0, r3
 801f34a:	f7ff fa3f 	bl	801e7cc <calc_res_heat>
 801f34e:	4603      	mov	r3, r0
 801f350:	461a      	mov	r2, r3
 801f352:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801f356:	4423      	add	r3, r4
 801f358:	f803 2c1c 	strb.w	r2, [r3, #-28]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 801f35c:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f360:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f364:	3264      	adds	r2, #100	; 0x64
 801f366:	b2d2      	uxtb	r2, r2
 801f368:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801f36c:	440b      	add	r3, r1
 801f36e:	f803 2c28 	strb.w	r2, [r3, #-40]
                gw_reg_data[i] = calc_gas_wait(conf->heatr_dur_prof[i]);
 801f372:	68fb      	ldr	r3, [r7, #12]
 801f374:	68da      	ldr	r2, [r3, #12]
 801f376:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f37a:	005b      	lsls	r3, r3, #1
 801f37c:	4413      	add	r3, r2
 801f37e:	881b      	ldrh	r3, [r3, #0]
 801f380:	f897 4046 	ldrb.w	r4, [r7, #70]	; 0x46
 801f384:	4618      	mov	r0, r3
 801f386:	f7ff fad1 	bl	801e92c <calc_gas_wait>
 801f38a:	4603      	mov	r3, r0
 801f38c:	461a      	mov	r2, r3
 801f38e:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801f392:	4423      	add	r3, r4
 801f394:	f803 2c34 	strb.w	r2, [r3, #-52]
            for (i = 0; i < conf->profile_len; i++)
 801f398:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f39c:	3301      	adds	r3, #1
 801f39e:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 801f3a2:	68fb      	ldr	r3, [r7, #12]
 801f3a4:	7c1b      	ldrb	r3, [r3, #16]
 801f3a6:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f3aa:	429a      	cmp	r2, r3
 801f3ac:	d3b7      	bcc.n	801f31e <set_conf+0xc2>
            }

            (*nb_conv) = conf->profile_len;
 801f3ae:	68fb      	ldr	r3, [r7, #12]
 801f3b0:	7c1a      	ldrb	r2, [r3, #16]
 801f3b2:	687b      	ldr	r3, [r7, #4]
 801f3b4:	701a      	strb	r2, [r3, #0]
            write_len = conf->profile_len;
 801f3b6:	68fb      	ldr	r3, [r7, #12]
 801f3b8:	7c1b      	ldrb	r3, [r3, #16]
 801f3ba:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
            break;
 801f3be:	e07f      	b.n	801f4c0 <set_conf+0x264>
        case BME68X_PARALLEL_MODE:
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
 801f3c0:	68fb      	ldr	r3, [r7, #12]
 801f3c2:	68db      	ldr	r3, [r3, #12]
 801f3c4:	2b00      	cmp	r3, #0
 801f3c6:	d003      	beq.n	801f3d0 <set_conf+0x174>
 801f3c8:	68fb      	ldr	r3, [r7, #12]
 801f3ca:	689b      	ldr	r3, [r3, #8]
 801f3cc:	2b00      	cmp	r3, #0
 801f3ce:	d103      	bne.n	801f3d8 <set_conf+0x17c>
            {
                rslt = BME68X_E_NULL_PTR;
 801f3d0:	23ff      	movs	r3, #255	; 0xff
 801f3d2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                break;
 801f3d6:	e073      	b.n	801f4c0 <set_conf+0x264>
            }

            if (conf->shared_heatr_dur == 0)
 801f3d8:	68fb      	ldr	r3, [r7, #12]
 801f3da:	8a5b      	ldrh	r3, [r3, #18]
 801f3dc:	2b00      	cmp	r3, #0
 801f3de:	d102      	bne.n	801f3e6 <set_conf+0x18a>
            {
                rslt = BME68X_W_DEFINE_SHD_HEATR_DUR;
 801f3e0:	2303      	movs	r3, #3
 801f3e2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            }

            for (i = 0; i < conf->profile_len; i++)
 801f3e6:	2300      	movs	r3, #0
 801f3e8:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 801f3ec:	e03d      	b.n	801f46a <set_conf+0x20e>
            {
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
 801f3ee:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f3f2:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f3f6:	325a      	adds	r2, #90	; 0x5a
 801f3f8:	b2d2      	uxtb	r2, r2
 801f3fa:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801f3fe:	440b      	add	r3, r1
 801f400:	f803 2c10 	strb.w	r2, [r3, #-16]
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
 801f404:	68fb      	ldr	r3, [r7, #12]
 801f406:	689a      	ldr	r2, [r3, #8]
 801f408:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f40c:	005b      	lsls	r3, r3, #1
 801f40e:	4413      	add	r3, r2
 801f410:	881b      	ldrh	r3, [r3, #0]
 801f412:	f897 4046 	ldrb.w	r4, [r7, #70]	; 0x46
 801f416:	6839      	ldr	r1, [r7, #0]
 801f418:	4618      	mov	r0, r3
 801f41a:	f7ff f9d7 	bl	801e7cc <calc_res_heat>
 801f41e:	4603      	mov	r3, r0
 801f420:	461a      	mov	r2, r3
 801f422:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801f426:	4423      	add	r3, r4
 801f428:	f803 2c1c 	strb.w	r2, [r3, #-28]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
 801f42c:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f430:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f434:	3264      	adds	r2, #100	; 0x64
 801f436:	b2d2      	uxtb	r2, r2
 801f438:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801f43c:	440b      	add	r3, r1
 801f43e:	f803 2c28 	strb.w	r2, [r3, #-40]
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
 801f442:	68fb      	ldr	r3, [r7, #12]
 801f444:	68da      	ldr	r2, [r3, #12]
 801f446:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f44a:	005b      	lsls	r3, r3, #1
 801f44c:	4413      	add	r3, r2
 801f44e:	881a      	ldrh	r2, [r3, #0]
 801f450:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f454:	b2d2      	uxtb	r2, r2
 801f456:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801f45a:	440b      	add	r3, r1
 801f45c:	f803 2c34 	strb.w	r2, [r3, #-52]
            for (i = 0; i < conf->profile_len; i++)
 801f460:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 801f464:	3301      	adds	r3, #1
 801f466:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 801f46a:	68fb      	ldr	r3, [r7, #12]
 801f46c:	7c1b      	ldrb	r3, [r3, #16]
 801f46e:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 801f472:	429a      	cmp	r2, r3
 801f474:	d3bb      	bcc.n	801f3ee <set_conf+0x192>
            }

            (*nb_conv) = conf->profile_len;
 801f476:	68fb      	ldr	r3, [r7, #12]
 801f478:	7c1a      	ldrb	r2, [r3, #16]
 801f47a:	687b      	ldr	r3, [r7, #4]
 801f47c:	701a      	strb	r2, [r3, #0]
            write_len = conf->profile_len;
 801f47e:	68fb      	ldr	r3, [r7, #12]
 801f480:	7c1b      	ldrb	r3, [r3, #16]
 801f482:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
            shared_dur = calc_heatr_dur_shared(conf->shared_heatr_dur);
 801f486:	68fb      	ldr	r3, [r7, #12]
 801f488:	8a5b      	ldrh	r3, [r3, #18]
 801f48a:	4618      	mov	r0, r3
 801f48c:	f000 f840 	bl	801f510 <calc_heatr_dur_shared>
 801f490:	4603      	mov	r3, r0
 801f492:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
            if (rslt == BME68X_OK)
 801f496:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801f49a:	2b00      	cmp	r3, #0
 801f49c:	d10f      	bne.n	801f4be <set_conf+0x262>
            {
                rslt = bme68x_set_regs(&heater_dur_shared_addr, &shared_dur, 1, dev);
 801f49e:	f107 0144 	add.w	r1, r7, #68	; 0x44
 801f4a2:	f107 0043 	add.w	r0, r7, #67	; 0x43
 801f4a6:	683b      	ldr	r3, [r7, #0]
 801f4a8:	2201      	movs	r2, #1
 801f4aa:	f7fe f935 	bl	801d718 <bme68x_set_regs>
 801f4ae:	4603      	mov	r3, r0
 801f4b0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            }

            break;
 801f4b4:	e003      	b.n	801f4be <set_conf+0x262>
        default:
            rslt = BME68X_W_DEFINE_OP_MODE;
 801f4b6:	2301      	movs	r3, #1
 801f4b8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801f4bc:	e000      	b.n	801f4c0 <set_conf+0x264>
            break;
 801f4be:	bf00      	nop
    }

    if (rslt == BME68X_OK)
 801f4c0:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801f4c4:	2b00      	cmp	r3, #0
 801f4c6:	d10b      	bne.n	801f4e0 <set_conf+0x284>
    {
        rslt = bme68x_set_regs(rh_reg_addr, rh_reg_data, write_len, dev);
 801f4c8:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 801f4cc:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 801f4d0:	f107 0038 	add.w	r0, r7, #56	; 0x38
 801f4d4:	683b      	ldr	r3, [r7, #0]
 801f4d6:	f7fe f91f 	bl	801d718 <bme68x_set_regs>
 801f4da:	4603      	mov	r3, r0
 801f4dc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    }

    if (rslt == BME68X_OK)
 801f4e0:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801f4e4:	2b00      	cmp	r3, #0
 801f4e6:	d10b      	bne.n	801f500 <set_conf+0x2a4>
    {
        rslt = bme68x_set_regs(gw_reg_addr, gw_reg_data, write_len, dev);
 801f4e8:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 801f4ec:	f107 0114 	add.w	r1, r7, #20
 801f4f0:	f107 0020 	add.w	r0, r7, #32
 801f4f4:	683b      	ldr	r3, [r7, #0]
 801f4f6:	f7fe f90f 	bl	801d718 <bme68x_set_regs>
 801f4fa:	4603      	mov	r3, r0
 801f4fc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    }

    return rslt;
 801f500:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
}
 801f504:	4618      	mov	r0, r3
 801f506:	374c      	adds	r7, #76	; 0x4c
 801f508:	46bd      	mov	sp, r7
 801f50a:	bd90      	pop	{r4, r7, pc}
 801f50c:	0802c608 	.word	0x0802c608

0801f510 <calc_heatr_dur_shared>:

/* This internal API is used to calculate the register value for
 * shared heater duration */
static uint8_t calc_heatr_dur_shared(uint16_t dur)
{
 801f510:	b480      	push	{r7}
 801f512:	b085      	sub	sp, #20
 801f514:	af00      	add	r7, sp, #0
 801f516:	4603      	mov	r3, r0
 801f518:	80fb      	strh	r3, [r7, #6]
    uint8_t factor = 0;
 801f51a:	2300      	movs	r3, #0
 801f51c:	73fb      	strb	r3, [r7, #15]
    uint8_t heatdurval;

    if (dur >= 0x783)
 801f51e:	88fb      	ldrh	r3, [r7, #6]
 801f520:	f240 7282 	movw	r2, #1922	; 0x782
 801f524:	4293      	cmp	r3, r2
 801f526:	d902      	bls.n	801f52e <calc_heatr_dur_shared+0x1e>
    {
        heatdurval = 0xff; /* Max duration */
 801f528:	23ff      	movs	r3, #255	; 0xff
 801f52a:	73bb      	strb	r3, [r7, #14]
 801f52c:	e01d      	b.n	801f56a <calc_heatr_dur_shared+0x5a>
    }
    else
    {
        /* Step size of 0.477ms */
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
 801f52e:	88fb      	ldrh	r3, [r7, #6]
 801f530:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801f534:	fb02 f203 	mul.w	r2, r2, r3
 801f538:	4b0f      	ldr	r3, [pc, #60]	; (801f578 <calc_heatr_dur_shared+0x68>)
 801f53a:	fba3 1302 	umull	r1, r3, r3, r2
 801f53e:	1ad2      	subs	r2, r2, r3
 801f540:	0852      	lsrs	r2, r2, #1
 801f542:	4413      	add	r3, r2
 801f544:	0a1b      	lsrs	r3, r3, #8
 801f546:	80fb      	strh	r3, [r7, #6]
        while (dur > 0x3F)
 801f548:	e005      	b.n	801f556 <calc_heatr_dur_shared+0x46>
        {
            dur = dur >> 2;
 801f54a:	88fb      	ldrh	r3, [r7, #6]
 801f54c:	089b      	lsrs	r3, r3, #2
 801f54e:	80fb      	strh	r3, [r7, #6]
            factor += 1;
 801f550:	7bfb      	ldrb	r3, [r7, #15]
 801f552:	3301      	adds	r3, #1
 801f554:	73fb      	strb	r3, [r7, #15]
        while (dur > 0x3F)
 801f556:	88fb      	ldrh	r3, [r7, #6]
 801f558:	2b3f      	cmp	r3, #63	; 0x3f
 801f55a:	d8f6      	bhi.n	801f54a <calc_heatr_dur_shared+0x3a>
        }

        heatdurval = (uint8_t)(dur + (factor * 64));
 801f55c:	88fb      	ldrh	r3, [r7, #6]
 801f55e:	b2da      	uxtb	r2, r3
 801f560:	7bfb      	ldrb	r3, [r7, #15]
 801f562:	019b      	lsls	r3, r3, #6
 801f564:	b2db      	uxtb	r3, r3
 801f566:	4413      	add	r3, r2
 801f568:	73bb      	strb	r3, [r7, #14]
    }

    return heatdurval;
 801f56a:	7bbb      	ldrb	r3, [r7, #14]
}
 801f56c:	4618      	mov	r0, r3
 801f56e:	3714      	adds	r7, #20
 801f570:	46bd      	mov	sp, r7
 801f572:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f576:	4770      	bx	lr
 801f578:	12c8b89f 	.word	0x12c8b89f

0801f57c <sort_sensor_data>:

/* This internal API is used sort the sensor data */
static void sort_sensor_data(uint8_t low_index, uint8_t high_index, struct bme68x_data *field[])
{
 801f57c:	b580      	push	{r7, lr}
 801f57e:	b084      	sub	sp, #16
 801f580:	af00      	add	r7, sp, #0
 801f582:	4603      	mov	r3, r0
 801f584:	603a      	str	r2, [r7, #0]
 801f586:	71fb      	strb	r3, [r7, #7]
 801f588:	460b      	mov	r3, r1
 801f58a:	71bb      	strb	r3, [r7, #6]
    int16_t meas_index1;
    int16_t meas_index2;

    meas_index1 = (int16_t)field[low_index]->meas_index;
 801f58c:	79fb      	ldrb	r3, [r7, #7]
 801f58e:	009b      	lsls	r3, r3, #2
 801f590:	683a      	ldr	r2, [r7, #0]
 801f592:	4413      	add	r3, r2
 801f594:	681b      	ldr	r3, [r3, #0]
 801f596:	789b      	ldrb	r3, [r3, #2]
 801f598:	81fb      	strh	r3, [r7, #14]
    meas_index2 = (int16_t)field[high_index]->meas_index;
 801f59a:	79bb      	ldrb	r3, [r7, #6]
 801f59c:	009b      	lsls	r3, r3, #2
 801f59e:	683a      	ldr	r2, [r7, #0]
 801f5a0:	4413      	add	r3, r2
 801f5a2:	681b      	ldr	r3, [r3, #0]
 801f5a4:	789b      	ldrb	r3, [r3, #2]
 801f5a6:	81bb      	strh	r3, [r7, #12]
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
 801f5a8:	79fb      	ldrb	r3, [r7, #7]
 801f5aa:	009b      	lsls	r3, r3, #2
 801f5ac:	683a      	ldr	r2, [r7, #0]
 801f5ae:	4413      	add	r3, r2
 801f5b0:	681b      	ldr	r3, [r3, #0]
 801f5b2:	781b      	ldrb	r3, [r3, #0]
 801f5b4:	b25b      	sxtb	r3, r3
 801f5b6:	2b00      	cmp	r3, #0
 801f5b8:	da21      	bge.n	801f5fe <sort_sensor_data+0x82>
 801f5ba:	79bb      	ldrb	r3, [r7, #6]
 801f5bc:	009b      	lsls	r3, r3, #2
 801f5be:	683a      	ldr	r2, [r7, #0]
 801f5c0:	4413      	add	r3, r2
 801f5c2:	681b      	ldr	r3, [r3, #0]
 801f5c4:	781b      	ldrb	r3, [r3, #0]
 801f5c6:	b25b      	sxtb	r3, r3
 801f5c8:	2b00      	cmp	r3, #0
 801f5ca:	da18      	bge.n	801f5fe <sort_sensor_data+0x82>
    {
        int16_t diff = meas_index2 - meas_index1;
 801f5cc:	89ba      	ldrh	r2, [r7, #12]
 801f5ce:	89fb      	ldrh	r3, [r7, #14]
 801f5d0:	1ad3      	subs	r3, r2, r3
 801f5d2:	b29b      	uxth	r3, r3
 801f5d4:	817b      	strh	r3, [r7, #10]
        if (((diff > -3) && (diff < 0)) || (diff > 2))
 801f5d6:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801f5da:	f113 0f02 	cmn.w	r3, #2
 801f5de:	db03      	blt.n	801f5e8 <sort_sensor_data+0x6c>
 801f5e0:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801f5e4:	2b00      	cmp	r3, #0
 801f5e6:	db03      	blt.n	801f5f0 <sort_sensor_data+0x74>
 801f5e8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801f5ec:	2b02      	cmp	r3, #2
 801f5ee:	dd16      	ble.n	801f61e <sort_sensor_data+0xa2>
        {
            swap_fields(low_index, high_index, field);
 801f5f0:	79b9      	ldrb	r1, [r7, #6]
 801f5f2:	79fb      	ldrb	r3, [r7, #7]
 801f5f4:	683a      	ldr	r2, [r7, #0]
 801f5f6:	4618      	mov	r0, r3
 801f5f8:	f000 f816 	bl	801f628 <swap_fields>
    {
 801f5fc:	e00f      	b.n	801f61e <sort_sensor_data+0xa2>
        }
    }
    else if (field[high_index]->status & BME68X_NEW_DATA_MSK)
 801f5fe:	79bb      	ldrb	r3, [r7, #6]
 801f600:	009b      	lsls	r3, r3, #2
 801f602:	683a      	ldr	r2, [r7, #0]
 801f604:	4413      	add	r3, r2
 801f606:	681b      	ldr	r3, [r3, #0]
 801f608:	781b      	ldrb	r3, [r3, #0]
 801f60a:	b25b      	sxtb	r3, r3
 801f60c:	2b00      	cmp	r3, #0
 801f60e:	da07      	bge.n	801f620 <sort_sensor_data+0xa4>
    {
        swap_fields(low_index, high_index, field);
 801f610:	79b9      	ldrb	r1, [r7, #6]
 801f612:	79fb      	ldrb	r3, [r7, #7]
 801f614:	683a      	ldr	r2, [r7, #0]
 801f616:	4618      	mov	r0, r3
 801f618:	f000 f806 	bl	801f628 <swap_fields>
     *         - diff > 2, case 4.
     *
     *     Here the limits of -3 and 2 derive from the fact that there are 3 fields.
     *     These values decrease or increase respectively if the number of fields increases.
     */
}
 801f61c:	e000      	b.n	801f620 <sort_sensor_data+0xa4>
    {
 801f61e:	bf00      	nop
}
 801f620:	bf00      	nop
 801f622:	3710      	adds	r7, #16
 801f624:	46bd      	mov	sp, r7
 801f626:	bd80      	pop	{r7, pc}

0801f628 <swap_fields>:

/* This internal API is used sort the sensor data */
static void swap_fields(uint8_t index1, uint8_t index2, struct bme68x_data *field[])
{
 801f628:	b480      	push	{r7}
 801f62a:	b085      	sub	sp, #20
 801f62c:	af00      	add	r7, sp, #0
 801f62e:	4603      	mov	r3, r0
 801f630:	603a      	str	r2, [r7, #0]
 801f632:	71fb      	strb	r3, [r7, #7]
 801f634:	460b      	mov	r3, r1
 801f636:	71bb      	strb	r3, [r7, #6]
    struct bme68x_data *temp;

    temp = field[index1];
 801f638:	79fb      	ldrb	r3, [r7, #7]
 801f63a:	009b      	lsls	r3, r3, #2
 801f63c:	683a      	ldr	r2, [r7, #0]
 801f63e:	4413      	add	r3, r2
 801f640:	681b      	ldr	r3, [r3, #0]
 801f642:	60fb      	str	r3, [r7, #12]
    field[index1] = field[index2];
 801f644:	79bb      	ldrb	r3, [r7, #6]
 801f646:	009b      	lsls	r3, r3, #2
 801f648:	683a      	ldr	r2, [r7, #0]
 801f64a:	441a      	add	r2, r3
 801f64c:	79fb      	ldrb	r3, [r7, #7]
 801f64e:	009b      	lsls	r3, r3, #2
 801f650:	6839      	ldr	r1, [r7, #0]
 801f652:	440b      	add	r3, r1
 801f654:	6812      	ldr	r2, [r2, #0]
 801f656:	601a      	str	r2, [r3, #0]
    field[index2] = temp;
 801f658:	79bb      	ldrb	r3, [r7, #6]
 801f65a:	009b      	lsls	r3, r3, #2
 801f65c:	683a      	ldr	r2, [r7, #0]
 801f65e:	4413      	add	r3, r2
 801f660:	68fa      	ldr	r2, [r7, #12]
 801f662:	601a      	str	r2, [r3, #0]
}
 801f664:	bf00      	nop
 801f666:	3714      	adds	r7, #20
 801f668:	46bd      	mov	sp, r7
 801f66a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f66e:	4770      	bx	lr

0801f670 <get_calib_data>:
    return rslt;
}

/* This internal API is used to read the calibration coefficients */
static int8_t get_calib_data(struct bme68x_dev *dev)
{
 801f670:	b580      	push	{r7, lr}
 801f672:	b08e      	sub	sp, #56	; 0x38
 801f674:	af00      	add	r7, sp, #0
 801f676:	6078      	str	r0, [r7, #4]
    int8_t rslt;
    uint8_t coeff_array[BME68X_LEN_COEFF_ALL];

    rslt = bme68x_get_regs(BME68X_REG_COEFF1, coeff_array, BME68X_LEN_COEFF1, dev);
 801f678:	f107 010c 	add.w	r1, r7, #12
 801f67c:	687b      	ldr	r3, [r7, #4]
 801f67e:	2217      	movs	r2, #23
 801f680:	208a      	movs	r0, #138	; 0x8a
 801f682:	f7fe f8dc 	bl	801d83e <bme68x_get_regs>
 801f686:	4603      	mov	r3, r0
 801f688:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    if (rslt == BME68X_OK)
 801f68c:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801f690:	2b00      	cmp	r3, #0
 801f692:	d10b      	bne.n	801f6ac <get_calib_data+0x3c>
    {
        rslt = bme68x_get_regs(BME68X_REG_COEFF2, &coeff_array[BME68X_LEN_COEFF1], BME68X_LEN_COEFF2, dev);
 801f694:	f107 030c 	add.w	r3, r7, #12
 801f698:	f103 0117 	add.w	r1, r3, #23
 801f69c:	687b      	ldr	r3, [r7, #4]
 801f69e:	220e      	movs	r2, #14
 801f6a0:	20e1      	movs	r0, #225	; 0xe1
 801f6a2:	f7fe f8cc 	bl	801d83e <bme68x_get_regs>
 801f6a6:	4603      	mov	r3, r0
 801f6a8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    }

    if (rslt == BME68X_OK)
 801f6ac:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801f6b0:	2b00      	cmp	r3, #0
 801f6b2:	d10b      	bne.n	801f6cc <get_calib_data+0x5c>
    {
        rslt = bme68x_get_regs(BME68X_REG_COEFF3,
 801f6b4:	f107 030c 	add.w	r3, r7, #12
 801f6b8:	f103 0125 	add.w	r1, r3, #37	; 0x25
 801f6bc:	687b      	ldr	r3, [r7, #4]
 801f6be:	2205      	movs	r2, #5
 801f6c0:	2000      	movs	r0, #0
 801f6c2:	f7fe f8bc 	bl	801d83e <bme68x_get_regs>
 801f6c6:	4603      	mov	r3, r0
 801f6c8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                               &coeff_array[BME68X_LEN_COEFF1 + BME68X_LEN_COEFF2],
                               BME68X_LEN_COEFF3,
                               dev);
    }

    if (rslt == BME68X_OK)
 801f6cc:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
 801f6d0:	2b00      	cmp	r3, #0
 801f6d2:	f040 80cb 	bne.w	801f86c <get_calib_data+0x1fc>
    {
        /* Temperature related coefficients */
        dev->calib.par_t1 =
            (uint16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_T1_MSB], coeff_array[BME68X_IDX_T1_LSB]));
 801f6d6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801f6da:	021b      	lsls	r3, r3, #8
 801f6dc:	b21a      	sxth	r2, r3
 801f6de:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801f6e2:	b21b      	sxth	r3, r3
 801f6e4:	4313      	orrs	r3, r2
 801f6e6:	b21b      	sxth	r3, r3
 801f6e8:	b29a      	uxth	r2, r3
        dev->calib.par_t1 =
 801f6ea:	687b      	ldr	r3, [r7, #4]
 801f6ec:	83da      	strh	r2, [r3, #30]
        dev->calib.par_t2 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_T2_MSB], coeff_array[BME68X_IDX_T2_LSB]));
 801f6ee:	7b7b      	ldrb	r3, [r7, #13]
 801f6f0:	021b      	lsls	r3, r3, #8
 801f6f2:	b21a      	sxth	r2, r3
 801f6f4:	7b3b      	ldrb	r3, [r7, #12]
 801f6f6:	b21b      	sxth	r3, r3
 801f6f8:	4313      	orrs	r3, r2
 801f6fa:	b21a      	sxth	r2, r3
        dev->calib.par_t2 =
 801f6fc:	687b      	ldr	r3, [r7, #4]
 801f6fe:	841a      	strh	r2, [r3, #32]
        dev->calib.par_t3 = (int8_t)(coeff_array[BME68X_IDX_T3]);
 801f700:	7bbb      	ldrb	r3, [r7, #14]
 801f702:	b25a      	sxtb	r2, r3
 801f704:	687b      	ldr	r3, [r7, #4]
 801f706:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

        /* Pressure related coefficients */
        dev->calib.par_p1 =
            (uint16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P1_MSB], coeff_array[BME68X_IDX_P1_LSB]));
 801f70a:	7c7b      	ldrb	r3, [r7, #17]
 801f70c:	021b      	lsls	r3, r3, #8
 801f70e:	b21a      	sxth	r2, r3
 801f710:	7c3b      	ldrb	r3, [r7, #16]
 801f712:	b21b      	sxth	r3, r3
 801f714:	4313      	orrs	r3, r2
 801f716:	b21b      	sxth	r3, r3
 801f718:	b29a      	uxth	r2, r3
        dev->calib.par_p1 =
 801f71a:	687b      	ldr	r3, [r7, #4]
 801f71c:	849a      	strh	r2, [r3, #36]	; 0x24
        dev->calib.par_p2 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P2_MSB], coeff_array[BME68X_IDX_P2_LSB]));
 801f71e:	7cfb      	ldrb	r3, [r7, #19]
 801f720:	021b      	lsls	r3, r3, #8
 801f722:	b21a      	sxth	r2, r3
 801f724:	7cbb      	ldrb	r3, [r7, #18]
 801f726:	b21b      	sxth	r3, r3
 801f728:	4313      	orrs	r3, r2
 801f72a:	b21a      	sxth	r2, r3
        dev->calib.par_p2 =
 801f72c:	687b      	ldr	r3, [r7, #4]
 801f72e:	84da      	strh	r2, [r3, #38]	; 0x26
        dev->calib.par_p3 = (int8_t)coeff_array[BME68X_IDX_P3];
 801f730:	7d3b      	ldrb	r3, [r7, #20]
 801f732:	b25a      	sxtb	r2, r3
 801f734:	687b      	ldr	r3, [r7, #4]
 801f736:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
        dev->calib.par_p4 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P4_MSB], coeff_array[BME68X_IDX_P4_LSB]));
 801f73a:	7dfb      	ldrb	r3, [r7, #23]
 801f73c:	021b      	lsls	r3, r3, #8
 801f73e:	b21a      	sxth	r2, r3
 801f740:	7dbb      	ldrb	r3, [r7, #22]
 801f742:	b21b      	sxth	r3, r3
 801f744:	4313      	orrs	r3, r2
 801f746:	b21a      	sxth	r2, r3
        dev->calib.par_p4 =
 801f748:	687b      	ldr	r3, [r7, #4]
 801f74a:	855a      	strh	r2, [r3, #42]	; 0x2a
        dev->calib.par_p5 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P5_MSB], coeff_array[BME68X_IDX_P5_LSB]));
 801f74c:	7e7b      	ldrb	r3, [r7, #25]
 801f74e:	021b      	lsls	r3, r3, #8
 801f750:	b21a      	sxth	r2, r3
 801f752:	7e3b      	ldrb	r3, [r7, #24]
 801f754:	b21b      	sxth	r3, r3
 801f756:	4313      	orrs	r3, r2
 801f758:	b21a      	sxth	r2, r3
        dev->calib.par_p5 =
 801f75a:	687b      	ldr	r3, [r7, #4]
 801f75c:	859a      	strh	r2, [r3, #44]	; 0x2c
        dev->calib.par_p6 = (int8_t)(coeff_array[BME68X_IDX_P6]);
 801f75e:	7efb      	ldrb	r3, [r7, #27]
 801f760:	b25a      	sxtb	r2, r3
 801f762:	687b      	ldr	r3, [r7, #4]
 801f764:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
        dev->calib.par_p7 = (int8_t)(coeff_array[BME68X_IDX_P7]);
 801f768:	7ebb      	ldrb	r3, [r7, #26]
 801f76a:	b25a      	sxtb	r2, r3
 801f76c:	687b      	ldr	r3, [r7, #4]
 801f76e:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
        dev->calib.par_p8 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P8_MSB], coeff_array[BME68X_IDX_P8_LSB]));
 801f772:	7ffb      	ldrb	r3, [r7, #31]
 801f774:	021b      	lsls	r3, r3, #8
 801f776:	b21a      	sxth	r2, r3
 801f778:	7fbb      	ldrb	r3, [r7, #30]
 801f77a:	b21b      	sxth	r3, r3
 801f77c:	4313      	orrs	r3, r2
 801f77e:	b21a      	sxth	r2, r3
        dev->calib.par_p8 =
 801f780:	687b      	ldr	r3, [r7, #4]
 801f782:	861a      	strh	r2, [r3, #48]	; 0x30
        dev->calib.par_p9 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P9_MSB], coeff_array[BME68X_IDX_P9_LSB]));
 801f784:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801f788:	021b      	lsls	r3, r3, #8
 801f78a:	b21a      	sxth	r2, r3
 801f78c:	f897 3020 	ldrb.w	r3, [r7, #32]
 801f790:	b21b      	sxth	r3, r3
 801f792:	4313      	orrs	r3, r2
 801f794:	b21a      	sxth	r2, r3
        dev->calib.par_p9 =
 801f796:	687b      	ldr	r3, [r7, #4]
 801f798:	865a      	strh	r2, [r3, #50]	; 0x32
        dev->calib.par_p10 = (uint8_t)(coeff_array[BME68X_IDX_P10]);
 801f79a:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 801f79e:	687b      	ldr	r3, [r7, #4]
 801f7a0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Humidity related coefficients */
        dev->calib.par_h1 =
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
 801f7a4:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 801f7a8:	011b      	lsls	r3, r3, #4
 801f7aa:	b21a      	sxth	r2, r3
                       (coeff_array[BME68X_IDX_H1_LSB] & BME68X_BIT_H1_DATA_MSK));
 801f7ac:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 801f7b0:	b21b      	sxth	r3, r3
 801f7b2:	f003 030f 	and.w	r3, r3, #15
 801f7b6:	b21b      	sxth	r3, r3
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
 801f7b8:	4313      	orrs	r3, r2
 801f7ba:	b21b      	sxth	r3, r3
 801f7bc:	b29a      	uxth	r2, r3
        dev->calib.par_h1 =
 801f7be:	687b      	ldr	r3, [r7, #4]
 801f7c0:	821a      	strh	r2, [r3, #16]
        dev->calib.par_h2 =
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H2_MSB] << 4) | ((coeff_array[BME68X_IDX_H2_LSB]) >> 4));
 801f7c2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f7c6:	011b      	lsls	r3, r3, #4
 801f7c8:	b21a      	sxth	r2, r3
 801f7ca:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 801f7ce:	091b      	lsrs	r3, r3, #4
 801f7d0:	b2db      	uxtb	r3, r3
 801f7d2:	b21b      	sxth	r3, r3
 801f7d4:	4313      	orrs	r3, r2
 801f7d6:	b21b      	sxth	r3, r3
 801f7d8:	b29a      	uxth	r2, r3
        dev->calib.par_h2 =
 801f7da:	687b      	ldr	r3, [r7, #4]
 801f7dc:	825a      	strh	r2, [r3, #18]
        dev->calib.par_h3 = (int8_t)coeff_array[BME68X_IDX_H3];
 801f7de:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801f7e2:	b25a      	sxtb	r2, r3
 801f7e4:	687b      	ldr	r3, [r7, #4]
 801f7e6:	751a      	strb	r2, [r3, #20]
        dev->calib.par_h4 = (int8_t)coeff_array[BME68X_IDX_H4];
 801f7e8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801f7ec:	b25a      	sxtb	r2, r3
 801f7ee:	687b      	ldr	r3, [r7, #4]
 801f7f0:	755a      	strb	r2, [r3, #21]
        dev->calib.par_h5 = (int8_t)coeff_array[BME68X_IDX_H5];
 801f7f2:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801f7f6:	b25a      	sxtb	r2, r3
 801f7f8:	687b      	ldr	r3, [r7, #4]
 801f7fa:	759a      	strb	r2, [r3, #22]
        dev->calib.par_h6 = (uint8_t)coeff_array[BME68X_IDX_H6];
 801f7fc:	f897 2029 	ldrb.w	r2, [r7, #41]	; 0x29
 801f800:	687b      	ldr	r3, [r7, #4]
 801f802:	75da      	strb	r2, [r3, #23]
        dev->calib.par_h7 = (int8_t)coeff_array[BME68X_IDX_H7];
 801f804:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 801f808:	b25a      	sxtb	r2, r3
 801f80a:	687b      	ldr	r3, [r7, #4]
 801f80c:	761a      	strb	r2, [r3, #24]

        /* Gas heater related coefficients */
        dev->calib.par_gh1 = (int8_t)coeff_array[BME68X_IDX_GH1];
 801f80e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801f812:	b25a      	sxtb	r2, r3
 801f814:	687b      	ldr	r3, [r7, #4]
 801f816:	765a      	strb	r2, [r3, #25]
        dev->calib.par_gh2 =
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_GH2_MSB], coeff_array[BME68X_IDX_GH2_LSB]));
 801f818:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801f81c:	021b      	lsls	r3, r3, #8
 801f81e:	b21a      	sxth	r2, r3
 801f820:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 801f824:	b21b      	sxth	r3, r3
 801f826:	4313      	orrs	r3, r2
 801f828:	b21a      	sxth	r2, r3
        dev->calib.par_gh2 =
 801f82a:	687b      	ldr	r3, [r7, #4]
 801f82c:	835a      	strh	r2, [r3, #26]
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
 801f82e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801f832:	b25a      	sxtb	r2, r3
 801f834:	687b      	ldr	r3, [r7, #4]
 801f836:	771a      	strb	r2, [r3, #28]

        /* Other coefficients */
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
 801f838:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801f83c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801f840:	2b00      	cmp	r3, #0
 801f842:	da00      	bge.n	801f846 <get_calib_data+0x1d6>
 801f844:	330f      	adds	r3, #15
 801f846:	111b      	asrs	r3, r3, #4
 801f848:	b2da      	uxtb	r2, r3
 801f84a:	687b      	ldr	r3, [r7, #4]
 801f84c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        dev->calib.res_heat_val = (int8_t)coeff_array[BME68X_IDX_RES_HEAT_VAL];
 801f850:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 801f854:	b25a      	sxtb	r2, r3
 801f856:	687b      	ldr	r3, [r7, #4]
 801f858:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        dev->calib.range_sw_err = ((int8_t)(coeff_array[BME68X_IDX_RANGE_SW_ERR] & BME68X_RSERROR_MSK)) / 16;
 801f85c:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 801f860:	b25b      	sxtb	r3, r3
 801f862:	111b      	asrs	r3, r3, #4
 801f864:	b25a      	sxtb	r2, r3
 801f866:	687b      	ldr	r3, [r7, #4]
 801f868:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
    }

    return rslt;
 801f86c:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
}
 801f870:	4618      	mov	r0, r3
 801f872:	3738      	adds	r7, #56	; 0x38
 801f874:	46bd      	mov	sp, r7
 801f876:	bd80      	pop	{r7, pc}

0801f878 <read_variant_id>:

/* This internal API is used to read variant ID information from the register */
static int8_t read_variant_id(struct bme68x_dev *dev)
{
 801f878:	b580      	push	{r7, lr}
 801f87a:	b084      	sub	sp, #16
 801f87c:	af00      	add	r7, sp, #0
 801f87e:	6078      	str	r0, [r7, #4]
    int8_t rslt;
    uint8_t reg_data = 0;
 801f880:	2300      	movs	r3, #0
 801f882:	73bb      	strb	r3, [r7, #14]

    /* Read variant ID information register */
    rslt = bme68x_get_regs(BME68X_REG_VARIANT_ID, &reg_data, 1, dev);
 801f884:	f107 010e 	add.w	r1, r7, #14
 801f888:	687b      	ldr	r3, [r7, #4]
 801f88a:	2201      	movs	r2, #1
 801f88c:	20f0      	movs	r0, #240	; 0xf0
 801f88e:	f7fd ffd6 	bl	801d83e <bme68x_get_regs>
 801f892:	4603      	mov	r3, r0
 801f894:	73fb      	strb	r3, [r7, #15]

    if (rslt == BME68X_OK)
 801f896:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801f89a:	2b00      	cmp	r3, #0
 801f89c:	d103      	bne.n	801f8a6 <read_variant_id+0x2e>
    {
        dev->variant_id = reg_data;
 801f89e:	7bbb      	ldrb	r3, [r7, #14]
 801f8a0:	461a      	mov	r2, r3
 801f8a2:	687b      	ldr	r3, [r7, #4]
 801f8a4:	609a      	str	r2, [r3, #8]
    }

    return rslt;
 801f8a6:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
 801f8aa:	4618      	mov	r0, r3
 801f8ac:	3710      	adds	r7, #16
 801f8ae:	46bd      	mov	sp, r7
 801f8b0:	bd80      	pop	{r7, pc}

0801f8b2 <_ZN8CALIPILE5setupEhP19__I2C_HandleTypeDefh>:
#include "math.h"

#define delay			HAL_Delay
#define I2C_TIMEOUT		100

void CALIPILE::setup(uint8_t i2c_address, I2C_HandleTypeDef *i2c_handle, uint8_t identifier) {
 801f8b2:	b480      	push	{r7}
 801f8b4:	b085      	sub	sp, #20
 801f8b6:	af00      	add	r7, sp, #0
 801f8b8:	60f8      	str	r0, [r7, #12]
 801f8ba:	607a      	str	r2, [r7, #4]
 801f8bc:	461a      	mov	r2, r3
 801f8be:	460b      	mov	r3, r1
 801f8c0:	72fb      	strb	r3, [r7, #11]
 801f8c2:	4613      	mov	r3, r2
 801f8c4:	72bb      	strb	r3, [r7, #10]
	i2c_han = i2c_handle;
 801f8c6:	68fb      	ldr	r3, [r7, #12]
 801f8c8:	687a      	ldr	r2, [r7, #4]
 801f8ca:	605a      	str	r2, [r3, #4]
	i2c_addr = i2c_address << 1;
 801f8cc:	7afb      	ldrb	r3, [r7, #11]
 801f8ce:	005b      	lsls	r3, r3, #1
 801f8d0:	b2da      	uxtb	r2, r3
 801f8d2:	68fb      	ldr	r3, [r7, #12]
 801f8d4:	721a      	strb	r2, [r3, #8]
	descriptor = identifier;
 801f8d6:	68fb      	ldr	r3, [r7, #12]
 801f8d8:	7aba      	ldrb	r2, [r7, #10]
 801f8da:	701a      	strb	r2, [r3, #0]
}
 801f8dc:	bf00      	nop
 801f8de:	3714      	adds	r7, #20
 801f8e0:	46bd      	mov	sp, r7
 801f8e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f8e6:	4770      	bx	lr

0801f8e8 <_ZN8CALIPILE4wakeEv>:

void CALIPILE::wake() {
 801f8e8:	b580      	push	{r7, lr}
 801f8ea:	b088      	sub	sp, #32
 801f8ec:	af04      	add	r7, sp, #16
 801f8ee:	6078      	str	r0, [r7, #4]
//	writeByte(0x00, 0x04, 0x00);  // issue general call and reload command
	uint8_t data = 0;
 801f8f0:	2300      	movs	r3, #0
 801f8f2:	73fb      	strb	r3, [r7, #15]
	HAL_I2C_Mem_Write(i2c_han, 0, 0x04, 1, &data, 1, I2C_TIMEOUT);
 801f8f4:	687b      	ldr	r3, [r7, #4]
 801f8f6:	6858      	ldr	r0, [r3, #4]
 801f8f8:	2364      	movs	r3, #100	; 0x64
 801f8fa:	9302      	str	r3, [sp, #8]
 801f8fc:	2301      	movs	r3, #1
 801f8fe:	9301      	str	r3, [sp, #4]
 801f900:	f107 030f 	add.w	r3, r7, #15
 801f904:	9300      	str	r3, [sp, #0]
 801f906:	2301      	movs	r3, #1
 801f908:	2204      	movs	r2, #4
 801f90a:	2100      	movs	r1, #0
 801f90c:	f7ee fee2 	bl	800e6d4 <HAL_I2C_Mem_Write>
	delay(1);
 801f910:	2001      	movs	r0, #1
 801f912:	f7e9 fb53 	bl	8008fbc <HAL_Delay>
}
 801f916:	bf00      	nop
 801f918:	3710      	adds	r7, #16
 801f91a:	46bd      	mov	sp, r7
 801f91c:	bd80      	pop	{r7, pc}
	...

0801f920 <_ZN8CALIPILE10readEEPROMEv>:

void CALIPILE::readEEPROM()
{
 801f920:	b580      	push	{r7, lr}
 801f922:	ed2d 8b02 	vpush	{d8}
 801f926:	b088      	sub	sp, #32
 801f928:	af02      	add	r7, sp, #8
 801f92a:	6078      	str	r0, [r7, #4]

	uint8_t rawData[2] = {0, 0};
 801f92c:	2300      	movs	r3, #0
 801f92e:	81bb      	strh	r3, [r7, #12]
	/* Start of EEPROM operations, just have to do once *************************************************** */
	// Check EEPROM protocol number as a test of I2C communication
	writeByte(i2c_addr, CALIPILE_EEPROM_CONTROL, 0x80);// enable EEPROM read
 801f930:	687b      	ldr	r3, [r7, #4]
 801f932:	7a19      	ldrb	r1, [r3, #8]
 801f934:	2380      	movs	r3, #128	; 0x80
 801f936:	221f      	movs	r2, #31
 801f938:	6878      	ldr	r0, [r7, #4]
 801f93a:	f000 f9e7 	bl	801fd0c <_ZN8CALIPILE9writeByteEhhh>

	uint8_t c = readByte(i2c_addr, CALIPILE_EEPROM_PROTOCOL);
 801f93e:	687b      	ldr	r3, [r7, #4]
 801f940:	7a1b      	ldrb	r3, [r3, #8]
 801f942:	2220      	movs	r2, #32
 801f944:	4619      	mov	r1, r3
 801f946:	6878      	ldr	r0, [r7, #4]
 801f948:	f000 f9f7 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801f94c:	4603      	mov	r3, r0
 801f94e:	73fb      	strb	r3, [r7, #15]
	//Serial.print("CaliPile EEPROM protocol number is "); //Serial.println(c);
	//Serial.println("CaliPile EEPROM protocol number should be 3");

	uint8_t d = readByte(i2c_addr, CALIPILE_SLAVE_ADDRESS);
 801f950:	687b      	ldr	r3, [r7, #4]
 801f952:	7a1b      	ldrb	r3, [r3, #8]
 801f954:	223f      	movs	r2, #63	; 0x3f
 801f956:	4619      	mov	r1, r3
 801f958:	6878      	ldr	r0, [r7, #4]
 801f95a:	f000 f9ee 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801f95e:	4603      	mov	r3, r0
 801f960:	73bb      	strb	r3, [r7, #14]
	//Serial.println("CaliPile EEPROM slave address should be 140");
	//Serial.println(" ");

	// Read the EEPROM calibration constants

	_LOOKUP = readByte(i2c_addr, CALIPILE_EEPROM_LOOKUPNUM);
 801f962:	687b      	ldr	r3, [r7, #4]
 801f964:	7a1b      	ldrb	r3, [r3, #8]
 801f966:	2229      	movs	r2, #41	; 0x29
 801f968:	4619      	mov	r1, r3
 801f96a:	6878      	ldr	r0, [r7, #4]
 801f96c:	f000 f9e5 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801f970:	4603      	mov	r3, r0
 801f972:	461a      	mov	r2, r3
 801f974:	687b      	ldr	r3, [r7, #4]
 801f976:	765a      	strb	r2, [r3, #25]
	//Serial.print("CaliPile LookUpNumber is "); //Serial.println(_LOOKUP);

	readBytes(i2c_addr, CALIPILE_EEPROM_PTAT25, 2, &rawData[0]);
 801f978:	687b      	ldr	r3, [r7, #4]
 801f97a:	7a19      	ldrb	r1, [r3, #8]
 801f97c:	f107 030c 	add.w	r3, r7, #12
 801f980:	9300      	str	r3, [sp, #0]
 801f982:	2302      	movs	r3, #2
 801f984:	222a      	movs	r2, #42	; 0x2a
 801f986:	6878      	ldr	r0, [r7, #4]
 801f988:	f000 f9ec 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	_PTAT25 = ( (uint16_t) rawData[0] << 8) | rawData[1];
 801f98c:	7b3b      	ldrb	r3, [r7, #12]
 801f98e:	021b      	lsls	r3, r3, #8
 801f990:	b21a      	sxth	r2, r3
 801f992:	7b7b      	ldrb	r3, [r7, #13]
 801f994:	b21b      	sxth	r3, r3
 801f996:	4313      	orrs	r3, r2
 801f998:	b21b      	sxth	r3, r3
 801f99a:	b29a      	uxth	r2, r3
 801f99c:	687b      	ldr	r3, [r7, #4]
 801f99e:	815a      	strh	r2, [r3, #10]
	//Serial.print("CaliPile PTAT25 is "); //Serial.println(_PTAT25);

	readBytes(i2c_addr, CALIPILE_EEPROM_M, 2, &rawData[0]);
 801f9a0:	687b      	ldr	r3, [r7, #4]
 801f9a2:	7a19      	ldrb	r1, [r3, #8]
 801f9a4:	f107 030c 	add.w	r3, r7, #12
 801f9a8:	9300      	str	r3, [sp, #0]
 801f9aa:	2302      	movs	r3, #2
 801f9ac:	222c      	movs	r2, #44	; 0x2c
 801f9ae:	6878      	ldr	r0, [r7, #4]
 801f9b0:	f000 f9d8 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	_M = ( (uint16_t) rawData[0] << 8) | rawData[1];
 801f9b4:	7b3b      	ldrb	r3, [r7, #12]
 801f9b6:	021b      	lsls	r3, r3, #8
 801f9b8:	b21a      	sxth	r2, r3
 801f9ba:	7b7b      	ldrb	r3, [r7, #13]
 801f9bc:	b21b      	sxth	r3, r3
 801f9be:	4313      	orrs	r3, r2
 801f9c0:	b21b      	sxth	r3, r3
 801f9c2:	b29a      	uxth	r2, r3
 801f9c4:	687b      	ldr	r3, [r7, #4]
 801f9c6:	819a      	strh	r2, [r3, #12]
	_M /= 100;
 801f9c8:	687b      	ldr	r3, [r7, #4]
 801f9ca:	899b      	ldrh	r3, [r3, #12]
 801f9cc:	4a4f      	ldr	r2, [pc, #316]	; (801fb0c <_ZN8CALIPILE10readEEPROMEv+0x1ec>)
 801f9ce:	fba2 2303 	umull	r2, r3, r2, r3
 801f9d2:	095b      	lsrs	r3, r3, #5
 801f9d4:	b29a      	uxth	r2, r3
 801f9d6:	687b      	ldr	r3, [r7, #4]
 801f9d8:	819a      	strh	r2, [r3, #12]
	//Serial.print("CaliPile M is "); //Serial.println(_M);

	readBytes(i2c_addr, CALIPILE_EEPROM_U0, 2, &rawData[0]);
 801f9da:	687b      	ldr	r3, [r7, #4]
 801f9dc:	7a19      	ldrb	r1, [r3, #8]
 801f9de:	f107 030c 	add.w	r3, r7, #12
 801f9e2:	9300      	str	r3, [sp, #0]
 801f9e4:	2302      	movs	r3, #2
 801f9e6:	222e      	movs	r2, #46	; 0x2e
 801f9e8:	6878      	ldr	r0, [r7, #4]
 801f9ea:	f000 f9bb 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	_U0 = ( (uint16_t) rawData[0] << 8) | rawData[1];
 801f9ee:	7b3b      	ldrb	r3, [r7, #12]
 801f9f0:	021b      	lsls	r3, r3, #8
 801f9f2:	b21a      	sxth	r2, r3
 801f9f4:	7b7b      	ldrb	r3, [r7, #13]
 801f9f6:	b21b      	sxth	r3, r3
 801f9f8:	4313      	orrs	r3, r2
 801f9fa:	b21b      	sxth	r3, r3
 801f9fc:	b29a      	uxth	r2, r3
 801f9fe:	687b      	ldr	r3, [r7, #4]
 801fa00:	81da      	strh	r2, [r3, #14]
	_U0 += 32768;
 801fa02:	687b      	ldr	r3, [r7, #4]
 801fa04:	89db      	ldrh	r3, [r3, #14]
 801fa06:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 801fa0a:	b29a      	uxth	r2, r3
 801fa0c:	687b      	ldr	r3, [r7, #4]
 801fa0e:	81da      	strh	r2, [r3, #14]
	//Serial.print("CaliPile U0 is "); //Serial.println(_U0);

	readBytes(i2c_addr, CALIPILE_EEPROM_UOUT1, 2, &rawData[0]);
 801fa10:	687b      	ldr	r3, [r7, #4]
 801fa12:	7a19      	ldrb	r1, [r3, #8]
 801fa14:	f107 030c 	add.w	r3, r7, #12
 801fa18:	9300      	str	r3, [sp, #0]
 801fa1a:	2302      	movs	r3, #2
 801fa1c:	2230      	movs	r2, #48	; 0x30
 801fa1e:	6878      	ldr	r0, [r7, #4]
 801fa20:	f000 f9a0 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	_UOUT1 = ( (uint16_t) rawData[0] << 8) | rawData[1];
 801fa24:	7b3b      	ldrb	r3, [r7, #12]
 801fa26:	021b      	lsls	r3, r3, #8
 801fa28:	7b7a      	ldrb	r2, [r7, #13]
 801fa2a:	4313      	orrs	r3, r2
 801fa2c:	461a      	mov	r2, r3
 801fa2e:	687b      	ldr	r3, [r7, #4]
 801fa30:	615a      	str	r2, [r3, #20]
	_UOUT1 *= 2;
 801fa32:	687b      	ldr	r3, [r7, #4]
 801fa34:	695b      	ldr	r3, [r3, #20]
 801fa36:	005a      	lsls	r2, r3, #1
 801fa38:	687b      	ldr	r3, [r7, #4]
 801fa3a:	615a      	str	r2, [r3, #20]
	//Serial.print("CaliPile UOUT1 is "); //Serial.println(_UOUT1);

	_TOBJ1 = readByte(i2c_addr, CALIPILE_EEPROM_TOBJ1);
 801fa3c:	687b      	ldr	r3, [r7, #4]
 801fa3e:	7a1b      	ldrb	r3, [r3, #8]
 801fa40:	2232      	movs	r2, #50	; 0x32
 801fa42:	4619      	mov	r1, r3
 801fa44:	6878      	ldr	r0, [r7, #4]
 801fa46:	f000 f978 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801fa4a:	4603      	mov	r3, r0
 801fa4c:	461a      	mov	r2, r3
 801fa4e:	687b      	ldr	r3, [r7, #4]
 801fa50:	761a      	strb	r2, [r3, #24]
	//Serial.print("CaliPile TOBJ1 is "); //Serial.println(_TOBJ1);

	readBytes(i2c_addr, CALIPILE_EEPROM_CHECKSUM, 2, &rawData[0]);
 801fa52:	687b      	ldr	r3, [r7, #4]
 801fa54:	7a19      	ldrb	r1, [r3, #8]
 801fa56:	f107 030c 	add.w	r3, r7, #12
 801fa5a:	9300      	str	r3, [sp, #0]
 801fa5c:	2302      	movs	r3, #2
 801fa5e:	2221      	movs	r2, #33	; 0x21
 801fa60:	6878      	ldr	r0, [r7, #4]
 801fa62:	f000 f97f 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	_CHECKSUM = ( (uint16_t) rawData[0] << 8) | rawData[1];
 801fa66:	7b3b      	ldrb	r3, [r7, #12]
 801fa68:	021b      	lsls	r3, r3, #8
 801fa6a:	b21a      	sxth	r2, r3
 801fa6c:	7b7b      	ldrb	r3, [r7, #13]
 801fa6e:	b21b      	sxth	r3, r3
 801fa70:	4313      	orrs	r3, r2
 801fa72:	b21b      	sxth	r3, r3
 801fa74:	b29a      	uxth	r2, r3
 801fa76:	687b      	ldr	r3, [r7, #4]
 801fa78:	821a      	strh	r2, [r3, #16]
	//Serial.print("CaliPile CHECKSUM is supposed to be "); //Serial.println(_CHECKSUM);

	// Calculate the checksum
	uint16_t sum = 0;
 801fa7a:	2300      	movs	r3, #0
 801fa7c:	82fb      	strh	r3, [r7, #22]
	for(int ii = 35; ii < 64; ii++)
 801fa7e:	2323      	movs	r3, #35	; 0x23
 801fa80:	613b      	str	r3, [r7, #16]
 801fa82:	693b      	ldr	r3, [r7, #16]
 801fa84:	2b3f      	cmp	r3, #63	; 0x3f
 801fa86:	dc10      	bgt.n	801faaa <_ZN8CALIPILE10readEEPROMEv+0x18a>
	{
		sum += readByte(i2c_addr, ii);
 801fa88:	687b      	ldr	r3, [r7, #4]
 801fa8a:	7a1b      	ldrb	r3, [r3, #8]
 801fa8c:	693a      	ldr	r2, [r7, #16]
 801fa8e:	b2d2      	uxtb	r2, r2
 801fa90:	4619      	mov	r1, r3
 801fa92:	6878      	ldr	r0, [r7, #4]
 801fa94:	f000 f951 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801fa98:	4603      	mov	r3, r0
 801fa9a:	b29a      	uxth	r2, r3
 801fa9c:	8afb      	ldrh	r3, [r7, #22]
 801fa9e:	4413      	add	r3, r2
 801faa0:	82fb      	strh	r3, [r7, #22]
	for(int ii = 35; ii < 64; ii++)
 801faa2:	693b      	ldr	r3, [r7, #16]
 801faa4:	3301      	adds	r3, #1
 801faa6:	613b      	str	r3, [r7, #16]
 801faa8:	e7eb      	b.n	801fa82 <_ZN8CALIPILE10readEEPROMEv+0x162>
	}
	//Serial.print("CaliPile CHECKSUM is "); //Serial.println(sum + c);

	writeByte(i2c_addr, CALIPILE_EEPROM_CONTROL, 0x00); // disable EEPROM read
 801faaa:	687b      	ldr	r3, [r7, #4]
 801faac:	7a19      	ldrb	r1, [r3, #8]
 801faae:	2300      	movs	r3, #0
 801fab0:	221f      	movs	r2, #31
 801fab2:	6878      	ldr	r0, [r7, #4]
 801fab4:	f000 f92a 	bl	801fd0c <_ZN8CALIPILE9writeByteEhhh>
	/* End of EEPROM operations, just have to do once *************************************************** */

	// Construct needed calibration constants (just need to calculate once)
	_k = ( (float) (_UOUT1 - _U0) )/(powf((float)(_TOBJ1 + 273.15f), 3.8f) - powf(25.0f + 273.15f, 3.8f) );
 801fab8:	687b      	ldr	r3, [r7, #4]
 801faba:	695b      	ldr	r3, [r3, #20]
 801fabc:	687a      	ldr	r2, [r7, #4]
 801fabe:	89d2      	ldrh	r2, [r2, #14]
 801fac0:	1a9b      	subs	r3, r3, r2
 801fac2:	ee07 3a90 	vmov	s15, r3
 801fac6:	eeb8 8a67 	vcvt.f32.u32	s16, s15
 801faca:	687b      	ldr	r3, [r7, #4]
 801facc:	7e1b      	ldrb	r3, [r3, #24]
 801face:	ee07 3a90 	vmov	s15, r3
 801fad2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801fad6:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 801fb10 <_ZN8CALIPILE10readEEPROMEv+0x1f0>
 801fada:	ee77 7a87 	vadd.f32	s15, s15, s14
 801fade:	eddf 0a0d 	vldr	s1, [pc, #52]	; 801fb14 <_ZN8CALIPILE10readEEPROMEv+0x1f4>
 801fae2:	eeb0 0a67 	vmov.f32	s0, s15
 801fae6:	f009 ffb9 	bl	8029a5c <powf>
 801faea:	eef0 7a40 	vmov.f32	s15, s0
 801faee:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 801fb18 <_ZN8CALIPILE10readEEPROMEv+0x1f8>
 801faf2:	ee37 7ac7 	vsub.f32	s14, s15, s14
 801faf6:	eec8 7a07 	vdiv.f32	s15, s16, s14
 801fafa:	687b      	ldr	r3, [r7, #4]
 801fafc:	edc3 7a07 	vstr	s15, [r3, #28]

}
 801fb00:	bf00      	nop
 801fb02:	3718      	adds	r7, #24
 801fb04:	46bd      	mov	sp, r7
 801fb06:	ecbd 8b02 	vpop	{d8}
 801fb0a:	bd80      	pop	{r7, pc}
 801fb0c:	51eb851f 	.word	0x51eb851f
 801fb10:	43889333 	.word	0x43889333
 801fb14:	40733333 	.word	0x40733333
 801fb18:	4f16b4e3 	.word	0x4f16b4e3

0801fb1c <_ZN8CALIPILE11initTempThrEt>:
	// select motion threshold
	writeByte(i2c_addr, CALIPILE_TP_PRES_THLD, 0x22);// presence threshold, set at 50 counts
	writeByte(i2c_addr, CALIPILE_TP_MOT_THLD, 0x0A);// motion threshold, set at 10 counts
}

void CALIPILE::initTempThr(uint16_t Tcounts) {
 801fb1c:	b580      	push	{r7, lr}
 801fb1e:	b086      	sub	sp, #24
 801fb20:	af02      	add	r7, sp, #8
 801fb22:	6078      	str	r0, [r7, #4]
 801fb24:	460b      	mov	r3, r1
 801fb26:	807b      	strh	r3, [r7, #2]
	uint8_t rawData[2] = {0, 0};
 801fb28:	2300      	movs	r3, #0
 801fb2a:	813b      	strh	r3, [r7, #8]
	// specify the over temperature interrupt threshold (2 bytes)
	writeByte(i2c_addr, CALIPILE_TPOT_THR, Tcounts);// 0x83 means 67,072 counts as threshold
 801fb2c:	687b      	ldr	r3, [r7, #4]
 801fb2e:	7a19      	ldrb	r1, [r3, #8]
 801fb30:	887b      	ldrh	r3, [r7, #2]
 801fb32:	b2db      	uxtb	r3, r3
 801fb34:	221c      	movs	r2, #28
 801fb36:	6878      	ldr	r0, [r7, #4]
 801fb38:	f000 f8e8 	bl	801fd0c <_ZN8CALIPILE9writeByteEhhh>
	writeByte(i2c_addr, (CALIPILE_TPOT_THR + 1), 0x00);
 801fb3c:	687b      	ldr	r3, [r7, #4]
 801fb3e:	7a19      	ldrb	r1, [r3, #8]
 801fb40:	2300      	movs	r3, #0
 801fb42:	221d      	movs	r2, #29
 801fb44:	6878      	ldr	r0, [r7, #4]
 801fb46:	f000 f8e1 	bl	801fd0c <_ZN8CALIPILE9writeByteEhhh>
	uint8_t temp = readByte(i2c_addr, CALIPILE_SRC_SELECT);
 801fb4a:	687b      	ldr	r3, [r7, #4]
 801fb4c:	7a1b      	ldrb	r3, [r3, #8]
 801fb4e:	221a      	movs	r2, #26
 801fb50:	4619      	mov	r1, r3
 801fb52:	6878      	ldr	r0, [r7, #4]
 801fb54:	f000 f8f1 	bl	801fd3a <_ZN8CALIPILE8readByteEhh>
 801fb58:	4603      	mov	r3, r0
 801fb5a:	73fb      	strb	r3, [r7, #15]
	writeByte(i2c_addr, CALIPILE_SRC_SELECT, temp | 0x10);// interrupt on exceeding threshold
 801fb5c:	687b      	ldr	r3, [r7, #4]
 801fb5e:	7a19      	ldrb	r1, [r3, #8]
 801fb60:	7bfb      	ldrb	r3, [r7, #15]
 801fb62:	f043 0310 	orr.w	r3, r3, #16
 801fb66:	b2db      	uxtb	r3, r3
 801fb68:	221a      	movs	r2, #26
 801fb6a:	6878      	ldr	r0, [r7, #4]
 801fb6c:	f000 f8ce 	bl	801fd0c <_ZN8CALIPILE9writeByteEhhh>
	// Verify threshold set
	readBytes(i2c_addr, CALIPILE_TPOT_THR, 2, &rawData[0]);
 801fb70:	687b      	ldr	r3, [r7, #4]
 801fb72:	7a19      	ldrb	r1, [r3, #8]
 801fb74:	f107 0308 	add.w	r3, r7, #8
 801fb78:	9300      	str	r3, [sp, #0]
 801fb7a:	2302      	movs	r3, #2
 801fb7c:	221c      	movs	r2, #28
 801fb7e:	6878      	ldr	r0, [r7, #4]
 801fb80:	f000 f8f0 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	uint16_t TPOTTHR = ((uint16_t) rawData[0] << 8) | rawData[1];
 801fb84:	7a3b      	ldrb	r3, [r7, #8]
 801fb86:	021b      	lsls	r3, r3, #8
 801fb88:	b21a      	sxth	r2, r3
 801fb8a:	7a7b      	ldrb	r3, [r7, #9]
 801fb8c:	b21b      	sxth	r3, r3
 801fb8e:	4313      	orrs	r3, r2
 801fb90:	b21b      	sxth	r3, r3
 801fb92:	81bb      	strh	r3, [r7, #12]
	//Serial.print("Overtemp threshold = "); //Serial.println(TPOTTHR * 2);
}
 801fb94:	bf00      	nop
 801fb96:	3710      	adds	r7, #16
 801fb98:	46bd      	mov	sp, r7
 801fb9a:	bd80      	pop	{r7, pc}

0801fb9c <_ZN8CALIPILE8getTPAMBEv>:

uint16_t CALIPILE::getTPAMB() {
 801fb9c:	b580      	push	{r7, lr}
 801fb9e:	b086      	sub	sp, #24
 801fba0:	af02      	add	r7, sp, #8
 801fba2:	6078      	str	r0, [r7, #4]
	uint8_t rawData[2] = {0, 0};
 801fba4:	2300      	movs	r3, #0
 801fba6:	81bb      	strh	r3, [r7, #12]
	readBytes(i2c_addr, CALIPILE_TPAMBIENT, 2, &rawData[0]);
 801fba8:	687b      	ldr	r3, [r7, #4]
 801fbaa:	7a19      	ldrb	r1, [r3, #8]
 801fbac:	f107 030c 	add.w	r3, r7, #12
 801fbb0:	9300      	str	r3, [sp, #0]
 801fbb2:	2302      	movs	r3, #2
 801fbb4:	2203      	movs	r2, #3
 801fbb6:	6878      	ldr	r0, [r7, #4]
 801fbb8:	f000 f8d4 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	uint16_t temp = ( (uint16_t)(rawData[0] & 0x7F) << 8) | rawData[1];
 801fbbc:	7b3b      	ldrb	r3, [r7, #12]
 801fbbe:	021b      	lsls	r3, r3, #8
 801fbc0:	b21b      	sxth	r3, r3
 801fbc2:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 801fbc6:	b21a      	sxth	r2, r3
 801fbc8:	7b7b      	ldrb	r3, [r7, #13]
 801fbca:	b21b      	sxth	r3, r3
 801fbcc:	4313      	orrs	r3, r2
 801fbce:	b21b      	sxth	r3, r3
 801fbd0:	81fb      	strh	r3, [r7, #14]
	return temp;
 801fbd2:	89fb      	ldrh	r3, [r7, #14]
}
 801fbd4:	4618      	mov	r0, r3
 801fbd6:	3710      	adds	r7, #16
 801fbd8:	46bd      	mov	sp, r7
 801fbda:	bd80      	pop	{r7, pc}

0801fbdc <_ZN8CALIPILE8getTPOBJEv>:

uint32_t CALIPILE::getTPOBJ() {
 801fbdc:	b580      	push	{r7, lr}
 801fbde:	b086      	sub	sp, #24
 801fbe0:	af02      	add	r7, sp, #8
 801fbe2:	6078      	str	r0, [r7, #4]
	uint8_t rawData[3] = {0, 0, 0};
 801fbe4:	4b10      	ldr	r3, [pc, #64]	; (801fc28 <_ZN8CALIPILE8getTPOBJEv+0x4c>)
 801fbe6:	781b      	ldrb	r3, [r3, #0]
 801fbe8:	723b      	strb	r3, [r7, #8]
 801fbea:	f107 0309 	add.w	r3, r7, #9
 801fbee:	2200      	movs	r2, #0
 801fbf0:	801a      	strh	r2, [r3, #0]
	readBytes(i2c_addr, CALIPILE_TPOBJECT, 3, &rawData[0]);
 801fbf2:	687b      	ldr	r3, [r7, #4]
 801fbf4:	7a19      	ldrb	r1, [r3, #8]
 801fbf6:	f107 0308 	add.w	r3, r7, #8
 801fbfa:	9300      	str	r3, [sp, #0]
 801fbfc:	2303      	movs	r3, #3
 801fbfe:	2201      	movs	r2, #1
 801fc00:	6878      	ldr	r0, [r7, #4]
 801fc02:	f000 f8af 	bl	801fd64 <_ZN8CALIPILE9readBytesEhhhPh>
	uint32_t temp = ( (uint32_t) ( (uint32_t)rawData[0] << 24) | ( (uint32_t)rawData[1] << 16) | ( (uint32_t)rawData[2] & 0x80) << 8) >> 15;
 801fc06:	7a3b      	ldrb	r3, [r7, #8]
 801fc08:	061a      	lsls	r2, r3, #24
 801fc0a:	7a7b      	ldrb	r3, [r7, #9]
 801fc0c:	041b      	lsls	r3, r3, #16
 801fc0e:	431a      	orrs	r2, r3
 801fc10:	7abb      	ldrb	r3, [r7, #10]
 801fc12:	021b      	lsls	r3, r3, #8
 801fc14:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801fc18:	4313      	orrs	r3, r2
 801fc1a:	0bdb      	lsrs	r3, r3, #15
 801fc1c:	60fb      	str	r3, [r7, #12]
	return temp;
 801fc1e:	68fb      	ldr	r3, [r7, #12]
}
 801fc20:	4618      	mov	r0, r3
 801fc22:	3710      	adds	r7, #16
 801fc24:	46bd      	mov	sp, r7
 801fc26:	bd80      	pop	{r7, pc}
 801fc28:	0802c614 	.word	0x0802c614

0801fc2c <_ZN8CALIPILE7getTambEt>:
uint8_t CALIPILE::getTPAMBSHK() {
	uint8_t temp = readByte(i2c_addr, CALIPILE_TPAMB_SHOCK);
	return temp;
}

float CALIPILE::getTamb(uint16_t TPAMB) {
 801fc2c:	b480      	push	{r7}
 801fc2e:	b085      	sub	sp, #20
 801fc30:	af00      	add	r7, sp, #0
 801fc32:	6078      	str	r0, [r7, #4]
 801fc34:	460b      	mov	r3, r1
 801fc36:	807b      	strh	r3, [r7, #2]
	float temp = 298.15f + ((float)TPAMB - (float) _PTAT25) * (1.0f/(float) _M);
 801fc38:	887b      	ldrh	r3, [r7, #2]
 801fc3a:	ee07 3a90 	vmov	s15, r3
 801fc3e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801fc42:	687b      	ldr	r3, [r7, #4]
 801fc44:	895b      	ldrh	r3, [r3, #10]
 801fc46:	ee07 3a90 	vmov	s15, r3
 801fc4a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801fc4e:	ee37 7a67 	vsub.f32	s14, s14, s15
 801fc52:	687b      	ldr	r3, [r7, #4]
 801fc54:	899b      	ldrh	r3, [r3, #12]
 801fc56:	ee07 3a90 	vmov	s15, r3
 801fc5a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 801fc5e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801fc62:	eec6 7a26 	vdiv.f32	s15, s12, s13
 801fc66:	ee67 7a27 	vmul.f32	s15, s14, s15
 801fc6a:	ed9f 7a08 	vldr	s14, [pc, #32]	; 801fc8c <_ZN8CALIPILE7getTambEt+0x60>
 801fc6e:	ee77 7a87 	vadd.f32	s15, s15, s14
 801fc72:	edc7 7a03 	vstr	s15, [r7, #12]
	return temp;
 801fc76:	68fb      	ldr	r3, [r7, #12]
 801fc78:	ee07 3a90 	vmov	s15, r3
}
 801fc7c:	eeb0 0a67 	vmov.f32	s0, s15
 801fc80:	3714      	adds	r7, #20
 801fc82:	46bd      	mov	sp, r7
 801fc84:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fc88:	4770      	bx	lr
 801fc8a:	bf00      	nop
 801fc8c:	43951333 	.word	0x43951333

0801fc90 <_ZN8CALIPILE7getTobjEmf>:

float CALIPILE::getTobj(uint32_t TPOBJ, float Tamb) {
 801fc90:	b580      	push	{r7, lr}
 801fc92:	b088      	sub	sp, #32
 801fc94:	af00      	add	r7, sp, #0
 801fc96:	60f8      	str	r0, [r7, #12]
 801fc98:	60b9      	str	r1, [r7, #8]
 801fc9a:	ed87 0a01 	vstr	s0, [r7, #4]
	float temp0 = powf(Tamb, 3.8f);
 801fc9e:	eddf 0a19 	vldr	s1, [pc, #100]	; 801fd04 <_ZN8CALIPILE7getTobjEmf+0x74>
 801fca2:	ed97 0a01 	vldr	s0, [r7, #4]
 801fca6:	f009 fed9 	bl	8029a5c <powf>
 801fcaa:	ed87 0a07 	vstr	s0, [r7, #28]
	float temp1 = ( ((float) TPOBJ) - ((float) _U0) ) / _k;
 801fcae:	68bb      	ldr	r3, [r7, #8]
 801fcb0:	ee07 3a90 	vmov	s15, r3
 801fcb4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 801fcb8:	68fb      	ldr	r3, [r7, #12]
 801fcba:	89db      	ldrh	r3, [r3, #14]
 801fcbc:	ee07 3a90 	vmov	s15, r3
 801fcc0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801fcc4:	ee77 6a67 	vsub.f32	s13, s14, s15
 801fcc8:	68fb      	ldr	r3, [r7, #12]
 801fcca:	ed93 7a07 	vldr	s14, [r3, #28]
 801fcce:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801fcd2:	edc7 7a06 	vstr	s15, [r7, #24]
	float temp3 = powf( (temp0 + temp1), 0.2631578947f );
 801fcd6:	ed97 7a07 	vldr	s14, [r7, #28]
 801fcda:	edd7 7a06 	vldr	s15, [r7, #24]
 801fcde:	ee77 7a27 	vadd.f32	s15, s14, s15
 801fce2:	eddf 0a09 	vldr	s1, [pc, #36]	; 801fd08 <_ZN8CALIPILE7getTobjEmf+0x78>
 801fce6:	eeb0 0a67 	vmov.f32	s0, s15
 801fcea:	f009 feb7 	bl	8029a5c <powf>
 801fcee:	ed87 0a05 	vstr	s0, [r7, #20]
	return temp3;
 801fcf2:	697b      	ldr	r3, [r7, #20]
 801fcf4:	ee07 3a90 	vmov	s15, r3
}
 801fcf8:	eeb0 0a67 	vmov.f32	s0, s15
 801fcfc:	3720      	adds	r7, #32
 801fcfe:	46bd      	mov	sp, r7
 801fd00:	bd80      	pop	{r7, pc}
 801fd02:	bf00      	nop
 801fd04:	40733333 	.word	0x40733333
 801fd08:	3e86bca2 	.word	0x3e86bca2

0801fd0c <_ZN8CALIPILE9writeByteEhhh>:
//	//Serial.println("done\n");
//
//}

// I2C read/write functions for the BMP280 sensors
void CALIPILE::writeByte(uint8_t address, uint8_t subAddress, uint8_t data) {
 801fd0c:	b580      	push	{r7, lr}
 801fd0e:	b082      	sub	sp, #8
 801fd10:	af00      	add	r7, sp, #0
 801fd12:	6078      	str	r0, [r7, #4]
 801fd14:	4608      	mov	r0, r1
 801fd16:	4611      	mov	r1, r2
 801fd18:	461a      	mov	r2, r3
 801fd1a:	4603      	mov	r3, r0
 801fd1c:	70fb      	strb	r3, [r7, #3]
 801fd1e:	460b      	mov	r3, r1
 801fd20:	70bb      	strb	r3, [r7, #2]
 801fd22:	4613      	mov	r3, r2
 801fd24:	707b      	strb	r3, [r7, #1]
	writeRegister(subAddress, &data, 1);
 801fd26:	1c7a      	adds	r2, r7, #1
 801fd28:	78b9      	ldrb	r1, [r7, #2]
 801fd2a:	2301      	movs	r3, #1
 801fd2c:	6878      	ldr	r0, [r7, #4]
 801fd2e:	f000 f85a 	bl	801fde6 <_ZN8CALIPILE13writeRegisterEhPht>
}
 801fd32:	bf00      	nop
 801fd34:	3708      	adds	r7, #8
 801fd36:	46bd      	mov	sp, r7
 801fd38:	bd80      	pop	{r7, pc}

0801fd3a <_ZN8CALIPILE8readByteEhh>:

uint8_t CALIPILE::readByte(uint8_t address, uint8_t subAddress) {
 801fd3a:	b580      	push	{r7, lr}
 801fd3c:	b084      	sub	sp, #16
 801fd3e:	af00      	add	r7, sp, #0
 801fd40:	6078      	str	r0, [r7, #4]
 801fd42:	460b      	mov	r3, r1
 801fd44:	70fb      	strb	r3, [r7, #3]
 801fd46:	4613      	mov	r3, r2
 801fd48:	70bb      	strb	r3, [r7, #2]
	uint8_t temp[1];
	readRegister(subAddress, &temp[0], 1);
 801fd4a:	78bb      	ldrb	r3, [r7, #2]
 801fd4c:	b299      	uxth	r1, r3
 801fd4e:	f107 020c 	add.w	r2, r7, #12
 801fd52:	2301      	movs	r3, #1
 801fd54:	6878      	ldr	r0, [r7, #4]
 801fd56:	f000 f81e 	bl	801fd96 <_ZN8CALIPILE12readRegisterEtPht>
	return temp[0];
 801fd5a:	7b3b      	ldrb	r3, [r7, #12]
}
 801fd5c:	4618      	mov	r0, r3
 801fd5e:	3710      	adds	r7, #16
 801fd60:	46bd      	mov	sp, r7
 801fd62:	bd80      	pop	{r7, pc}

0801fd64 <_ZN8CALIPILE9readBytesEhhhPh>:

void CALIPILE::readBytes(uint8_t address, uint8_t subAddress, uint8_t count, uint8_t * dest) {
 801fd64:	b580      	push	{r7, lr}
 801fd66:	b082      	sub	sp, #8
 801fd68:	af00      	add	r7, sp, #0
 801fd6a:	6078      	str	r0, [r7, #4]
 801fd6c:	4608      	mov	r0, r1
 801fd6e:	4611      	mov	r1, r2
 801fd70:	461a      	mov	r2, r3
 801fd72:	4603      	mov	r3, r0
 801fd74:	70fb      	strb	r3, [r7, #3]
 801fd76:	460b      	mov	r3, r1
 801fd78:	70bb      	strb	r3, [r7, #2]
 801fd7a:	4613      	mov	r3, r2
 801fd7c:	707b      	strb	r3, [r7, #1]
	readRegister(subAddress, dest, count);
 801fd7e:	78bb      	ldrb	r3, [r7, #2]
 801fd80:	b299      	uxth	r1, r3
 801fd82:	787b      	ldrb	r3, [r7, #1]
 801fd84:	b29b      	uxth	r3, r3
 801fd86:	693a      	ldr	r2, [r7, #16]
 801fd88:	6878      	ldr	r0, [r7, #4]
 801fd8a:	f000 f804 	bl	801fd96 <_ZN8CALIPILE12readRegisterEtPht>
}
 801fd8e:	bf00      	nop
 801fd90:	3708      	adds	r7, #8
 801fd92:	46bd      	mov	sp, r7
 801fd94:	bd80      	pop	{r7, pc}

0801fd96 <_ZN8CALIPILE12readRegisterEtPht>:
	} else {
		return false;
	}
}

bool CALIPILE::readRegister(uint16_t mem_addr, uint8_t *dest, uint16_t size) {
 801fd96:	b580      	push	{r7, lr}
 801fd98:	b088      	sub	sp, #32
 801fd9a:	af04      	add	r7, sp, #16
 801fd9c:	60f8      	str	r0, [r7, #12]
 801fd9e:	607a      	str	r2, [r7, #4]
 801fda0:	461a      	mov	r2, r3
 801fda2:	460b      	mov	r3, r1
 801fda4:	817b      	strh	r3, [r7, #10]
 801fda6:	4613      	mov	r3, r2
 801fda8:	813b      	strh	r3, [r7, #8]
	if (HAL_OK
			== HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, dest, size, I2C_TIMEOUT)) {
 801fdaa:	68fb      	ldr	r3, [r7, #12]
 801fdac:	6858      	ldr	r0, [r3, #4]
 801fdae:	68fb      	ldr	r3, [r7, #12]
 801fdb0:	7a1b      	ldrb	r3, [r3, #8]
 801fdb2:	b299      	uxth	r1, r3
 801fdb4:	897a      	ldrh	r2, [r7, #10]
 801fdb6:	2364      	movs	r3, #100	; 0x64
 801fdb8:	9302      	str	r3, [sp, #8]
 801fdba:	893b      	ldrh	r3, [r7, #8]
 801fdbc:	9301      	str	r3, [sp, #4]
 801fdbe:	687b      	ldr	r3, [r7, #4]
 801fdc0:	9300      	str	r3, [sp, #0]
 801fdc2:	2301      	movs	r3, #1
 801fdc4:	f7ee fd9a 	bl	800e8fc <HAL_I2C_Mem_Read>
 801fdc8:	4603      	mov	r3, r0
 801fdca:	2b00      	cmp	r3, #0
 801fdcc:	bf0c      	ite	eq
 801fdce:	2301      	moveq	r3, #1
 801fdd0:	2300      	movne	r3, #0
 801fdd2:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801fdd4:	2b00      	cmp	r3, #0
 801fdd6:	d001      	beq.n	801fddc <_ZN8CALIPILE12readRegisterEtPht+0x46>
		return true;
 801fdd8:	2301      	movs	r3, #1
 801fdda:	e000      	b.n	801fdde <_ZN8CALIPILE12readRegisterEtPht+0x48>
	} else {
		return false;
 801fddc:	2300      	movs	r3, #0
	}
}
 801fdde:	4618      	mov	r0, r3
 801fde0:	3710      	adds	r7, #16
 801fde2:	46bd      	mov	sp, r7
 801fde4:	bd80      	pop	{r7, pc}

0801fde6 <_ZN8CALIPILE13writeRegisterEhPht>:

bool CALIPILE::writeRegister(uint8_t mem_addr, uint8_t *val, uint16_t size) {
 801fde6:	b580      	push	{r7, lr}
 801fde8:	b088      	sub	sp, #32
 801fdea:	af04      	add	r7, sp, #16
 801fdec:	60f8      	str	r0, [r7, #12]
 801fdee:	607a      	str	r2, [r7, #4]
 801fdf0:	461a      	mov	r2, r3
 801fdf2:	460b      	mov	r3, r1
 801fdf4:	72fb      	strb	r3, [r7, #11]
 801fdf6:	4613      	mov	r3, r2
 801fdf8:	813b      	strh	r3, [r7, #8]
	if (HAL_OK
			== HAL_I2C_Mem_Write(i2c_han, i2c_addr, mem_addr, 1, val, size, I2C_TIMEOUT)) {
 801fdfa:	68fb      	ldr	r3, [r7, #12]
 801fdfc:	6858      	ldr	r0, [r3, #4]
 801fdfe:	68fb      	ldr	r3, [r7, #12]
 801fe00:	7a1b      	ldrb	r3, [r3, #8]
 801fe02:	b299      	uxth	r1, r3
 801fe04:	7afb      	ldrb	r3, [r7, #11]
 801fe06:	b29a      	uxth	r2, r3
 801fe08:	2364      	movs	r3, #100	; 0x64
 801fe0a:	9302      	str	r3, [sp, #8]
 801fe0c:	893b      	ldrh	r3, [r7, #8]
 801fe0e:	9301      	str	r3, [sp, #4]
 801fe10:	687b      	ldr	r3, [r7, #4]
 801fe12:	9300      	str	r3, [sp, #0]
 801fe14:	2301      	movs	r3, #1
 801fe16:	f7ee fc5d 	bl	800e6d4 <HAL_I2C_Mem_Write>
 801fe1a:	4603      	mov	r3, r0
 801fe1c:	2b00      	cmp	r3, #0
 801fe1e:	bf0c      	ite	eq
 801fe20:	2301      	moveq	r3, #1
 801fe22:	2300      	movne	r3, #0
 801fe24:	b2db      	uxtb	r3, r3
	if (HAL_OK
 801fe26:	2b00      	cmp	r3, #0
 801fe28:	d001      	beq.n	801fe2e <_ZN8CALIPILE13writeRegisterEhPht+0x48>
		return true;
 801fe2a:	2301      	movs	r3, #1
 801fe2c:	e000      	b.n	801fe30 <_ZN8CALIPILE13writeRegisterEhPht+0x4a>
	} else {
		return false;
 801fe2e:	2300      	movs	r3, #0
	}
}
 801fe30:	4618      	mov	r0, r3
 801fe32:	3710      	adds	r7, #16
 801fe34:	46bd      	mov	sp, r7
 801fe36:	bd80      	pop	{r7, pc}

0801fe38 <_ZN17Adafruit_ICM20948C1Ev>:
#include "main.h"
/*!
 *    @brief  Instantiates a new ICM20948 class!
 */

Adafruit_ICM20948::Adafruit_ICM20948(void) {
 801fe38:	b580      	push	{r7, lr}
 801fe3a:	b082      	sub	sp, #8
 801fe3c:	af00      	add	r7, sp, #0
 801fe3e:	6078      	str	r0, [r7, #4]
 801fe40:	687b      	ldr	r3, [r7, #4]
 801fe42:	4618      	mov	r0, r3
 801fe44:	f000 f9c0 	bl	80201c8 <_ZN15Adafruit_ICM20XC1Ev>
 801fe48:	4a03      	ldr	r2, [pc, #12]	; (801fe58 <_ZN17Adafruit_ICM20948C1Ev+0x20>)
 801fe4a:	687b      	ldr	r3, [r7, #4]
 801fe4c:	601a      	str	r2, [r3, #0]
}
 801fe4e:	687b      	ldr	r3, [r7, #4]
 801fe50:	4618      	mov	r0, r3
 801fe52:	3708      	adds	r7, #8
 801fe54:	46bd      	mov	sp, r7
 801fe56:	bd80      	pop	{r7, pc}
 801fe58:	0802cb40 	.word	0x0802cb40

0801fe5c <_ZN17Adafruit_ICM209489begin_I2CEhP19__I2C_HandleTypeDefl>:
 *            An optional parameter to set the sensor ids to differentiate
 * similar sensors The passed value is assigned to the accelerometer and the
 * gyro get +1 and the temperature sensor +2.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_ICM20948::begin_I2C(uint8_t i2c_address, I2C_HandleTypeDef *i2c_handle, int32_t sensor_id) {
 801fe5c:	b580      	push	{r7, lr}
 801fe5e:	b086      	sub	sp, #24
 801fe60:	af00      	add	r7, sp, #0
 801fe62:	60f8      	str	r0, [r7, #12]
 801fe64:	607a      	str	r2, [r7, #4]
 801fe66:	603b      	str	r3, [r7, #0]
 801fe68:	460b      	mov	r3, r1
 801fe6a:	72fb      	strb	r3, [r7, #11]


	i2c_han = &hi2c3;
 801fe6c:	68fb      	ldr	r3, [r7, #12]
 801fe6e:	4a0a      	ldr	r2, [pc, #40]	; (801fe98 <_ZN17Adafruit_ICM209489begin_I2CEhP19__I2C_HandleTypeDefl+0x3c>)
 801fe70:	639a      	str	r2, [r3, #56]	; 0x38
	i2c_addr = i2c_address << 1;
 801fe72:	7afb      	ldrb	r3, [r7, #11]
 801fe74:	005b      	lsls	r3, r3, #1
 801fe76:	b2da      	uxtb	r2, r3
 801fe78:	68fb      	ldr	r3, [r7, #12]
 801fe7a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

	bool init_success = _init(sensor_id);
 801fe7e:	68fb      	ldr	r3, [r7, #12]
 801fe80:	6839      	ldr	r1, [r7, #0]
 801fe82:	4618      	mov	r0, r3
 801fe84:	f000 fa5c 	bl	8020340 <_ZN15Adafruit_ICM20X5_initEl>
 801fe88:	4603      	mov	r3, r0
 801fe8a:	75fb      	strb	r3, [r7, #23]
	// todo: the below function doesnt execute properly, not sure why yet (or if its needed)
//	if (!setupMag()) {
//		return false;
//	}

	return init_success;
 801fe8c:	7dfb      	ldrb	r3, [r7, #23]

}
 801fe8e:	4618      	mov	r0, r3
 801fe90:	3718      	adds	r7, #24
 801fe92:	46bd      	mov	sp, r7
 801fe94:	bd80      	pop	{r7, pc}
 801fe96:	bf00      	nop
 801fe98:	20011f5c 	.word	0x20011f5c
 801fe9c:	00000000 	.word	0x00000000

0801fea0 <_ZN17Adafruit_ICM2094811scaleValuesEv>:

bool Adafruit_ICM20948::writeMagRegister(uint8_t mag_reg_addr, uint8_t value) {
	return writeExternalRegister(0x0C, mag_reg_addr, value);
}

void Adafruit_ICM20948::scaleValues(void) {
 801fea0:	b580      	push	{r7, lr}
 801fea2:	b086      	sub	sp, #24
 801fea4:	af00      	add	r7, sp, #0
 801fea6:	6078      	str	r0, [r7, #4]

	icm20948_gyro_range_t gyro_range = (icm20948_gyro_range_t) current_gyro_range;
 801fea8:	687b      	ldr	r3, [r7, #4]
 801feaa:	f893 306d 	ldrb.w	r3, [r3, #109]	; 0x6d
 801feae:	73fb      	strb	r3, [r7, #15]
	icm20948_accel_range_t accel_range =
 801feb0:	687b      	ldr	r3, [r7, #4]
 801feb2:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 801feb6:	73bb      	strb	r3, [r7, #14]
			(icm20948_accel_range_t) current_accel_range;

	float accel_scale = 1.0;
 801feb8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 801febc:	617b      	str	r3, [r7, #20]
	float gyro_scale = 1.0;
 801febe:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 801fec2:	613b      	str	r3, [r7, #16]

	if (gyro_range == ICM20948_GYRO_RANGE_250_DPS)
 801fec4:	7bfb      	ldrb	r3, [r7, #15]
 801fec6:	2b00      	cmp	r3, #0
 801fec8:	d101      	bne.n	801fece <_ZN17Adafruit_ICM2094811scaleValuesEv+0x2e>
		gyro_scale = 131.0;
 801feca:	4b61      	ldr	r3, [pc, #388]	; (8020050 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1b0>)
 801fecc:	613b      	str	r3, [r7, #16]
	if (gyro_range == ICM20948_GYRO_RANGE_500_DPS)
 801fece:	7bfb      	ldrb	r3, [r7, #15]
 801fed0:	2b01      	cmp	r3, #1
 801fed2:	d101      	bne.n	801fed8 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x38>
		gyro_scale = 65.5;
 801fed4:	4b5f      	ldr	r3, [pc, #380]	; (8020054 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1b4>)
 801fed6:	613b      	str	r3, [r7, #16]
	if (gyro_range == ICM20948_GYRO_RANGE_1000_DPS)
 801fed8:	7bfb      	ldrb	r3, [r7, #15]
 801feda:	2b02      	cmp	r3, #2
 801fedc:	d101      	bne.n	801fee2 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x42>
		gyro_scale = 32.8;
 801fede:	4b5e      	ldr	r3, [pc, #376]	; (8020058 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1b8>)
 801fee0:	613b      	str	r3, [r7, #16]
	if (gyro_range == ICM20948_GYRO_RANGE_2000_DPS)
 801fee2:	7bfb      	ldrb	r3, [r7, #15]
 801fee4:	2b03      	cmp	r3, #3
 801fee6:	d101      	bne.n	801feec <_ZN17Adafruit_ICM2094811scaleValuesEv+0x4c>
		gyro_scale = 16.4;
 801fee8:	4b5c      	ldr	r3, [pc, #368]	; (802005c <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1bc>)
 801feea:	613b      	str	r3, [r7, #16]

	if (accel_range == ICM20948_ACCEL_RANGE_2_G)
 801feec:	7bbb      	ldrb	r3, [r7, #14]
 801feee:	2b00      	cmp	r3, #0
 801fef0:	d102      	bne.n	801fef8 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x58>
		accel_scale = 16384.0;
 801fef2:	f04f 438d 	mov.w	r3, #1182793728	; 0x46800000
 801fef6:	617b      	str	r3, [r7, #20]
	if (accel_range == ICM20948_ACCEL_RANGE_4_G)
 801fef8:	7bbb      	ldrb	r3, [r7, #14]
 801fefa:	2b01      	cmp	r3, #1
 801fefc:	d102      	bne.n	801ff04 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x64>
		accel_scale = 8192.0;
 801fefe:	f04f 438c 	mov.w	r3, #1174405120	; 0x46000000
 801ff02:	617b      	str	r3, [r7, #20]
	if (accel_range == ICM20948_ACCEL_RANGE_8_G)
 801ff04:	7bbb      	ldrb	r3, [r7, #14]
 801ff06:	2b02      	cmp	r3, #2
 801ff08:	d102      	bne.n	801ff10 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x70>
		accel_scale = 4096.0;
 801ff0a:	f04f 438b 	mov.w	r3, #1166016512	; 0x45800000
 801ff0e:	617b      	str	r3, [r7, #20]
	if (accel_range == ICM20948_ACCEL_RANGE_16_G)
 801ff10:	7bbb      	ldrb	r3, [r7, #14]
 801ff12:	2b03      	cmp	r3, #3
 801ff14:	d102      	bne.n	801ff1c <_ZN17Adafruit_ICM2094811scaleValuesEv+0x7c>
		accel_scale = 2048.0;
 801ff16:	f04f 438a 	mov.w	r3, #1157627904	; 0x45000000
 801ff1a:	617b      	str	r3, [r7, #20]

	gyroX = rawGyroX / gyro_scale;
 801ff1c:	687b      	ldr	r3, [r7, #4]
 801ff1e:	f9b3 3060 	ldrsh.w	r3, [r3, #96]	; 0x60
 801ff22:	ee07 3a90 	vmov	s15, r3
 801ff26:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ff2a:	ed97 7a04 	vldr	s14, [r7, #16]
 801ff2e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ff32:	687b      	ldr	r3, [r7, #4]
 801ff34:	edc3 7a08 	vstr	s15, [r3, #32]
	gyroY = rawGyroY / gyro_scale;
 801ff38:	687b      	ldr	r3, [r7, #4]
 801ff3a:	f9b3 3062 	ldrsh.w	r3, [r3, #98]	; 0x62
 801ff3e:	ee07 3a90 	vmov	s15, r3
 801ff42:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ff46:	ed97 7a04 	vldr	s14, [r7, #16]
 801ff4a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ff4e:	687b      	ldr	r3, [r7, #4]
 801ff50:	edc3 7a09 	vstr	s15, [r3, #36]	; 0x24
	gyroZ = rawGyroZ / gyro_scale;
 801ff54:	687b      	ldr	r3, [r7, #4]
 801ff56:	f9b3 3064 	ldrsh.w	r3, [r3, #100]	; 0x64
 801ff5a:	ee07 3a90 	vmov	s15, r3
 801ff5e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ff62:	ed97 7a04 	vldr	s14, [r7, #16]
 801ff66:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ff6a:	687b      	ldr	r3, [r7, #4]
 801ff6c:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28

	accX = rawAccX / accel_scale;
 801ff70:	687b      	ldr	r3, [r7, #4]
 801ff72:	f9b3 3058 	ldrsh.w	r3, [r3, #88]	; 0x58
 801ff76:	ee07 3a90 	vmov	s15, r3
 801ff7a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ff7e:	ed97 7a05 	vldr	s14, [r7, #20]
 801ff82:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ff86:	687b      	ldr	r3, [r7, #4]
 801ff88:	edc3 7a05 	vstr	s15, [r3, #20]
	accY = rawAccY / accel_scale;
 801ff8c:	687b      	ldr	r3, [r7, #4]
 801ff8e:	f9b3 305a 	ldrsh.w	r3, [r3, #90]	; 0x5a
 801ff92:	ee07 3a90 	vmov	s15, r3
 801ff96:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ff9a:	ed97 7a05 	vldr	s14, [r7, #20]
 801ff9e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ffa2:	687b      	ldr	r3, [r7, #4]
 801ffa4:	edc3 7a06 	vstr	s15, [r3, #24]
	accZ = rawAccZ / accel_scale;
 801ffa8:	687b      	ldr	r3, [r7, #4]
 801ffaa:	f9b3 305c 	ldrsh.w	r3, [r3, #92]	; 0x5c
 801ffae:	ee07 3a90 	vmov	s15, r3
 801ffb2:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 801ffb6:	ed97 7a05 	vldr	s14, [r7, #20]
 801ffba:	eec6 7a87 	vdiv.f32	s15, s13, s14
 801ffbe:	687b      	ldr	r3, [r7, #4]
 801ffc0:	edc3 7a07 	vstr	s15, [r3, #28]

	magX = rawMagX * ICM20948_UT_PER_LSB;
 801ffc4:	687b      	ldr	r3, [r7, #4]
 801ffc6:	f9b3 3066 	ldrsh.w	r3, [r3, #102]	; 0x66
 801ffca:	4618      	mov	r0, r3
 801ffcc:	f7e7 fd2a 	bl	8007a24 <__aeabi_i2d>
 801ffd0:	a31d      	add	r3, pc, #116	; (adr r3, 8020048 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1a8>)
 801ffd2:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ffd6:	f7e7 fd8f 	bl	8007af8 <__aeabi_dmul>
 801ffda:	4602      	mov	r2, r0
 801ffdc:	460b      	mov	r3, r1
 801ffde:	4610      	mov	r0, r2
 801ffe0:	4619      	mov	r1, r3
 801ffe2:	f7e8 f881 	bl	80080e8 <__aeabi_d2f>
 801ffe6:	4602      	mov	r2, r0
 801ffe8:	687b      	ldr	r3, [r7, #4]
 801ffea:	62da      	str	r2, [r3, #44]	; 0x2c
	magY = rawMagY * ICM20948_UT_PER_LSB;
 801ffec:	687b      	ldr	r3, [r7, #4]
 801ffee:	f9b3 3068 	ldrsh.w	r3, [r3, #104]	; 0x68
 801fff2:	4618      	mov	r0, r3
 801fff4:	f7e7 fd16 	bl	8007a24 <__aeabi_i2d>
 801fff8:	a313      	add	r3, pc, #76	; (adr r3, 8020048 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1a8>)
 801fffa:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fffe:	f7e7 fd7b 	bl	8007af8 <__aeabi_dmul>
 8020002:	4602      	mov	r2, r0
 8020004:	460b      	mov	r3, r1
 8020006:	4610      	mov	r0, r2
 8020008:	4619      	mov	r1, r3
 802000a:	f7e8 f86d 	bl	80080e8 <__aeabi_d2f>
 802000e:	4602      	mov	r2, r0
 8020010:	687b      	ldr	r3, [r7, #4]
 8020012:	631a      	str	r2, [r3, #48]	; 0x30
	magZ = rawMagZ * ICM20948_UT_PER_LSB;
 8020014:	687b      	ldr	r3, [r7, #4]
 8020016:	f9b3 306a 	ldrsh.w	r3, [r3, #106]	; 0x6a
 802001a:	4618      	mov	r0, r3
 802001c:	f7e7 fd02 	bl	8007a24 <__aeabi_i2d>
 8020020:	a309      	add	r3, pc, #36	; (adr r3, 8020048 <_ZN17Adafruit_ICM2094811scaleValuesEv+0x1a8>)
 8020022:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020026:	f7e7 fd67 	bl	8007af8 <__aeabi_dmul>
 802002a:	4602      	mov	r2, r0
 802002c:	460b      	mov	r3, r1
 802002e:	4610      	mov	r0, r2
 8020030:	4619      	mov	r1, r3
 8020032:	f7e8 f859 	bl	80080e8 <__aeabi_d2f>
 8020036:	4602      	mov	r2, r0
 8020038:	687b      	ldr	r3, [r7, #4]
 802003a:	635a      	str	r2, [r3, #52]	; 0x34
}
 802003c:	bf00      	nop
 802003e:	3718      	adds	r7, #24
 8020040:	46bd      	mov	sp, r7
 8020042:	bd80      	pop	{r7, pc}
 8020044:	f3af 8000 	nop.w
 8020048:	33333333 	.word	0x33333333
 802004c:	3fc33333 	.word	0x3fc33333
 8020050:	43030000 	.word	0x43030000
 8020054:	42830000 	.word	0x42830000
 8020058:	42033333 	.word	0x42033333
 802005c:	41833333 	.word	0x41833333

08020060 <_ZN15Adafruit_SensorC1Ev>:
 * https://github.com/android/platform_hardware_libhardware/blob/master/include/hardware/sensors.h
 */
class Adafruit_Sensor {
public:
  // Constructor(s)
  Adafruit_Sensor() {}
 8020060:	b480      	push	{r7}
 8020062:	b083      	sub	sp, #12
 8020064:	af00      	add	r7, sp, #0
 8020066:	6078      	str	r0, [r7, #4]
 8020068:	4a04      	ldr	r2, [pc, #16]	; (802007c <_ZN15Adafruit_SensorC1Ev+0x1c>)
 802006a:	687b      	ldr	r3, [r7, #4]
 802006c:	601a      	str	r2, [r3, #0]
 802006e:	687b      	ldr	r3, [r7, #4]
 8020070:	4618      	mov	r0, r3
 8020072:	370c      	adds	r7, #12
 8020074:	46bd      	mov	sp, r7
 8020076:	f85d 7b04 	ldr.w	r7, [sp], #4
 802007a:	4770      	bx	lr
 802007c:	0802cbd0 	.word	0x0802cbd0

08020080 <_ZN15Adafruit_SensorD1Ev>:
  virtual ~Adafruit_Sensor() {}
 8020080:	b480      	push	{r7}
 8020082:	b083      	sub	sp, #12
 8020084:	af00      	add	r7, sp, #0
 8020086:	6078      	str	r0, [r7, #4]
 8020088:	4a04      	ldr	r2, [pc, #16]	; (802009c <_ZN15Adafruit_SensorD1Ev+0x1c>)
 802008a:	687b      	ldr	r3, [r7, #4]
 802008c:	601a      	str	r2, [r3, #0]
 802008e:	687b      	ldr	r3, [r7, #4]
 8020090:	4618      	mov	r0, r3
 8020092:	370c      	adds	r7, #12
 8020094:	46bd      	mov	sp, r7
 8020096:	f85d 7b04 	ldr.w	r7, [sp], #4
 802009a:	4770      	bx	lr
 802009c:	0802cbd0 	.word	0x0802cbd0

080200a0 <_ZN15Adafruit_SensorD0Ev>:
 80200a0:	b580      	push	{r7, lr}
 80200a2:	b082      	sub	sp, #8
 80200a4:	af00      	add	r7, sp, #0
 80200a6:	6078      	str	r0, [r7, #4]
 80200a8:	6878      	ldr	r0, [r7, #4]
 80200aa:	f7ff ffe9 	bl	8020080 <_ZN15Adafruit_SensorD1Ev>
 80200ae:	2108      	movs	r1, #8
 80200b0:	6878      	ldr	r0, [r7, #4]
 80200b2:	f009 f8c7 	bl	8029244 <_ZdlPvj>
 80200b6:	687b      	ldr	r3, [r7, #4]
 80200b8:	4618      	mov	r0, r3
 80200ba:	3708      	adds	r7, #8
 80200bc:	46bd      	mov	sp, r7
 80200be:	bd80      	pop	{r7, pc}

080200c0 <_ZN15Adafruit_Sensor15enableAutoRangeEb>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
 80200c0:	b480      	push	{r7}
 80200c2:	b083      	sub	sp, #12
 80200c4:	af00      	add	r7, sp, #0
 80200c6:	6078      	str	r0, [r7, #4]
 80200c8:	460b      	mov	r3, r1
 80200ca:	70fb      	strb	r3, [r7, #3]
    (void)enabled; /* suppress unused warning */
  };
 80200cc:	bf00      	nop
 80200ce:	370c      	adds	r7, #12
 80200d0:	46bd      	mov	sp, r7
 80200d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80200d6:	4770      	bx	lr

080200d8 <_ZN29Adafruit_ICM20X_AccelerometerC1EP15Adafruit_ICM20X>:
class Adafruit_ICM20X_Accelerometer: public Adafruit_Sensor {
public:
	/** @brief Create an Adafruit_Sensor compatible object for the accelerometer
	 sensor
	 @param parent A pointer to the ICM20X class */
	Adafruit_ICM20X_Accelerometer(Adafruit_ICM20X *parent) {
 80200d8:	b580      	push	{r7, lr}
 80200da:	b082      	sub	sp, #8
 80200dc:	af00      	add	r7, sp, #0
 80200de:	6078      	str	r0, [r7, #4]
 80200e0:	6039      	str	r1, [r7, #0]
 80200e2:	687b      	ldr	r3, [r7, #4]
 80200e4:	4618      	mov	r0, r3
 80200e6:	f7ff ffbb 	bl	8020060 <_ZN15Adafruit_SensorC1Ev>
 80200ea:	4a09      	ldr	r2, [pc, #36]	; (8020110 <_ZN29Adafruit_ICM20X_AccelerometerC1EP15Adafruit_ICM20X+0x38>)
 80200ec:	687b      	ldr	r3, [r7, #4]
 80200ee:	601a      	str	r2, [r3, #0]
 80200f0:	687b      	ldr	r3, [r7, #4]
 80200f2:	f240 220a 	movw	r2, #522	; 0x20a
 80200f6:	609a      	str	r2, [r3, #8]
 80200f8:	687b      	ldr	r3, [r7, #4]
 80200fa:	2200      	movs	r2, #0
 80200fc:	60da      	str	r2, [r3, #12]
		_theICM20X = parent;
 80200fe:	687b      	ldr	r3, [r7, #4]
 8020100:	683a      	ldr	r2, [r7, #0]
 8020102:	60da      	str	r2, [r3, #12]
	}
 8020104:	687b      	ldr	r3, [r7, #4]
 8020106:	4618      	mov	r0, r3
 8020108:	3708      	adds	r7, #8
 802010a:	46bd      	mov	sp, r7
 802010c:	bd80      	pop	{r7, pc}
 802010e:	bf00      	nop
 8020110:	0802cbb4 	.word	0x0802cbb4

08020114 <_ZN20Adafruit_ICM20X_GyroC1EP15Adafruit_ICM20X>:
/** Adafruit Unified Sensor interface for gyro component of ICM20X */
class Adafruit_ICM20X_Gyro: public Adafruit_Sensor {
public:
	/** @brief Create an Adafruit_Sensor compatible object for the gyro sensor
	 @param parent A pointer to the ICM20X class */
	Adafruit_ICM20X_Gyro(Adafruit_ICM20X *parent) {
 8020114:	b580      	push	{r7, lr}
 8020116:	b082      	sub	sp, #8
 8020118:	af00      	add	r7, sp, #0
 802011a:	6078      	str	r0, [r7, #4]
 802011c:	6039      	str	r1, [r7, #0]
 802011e:	687b      	ldr	r3, [r7, #4]
 8020120:	4618      	mov	r0, r3
 8020122:	f7ff ff9d 	bl	8020060 <_ZN15Adafruit_SensorC1Ev>
 8020126:	4a09      	ldr	r2, [pc, #36]	; (802014c <_ZN20Adafruit_ICM20X_GyroC1EP15Adafruit_ICM20X+0x38>)
 8020128:	687b      	ldr	r3, [r7, #4]
 802012a:	601a      	str	r2, [r3, #0]
 802012c:	687b      	ldr	r3, [r7, #4]
 802012e:	f240 220b 	movw	r2, #523	; 0x20b
 8020132:	609a      	str	r2, [r3, #8]
 8020134:	687b      	ldr	r3, [r7, #4]
 8020136:	2200      	movs	r2, #0
 8020138:	60da      	str	r2, [r3, #12]
		_theICM20X = parent;
 802013a:	687b      	ldr	r3, [r7, #4]
 802013c:	683a      	ldr	r2, [r7, #0]
 802013e:	60da      	str	r2, [r3, #12]
	}
 8020140:	687b      	ldr	r3, [r7, #4]
 8020142:	4618      	mov	r0, r3
 8020144:	3708      	adds	r7, #8
 8020146:	46bd      	mov	sp, r7
 8020148:	bd80      	pop	{r7, pc}
 802014a:	bf00      	nop
 802014c:	0802cb98 	.word	0x0802cb98

08020150 <_ZN28Adafruit_ICM20X_MagnetometerC1EP15Adafruit_ICM20X>:
class Adafruit_ICM20X_Magnetometer: public Adafruit_Sensor {
public:
	/** @brief Create an Adafruit_Sensor compatible object for the magnetometer
	 sensor
	 @param parent A pointer to the ICM20X class */
	Adafruit_ICM20X_Magnetometer(Adafruit_ICM20X *parent) {
 8020150:	b580      	push	{r7, lr}
 8020152:	b082      	sub	sp, #8
 8020154:	af00      	add	r7, sp, #0
 8020156:	6078      	str	r0, [r7, #4]
 8020158:	6039      	str	r1, [r7, #0]
 802015a:	687b      	ldr	r3, [r7, #4]
 802015c:	4618      	mov	r0, r3
 802015e:	f7ff ff7f 	bl	8020060 <_ZN15Adafruit_SensorC1Ev>
 8020162:	4a09      	ldr	r2, [pc, #36]	; (8020188 <_ZN28Adafruit_ICM20X_MagnetometerC1EP15Adafruit_ICM20X+0x38>)
 8020164:	687b      	ldr	r3, [r7, #4]
 8020166:	601a      	str	r2, [r3, #0]
 8020168:	687b      	ldr	r3, [r7, #4]
 802016a:	f44f 7203 	mov.w	r2, #524	; 0x20c
 802016e:	609a      	str	r2, [r3, #8]
 8020170:	687b      	ldr	r3, [r7, #4]
 8020172:	2200      	movs	r2, #0
 8020174:	60da      	str	r2, [r3, #12]
		_theICM20X = parent;
 8020176:	687b      	ldr	r3, [r7, #4]
 8020178:	683a      	ldr	r2, [r7, #0]
 802017a:	60da      	str	r2, [r3, #12]
	}
 802017c:	687b      	ldr	r3, [r7, #4]
 802017e:	4618      	mov	r0, r3
 8020180:	3708      	adds	r7, #8
 8020182:	46bd      	mov	sp, r7
 8020184:	bd80      	pop	{r7, pc}
 8020186:	bf00      	nop
 8020188:	0802cb7c 	.word	0x0802cb7c

0802018c <_ZN20Adafruit_ICM20X_TempC1EP15Adafruit_ICM20X>:
/** Adafruit Unified Sensor interface for temperature component of ICM20X */
class Adafruit_ICM20X_Temp: public Adafruit_Sensor {
public:
	/** @brief Create an Adafruit_Sensor compatible object for the temp sensor
	 @param parent A pointer to the ICM20X class */
	Adafruit_ICM20X_Temp(Adafruit_ICM20X *parent) {
 802018c:	b580      	push	{r7, lr}
 802018e:	b082      	sub	sp, #8
 8020190:	af00      	add	r7, sp, #0
 8020192:	6078      	str	r0, [r7, #4]
 8020194:	6039      	str	r1, [r7, #0]
 8020196:	687b      	ldr	r3, [r7, #4]
 8020198:	4618      	mov	r0, r3
 802019a:	f7ff ff61 	bl	8020060 <_ZN15Adafruit_SensorC1Ev>
 802019e:	4a09      	ldr	r2, [pc, #36]	; (80201c4 <_ZN20Adafruit_ICM20X_TempC1EP15Adafruit_ICM20X+0x38>)
 80201a0:	687b      	ldr	r3, [r7, #4]
 80201a2:	601a      	str	r2, [r3, #0]
 80201a4:	687b      	ldr	r3, [r7, #4]
 80201a6:	f240 220d 	movw	r2, #525	; 0x20d
 80201aa:	609a      	str	r2, [r3, #8]
 80201ac:	687b      	ldr	r3, [r7, #4]
 80201ae:	2200      	movs	r2, #0
 80201b0:	60da      	str	r2, [r3, #12]
		_theICM20X = parent;
 80201b2:	687b      	ldr	r3, [r7, #4]
 80201b4:	683a      	ldr	r2, [r7, #0]
 80201b6:	60da      	str	r2, [r3, #12]
	}
 80201b8:	687b      	ldr	r3, [r7, #4]
 80201ba:	4618      	mov	r0, r3
 80201bc:	3708      	adds	r7, #8
 80201be:	46bd      	mov	sp, r7
 80201c0:	bd80      	pop	{r7, pc}
 80201c2:	bf00      	nop
 80201c4:	0802cb60 	.word	0x0802cb60

080201c8 <_ZN15Adafruit_ICM20XC1Ev>:
#include "Adafruit_ICM20X.h"
#include "string.h"
/*!
 *    @brief  Instantiates a new ICM20X class!
 */
Adafruit_ICM20X::Adafruit_ICM20X(void) {
 80201c8:	b480      	push	{r7}
 80201ca:	b083      	sub	sp, #12
 80201cc:	af00      	add	r7, sp, #0
 80201ce:	6078      	str	r0, [r7, #4]
 80201d0:	4a0e      	ldr	r2, [pc, #56]	; (802020c <_ZN15Adafruit_ICM20XC1Ev+0x44>)
 80201d2:	687b      	ldr	r3, [r7, #4]
 80201d4:	601a      	str	r2, [r3, #0]
 80201d6:	687b      	ldr	r3, [r7, #4]
 80201d8:	2200      	movs	r2, #0
 80201da:	639a      	str	r2, [r3, #56]	; 0x38
 80201dc:	687b      	ldr	r3, [r7, #4]
 80201de:	2200      	movs	r2, #0
 80201e0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 80201e4:	687b      	ldr	r3, [r7, #4]
 80201e6:	2200      	movs	r2, #0
 80201e8:	641a      	str	r2, [r3, #64]	; 0x40
 80201ea:	687b      	ldr	r3, [r7, #4]
 80201ec:	2200      	movs	r2, #0
 80201ee:	645a      	str	r2, [r3, #68]	; 0x44
 80201f0:	687b      	ldr	r3, [r7, #4]
 80201f2:	2200      	movs	r2, #0
 80201f4:	649a      	str	r2, [r3, #72]	; 0x48
 80201f6:	687b      	ldr	r3, [r7, #4]
 80201f8:	2200      	movs	r2, #0
 80201fa:	64da      	str	r2, [r3, #76]	; 0x4c
}
 80201fc:	687b      	ldr	r3, [r7, #4]
 80201fe:	4618      	mov	r0, r3
 8020200:	370c      	adds	r7, #12
 8020202:	46bd      	mov	sp, r7
 8020204:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020208:	4770      	bx	lr
 802020a:	bf00      	nop
 802020c:	0802cb50 	.word	0x0802cb50

08020210 <_ZN15Adafruit_ICM20XD1Ev>:

/*!
 *    @brief  Cleans up the ICM20X
 */
Adafruit_ICM20X::~Adafruit_ICM20X(void) {
 8020210:	b580      	push	{r7, lr}
 8020212:	b082      	sub	sp, #8
 8020214:	af00      	add	r7, sp, #0
 8020216:	6078      	str	r0, [r7, #4]
 8020218:	4a1d      	ldr	r2, [pc, #116]	; (8020290 <_ZN15Adafruit_ICM20XD1Ev+0x80>)
 802021a:	687b      	ldr	r3, [r7, #4]
 802021c:	601a      	str	r2, [r3, #0]
	if (accel_sensor)
 802021e:	687b      	ldr	r3, [r7, #4]
 8020220:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8020222:	2b00      	cmp	r3, #0
 8020224:	d008      	beq.n	8020238 <_ZN15Adafruit_ICM20XD1Ev+0x28>
		delete accel_sensor;
 8020226:	687b      	ldr	r3, [r7, #4]
 8020228:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802022a:	2b00      	cmp	r3, #0
 802022c:	d004      	beq.n	8020238 <_ZN15Adafruit_ICM20XD1Ev+0x28>
 802022e:	681a      	ldr	r2, [r3, #0]
 8020230:	3204      	adds	r2, #4
 8020232:	6812      	ldr	r2, [r2, #0]
 8020234:	4618      	mov	r0, r3
 8020236:	4790      	blx	r2
	if (gyro_sensor)
 8020238:	687b      	ldr	r3, [r7, #4]
 802023a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802023c:	2b00      	cmp	r3, #0
 802023e:	d008      	beq.n	8020252 <_ZN15Adafruit_ICM20XD1Ev+0x42>
		delete gyro_sensor;
 8020240:	687b      	ldr	r3, [r7, #4]
 8020242:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8020244:	2b00      	cmp	r3, #0
 8020246:	d004      	beq.n	8020252 <_ZN15Adafruit_ICM20XD1Ev+0x42>
 8020248:	681a      	ldr	r2, [r3, #0]
 802024a:	3204      	adds	r2, #4
 802024c:	6812      	ldr	r2, [r2, #0]
 802024e:	4618      	mov	r0, r3
 8020250:	4790      	blx	r2
	if (mag_sensor)
 8020252:	687b      	ldr	r3, [r7, #4]
 8020254:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020256:	2b00      	cmp	r3, #0
 8020258:	d008      	beq.n	802026c <_ZN15Adafruit_ICM20XD1Ev+0x5c>
		delete mag_sensor;
 802025a:	687b      	ldr	r3, [r7, #4]
 802025c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802025e:	2b00      	cmp	r3, #0
 8020260:	d004      	beq.n	802026c <_ZN15Adafruit_ICM20XD1Ev+0x5c>
 8020262:	681a      	ldr	r2, [r3, #0]
 8020264:	3204      	adds	r2, #4
 8020266:	6812      	ldr	r2, [r2, #0]
 8020268:	4618      	mov	r0, r3
 802026a:	4790      	blx	r2
	if (temp_sensor)
 802026c:	687b      	ldr	r3, [r7, #4]
 802026e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8020270:	2b00      	cmp	r3, #0
 8020272:	d008      	beq.n	8020286 <_ZN15Adafruit_ICM20XD1Ev+0x76>
		delete temp_sensor;
 8020274:	687b      	ldr	r3, [r7, #4]
 8020276:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8020278:	2b00      	cmp	r3, #0
 802027a:	d004      	beq.n	8020286 <_ZN15Adafruit_ICM20XD1Ev+0x76>
 802027c:	681a      	ldr	r2, [r3, #0]
 802027e:	3204      	adds	r2, #4
 8020280:	6812      	ldr	r2, [r2, #0]
 8020282:	4618      	mov	r0, r3
 8020284:	4790      	blx	r2
}
 8020286:	687b      	ldr	r3, [r7, #4]
 8020288:	4618      	mov	r0, r3
 802028a:	3708      	adds	r7, #8
 802028c:	46bd      	mov	sp, r7
 802028e:	bd80      	pop	{r7, pc}
 8020290:	0802cb50 	.word	0x0802cb50

08020294 <_ZN15Adafruit_ICM20X9begin_I2CEhP19__I2C_HandleTypeDefl>:
 * similar sensors The passed value is assigned to the accelerometer, the gyro
 * gets +1, the magnetometer +2, and the temperature sensor +3.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_ICM20X::begin_I2C(uint8_t i2c_addr, I2C_HandleTypeDef *i2c_handle,
		int32_t sensor_id) {
 8020294:	b480      	push	{r7}
 8020296:	b085      	sub	sp, #20
 8020298:	af00      	add	r7, sp, #0
 802029a:	60f8      	str	r0, [r7, #12]
 802029c:	607a      	str	r2, [r7, #4]
 802029e:	603b      	str	r3, [r7, #0]
 80202a0:	460b      	mov	r3, r1
 80202a2:	72fb      	strb	r3, [r7, #11]
	(void) i2c_addr;
	(void) i2c_handle;
	(void) sensor_id;
	return false;
 80202a4:	2300      	movs	r3, #0
}
 80202a6:	4618      	mov	r0, r3
 80202a8:	3714      	adds	r7, #20
 80202aa:	46bd      	mov	sp, r7
 80202ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80202b0:	4770      	bx	lr

080202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>:
	enableSPI(true);

	return _init(sensor_id);
}

void Adafruit_ICM20X::cs_active(bool state) {
 80202b2:	b580      	push	{r7, lr}
 80202b4:	b082      	sub	sp, #8
 80202b6:	af00      	add	r7, sp, #0
 80202b8:	6078      	str	r0, [r7, #4]
 80202ba:	460b      	mov	r3, r1
 80202bc:	70fb      	strb	r3, [r7, #3]
	if (state) {
 80202be:	78fb      	ldrb	r3, [r7, #3]
 80202c0:	2b00      	cmp	r3, #0
 80202c2:	d008      	beq.n	80202d6 <_ZN15Adafruit_ICM20X9cs_activeEb+0x24>
		HAL_GPIO_WritePin(_cs_port, _cs_pin, GPIO_PIN_RESET);
 80202c4:	687b      	ldr	r3, [r7, #4]
 80202c6:	6898      	ldr	r0, [r3, #8]
 80202c8:	687b      	ldr	r3, [r7, #4]
 80202ca:	899b      	ldrh	r3, [r3, #12]
 80202cc:	2200      	movs	r2, #0
 80202ce:	4619      	mov	r1, r3
 80202d0:	f7ed ff32 	bl	800e138 <HAL_GPIO_WritePin>
	} else {
		HAL_GPIO_WritePin(_cs_port, _cs_pin, GPIO_PIN_SET);

	}
}
 80202d4:	e007      	b.n	80202e6 <_ZN15Adafruit_ICM20X9cs_activeEb+0x34>
		HAL_GPIO_WritePin(_cs_port, _cs_pin, GPIO_PIN_SET);
 80202d6:	687b      	ldr	r3, [r7, #4]
 80202d8:	6898      	ldr	r0, [r3, #8]
 80202da:	687b      	ldr	r3, [r7, #4]
 80202dc:	899b      	ldrh	r3, [r3, #12]
 80202de:	2201      	movs	r2, #1
 80202e0:	4619      	mov	r1, r3
 80202e2:	f7ed ff29 	bl	800e138 <HAL_GPIO_WritePin>
}
 80202e6:	bf00      	nop
 80202e8:	3708      	adds	r7, #8
 80202ea:	46bd      	mov	sp, r7
 80202ec:	bd80      	pop	{r7, pc}

080202ee <_ZN15Adafruit_ICM20X5resetEv>:

/*!
 * @brief Reset the internal registers and restores the default settings
 *
 */
void Adafruit_ICM20X::reset(void) {
 80202ee:	b580      	push	{r7, lr}
 80202f0:	b082      	sub	sp, #8
 80202f2:	af00      	add	r7, sp, #0
 80202f4:	6078      	str	r0, [r7, #4]
	_setBank(0);
 80202f6:	2100      	movs	r1, #0
 80202f8:	6878      	ldr	r0, [r7, #4]
 80202fa:	f000 fa70 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterBit(ICM20X_B0_PWR_MGMT_1, 1, 7);
 80202fe:	2307      	movs	r3, #7
 8020300:	2201      	movs	r2, #1
 8020302:	2106      	movs	r1, #6
 8020304:	6878      	ldr	r0, [r7, #4]
 8020306:	f000 fd55 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>

	HAL_Delay(20);
 802030a:	2014      	movs	r0, #20
 802030c:	f7e8 fe56 	bl	8008fbc <HAL_Delay>

	while (checkRegisterBit(ICM20X_B0_PWR_MGMT_1, 7)) {
 8020310:	2207      	movs	r2, #7
 8020312:	2106      	movs	r1, #6
 8020314:	6878      	ldr	r0, [r7, #4]
 8020316:	f000 fd33 	bl	8020d80 <_ZN15Adafruit_ICM20X16checkRegisterBitEth>
 802031a:	4603      	mov	r3, r0
 802031c:	2b00      	cmp	r3, #0
 802031e:	bf14      	ite	ne
 8020320:	2301      	movne	r3, #1
 8020322:	2300      	moveq	r3, #0
 8020324:	b2db      	uxtb	r3, r3
 8020326:	2b00      	cmp	r3, #0
 8020328:	d003      	beq.n	8020332 <_ZN15Adafruit_ICM20X5resetEv+0x44>
		HAL_Delay(10);
 802032a:	200a      	movs	r0, #10
 802032c:	f7e8 fe46 	bl	8008fbc <HAL_Delay>
	while (checkRegisterBit(ICM20X_B0_PWR_MGMT_1, 7)) {
 8020330:	e7ee      	b.n	8020310 <_ZN15Adafruit_ICM20X5resetEv+0x22>
	};
	HAL_Delay(50);
 8020332:	2032      	movs	r0, #50	; 0x32
 8020334:	f7e8 fe42 	bl	8008fbc <HAL_Delay>
}
 8020338:	bf00      	nop
 802033a:	3708      	adds	r7, #8
 802033c:	46bd      	mov	sp, r7
 802033e:	bd80      	pop	{r7, pc}

08020340 <_ZN15Adafruit_ICM20X5_initEl>:

/*!  @brief Initilizes the sensor
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_ICM20X::_init(int32_t sensor_id) {
 8020340:	b590      	push	{r4, r7, lr}
 8020342:	b085      	sub	sp, #20
 8020344:	af00      	add	r7, sp, #0
 8020346:	6078      	str	r0, [r7, #4]
 8020348:	6039      	str	r1, [r7, #0]
	_setBank(0);
 802034a:	2100      	movs	r1, #0
 802034c:	6878      	ldr	r0, [r7, #4]
 802034e:	f000 fa46 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	uint8_t chip_id_ = readRegisterByte(ICM20X_B0_WHOAMI);
 8020352:	2100      	movs	r1, #0
 8020354:	6878      	ldr	r0, [r7, #4]
 8020356:	f000 fc24 	bl	8020ba2 <_ZN15Adafruit_ICM20X16readRegisterByteEt>
 802035a:	4603      	mov	r3, r0
 802035c:	73fb      	strb	r3, [r7, #15]
	// This returns true when using a 649 lib with a 948
	if ((chip_id_ != ICM20649_CHIP_ID) && (chip_id_ != ICM20948_CHIP_ID)) {
 802035e:	7bfb      	ldrb	r3, [r7, #15]
 8020360:	2be1      	cmp	r3, #225	; 0xe1
 8020362:	d004      	beq.n	802036e <_ZN15Adafruit_ICM20X5_initEl+0x2e>
 8020364:	7bfb      	ldrb	r3, [r7, #15]
 8020366:	2bea      	cmp	r3, #234	; 0xea
 8020368:	d001      	beq.n	802036e <_ZN15Adafruit_ICM20X5_initEl+0x2e>
		return false;
 802036a:	2300      	movs	r3, #0
 802036c:	e0bd      	b.n	80204ea <_ZN15Adafruit_ICM20X5_initEl+0x1aa>
	}

	_sensorid_accel = sensor_id;
 802036e:	683b      	ldr	r3, [r7, #0]
 8020370:	b29a      	uxth	r2, r3
 8020372:	687b      	ldr	r3, [r7, #4]
 8020374:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
	_sensorid_gyro = sensor_id + 1;
 8020378:	683b      	ldr	r3, [r7, #0]
 802037a:	b29b      	uxth	r3, r3
 802037c:	3301      	adds	r3, #1
 802037e:	b29a      	uxth	r2, r3
 8020380:	687b      	ldr	r3, [r7, #4]
 8020382:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
	_sensorid_mag = sensor_id + 2;
 8020386:	683b      	ldr	r3, [r7, #0]
 8020388:	b29b      	uxth	r3, r3
 802038a:	3302      	adds	r3, #2
 802038c:	b29a      	uxth	r2, r3
 802038e:	687b      	ldr	r3, [r7, #4]
 8020390:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
	_sensorid_temp = sensor_id + 3;
 8020394:	683b      	ldr	r3, [r7, #0]
 8020396:	b29b      	uxth	r3, r3
 8020398:	3303      	adds	r3, #3
 802039a:	b29a      	uxth	r2, r3
 802039c:	687b      	ldr	r3, [r7, #4]
 802039e:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

	reset();
 80203a2:	6878      	ldr	r0, [r7, #4]
 80203a4:	f7ff ffa3 	bl	80202ee <_ZN15Adafruit_ICM20X5resetEv>

	modifyRegisterBit(ICM20X_B0_PWR_MGMT_1, 0, 6); // take out of default sleep state
 80203a8:	2306      	movs	r3, #6
 80203aa:	2200      	movs	r2, #0
 80203ac:	2106      	movs	r1, #6
 80203ae:	6878      	ldr	r0, [r7, #4]
 80203b0:	f000 fd00 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
//	modifyRegisterMultipleBit(ICM20X_B0_PWR_MGMT_2, 0x7, 0, 3); // disable gyro


	_setBank(0);
 80203b4:	2100      	movs	r1, #0
 80203b6:	6878      	ldr	r0, [r7, #4]
 80203b8:	f000 fa11 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
	HAL_Delay(1);
 80203bc:	2001      	movs	r0, #1
 80203be:	f7e8 fdfd 	bl	8008fbc <HAL_Delay>
	modifyRegisterBit(ICM20X_BO_FIFO_EN_2, 1, 4); // Enable accelerometer data to be saved to FIFO
 80203c2:	2304      	movs	r3, #4
 80203c4:	2201      	movs	r2, #1
 80203c6:	2167      	movs	r1, #103	; 0x67
 80203c8:	6878      	ldr	r0, [r7, #4]
 80203ca:	f000 fcf3 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	modifyRegisterBit(ICM20X_BO_FIFO_EN_2, 1, 3); // Enable gyro Z
 80203ce:	2303      	movs	r3, #3
 80203d0:	2201      	movs	r2, #1
 80203d2:	2167      	movs	r1, #103	; 0x67
 80203d4:	6878      	ldr	r0, [r7, #4]
 80203d6:	f000 fced 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	modifyRegisterBit(ICM20X_BO_FIFO_EN_2, 1, 2); // Enable gyro Y
 80203da:	2302      	movs	r3, #2
 80203dc:	2201      	movs	r2, #1
 80203de:	2167      	movs	r1, #103	; 0x67
 80203e0:	6878      	ldr	r0, [r7, #4]
 80203e2:	f000 fce7 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	modifyRegisterBit(ICM20X_BO_FIFO_EN_2, 1, 1); // Enable gyro X
 80203e6:	2301      	movs	r3, #1
 80203e8:	2201      	movs	r2, #1
 80203ea:	2167      	movs	r1, #103	; 0x67
 80203ec:	6878      	ldr	r0, [r7, #4]
 80203ee:	f000 fce1 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	HAL_Delay(1);
 80203f2:	2001      	movs	r0, #1
 80203f4:	f7e8 fde2 	bl	8008fbc <HAL_Delay>

	setInt1ActiveLow(true);
 80203f8:	2101      	movs	r1, #1
 80203fa:	6878      	ldr	r0, [r7, #4]
 80203fc:	f000 faea 	bl	80209d4 <_ZN15Adafruit_ICM20X16setInt1ActiveLowEb>
	setInt1Latch(false);
 8020400:	2100      	movs	r1, #0
 8020402:	6878      	ldr	r0, [r7, #4]
 8020404:	f000 fb00 	bl	8020a08 <_ZN15Adafruit_ICM20X12setInt1LatchEb>
	clearIntOnRead(true);
 8020408:	2101      	movs	r1, #1
 802040a:	6878      	ldr	r0, [r7, #4]
 802040c:	f000 fb10 	bl	8020a30 <_ZN15Adafruit_ICM20X14clearIntOnReadEb>
//	_setBank(2);
//	modifyRegisterMultipleBit(ICM20X_B2_GYRO_CONFIG_2, 0x7, 3, 3); // gyro self test
//	_setBank(0);

	// 3 will be the largest range for either sensor
	enableGyrolDLPF(true, ICM20X_GYRO_FREQ_196_6_HZ);
 8020410:	2200      	movs	r2, #0
 8020412:	2101      	movs	r1, #1
 8020414:	6878      	ldr	r0, [r7, #4]
 8020416:	f000 faa6 	bl	8020966 <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t>
	writeGyroRange(3);
 802041a:	2103      	movs	r1, #3
 802041c:	6878      	ldr	r0, [r7, #4]
 802041e:	f000 fa11 	bl	8020844 <_ZN15Adafruit_ICM20X14writeGyroRangeEh>

	enableAccelDLPF(true, ICM20X_ACCEL_FREQ_246_0_HZ);
 8020422:	2201      	movs	r2, #1
 8020424:	2101      	movs	r1, #1
 8020426:	6878      	ldr	r0, [r7, #4]
 8020428:	f000 fa66 	bl	80208f8 <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t>
	writeAccelRange(3);
 802042c:	2103      	movs	r1, #3
 802042e:	6878      	ldr	r0, [r7, #4]
 8020430:	f000 f9ea 	bl	8020808 <_ZN15Adafruit_ICM20X15writeAccelRangeEh>

	// 1.1 kHz/(1+GYRO_SMPLRT_DIV[7:0])
	setGyroRateDivisor(1); //550hz
 8020434:	2101      	movs	r1, #1
 8020436:	6878      	ldr	r0, [r7, #4]
 8020438:	f000 fa46 	bl	80208c8 <_ZN15Adafruit_ICM20X18setGyroRateDivisorEh>

	// 1.125 kHz/(1+ACCEL_SMPLRT_DIV[11:0])
	setAccelRateDivisor(1); // 562.5Hz
 802043c:	2101      	movs	r1, #1
 802043e:	6878      	ldr	r0, [r7, #4]
 8020440:	f000 fa1e 	bl	8020880 <_ZN15Adafruit_ICM20X19setAccelRateDivisorEt>

	temp_sensor = new Adafruit_ICM20X_Temp(this);
 8020444:	2010      	movs	r0, #16
 8020446:	f008 feff 	bl	8029248 <_Znwj>
 802044a:	4603      	mov	r3, r0
 802044c:	461c      	mov	r4, r3
 802044e:	6879      	ldr	r1, [r7, #4]
 8020450:	4620      	mov	r0, r4
 8020452:	f7ff fe9b 	bl	802018c <_ZN20Adafruit_ICM20X_TempC1EP15Adafruit_ICM20X>
 8020456:	687b      	ldr	r3, [r7, #4]
 8020458:	64dc      	str	r4, [r3, #76]	; 0x4c
	accel_sensor = new Adafruit_ICM20X_Accelerometer(this);
 802045a:	2010      	movs	r0, #16
 802045c:	f008 fef4 	bl	8029248 <_Znwj>
 8020460:	4603      	mov	r3, r0
 8020462:	461c      	mov	r4, r3
 8020464:	6879      	ldr	r1, [r7, #4]
 8020466:	4620      	mov	r0, r4
 8020468:	f7ff fe36 	bl	80200d8 <_ZN29Adafruit_ICM20X_AccelerometerC1EP15Adafruit_ICM20X>
 802046c:	687b      	ldr	r3, [r7, #4]
 802046e:	641c      	str	r4, [r3, #64]	; 0x40
	gyro_sensor = new Adafruit_ICM20X_Gyro(this);
 8020470:	2010      	movs	r0, #16
 8020472:	f008 fee9 	bl	8029248 <_Znwj>
 8020476:	4603      	mov	r3, r0
 8020478:	461c      	mov	r4, r3
 802047a:	6879      	ldr	r1, [r7, #4]
 802047c:	4620      	mov	r0, r4
 802047e:	f7ff fe49 	bl	8020114 <_ZN20Adafruit_ICM20X_GyroC1EP15Adafruit_ICM20X>
 8020482:	687b      	ldr	r3, [r7, #4]
 8020484:	645c      	str	r4, [r3, #68]	; 0x44
	mag_sensor = new Adafruit_ICM20X_Magnetometer(this);
 8020486:	2010      	movs	r0, #16
 8020488:	f008 fede 	bl	8029248 <_Znwj>
 802048c:	4603      	mov	r3, r0
 802048e:	461c      	mov	r4, r3
 8020490:	6879      	ldr	r1, [r7, #4]
 8020492:	4620      	mov	r0, r4
 8020494:	f7ff fe5c 	bl	8020150 <_ZN28Adafruit_ICM20X_MagnetometerC1EP15Adafruit_ICM20X>
 8020498:	687b      	ldr	r3, [r7, #4]
 802049a:	649c      	str	r4, [r3, #72]	; 0x48

	/* ENABLE FIFO */
	_setBank(0);
 802049c:	2100      	movs	r1, #0
 802049e:	6878      	ldr	r0, [r7, #4]
 80204a0:	f000 f99d 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
	writeRegisterByte(ICM20X_BO_FIFO_RST, 0x0F); // reset FIFO
 80204a4:	220f      	movs	r2, #15
 80204a6:	2168      	movs	r1, #104	; 0x68
 80204a8:	6878      	ldr	r0, [r7, #4]
 80204aa:	f000 fc0f 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
	HAL_Delay(1);
 80204ae:	2001      	movs	r0, #1
 80204b0:	f7e8 fd84 	bl	8008fbc <HAL_Delay>
	writeRegisterByte(ICM20X_BO_FIFO_RST, 0x00);
 80204b4:	2200      	movs	r2, #0
 80204b6:	2168      	movs	r1, #104	; 0x68
 80204b8:	6878      	ldr	r0, [r7, #4]
 80204ba:	f000 fc07 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
	HAL_Delay(1);
 80204be:	2001      	movs	r0, #1
 80204c0:	f7e8 fd7c 	bl	8008fbc <HAL_Delay>
	modifyRegisterBit(ICM20X_B0_USER_CTRL, 1, 7); // Enable digital motion processor (dmp)
 80204c4:	2307      	movs	r3, #7
 80204c6:	2201      	movs	r2, #1
 80204c8:	2103      	movs	r1, #3
 80204ca:	6878      	ldr	r0, [r7, #4]
 80204cc:	f000 fc72 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	HAL_Delay(1);
 80204d0:	2001      	movs	r0, #1
 80204d2:	f7e8 fd73 	bl	8008fbc <HAL_Delay>
	modifyRegisterBit(ICM20X_B0_USER_CTRL, 1, 6); // Enable FIFO
 80204d6:	2306      	movs	r3, #6
 80204d8:	2201      	movs	r2, #1
 80204da:	2103      	movs	r1, #3
 80204dc:	6878      	ldr	r0, [r7, #4]
 80204de:	f000 fc69 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>


//	HAL_Delay(1);
//	modifyRegisterBit(ICM20X_B0_REG_INT_ENABLE_3, 1, 3); // Enable FIFO to interrupt on watermark

	HAL_Delay(20);
 80204e2:	2014      	movs	r0, #20
 80204e4:	f7e8 fd6a 	bl	8008fbc <HAL_Delay>

	return true;
 80204e8:	2301      	movs	r3, #1
}
 80204ea:	4618      	mov	r0, r3
 80204ec:	3714      	adds	r7, #20
 80204ee:	46bd      	mov	sp, r7
 80204f0:	bd90      	pop	{r4, r7, pc}
	...

080204f4 <_ZN15Adafruit_ICM20X14fillAccelEventEP15sensors_event_tm>:

	return true;
}

void Adafruit_ICM20X::fillAccelEvent(sensors_event_t *accel,
		uint32_t timestamp) {
 80204f4:	b580      	push	{r7, lr}
 80204f6:	b084      	sub	sp, #16
 80204f8:	af00      	add	r7, sp, #0
 80204fa:	60f8      	str	r0, [r7, #12]
 80204fc:	60b9      	str	r1, [r7, #8]
 80204fe:	607a      	str	r2, [r7, #4]
	memset(accel, 0, sizeof(sensors_event_t));
 8020500:	2224      	movs	r2, #36	; 0x24
 8020502:	2100      	movs	r1, #0
 8020504:	68b8      	ldr	r0, [r7, #8]
 8020506:	f00b fdf9 	bl	802c0fc <memset>
	accel->version = 1;
 802050a:	68bb      	ldr	r3, [r7, #8]
 802050c:	2201      	movs	r2, #1
 802050e:	601a      	str	r2, [r3, #0]
	accel->sensor_id = _sensorid_accel;
 8020510:	68fb      	ldr	r3, [r7, #12]
 8020512:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8020516:	461a      	mov	r2, r3
 8020518:	68bb      	ldr	r3, [r7, #8]
 802051a:	605a      	str	r2, [r3, #4]
	accel->type = SENSOR_TYPE_ACCELEROMETER;
 802051c:	68bb      	ldr	r3, [r7, #8]
 802051e:	2201      	movs	r2, #1
 8020520:	609a      	str	r2, [r3, #8]
	accel->timestamp = timestamp;
 8020522:	687a      	ldr	r2, [r7, #4]
 8020524:	68bb      	ldr	r3, [r7, #8]
 8020526:	611a      	str	r2, [r3, #16]

	accel->acceleration.x = accX * SENSORS_GRAVITY_EARTH;
 8020528:	68fb      	ldr	r3, [r7, #12]
 802052a:	edd3 7a05 	vldr	s15, [r3, #20]
 802052e:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 802056c <_ZN15Adafruit_ICM20X14fillAccelEventEP15sensors_event_tm+0x78>
 8020532:	ee67 7a87 	vmul.f32	s15, s15, s14
 8020536:	68bb      	ldr	r3, [r7, #8]
 8020538:	edc3 7a05 	vstr	s15, [r3, #20]
	accel->acceleration.y = accY * SENSORS_GRAVITY_EARTH;
 802053c:	68fb      	ldr	r3, [r7, #12]
 802053e:	edd3 7a06 	vldr	s15, [r3, #24]
 8020542:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 802056c <_ZN15Adafruit_ICM20X14fillAccelEventEP15sensors_event_tm+0x78>
 8020546:	ee67 7a87 	vmul.f32	s15, s15, s14
 802054a:	68bb      	ldr	r3, [r7, #8]
 802054c:	edc3 7a06 	vstr	s15, [r3, #24]
	accel->acceleration.z = accZ * SENSORS_GRAVITY_EARTH;
 8020550:	68fb      	ldr	r3, [r7, #12]
 8020552:	edd3 7a07 	vldr	s15, [r3, #28]
 8020556:	ed9f 7a05 	vldr	s14, [pc, #20]	; 802056c <_ZN15Adafruit_ICM20X14fillAccelEventEP15sensors_event_tm+0x78>
 802055a:	ee67 7a87 	vmul.f32	s15, s15, s14
 802055e:	68bb      	ldr	r3, [r7, #8]
 8020560:	edc3 7a07 	vstr	s15, [r3, #28]
}
 8020564:	bf00      	nop
 8020566:	3710      	adds	r7, #16
 8020568:	46bd      	mov	sp, r7
 802056a:	bd80      	pop	{r7, pc}
 802056c:	411ce80a 	.word	0x411ce80a

08020570 <_ZN15Adafruit_ICM20X13fillGyroEventEP15sensors_event_tm>:

void Adafruit_ICM20X::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
 8020570:	b580      	push	{r7, lr}
 8020572:	b084      	sub	sp, #16
 8020574:	af00      	add	r7, sp, #0
 8020576:	60f8      	str	r0, [r7, #12]
 8020578:	60b9      	str	r1, [r7, #8]
 802057a:	607a      	str	r2, [r7, #4]
	memset(gyro, 0, sizeof(sensors_event_t));
 802057c:	2224      	movs	r2, #36	; 0x24
 802057e:	2100      	movs	r1, #0
 8020580:	68b8      	ldr	r0, [r7, #8]
 8020582:	f00b fdbb 	bl	802c0fc <memset>
	gyro->version = 1;
 8020586:	68bb      	ldr	r3, [r7, #8]
 8020588:	2201      	movs	r2, #1
 802058a:	601a      	str	r2, [r3, #0]
	gyro->sensor_id = _sensorid_gyro;
 802058c:	68fb      	ldr	r3, [r7, #12]
 802058e:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8020592:	461a      	mov	r2, r3
 8020594:	68bb      	ldr	r3, [r7, #8]
 8020596:	605a      	str	r2, [r3, #4]
	gyro->type = SENSOR_TYPE_GYROSCOPE;
 8020598:	68bb      	ldr	r3, [r7, #8]
 802059a:	2204      	movs	r2, #4
 802059c:	609a      	str	r2, [r3, #8]
	gyro->timestamp = timestamp;
 802059e:	687a      	ldr	r2, [r7, #4]
 80205a0:	68bb      	ldr	r3, [r7, #8]
 80205a2:	611a      	str	r2, [r3, #16]
	gyro->gyro.x = gyroX * SENSORS_DPS_TO_RADS;
 80205a4:	68fb      	ldr	r3, [r7, #12]
 80205a6:	edd3 7a08 	vldr	s15, [r3, #32]
 80205aa:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 80205e8 <_ZN15Adafruit_ICM20X13fillGyroEventEP15sensors_event_tm+0x78>
 80205ae:	ee67 7a87 	vmul.f32	s15, s15, s14
 80205b2:	68bb      	ldr	r3, [r7, #8]
 80205b4:	edc3 7a05 	vstr	s15, [r3, #20]
	gyro->gyro.y = gyroY * SENSORS_DPS_TO_RADS;
 80205b8:	68fb      	ldr	r3, [r7, #12]
 80205ba:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 80205be:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 80205e8 <_ZN15Adafruit_ICM20X13fillGyroEventEP15sensors_event_tm+0x78>
 80205c2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80205c6:	68bb      	ldr	r3, [r7, #8]
 80205c8:	edc3 7a06 	vstr	s15, [r3, #24]
	gyro->gyro.z = gyroZ * SENSORS_DPS_TO_RADS;
 80205cc:	68fb      	ldr	r3, [r7, #12]
 80205ce:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 80205d2:	ed9f 7a05 	vldr	s14, [pc, #20]	; 80205e8 <_ZN15Adafruit_ICM20X13fillGyroEventEP15sensors_event_tm+0x78>
 80205d6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80205da:	68bb      	ldr	r3, [r7, #8]
 80205dc:	edc3 7a07 	vstr	s15, [r3, #28]
}
 80205e0:	bf00      	nop
 80205e2:	3710      	adds	r7, #16
 80205e4:	46bd      	mov	sp, r7
 80205e6:	bd80      	pop	{r7, pc}
 80205e8:	3c8efa35 	.word	0x3c8efa35

080205ec <_ZN15Adafruit_ICM20X12fillMagEventEP15sensors_event_tm>:

void Adafruit_ICM20X::fillMagEvent(sensors_event_t *mag, uint32_t timestamp) {
 80205ec:	b580      	push	{r7, lr}
 80205ee:	b084      	sub	sp, #16
 80205f0:	af00      	add	r7, sp, #0
 80205f2:	60f8      	str	r0, [r7, #12]
 80205f4:	60b9      	str	r1, [r7, #8]
 80205f6:	607a      	str	r2, [r7, #4]
	memset(mag, 0, sizeof(sensors_event_t));
 80205f8:	2224      	movs	r2, #36	; 0x24
 80205fa:	2100      	movs	r1, #0
 80205fc:	68b8      	ldr	r0, [r7, #8]
 80205fe:	f00b fd7d 	bl	802c0fc <memset>
	mag->version = 1;
 8020602:	68bb      	ldr	r3, [r7, #8]
 8020604:	2201      	movs	r2, #1
 8020606:	601a      	str	r2, [r3, #0]
	mag->sensor_id = _sensorid_mag;
 8020608:	68fb      	ldr	r3, [r7, #12]
 802060a:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 802060e:	461a      	mov	r2, r3
 8020610:	68bb      	ldr	r3, [r7, #8]
 8020612:	605a      	str	r2, [r3, #4]
	mag->type = SENSOR_TYPE_MAGNETIC_FIELD;
 8020614:	68bb      	ldr	r3, [r7, #8]
 8020616:	2202      	movs	r2, #2
 8020618:	609a      	str	r2, [r3, #8]
	mag->timestamp = timestamp;
 802061a:	687a      	ldr	r2, [r7, #4]
 802061c:	68bb      	ldr	r3, [r7, #8]
 802061e:	611a      	str	r2, [r3, #16]
	mag->magnetic.x = magX; // magic number!
 8020620:	68fb      	ldr	r3, [r7, #12]
 8020622:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8020624:	68bb      	ldr	r3, [r7, #8]
 8020626:	615a      	str	r2, [r3, #20]
	mag->magnetic.y = magY;
 8020628:	68fb      	ldr	r3, [r7, #12]
 802062a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802062c:	68bb      	ldr	r3, [r7, #8]
 802062e:	619a      	str	r2, [r3, #24]
	mag->magnetic.z = magZ;
 8020630:	68fb      	ldr	r3, [r7, #12]
 8020632:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8020634:	68bb      	ldr	r3, [r7, #8]
 8020636:	61da      	str	r2, [r3, #28]
}
 8020638:	bf00      	nop
 802063a:	3710      	adds	r7, #16
 802063c:	46bd      	mov	sp, r7
 802063e:	bd80      	pop	{r7, pc}

08020640 <_ZN15Adafruit_ICM20X13fillTempEventEP15sensors_event_tm>:

void Adafruit_ICM20X::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
 8020640:	b580      	push	{r7, lr}
 8020642:	b084      	sub	sp, #16
 8020644:	af00      	add	r7, sp, #0
 8020646:	60f8      	str	r0, [r7, #12]
 8020648:	60b9      	str	r1, [r7, #8]
 802064a:	607a      	str	r2, [r7, #4]

	memset(temp, 0, sizeof(sensors_event_t));
 802064c:	2224      	movs	r2, #36	; 0x24
 802064e:	2100      	movs	r1, #0
 8020650:	68b8      	ldr	r0, [r7, #8]
 8020652:	f00b fd53 	bl	802c0fc <memset>
	temp->version = sizeof(sensors_event_t);
 8020656:	68bb      	ldr	r3, [r7, #8]
 8020658:	2224      	movs	r2, #36	; 0x24
 802065a:	601a      	str	r2, [r3, #0]
	temp->sensor_id = _sensorid_temp;
 802065c:	68fb      	ldr	r3, [r7, #12]
 802065e:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 8020662:	461a      	mov	r2, r3
 8020664:	68bb      	ldr	r3, [r7, #8]
 8020666:	605a      	str	r2, [r3, #4]
	temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
 8020668:	68bb      	ldr	r3, [r7, #8]
 802066a:	220d      	movs	r2, #13
 802066c:	609a      	str	r2, [r3, #8]
	temp->timestamp = timestamp;
 802066e:	687a      	ldr	r2, [r7, #4]
 8020670:	68bb      	ldr	r3, [r7, #8]
 8020672:	611a      	str	r2, [r3, #16]
	temp->temperature = (temperature / 333.87) + 21.0;
 8020674:	68fb      	ldr	r3, [r7, #12]
 8020676:	691b      	ldr	r3, [r3, #16]
 8020678:	4618      	mov	r0, r3
 802067a:	f7e7 f9e5 	bl	8007a48 <__aeabi_f2d>
 802067e:	a30f      	add	r3, pc, #60	; (adr r3, 80206bc <_ZN15Adafruit_ICM20X13fillTempEventEP15sensors_event_tm+0x7c>)
 8020680:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020684:	f7e7 fb62 	bl	8007d4c <__aeabi_ddiv>
 8020688:	4602      	mov	r2, r0
 802068a:	460b      	mov	r3, r1
 802068c:	4610      	mov	r0, r2
 802068e:	4619      	mov	r1, r3
 8020690:	f04f 0200 	mov.w	r2, #0
 8020694:	4b08      	ldr	r3, [pc, #32]	; (80206b8 <_ZN15Adafruit_ICM20X13fillTempEventEP15sensors_event_tm+0x78>)
 8020696:	f7e7 f879 	bl	800778c <__adddf3>
 802069a:	4602      	mov	r2, r0
 802069c:	460b      	mov	r3, r1
 802069e:	4610      	mov	r0, r2
 80206a0:	4619      	mov	r1, r3
 80206a2:	f7e7 fd21 	bl	80080e8 <__aeabi_d2f>
 80206a6:	4602      	mov	r2, r0
 80206a8:	68bb      	ldr	r3, [r7, #8]
 80206aa:	615a      	str	r2, [r3, #20]
}
 80206ac:	bf00      	nop
 80206ae:	3710      	adds	r7, #16
 80206b0:	46bd      	mov	sp, r7
 80206b2:	bd80      	pop	{r7, pc}
 80206b4:	f3af 8000 	nop.w
 80206b8:	40350000 	.word	0x40350000
 80206bc:	851eb852 	.word	0x851eb852
 80206c0:	4074ddeb 	.word	0x4074ddeb

080206c4 <_ZN15Adafruit_ICM20X5_readEv>:
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_ICM20X::_read(void) {
 80206c4:	b580      	push	{r7, lr}
 80206c6:	b088      	sub	sp, #32
 80206c8:	af00      	add	r7, sp, #0
 80206ca:	6078      	str	r0, [r7, #4]

	_setBank(0);
 80206cc:	2100      	movs	r1, #0
 80206ce:	6878      	ldr	r0, [r7, #4]
 80206d0:	f000 f885 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	// reading 9 bytes of mag data to fetch the register that tells the mag we've
	// read all the data
	const uint8_t numbytes = 14 + 9; // Read Accel, gyro, temp, and 9 bytes of mag
 80206d4:	2317      	movs	r3, #23
 80206d6:	77fb      	strb	r3, [r7, #31]
//      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, ICM20X_B0_ACCEL_XOUT_H, numbytes);

	uint8_t buffer[numbytes];
//  data_reg.read(buffer, numbytes);

	readRegister(ICM20X_B0_ACCEL_XOUT_H, buffer, numbytes);
 80206d8:	f107 0208 	add.w	r2, r7, #8
 80206dc:	2317      	movs	r3, #23
 80206de:	212d      	movs	r1, #45	; 0x2d
 80206e0:	6878      	ldr	r0, [r7, #4]
 80206e2:	f000 f9b9 	bl	8020a58 <_ZN15Adafruit_ICM20X12readRegisterEtPht>

	rawAccX = buffer[0] << 8 | buffer[1];
 80206e6:	7a3b      	ldrb	r3, [r7, #8]
 80206e8:	021b      	lsls	r3, r3, #8
 80206ea:	b21a      	sxth	r2, r3
 80206ec:	7a7b      	ldrb	r3, [r7, #9]
 80206ee:	b21b      	sxth	r3, r3
 80206f0:	4313      	orrs	r3, r2
 80206f2:	b21a      	sxth	r2, r3
 80206f4:	687b      	ldr	r3, [r7, #4]
 80206f6:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
	rawAccY = buffer[2] << 8 | buffer[3];
 80206fa:	7abb      	ldrb	r3, [r7, #10]
 80206fc:	021b      	lsls	r3, r3, #8
 80206fe:	b21a      	sxth	r2, r3
 8020700:	7afb      	ldrb	r3, [r7, #11]
 8020702:	b21b      	sxth	r3, r3
 8020704:	4313      	orrs	r3, r2
 8020706:	b21a      	sxth	r2, r3
 8020708:	687b      	ldr	r3, [r7, #4]
 802070a:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
	rawAccZ = buffer[4] << 8 | buffer[5];
 802070e:	7b3b      	ldrb	r3, [r7, #12]
 8020710:	021b      	lsls	r3, r3, #8
 8020712:	b21a      	sxth	r2, r3
 8020714:	7b7b      	ldrb	r3, [r7, #13]
 8020716:	b21b      	sxth	r3, r3
 8020718:	4313      	orrs	r3, r2
 802071a:	b21a      	sxth	r2, r3
 802071c:	687b      	ldr	r3, [r7, #4]
 802071e:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c

	rawGyroX = buffer[6] << 8 | buffer[7];
 8020722:	7bbb      	ldrb	r3, [r7, #14]
 8020724:	021b      	lsls	r3, r3, #8
 8020726:	b21a      	sxth	r2, r3
 8020728:	7bfb      	ldrb	r3, [r7, #15]
 802072a:	b21b      	sxth	r3, r3
 802072c:	4313      	orrs	r3, r2
 802072e:	b21a      	sxth	r2, r3
 8020730:	687b      	ldr	r3, [r7, #4]
 8020732:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
	rawGyroY = buffer[8] << 8 | buffer[9];
 8020736:	7c3b      	ldrb	r3, [r7, #16]
 8020738:	021b      	lsls	r3, r3, #8
 802073a:	b21a      	sxth	r2, r3
 802073c:	7c7b      	ldrb	r3, [r7, #17]
 802073e:	b21b      	sxth	r3, r3
 8020740:	4313      	orrs	r3, r2
 8020742:	b21a      	sxth	r2, r3
 8020744:	687b      	ldr	r3, [r7, #4]
 8020746:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
	rawGyroZ = buffer[10] << 8 | buffer[11];
 802074a:	7cbb      	ldrb	r3, [r7, #18]
 802074c:	021b      	lsls	r3, r3, #8
 802074e:	b21a      	sxth	r2, r3
 8020750:	7cfb      	ldrb	r3, [r7, #19]
 8020752:	b21b      	sxth	r3, r3
 8020754:	4313      	orrs	r3, r2
 8020756:	b21a      	sxth	r2, r3
 8020758:	687b      	ldr	r3, [r7, #4]
 802075a:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64

	temperature = buffer[12] << 8 | buffer[13];
 802075e:	7d3b      	ldrb	r3, [r7, #20]
 8020760:	021b      	lsls	r3, r3, #8
 8020762:	7d7a      	ldrb	r2, [r7, #21]
 8020764:	4313      	orrs	r3, r2
 8020766:	ee07 3a90 	vmov	s15, r3
 802076a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802076e:	687b      	ldr	r3, [r7, #4]
 8020770:	edc3 7a04 	vstr	s15, [r3, #16]

	rawMagX = ((buffer[16] << 8) | (buffer[15] & 0xFF)); // Mag data is read little endian
 8020774:	7e3b      	ldrb	r3, [r7, #24]
 8020776:	021b      	lsls	r3, r3, #8
 8020778:	b21a      	sxth	r2, r3
 802077a:	7dfb      	ldrb	r3, [r7, #23]
 802077c:	b21b      	sxth	r3, r3
 802077e:	4313      	orrs	r3, r2
 8020780:	b21a      	sxth	r2, r3
 8020782:	687b      	ldr	r3, [r7, #4]
 8020784:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
	rawMagY = ((buffer[18] << 8) | (buffer[17] & 0xFF));
 8020788:	7ebb      	ldrb	r3, [r7, #26]
 802078a:	021b      	lsls	r3, r3, #8
 802078c:	b21a      	sxth	r2, r3
 802078e:	7e7b      	ldrb	r3, [r7, #25]
 8020790:	b21b      	sxth	r3, r3
 8020792:	4313      	orrs	r3, r2
 8020794:	b21a      	sxth	r2, r3
 8020796:	687b      	ldr	r3, [r7, #4]
 8020798:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
	rawMagZ = ((buffer[20] << 8) | (buffer[19] & 0xFF));
 802079c:	7f3b      	ldrb	r3, [r7, #28]
 802079e:	021b      	lsls	r3, r3, #8
 80207a0:	b21a      	sxth	r2, r3
 80207a2:	7efb      	ldrb	r3, [r7, #27]
 80207a4:	b21b      	sxth	r3, r3
 80207a6:	4313      	orrs	r3, r2
 80207a8:	b21a      	sxth	r2, r3
 80207aa:	687b      	ldr	r3, [r7, #4]
 80207ac:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a

	scaleValues();
 80207b0:	687b      	ldr	r3, [r7, #4]
 80207b2:	681b      	ldr	r3, [r3, #0]
 80207b4:	681b      	ldr	r3, [r3, #0]
 80207b6:	6878      	ldr	r0, [r7, #4]
 80207b8:	4798      	blx	r3
	_setBank(0);
 80207ba:	2100      	movs	r1, #0
 80207bc:	6878      	ldr	r0, [r7, #4]
 80207be:	f000 f80e 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
}
 80207c2:	bf00      	nop
 80207c4:	3720      	adds	r7, #32
 80207c6:	46bd      	mov	sp, r7
 80207c8:	bd80      	pop	{r7, pc}

080207ca <_ZN15Adafruit_ICM20X11scaleValuesEv>:
/*!
 * @brief Scales the raw variables based on the current measurement range
 *
 */
void Adafruit_ICM20X::scaleValues(void) {
 80207ca:	b480      	push	{r7}
 80207cc:	b083      	sub	sp, #12
 80207ce:	af00      	add	r7, sp, #0
 80207d0:	6078      	str	r0, [r7, #4]
}
 80207d2:	bf00      	nop
 80207d4:	370c      	adds	r7, #12
 80207d6:	46bd      	mov	sp, r7
 80207d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207dc:	4770      	bx	lr

080207de <_ZN15Adafruit_ICM20X8_setBankEh>:
/*!
 @brief Sets register bank.
 @param  bank_number
 The bank to set to active
 */
void Adafruit_ICM20X::_setBank(uint8_t bank_number) {
 80207de:	b580      	push	{r7, lr}
 80207e0:	b082      	sub	sp, #8
 80207e2:	af00      	add	r7, sp, #0
 80207e4:	6078      	str	r0, [r7, #4]
 80207e6:	460b      	mov	r3, r1
 80207e8:	70fb      	strb	r3, [r7, #3]
	writeRegisterByte(ICM20X_B0_REG_BANK_SEL, (bank_number << 4) & 0x30);
 80207ea:	78fb      	ldrb	r3, [r7, #3]
 80207ec:	011b      	lsls	r3, r3, #4
 80207ee:	b2db      	uxtb	r3, r3
 80207f0:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80207f4:	b2db      	uxtb	r3, r3
 80207f6:	461a      	mov	r2, r3
 80207f8:	217f      	movs	r1, #127	; 0x7f
 80207fa:	6878      	ldr	r0, [r7, #4]
 80207fc:	f000 fa66 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
}
 8020800:	bf00      	nop
 8020802:	3708      	adds	r7, #8
 8020804:	46bd      	mov	sp, r7
 8020806:	bd80      	pop	{r7, pc}

08020808 <_ZN15Adafruit_ICM20X15writeAccelRangeEh>:
 @brief Sets the accelerometer's measurement range.
 @param  new_accel_range
 Measurement range to be set. Must be an
 `icm20x_accel_range_t`.
 */
void Adafruit_ICM20X::writeAccelRange(uint8_t new_accel_range) {
 8020808:	b580      	push	{r7, lr}
 802080a:	b084      	sub	sp, #16
 802080c:	af02      	add	r7, sp, #8
 802080e:	6078      	str	r0, [r7, #4]
 8020810:	460b      	mov	r3, r1
 8020812:	70fb      	strb	r3, [r7, #3]
	_setBank(2);
 8020814:	2102      	movs	r1, #2
 8020816:	6878      	ldr	r0, [r7, #4]
 8020818:	f7ff ffe1 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterMultipleBit(ICM20X_B2_ACCEL_CONFIG_1, new_accel_range, 1, 2);
 802081c:	78fa      	ldrb	r2, [r7, #3]
 802081e:	2302      	movs	r3, #2
 8020820:	9300      	str	r3, [sp, #0]
 8020822:	2301      	movs	r3, #1
 8020824:	2114      	movs	r1, #20
 8020826:	6878      	ldr	r0, [r7, #4]
 8020828:	f000 faec 	bl	8020e04 <_ZN15Adafruit_ICM20X25modifyRegisterMultipleBitEthhh>
	current_accel_range = new_accel_range;
 802082c:	687b      	ldr	r3, [r7, #4]
 802082e:	78fa      	ldrb	r2, [r7, #3]
 8020830:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c

	_setBank(0);
 8020834:	2100      	movs	r1, #0
 8020836:	6878      	ldr	r0, [r7, #4]
 8020838:	f7ff ffd1 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
}
 802083c:	bf00      	nop
 802083e:	3708      	adds	r7, #8
 8020840:	46bd      	mov	sp, r7
 8020842:	bd80      	pop	{r7, pc}

08020844 <_ZN15Adafruit_ICM20X14writeGyroRangeEh>:
 @brief Sets the gyro's measurement range.
 @param  new_gyro_range
 Measurement range to be set. Must be an
 `icm20x_gyro_range_t`.
 */
void Adafruit_ICM20X::writeGyroRange(uint8_t new_gyro_range) {
 8020844:	b580      	push	{r7, lr}
 8020846:	b084      	sub	sp, #16
 8020848:	af02      	add	r7, sp, #8
 802084a:	6078      	str	r0, [r7, #4]
 802084c:	460b      	mov	r3, r1
 802084e:	70fb      	strb	r3, [r7, #3]
	_setBank(2);
 8020850:	2102      	movs	r1, #2
 8020852:	6878      	ldr	r0, [r7, #4]
 8020854:	f7ff ffc3 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterMultipleBit(ICM20X_B2_GYRO_CONFIG_1, new_gyro_range, 1, 2);
 8020858:	78fa      	ldrb	r2, [r7, #3]
 802085a:	2302      	movs	r3, #2
 802085c:	9300      	str	r3, [sp, #0]
 802085e:	2301      	movs	r3, #1
 8020860:	2101      	movs	r1, #1
 8020862:	6878      	ldr	r0, [r7, #4]
 8020864:	f000 face 	bl	8020e04 <_ZN15Adafruit_ICM20X25modifyRegisterMultipleBitEthhh>
	current_gyro_range = new_gyro_range;
 8020868:	687b      	ldr	r3, [r7, #4]
 802086a:	78fa      	ldrb	r2, [r7, #3]
 802086c:	f883 206d 	strb.w	r2, [r3, #109]	; 0x6d
	_setBank(0);
 8020870:	2100      	movs	r1, #0
 8020872:	6878      	ldr	r0, [r7, #4]
 8020874:	f7ff ffb3 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
}
 8020878:	bf00      	nop
 802087a:	3708      	adds	r7, #8
 802087c:	46bd      	mov	sp, r7
 802087e:	bd80      	pop	{r7, pc}

08020880 <_ZN15Adafruit_ICM20X19setAccelRateDivisorEt>:
 @brief Sets the accelerometer's data rate divisor.
 @param  new_accel_divisor
 The accelerometer's data rate divisor (`uint16_t`). This 12-bit
 value must be <= 4095
 */
void Adafruit_ICM20X::setAccelRateDivisor(uint16_t new_accel_divisor) {
 8020880:	b580      	push	{r7, lr}
 8020882:	b084      	sub	sp, #16
 8020884:	af00      	add	r7, sp, #0
 8020886:	6078      	str	r0, [r7, #4]
 8020888:	460b      	mov	r3, r1
 802088a:	807b      	strh	r3, [r7, #2]
	_setBank(2);
 802088c:	2102      	movs	r1, #2
 802088e:	6878      	ldr	r0, [r7, #4]
 8020890:	f7ff ffa5 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	uint8_t data[2];
	data[0] = new_accel_divisor >> 8;
 8020894:	887b      	ldrh	r3, [r7, #2]
 8020896:	121b      	asrs	r3, r3, #8
 8020898:	b2db      	uxtb	r3, r3
 802089a:	733b      	strb	r3, [r7, #12]
	data[1] = new_accel_divisor & 0xFF;
 802089c:	887b      	ldrh	r3, [r7, #2]
 802089e:	b2db      	uxtb	r3, r3
 80208a0:	737b      	strb	r3, [r7, #13]

	new_accel_divisor = new_accel_divisor & 0x07FF;
 80208a2:	887b      	ldrh	r3, [r7, #2]
 80208a4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80208a8:	807b      	strh	r3, [r7, #2]
	writeRegister(ICM20X_B2_ACCEL_SMPLRT_DIV_1, data,
 80208aa:	f107 020c 	add.w	r2, r7, #12
 80208ae:	2302      	movs	r3, #2
 80208b0:	2110      	movs	r1, #16
 80208b2:	6878      	ldr	r0, [r7, #4]
 80208b4:	f000 f9a6 	bl	8020c04 <_ZN15Adafruit_ICM20X13writeRegisterEhPht>
			2);
	_setBank(0);
 80208b8:	2100      	movs	r1, #0
 80208ba:	6878      	ldr	r0, [r7, #4]
 80208bc:	f7ff ff8f 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
}
 80208c0:	bf00      	nop
 80208c2:	3710      	adds	r7, #16
 80208c4:	46bd      	mov	sp, r7
 80208c6:	bd80      	pop	{r7, pc}

080208c8 <_ZN15Adafruit_ICM20X18setGyroRateDivisorEh>:

 @brief Sets the gyro's data rate divisor.
 @param  new_gyro_divisor
 The gyro's data rate divisor (`uint8_t`).
 */
void Adafruit_ICM20X::setGyroRateDivisor(uint8_t new_gyro_divisor) {
 80208c8:	b580      	push	{r7, lr}
 80208ca:	b082      	sub	sp, #8
 80208cc:	af00      	add	r7, sp, #0
 80208ce:	6078      	str	r0, [r7, #4]
 80208d0:	460b      	mov	r3, r1
 80208d2:	70fb      	strb	r3, [r7, #3]
	_setBank(2);
 80208d4:	2102      	movs	r1, #2
 80208d6:	6878      	ldr	r0, [r7, #4]
 80208d8:	f7ff ff81 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	writeRegisterByte(ICM20X_B2_GYRO_SMPLRT_DIV, new_gyro_divisor);
 80208dc:	78fb      	ldrb	r3, [r7, #3]
 80208de:	461a      	mov	r2, r3
 80208e0:	2100      	movs	r1, #0
 80208e2:	6878      	ldr	r0, [r7, #4]
 80208e4:	f000 f9f2 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
	_setBank(0);
 80208e8:	2100      	movs	r1, #0
 80208ea:	6878      	ldr	r0, [r7, #4]
 80208ec:	f7ff ff77 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>
}
 80208f0:	bf00      	nop
 80208f2:	3708      	adds	r7, #8
 80208f4:	46bd      	mov	sp, r7
 80208f6:	bd80      	pop	{r7, pc}

080208f8 <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t>:
 * @param cutoff_freq Signals changing at a rate higher than the given cutoff
 * frequency will be filtered out
 * @return true: success false: failure
 */
bool Adafruit_ICM20X::enableAccelDLPF(bool enable,
		icm20x_accel_cutoff_t cutoff_freq) {
 80208f8:	b580      	push	{r7, lr}
 80208fa:	b084      	sub	sp, #16
 80208fc:	af02      	add	r7, sp, #8
 80208fe:	6078      	str	r0, [r7, #4]
 8020900:	460b      	mov	r3, r1
 8020902:	70fb      	strb	r3, [r7, #3]
 8020904:	4613      	mov	r3, r2
 8020906:	70bb      	strb	r3, [r7, #2]
	_setBank(2);
 8020908:	2102      	movs	r1, #2
 802090a:	6878      	ldr	r0, [r7, #4]
 802090c:	f7ff ff67 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	if (!modifyRegisterBit(ICM20X_B2_ACCEL_CONFIG_1, enable, 0)) {
 8020910:	78fa      	ldrb	r2, [r7, #3]
 8020912:	2300      	movs	r3, #0
 8020914:	2114      	movs	r1, #20
 8020916:	6878      	ldr	r0, [r7, #4]
 8020918:	f000 fa4c 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
 802091c:	4603      	mov	r3, r0
 802091e:	f083 0301 	eor.w	r3, r3, #1
 8020922:	b2db      	uxtb	r3, r3
 8020924:	2b00      	cmp	r3, #0
 8020926:	d001      	beq.n	802092c <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x34>
		return false;
 8020928:	2300      	movs	r3, #0
 802092a:	e018      	b.n	802095e <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x66>
	}

	if (!enable) {
 802092c:	78fb      	ldrb	r3, [r7, #3]
 802092e:	f083 0301 	eor.w	r3, r3, #1
 8020932:	b2db      	uxtb	r3, r3
 8020934:	2b00      	cmp	r3, #0
 8020936:	d001      	beq.n	802093c <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x44>
		return true;
 8020938:	2301      	movs	r3, #1
 802093a:	e010      	b.n	802095e <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x66>
	}

	if (!modifyRegisterMultipleBit(ICM20X_B2_ACCEL_CONFIG_1, cutoff_freq, 3,
 802093c:	78ba      	ldrb	r2, [r7, #2]
 802093e:	2303      	movs	r3, #3
 8020940:	9300      	str	r3, [sp, #0]
 8020942:	2303      	movs	r3, #3
 8020944:	2114      	movs	r1, #20
 8020946:	6878      	ldr	r0, [r7, #4]
 8020948:	f000 fa5c 	bl	8020e04 <_ZN15Adafruit_ICM20X25modifyRegisterMultipleBitEthhh>
 802094c:	4603      	mov	r3, r0
 802094e:	f083 0301 	eor.w	r3, r3, #1
 8020952:	b2db      	uxtb	r3, r3
 8020954:	2b00      	cmp	r3, #0
 8020956:	d001      	beq.n	802095c <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x64>
			3)) {
		return false;
 8020958:	2300      	movs	r3, #0
 802095a:	e000      	b.n	802095e <_ZN15Adafruit_ICM20X15enableAccelDLPFEb21icm20x_accel_cutoff_t+0x66>
	}
	return true;
 802095c:	2301      	movs	r3, #1
}
 802095e:	4618      	mov	r0, r3
 8020960:	3708      	adds	r7, #8
 8020962:	46bd      	mov	sp, r7
 8020964:	bd80      	pop	{r7, pc}

08020966 <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t>:
 * @param cutoff_freq Signals changing at a rate higher than the given cutoff
 * frequency will be filtered out
 * @return true: success false: failure
 */
bool Adafruit_ICM20X::enableGyrolDLPF(bool enable,
		icm20x_gyro_cutoff_t cutoff_freq) {
 8020966:	b580      	push	{r7, lr}
 8020968:	b084      	sub	sp, #16
 802096a:	af02      	add	r7, sp, #8
 802096c:	6078      	str	r0, [r7, #4]
 802096e:	460b      	mov	r3, r1
 8020970:	70fb      	strb	r3, [r7, #3]
 8020972:	4613      	mov	r3, r2
 8020974:	70bb      	strb	r3, [r7, #2]
	_setBank(2);
 8020976:	2102      	movs	r1, #2
 8020978:	6878      	ldr	r0, [r7, #4]
 802097a:	f7ff ff30 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	if (!modifyRegisterBit(ICM20X_B2_ACCEL_CONFIG_1, enable, 0)) {
 802097e:	78fa      	ldrb	r2, [r7, #3]
 8020980:	2300      	movs	r3, #0
 8020982:	2114      	movs	r1, #20
 8020984:	6878      	ldr	r0, [r7, #4]
 8020986:	f000 fa15 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
 802098a:	4603      	mov	r3, r0
 802098c:	f083 0301 	eor.w	r3, r3, #1
 8020990:	b2db      	uxtb	r3, r3
 8020992:	2b00      	cmp	r3, #0
 8020994:	d001      	beq.n	802099a <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x34>
		return false;
 8020996:	2300      	movs	r3, #0
 8020998:	e018      	b.n	80209cc <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x66>
	}

	if (!enable) {
 802099a:	78fb      	ldrb	r3, [r7, #3]
 802099c:	f083 0301 	eor.w	r3, r3, #1
 80209a0:	b2db      	uxtb	r3, r3
 80209a2:	2b00      	cmp	r3, #0
 80209a4:	d001      	beq.n	80209aa <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x44>
		return true;
 80209a6:	2301      	movs	r3, #1
 80209a8:	e010      	b.n	80209cc <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x66>
	}

	if (!modifyRegisterMultipleBit(ICM20X_B2_ACCEL_CONFIG_1, cutoff_freq, 3,
 80209aa:	78ba      	ldrb	r2, [r7, #2]
 80209ac:	2303      	movs	r3, #3
 80209ae:	9300      	str	r3, [sp, #0]
 80209b0:	2303      	movs	r3, #3
 80209b2:	2114      	movs	r1, #20
 80209b4:	6878      	ldr	r0, [r7, #4]
 80209b6:	f000 fa25 	bl	8020e04 <_ZN15Adafruit_ICM20X25modifyRegisterMultipleBitEthhh>
 80209ba:	4603      	mov	r3, r0
 80209bc:	f083 0301 	eor.w	r3, r3, #1
 80209c0:	b2db      	uxtb	r3, r3
 80209c2:	2b00      	cmp	r3, #0
 80209c4:	d001      	beq.n	80209ca <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x64>
			3)) {
		return false;
 80209c6:	2300      	movs	r3, #0
 80209c8:	e000      	b.n	80209cc <_ZN15Adafruit_ICM20X15enableGyrolDLPFEb20icm20x_gyro_cutoff_t+0x66>
	}
	return true;
 80209ca:	2301      	movs	r3, #1
}
 80209cc:	4618      	mov	r0, r3
 80209ce:	3708      	adds	r7, #8
 80209d0:	46bd      	mov	sp, r7
 80209d2:	bd80      	pop	{r7, pc}

080209d4 <_ZN15Adafruit_ICM20X16setInt1ActiveLowEb>:
 * @brief Sets the polarity of the int1 pin
 *
 * @param active_low Set to true to make INT1 active low, false to make it
 * active high
 */
void Adafruit_ICM20X::setInt1ActiveLow(bool active_low) {
 80209d4:	b580      	push	{r7, lr}
 80209d6:	b082      	sub	sp, #8
 80209d8:	af00      	add	r7, sp, #0
 80209da:	6078      	str	r0, [r7, #4]
 80209dc:	460b      	mov	r3, r1
 80209de:	70fb      	strb	r3, [r7, #3]

	_setBank(0);
 80209e0:	2100      	movs	r1, #0
 80209e2:	6878      	ldr	r0, [r7, #4]
 80209e4:	f7ff fefb 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterBit(ICM20X_B0_REG_INT_PIN_CFG, true, 6); //open drain
 80209e8:	2306      	movs	r3, #6
 80209ea:	2201      	movs	r2, #1
 80209ec:	210f      	movs	r1, #15
 80209ee:	6878      	ldr	r0, [r7, #4]
 80209f0:	f000 f9e0 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
	modifyRegisterBit(ICM20X_B0_REG_INT_PIN_CFG, active_low, 7); //active low
 80209f4:	78fa      	ldrb	r2, [r7, #3]
 80209f6:	2307      	movs	r3, #7
 80209f8:	210f      	movs	r1, #15
 80209fa:	6878      	ldr	r0, [r7, #4]
 80209fc:	f000 f9da 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
}
 8020a00:	bf00      	nop
 8020a02:	3708      	adds	r7, #8
 8020a04:	46bd      	mov	sp, r7
 8020a06:	bd80      	pop	{r7, pc}

08020a08 <_ZN15Adafruit_ICM20X12setInt1LatchEb>:
 * @brief Sets the latch logic
 *
 * @param active_low Set to true to make INT1 active low, false to make it
 * active high
 */
void Adafruit_ICM20X::setInt1Latch(bool latch) {
 8020a08:	b580      	push	{r7, lr}
 8020a0a:	b082      	sub	sp, #8
 8020a0c:	af00      	add	r7, sp, #0
 8020a0e:	6078      	str	r0, [r7, #4]
 8020a10:	460b      	mov	r3, r1
 8020a12:	70fb      	strb	r3, [r7, #3]

	_setBank(0);
 8020a14:	2100      	movs	r1, #0
 8020a16:	6878      	ldr	r0, [r7, #4]
 8020a18:	f7ff fee1 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterBit(ICM20X_B0_REG_INT_PIN_CFG, latch, 5); //active low
 8020a1c:	78fa      	ldrb	r2, [r7, #3]
 8020a1e:	2305      	movs	r3, #5
 8020a20:	210f      	movs	r1, #15
 8020a22:	6878      	ldr	r0, [r7, #4]
 8020a24:	f000 f9c6 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
}
 8020a28:	bf00      	nop
 8020a2a:	3708      	adds	r7, #8
 8020a2c:	46bd      	mov	sp, r7
 8020a2e:	bd80      	pop	{r7, pc}

08020a30 <_ZN15Adafruit_ICM20X14clearIntOnReadEb>:


void Adafruit_ICM20X::clearIntOnRead(bool enable) {
 8020a30:	b580      	push	{r7, lr}
 8020a32:	b082      	sub	sp, #8
 8020a34:	af00      	add	r7, sp, #0
 8020a36:	6078      	str	r0, [r7, #4]
 8020a38:	460b      	mov	r3, r1
 8020a3a:	70fb      	strb	r3, [r7, #3]

	_setBank(0);
 8020a3c:	2100      	movs	r1, #0
 8020a3e:	6878      	ldr	r0, [r7, #4]
 8020a40:	f7ff fecd 	bl	80207de <_ZN15Adafruit_ICM20X8_setBankEh>

	modifyRegisterBit(ICM20X_B0_REG_INT_PIN_CFG, enable, 4); //active low
 8020a44:	78fa      	ldrb	r2, [r7, #3]
 8020a46:	2304      	movs	r3, #4
 8020a48:	210f      	movs	r1, #15
 8020a4a:	6878      	ldr	r0, [r7, #4]
 8020a4c:	f000 f9b2 	bl	8020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>
}
 8020a50:	bf00      	nop
 8020a52:	3708      	adds	r7, #8
 8020a54:	46bd      	mov	sp, r7
 8020a56:	bd80      	pop	{r7, pc}

08020a58 <_ZN15Adafruit_ICM20X12readRegisterEtPht>:
	}
}


bool Adafruit_ICM20X::readRegister(uint16_t mem_addr, uint8_t *dest,
		uint16_t size) {
 8020a58:	b5b0      	push	{r4, r5, r7, lr}
 8020a5a:	b08a      	sub	sp, #40	; 0x28
 8020a5c:	af02      	add	r7, sp, #8
 8020a5e:	60f8      	str	r0, [r7, #12]
 8020a60:	607a      	str	r2, [r7, #4]
 8020a62:	461a      	mov	r2, r3
 8020a64:	460b      	mov	r3, r1
 8020a66:	817b      	strh	r3, [r7, #10]
 8020a68:	4613      	mov	r3, r2
 8020a6a:	813b      	strh	r3, [r7, #8]
		memcpy(dest, &rx_data[1], size);
		return true;
	} else {
		cs_active(false);
		return false;
	}
 8020a6c:	466b      	mov	r3, sp
 8020a6e:	461d      	mov	r5, r3
	uint8_t tx_data[size + 1] = {0};
 8020a70:	893c      	ldrh	r4, [r7, #8]
 8020a72:	61fc      	str	r4, [r7, #28]
 8020a74:	4623      	mov	r3, r4
 8020a76:	3301      	adds	r3, #1
 8020a78:	4618      	mov	r0, r3
 8020a7a:	f04f 0100 	mov.w	r1, #0
 8020a7e:	f04f 0200 	mov.w	r2, #0
 8020a82:	f04f 0300 	mov.w	r3, #0
 8020a86:	00cb      	lsls	r3, r1, #3
 8020a88:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020a8c:	00c2      	lsls	r2, r0, #3
 8020a8e:	4623      	mov	r3, r4
 8020a90:	3301      	adds	r3, #1
 8020a92:	4618      	mov	r0, r3
 8020a94:	f04f 0100 	mov.w	r1, #0
 8020a98:	f04f 0200 	mov.w	r2, #0
 8020a9c:	f04f 0300 	mov.w	r3, #0
 8020aa0:	00cb      	lsls	r3, r1, #3
 8020aa2:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020aa6:	00c2      	lsls	r2, r0, #3
 8020aa8:	4623      	mov	r3, r4
 8020aaa:	3301      	adds	r3, #1
 8020aac:	3307      	adds	r3, #7
 8020aae:	08db      	lsrs	r3, r3, #3
 8020ab0:	00db      	lsls	r3, r3, #3
 8020ab2:	ebad 0d03 	sub.w	sp, sp, r3
 8020ab6:	ab02      	add	r3, sp, #8
 8020ab8:	3300      	adds	r3, #0
 8020aba:	61bb      	str	r3, [r7, #24]
 8020abc:	69bb      	ldr	r3, [r7, #24]
 8020abe:	2200      	movs	r2, #0
 8020ac0:	701a      	strb	r2, [r3, #0]
 8020ac2:	1c5a      	adds	r2, r3, #1
 8020ac4:	1e63      	subs	r3, r4, #1
 8020ac6:	2b00      	cmp	r3, #0
 8020ac8:	db04      	blt.n	8020ad4 <_ZN15Adafruit_ICM20X12readRegisterEtPht+0x7c>
 8020aca:	2100      	movs	r1, #0
 8020acc:	7011      	strb	r1, [r2, #0]
 8020ace:	3201      	adds	r2, #1
 8020ad0:	3b01      	subs	r3, #1
 8020ad2:	e7f8      	b.n	8020ac6 <_ZN15Adafruit_ICM20X12readRegisterEtPht+0x6e>
	uint8_t rx_data[size + 1] = {0};
 8020ad4:	893c      	ldrh	r4, [r7, #8]
 8020ad6:	617c      	str	r4, [r7, #20]
 8020ad8:	4623      	mov	r3, r4
 8020ada:	3301      	adds	r3, #1
 8020adc:	4618      	mov	r0, r3
 8020ade:	f04f 0100 	mov.w	r1, #0
 8020ae2:	f04f 0200 	mov.w	r2, #0
 8020ae6:	f04f 0300 	mov.w	r3, #0
 8020aea:	00cb      	lsls	r3, r1, #3
 8020aec:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020af0:	00c2      	lsls	r2, r0, #3
 8020af2:	4623      	mov	r3, r4
 8020af4:	3301      	adds	r3, #1
 8020af6:	4618      	mov	r0, r3
 8020af8:	f04f 0100 	mov.w	r1, #0
 8020afc:	f04f 0200 	mov.w	r2, #0
 8020b00:	f04f 0300 	mov.w	r3, #0
 8020b04:	00cb      	lsls	r3, r1, #3
 8020b06:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020b0a:	00c2      	lsls	r2, r0, #3
 8020b0c:	4623      	mov	r3, r4
 8020b0e:	3301      	adds	r3, #1
 8020b10:	3307      	adds	r3, #7
 8020b12:	08db      	lsrs	r3, r3, #3
 8020b14:	00db      	lsls	r3, r3, #3
 8020b16:	ebad 0d03 	sub.w	sp, sp, r3
 8020b1a:	ab02      	add	r3, sp, #8
 8020b1c:	3300      	adds	r3, #0
 8020b1e:	613b      	str	r3, [r7, #16]
 8020b20:	693b      	ldr	r3, [r7, #16]
 8020b22:	2200      	movs	r2, #0
 8020b24:	701a      	strb	r2, [r3, #0]
 8020b26:	1c5a      	adds	r2, r3, #1
 8020b28:	1e63      	subs	r3, r4, #1
 8020b2a:	2b00      	cmp	r3, #0
 8020b2c:	db04      	blt.n	8020b38 <_ZN15Adafruit_ICM20X12readRegisterEtPht+0xe0>
 8020b2e:	2100      	movs	r1, #0
 8020b30:	7011      	strb	r1, [r2, #0]
 8020b32:	3201      	adds	r2, #1
 8020b34:	3b01      	subs	r3, #1
 8020b36:	e7f8      	b.n	8020b2a <_ZN15Adafruit_ICM20X12readRegisterEtPht+0xd2>
	tx_data[0] = (mem_addr & 0x7F) | 0x80;
 8020b38:	897b      	ldrh	r3, [r7, #10]
 8020b3a:	b2db      	uxtb	r3, r3
 8020b3c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8020b40:	b2da      	uxtb	r2, r3
 8020b42:	69bb      	ldr	r3, [r7, #24]
 8020b44:	701a      	strb	r2, [r3, #0]
	cs_active(true);
 8020b46:	2101      	movs	r1, #1
 8020b48:	68f8      	ldr	r0, [r7, #12]
 8020b4a:	f7ff fbb2 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
			== HAL_SPI_TransmitReceive(spi_han, tx_data, rx_data, size + 1,
 8020b4e:	68fb      	ldr	r3, [r7, #12]
 8020b50:	6858      	ldr	r0, [r3, #4]
 8020b52:	69b9      	ldr	r1, [r7, #24]
 8020b54:	693a      	ldr	r2, [r7, #16]
 8020b56:	893b      	ldrh	r3, [r7, #8]
 8020b58:	3301      	adds	r3, #1
 8020b5a:	b29b      	uxth	r3, r3
 8020b5c:	2464      	movs	r4, #100	; 0x64
 8020b5e:	9400      	str	r4, [sp, #0]
 8020b60:	f7f3 fe71 	bl	8014846 <HAL_SPI_TransmitReceive>
 8020b64:	4603      	mov	r3, r0
 8020b66:	2b00      	cmp	r3, #0
 8020b68:	bf0c      	ite	eq
 8020b6a:	2301      	moveq	r3, #1
 8020b6c:	2300      	movne	r3, #0
 8020b6e:	b2db      	uxtb	r3, r3
	if (HAL_OK
 8020b70:	2b00      	cmp	r3, #0
 8020b72:	d00c      	beq.n	8020b8e <_ZN15Adafruit_ICM20X12readRegisterEtPht+0x136>
		cs_active(false);
 8020b74:	2100      	movs	r1, #0
 8020b76:	68f8      	ldr	r0, [r7, #12]
 8020b78:	f7ff fb9b 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		memcpy(dest, &rx_data[1], size);
 8020b7c:	693b      	ldr	r3, [r7, #16]
 8020b7e:	3301      	adds	r3, #1
 8020b80:	893a      	ldrh	r2, [r7, #8]
 8020b82:	4619      	mov	r1, r3
 8020b84:	6878      	ldr	r0, [r7, #4]
 8020b86:	f00b faab 	bl	802c0e0 <memcpy>
		return true;
 8020b8a:	2301      	movs	r3, #1
 8020b8c:	e004      	b.n	8020b98 <_ZN15Adafruit_ICM20X12readRegisterEtPht+0x140>
		cs_active(false);
 8020b8e:	2100      	movs	r1, #0
 8020b90:	68f8      	ldr	r0, [r7, #12]
 8020b92:	f7ff fb8e 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return false;
 8020b96:	2300      	movs	r3, #0
 8020b98:	46ad      	mov	sp, r5
}
 8020b9a:	4618      	mov	r0, r3
 8020b9c:	3720      	adds	r7, #32
 8020b9e:	46bd      	mov	sp, r7
 8020ba0:	bdb0      	pop	{r4, r5, r7, pc}

08020ba2 <_ZN15Adafruit_ICM20X16readRegisterByteEt>:

uint8_t Adafruit_ICM20X::readRegisterByte(uint16_t mem_addr) {
 8020ba2:	b580      	push	{r7, lr}
 8020ba4:	b086      	sub	sp, #24
 8020ba6:	af02      	add	r7, sp, #8
 8020ba8:	6078      	str	r0, [r7, #4]
 8020baa:	460b      	mov	r3, r1
 8020bac:	807b      	strh	r3, [r7, #2]
	uint8_t tx_data[2];
	uint8_t rx_data[2];
	tx_data[0] = (mem_addr & 0x7F) | 0x80;
 8020bae:	887b      	ldrh	r3, [r7, #2]
 8020bb0:	b2db      	uxtb	r3, r3
 8020bb2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8020bb6:	b2db      	uxtb	r3, r3
 8020bb8:	733b      	strb	r3, [r7, #12]
	tx_data[1] = 0;
 8020bba:	2300      	movs	r3, #0
 8020bbc:	737b      	strb	r3, [r7, #13]

	HAL_StatusTypeDef test;
	cs_active(true);
 8020bbe:	2101      	movs	r1, #1
 8020bc0:	6878      	ldr	r0, [r7, #4]
 8020bc2:	f7ff fb76 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>

	test = HAL_SPI_TransmitReceive(spi_han, tx_data, rx_data, 2, 100);
 8020bc6:	687b      	ldr	r3, [r7, #4]
 8020bc8:	6858      	ldr	r0, [r3, #4]
 8020bca:	f107 0208 	add.w	r2, r7, #8
 8020bce:	f107 010c 	add.w	r1, r7, #12
 8020bd2:	2364      	movs	r3, #100	; 0x64
 8020bd4:	9300      	str	r3, [sp, #0]
 8020bd6:	2302      	movs	r3, #2
 8020bd8:	f7f3 fe35 	bl	8014846 <HAL_SPI_TransmitReceive>
 8020bdc:	4603      	mov	r3, r0
 8020bde:	73fb      	strb	r3, [r7, #15]

	if (HAL_OK == test) {
 8020be0:	7bfb      	ldrb	r3, [r7, #15]
 8020be2:	2b00      	cmp	r3, #0
 8020be4:	d105      	bne.n	8020bf2 <_ZN15Adafruit_ICM20X16readRegisterByteEt+0x50>
		cs_active(false);
 8020be6:	2100      	movs	r1, #0
 8020be8:	6878      	ldr	r0, [r7, #4]
 8020bea:	f7ff fb62 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return rx_data[1];
 8020bee:	7a7b      	ldrb	r3, [r7, #9]
 8020bf0:	e004      	b.n	8020bfc <_ZN15Adafruit_ICM20X16readRegisterByteEt+0x5a>
	} else {
		cs_active(false);
 8020bf2:	2100      	movs	r1, #0
 8020bf4:	6878      	ldr	r0, [r7, #4]
 8020bf6:	f7ff fb5c 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return 0;
 8020bfa:	2300      	movs	r3, #0
	}
}
 8020bfc:	4618      	mov	r0, r3
 8020bfe:	3710      	adds	r7, #16
 8020c00:	46bd      	mov	sp, r7
 8020c02:	bd80      	pop	{r7, pc}

08020c04 <_ZN15Adafruit_ICM20X13writeRegisterEhPht>:

bool Adafruit_ICM20X::writeRegister(uint8_t mem_addr, uint8_t *val,
		uint16_t size) {
 8020c04:	b5b0      	push	{r4, r5, r7, lr}
 8020c06:	b086      	sub	sp, #24
 8020c08:	af00      	add	r7, sp, #0
 8020c0a:	60f8      	str	r0, [r7, #12]
 8020c0c:	607a      	str	r2, [r7, #4]
 8020c0e:	461a      	mov	r2, r3
 8020c10:	460b      	mov	r3, r1
 8020c12:	72fb      	strb	r3, [r7, #11]
 8020c14:	4613      	mov	r3, r2
 8020c16:	813b      	strh	r3, [r7, #8]
		cs_active(false);
		return true;
	} else {
		cs_active(false);
		return false;
	}
 8020c18:	466b      	mov	r3, sp
 8020c1a:	461d      	mov	r5, r3
	uint8_t data[1 + size];
 8020c1c:	893c      	ldrh	r4, [r7, #8]
 8020c1e:	617c      	str	r4, [r7, #20]
 8020c20:	4623      	mov	r3, r4
 8020c22:	3301      	adds	r3, #1
 8020c24:	4618      	mov	r0, r3
 8020c26:	f04f 0100 	mov.w	r1, #0
 8020c2a:	f04f 0200 	mov.w	r2, #0
 8020c2e:	f04f 0300 	mov.w	r3, #0
 8020c32:	00cb      	lsls	r3, r1, #3
 8020c34:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020c38:	00c2      	lsls	r2, r0, #3
 8020c3a:	4623      	mov	r3, r4
 8020c3c:	3301      	adds	r3, #1
 8020c3e:	4618      	mov	r0, r3
 8020c40:	f04f 0100 	mov.w	r1, #0
 8020c44:	f04f 0200 	mov.w	r2, #0
 8020c48:	f04f 0300 	mov.w	r3, #0
 8020c4c:	00cb      	lsls	r3, r1, #3
 8020c4e:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8020c52:	00c2      	lsls	r2, r0, #3
 8020c54:	4623      	mov	r3, r4
 8020c56:	3301      	adds	r3, #1
 8020c58:	3307      	adds	r3, #7
 8020c5a:	08db      	lsrs	r3, r3, #3
 8020c5c:	00db      	lsls	r3, r3, #3
 8020c5e:	ebad 0d03 	sub.w	sp, sp, r3
 8020c62:	466b      	mov	r3, sp
 8020c64:	3300      	adds	r3, #0
 8020c66:	613b      	str	r3, [r7, #16]
	data[0] = (mem_addr & 0x7F) | 0x00;
 8020c68:	7afb      	ldrb	r3, [r7, #11]
 8020c6a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020c6e:	b2da      	uxtb	r2, r3
 8020c70:	693b      	ldr	r3, [r7, #16]
 8020c72:	701a      	strb	r2, [r3, #0]
	memcpy(&data[1], val, size);
 8020c74:	693b      	ldr	r3, [r7, #16]
 8020c76:	3301      	adds	r3, #1
 8020c78:	893a      	ldrh	r2, [r7, #8]
 8020c7a:	6879      	ldr	r1, [r7, #4]
 8020c7c:	4618      	mov	r0, r3
 8020c7e:	f00b fa2f 	bl	802c0e0 <memcpy>
	cs_active(true);
 8020c82:	2101      	movs	r1, #1
 8020c84:	68f8      	ldr	r0, [r7, #12]
 8020c86:	f7ff fb14 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
	if (HAL_OK == HAL_SPI_Transmit(spi_han, data, 1 + size, 10)) {
 8020c8a:	68fb      	ldr	r3, [r7, #12]
 8020c8c:	6858      	ldr	r0, [r3, #4]
 8020c8e:	6939      	ldr	r1, [r7, #16]
 8020c90:	893b      	ldrh	r3, [r7, #8]
 8020c92:	3301      	adds	r3, #1
 8020c94:	b29a      	uxth	r2, r3
 8020c96:	230a      	movs	r3, #10
 8020c98:	f7f3 fb37 	bl	801430a <HAL_SPI_Transmit>
 8020c9c:	4603      	mov	r3, r0
 8020c9e:	2b00      	cmp	r3, #0
 8020ca0:	bf0c      	ite	eq
 8020ca2:	2301      	moveq	r3, #1
 8020ca4:	2300      	movne	r3, #0
 8020ca6:	b2db      	uxtb	r3, r3
 8020ca8:	2b00      	cmp	r3, #0
 8020caa:	d005      	beq.n	8020cb8 <_ZN15Adafruit_ICM20X13writeRegisterEhPht+0xb4>
		cs_active(false);
 8020cac:	2100      	movs	r1, #0
 8020cae:	68f8      	ldr	r0, [r7, #12]
 8020cb0:	f7ff faff 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return true;
 8020cb4:	2301      	movs	r3, #1
 8020cb6:	e004      	b.n	8020cc2 <_ZN15Adafruit_ICM20X13writeRegisterEhPht+0xbe>
		cs_active(false);
 8020cb8:	2100      	movs	r1, #0
 8020cba:	68f8      	ldr	r0, [r7, #12]
 8020cbc:	f7ff faf9 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return false;
 8020cc0:	2300      	movs	r3, #0
 8020cc2:	46ad      	mov	sp, r5
}
 8020cc4:	4618      	mov	r0, r3
 8020cc6:	3718      	adds	r7, #24
 8020cc8:	46bd      	mov	sp, r7
 8020cca:	bdb0      	pop	{r4, r5, r7, pc}

08020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>:

bool Adafruit_ICM20X::writeRegisterByte(uint8_t mem_addr, uint8_t val) {
 8020ccc:	b580      	push	{r7, lr}
 8020cce:	b084      	sub	sp, #16
 8020cd0:	af00      	add	r7, sp, #0
 8020cd2:	6078      	str	r0, [r7, #4]
 8020cd4:	460b      	mov	r3, r1
 8020cd6:	70fb      	strb	r3, [r7, #3]
 8020cd8:	4613      	mov	r3, r2
 8020cda:	70bb      	strb	r3, [r7, #2]
	uint8_t data[2];
	data[0] = (mem_addr & 0x7F) | 0x00;
 8020cdc:	78fb      	ldrb	r3, [r7, #3]
 8020cde:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020ce2:	b2db      	uxtb	r3, r3
 8020ce4:	733b      	strb	r3, [r7, #12]
	data[1] = val;
 8020ce6:	78bb      	ldrb	r3, [r7, #2]
 8020ce8:	737b      	strb	r3, [r7, #13]

	cs_active(true);
 8020cea:	2101      	movs	r1, #1
 8020cec:	6878      	ldr	r0, [r7, #4]
 8020cee:	f7ff fae0 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
	if (HAL_OK == HAL_SPI_Transmit(spi_han, data, 2, 10)) {
 8020cf2:	687b      	ldr	r3, [r7, #4]
 8020cf4:	6858      	ldr	r0, [r3, #4]
 8020cf6:	f107 010c 	add.w	r1, r7, #12
 8020cfa:	230a      	movs	r3, #10
 8020cfc:	2202      	movs	r2, #2
 8020cfe:	f7f3 fb04 	bl	801430a <HAL_SPI_Transmit>
 8020d02:	4603      	mov	r3, r0
 8020d04:	2b00      	cmp	r3, #0
 8020d06:	bf0c      	ite	eq
 8020d08:	2301      	moveq	r3, #1
 8020d0a:	2300      	movne	r3, #0
 8020d0c:	b2db      	uxtb	r3, r3
 8020d0e:	2b00      	cmp	r3, #0
 8020d10:	d005      	beq.n	8020d1e <_ZN15Adafruit_ICM20X17writeRegisterByteEhh+0x52>
		cs_active(false);
 8020d12:	2100      	movs	r1, #0
 8020d14:	6878      	ldr	r0, [r7, #4]
 8020d16:	f7ff facc 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return true;
 8020d1a:	2301      	movs	r3, #1
 8020d1c:	e004      	b.n	8020d28 <_ZN15Adafruit_ICM20X17writeRegisterByteEhh+0x5c>
	} else {
		cs_active(false);
 8020d1e:	2100      	movs	r1, #0
 8020d20:	6878      	ldr	r0, [r7, #4]
 8020d22:	f7ff fac6 	bl	80202b2 <_ZN15Adafruit_ICM20X9cs_activeEb>
		return false;
 8020d26:	2300      	movs	r3, #0
	}
}
 8020d28:	4618      	mov	r0, r3
 8020d2a:	3710      	adds	r7, #16
 8020d2c:	46bd      	mov	sp, r7
 8020d2e:	bd80      	pop	{r7, pc}

08020d30 <_ZN15Adafruit_ICM20X15modifyBitInByteEhhh>:

uint8_t Adafruit_ICM20X::modifyBitInByte(uint8_t var, uint8_t value,
		uint8_t pos) {
 8020d30:	b480      	push	{r7}
 8020d32:	b085      	sub	sp, #20
 8020d34:	af00      	add	r7, sp, #0
 8020d36:	6078      	str	r0, [r7, #4]
 8020d38:	4608      	mov	r0, r1
 8020d3a:	4611      	mov	r1, r2
 8020d3c:	461a      	mov	r2, r3
 8020d3e:	4603      	mov	r3, r0
 8020d40:	70fb      	strb	r3, [r7, #3]
 8020d42:	460b      	mov	r3, r1
 8020d44:	70bb      	strb	r3, [r7, #2]
 8020d46:	4613      	mov	r3, r2
 8020d48:	707b      	strb	r3, [r7, #1]
	uint8_t mask = 1 << pos;
 8020d4a:	787b      	ldrb	r3, [r7, #1]
 8020d4c:	2201      	movs	r2, #1
 8020d4e:	fa02 f303 	lsl.w	r3, r2, r3
 8020d52:	73fb      	strb	r3, [r7, #15]
	return ((var & ~mask) | (value << pos));
 8020d54:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8020d58:	43db      	mvns	r3, r3
 8020d5a:	b25a      	sxtb	r2, r3
 8020d5c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8020d60:	4013      	ands	r3, r2
 8020d62:	b25a      	sxtb	r2, r3
 8020d64:	78b9      	ldrb	r1, [r7, #2]
 8020d66:	787b      	ldrb	r3, [r7, #1]
 8020d68:	fa01 f303 	lsl.w	r3, r1, r3
 8020d6c:	b25b      	sxtb	r3, r3
 8020d6e:	4313      	orrs	r3, r2
 8020d70:	b25b      	sxtb	r3, r3
 8020d72:	b2db      	uxtb	r3, r3
}
 8020d74:	4618      	mov	r0, r3
 8020d76:	3714      	adds	r7, #20
 8020d78:	46bd      	mov	sp, r7
 8020d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d7e:	4770      	bx	lr

08020d80 <_ZN15Adafruit_ICM20X16checkRegisterBitEth>:
//	uint8_t data;
//	HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, &data, 1, 10);
//	return data;
//}

uint8_t Adafruit_ICM20X::checkRegisterBit(uint16_t reg, uint8_t pos) {
 8020d80:	b580      	push	{r7, lr}
 8020d82:	b082      	sub	sp, #8
 8020d84:	af00      	add	r7, sp, #0
 8020d86:	6078      	str	r0, [r7, #4]
 8020d88:	460b      	mov	r3, r1
 8020d8a:	807b      	strh	r3, [r7, #2]
 8020d8c:	4613      	mov	r3, r2
 8020d8e:	707b      	strb	r3, [r7, #1]
	return (uint8_t) ((readRegisterByte(reg) >> pos) & 0x01);
 8020d90:	887b      	ldrh	r3, [r7, #2]
 8020d92:	4619      	mov	r1, r3
 8020d94:	6878      	ldr	r0, [r7, #4]
 8020d96:	f7ff ff04 	bl	8020ba2 <_ZN15Adafruit_ICM20X16readRegisterByteEt>
 8020d9a:	4603      	mov	r3, r0
 8020d9c:	461a      	mov	r2, r3
 8020d9e:	787b      	ldrb	r3, [r7, #1]
 8020da0:	fa42 f303 	asr.w	r3, r2, r3
 8020da4:	b2db      	uxtb	r3, r3
 8020da6:	f003 0301 	and.w	r3, r3, #1
 8020daa:	b2db      	uxtb	r3, r3
}
 8020dac:	4618      	mov	r0, r3
 8020dae:	3708      	adds	r7, #8
 8020db0:	46bd      	mov	sp, r7
 8020db2:	bd80      	pop	{r7, pc}

08020db4 <_ZN15Adafruit_ICM20X17modifyRegisterBitEtbh>:

bool Adafruit_ICM20X::modifyRegisterBit(uint16_t reg, bool value, uint8_t pos) {
 8020db4:	b580      	push	{r7, lr}
 8020db6:	b084      	sub	sp, #16
 8020db8:	af00      	add	r7, sp, #0
 8020dba:	6078      	str	r0, [r7, #4]
 8020dbc:	4608      	mov	r0, r1
 8020dbe:	4611      	mov	r1, r2
 8020dc0:	461a      	mov	r2, r3
 8020dc2:	4603      	mov	r3, r0
 8020dc4:	807b      	strh	r3, [r7, #2]
 8020dc6:	460b      	mov	r3, r1
 8020dc8:	707b      	strb	r3, [r7, #1]
 8020dca:	4613      	mov	r3, r2
 8020dcc:	703b      	strb	r3, [r7, #0]
	uint8_t register_value = readRegisterByte(reg);
 8020dce:	887b      	ldrh	r3, [r7, #2]
 8020dd0:	4619      	mov	r1, r3
 8020dd2:	6878      	ldr	r0, [r7, #4]
 8020dd4:	f7ff fee5 	bl	8020ba2 <_ZN15Adafruit_ICM20X16readRegisterByteEt>
 8020dd8:	4603      	mov	r3, r0
 8020dda:	73fb      	strb	r3, [r7, #15]
	register_value = modifyBitInByte(register_value, (uint8_t) value, pos);
 8020ddc:	787a      	ldrb	r2, [r7, #1]
 8020dde:	783b      	ldrb	r3, [r7, #0]
 8020de0:	7bf9      	ldrb	r1, [r7, #15]
 8020de2:	6878      	ldr	r0, [r7, #4]
 8020de4:	f7ff ffa4 	bl	8020d30 <_ZN15Adafruit_ICM20X15modifyBitInByteEhhh>
 8020de8:	4603      	mov	r3, r0
 8020dea:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(reg, register_value);
 8020dec:	887b      	ldrh	r3, [r7, #2]
 8020dee:	b2db      	uxtb	r3, r3
 8020df0:	7bfa      	ldrb	r2, [r7, #15]
 8020df2:	4619      	mov	r1, r3
 8020df4:	6878      	ldr	r0, [r7, #4]
 8020df6:	f7ff ff69 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
 8020dfa:	4603      	mov	r3, r0
}
 8020dfc:	4618      	mov	r0, r3
 8020dfe:	3710      	adds	r7, #16
 8020e00:	46bd      	mov	sp, r7
 8020e02:	bd80      	pop	{r7, pc}

08020e04 <_ZN15Adafruit_ICM20X25modifyRegisterMultipleBitEthhh>:

bool Adafruit_ICM20X::modifyRegisterMultipleBit(uint16_t reg, uint8_t value,
		uint8_t pos, uint8_t bits) {
 8020e04:	b580      	push	{r7, lr}
 8020e06:	b084      	sub	sp, #16
 8020e08:	af00      	add	r7, sp, #0
 8020e0a:	6078      	str	r0, [r7, #4]
 8020e0c:	4608      	mov	r0, r1
 8020e0e:	4611      	mov	r1, r2
 8020e10:	461a      	mov	r2, r3
 8020e12:	4603      	mov	r3, r0
 8020e14:	807b      	strh	r3, [r7, #2]
 8020e16:	460b      	mov	r3, r1
 8020e18:	707b      	strb	r3, [r7, #1]
 8020e1a:	4613      	mov	r3, r2
 8020e1c:	703b      	strb	r3, [r7, #0]

	uint8_t register_value = readRegisterByte(reg);
 8020e1e:	887b      	ldrh	r3, [r7, #2]
 8020e20:	4619      	mov	r1, r3
 8020e22:	6878      	ldr	r0, [r7, #4]
 8020e24:	f7ff febd 	bl	8020ba2 <_ZN15Adafruit_ICM20X16readRegisterByteEt>
 8020e28:	4603      	mov	r3, r0
 8020e2a:	73fb      	strb	r3, [r7, #15]

	uint8_t mask = (1 << (bits)) - 1;
 8020e2c:	7e3b      	ldrb	r3, [r7, #24]
 8020e2e:	2201      	movs	r2, #1
 8020e30:	fa02 f303 	lsl.w	r3, r2, r3
 8020e34:	b2db      	uxtb	r3, r3
 8020e36:	3b01      	subs	r3, #1
 8020e38:	73bb      	strb	r3, [r7, #14]
	value &= mask;
 8020e3a:	787a      	ldrb	r2, [r7, #1]
 8020e3c:	7bbb      	ldrb	r3, [r7, #14]
 8020e3e:	4013      	ands	r3, r2
 8020e40:	707b      	strb	r3, [r7, #1]

	mask <<= pos;
 8020e42:	7bba      	ldrb	r2, [r7, #14]
 8020e44:	783b      	ldrb	r3, [r7, #0]
 8020e46:	fa02 f303 	lsl.w	r3, r2, r3
 8020e4a:	73bb      	strb	r3, [r7, #14]
	register_value &= ~mask;          // remove the current data at that spot
 8020e4c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020e50:	43db      	mvns	r3, r3
 8020e52:	b25a      	sxtb	r2, r3
 8020e54:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8020e58:	4013      	ands	r3, r2
 8020e5a:	b25b      	sxtb	r3, r3
 8020e5c:	73fb      	strb	r3, [r7, #15]
	register_value |= value << pos; // and add in the new data
 8020e5e:	787a      	ldrb	r2, [r7, #1]
 8020e60:	783b      	ldrb	r3, [r7, #0]
 8020e62:	fa02 f303 	lsl.w	r3, r2, r3
 8020e66:	b25a      	sxtb	r2, r3
 8020e68:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8020e6c:	4313      	orrs	r3, r2
 8020e6e:	b25b      	sxtb	r3, r3
 8020e70:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(reg, register_value);
 8020e72:	887b      	ldrh	r3, [r7, #2]
 8020e74:	b2db      	uxtb	r3, r3
 8020e76:	7bfa      	ldrb	r2, [r7, #15]
 8020e78:	4619      	mov	r1, r3
 8020e7a:	6878      	ldr	r0, [r7, #4]
 8020e7c:	f7ff ff26 	bl	8020ccc <_ZN15Adafruit_ICM20X17writeRegisterByteEhh>
 8020e80:	4603      	mov	r3, r0
}
 8020e82:	4618      	mov	r0, r3
 8020e84:	3710      	adds	r7, #16
 8020e86:	46bd      	mov	sp, r7
 8020e88:	bd80      	pop	{r7, pc}
	...

08020e8c <_ZN29Adafruit_ICM20X_Accelerometer9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
 @brief  Gets the sensor_t data for the ICM20X's accelerometer
 */
/**************************************************************************/
void Adafruit_ICM20X_Accelerometer::getSensor(sensor_t *sensor) {
 8020e8c:	b580      	push	{r7, lr}
 8020e8e:	b082      	sub	sp, #8
 8020e90:	af00      	add	r7, sp, #0
 8020e92:	6078      	str	r0, [r7, #4]
 8020e94:	6039      	str	r1, [r7, #0]
	/* Clear the sensor_t object */
	memset(sensor, 0, sizeof(sensor_t));
 8020e96:	2228      	movs	r2, #40	; 0x28
 8020e98:	2100      	movs	r1, #0
 8020e9a:	6838      	ldr	r0, [r7, #0]
 8020e9c:	f00b f92e 	bl	802c0fc <memset>

	/* Insert the sensor name in the fixed length char array */
	strncpy(sensor->name, "ICM20X_A", sizeof(sensor->name) - 1);
 8020ea0:	683b      	ldr	r3, [r7, #0]
 8020ea2:	220b      	movs	r2, #11
 8020ea4:	4910      	ldr	r1, [pc, #64]	; (8020ee8 <_ZN29Adafruit_ICM20X_Accelerometer9getSensorEP8sensor_t+0x5c>)
 8020ea6:	4618      	mov	r0, r3
 8020ea8:	f00b fa98 	bl	802c3dc <strncpy>
	sensor->name[sizeof(sensor->name) - 1] = 0;
 8020eac:	683b      	ldr	r3, [r7, #0]
 8020eae:	2200      	movs	r2, #0
 8020eb0:	72da      	strb	r2, [r3, #11]
	sensor->version = 1;
 8020eb2:	683b      	ldr	r3, [r7, #0]
 8020eb4:	2201      	movs	r2, #1
 8020eb6:	60da      	str	r2, [r3, #12]
	sensor->sensor_id = _sensorID;
 8020eb8:	687b      	ldr	r3, [r7, #4]
 8020eba:	689a      	ldr	r2, [r3, #8]
 8020ebc:	683b      	ldr	r3, [r7, #0]
 8020ebe:	611a      	str	r2, [r3, #16]
	sensor->type = SENSOR_TYPE_ACCELEROMETER;
 8020ec0:	683b      	ldr	r3, [r7, #0]
 8020ec2:	2201      	movs	r2, #1
 8020ec4:	615a      	str	r2, [r3, #20]
	sensor->min_delay = 0;
 8020ec6:	683b      	ldr	r3, [r7, #0]
 8020ec8:	2200      	movs	r2, #0
 8020eca:	625a      	str	r2, [r3, #36]	; 0x24
	sensor->min_value = -294.1995F; /*  -30g = 294.1995 m/s^2  */
 8020ecc:	683b      	ldr	r3, [r7, #0]
 8020ece:	4a07      	ldr	r2, [pc, #28]	; (8020eec <_ZN29Adafruit_ICM20X_Accelerometer9getSensorEP8sensor_t+0x60>)
 8020ed0:	61da      	str	r2, [r3, #28]
	sensor->max_value = 294.1995F; /* 30g = 294.1995 m/s^2  */
 8020ed2:	683b      	ldr	r3, [r7, #0]
 8020ed4:	4a06      	ldr	r2, [pc, #24]	; (8020ef0 <_ZN29Adafruit_ICM20X_Accelerometer9getSensorEP8sensor_t+0x64>)
 8020ed6:	619a      	str	r2, [r3, #24]
	sensor->resolution = 0.122; /* 8192LSB/1000 mG -> 8.192 LSB/ mG => 0.122 mG/LSB at +-4g */
 8020ed8:	683b      	ldr	r3, [r7, #0]
 8020eda:	4a06      	ldr	r2, [pc, #24]	; (8020ef4 <_ZN29Adafruit_ICM20X_Accelerometer9getSensorEP8sensor_t+0x68>)
 8020edc:	621a      	str	r2, [r3, #32]
}
 8020ede:	bf00      	nop
 8020ee0:	3708      	adds	r7, #8
 8020ee2:	46bd      	mov	sp, r7
 8020ee4:	bd80      	pop	{r7, pc}
 8020ee6:	bf00      	nop
 8020ee8:	0802c618 	.word	0x0802c618
 8020eec:	c3931989 	.word	0xc3931989
 8020ef0:	43931989 	.word	0x43931989
 8020ef4:	3df9db23 	.word	0x3df9db23

08020ef8 <_ZN29Adafruit_ICM20X_Accelerometer8getEventEP15sensors_event_t>:
 @brief  Gets the accelerometer as a standard sensor event
 @param  event Sensor event object that will be populated
 @returns True
 */
/**************************************************************************/
bool Adafruit_ICM20X_Accelerometer::getEvent(sensors_event_t *event) {
 8020ef8:	b590      	push	{r4, r7, lr}
 8020efa:	b083      	sub	sp, #12
 8020efc:	af00      	add	r7, sp, #0
 8020efe:	6078      	str	r0, [r7, #4]
 8020f00:	6039      	str	r1, [r7, #0]
	_theICM20X->_read();
 8020f02:	687b      	ldr	r3, [r7, #4]
 8020f04:	68db      	ldr	r3, [r3, #12]
 8020f06:	4618      	mov	r0, r3
 8020f08:	f7ff fbdc 	bl	80206c4 <_ZN15Adafruit_ICM20X5_readEv>
	_theICM20X->fillAccelEvent(event, HAL_GetTick());
 8020f0c:	687b      	ldr	r3, [r7, #4]
 8020f0e:	68dc      	ldr	r4, [r3, #12]
 8020f10:	f7eb fdba 	bl	800ca88 <HAL_GetTick>
 8020f14:	4603      	mov	r3, r0
 8020f16:	461a      	mov	r2, r3
 8020f18:	6839      	ldr	r1, [r7, #0]
 8020f1a:	4620      	mov	r0, r4
 8020f1c:	f7ff faea 	bl	80204f4 <_ZN15Adafruit_ICM20X14fillAccelEventEP15sensors_event_tm>

	return true;
 8020f20:	2301      	movs	r3, #1
}
 8020f22:	4618      	mov	r0, r3
 8020f24:	370c      	adds	r7, #12
 8020f26:	46bd      	mov	sp, r7
 8020f28:	bd90      	pop	{r4, r7, pc}
	...

08020f2c <_ZN20Adafruit_ICM20X_Gyro9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
 @brief  Gets the sensor_t data for the ICM20X's gyroscope sensor
 */
/**************************************************************************/
void Adafruit_ICM20X_Gyro::getSensor(sensor_t *sensor) {
 8020f2c:	b580      	push	{r7, lr}
 8020f2e:	b082      	sub	sp, #8
 8020f30:	af00      	add	r7, sp, #0
 8020f32:	6078      	str	r0, [r7, #4]
 8020f34:	6039      	str	r1, [r7, #0]
	/* Clear the sensor_t object */
	memset(sensor, 0, sizeof(sensor_t));
 8020f36:	2228      	movs	r2, #40	; 0x28
 8020f38:	2100      	movs	r1, #0
 8020f3a:	6838      	ldr	r0, [r7, #0]
 8020f3c:	f00b f8de 	bl	802c0fc <memset>

	/* Insert the sensor name in the fixed length char array */
	strncpy(sensor->name, "ICM20X_G", sizeof(sensor->name) - 1);
 8020f40:	683b      	ldr	r3, [r7, #0]
 8020f42:	220b      	movs	r2, #11
 8020f44:	4910      	ldr	r1, [pc, #64]	; (8020f88 <_ZN20Adafruit_ICM20X_Gyro9getSensorEP8sensor_t+0x5c>)
 8020f46:	4618      	mov	r0, r3
 8020f48:	f00b fa48 	bl	802c3dc <strncpy>
	sensor->name[sizeof(sensor->name) - 1] = 0;
 8020f4c:	683b      	ldr	r3, [r7, #0]
 8020f4e:	2200      	movs	r2, #0
 8020f50:	72da      	strb	r2, [r3, #11]
	sensor->version = 1;
 8020f52:	683b      	ldr	r3, [r7, #0]
 8020f54:	2201      	movs	r2, #1
 8020f56:	60da      	str	r2, [r3, #12]
	sensor->sensor_id = _sensorID;
 8020f58:	687b      	ldr	r3, [r7, #4]
 8020f5a:	689a      	ldr	r2, [r3, #8]
 8020f5c:	683b      	ldr	r3, [r7, #0]
 8020f5e:	611a      	str	r2, [r3, #16]
	sensor->type = SENSOR_TYPE_GYROSCOPE;
 8020f60:	683b      	ldr	r3, [r7, #0]
 8020f62:	2204      	movs	r2, #4
 8020f64:	615a      	str	r2, [r3, #20]
	sensor->min_delay = 0;
 8020f66:	683b      	ldr	r3, [r7, #0]
 8020f68:	2200      	movs	r2, #0
 8020f6a:	625a      	str	r2, [r3, #36]	; 0x24
	sensor->min_value = -69.81; /* -4000 dps -> rad/s (radians per second) */
 8020f6c:	683b      	ldr	r3, [r7, #0]
 8020f6e:	4a07      	ldr	r2, [pc, #28]	; (8020f8c <_ZN20Adafruit_ICM20X_Gyro9getSensorEP8sensor_t+0x60>)
 8020f70:	61da      	str	r2, [r3, #28]
	sensor->max_value = +69.81;
 8020f72:	683b      	ldr	r3, [r7, #0]
 8020f74:	4a06      	ldr	r2, [pc, #24]	; (8020f90 <_ZN20Adafruit_ICM20X_Gyro9getSensorEP8sensor_t+0x64>)
 8020f76:	619a      	str	r2, [r3, #24]
	sensor->resolution = 2.665e-7; /* 65.5 LSB/DPS */
 8020f78:	683b      	ldr	r3, [r7, #0]
 8020f7a:	4a06      	ldr	r2, [pc, #24]	; (8020f94 <_ZN20Adafruit_ICM20X_Gyro9getSensorEP8sensor_t+0x68>)
 8020f7c:	621a      	str	r2, [r3, #32]
}
 8020f7e:	bf00      	nop
 8020f80:	3708      	adds	r7, #8
 8020f82:	46bd      	mov	sp, r7
 8020f84:	bd80      	pop	{r7, pc}
 8020f86:	bf00      	nop
 8020f88:	0802c624 	.word	0x0802c624
 8020f8c:	c28b9eb8 	.word	0xc28b9eb8
 8020f90:	428b9eb8 	.word	0x428b9eb8
 8020f94:	348f137b 	.word	0x348f137b

08020f98 <_ZN20Adafruit_ICM20X_Gyro8getEventEP15sensors_event_t>:
 @brief  Gets the gyroscope as a standard sensor event
 @param  event Sensor event object that will be populated
 @returns True
 */
/**************************************************************************/
bool Adafruit_ICM20X_Gyro::getEvent(sensors_event_t *event) {
 8020f98:	b590      	push	{r4, r7, lr}
 8020f9a:	b083      	sub	sp, #12
 8020f9c:	af00      	add	r7, sp, #0
 8020f9e:	6078      	str	r0, [r7, #4]
 8020fa0:	6039      	str	r1, [r7, #0]
	_theICM20X->_read();
 8020fa2:	687b      	ldr	r3, [r7, #4]
 8020fa4:	68db      	ldr	r3, [r3, #12]
 8020fa6:	4618      	mov	r0, r3
 8020fa8:	f7ff fb8c 	bl	80206c4 <_ZN15Adafruit_ICM20X5_readEv>
	_theICM20X->fillGyroEvent(event, HAL_GetTick());
 8020fac:	687b      	ldr	r3, [r7, #4]
 8020fae:	68dc      	ldr	r4, [r3, #12]
 8020fb0:	f7eb fd6a 	bl	800ca88 <HAL_GetTick>
 8020fb4:	4603      	mov	r3, r0
 8020fb6:	461a      	mov	r2, r3
 8020fb8:	6839      	ldr	r1, [r7, #0]
 8020fba:	4620      	mov	r0, r4
 8020fbc:	f7ff fad8 	bl	8020570 <_ZN15Adafruit_ICM20X13fillGyroEventEP15sensors_event_tm>

	return true;
 8020fc0:	2301      	movs	r3, #1
}
 8020fc2:	4618      	mov	r0, r3
 8020fc4:	370c      	adds	r7, #12
 8020fc6:	46bd      	mov	sp, r7
 8020fc8:	bd90      	pop	{r4, r7, pc}
	...

08020fcc <_ZN28Adafruit_ICM20X_Magnetometer9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
 @brief  Gets the sensor_t data for the ICM20X's magnetometer sensor
 */
/**************************************************************************/
void Adafruit_ICM20X_Magnetometer::getSensor(sensor_t *sensor) {
 8020fcc:	b580      	push	{r7, lr}
 8020fce:	b082      	sub	sp, #8
 8020fd0:	af00      	add	r7, sp, #0
 8020fd2:	6078      	str	r0, [r7, #4]
 8020fd4:	6039      	str	r1, [r7, #0]
	/* Clear the sensor_t object */
	memset(sensor, 0, sizeof(sensor_t));
 8020fd6:	2228      	movs	r2, #40	; 0x28
 8020fd8:	2100      	movs	r1, #0
 8020fda:	6838      	ldr	r0, [r7, #0]
 8020fdc:	f00b f88e 	bl	802c0fc <memset>

	/* Insert the sensor name in the fixed length char array */
	strncpy(sensor->name, "ICM20X_M", sizeof(sensor->name) - 1);
 8020fe0:	683b      	ldr	r3, [r7, #0]
 8020fe2:	220b      	movs	r2, #11
 8020fe4:	4910      	ldr	r1, [pc, #64]	; (8021028 <_ZN28Adafruit_ICM20X_Magnetometer9getSensorEP8sensor_t+0x5c>)
 8020fe6:	4618      	mov	r0, r3
 8020fe8:	f00b f9f8 	bl	802c3dc <strncpy>
	sensor->name[sizeof(sensor->name) - 1] = 0;
 8020fec:	683b      	ldr	r3, [r7, #0]
 8020fee:	2200      	movs	r2, #0
 8020ff0:	72da      	strb	r2, [r3, #11]
	sensor->version = 1;
 8020ff2:	683b      	ldr	r3, [r7, #0]
 8020ff4:	2201      	movs	r2, #1
 8020ff6:	60da      	str	r2, [r3, #12]
	sensor->sensor_id = _sensorID;
 8020ff8:	687b      	ldr	r3, [r7, #4]
 8020ffa:	689a      	ldr	r2, [r3, #8]
 8020ffc:	683b      	ldr	r3, [r7, #0]
 8020ffe:	611a      	str	r2, [r3, #16]
	sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
 8021000:	683b      	ldr	r3, [r7, #0]
 8021002:	2202      	movs	r2, #2
 8021004:	615a      	str	r2, [r3, #20]
	sensor->min_delay = 0;
 8021006:	683b      	ldr	r3, [r7, #0]
 8021008:	2200      	movs	r2, #0
 802100a:	625a      	str	r2, [r3, #36]	; 0x24
	sensor->min_value = -4900;
 802100c:	683b      	ldr	r3, [r7, #0]
 802100e:	4a07      	ldr	r2, [pc, #28]	; (802102c <_ZN28Adafruit_ICM20X_Magnetometer9getSensorEP8sensor_t+0x60>)
 8021010:	61da      	str	r2, [r3, #28]
	sensor->max_value = 4900;
 8021012:	683b      	ldr	r3, [r7, #0]
 8021014:	4a06      	ldr	r2, [pc, #24]	; (8021030 <_ZN28Adafruit_ICM20X_Magnetometer9getSensorEP8sensor_t+0x64>)
 8021016:	619a      	str	r2, [r3, #24]
	sensor->resolution = 0.6667;
 8021018:	683b      	ldr	r3, [r7, #0]
 802101a:	4a06      	ldr	r2, [pc, #24]	; (8021034 <_ZN28Adafruit_ICM20X_Magnetometer9getSensorEP8sensor_t+0x68>)
 802101c:	621a      	str	r2, [r3, #32]
}
 802101e:	bf00      	nop
 8021020:	3708      	adds	r7, #8
 8021022:	46bd      	mov	sp, r7
 8021024:	bd80      	pop	{r7, pc}
 8021026:	bf00      	nop
 8021028:	0802c630 	.word	0x0802c630
 802102c:	c5992000 	.word	0xc5992000
 8021030:	45992000 	.word	0x45992000
 8021034:	3f2aacda 	.word	0x3f2aacda

08021038 <_ZN28Adafruit_ICM20X_Magnetometer8getEventEP15sensors_event_t>:
 @brief  Gets the magnetometer as a standard sensor event
 @param  event Sensor event object that will be populated
 @returns True
 */
/**************************************************************************/
bool Adafruit_ICM20X_Magnetometer::getEvent(sensors_event_t *event) {
 8021038:	b590      	push	{r4, r7, lr}
 802103a:	b083      	sub	sp, #12
 802103c:	af00      	add	r7, sp, #0
 802103e:	6078      	str	r0, [r7, #4]
 8021040:	6039      	str	r1, [r7, #0]
	_theICM20X->_read();
 8021042:	687b      	ldr	r3, [r7, #4]
 8021044:	68db      	ldr	r3, [r3, #12]
 8021046:	4618      	mov	r0, r3
 8021048:	f7ff fb3c 	bl	80206c4 <_ZN15Adafruit_ICM20X5_readEv>
	_theICM20X->fillMagEvent(event, HAL_GetTick());
 802104c:	687b      	ldr	r3, [r7, #4]
 802104e:	68dc      	ldr	r4, [r3, #12]
 8021050:	f7eb fd1a 	bl	800ca88 <HAL_GetTick>
 8021054:	4603      	mov	r3, r0
 8021056:	461a      	mov	r2, r3
 8021058:	6839      	ldr	r1, [r7, #0]
 802105a:	4620      	mov	r0, r4
 802105c:	f7ff fac6 	bl	80205ec <_ZN15Adafruit_ICM20X12fillMagEventEP15sensors_event_tm>

	return true;
 8021060:	2301      	movs	r3, #1
}
 8021062:	4618      	mov	r0, r3
 8021064:	370c      	adds	r7, #12
 8021066:	46bd      	mov	sp, r7
 8021068:	bd90      	pop	{r4, r7, pc}
	...

0802106c <_ZN20Adafruit_ICM20X_Temp9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
 @brief  Gets the sensor_t data for the ICM20X's tenperature
 */
/**************************************************************************/
void Adafruit_ICM20X_Temp::getSensor(sensor_t *sensor) {
 802106c:	b580      	push	{r7, lr}
 802106e:	b082      	sub	sp, #8
 8021070:	af00      	add	r7, sp, #0
 8021072:	6078      	str	r0, [r7, #4]
 8021074:	6039      	str	r1, [r7, #0]
	/* Clear the sensor_t object */
	memset(sensor, 0, sizeof(sensor_t));
 8021076:	2228      	movs	r2, #40	; 0x28
 8021078:	2100      	movs	r1, #0
 802107a:	6838      	ldr	r0, [r7, #0]
 802107c:	f00b f83e 	bl	802c0fc <memset>

	/* Insert the sensor name in the fixed length char array */
	strncpy(sensor->name, "ICM20X_T", sizeof(sensor->name) - 1);
 8021080:	683b      	ldr	r3, [r7, #0]
 8021082:	220b      	movs	r2, #11
 8021084:	4910      	ldr	r1, [pc, #64]	; (80210c8 <_ZN20Adafruit_ICM20X_Temp9getSensorEP8sensor_t+0x5c>)
 8021086:	4618      	mov	r0, r3
 8021088:	f00b f9a8 	bl	802c3dc <strncpy>
	sensor->name[sizeof(sensor->name) - 1] = 0;
 802108c:	683b      	ldr	r3, [r7, #0]
 802108e:	2200      	movs	r2, #0
 8021090:	72da      	strb	r2, [r3, #11]
	sensor->version = 1;
 8021092:	683b      	ldr	r3, [r7, #0]
 8021094:	2201      	movs	r2, #1
 8021096:	60da      	str	r2, [r3, #12]
	sensor->sensor_id = _sensorID;
 8021098:	687b      	ldr	r3, [r7, #4]
 802109a:	689a      	ldr	r2, [r3, #8]
 802109c:	683b      	ldr	r3, [r7, #0]
 802109e:	611a      	str	r2, [r3, #16]
	sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
 80210a0:	683b      	ldr	r3, [r7, #0]
 80210a2:	220d      	movs	r2, #13
 80210a4:	615a      	str	r2, [r3, #20]
	sensor->min_delay = 0;
 80210a6:	683b      	ldr	r3, [r7, #0]
 80210a8:	2200      	movs	r2, #0
 80210aa:	625a      	str	r2, [r3, #36]	; 0x24
	sensor->min_value = -40;
 80210ac:	683b      	ldr	r3, [r7, #0]
 80210ae:	4a07      	ldr	r2, [pc, #28]	; (80210cc <_ZN20Adafruit_ICM20X_Temp9getSensorEP8sensor_t+0x60>)
 80210b0:	61da      	str	r2, [r3, #28]
	sensor->max_value = 85;
 80210b2:	683b      	ldr	r3, [r7, #0]
 80210b4:	4a06      	ldr	r2, [pc, #24]	; (80210d0 <_ZN20Adafruit_ICM20X_Temp9getSensorEP8sensor_t+0x64>)
 80210b6:	619a      	str	r2, [r3, #24]
	sensor->resolution = 0.0029952; /* 333.87 LSB/C => 1/333.87 C/LSB */
 80210b8:	683b      	ldr	r3, [r7, #0]
 80210ba:	4a06      	ldr	r2, [pc, #24]	; (80210d4 <_ZN20Adafruit_ICM20X_Temp9getSensorEP8sensor_t+0x68>)
 80210bc:	621a      	str	r2, [r3, #32]
}
 80210be:	bf00      	nop
 80210c0:	3708      	adds	r7, #8
 80210c2:	46bd      	mov	sp, r7
 80210c4:	bd80      	pop	{r7, pc}
 80210c6:	bf00      	nop
 80210c8:	0802c63c 	.word	0x0802c63c
 80210cc:	c2200000 	.word	0xc2200000
 80210d0:	42aa0000 	.word	0x42aa0000
 80210d4:	3b444b1e 	.word	0x3b444b1e

080210d8 <_ZN20Adafruit_ICM20X_Temp8getEventEP15sensors_event_t>:
 @brief  Gets the temperature as a standard sensor event
 @param  event Sensor event object that will be populated
 @returns True
 */
/**************************************************************************/
bool Adafruit_ICM20X_Temp::getEvent(sensors_event_t *event) {
 80210d8:	b590      	push	{r4, r7, lr}
 80210da:	b083      	sub	sp, #12
 80210dc:	af00      	add	r7, sp, #0
 80210de:	6078      	str	r0, [r7, #4]
 80210e0:	6039      	str	r1, [r7, #0]
	_theICM20X->_read();
 80210e2:	687b      	ldr	r3, [r7, #4]
 80210e4:	68db      	ldr	r3, [r3, #12]
 80210e6:	4618      	mov	r0, r3
 80210e8:	f7ff faec 	bl	80206c4 <_ZN15Adafruit_ICM20X5_readEv>
	_theICM20X->fillTempEvent(event, HAL_GetTick());
 80210ec:	687b      	ldr	r3, [r7, #4]
 80210ee:	68dc      	ldr	r4, [r3, #12]
 80210f0:	f7eb fcca 	bl	800ca88 <HAL_GetTick>
 80210f4:	4603      	mov	r3, r0
 80210f6:	461a      	mov	r2, r3
 80210f8:	6839      	ldr	r1, [r7, #0]
 80210fa:	4620      	mov	r0, r4
 80210fc:	f7ff faa0 	bl	8020640 <_ZN15Adafruit_ICM20X13fillTempEventEP15sensors_event_tm>

	return true;
 8021100:	2301      	movs	r3, #1
}
 8021102:	4618      	mov	r0, r3
 8021104:	370c      	adds	r7, #12
 8021106:	46bd      	mov	sp, r7
 8021108:	bd90      	pop	{r4, r7, pc}
	...

0802110c <_ZN20Adafruit_ICM20X_TempD1Ev>:
class Adafruit_ICM20X_Temp: public Adafruit_Sensor {
 802110c:	b580      	push	{r7, lr}
 802110e:	b082      	sub	sp, #8
 8021110:	af00      	add	r7, sp, #0
 8021112:	6078      	str	r0, [r7, #4]
 8021114:	4a05      	ldr	r2, [pc, #20]	; (802112c <_ZN20Adafruit_ICM20X_TempD1Ev+0x20>)
 8021116:	687b      	ldr	r3, [r7, #4]
 8021118:	601a      	str	r2, [r3, #0]
 802111a:	687b      	ldr	r3, [r7, #4]
 802111c:	4618      	mov	r0, r3
 802111e:	f7fe ffaf 	bl	8020080 <_ZN15Adafruit_SensorD1Ev>
 8021122:	687b      	ldr	r3, [r7, #4]
 8021124:	4618      	mov	r0, r3
 8021126:	3708      	adds	r7, #8
 8021128:	46bd      	mov	sp, r7
 802112a:	bd80      	pop	{r7, pc}
 802112c:	0802cb60 	.word	0x0802cb60

08021130 <_ZN20Adafruit_ICM20X_TempD0Ev>:
 8021130:	b580      	push	{r7, lr}
 8021132:	b082      	sub	sp, #8
 8021134:	af00      	add	r7, sp, #0
 8021136:	6078      	str	r0, [r7, #4]
 8021138:	6878      	ldr	r0, [r7, #4]
 802113a:	f7ff ffe7 	bl	802110c <_ZN20Adafruit_ICM20X_TempD1Ev>
 802113e:	2110      	movs	r1, #16
 8021140:	6878      	ldr	r0, [r7, #4]
 8021142:	f008 f87f 	bl	8029244 <_ZdlPvj>
 8021146:	687b      	ldr	r3, [r7, #4]
 8021148:	4618      	mov	r0, r3
 802114a:	3708      	adds	r7, #8
 802114c:	46bd      	mov	sp, r7
 802114e:	bd80      	pop	{r7, pc}

08021150 <_ZN28Adafruit_ICM20X_MagnetometerD1Ev>:
class Adafruit_ICM20X_Magnetometer: public Adafruit_Sensor {
 8021150:	b580      	push	{r7, lr}
 8021152:	b082      	sub	sp, #8
 8021154:	af00      	add	r7, sp, #0
 8021156:	6078      	str	r0, [r7, #4]
 8021158:	4a05      	ldr	r2, [pc, #20]	; (8021170 <_ZN28Adafruit_ICM20X_MagnetometerD1Ev+0x20>)
 802115a:	687b      	ldr	r3, [r7, #4]
 802115c:	601a      	str	r2, [r3, #0]
 802115e:	687b      	ldr	r3, [r7, #4]
 8021160:	4618      	mov	r0, r3
 8021162:	f7fe ff8d 	bl	8020080 <_ZN15Adafruit_SensorD1Ev>
 8021166:	687b      	ldr	r3, [r7, #4]
 8021168:	4618      	mov	r0, r3
 802116a:	3708      	adds	r7, #8
 802116c:	46bd      	mov	sp, r7
 802116e:	bd80      	pop	{r7, pc}
 8021170:	0802cb7c 	.word	0x0802cb7c

08021174 <_ZN28Adafruit_ICM20X_MagnetometerD0Ev>:
 8021174:	b580      	push	{r7, lr}
 8021176:	b082      	sub	sp, #8
 8021178:	af00      	add	r7, sp, #0
 802117a:	6078      	str	r0, [r7, #4]
 802117c:	6878      	ldr	r0, [r7, #4]
 802117e:	f7ff ffe7 	bl	8021150 <_ZN28Adafruit_ICM20X_MagnetometerD1Ev>
 8021182:	2110      	movs	r1, #16
 8021184:	6878      	ldr	r0, [r7, #4]
 8021186:	f008 f85d 	bl	8029244 <_ZdlPvj>
 802118a:	687b      	ldr	r3, [r7, #4]
 802118c:	4618      	mov	r0, r3
 802118e:	3708      	adds	r7, #8
 8021190:	46bd      	mov	sp, r7
 8021192:	bd80      	pop	{r7, pc}

08021194 <_ZN20Adafruit_ICM20X_GyroD1Ev>:
class Adafruit_ICM20X_Gyro: public Adafruit_Sensor {
 8021194:	b580      	push	{r7, lr}
 8021196:	b082      	sub	sp, #8
 8021198:	af00      	add	r7, sp, #0
 802119a:	6078      	str	r0, [r7, #4]
 802119c:	4a05      	ldr	r2, [pc, #20]	; (80211b4 <_ZN20Adafruit_ICM20X_GyroD1Ev+0x20>)
 802119e:	687b      	ldr	r3, [r7, #4]
 80211a0:	601a      	str	r2, [r3, #0]
 80211a2:	687b      	ldr	r3, [r7, #4]
 80211a4:	4618      	mov	r0, r3
 80211a6:	f7fe ff6b 	bl	8020080 <_ZN15Adafruit_SensorD1Ev>
 80211aa:	687b      	ldr	r3, [r7, #4]
 80211ac:	4618      	mov	r0, r3
 80211ae:	3708      	adds	r7, #8
 80211b0:	46bd      	mov	sp, r7
 80211b2:	bd80      	pop	{r7, pc}
 80211b4:	0802cb98 	.word	0x0802cb98

080211b8 <_ZN20Adafruit_ICM20X_GyroD0Ev>:
 80211b8:	b580      	push	{r7, lr}
 80211ba:	b082      	sub	sp, #8
 80211bc:	af00      	add	r7, sp, #0
 80211be:	6078      	str	r0, [r7, #4]
 80211c0:	6878      	ldr	r0, [r7, #4]
 80211c2:	f7ff ffe7 	bl	8021194 <_ZN20Adafruit_ICM20X_GyroD1Ev>
 80211c6:	2110      	movs	r1, #16
 80211c8:	6878      	ldr	r0, [r7, #4]
 80211ca:	f008 f83b 	bl	8029244 <_ZdlPvj>
 80211ce:	687b      	ldr	r3, [r7, #4]
 80211d0:	4618      	mov	r0, r3
 80211d2:	3708      	adds	r7, #8
 80211d4:	46bd      	mov	sp, r7
 80211d6:	bd80      	pop	{r7, pc}

080211d8 <_ZN29Adafruit_ICM20X_AccelerometerD1Ev>:
class Adafruit_ICM20X_Accelerometer: public Adafruit_Sensor {
 80211d8:	b580      	push	{r7, lr}
 80211da:	b082      	sub	sp, #8
 80211dc:	af00      	add	r7, sp, #0
 80211de:	6078      	str	r0, [r7, #4]
 80211e0:	4a05      	ldr	r2, [pc, #20]	; (80211f8 <_ZN29Adafruit_ICM20X_AccelerometerD1Ev+0x20>)
 80211e2:	687b      	ldr	r3, [r7, #4]
 80211e4:	601a      	str	r2, [r3, #0]
 80211e6:	687b      	ldr	r3, [r7, #4]
 80211e8:	4618      	mov	r0, r3
 80211ea:	f7fe ff49 	bl	8020080 <_ZN15Adafruit_SensorD1Ev>
 80211ee:	687b      	ldr	r3, [r7, #4]
 80211f0:	4618      	mov	r0, r3
 80211f2:	3708      	adds	r7, #8
 80211f4:	46bd      	mov	sp, r7
 80211f6:	bd80      	pop	{r7, pc}
 80211f8:	0802cbb4 	.word	0x0802cbb4

080211fc <_ZN29Adafruit_ICM20X_AccelerometerD0Ev>:
 80211fc:	b580      	push	{r7, lr}
 80211fe:	b082      	sub	sp, #8
 8021200:	af00      	add	r7, sp, #0
 8021202:	6078      	str	r0, [r7, #4]
 8021204:	6878      	ldr	r0, [r7, #4]
 8021206:	f7ff ffe7 	bl	80211d8 <_ZN29Adafruit_ICM20X_AccelerometerD1Ev>
 802120a:	2110      	movs	r1, #16
 802120c:	6878      	ldr	r0, [r7, #4]
 802120e:	f008 f819 	bl	8029244 <_ZdlPvj>
 8021212:	687b      	ldr	r3, [r7, #4]
 8021214:	4618      	mov	r0, r3
 8021216:	3708      	adds	r7, #8
 8021218:	46bd      	mov	sp, r7
 802121a:	bd80      	pop	{r7, pc}

0802121c <_ZN19SensirionI2CRxFrameC1EPhj>:
     * @param buffer     Buffer in which the receive frame will be
     *                   stored.
     * @param bufferSize Number of bytes in the buffer for the receive frame.
     *
     */
    SensirionI2CRxFrame(uint8_t buffer[], size_t bufferSize)
 802121c:	b580      	push	{r7, lr}
 802121e:	b084      	sub	sp, #16
 8021220:	af00      	add	r7, sp, #0
 8021222:	60f8      	str	r0, [r7, #12]
 8021224:	60b9      	str	r1, [r7, #8]
 8021226:	607a      	str	r2, [r7, #4]
        : SensirionRxFrame(buffer, bufferSize){};
 8021228:	68fb      	ldr	r3, [r7, #12]
 802122a:	687a      	ldr	r2, [r7, #4]
 802122c:	68b9      	ldr	r1, [r7, #8]
 802122e:	4618      	mov	r0, r3
 8021230:	f001 f89c 	bl	802236c <_ZN16SensirionRxFrameC1EPhj>
 8021234:	68fb      	ldr	r3, [r7, #12]
 8021236:	4618      	mov	r0, r3
 8021238:	3710      	adds	r7, #16
 802123a:	46bd      	mov	sp, r7
 802123c:	bd80      	pop	{r7, pc}

0802123e <_ZN17SensirionI2CSgp41C1Ev>:
#include "../Sensirion_Core/src/SensirionCore.h"
#include "cmsis_os2.h"

#define SGP41_I2C_ADDRESS 0x59

SensirionI2CSgp41::SensirionI2CSgp41() {
 802123e:	b480      	push	{r7}
 8021240:	b083      	sub	sp, #12
 8021242:	af00      	add	r7, sp, #0
 8021244:	6078      	str	r0, [r7, #4]
 8021246:	687b      	ldr	r3, [r7, #4]
 8021248:	2200      	movs	r2, #0
 802124a:	601a      	str	r2, [r3, #0]
 802124c:	687b      	ldr	r3, [r7, #4]
 802124e:	2200      	movs	r2, #0
 8021250:	711a      	strb	r2, [r3, #4]
}
 8021252:	687b      	ldr	r3, [r7, #4]
 8021254:	4618      	mov	r0, r3
 8021256:	370c      	adds	r7, #12
 8021258:	46bd      	mov	sp, r7
 802125a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802125e:	4770      	bx	lr

08021260 <_ZN17SensirionI2CSgp415beginEP19__I2C_HandleTypeDef>:

bool SensirionI2CSgp41::begin(I2C_HandleTypeDef *i2c_handle) {
 8021260:	b480      	push	{r7}
 8021262:	b083      	sub	sp, #12
 8021264:	af00      	add	r7, sp, #0
 8021266:	6078      	str	r0, [r7, #4]
 8021268:	6039      	str	r1, [r7, #0]
	i2c_han = i2c_handle;
 802126a:	687b      	ldr	r3, [r7, #4]
 802126c:	683a      	ldr	r2, [r7, #0]
 802126e:	601a      	str	r2, [r3, #0]
	i2c_addr = SGP41_I2C_ADDRESS << 1;
 8021270:	687b      	ldr	r3, [r7, #4]
 8021272:	22b2      	movs	r2, #178	; 0xb2
 8021274:	711a      	strb	r2, [r3, #4]

	return true;
 8021276:	2301      	movs	r3, #1
}
 8021278:	4618      	mov	r0, r3
 802127a:	370c      	adds	r7, #12
 802127c:	46bd      	mov	sp, r7
 802127e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021282:	4770      	bx	lr

08021284 <_ZN17SensirionI2CSgp4119executeConditioningEttRt>:

uint16_t SensirionI2CSgp41::executeConditioning(uint16_t defaultRh,
                                                uint16_t defaultT,
                                                uint16_t& srawVoc) {
 8021284:	b580      	push	{r7, lr}
 8021286:	b092      	sub	sp, #72	; 0x48
 8021288:	af02      	add	r7, sp, #8
 802128a:	60f8      	str	r0, [r7, #12]
 802128c:	607b      	str	r3, [r7, #4]
 802128e:	460b      	mov	r3, r1
 8021290:	817b      	strh	r3, [r7, #10]
 8021292:	4613      	mov	r3, r2
 8021294:	813b      	strh	r3, [r7, #8]
    uint16_t error;
    uint8_t buffer[8];
    SensirionI2CTxFrame txFrame =
        SensirionI2CTxFrame::createWithUInt16Command(0x2612, buffer, 8);
 8021296:	f107 0020 	add.w	r0, r7, #32
 802129a:	f107 0234 	add.w	r2, r7, #52	; 0x34
 802129e:	2301      	movs	r3, #1
 80212a0:	9300      	str	r3, [sp, #0]
 80212a2:	2308      	movs	r3, #8
 80212a4:	f242 6112 	movw	r1, #9746	; 0x2612
 80212a8:	f000 ffcd 	bl	8022246 <_ZN19SensirionI2CTxFrame23createWithUInt16CommandEtPhj13CrcPolynomial>

    error = txFrame.addUInt16(defaultRh);
 80212ac:	897a      	ldrh	r2, [r7, #10]
 80212ae:	f107 0320 	add.w	r3, r7, #32
 80212b2:	4611      	mov	r1, r2
 80212b4:	4618      	mov	r0, r3
 80212b6:	f000 ffe8 	bl	802228a <_ZN19SensirionI2CTxFrame9addUInt16Et>
 80212ba:	4603      	mov	r3, r0
 80212bc:	87fb      	strh	r3, [r7, #62]	; 0x3e
    error |= txFrame.addUInt16(defaultT);
 80212be:	893a      	ldrh	r2, [r7, #8]
 80212c0:	f107 0320 	add.w	r3, r7, #32
 80212c4:	4611      	mov	r1, r2
 80212c6:	4618      	mov	r0, r3
 80212c8:	f000 ffdf 	bl	802228a <_ZN19SensirionI2CTxFrame9addUInt16Et>
 80212cc:	4603      	mov	r3, r0
 80212ce:	461a      	mov	r2, r3
 80212d0:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80212d2:	4313      	orrs	r3, r2
 80212d4:	87fb      	strh	r3, [r7, #62]	; 0x3e
    if (error) {
 80212d6:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80212d8:	2b00      	cmp	r3, #0
 80212da:	d001      	beq.n	80212e0 <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0x5c>
        return error;
 80212dc:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80212de:	e036      	b.n	802134e <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0xca>
    }

    error = SensirionI2CCommunication::sendFrame(SGP41_I2C_ADDRESS, txFrame,
 80212e0:	68fb      	ldr	r3, [r7, #12]
 80212e2:	681a      	ldr	r2, [r3, #0]
 80212e4:	f107 0320 	add.w	r3, r7, #32
 80212e8:	4619      	mov	r1, r3
 80212ea:	2059      	movs	r0, #89	; 0x59
 80212ec:	f000 feae 	bl	802204c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef>
 80212f0:	4603      	mov	r3, r0
 80212f2:	87fb      	strh	r3, [r7, #62]	; 0x3e
    		i2c_han);
    if (error) {
 80212f4:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80212f6:	2b00      	cmp	r3, #0
 80212f8:	d001      	beq.n	80212fe <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0x7a>
        return error;
 80212fa:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80212fc:	e027      	b.n	802134e <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0xca>
    }

    osDelay(50);
 80212fe:	2032      	movs	r0, #50	; 0x32
 8021300:	f001 fa73 	bl	80227ea <osDelay>

    SensirionI2CRxFrame rxFrame(buffer, 8);
 8021304:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8021308:	f107 0310 	add.w	r3, r7, #16
 802130c:	2208      	movs	r2, #8
 802130e:	4618      	mov	r0, r3
 8021310:	f7ff ff84 	bl	802121c <_ZN19SensirionI2CRxFrameC1EPhj>
    error = SensirionI2CCommunication::receiveFrame(SGP41_I2C_ADDRESS, 3,
 8021314:	68fb      	ldr	r3, [r7, #12]
 8021316:	681b      	ldr	r3, [r3, #0]
 8021318:	f107 0210 	add.w	r2, r7, #16
 802131c:	2101      	movs	r1, #1
 802131e:	9100      	str	r1, [sp, #0]
 8021320:	2103      	movs	r1, #3
 8021322:	2059      	movs	r0, #89	; 0x59
 8021324:	f000 feb8 	bl	8022098 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial>
 8021328:	4603      	mov	r3, r0
 802132a:	87fb      	strh	r3, [r7, #62]	; 0x3e
                                                    rxFrame, i2c_han);
    if (error) {
 802132c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 802132e:	2b00      	cmp	r3, #0
 8021330:	d001      	beq.n	8021336 <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0xb2>
        return error;
 8021332:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021334:	e00b      	b.n	802134e <_ZN17SensirionI2CSgp4119executeConditioningEttRt+0xca>
    }

    error |= rxFrame.getUInt16(srawVoc);
 8021336:	f107 0310 	add.w	r3, r7, #16
 802133a:	6879      	ldr	r1, [r7, #4]
 802133c:	4618      	mov	r0, r3
 802133e:	f001 f82e 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 8021342:	4603      	mov	r3, r0
 8021344:	461a      	mov	r2, r3
 8021346:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021348:	4313      	orrs	r3, r2
 802134a:	87fb      	strh	r3, [r7, #62]	; 0x3e
    return error;
 802134c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 802134e:	4618      	mov	r0, r3
 8021350:	3740      	adds	r7, #64	; 0x40
 8021352:	46bd      	mov	sp, r7
 8021354:	bd80      	pop	{r7, pc}

08021356 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_>:

uint16_t SensirionI2CSgp41::measureRawSignals(uint16_t relativeHumidity,
                                              uint16_t temperature,
                                              uint16_t& srawVoc,
                                              uint16_t& srawNox) {
 8021356:	b580      	push	{r7, lr}
 8021358:	b092      	sub	sp, #72	; 0x48
 802135a:	af02      	add	r7, sp, #8
 802135c:	60f8      	str	r0, [r7, #12]
 802135e:	607b      	str	r3, [r7, #4]
 8021360:	460b      	mov	r3, r1
 8021362:	817b      	strh	r3, [r7, #10]
 8021364:	4613      	mov	r3, r2
 8021366:	813b      	strh	r3, [r7, #8]
    uint16_t error;
    uint8_t buffer[8];
    SensirionI2CTxFrame txFrame =
        SensirionI2CTxFrame::createWithUInt16Command(0x2619, buffer, 8);
 8021368:	f107 0020 	add.w	r0, r7, #32
 802136c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 8021370:	2301      	movs	r3, #1
 8021372:	9300      	str	r3, [sp, #0]
 8021374:	2308      	movs	r3, #8
 8021376:	f242 6119 	movw	r1, #9753	; 0x2619
 802137a:	f000 ff64 	bl	8022246 <_ZN19SensirionI2CTxFrame23createWithUInt16CommandEtPhj13CrcPolynomial>

    error = txFrame.addUInt16(relativeHumidity);
 802137e:	897a      	ldrh	r2, [r7, #10]
 8021380:	f107 0320 	add.w	r3, r7, #32
 8021384:	4611      	mov	r1, r2
 8021386:	4618      	mov	r0, r3
 8021388:	f000 ff7f 	bl	802228a <_ZN19SensirionI2CTxFrame9addUInt16Et>
 802138c:	4603      	mov	r3, r0
 802138e:	87fb      	strh	r3, [r7, #62]	; 0x3e
    error |= txFrame.addUInt16(temperature);
 8021390:	893a      	ldrh	r2, [r7, #8]
 8021392:	f107 0320 	add.w	r3, r7, #32
 8021396:	4611      	mov	r1, r2
 8021398:	4618      	mov	r0, r3
 802139a:	f000 ff76 	bl	802228a <_ZN19SensirionI2CTxFrame9addUInt16Et>
 802139e:	4603      	mov	r3, r0
 80213a0:	461a      	mov	r2, r3
 80213a2:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80213a4:	4313      	orrs	r3, r2
 80213a6:	87fb      	strh	r3, [r7, #62]	; 0x3e
    if (error) {
 80213a8:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80213aa:	2b00      	cmp	r3, #0
 80213ac:	d001      	beq.n	80213b2 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0x5c>
        return error;
 80213ae:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80213b0:	e041      	b.n	8021436 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0xe0>
    }

    error = SensirionI2CCommunication::sendFrame(SGP41_I2C_ADDRESS, txFrame,
 80213b2:	68fb      	ldr	r3, [r7, #12]
 80213b4:	681a      	ldr	r2, [r3, #0]
 80213b6:	f107 0320 	add.w	r3, r7, #32
 80213ba:	4619      	mov	r1, r3
 80213bc:	2059      	movs	r0, #89	; 0x59
 80213be:	f000 fe45 	bl	802204c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef>
 80213c2:	4603      	mov	r3, r0
 80213c4:	87fb      	strh	r3, [r7, #62]	; 0x3e
    		i2c_han);
    if (error) {
 80213c6:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80213c8:	2b00      	cmp	r3, #0
 80213ca:	d001      	beq.n	80213d0 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0x7a>
        return error;
 80213cc:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80213ce:	e032      	b.n	8021436 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0xe0>
    }

    osDelay(50);
 80213d0:	2032      	movs	r0, #50	; 0x32
 80213d2:	f001 fa0a 	bl	80227ea <osDelay>

    SensirionI2CRxFrame rxFrame(buffer, 8);
 80213d6:	f107 0134 	add.w	r1, r7, #52	; 0x34
 80213da:	f107 0310 	add.w	r3, r7, #16
 80213de:	2208      	movs	r2, #8
 80213e0:	4618      	mov	r0, r3
 80213e2:	f7ff ff1b 	bl	802121c <_ZN19SensirionI2CRxFrameC1EPhj>
    error = SensirionI2CCommunication::receiveFrame(SGP41_I2C_ADDRESS, 6,
 80213e6:	68fb      	ldr	r3, [r7, #12]
 80213e8:	681b      	ldr	r3, [r3, #0]
 80213ea:	f107 0210 	add.w	r2, r7, #16
 80213ee:	2101      	movs	r1, #1
 80213f0:	9100      	str	r1, [sp, #0]
 80213f2:	2106      	movs	r1, #6
 80213f4:	2059      	movs	r0, #89	; 0x59
 80213f6:	f000 fe4f 	bl	8022098 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial>
 80213fa:	4603      	mov	r3, r0
 80213fc:	87fb      	strh	r3, [r7, #62]	; 0x3e
                                                    rxFrame, i2c_han);
    if (error) {
 80213fe:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021400:	2b00      	cmp	r3, #0
 8021402:	d001      	beq.n	8021408 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0xb2>
        return error;
 8021404:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021406:	e016      	b.n	8021436 <_ZN17SensirionI2CSgp4117measureRawSignalsEttRtS0_+0xe0>
    }

    error |= rxFrame.getUInt16(srawVoc);
 8021408:	f107 0310 	add.w	r3, r7, #16
 802140c:	6879      	ldr	r1, [r7, #4]
 802140e:	4618      	mov	r0, r3
 8021410:	f000 ffc5 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 8021414:	4603      	mov	r3, r0
 8021416:	461a      	mov	r2, r3
 8021418:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 802141a:	4313      	orrs	r3, r2
 802141c:	87fb      	strh	r3, [r7, #62]	; 0x3e
    error |= rxFrame.getUInt16(srawNox);
 802141e:	f107 0310 	add.w	r3, r7, #16
 8021422:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8021424:	4618      	mov	r0, r3
 8021426:	f000 ffba 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 802142a:	4603      	mov	r3, r0
 802142c:	461a      	mov	r2, r3
 802142e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021430:	4313      	orrs	r3, r2
 8021432:	87fb      	strh	r3, [r7, #62]	; 0x3e
    return error;
 8021434:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 8021436:	4618      	mov	r0, r3
 8021438:	3740      	adds	r7, #64	; 0x40
 802143a:	46bd      	mov	sp, r7
 802143c:	bd80      	pop	{r7, pc}

0802143e <_ZN17SensirionI2CSgp4115executeSelfTestERt>:

uint16_t SensirionI2CSgp41::executeSelfTest(uint16_t& testResult) {
 802143e:	b580      	push	{r7, lr}
 8021440:	b090      	sub	sp, #64	; 0x40
 8021442:	af02      	add	r7, sp, #8
 8021444:	6078      	str	r0, [r7, #4]
 8021446:	6039      	str	r1, [r7, #0]
    uint16_t error;
    uint8_t buffer[3];
    SensirionI2CTxFrame txFrame =
        SensirionI2CTxFrame::createWithUInt16Command(0x280E, buffer, 3);
 8021448:	f107 001c 	add.w	r0, r7, #28
 802144c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8021450:	2301      	movs	r3, #1
 8021452:	9300      	str	r3, [sp, #0]
 8021454:	2303      	movs	r3, #3
 8021456:	f642 010e 	movw	r1, #10254	; 0x280e
 802145a:	f000 fef4 	bl	8022246 <_ZN19SensirionI2CTxFrame23createWithUInt16CommandEtPhj13CrcPolynomial>

    error = SensirionI2CCommunication::sendFrame(SGP41_I2C_ADDRESS, txFrame,
 802145e:	687b      	ldr	r3, [r7, #4]
 8021460:	681a      	ldr	r2, [r3, #0]
 8021462:	f107 031c 	add.w	r3, r7, #28
 8021466:	4619      	mov	r1, r3
 8021468:	2059      	movs	r0, #89	; 0x59
 802146a:	f000 fdef 	bl	802204c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef>
 802146e:	4603      	mov	r3, r0
 8021470:	86fb      	strh	r3, [r7, #54]	; 0x36
    		i2c_han);
    if (error) {
 8021472:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8021474:	2b00      	cmp	r3, #0
 8021476:	d001      	beq.n	802147c <_ZN17SensirionI2CSgp4115executeSelfTestERt+0x3e>
        return error;
 8021478:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 802147a:	e028      	b.n	80214ce <_ZN17SensirionI2CSgp4115executeSelfTestERt+0x90>
    }

    osDelay(320);
 802147c:	f44f 70a0 	mov.w	r0, #320	; 0x140
 8021480:	f001 f9b3 	bl	80227ea <osDelay>

    SensirionI2CRxFrame rxFrame(buffer, 3);
 8021484:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8021488:	f107 030c 	add.w	r3, r7, #12
 802148c:	2203      	movs	r2, #3
 802148e:	4618      	mov	r0, r3
 8021490:	f7ff fec4 	bl	802121c <_ZN19SensirionI2CRxFrameC1EPhj>
    error = SensirionI2CCommunication::receiveFrame(SGP41_I2C_ADDRESS, 3,
 8021494:	687b      	ldr	r3, [r7, #4]
 8021496:	681b      	ldr	r3, [r3, #0]
 8021498:	f107 020c 	add.w	r2, r7, #12
 802149c:	2101      	movs	r1, #1
 802149e:	9100      	str	r1, [sp, #0]
 80214a0:	2103      	movs	r1, #3
 80214a2:	2059      	movs	r0, #89	; 0x59
 80214a4:	f000 fdf8 	bl	8022098 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial>
 80214a8:	4603      	mov	r3, r0
 80214aa:	86fb      	strh	r3, [r7, #54]	; 0x36
                                                    rxFrame, i2c_han);
    if (error) {
 80214ac:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80214ae:	2b00      	cmp	r3, #0
 80214b0:	d001      	beq.n	80214b6 <_ZN17SensirionI2CSgp4115executeSelfTestERt+0x78>
        return error;
 80214b2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80214b4:	e00b      	b.n	80214ce <_ZN17SensirionI2CSgp4115executeSelfTestERt+0x90>
    }

    error |= rxFrame.getUInt16(testResult);
 80214b6:	f107 030c 	add.w	r3, r7, #12
 80214ba:	6839      	ldr	r1, [r7, #0]
 80214bc:	4618      	mov	r0, r3
 80214be:	f000 ff6e 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 80214c2:	4603      	mov	r3, r0
 80214c4:	461a      	mov	r2, r3
 80214c6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 80214c8:	4313      	orrs	r3, r2
 80214ca:	86fb      	strh	r3, [r7, #54]	; 0x36
    return error;
 80214cc:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
 80214ce:	4618      	mov	r0, r3
 80214d0:	3738      	adds	r7, #56	; 0x38
 80214d2:	46bd      	mov	sp, r7
 80214d4:	bd80      	pop	{r7, pc}

080214d6 <_ZN17SensirionI2CSgp4115getSerialNumberEPth>:
    osDelay(1);
    return error;
}

uint16_t SensirionI2CSgp41::getSerialNumber(uint16_t serialNumber[],
                                            uint8_t serialNumberSize) {
 80214d6:	b580      	push	{r7, lr}
 80214d8:	b092      	sub	sp, #72	; 0x48
 80214da:	af02      	add	r7, sp, #8
 80214dc:	60f8      	str	r0, [r7, #12]
 80214de:	60b9      	str	r1, [r7, #8]
 80214e0:	4613      	mov	r3, r2
 80214e2:	71fb      	strb	r3, [r7, #7]
    uint16_t error;
    uint8_t buffer[9];
    SensirionI2CTxFrame txFrame =
        SensirionI2CTxFrame::createWithUInt16Command(0x3682, buffer, 9);
 80214e4:	f107 0020 	add.w	r0, r7, #32
 80214e8:	f107 0234 	add.w	r2, r7, #52	; 0x34
 80214ec:	2301      	movs	r3, #1
 80214ee:	9300      	str	r3, [sp, #0]
 80214f0:	2309      	movs	r3, #9
 80214f2:	f243 6182 	movw	r1, #13954	; 0x3682
 80214f6:	f000 fea6 	bl	8022246 <_ZN19SensirionI2CTxFrame23createWithUInt16CommandEtPhj13CrcPolynomial>

    error = SensirionI2CCommunication::sendFrame(SGP41_I2C_ADDRESS, txFrame,
 80214fa:	68fb      	ldr	r3, [r7, #12]
 80214fc:	681a      	ldr	r2, [r3, #0]
 80214fe:	f107 0320 	add.w	r3, r7, #32
 8021502:	4619      	mov	r1, r3
 8021504:	2059      	movs	r0, #89	; 0x59
 8021506:	f000 fda1 	bl	802204c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef>
 802150a:	4603      	mov	r3, r0
 802150c:	87fb      	strh	r3, [r7, #62]	; 0x3e
    		i2c_han);
    if (error) {
 802150e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021510:	2b00      	cmp	r3, #0
 8021512:	d001      	beq.n	8021518 <_ZN17SensirionI2CSgp4115getSerialNumberEPth+0x42>
        return error;
 8021514:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021516:	e041      	b.n	802159c <_ZN17SensirionI2CSgp4115getSerialNumberEPth+0xc6>
    }

    osDelay(1);
 8021518:	2001      	movs	r0, #1
 802151a:	f001 f966 	bl	80227ea <osDelay>

    SensirionI2CRxFrame rxFrame(buffer, 9);
 802151e:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8021522:	f107 0310 	add.w	r3, r7, #16
 8021526:	2209      	movs	r2, #9
 8021528:	4618      	mov	r0, r3
 802152a:	f7ff fe77 	bl	802121c <_ZN19SensirionI2CRxFrameC1EPhj>
    error = SensirionI2CCommunication::receiveFrame(SGP41_I2C_ADDRESS, 9,
 802152e:	68fb      	ldr	r3, [r7, #12]
 8021530:	681b      	ldr	r3, [r3, #0]
 8021532:	f107 0210 	add.w	r2, r7, #16
 8021536:	2101      	movs	r1, #1
 8021538:	9100      	str	r1, [sp, #0]
 802153a:	2109      	movs	r1, #9
 802153c:	2059      	movs	r0, #89	; 0x59
 802153e:	f000 fdab 	bl	8022098 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial>
 8021542:	4603      	mov	r3, r0
 8021544:	87fb      	strh	r3, [r7, #62]	; 0x3e
                                                    rxFrame, i2c_han);
    if (error) {
 8021546:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021548:	2b00      	cmp	r3, #0
 802154a:	d001      	beq.n	8021550 <_ZN17SensirionI2CSgp4115getSerialNumberEPth+0x7a>
        return error;
 802154c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 802154e:	e025      	b.n	802159c <_ZN17SensirionI2CSgp4115getSerialNumberEPth+0xc6>
    }

    error |= rxFrame.getUInt16(serialNumber[0]);
 8021550:	f107 0310 	add.w	r3, r7, #16
 8021554:	68b9      	ldr	r1, [r7, #8]
 8021556:	4618      	mov	r0, r3
 8021558:	f000 ff21 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 802155c:	4603      	mov	r3, r0
 802155e:	461a      	mov	r2, r3
 8021560:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021562:	4313      	orrs	r3, r2
 8021564:	87fb      	strh	r3, [r7, #62]	; 0x3e
    error |= rxFrame.getUInt16(serialNumber[1]);
 8021566:	68bb      	ldr	r3, [r7, #8]
 8021568:	1c9a      	adds	r2, r3, #2
 802156a:	f107 0310 	add.w	r3, r7, #16
 802156e:	4611      	mov	r1, r2
 8021570:	4618      	mov	r0, r3
 8021572:	f000 ff14 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 8021576:	4603      	mov	r3, r0
 8021578:	461a      	mov	r2, r3
 802157a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 802157c:	4313      	orrs	r3, r2
 802157e:	87fb      	strh	r3, [r7, #62]	; 0x3e
    error |= rxFrame.getUInt16(serialNumber[2]);
 8021580:	68bb      	ldr	r3, [r7, #8]
 8021582:	1d1a      	adds	r2, r3, #4
 8021584:	f107 0310 	add.w	r3, r7, #16
 8021588:	4611      	mov	r1, r2
 802158a:	4618      	mov	r0, r3
 802158c:	f000 ff07 	bl	802239e <_ZN16SensirionRxFrame9getUInt16ERt>
 8021590:	4603      	mov	r3, r0
 8021592:	461a      	mov	r2, r3
 8021594:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8021596:	4313      	orrs	r3, r2
 8021598:	87fb      	strh	r3, [r7, #62]	; 0x3e
    return error;
 802159a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
}
 802159c:	4618      	mov	r0, r3
 802159e:	3740      	adds	r7, #64	; 0x40
 80215a0:	46bd      	mov	sp, r7
 80215a2:	bd80      	pop	{r7, pc}

080215a4 <_ZSt4fmaxff>:
#endif

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }
 80215a4:	b580      	push	{r7, lr}
 80215a6:	b082      	sub	sp, #8
 80215a8:	af00      	add	r7, sp, #0
 80215aa:	ed87 0a01 	vstr	s0, [r7, #4]
 80215ae:	edc7 0a00 	vstr	s1, [r7]
 80215b2:	edd7 0a00 	vldr	s1, [r7]
 80215b6:	ed97 0a01 	vldr	s0, [r7, #4]
 80215ba:	f008 f801 	bl	80295c0 <fmaxf>
 80215be:	eef0 7a40 	vmov.f32	s15, s0
 80215c2:	eeb0 0a67 	vmov.f32	s0, s15
 80215c6:	3708      	adds	r7, #8
 80215c8:	46bd      	mov	sp, r7
 80215ca:	bd80      	pop	{r7, pc}

080215cc <_ZSt4fminff>:
#endif

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }
 80215cc:	b580      	push	{r7, lr}
 80215ce:	b082      	sub	sp, #8
 80215d0:	af00      	add	r7, sp, #0
 80215d2:	ed87 0a01 	vstr	s0, [r7, #4]
 80215d6:	edc7 0a00 	vstr	s1, [r7]
 80215da:	edd7 0a00 	vldr	s1, [r7]
 80215de:	ed97 0a01 	vldr	s0, [r7, #4]
 80215e2:	f008 f808 	bl	80295f6 <fminf>
 80215e6:	eef0 7a40 	vmov.f32	s15, s0
 80215ea:	eeb0 0a67 	vmov.f32	s0, s15
 80215ee:	3708      	adds	r7, #8
 80215f0:	46bd      	mov	sp, r7
 80215f2:	bd80      	pop	{r7, pc}

080215f4 <_ZN14Adafruit_SHT4xC1Ev>:
static uint8_t crc8(const uint8_t *data, int len);

/*!
 * @brief  SHT4x constructor
 */
Adafruit_SHT4x::Adafruit_SHT4x(void) {}
 80215f4:	b480      	push	{r7}
 80215f6:	b083      	sub	sp, #12
 80215f8:	af00      	add	r7, sp, #0
 80215fa:	6078      	str	r0, [r7, #4]
 80215fc:	687b      	ldr	r3, [r7, #4]
 80215fe:	2200      	movs	r2, #0
 8021600:	731a      	strb	r2, [r3, #12]
 8021602:	687b      	ldr	r3, [r7, #4]
 8021604:	2200      	movs	r2, #0
 8021606:	611a      	str	r2, [r3, #16]
 8021608:	687b      	ldr	r3, [r7, #4]
 802160a:	2200      	movs	r2, #0
 802160c:	615a      	str	r2, [r3, #20]
 802160e:	687b      	ldr	r3, [r7, #4]
 8021610:	2200      	movs	r2, #0
 8021612:	619a      	str	r2, [r3, #24]
 8021614:	687b      	ldr	r3, [r7, #4]
 8021616:	2200      	movs	r2, #0
 8021618:	771a      	strb	r2, [r3, #28]
 802161a:	687b      	ldr	r3, [r7, #4]
 802161c:	2200      	movs	r2, #0
 802161e:	775a      	strb	r2, [r3, #29]
 8021620:	687b      	ldr	r3, [r7, #4]
 8021622:	4618      	mov	r0, r3
 8021624:	370c      	adds	r7, #12
 8021626:	46bd      	mov	sp, r7
 8021628:	f85d 7b04 	ldr.w	r7, [sp], #4
 802162c:	4770      	bx	lr

0802162e <_ZN14Adafruit_SHT4xD1Ev>:

/*!
 * @brief  SHT4x destructor
 */
Adafruit_SHT4x::~Adafruit_SHT4x(void) {
 802162e:	b580      	push	{r7, lr}
 8021630:	b082      	sub	sp, #8
 8021632:	af00      	add	r7, sp, #0
 8021634:	6078      	str	r0, [r7, #4]
  if (temp_sensor) {
 8021636:	687b      	ldr	r3, [r7, #4]
 8021638:	695b      	ldr	r3, [r3, #20]
 802163a:	2b00      	cmp	r3, #0
 802163c:	d008      	beq.n	8021650 <_ZN14Adafruit_SHT4xD1Ev+0x22>
    delete temp_sensor;
 802163e:	687b      	ldr	r3, [r7, #4]
 8021640:	695b      	ldr	r3, [r3, #20]
 8021642:	2b00      	cmp	r3, #0
 8021644:	d004      	beq.n	8021650 <_ZN14Adafruit_SHT4xD1Ev+0x22>
 8021646:	681a      	ldr	r2, [r3, #0]
 8021648:	3204      	adds	r2, #4
 802164a:	6812      	ldr	r2, [r2, #0]
 802164c:	4618      	mov	r0, r3
 802164e:	4790      	blx	r2
  }
  if (humidity_sensor) {
 8021650:	687b      	ldr	r3, [r7, #4]
 8021652:	699b      	ldr	r3, [r3, #24]
 8021654:	2b00      	cmp	r3, #0
 8021656:	d008      	beq.n	802166a <_ZN14Adafruit_SHT4xD1Ev+0x3c>
    delete humidity_sensor;
 8021658:	687b      	ldr	r3, [r7, #4]
 802165a:	699b      	ldr	r3, [r3, #24]
 802165c:	2b00      	cmp	r3, #0
 802165e:	d004      	beq.n	802166a <_ZN14Adafruit_SHT4xD1Ev+0x3c>
 8021660:	681a      	ldr	r2, [r3, #0]
 8021662:	3204      	adds	r2, #4
 8021664:	6812      	ldr	r2, [r2, #0]
 8021666:	4618      	mov	r0, r3
 8021668:	4790      	blx	r2
  }
}
 802166a:	687b      	ldr	r3, [r7, #4]
 802166c:	4618      	mov	r0, r3
 802166e:	3708      	adds	r7, #8
 8021670:	46bd      	mov	sp, r7
 8021672:	bd80      	pop	{r7, pc}

08021674 <_ZN14Adafruit_SHT4x5beginEP19__I2C_HandleTypeDef>:
 *
 * @param theWire   The I2C bus to use, defaults to &Wire
 *
 * @return True if initialisation was successful, otherwise False.
 */
bool Adafruit_SHT4x::begin(I2C_HandleTypeDef *i2c_handle) {
 8021674:	b580      	push	{r7, lr}
 8021676:	b082      	sub	sp, #8
 8021678:	af00      	add	r7, sp, #0
 802167a:	6078      	str	r0, [r7, #4]
 802167c:	6039      	str	r1, [r7, #0]

  i2c_han = i2c_handle;
 802167e:	687b      	ldr	r3, [r7, #4]
 8021680:	683a      	ldr	r2, [r7, #0]
 8021682:	611a      	str	r2, [r3, #16]
  i2c_addr = SHT4x_DEFAULT_ADDR << 1;
 8021684:	687b      	ldr	r3, [r7, #4]
 8021686:	2288      	movs	r2, #136	; 0x88
 8021688:	731a      	strb	r2, [r3, #12]

  if (!reset()) {
 802168a:	6878      	ldr	r0, [r7, #4]
 802168c:	f000 f80d 	bl	80216aa <_ZN14Adafruit_SHT4x5resetEv>
 8021690:	4603      	mov	r3, r0
 8021692:	f083 0301 	eor.w	r3, r3, #1
 8021696:	b2db      	uxtb	r3, r3
 8021698:	2b00      	cmp	r3, #0
 802169a:	d001      	beq.n	80216a0 <_ZN14Adafruit_SHT4x5beginEP19__I2C_HandleTypeDef+0x2c>
    return false;
 802169c:	2300      	movs	r3, #0
 802169e:	e000      	b.n	80216a2 <_ZN14Adafruit_SHT4x5beginEP19__I2C_HandleTypeDef+0x2e>
  }

//  humidity_sensor = new Adafruit_SHT4x_Humidity(this);
//  temp_sensor = new Adafruit_SHT4x_Temp(this);
  return true;
 80216a0:	2301      	movs	r3, #1
}
 80216a2:	4618      	mov	r0, r3
 80216a4:	3708      	adds	r7, #8
 80216a6:	46bd      	mov	sp, r7
 80216a8:	bd80      	pop	{r7, pc}

080216aa <_ZN14Adafruit_SHT4x5resetEv>:

/**
 * Performs a soft reset of the sensor to put it into a known state.
 * @returns True on success, false if could not communicate with chip
 */
bool Adafruit_SHT4x::reset(void) {
 80216aa:	b580      	push	{r7, lr}
 80216ac:	b084      	sub	sp, #16
 80216ae:	af00      	add	r7, sp, #0
 80216b0:	6078      	str	r0, [r7, #4]
  uint8_t cmd = SHT4x_SOFTRESET;
 80216b2:	2394      	movs	r3, #148	; 0x94
 80216b4:	73fb      	strb	r3, [r7, #15]
  if (!write(&cmd, 1)) {
 80216b6:	f107 030f 	add.w	r3, r7, #15
 80216ba:	2201      	movs	r2, #1
 80216bc:	4619      	mov	r1, r3
 80216be:	6878      	ldr	r0, [r7, #4]
 80216c0:	f000 f924 	bl	802190c <_ZN14Adafruit_SHT4x5writeEPhh>
 80216c4:	4603      	mov	r3, r0
 80216c6:	f083 0301 	eor.w	r3, r3, #1
 80216ca:	b2db      	uxtb	r3, r3
 80216cc:	2b00      	cmp	r3, #0
 80216ce:	d001      	beq.n	80216d4 <_ZN14Adafruit_SHT4x5resetEv+0x2a>
    return false;
 80216d0:	2300      	movs	r3, #0
 80216d2:	e003      	b.n	80216dc <_ZN14Adafruit_SHT4x5resetEv+0x32>
  }
  osDelay(1);
 80216d4:	2001      	movs	r0, #1
 80216d6:	f001 f888 	bl	80227ea <osDelay>
  return true;
 80216da:	2301      	movs	r3, #1
}
 80216dc:	4618      	mov	r0, r3
 80216de:	3710      	adds	r7, #16
 80216e0:	46bd      	mov	sp, r7
 80216e2:	bd80      	pop	{r7, pc}

080216e4 <_ZN14Adafruit_SHT4x12setPrecisionE17sht4x_precision_t>:
/*!
    @brief  Sets the precision rating - more precise takes longer!
    @param  prec The desired precision setting, will be used during reads
*/
/**************************************************************************/
void Adafruit_SHT4x::setPrecision(sht4x_precision_t prec) { _precision = prec; }
 80216e4:	b480      	push	{r7}
 80216e6:	b083      	sub	sp, #12
 80216e8:	af00      	add	r7, sp, #0
 80216ea:	6078      	str	r0, [r7, #4]
 80216ec:	460b      	mov	r3, r1
 80216ee:	70fb      	strb	r3, [r7, #3]
 80216f0:	687b      	ldr	r3, [r7, #4]
 80216f2:	78fa      	ldrb	r2, [r7, #3]
 80216f4:	771a      	strb	r2, [r3, #28]
 80216f6:	bf00      	nop
 80216f8:	370c      	adds	r7, #12
 80216fa:	46bd      	mov	sp, r7
 80216fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021700:	4770      	bx	lr

08021702 <_ZN14Adafruit_SHT4x9setHeaterE14sht4x_heater_t>:
    @brief  Sets the heating setting - more heating uses more power and takes
   longer
    @param  heat The desired heater setting, will be used during reads
*/
/**************************************************************************/
void Adafruit_SHT4x::setHeater(sht4x_heater_t heat) { _heater = heat; }
 8021702:	b480      	push	{r7}
 8021704:	b083      	sub	sp, #12
 8021706:	af00      	add	r7, sp, #0
 8021708:	6078      	str	r0, [r7, #4]
 802170a:	460b      	mov	r3, r1
 802170c:	70fb      	strb	r3, [r7, #3]
 802170e:	687b      	ldr	r3, [r7, #4]
 8021710:	78fa      	ldrb	r2, [r7, #3]
 8021712:	775a      	strb	r2, [r3, #29]
 8021714:	bf00      	nop
 8021716:	370c      	adds	r7, #12
 8021718:	46bd      	mov	sp, r7
 802171a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802171e:	4770      	bx	lr

08021720 <_ZN14Adafruit_SHT4x8getEventEv>:
   data
    @param  temp Sensor event object that will be populated with temp data
    @returns true if the event data was read successfully
*/
/**************************************************************************/
bool Adafruit_SHT4x::getEvent(void) {
 8021720:	b590      	push	{r4, r7, lr}
 8021722:	b08b      	sub	sp, #44	; 0x2c
 8021724:	af00      	add	r7, sp, #0
 8021726:	6078      	str	r0, [r7, #4]
  uint32_t t = HAL_GetTick();
 8021728:	f7eb f9ae 	bl	800ca88 <HAL_GetTick>
 802172c:	6238      	str	r0, [r7, #32]

  uint8_t readbuffer[6];
  uint8_t cmd = SHT4x_NOHEAT_HIGHPRECISION;
 802172e:	23fd      	movs	r3, #253	; 0xfd
 8021730:	73fb      	strb	r3, [r7, #15]
  uint16_t duration = 10;
 8021732:	230a      	movs	r3, #10
 8021734:	84fb      	strh	r3, [r7, #38]	; 0x26

  if (_heater == SHT4X_NO_HEATER) {
 8021736:	687b      	ldr	r3, [r7, #4]
 8021738:	7f5b      	ldrb	r3, [r3, #29]
 802173a:	2b00      	cmp	r3, #0
 802173c:	d117      	bne.n	802176e <_ZN14Adafruit_SHT4x8getEventEv+0x4e>
    if (_precision == SHT4X_HIGH_PRECISION) {
 802173e:	687b      	ldr	r3, [r7, #4]
 8021740:	7f1b      	ldrb	r3, [r3, #28]
 8021742:	2b00      	cmp	r3, #0
 8021744:	d103      	bne.n	802174e <_ZN14Adafruit_SHT4x8getEventEv+0x2e>
      cmd = SHT4x_NOHEAT_HIGHPRECISION;
 8021746:	23fd      	movs	r3, #253	; 0xfd
 8021748:	73fb      	strb	r3, [r7, #15]
      duration = 10;
 802174a:	230a      	movs	r3, #10
 802174c:	84fb      	strh	r3, [r7, #38]	; 0x26
    }
    if (_precision == SHT4X_MED_PRECISION) {
 802174e:	687b      	ldr	r3, [r7, #4]
 8021750:	7f1b      	ldrb	r3, [r3, #28]
 8021752:	2b01      	cmp	r3, #1
 8021754:	d103      	bne.n	802175e <_ZN14Adafruit_SHT4x8getEventEv+0x3e>
      cmd = SHT4x_NOHEAT_MEDPRECISION;
 8021756:	23f6      	movs	r3, #246	; 0xf6
 8021758:	73fb      	strb	r3, [r7, #15]
      duration = 5;
 802175a:	2305      	movs	r3, #5
 802175c:	84fb      	strh	r3, [r7, #38]	; 0x26
    }
    if (_precision == SHT4X_LOW_PRECISION) {
 802175e:	687b      	ldr	r3, [r7, #4]
 8021760:	7f1b      	ldrb	r3, [r3, #28]
 8021762:	2b02      	cmp	r3, #2
 8021764:	d103      	bne.n	802176e <_ZN14Adafruit_SHT4x8getEventEv+0x4e>
      cmd = SHT4x_NOHEAT_LOWPRECISION;
 8021766:	23e0      	movs	r3, #224	; 0xe0
 8021768:	73fb      	strb	r3, [r7, #15]
      duration = 2;
 802176a:	2302      	movs	r3, #2
 802176c:	84fb      	strh	r3, [r7, #38]	; 0x26
    }
  }

  if (_heater == SHT4X_HIGH_HEATER_1S) {
 802176e:	687b      	ldr	r3, [r7, #4]
 8021770:	7f5b      	ldrb	r3, [r3, #29]
 8021772:	2b01      	cmp	r3, #1
 8021774:	d104      	bne.n	8021780 <_ZN14Adafruit_SHT4x8getEventEv+0x60>
    cmd = SHT4x_HIGHHEAT_1S;
 8021776:	2339      	movs	r3, #57	; 0x39
 8021778:	73fb      	strb	r3, [r7, #15]
    duration = 1100;
 802177a:	f240 434c 	movw	r3, #1100	; 0x44c
 802177e:	84fb      	strh	r3, [r7, #38]	; 0x26
  }
  if (_heater == SHT4X_HIGH_HEATER_100MS) {
 8021780:	687b      	ldr	r3, [r7, #4]
 8021782:	7f5b      	ldrb	r3, [r3, #29]
 8021784:	2b02      	cmp	r3, #2
 8021786:	d103      	bne.n	8021790 <_ZN14Adafruit_SHT4x8getEventEv+0x70>
    cmd = SHT4x_HIGHHEAT_100MS;
 8021788:	2332      	movs	r3, #50	; 0x32
 802178a:	73fb      	strb	r3, [r7, #15]
    duration = 110;
 802178c:	236e      	movs	r3, #110	; 0x6e
 802178e:	84fb      	strh	r3, [r7, #38]	; 0x26
  }

  if (_heater == SHT4X_MED_HEATER_1S) {
 8021790:	687b      	ldr	r3, [r7, #4]
 8021792:	7f5b      	ldrb	r3, [r3, #29]
 8021794:	2b03      	cmp	r3, #3
 8021796:	d104      	bne.n	80217a2 <_ZN14Adafruit_SHT4x8getEventEv+0x82>
    cmd = SHT4x_MEDHEAT_1S;
 8021798:	232f      	movs	r3, #47	; 0x2f
 802179a:	73fb      	strb	r3, [r7, #15]
    duration = 1100;
 802179c:	f240 434c 	movw	r3, #1100	; 0x44c
 80217a0:	84fb      	strh	r3, [r7, #38]	; 0x26
  }
  if (_heater == SHT4X_MED_HEATER_100MS) {
 80217a2:	687b      	ldr	r3, [r7, #4]
 80217a4:	7f5b      	ldrb	r3, [r3, #29]
 80217a6:	2b04      	cmp	r3, #4
 80217a8:	d103      	bne.n	80217b2 <_ZN14Adafruit_SHT4x8getEventEv+0x92>
    cmd = SHT4x_MEDHEAT_100MS;
 80217aa:	2324      	movs	r3, #36	; 0x24
 80217ac:	73fb      	strb	r3, [r7, #15]
    duration = 110;
 80217ae:	236e      	movs	r3, #110	; 0x6e
 80217b0:	84fb      	strh	r3, [r7, #38]	; 0x26
  }

  if (_heater == SHT4X_LOW_HEATER_1S) {
 80217b2:	687b      	ldr	r3, [r7, #4]
 80217b4:	7f5b      	ldrb	r3, [r3, #29]
 80217b6:	2b05      	cmp	r3, #5
 80217b8:	d104      	bne.n	80217c4 <_ZN14Adafruit_SHT4x8getEventEv+0xa4>
    cmd = SHT4x_LOWHEAT_1S;
 80217ba:	231e      	movs	r3, #30
 80217bc:	73fb      	strb	r3, [r7, #15]
    duration = 1100;
 80217be:	f240 434c 	movw	r3, #1100	; 0x44c
 80217c2:	84fb      	strh	r3, [r7, #38]	; 0x26
  }
  if (_heater == SHT4X_LOW_HEATER_100MS) {
 80217c4:	687b      	ldr	r3, [r7, #4]
 80217c6:	7f5b      	ldrb	r3, [r3, #29]
 80217c8:	2b06      	cmp	r3, #6
 80217ca:	d103      	bne.n	80217d4 <_ZN14Adafruit_SHT4x8getEventEv+0xb4>
    cmd = SHT4x_LOWHEAT_100MS;
 80217cc:	2315      	movs	r3, #21
 80217ce:	73fb      	strb	r3, [r7, #15]
    duration = 110;
 80217d0:	236e      	movs	r3, #110	; 0x6e
 80217d2:	84fb      	strh	r3, [r7, #38]	; 0x26
  }

  if (!write(&cmd, 1)) {
 80217d4:	f107 030f 	add.w	r3, r7, #15
 80217d8:	2201      	movs	r2, #1
 80217da:	4619      	mov	r1, r3
 80217dc:	6878      	ldr	r0, [r7, #4]
 80217de:	f000 f895 	bl	802190c <_ZN14Adafruit_SHT4x5writeEPhh>
 80217e2:	4603      	mov	r3, r0
 80217e4:	f083 0301 	eor.w	r3, r3, #1
 80217e8:	b2db      	uxtb	r3, r3
 80217ea:	2b00      	cmp	r3, #0
 80217ec:	d001      	beq.n	80217f2 <_ZN14Adafruit_SHT4x8getEventEv+0xd2>
    return false;
 80217ee:	2300      	movs	r3, #0
 80217f0:	e07b      	b.n	80218ea <_ZN14Adafruit_SHT4x8getEventEv+0x1ca>
  }
  osDelay(duration);
 80217f2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80217f4:	4618      	mov	r0, r3
 80217f6:	f000 fff8 	bl	80227ea <osDelay>
  if (!read(readbuffer, 6)) {
 80217fa:	f107 0310 	add.w	r3, r7, #16
 80217fe:	2206      	movs	r2, #6
 8021800:	4619      	mov	r1, r3
 8021802:	6878      	ldr	r0, [r7, #4]
 8021804:	f000 f8a4 	bl	8021950 <_ZN14Adafruit_SHT4x4readEPhh>
 8021808:	4603      	mov	r3, r0
 802180a:	f083 0301 	eor.w	r3, r3, #1
 802180e:	b2db      	uxtb	r3, r3
 8021810:	2b00      	cmp	r3, #0
 8021812:	d001      	beq.n	8021818 <_ZN14Adafruit_SHT4x8getEventEv+0xf8>
    return false;
 8021814:	2300      	movs	r3, #0
 8021816:	e068      	b.n	80218ea <_ZN14Adafruit_SHT4x8getEventEv+0x1ca>
  }

  if (readbuffer[2] != crc8(readbuffer, 2) ||
 8021818:	7cbc      	ldrb	r4, [r7, #18]
 802181a:	f107 0310 	add.w	r3, r7, #16
 802181e:	2102      	movs	r1, #2
 8021820:	4618      	mov	r0, r3
 8021822:	f000 f8b7 	bl	8021994 <_ZL4crc8PKhi>
 8021826:	4603      	mov	r3, r0
 8021828:	429c      	cmp	r4, r3
 802182a:	d10a      	bne.n	8021842 <_ZN14Adafruit_SHT4x8getEventEv+0x122>
      readbuffer[5] != crc8(readbuffer + 3, 2))
 802182c:	7d7c      	ldrb	r4, [r7, #21]
 802182e:	f107 0310 	add.w	r3, r7, #16
 8021832:	3303      	adds	r3, #3
 8021834:	2102      	movs	r1, #2
 8021836:	4618      	mov	r0, r3
 8021838:	f000 f8ac 	bl	8021994 <_ZL4crc8PKhi>
 802183c:	4603      	mov	r3, r0
  if (readbuffer[2] != crc8(readbuffer, 2) ||
 802183e:	429c      	cmp	r4, r3
 8021840:	d001      	beq.n	8021846 <_ZN14Adafruit_SHT4x8getEventEv+0x126>
 8021842:	2301      	movs	r3, #1
 8021844:	e000      	b.n	8021848 <_ZN14Adafruit_SHT4x8getEventEv+0x128>
 8021846:	2300      	movs	r3, #0
 8021848:	2b00      	cmp	r3, #0
 802184a:	d001      	beq.n	8021850 <_ZN14Adafruit_SHT4x8getEventEv+0x130>
    return false;
 802184c:	2300      	movs	r3, #0
 802184e:	e04c      	b.n	80218ea <_ZN14Adafruit_SHT4x8getEventEv+0x1ca>

  float t_ticks = (uint16_t)readbuffer[0] * 256 + (uint16_t)readbuffer[1];
 8021850:	7c3b      	ldrb	r3, [r7, #16]
 8021852:	021b      	lsls	r3, r3, #8
 8021854:	7c7a      	ldrb	r2, [r7, #17]
 8021856:	4413      	add	r3, r2
 8021858:	ee07 3a90 	vmov	s15, r3
 802185c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8021860:	edc7 7a07 	vstr	s15, [r7, #28]
  float rh_ticks = (uint16_t)readbuffer[3] * 256 + (uint16_t)readbuffer[4];
 8021864:	7cfb      	ldrb	r3, [r7, #19]
 8021866:	021b      	lsls	r3, r3, #8
 8021868:	7d3a      	ldrb	r2, [r7, #20]
 802186a:	4413      	add	r3, r2
 802186c:	ee07 3a90 	vmov	s15, r3
 8021870:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8021874:	edc7 7a06 	vstr	s15, [r7, #24]
  _temperature = -45 + 175 * t_ticks / 65535;
 8021878:	edd7 7a07 	vldr	s15, [r7, #28]
 802187c:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 80218f4 <_ZN14Adafruit_SHT4x8getEventEv+0x1d4>
 8021880:	ee27 7a87 	vmul.f32	s14, s15, s14
 8021884:	eddf 6a1c 	vldr	s13, [pc, #112]	; 80218f8 <_ZN14Adafruit_SHT4x8getEventEv+0x1d8>
 8021888:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802188c:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80218fc <_ZN14Adafruit_SHT4x8getEventEv+0x1dc>
 8021890:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8021894:	687b      	ldr	r3, [r7, #4]
 8021896:	edc3 7a00 	vstr	s15, [r3]
  _humidity = -6 + 125 * rh_ticks / 65535;
 802189a:	edd7 7a06 	vldr	s15, [r7, #24]
 802189e:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8021900 <_ZN14Adafruit_SHT4x8getEventEv+0x1e0>
 80218a2:	ee27 7a87 	vmul.f32	s14, s15, s14
 80218a6:	eddf 6a14 	vldr	s13, [pc, #80]	; 80218f8 <_ZN14Adafruit_SHT4x8getEventEv+0x1d8>
 80218aa:	eec7 7a26 	vdiv.f32	s15, s14, s13
 80218ae:	eeb1 7a08 	vmov.f32	s14, #24	; 0x40c00000  6.0
 80218b2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80218b6:	687b      	ldr	r3, [r7, #4]
 80218b8:	edc3 7a01 	vstr	s15, [r3, #4]

  _humidity = fmin(fmax(_humidity, (float)0.0), (float)100.0);
 80218bc:	687b      	ldr	r3, [r7, #4]
 80218be:	edd3 7a01 	vldr	s15, [r3, #4]
 80218c2:	eddf 0a10 	vldr	s1, [pc, #64]	; 8021904 <_ZN14Adafruit_SHT4x8getEventEv+0x1e4>
 80218c6:	eeb0 0a67 	vmov.f32	s0, s15
 80218ca:	f7ff fe6b 	bl	80215a4 <_ZSt4fmaxff>
 80218ce:	eef0 7a40 	vmov.f32	s15, s0
 80218d2:	eddf 0a0d 	vldr	s1, [pc, #52]	; 8021908 <_ZN14Adafruit_SHT4x8getEventEv+0x1e8>
 80218d6:	eeb0 0a67 	vmov.f32	s0, s15
 80218da:	f7ff fe77 	bl	80215cc <_ZSt4fminff>
 80218de:	eef0 7a40 	vmov.f32	s15, s0
 80218e2:	687b      	ldr	r3, [r7, #4]
 80218e4:	edc3 7a01 	vstr	s15, [r3, #4]
  // use helpers to fill in the events
//  if (temp)
//    fillTempEvent(temp, t);
//  if (humidity)
//    fillHumidityEvent(humidity, t);
  return true;
 80218e8:	2301      	movs	r3, #1
}
 80218ea:	4618      	mov	r0, r3
 80218ec:	372c      	adds	r7, #44	; 0x2c
 80218ee:	46bd      	mov	sp, r7
 80218f0:	bd90      	pop	{r4, r7, pc}
 80218f2:	bf00      	nop
 80218f4:	432f0000 	.word	0x432f0000
 80218f8:	477fff00 	.word	0x477fff00
 80218fc:	42340000 	.word	0x42340000
 8021900:	42fa0000 	.word	0x42fa0000
 8021904:	00000000 	.word	0x00000000
 8021908:	42c80000 	.word	0x42c80000

0802190c <_ZN14Adafruit_SHT4x5writeEPhh>:
  write(cmd, 2);

  return read(buffer, num_bytes);
}

bool Adafruit_SHT4x::write(uint8_t *data, uint8_t size) {
 802190c:	b580      	push	{r7, lr}
 802190e:	b086      	sub	sp, #24
 8021910:	af02      	add	r7, sp, #8
 8021912:	60f8      	str	r0, [r7, #12]
 8021914:	60b9      	str	r1, [r7, #8]
 8021916:	4613      	mov	r3, r2
 8021918:	71fb      	strb	r3, [r7, #7]
	if (HAL_OK
			== HAL_I2C_Master_Transmit(i2c_han, i2c_addr, data, size, I2C_TIMEOUT)) {
 802191a:	68fb      	ldr	r3, [r7, #12]
 802191c:	6918      	ldr	r0, [r3, #16]
 802191e:	68fb      	ldr	r3, [r7, #12]
 8021920:	7b1b      	ldrb	r3, [r3, #12]
 8021922:	b299      	uxth	r1, r3
 8021924:	79fb      	ldrb	r3, [r7, #7]
 8021926:	b29b      	uxth	r3, r3
 8021928:	220a      	movs	r2, #10
 802192a:	9200      	str	r2, [sp, #0]
 802192c:	68ba      	ldr	r2, [r7, #8]
 802192e:	f7ec fce7 	bl	800e300 <HAL_I2C_Master_Transmit>
 8021932:	4603      	mov	r3, r0
 8021934:	2b00      	cmp	r3, #0
 8021936:	bf0c      	ite	eq
 8021938:	2301      	moveq	r3, #1
 802193a:	2300      	movne	r3, #0
 802193c:	b2db      	uxtb	r3, r3
	if (HAL_OK
 802193e:	2b00      	cmp	r3, #0
 8021940:	d001      	beq.n	8021946 <_ZN14Adafruit_SHT4x5writeEPhh+0x3a>
		return true;
 8021942:	2301      	movs	r3, #1
 8021944:	e000      	b.n	8021948 <_ZN14Adafruit_SHT4x5writeEPhh+0x3c>
	} else {
		return false;
 8021946:	2300      	movs	r3, #0
	}
}
 8021948:	4618      	mov	r0, r3
 802194a:	3710      	adds	r7, #16
 802194c:	46bd      	mov	sp, r7
 802194e:	bd80      	pop	{r7, pc}

08021950 <_ZN14Adafruit_SHT4x4readEPhh>:

bool Adafruit_SHT4x::read(uint8_t *data, uint8_t size) {
 8021950:	b580      	push	{r7, lr}
 8021952:	b086      	sub	sp, #24
 8021954:	af02      	add	r7, sp, #8
 8021956:	60f8      	str	r0, [r7, #12]
 8021958:	60b9      	str	r1, [r7, #8]
 802195a:	4613      	mov	r3, r2
 802195c:	71fb      	strb	r3, [r7, #7]
	if (HAL_OK
			== HAL_I2C_Master_Receive(i2c_han, i2c_addr, data, size, I2C_TIMEOUT)) {
 802195e:	68fb      	ldr	r3, [r7, #12]
 8021960:	6918      	ldr	r0, [r3, #16]
 8021962:	68fb      	ldr	r3, [r7, #12]
 8021964:	7b1b      	ldrb	r3, [r3, #12]
 8021966:	b299      	uxth	r1, r3
 8021968:	79fb      	ldrb	r3, [r7, #7]
 802196a:	b29b      	uxth	r3, r3
 802196c:	220a      	movs	r2, #10
 802196e:	9200      	str	r2, [sp, #0]
 8021970:	68ba      	ldr	r2, [r7, #8]
 8021972:	f7ec fdb9 	bl	800e4e8 <HAL_I2C_Master_Receive>
 8021976:	4603      	mov	r3, r0
 8021978:	2b00      	cmp	r3, #0
 802197a:	bf0c      	ite	eq
 802197c:	2301      	moveq	r3, #1
 802197e:	2300      	movne	r3, #0
 8021980:	b2db      	uxtb	r3, r3
	if (HAL_OK
 8021982:	2b00      	cmp	r3, #0
 8021984:	d001      	beq.n	802198a <_ZN14Adafruit_SHT4x4readEPhh+0x3a>
		return true;
 8021986:	2301      	movs	r3, #1
 8021988:	e000      	b.n	802198c <_ZN14Adafruit_SHT4x4readEPhh+0x3c>
	} else {
		return false;
 802198a:	2300      	movs	r3, #0
	}
}
 802198c:	4618      	mov	r0, r3
 802198e:	3710      	adds	r7, #16
 8021990:	46bd      	mov	sp, r7
 8021992:	bd80      	pop	{r7, pc}

08021994 <_ZL4crc8PKhi>:
 * @param data  Pointer to the data to use when calculating the CRC8.
 * @param len   The number of bytes in 'data'.
 *
 * @return The computed CRC8 value.
 */
static uint8_t crc8(const uint8_t *data, int len) {
 8021994:	b480      	push	{r7}
 8021996:	b087      	sub	sp, #28
 8021998:	af00      	add	r7, sp, #0
 802199a:	6078      	str	r0, [r7, #4]
 802199c:	6039      	str	r1, [r7, #0]
   * Initialization data 0xFF
   * Polynomial 0x31 (x8 + x5 +x4 +1)
   * Final XOR 0x00
   */

  const uint8_t POLYNOMIAL(0x31);
 802199e:	2331      	movs	r3, #49	; 0x31
 80219a0:	72fb      	strb	r3, [r7, #11]
  uint8_t crc(0xFF);
 80219a2:	23ff      	movs	r3, #255	; 0xff
 80219a4:	75fb      	strb	r3, [r7, #23]

  for (int j = len; j; --j) {
 80219a6:	683b      	ldr	r3, [r7, #0]
 80219a8:	613b      	str	r3, [r7, #16]
 80219aa:	693b      	ldr	r3, [r7, #16]
 80219ac:	2b00      	cmp	r3, #0
 80219ae:	d023      	beq.n	80219f8 <_ZL4crc8PKhi+0x64>
    crc ^= *data++;
 80219b0:	687b      	ldr	r3, [r7, #4]
 80219b2:	1c5a      	adds	r2, r3, #1
 80219b4:	607a      	str	r2, [r7, #4]
 80219b6:	781a      	ldrb	r2, [r3, #0]
 80219b8:	7dfb      	ldrb	r3, [r7, #23]
 80219ba:	4053      	eors	r3, r2
 80219bc:	75fb      	strb	r3, [r7, #23]

    for (int i = 8; i; --i) {
 80219be:	2308      	movs	r3, #8
 80219c0:	60fb      	str	r3, [r7, #12]
 80219c2:	68fb      	ldr	r3, [r7, #12]
 80219c4:	2b00      	cmp	r3, #0
 80219c6:	d013      	beq.n	80219f0 <_ZL4crc8PKhi+0x5c>
      crc = (crc & 0x80) ? (crc << 1) ^ POLYNOMIAL : (crc << 1);
 80219c8:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80219cc:	2b00      	cmp	r3, #0
 80219ce:	da07      	bge.n	80219e0 <_ZL4crc8PKhi+0x4c>
 80219d0:	7dfb      	ldrb	r3, [r7, #23]
 80219d2:	005b      	lsls	r3, r3, #1
 80219d4:	b25b      	sxtb	r3, r3
 80219d6:	f083 0331 	eor.w	r3, r3, #49	; 0x31
 80219da:	b25b      	sxtb	r3, r3
 80219dc:	b2db      	uxtb	r3, r3
 80219de:	e002      	b.n	80219e6 <_ZL4crc8PKhi+0x52>
 80219e0:	7dfb      	ldrb	r3, [r7, #23]
 80219e2:	005b      	lsls	r3, r3, #1
 80219e4:	b2db      	uxtb	r3, r3
 80219e6:	75fb      	strb	r3, [r7, #23]
    for (int i = 8; i; --i) {
 80219e8:	68fb      	ldr	r3, [r7, #12]
 80219ea:	3b01      	subs	r3, #1
 80219ec:	60fb      	str	r3, [r7, #12]
 80219ee:	e7e8      	b.n	80219c2 <_ZL4crc8PKhi+0x2e>
  for (int j = len; j; --j) {
 80219f0:	693b      	ldr	r3, [r7, #16]
 80219f2:	3b01      	subs	r3, #1
 80219f4:	613b      	str	r3, [r7, #16]
 80219f6:	e7d8      	b.n	80219aa <_ZL4crc8PKhi+0x16>
    }
  }
  return crc;
 80219f8:	7dfb      	ldrb	r3, [r7, #23]
}
 80219fa:	4618      	mov	r0, r3
 80219fc:	371c      	adds	r7, #28
 80219fe:	46bd      	mov	sp, r7
 8021a00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a04:	4770      	bx	lr
	...

08021a08 <_ZN7TSL2772C1Ev>:
#define TSL27721_CMD_NORMAL				CMD_REG_W | CMD_REG_TYPE_AUTO_INC
/**
 * @brief Construct a new TSL2772::TSL2772 object
 *
 */
TSL2772::TSL2772(void) {
 8021a08:	b480      	push	{r7}
 8021a0a:	b083      	sub	sp, #12
 8021a0c:	af00      	add	r7, sp, #0
 8021a0e:	6078      	str	r0, [r7, #4]
 8021a10:	687b      	ldr	r3, [r7, #4]
 8021a12:	2200      	movs	r2, #0
 8021a14:	601a      	str	r2, [r3, #0]
 8021a16:	687b      	ldr	r3, [r7, #4]
 8021a18:	2200      	movs	r2, #0
 8021a1a:	711a      	strb	r2, [r3, #4]
 8021a1c:	687b      	ldr	r3, [r7, #4]
 8021a1e:	2200      	movs	r2, #0
 8021a20:	729a      	strb	r2, [r3, #10]
 8021a22:	687b      	ldr	r3, [r7, #4]
 8021a24:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8021a28:	60da      	str	r2, [r3, #12]
 8021a2a:	687b      	ldr	r3, [r7, #4]
 8021a2c:	4a05      	ldr	r2, [pc, #20]	; (8021a44 <_ZN7TSL2772C1Ev+0x3c>)
 8021a2e:	611a      	str	r2, [r3, #16]
 8021a30:	687b      	ldr	r3, [r7, #4]
 8021a32:	2201      	movs	r2, #1
 8021a34:	615a      	str	r2, [r3, #20]
}
 8021a36:	687b      	ldr	r3, [r7, #4]
 8021a38:	4618      	mov	r0, r3
 8021a3a:	370c      	adds	r7, #12
 8021a3c:	46bd      	mov	sp, r7
 8021a3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a42:	4770      	bx	lr
 8021a44:	402eb852 	.word	0x402eb852

08021a48 <_ZN7TSL2772D1Ev>:

/**
 * @brief Destroy the TSL2772::TSL2772 object
 *
 */
TSL2772::~TSL2772(void) {
 8021a48:	b480      	push	{r7}
 8021a4a:	b083      	sub	sp, #12
 8021a4c:	af00      	add	r7, sp, #0
 8021a4e:	6078      	str	r0, [r7, #4]
}
 8021a50:	687b      	ldr	r3, [r7, #4]
 8021a52:	4618      	mov	r0, r3
 8021a54:	370c      	adds	r7, #12
 8021a56:	46bd      	mov	sp, r7
 8021a58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a5c:	4770      	bx	lr

08021a5e <_ZN7TSL27725beginEhP19__I2C_HandleTypeDef>:
 *            The Wire object to be used for I2C connections.
 *    @param  sensor_id
 *            The unique ID to differentiate the sensors from others
 *    @return True if initialization was successful, otherwise false.
 */
bool TSL2772::begin(uint8_t i2c_address, I2C_HandleTypeDef *i2c_handle) {
 8021a5e:	b580      	push	{r7, lr}
 8021a60:	b084      	sub	sp, #16
 8021a62:	af00      	add	r7, sp, #0
 8021a64:	60f8      	str	r0, [r7, #12]
 8021a66:	460b      	mov	r3, r1
 8021a68:	607a      	str	r2, [r7, #4]
 8021a6a:	72fb      	strb	r3, [r7, #11]

	i2c_han = i2c_handle;
 8021a6c:	68fb      	ldr	r3, [r7, #12]
 8021a6e:	687a      	ldr	r2, [r7, #4]
 8021a70:	601a      	str	r2, [r3, #0]
	i2c_addr = i2c_address << 1;
 8021a72:	7afb      	ldrb	r3, [r7, #11]
 8021a74:	005b      	lsls	r3, r3, #1
 8021a76:	b2da      	uxtb	r2, r3
 8021a78:	68fb      	ldr	r3, [r7, #12]
 8021a7a:	711a      	strb	r2, [r3, #4]

	return _init();
 8021a7c:	68f8      	ldr	r0, [r7, #12]
 8021a7e:	f000 f805 	bl	8021a8c <_ZN7TSL27725_initEv>
 8021a82:	4603      	mov	r3, r0
}
 8021a84:	4618      	mov	r0, r3
 8021a86:	3710      	adds	r7, #16
 8021a88:	46bd      	mov	sp, r7
 8021a8a:	bd80      	pop	{r7, pc}

08021a8c <_ZN7TSL27725_initEv>:

/*!  @brief Initializer
 *   @returns True if chip identified and initialized
 */
bool TSL2772::_init() {
 8021a8c:	b580      	push	{r7, lr}
 8021a8e:	b084      	sub	sp, #16
 8021a90:	af00      	add	r7, sp, #0
 8021a92:	6078      	str	r0, [r7, #4]
	uint8_t devid = readRegisterByte(TSL2722_ID_REG | TSL27721_CMD_NORMAL);
 8021a94:	21b2      	movs	r1, #178	; 0xb2
 8021a96:	6878      	ldr	r0, [r7, #4]
 8021a98:	f000 fa39 	bl	8021f0e <_ZN7TSL277216readRegisterByteEt>
 8021a9c:	4603      	mov	r3, r0
 8021a9e:	73fb      	strb	r3, [r7, #15]

	// configure register autoincrement
	if (devid != TSL27721_ALSPROX_DEV_ID) return false;
 8021aa0:	7bfb      	ldrb	r3, [r7, #15]
 8021aa2:	2b30      	cmp	r3, #48	; 0x30
 8021aa4:	d001      	beq.n	8021aaa <_ZN7TSL27725_initEv+0x1e>
 8021aa6:	2300      	movs	r3, #0
 8021aa8:	e003      	b.n	8021ab2 <_ZN7TSL27725_initEv+0x26>

	reset();
 8021aaa:	6878      	ldr	r0, [r7, #4]
 8021aac:	f000 f805 	bl	8021aba <_ZN7TSL27725resetEv>

	return true;
 8021ab0:	2301      	movs	r3, #1
}
 8021ab2:	4618      	mov	r0, r3
 8021ab4:	3710      	adds	r7, #16
 8021ab6:	46bd      	mov	sp, r7
 8021ab8:	bd80      	pop	{r7, pc}

08021aba <_ZN7TSL27725resetEv>:

bool TSL2772::reset(void) {
 8021aba:	b580      	push	{r7, lr}
 8021abc:	b082      	sub	sp, #8
 8021abe:	af00      	add	r7, sp, #0
 8021ac0:	6078      	str	r0, [r7, #4]
	return writeRegisterByte(TSL2722_ENABLE_REG, 0);
 8021ac2:	2200      	movs	r2, #0
 8021ac4:	2100      	movs	r1, #0
 8021ac6:	6878      	ldr	r0, [r7, #4]
 8021ac8:	f000 f9cf 	bl	8021e6a <_ZN7TSL277217writeRegisterByteEhh>
 8021acc:	4603      	mov	r3, r0
}
 8021ace:	4618      	mov	r0, r3
 8021ad0:	3708      	adds	r7, #8
 8021ad2:	46bd      	mov	sp, r7
 8021ad4:	bd80      	pop	{r7, pc}

08021ad6 <_ZN7TSL27729enableALSEb>:
//	}else{
//		return false;
//	}
//}

bool TSL2772::enableALS(bool state) {
 8021ad6:	b580      	push	{r7, lr}
 8021ad8:	b084      	sub	sp, #16
 8021ada:	af00      	add	r7, sp, #0
 8021adc:	6078      	str	r0, [r7, #4]
 8021ade:	460b      	mov	r3, r1
 8021ae0:	70fb      	strb	r3, [r7, #3]
	uint8_t enable_reg_data = readRegisterByte(TSL2722_ENABLE_REG | TSL27721_CMD_NORMAL);
 8021ae2:	21a0      	movs	r1, #160	; 0xa0
 8021ae4:	6878      	ldr	r0, [r7, #4]
 8021ae6:	f000 fa12 	bl	8021f0e <_ZN7TSL277216readRegisterByteEt>
 8021aea:	4603      	mov	r3, r0
 8021aec:	73fb      	strb	r3, [r7, #15]

	if(state) enable_reg_data |= EN_REG_AEN;
 8021aee:	78fb      	ldrb	r3, [r7, #3]
 8021af0:	2b00      	cmp	r3, #0
 8021af2:	d004      	beq.n	8021afe <_ZN7TSL27729enableALSEb+0x28>
 8021af4:	7bfb      	ldrb	r3, [r7, #15]
 8021af6:	f043 0302 	orr.w	r3, r3, #2
 8021afa:	73fb      	strb	r3, [r7, #15]
 8021afc:	e001      	b.n	8021b02 <_ZN7TSL27729enableALSEb+0x2c>
	else enable_reg_data &= !EN_REG_AEN;
 8021afe:	2300      	movs	r3, #0
 8021b00:	73fb      	strb	r3, [r7, #15]

	return writeRegisterByte(TSL2722_ENABLE_REG, enable_reg_data);
 8021b02:	7bfb      	ldrb	r3, [r7, #15]
 8021b04:	461a      	mov	r2, r3
 8021b06:	2100      	movs	r1, #0
 8021b08:	6878      	ldr	r0, [r7, #4]
 8021b0a:	f000 f9ae 	bl	8021e6a <_ZN7TSL277217writeRegisterByteEhh>
 8021b0e:	4603      	mov	r3, r0
}
 8021b10:	4618      	mov	r0, r3
 8021b12:	3710      	adds	r7, #16
 8021b14:	46bd      	mov	sp, r7
 8021b16:	bd80      	pop	{r7, pc}

08021b18 <_ZN7TSL27727powerOnEb>:
	}

	return writeRegisterByte(TSL2722_CONFIG_REG, config_reg_data);
}

bool TSL2772::powerOn(bool state) {
 8021b18:	b580      	push	{r7, lr}
 8021b1a:	b084      	sub	sp, #16
 8021b1c:	af00      	add	r7, sp, #0
 8021b1e:	6078      	str	r0, [r7, #4]
 8021b20:	460b      	mov	r3, r1
 8021b22:	70fb      	strb	r3, [r7, #3]
	uint8_t enable_reg_data = readRegisterByte(TSL2722_ENABLE_REG | TSL27721_CMD_NORMAL);
 8021b24:	21a0      	movs	r1, #160	; 0xa0
 8021b26:	6878      	ldr	r0, [r7, #4]
 8021b28:	f000 f9f1 	bl	8021f0e <_ZN7TSL277216readRegisterByteEt>
 8021b2c:	4603      	mov	r3, r0
 8021b2e:	73fb      	strb	r3, [r7, #15]

	if(state) enable_reg_data |= EN_REG_PON;
 8021b30:	78fb      	ldrb	r3, [r7, #3]
 8021b32:	2b00      	cmp	r3, #0
 8021b34:	d004      	beq.n	8021b40 <_ZN7TSL27727powerOnEb+0x28>
 8021b36:	7bfb      	ldrb	r3, [r7, #15]
 8021b38:	f043 0301 	orr.w	r3, r3, #1
 8021b3c:	73fb      	strb	r3, [r7, #15]
 8021b3e:	e001      	b.n	8021b44 <_ZN7TSL27727powerOnEb+0x2c>
	else enable_reg_data &= !EN_REG_PON;
 8021b40:	2300      	movs	r3, #0
 8021b42:	73fb      	strb	r3, [r7, #15]

	writeRegisterByte(TSL2722_ENABLE_REG, enable_reg_data);
 8021b44:	7bfb      	ldrb	r3, [r7, #15]
 8021b46:	461a      	mov	r2, r3
 8021b48:	2100      	movs	r1, #0
 8021b4a:	6878      	ldr	r0, [r7, #4]
 8021b4c:	f000 f98d 	bl	8021e6a <_ZN7TSL277217writeRegisterByteEhh>

	return 1;
 8021b50:	2301      	movs	r3, #1
}
 8021b52:	4618      	mov	r0, r3
 8021b54:	3710      	adds	r7, #16
 8021b56:	46bd      	mov	sp, r7
 8021b58:	bd80      	pop	{r7, pc}
	...

08021b5c <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t>:

bool TSL2772::setATIME(tsl2591IntegrationTime_t atime_value){
 8021b5c:	b580      	push	{r7, lr}
 8021b5e:	b084      	sub	sp, #16
 8021b60:	af00      	add	r7, sp, #0
 8021b62:	6078      	str	r0, [r7, #4]
 8021b64:	460b      	mov	r3, r1
 8021b66:	70fb      	strb	r3, [r7, #3]
	uint8_t atime_reg_val = readRegisterByte(TSL2722_ATIME_REG | TSL27721_CMD_NORMAL);
 8021b68:	21a1      	movs	r1, #161	; 0xa1
 8021b6a:	6878      	ldr	r0, [r7, #4]
 8021b6c:	f000 f9cf 	bl	8021f0e <_ZN7TSL277216readRegisterByteEt>
 8021b70:	4603      	mov	r3, r0
 8021b72:	73fb      	strb	r3, [r7, #15]

	atime_reg_val = atime_value;
 8021b74:	78fb      	ldrb	r3, [r7, #3]
 8021b76:	73fb      	strb	r3, [r7, #15]

	switch(atime_value){
 8021b78:	78fb      	ldrb	r3, [r7, #3]
 8021b7a:	2bff      	cmp	r3, #255	; 0xff
 8021b7c:	d00e      	beq.n	8021b9c <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x40>
 8021b7e:	2bff      	cmp	r3, #255	; 0xff
 8021b80:	dc20      	bgt.n	8021bc4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x68>
 8021b82:	2bf6      	cmp	r3, #246	; 0xf6
 8021b84:	d00e      	beq.n	8021ba4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x48>
 8021b86:	2bf6      	cmp	r3, #246	; 0xf6
 8021b88:	dc1c      	bgt.n	8021bc4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x68>
 8021b8a:	2bdb      	cmp	r3, #219	; 0xdb
 8021b8c:	d00e      	beq.n	8021bac <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x50>
 8021b8e:	2bdb      	cmp	r3, #219	; 0xdb
 8021b90:	dc18      	bgt.n	8021bc4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x68>
 8021b92:	2b00      	cmp	r3, #0
 8021b94:	d012      	beq.n	8021bbc <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x60>
 8021b96:	2bc0      	cmp	r3, #192	; 0xc0
 8021b98:	d00c      	beq.n	8021bb4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x58>
		break;
	case TSL2722_INTEGRATIONTIME_600MS:
		als_integration_time_ms = 600;
		break;
	default:
		break;
 8021b9a:	e013      	b.n	8021bc4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x68>
		als_integration_time_ms = 2.73;
 8021b9c:	687b      	ldr	r3, [r7, #4]
 8021b9e:	4a0f      	ldr	r2, [pc, #60]	; (8021bdc <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x80>)
 8021ba0:	611a      	str	r2, [r3, #16]
		break;
 8021ba2:	e010      	b.n	8021bc6 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x6a>
		als_integration_time_ms = 27.33;
 8021ba4:	687b      	ldr	r3, [r7, #4]
 8021ba6:	4a0e      	ldr	r2, [pc, #56]	; (8021be0 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x84>)
 8021ba8:	611a      	str	r2, [r3, #16]
		break;
 8021baa:	e00c      	b.n	8021bc6 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x6a>
		als_integration_time_ms = 101;
 8021bac:	687b      	ldr	r3, [r7, #4]
 8021bae:	4a0d      	ldr	r2, [pc, #52]	; (8021be4 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x88>)
 8021bb0:	611a      	str	r2, [r3, #16]
		break;
 8021bb2:	e008      	b.n	8021bc6 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x6a>
		als_integration_time_ms = 175;
 8021bb4:	687b      	ldr	r3, [r7, #4]
 8021bb6:	4a0c      	ldr	r2, [pc, #48]	; (8021be8 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x8c>)
 8021bb8:	611a      	str	r2, [r3, #16]
		break;
 8021bba:	e004      	b.n	8021bc6 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x6a>
		als_integration_time_ms = 600;
 8021bbc:	687b      	ldr	r3, [r7, #4]
 8021bbe:	4a0b      	ldr	r2, [pc, #44]	; (8021bec <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x90>)
 8021bc0:	611a      	str	r2, [r3, #16]
		break;
 8021bc2:	e000      	b.n	8021bc6 <_ZN7TSL27728setATIMEE24tsl2591IntegrationTime_t+0x6a>
		break;
 8021bc4:	bf00      	nop
	}

	return writeRegisterByte(TSL2722_ATIME_REG, atime_reg_val);
 8021bc6:	7bfb      	ldrb	r3, [r7, #15]
 8021bc8:	461a      	mov	r2, r3
 8021bca:	2101      	movs	r1, #1
 8021bcc:	6878      	ldr	r0, [r7, #4]
 8021bce:	f000 f94c 	bl	8021e6a <_ZN7TSL277217writeRegisterByteEhh>
 8021bd2:	4603      	mov	r3, r0
}
 8021bd4:	4618      	mov	r0, r3
 8021bd6:	3710      	adds	r7, #16
 8021bd8:	46bd      	mov	sp, r7
 8021bda:	bd80      	pop	{r7, pc}
 8021bdc:	402eb852 	.word	0x402eb852
 8021be0:	41daa3d7 	.word	0x41daa3d7
 8021be4:	42ca0000 	.word	0x42ca0000
 8021be8:	432f0000 	.word	0x432f0000
 8021bec:	44160000 	.word	0x44160000

08021bf0 <_ZN7TSL27728setAGAINE13tsl2591Gain_t>:
bool TSL2772::setAGAIN(tsl2591Gain_t gain_value){
 8021bf0:	b580      	push	{r7, lr}
 8021bf2:	b084      	sub	sp, #16
 8021bf4:	af00      	add	r7, sp, #0
 8021bf6:	6078      	str	r0, [r7, #4]
 8021bf8:	460b      	mov	r3, r1
 8021bfa:	70fb      	strb	r3, [r7, #3]

	uint8_t ctrl_reg_val = readRegisterByte(TSL2722_CONTROL_REG  | TSL27721_CMD_NORMAL) & 0xFC;
 8021bfc:	21af      	movs	r1, #175	; 0xaf
 8021bfe:	6878      	ldr	r0, [r7, #4]
 8021c00:	f000 f985 	bl	8021f0e <_ZN7TSL277216readRegisterByteEt>
 8021c04:	4603      	mov	r3, r0
 8021c06:	f023 0303 	bic.w	r3, r3, #3
 8021c0a:	73fb      	strb	r3, [r7, #15]

	ctrl_reg_val &= 0xFC;
 8021c0c:	7bfb      	ldrb	r3, [r7, #15]
 8021c0e:	f023 0303 	bic.w	r3, r3, #3
 8021c12:	73fb      	strb	r3, [r7, #15]
	ctrl_reg_val |= gain_value;
 8021c14:	7bfa      	ldrb	r2, [r7, #15]
 8021c16:	78fb      	ldrb	r3, [r7, #3]
 8021c18:	4313      	orrs	r3, r2
 8021c1a:	73fb      	strb	r3, [r7, #15]

	switch(gain_value){
 8021c1c:	78fb      	ldrb	r3, [r7, #3]
 8021c1e:	2b03      	cmp	r3, #3
 8021c20:	d81d      	bhi.n	8021c5e <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x6e>
 8021c22:	a201      	add	r2, pc, #4	; (adr r2, 8021c28 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x38>)
 8021c24:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021c28:	08021c39 	.word	0x08021c39
 8021c2c:	08021c43 	.word	0x08021c43
 8021c30:	08021c4d 	.word	0x08021c4d
 8021c34:	08021c57 	.word	0x08021c57
	case TSL2722_GAIN_1X:
		als_gain = 1;
 8021c38:	687b      	ldr	r3, [r7, #4]
 8021c3a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8021c3e:	60da      	str	r2, [r3, #12]
		break;
 8021c40:	e00e      	b.n	8021c60 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x70>
	case TSL2722_GAIN_8X:
		als_gain = 8;
 8021c42:	687b      	ldr	r3, [r7, #4]
 8021c44:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
 8021c48:	60da      	str	r2, [r3, #12]
		break;
 8021c4a:	e009      	b.n	8021c60 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x70>
	case TSL2722_GAIN_16X:
		als_gain = 16;
 8021c4c:	687b      	ldr	r3, [r7, #4]
 8021c4e:	f04f 4283 	mov.w	r2, #1098907648	; 0x41800000
 8021c52:	60da      	str	r2, [r3, #12]
		break;
 8021c54:	e004      	b.n	8021c60 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x70>
	case TSL2722_GAIN_120X:
		als_gain = 120;
 8021c56:	687b      	ldr	r3, [r7, #4]
 8021c58:	4a15      	ldr	r2, [pc, #84]	; (8021cb0 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0xc0>)
 8021c5a:	60da      	str	r2, [r3, #12]
		break;
 8021c5c:	e000      	b.n	8021c60 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x70>
	default:
		break;
 8021c5e:	bf00      	nop
	}

	if(als_gain_scaler) als_gain *= 0.16;
 8021c60:	687b      	ldr	r3, [r7, #4]
 8021c62:	7a9b      	ldrb	r3, [r3, #10]
 8021c64:	2b00      	cmp	r3, #0
 8021c66:	d012      	beq.n	8021c8e <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0x9e>
 8021c68:	687b      	ldr	r3, [r7, #4]
 8021c6a:	68db      	ldr	r3, [r3, #12]
 8021c6c:	4618      	mov	r0, r3
 8021c6e:	f7e5 feeb 	bl	8007a48 <__aeabi_f2d>
 8021c72:	a30d      	add	r3, pc, #52	; (adr r3, 8021ca8 <_ZN7TSL27728setAGAINE13tsl2591Gain_t+0xb8>)
 8021c74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021c78:	f7e5 ff3e 	bl	8007af8 <__aeabi_dmul>
 8021c7c:	4602      	mov	r2, r0
 8021c7e:	460b      	mov	r3, r1
 8021c80:	4610      	mov	r0, r2
 8021c82:	4619      	mov	r1, r3
 8021c84:	f7e6 fa30 	bl	80080e8 <__aeabi_d2f>
 8021c88:	4602      	mov	r2, r0
 8021c8a:	687b      	ldr	r3, [r7, #4]
 8021c8c:	60da      	str	r2, [r3, #12]

	return writeRegisterByte(TSL2722_CONTROL_REG, ctrl_reg_val);
 8021c8e:	7bfb      	ldrb	r3, [r7, #15]
 8021c90:	461a      	mov	r2, r3
 8021c92:	210f      	movs	r1, #15
 8021c94:	6878      	ldr	r0, [r7, #4]
 8021c96:	f000 f8e8 	bl	8021e6a <_ZN7TSL277217writeRegisterByteEhh>
 8021c9a:	4603      	mov	r3, r0
}
 8021c9c:	4618      	mov	r0, r3
 8021c9e:	3710      	adds	r7, #16
 8021ca0:	46bd      	mov	sp, r7
 8021ca2:	bd80      	pop	{r7, pc}
 8021ca4:	f3af 8000 	nop.w
 8021ca8:	47ae147b 	.word	0x47ae147b
 8021cac:	3fc47ae1 	.word	0x3fc47ae1
 8021cb0:	42f00000 	.word	0x42f00000
 8021cb4:	00000000 	.word	0x00000000

08021cb8 <_ZN7TSL27726getLuxEv>:

tsl2591Gain_t TSL2772::getAGAIN(){
	return (tsl2591Gain_t) (readRegisterByte(TSL2722_CONTROL_REG | TSL27721_CMD_NORMAL) & 0xFC);
}

uint32_t TSL2772::getLux(){
 8021cb8:	b5b0      	push	{r4, r5, r7, lr}
 8021cba:	b086      	sub	sp, #24
 8021cbc:	af00      	add	r7, sp, #0
 8021cbe:	6078      	str	r0, [r7, #4]

	readALS_data(); // grab samples from sensor
 8021cc0:	6878      	ldr	r0, [r7, #4]
 8021cc2:	f000 f8af 	bl	8021e24 <_ZN7TSL277212readALS_dataEv>

	float _CPL; // counters per lux
	_CPL = (als_integration_time_ms * als_gain) / (_GA*60);
 8021cc6:	687b      	ldr	r3, [r7, #4]
 8021cc8:	ed93 7a04 	vldr	s14, [r3, #16]
 8021ccc:	687b      	ldr	r3, [r7, #4]
 8021cce:	edd3 7a03 	vldr	s15, [r3, #12]
 8021cd2:	ee67 6a27 	vmul.f32	s13, s14, s15
 8021cd6:	687b      	ldr	r3, [r7, #4]
 8021cd8:	695a      	ldr	r2, [r3, #20]
 8021cda:	4613      	mov	r3, r2
 8021cdc:	011b      	lsls	r3, r3, #4
 8021cde:	1a9b      	subs	r3, r3, r2
 8021ce0:	009b      	lsls	r3, r3, #2
 8021ce2:	ee07 3a90 	vmov	s15, r3
 8021ce6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8021cea:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8021cee:	edc7 7a05 	vstr	s15, [r7, #20]
	float Lux1, Lux2;
	Lux1 = (1*_C0DATA - 1.87*_C1DATA)/_CPL;
 8021cf2:	687b      	ldr	r3, [r7, #4]
 8021cf4:	88db      	ldrh	r3, [r3, #6]
 8021cf6:	4618      	mov	r0, r3
 8021cf8:	f7e5 fe94 	bl	8007a24 <__aeabi_i2d>
 8021cfc:	4604      	mov	r4, r0
 8021cfe:	460d      	mov	r5, r1
 8021d00:	687b      	ldr	r3, [r7, #4]
 8021d02:	891b      	ldrh	r3, [r3, #8]
 8021d04:	4618      	mov	r0, r3
 8021d06:	f7e5 fe8d 	bl	8007a24 <__aeabi_i2d>
 8021d0a:	a342      	add	r3, pc, #264	; (adr r3, 8021e14 <_ZN7TSL27726getLuxEv+0x15c>)
 8021d0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021d10:	f7e5 fef2 	bl	8007af8 <__aeabi_dmul>
 8021d14:	4602      	mov	r2, r0
 8021d16:	460b      	mov	r3, r1
 8021d18:	4620      	mov	r0, r4
 8021d1a:	4629      	mov	r1, r5
 8021d1c:	f7e5 fd34 	bl	8007788 <__aeabi_dsub>
 8021d20:	4602      	mov	r2, r0
 8021d22:	460b      	mov	r3, r1
 8021d24:	4614      	mov	r4, r2
 8021d26:	461d      	mov	r5, r3
 8021d28:	6978      	ldr	r0, [r7, #20]
 8021d2a:	f7e5 fe8d 	bl	8007a48 <__aeabi_f2d>
 8021d2e:	4602      	mov	r2, r0
 8021d30:	460b      	mov	r3, r1
 8021d32:	4620      	mov	r0, r4
 8021d34:	4629      	mov	r1, r5
 8021d36:	f7e6 f809 	bl	8007d4c <__aeabi_ddiv>
 8021d3a:	4602      	mov	r2, r0
 8021d3c:	460b      	mov	r3, r1
 8021d3e:	4610      	mov	r0, r2
 8021d40:	4619      	mov	r1, r3
 8021d42:	f7e6 f9d1 	bl	80080e8 <__aeabi_d2f>
 8021d46:	4603      	mov	r3, r0
 8021d48:	613b      	str	r3, [r7, #16]
	Lux2 = (0.63*_C0DATA - 1*_C1DATA)/_CPL;
 8021d4a:	687b      	ldr	r3, [r7, #4]
 8021d4c:	88db      	ldrh	r3, [r3, #6]
 8021d4e:	4618      	mov	r0, r3
 8021d50:	f7e5 fe68 	bl	8007a24 <__aeabi_i2d>
 8021d54:	a331      	add	r3, pc, #196	; (adr r3, 8021e1c <_ZN7TSL27726getLuxEv+0x164>)
 8021d56:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021d5a:	f7e5 fecd 	bl	8007af8 <__aeabi_dmul>
 8021d5e:	4602      	mov	r2, r0
 8021d60:	460b      	mov	r3, r1
 8021d62:	4614      	mov	r4, r2
 8021d64:	461d      	mov	r5, r3
 8021d66:	687b      	ldr	r3, [r7, #4]
 8021d68:	891b      	ldrh	r3, [r3, #8]
 8021d6a:	4618      	mov	r0, r3
 8021d6c:	f7e5 fe5a 	bl	8007a24 <__aeabi_i2d>
 8021d70:	4602      	mov	r2, r0
 8021d72:	460b      	mov	r3, r1
 8021d74:	4620      	mov	r0, r4
 8021d76:	4629      	mov	r1, r5
 8021d78:	f7e5 fd06 	bl	8007788 <__aeabi_dsub>
 8021d7c:	4602      	mov	r2, r0
 8021d7e:	460b      	mov	r3, r1
 8021d80:	4614      	mov	r4, r2
 8021d82:	461d      	mov	r5, r3
 8021d84:	6978      	ldr	r0, [r7, #20]
 8021d86:	f7e5 fe5f 	bl	8007a48 <__aeabi_f2d>
 8021d8a:	4602      	mov	r2, r0
 8021d8c:	460b      	mov	r3, r1
 8021d8e:	4620      	mov	r0, r4
 8021d90:	4629      	mov	r1, r5
 8021d92:	f7e5 ffdb 	bl	8007d4c <__aeabi_ddiv>
 8021d96:	4602      	mov	r2, r0
 8021d98:	460b      	mov	r3, r1
 8021d9a:	4610      	mov	r0, r2
 8021d9c:	4619      	mov	r1, r3
 8021d9e:	f7e6 f9a3 	bl	80080e8 <__aeabi_d2f>
 8021da2:	4603      	mov	r3, r0
 8021da4:	60fb      	str	r3, [r7, #12]

	if( (Lux1>=Lux2) && (Lux1 > 0)){
 8021da6:	ed97 7a04 	vldr	s14, [r7, #16]
 8021daa:	edd7 7a03 	vldr	s15, [r7, #12]
 8021dae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8021db2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021db6:	db0b      	blt.n	8021dd0 <_ZN7TSL27726getLuxEv+0x118>
 8021db8:	edd7 7a04 	vldr	s15, [r7, #16]
 8021dbc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021dc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021dc4:	dd04      	ble.n	8021dd0 <_ZN7TSL27726getLuxEv+0x118>
		return Lux1;
 8021dc6:	edd7 7a04 	vldr	s15, [r7, #16]
 8021dca:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8021dce:	e016      	b.n	8021dfe <_ZN7TSL27726getLuxEv+0x146>
	}else if ((Lux1<Lux2) && (Lux1 > 0)){
 8021dd0:	ed97 7a04 	vldr	s14, [r7, #16]
 8021dd4:	edd7 7a03 	vldr	s15, [r7, #12]
 8021dd8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8021ddc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021de0:	d50b      	bpl.n	8021dfa <_ZN7TSL27726getLuxEv+0x142>
 8021de2:	edd7 7a04 	vldr	s15, [r7, #16]
 8021de6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8021dea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021dee:	dd04      	ble.n	8021dfa <_ZN7TSL27726getLuxEv+0x142>
		return Lux2;
 8021df0:	edd7 7a03 	vldr	s15, [r7, #12]
 8021df4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8021df8:	e001      	b.n	8021dfe <_ZN7TSL27726getLuxEv+0x146>
	}else{
		return 0;
 8021dfa:	eddf 7a05 	vldr	s15, [pc, #20]	; 8021e10 <_ZN7TSL27726getLuxEv+0x158>
 8021dfe:	ee17 3a90 	vmov	r3, s15
	}
}
 8021e02:	4618      	mov	r0, r3
 8021e04:	3718      	adds	r7, #24
 8021e06:	46bd      	mov	sp, r7
 8021e08:	bdb0      	pop	{r4, r5, r7, pc}
 8021e0a:	bf00      	nop
 8021e0c:	f3af 8000 	nop.w
 8021e10:	00000000 	.word	0x00000000
 8021e14:	1eb851ec 	.word	0x1eb851ec
 8021e18:	3ffdeb85 	.word	0x3ffdeb85
 8021e1c:	c28f5c29 	.word	0xc28f5c29
 8021e20:	3fe428f5 	.word	0x3fe428f5

08021e24 <_ZN7TSL277212readALS_dataEv>:

void TSL2772::readALS_data(){
 8021e24:	b580      	push	{r7, lr}
 8021e26:	b084      	sub	sp, #16
 8021e28:	af00      	add	r7, sp, #0
 8021e2a:	6078      	str	r0, [r7, #4]
	uint8_t data[4];
	readRegister(TSL2722_C0DATA_REG | TSL27721_CMD_NORMAL, data, 4);
 8021e2c:	f107 020c 	add.w	r2, r7, #12
 8021e30:	2304      	movs	r3, #4
 8021e32:	21b4      	movs	r1, #180	; 0xb4
 8021e34:	6878      	ldr	r0, [r7, #4]
 8021e36:	f000 f842 	bl	8021ebe <_ZN7TSL277212readRegisterEtPht>

	_C0DATA = data[1] << 8 | data[0];
 8021e3a:	7b7b      	ldrb	r3, [r7, #13]
 8021e3c:	021b      	lsls	r3, r3, #8
 8021e3e:	b21a      	sxth	r2, r3
 8021e40:	7b3b      	ldrb	r3, [r7, #12]
 8021e42:	b21b      	sxth	r3, r3
 8021e44:	4313      	orrs	r3, r2
 8021e46:	b21b      	sxth	r3, r3
 8021e48:	b29a      	uxth	r2, r3
 8021e4a:	687b      	ldr	r3, [r7, #4]
 8021e4c:	80da      	strh	r2, [r3, #6]
	_C1DATA = data[3] << 8 | data[2];
 8021e4e:	7bfb      	ldrb	r3, [r7, #15]
 8021e50:	021b      	lsls	r3, r3, #8
 8021e52:	b21a      	sxth	r2, r3
 8021e54:	7bbb      	ldrb	r3, [r7, #14]
 8021e56:	b21b      	sxth	r3, r3
 8021e58:	4313      	orrs	r3, r2
 8021e5a:	b21b      	sxth	r3, r3
 8021e5c:	b29a      	uxth	r2, r3
 8021e5e:	687b      	ldr	r3, [r7, #4]
 8021e60:	811a      	strh	r2, [r3, #8]

//	readRegister(TSL2722_C0DATA_REG, (uint8_t*) &_C0DATA, 2);
//	readRegister(TSL2722_C1DATA_REG, (uint8_t*) &_C1DATA, 2);
}
 8021e62:	bf00      	nop
 8021e64:	3710      	adds	r7, #16
 8021e66:	46bd      	mov	sp, r7
 8021e68:	bd80      	pop	{r7, pc}

08021e6a <_ZN7TSL277217writeRegisterByteEhh>:
	} else {
		return false;
	}
}

bool TSL2772::writeRegisterByte(uint8_t mem_addr, uint8_t val) {
 8021e6a:	b580      	push	{r7, lr}
 8021e6c:	b086      	sub	sp, #24
 8021e6e:	af02      	add	r7, sp, #8
 8021e70:	6078      	str	r0, [r7, #4]
 8021e72:	460b      	mov	r3, r1
 8021e74:	70fb      	strb	r3, [r7, #3]
 8021e76:	4613      	mov	r3, r2
 8021e78:	70bb      	strb	r3, [r7, #2]
	uint8_t data[2];

	data[0] = mem_addr | CMD_REG_W;
 8021e7a:	78fb      	ldrb	r3, [r7, #3]
 8021e7c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8021e80:	b2db      	uxtb	r3, r3
 8021e82:	733b      	strb	r3, [r7, #12]
	data[1] = val;
 8021e84:	78bb      	ldrb	r3, [r7, #2]
 8021e86:	737b      	strb	r3, [r7, #13]

	if (HAL_OK
			== HAL_I2C_Master_Transmit(i2c_han, i2c_addr, data, 2, 10)) {
 8021e88:	687b      	ldr	r3, [r7, #4]
 8021e8a:	6818      	ldr	r0, [r3, #0]
 8021e8c:	687b      	ldr	r3, [r7, #4]
 8021e8e:	791b      	ldrb	r3, [r3, #4]
 8021e90:	b299      	uxth	r1, r3
 8021e92:	f107 020c 	add.w	r2, r7, #12
 8021e96:	230a      	movs	r3, #10
 8021e98:	9300      	str	r3, [sp, #0]
 8021e9a:	2302      	movs	r3, #2
 8021e9c:	f7ec fa30 	bl	800e300 <HAL_I2C_Master_Transmit>
 8021ea0:	4603      	mov	r3, r0
 8021ea2:	2b00      	cmp	r3, #0
 8021ea4:	bf0c      	ite	eq
 8021ea6:	2301      	moveq	r3, #1
 8021ea8:	2300      	movne	r3, #0
 8021eaa:	b2db      	uxtb	r3, r3
	if (HAL_OK
 8021eac:	2b00      	cmp	r3, #0
 8021eae:	d001      	beq.n	8021eb4 <_ZN7TSL277217writeRegisterByteEhh+0x4a>
		return true;
 8021eb0:	2301      	movs	r3, #1
 8021eb2:	e000      	b.n	8021eb6 <_ZN7TSL277217writeRegisterByteEhh+0x4c>
	} else {
		return false;
 8021eb4:	2300      	movs	r3, #0
//			== HAL_I2C_Mem_Write(i2c_han, i2c_addr, mem_addr, 1, &val, 1, 10)) {
//		return true;
//	} else {
//		return false;
//	}
}
 8021eb6:	4618      	mov	r0, r3
 8021eb8:	3710      	adds	r7, #16
 8021eba:	46bd      	mov	sp, r7
 8021ebc:	bd80      	pop	{r7, pc}

08021ebe <_ZN7TSL277212readRegisterEtPht>:
	uint8_t mask = 1 << pos;
	return ((var & ~mask) | (value << pos));
}

bool TSL2772::readRegister(uint16_t mem_addr, uint8_t *dest,
		uint16_t size) {
 8021ebe:	b580      	push	{r7, lr}
 8021ec0:	b088      	sub	sp, #32
 8021ec2:	af04      	add	r7, sp, #16
 8021ec4:	60f8      	str	r0, [r7, #12]
 8021ec6:	607a      	str	r2, [r7, #4]
 8021ec8:	461a      	mov	r2, r3
 8021eca:	460b      	mov	r3, r1
 8021ecc:	817b      	strh	r3, [r7, #10]
 8021ece:	4613      	mov	r3, r2
 8021ed0:	813b      	strh	r3, [r7, #8]
	if (HAL_OK
			== HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, dest, size, 10)) {
 8021ed2:	68fb      	ldr	r3, [r7, #12]
 8021ed4:	6818      	ldr	r0, [r3, #0]
 8021ed6:	68fb      	ldr	r3, [r7, #12]
 8021ed8:	791b      	ldrb	r3, [r3, #4]
 8021eda:	b299      	uxth	r1, r3
 8021edc:	897a      	ldrh	r2, [r7, #10]
 8021ede:	230a      	movs	r3, #10
 8021ee0:	9302      	str	r3, [sp, #8]
 8021ee2:	893b      	ldrh	r3, [r7, #8]
 8021ee4:	9301      	str	r3, [sp, #4]
 8021ee6:	687b      	ldr	r3, [r7, #4]
 8021ee8:	9300      	str	r3, [sp, #0]
 8021eea:	2301      	movs	r3, #1
 8021eec:	f7ec fd06 	bl	800e8fc <HAL_I2C_Mem_Read>
 8021ef0:	4603      	mov	r3, r0
 8021ef2:	2b00      	cmp	r3, #0
 8021ef4:	bf0c      	ite	eq
 8021ef6:	2301      	moveq	r3, #1
 8021ef8:	2300      	movne	r3, #0
 8021efa:	b2db      	uxtb	r3, r3
	if (HAL_OK
 8021efc:	2b00      	cmp	r3, #0
 8021efe:	d001      	beq.n	8021f04 <_ZN7TSL277212readRegisterEtPht+0x46>
		return true;
 8021f00:	2301      	movs	r3, #1
 8021f02:	e000      	b.n	8021f06 <_ZN7TSL277212readRegisterEtPht+0x48>
	} else {
		return false;
 8021f04:	2300      	movs	r3, #0
	}
}
 8021f06:	4618      	mov	r0, r3
 8021f08:	3710      	adds	r7, #16
 8021f0a:	46bd      	mov	sp, r7
 8021f0c:	bd80      	pop	{r7, pc}

08021f0e <_ZN7TSL277216readRegisterByteEt>:
	register_value |= value << pos; // and add in the new data

	return writeRegisterByte(reg, register_value);
}

uint8_t TSL2772::readRegisterByte(uint16_t mem_addr) {
 8021f0e:	b580      	push	{r7, lr}
 8021f10:	b088      	sub	sp, #32
 8021f12:	af04      	add	r7, sp, #16
 8021f14:	6078      	str	r0, [r7, #4]
 8021f16:	460b      	mov	r3, r1
 8021f18:	807b      	strh	r3, [r7, #2]
	uint8_t data = 0;
 8021f1a:	2300      	movs	r3, #0
 8021f1c:	73fb      	strb	r3, [r7, #15]

	if(HAL_OK != HAL_I2C_Mem_Read(i2c_han, i2c_addr, mem_addr, 1, &data, 1, 10)){
 8021f1e:	687b      	ldr	r3, [r7, #4]
 8021f20:	6818      	ldr	r0, [r3, #0]
 8021f22:	687b      	ldr	r3, [r7, #4]
 8021f24:	791b      	ldrb	r3, [r3, #4]
 8021f26:	b299      	uxth	r1, r3
 8021f28:	887a      	ldrh	r2, [r7, #2]
 8021f2a:	230a      	movs	r3, #10
 8021f2c:	9302      	str	r3, [sp, #8]
 8021f2e:	2301      	movs	r3, #1
 8021f30:	9301      	str	r3, [sp, #4]
 8021f32:	f107 030f 	add.w	r3, r7, #15
 8021f36:	9300      	str	r3, [sp, #0]
 8021f38:	2301      	movs	r3, #1
 8021f3a:	f7ec fcdf 	bl	800e8fc <HAL_I2C_Mem_Read>
 8021f3e:	4603      	mov	r3, r0
 8021f40:	2b00      	cmp	r3, #0
 8021f42:	bf14      	ite	ne
 8021f44:	2301      	movne	r3, #1
 8021f46:	2300      	moveq	r3, #0
 8021f48:	b2db      	uxtb	r3, r3
 8021f4a:	2b00      	cmp	r3, #0
 8021f4c:	d001      	beq.n	8021f52 <_ZN7TSL277216readRegisterByteEt+0x44>
		return 0;
 8021f4e:	2300      	movs	r3, #0
 8021f50:	e000      	b.n	8021f54 <_ZN7TSL277216readRegisterByteEt+0x46>
	}
	return data;
 8021f52:	7bfb      	ldrb	r3, [r7, #15]
}
 8021f54:	4618      	mov	r0, r3
 8021f56:	3710      	adds	r7, #16
 8021f58:	46bd      	mov	sp, r7
 8021f5a:	bd80      	pop	{r7, pc}

08021f5c <_Z18generateCRCGenericPKhjhh>:
 */

#include "../../Sensirion_Core/src/SensirionCrc.h"

uint8_t generateCRCGeneric(const uint8_t* data, size_t count, uint8_t init,
                           uint8_t polynomial) {
 8021f5c:	b480      	push	{r7}
 8021f5e:	b089      	sub	sp, #36	; 0x24
 8021f60:	af00      	add	r7, sp, #0
 8021f62:	60f8      	str	r0, [r7, #12]
 8021f64:	60b9      	str	r1, [r7, #8]
 8021f66:	4611      	mov	r1, r2
 8021f68:	461a      	mov	r2, r3
 8021f6a:	460b      	mov	r3, r1
 8021f6c:	71fb      	strb	r3, [r7, #7]
 8021f6e:	4613      	mov	r3, r2
 8021f70:	71bb      	strb	r3, [r7, #6]
    uint8_t crc = init;
 8021f72:	79fb      	ldrb	r3, [r7, #7]
 8021f74:	77fb      	strb	r3, [r7, #31]

    /* calculates 8-Bit checksum with given polynomial */
    for (size_t current_byte = 0; current_byte < count; ++current_byte) {
 8021f76:	2300      	movs	r3, #0
 8021f78:	61bb      	str	r3, [r7, #24]
 8021f7a:	69ba      	ldr	r2, [r7, #24]
 8021f7c:	68bb      	ldr	r3, [r7, #8]
 8021f7e:	429a      	cmp	r2, r3
 8021f80:	d223      	bcs.n	8021fca <_Z18generateCRCGenericPKhjhh+0x6e>
        crc ^= (data[current_byte]);
 8021f82:	68fa      	ldr	r2, [r7, #12]
 8021f84:	69bb      	ldr	r3, [r7, #24]
 8021f86:	4413      	add	r3, r2
 8021f88:	781a      	ldrb	r2, [r3, #0]
 8021f8a:	7ffb      	ldrb	r3, [r7, #31]
 8021f8c:	4053      	eors	r3, r2
 8021f8e:	77fb      	strb	r3, [r7, #31]
        for (uint8_t crc_bit = 8; crc_bit > 0; --crc_bit) {
 8021f90:	2308      	movs	r3, #8
 8021f92:	75fb      	strb	r3, [r7, #23]
 8021f94:	7dfb      	ldrb	r3, [r7, #23]
 8021f96:	2b00      	cmp	r3, #0
 8021f98:	d013      	beq.n	8021fc2 <_Z18generateCRCGenericPKhjhh+0x66>
            if (crc & 0x80)
 8021f9a:	f997 301f 	ldrsb.w	r3, [r7, #31]
 8021f9e:	2b00      	cmp	r3, #0
 8021fa0:	da08      	bge.n	8021fb4 <_Z18generateCRCGenericPKhjhh+0x58>
                crc = (crc << 1) ^ polynomial;
 8021fa2:	7ffb      	ldrb	r3, [r7, #31]
 8021fa4:	005b      	lsls	r3, r3, #1
 8021fa6:	b25a      	sxtb	r2, r3
 8021fa8:	f997 3006 	ldrsb.w	r3, [r7, #6]
 8021fac:	4053      	eors	r3, r2
 8021fae:	b25b      	sxtb	r3, r3
 8021fb0:	77fb      	strb	r3, [r7, #31]
 8021fb2:	e002      	b.n	8021fba <_Z18generateCRCGenericPKhjhh+0x5e>
            else
                crc = (crc << 1);
 8021fb4:	7ffb      	ldrb	r3, [r7, #31]
 8021fb6:	005b      	lsls	r3, r3, #1
 8021fb8:	77fb      	strb	r3, [r7, #31]
        for (uint8_t crc_bit = 8; crc_bit > 0; --crc_bit) {
 8021fba:	7dfb      	ldrb	r3, [r7, #23]
 8021fbc:	3b01      	subs	r3, #1
 8021fbe:	75fb      	strb	r3, [r7, #23]
 8021fc0:	e7e8      	b.n	8021f94 <_Z18generateCRCGenericPKhjhh+0x38>
    for (size_t current_byte = 0; current_byte < count; ++current_byte) {
 8021fc2:	69bb      	ldr	r3, [r7, #24]
 8021fc4:	3301      	adds	r3, #1
 8021fc6:	61bb      	str	r3, [r7, #24]
 8021fc8:	e7d7      	b.n	8021f7a <_Z18generateCRCGenericPKhjhh+0x1e>
        }
    }
    return crc;
 8021fca:	7ffb      	ldrb	r3, [r7, #31]
}
 8021fcc:	4618      	mov	r0, r3
 8021fce:	3724      	adds	r7, #36	; 0x24
 8021fd0:	46bd      	mov	sp, r7
 8021fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021fd6:	4770      	bx	lr

08021fd8 <_Z16generateCRC31_ffPKhj>:

uint8_t generateCRC31_ff(const uint8_t* data, size_t count) {
 8021fd8:	b580      	push	{r7, lr}
 8021fda:	b082      	sub	sp, #8
 8021fdc:	af00      	add	r7, sp, #0
 8021fde:	6078      	str	r0, [r7, #4]
 8021fe0:	6039      	str	r1, [r7, #0]
    return generateCRCGeneric(data, count, 0xff, 0x31);
 8021fe2:	2331      	movs	r3, #49	; 0x31
 8021fe4:	22ff      	movs	r2, #255	; 0xff
 8021fe6:	6839      	ldr	r1, [r7, #0]
 8021fe8:	6878      	ldr	r0, [r7, #4]
 8021fea:	f7ff ffb7 	bl	8021f5c <_Z18generateCRCGenericPKhjhh>
 8021fee:	4603      	mov	r3, r0
}
 8021ff0:	4618      	mov	r0, r3
 8021ff2:	3708      	adds	r7, #8
 8021ff4:	46bd      	mov	sp, r7
 8021ff6:	bd80      	pop	{r7, pc}

08021ff8 <_Z16generateCRC31_00PKhj>:

uint8_t generateCRC31_00(const uint8_t* data, size_t count) {
 8021ff8:	b580      	push	{r7, lr}
 8021ffa:	b082      	sub	sp, #8
 8021ffc:	af00      	add	r7, sp, #0
 8021ffe:	6078      	str	r0, [r7, #4]
 8022000:	6039      	str	r1, [r7, #0]
    return generateCRCGeneric(data, count, 0x00, 0x31);
 8022002:	2331      	movs	r3, #49	; 0x31
 8022004:	2200      	movs	r2, #0
 8022006:	6839      	ldr	r1, [r7, #0]
 8022008:	6878      	ldr	r0, [r7, #4]
 802200a:	f7ff ffa7 	bl	8021f5c <_Z18generateCRCGenericPKhjhh>
 802200e:	4603      	mov	r3, r0
}
 8022010:	4618      	mov	r0, r3
 8022012:	3708      	adds	r7, #8
 8022014:	46bd      	mov	sp, r7
 8022016:	bd80      	pop	{r7, pc}

08022018 <_Z11generateCRCPKhj13CrcPolynomial>:

uint8_t generateCRC(const uint8_t* data, size_t count, CrcPolynomial type) {
 8022018:	b580      	push	{r7, lr}
 802201a:	b084      	sub	sp, #16
 802201c:	af00      	add	r7, sp, #0
 802201e:	60f8      	str	r0, [r7, #12]
 8022020:	60b9      	str	r1, [r7, #8]
 8022022:	4613      	mov	r3, r2
 8022024:	71fb      	strb	r3, [r7, #7]
    if (CRC31_00 == type) {
 8022026:	79fb      	ldrb	r3, [r7, #7]
 8022028:	2b00      	cmp	r3, #0
 802202a:	d105      	bne.n	8022038 <_Z11generateCRCPKhj13CrcPolynomial+0x20>
        return generateCRC31_00(data, count);
 802202c:	68b9      	ldr	r1, [r7, #8]
 802202e:	68f8      	ldr	r0, [r7, #12]
 8022030:	f7ff ffe2 	bl	8021ff8 <_Z16generateCRC31_00PKhj>
 8022034:	4603      	mov	r3, r0
 8022036:	e005      	b.n	8022044 <_Z11generateCRCPKhj13CrcPolynomial+0x2c>
    }
    return generateCRC31_ff(data, count);
 8022038:	68b9      	ldr	r1, [r7, #8]
 802203a:	68f8      	ldr	r0, [r7, #12]
 802203c:	f7ff ffcc 	bl	8021fd8 <_Z16generateCRC31_ffPKhj>
 8022040:	4603      	mov	r3, r0
 8022042:	bf00      	nop
}
 8022044:	4618      	mov	r0, r3
 8022046:	3710      	adds	r7, #16
 8022048:	46bd      	mov	sp, r7
 802204a:	bd80      	pop	{r7, pc}

0802204c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef>:
//    }
}

uint16_t SensirionI2CCommunication::sendFrame(uint8_t address,
                                              SensirionI2CTxFrame& frame,
											  I2C_HandleTypeDef *i2c_handle) {
 802204c:	b580      	push	{r7, lr}
 802204e:	b086      	sub	sp, #24
 8022050:	af02      	add	r7, sp, #8
 8022052:	4603      	mov	r3, r0
 8022054:	60b9      	str	r1, [r7, #8]
 8022056:	607a      	str	r2, [r7, #4]
 8022058:	73fb      	strb	r3, [r7, #15]
//    i2cBus.beginTransmission(address);
//    size_t writtenBytes = i2cBus.write(frame._buffer, frame._index);
//    uint8_t i2c_error = i2cBus.endTransmission();

    if(HAL_OK != HAL_I2C_Master_Transmit(i2c_handle, address << 1, frame._buffer, frame._index, 10)){
 802205a:	7bfb      	ldrb	r3, [r7, #15]
 802205c:	b29b      	uxth	r3, r3
 802205e:	005b      	lsls	r3, r3, #1
 8022060:	b299      	uxth	r1, r3
 8022062:	68bb      	ldr	r3, [r7, #8]
 8022064:	681a      	ldr	r2, [r3, #0]
 8022066:	68bb      	ldr	r3, [r7, #8]
 8022068:	689b      	ldr	r3, [r3, #8]
 802206a:	b29b      	uxth	r3, r3
 802206c:	200a      	movs	r0, #10
 802206e:	9000      	str	r0, [sp, #0]
 8022070:	6878      	ldr	r0, [r7, #4]
 8022072:	f7ec f945 	bl	800e300 <HAL_I2C_Master_Transmit>
 8022076:	4603      	mov	r3, r0
 8022078:	2b00      	cmp	r3, #0
 802207a:	bf14      	ite	ne
 802207c:	2301      	movne	r3, #1
 802207e:	2300      	moveq	r3, #0
 8022080:	b2db      	uxtb	r3, r3
 8022082:	2b00      	cmp	r3, #0
 8022084:	d002      	beq.n	802208c <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef+0x40>
    	return WriteError | I2cOtherError;
 8022086:	f240 130d 	movw	r3, #269	; 0x10d
 802208a:	e000      	b.n	802208e <_ZN25SensirionI2CCommunication9sendFrameEhR19SensirionI2CTxFrameP19__I2C_HandleTypeDef+0x42>
    }else{
    	return NoError;
 802208c:	2300      	movs	r3, #0
    }

}
 802208e:	4618      	mov	r0, r3
 8022090:	3710      	adds	r7, #16
 8022092:	46bd      	mov	sp, r7
 8022094:	bd80      	pop	{r7, pc}
	...

08022098 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial>:

uint16_t SensirionI2CCommunication::receiveFrame(uint8_t address,
                                                 size_t numBytes,
                                                 SensirionI2CRxFrame& frame,
												 I2C_HandleTypeDef *i2c_handle,
                                                 CrcPolynomial poly) {
 8022098:	b5b0      	push	{r4, r5, r7, lr}
 802209a:	b08e      	sub	sp, #56	; 0x38
 802209c:	af02      	add	r7, sp, #8
 802209e:	60b9      	str	r1, [r7, #8]
 80220a0:	607a      	str	r2, [r7, #4]
 80220a2:	603b      	str	r3, [r7, #0]
 80220a4:	4603      	mov	r3, r0
 80220a6:	73fb      	strb	r3, [r7, #15]
            return ReadError | CRCError;
        }
        readAmount -= 3;
    } while (readAmount > 0);
    frame._numBytes = i;
    return NoError;
 80220a8:	466b      	mov	r3, sp
 80220aa:	461d      	mov	r5, r3
    size_t i = 0;
 80220ac:	2300      	movs	r3, #0
 80220ae:	62bb      	str	r3, [r7, #40]	; 0x28
    const uint8_t sizeBuffer = 30;
 80220b0:	231e      	movs	r3, #30
 80220b2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (numBytes % 3) {
 80220b6:	68b9      	ldr	r1, [r7, #8]
 80220b8:	4b53      	ldr	r3, [pc, #332]	; (8022208 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x170>)
 80220ba:	fba3 2301 	umull	r2, r3, r3, r1
 80220be:	085a      	lsrs	r2, r3, #1
 80220c0:	4613      	mov	r3, r2
 80220c2:	005b      	lsls	r3, r3, #1
 80220c4:	4413      	add	r3, r2
 80220c6:	1aca      	subs	r2, r1, r3
 80220c8:	2a00      	cmp	r2, #0
 80220ca:	d002      	beq.n	80220d2 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x3a>
        return ReadError | WrongNumberBytesError;
 80220cc:	f240 2309 	movw	r3, #521	; 0x209
 80220d0:	e095      	b.n	80221fe <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x166>
    if ((numBytes / 3) * 2 > frame._bufferSize) {
 80220d2:	68bb      	ldr	r3, [r7, #8]
 80220d4:	4a4c      	ldr	r2, [pc, #304]	; (8022208 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x170>)
 80220d6:	fba2 2303 	umull	r2, r3, r2, r3
 80220da:	085b      	lsrs	r3, r3, #1
 80220dc:	005a      	lsls	r2, r3, #1
 80220de:	687b      	ldr	r3, [r7, #4]
 80220e0:	685b      	ldr	r3, [r3, #4]
 80220e2:	429a      	cmp	r2, r3
 80220e4:	d902      	bls.n	80220ec <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x54>
        return ReadError | BufferSizeError;
 80220e6:	f240 2302 	movw	r3, #514	; 0x202
 80220ea:	e088      	b.n	80221fe <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x166>
    if (numBytes > sizeBuffer) {
 80220ec:	68bb      	ldr	r3, [r7, #8]
 80220ee:	2b1e      	cmp	r3, #30
 80220f0:	d902      	bls.n	80220f8 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x60>
        return ReadError | InternalBufferSizeError;
 80220f2:	f240 230f 	movw	r3, #527	; 0x20f
 80220f6:	e082      	b.n	80221fe <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x166>
    uint8_t rxData[numBytes];
 80220f8:	68bb      	ldr	r3, [r7, #8]
 80220fa:	1e5c      	subs	r4, r3, #1
 80220fc:	61fc      	str	r4, [r7, #28]
 80220fe:	4623      	mov	r3, r4
 8022100:	3301      	adds	r3, #1
 8022102:	4618      	mov	r0, r3
 8022104:	f04f 0100 	mov.w	r1, #0
 8022108:	f04f 0200 	mov.w	r2, #0
 802210c:	f04f 0300 	mov.w	r3, #0
 8022110:	00cb      	lsls	r3, r1, #3
 8022112:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8022116:	00c2      	lsls	r2, r0, #3
 8022118:	4623      	mov	r3, r4
 802211a:	3301      	adds	r3, #1
 802211c:	4618      	mov	r0, r3
 802211e:	f04f 0100 	mov.w	r1, #0
 8022122:	f04f 0200 	mov.w	r2, #0
 8022126:	f04f 0300 	mov.w	r3, #0
 802212a:	00cb      	lsls	r3, r1, #3
 802212c:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8022130:	00c2      	lsls	r2, r0, #3
 8022132:	4623      	mov	r3, r4
 8022134:	3301      	adds	r3, #1
 8022136:	3307      	adds	r3, #7
 8022138:	08db      	lsrs	r3, r3, #3
 802213a:	00db      	lsls	r3, r3, #3
 802213c:	ebad 0d03 	sub.w	sp, sp, r3
 8022140:	ab02      	add	r3, sp, #8
 8022142:	3300      	adds	r3, #0
 8022144:	61bb      	str	r3, [r7, #24]
    if(HAL_OK != HAL_I2C_Master_Receive(i2c_handle, address << 1, rxData, static_cast<uint8_t>(numBytes), 100)){
 8022146:	7bfb      	ldrb	r3, [r7, #15]
 8022148:	b29b      	uxth	r3, r3
 802214a:	005b      	lsls	r3, r3, #1
 802214c:	b299      	uxth	r1, r3
 802214e:	69ba      	ldr	r2, [r7, #24]
 8022150:	68bb      	ldr	r3, [r7, #8]
 8022152:	b2db      	uxtb	r3, r3
 8022154:	b29b      	uxth	r3, r3
 8022156:	2064      	movs	r0, #100	; 0x64
 8022158:	9000      	str	r0, [sp, #0]
 802215a:	6838      	ldr	r0, [r7, #0]
 802215c:	f7ec f9c4 	bl	800e4e8 <HAL_I2C_Master_Receive>
 8022160:	4603      	mov	r3, r0
 8022162:	2b00      	cmp	r3, #0
 8022164:	bf14      	ite	ne
 8022166:	2301      	movne	r3, #1
 8022168:	2300      	moveq	r3, #0
 802216a:	b2db      	uxtb	r3, r3
 802216c:	2b00      	cmp	r3, #0
 802216e:	d002      	beq.n	8022176 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0xde>
      	return WriteError | I2cOtherError;
 8022170:	f240 130d 	movw	r3, #269	; 0x10d
 8022174:	e043      	b.n	80221fe <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x166>
    readAmount = numBytes;
 8022176:	68bb      	ldr	r3, [r7, #8]
 8022178:	627b      	str	r3, [r7, #36]	; 0x24
    uint16_t j = 0;
 802217a:	2300      	movs	r3, #0
 802217c:	85fb      	strh	r3, [r7, #46]	; 0x2e
        frame._buffer[i++] = rxData[j++];
 802217e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8022180:	1c5a      	adds	r2, r3, #1
 8022182:	85fa      	strh	r2, [r7, #46]	; 0x2e
 8022184:	4618      	mov	r0, r3
 8022186:	687b      	ldr	r3, [r7, #4]
 8022188:	681a      	ldr	r2, [r3, #0]
 802218a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802218c:	1c59      	adds	r1, r3, #1
 802218e:	62b9      	str	r1, [r7, #40]	; 0x28
 8022190:	4413      	add	r3, r2
 8022192:	69ba      	ldr	r2, [r7, #24]
 8022194:	5c12      	ldrb	r2, [r2, r0]
 8022196:	701a      	strb	r2, [r3, #0]
        frame._buffer[i++] = rxData[j++];
 8022198:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 802219a:	1c5a      	adds	r2, r3, #1
 802219c:	85fa      	strh	r2, [r7, #46]	; 0x2e
 802219e:	4618      	mov	r0, r3
 80221a0:	687b      	ldr	r3, [r7, #4]
 80221a2:	681a      	ldr	r2, [r3, #0]
 80221a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80221a6:	1c59      	adds	r1, r3, #1
 80221a8:	62b9      	str	r1, [r7, #40]	; 0x28
 80221aa:	4413      	add	r3, r2
 80221ac:	69ba      	ldr	r2, [r7, #24]
 80221ae:	5c12      	ldrb	r2, [r2, r0]
 80221b0:	701a      	strb	r2, [r3, #0]
        uint8_t actualCRC = rxData[j++];;
 80221b2:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80221b4:	1c5a      	adds	r2, r3, #1
 80221b6:	85fa      	strh	r2, [r7, #46]	; 0x2e
 80221b8:	461a      	mov	r2, r3
 80221ba:	69bb      	ldr	r3, [r7, #24]
 80221bc:	5c9b      	ldrb	r3, [r3, r2]
 80221be:	75fb      	strb	r3, [r7, #23]
        uint8_t expectedCRC = generateCRC(&frame._buffer[i - 2], 2, poly);
 80221c0:	687b      	ldr	r3, [r7, #4]
 80221c2:	681a      	ldr	r2, [r3, #0]
 80221c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80221c6:	3b02      	subs	r3, #2
 80221c8:	4413      	add	r3, r2
 80221ca:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 80221ce:	2102      	movs	r1, #2
 80221d0:	4618      	mov	r0, r3
 80221d2:	f7ff ff21 	bl	8022018 <_Z11generateCRCPKhj13CrcPolynomial>
 80221d6:	4603      	mov	r3, r0
 80221d8:	75bb      	strb	r3, [r7, #22]
        if (actualCRC != expectedCRC) {
 80221da:	7dfa      	ldrb	r2, [r7, #23]
 80221dc:	7dbb      	ldrb	r3, [r7, #22]
 80221de:	429a      	cmp	r2, r3
 80221e0:	d002      	beq.n	80221e8 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x150>
            return ReadError | CRCError;
 80221e2:	f240 230a 	movw	r3, #522	; 0x20a
 80221e6:	e00a      	b.n	80221fe <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x166>
        readAmount -= 3;
 80221e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80221ea:	3b03      	subs	r3, #3
 80221ec:	627b      	str	r3, [r7, #36]	; 0x24
    } while (readAmount > 0);
 80221ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80221f0:	2b00      	cmp	r3, #0
 80221f2:	d000      	beq.n	80221f6 <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0x15e>
    do {
 80221f4:	e7c3      	b.n	802217e <_ZN25SensirionI2CCommunication12receiveFrameEhjR19SensirionI2CRxFrameP19__I2C_HandleTypeDef13CrcPolynomial+0xe6>
    frame._numBytes = i;
 80221f6:	687b      	ldr	r3, [r7, #4]
 80221f8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80221fa:	60da      	str	r2, [r3, #12]
    return NoError;
 80221fc:	2300      	movs	r3, #0
 80221fe:	46ad      	mov	sp, r5
}
 8022200:	4618      	mov	r0, r3
 8022202:	3730      	adds	r7, #48	; 0x30
 8022204:	46bd      	mov	sp, r7
 8022206:	bdb0      	pop	{r4, r5, r7, pc}
 8022208:	aaaaaaab 	.word	0xaaaaaaab

0802220c <_ZN19SensirionI2CTxFrameC1EPhjj13CrcPolynomial>:
#include <stdlib.h>

#include "../../Sensirion_Core/src/SensirionCrc.h"
#include "../../Sensirion_Core/src/SensirionErrors.h"

SensirionI2CTxFrame::SensirionI2CTxFrame(uint8_t buffer[], size_t bufferSize,
 802220c:	b480      	push	{r7}
 802220e:	b085      	sub	sp, #20
 8022210:	af00      	add	r7, sp, #0
 8022212:	60f8      	str	r0, [r7, #12]
 8022214:	60b9      	str	r1, [r7, #8]
 8022216:	607a      	str	r2, [r7, #4]
 8022218:	603b      	str	r3, [r7, #0]
                                         size_t numCommandBytes,
                                         CrcPolynomial poly)
    : _buffer(buffer), _bufferSize(bufferSize), _index(numCommandBytes),
      _numCommandBytes(numCommandBytes), _polynomial_type(poly) {
 802221a:	68fb      	ldr	r3, [r7, #12]
 802221c:	68ba      	ldr	r2, [r7, #8]
 802221e:	601a      	str	r2, [r3, #0]
 8022220:	68fb      	ldr	r3, [r7, #12]
 8022222:	687a      	ldr	r2, [r7, #4]
 8022224:	605a      	str	r2, [r3, #4]
 8022226:	68fb      	ldr	r3, [r7, #12]
 8022228:	683a      	ldr	r2, [r7, #0]
 802222a:	609a      	str	r2, [r3, #8]
 802222c:	68fb      	ldr	r3, [r7, #12]
 802222e:	683a      	ldr	r2, [r7, #0]
 8022230:	60da      	str	r2, [r3, #12]
 8022232:	68fb      	ldr	r3, [r7, #12]
 8022234:	7e3a      	ldrb	r2, [r7, #24]
 8022236:	741a      	strb	r2, [r3, #16]
}
 8022238:	68fb      	ldr	r3, [r7, #12]
 802223a:	4618      	mov	r0, r3
 802223c:	3714      	adds	r7, #20
 802223e:	46bd      	mov	sp, r7
 8022240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022244:	4770      	bx	lr

08022246 <_ZN19SensirionI2CTxFrame23createWithUInt16CommandEtPhj13CrcPolynomial>:
    instance._buffer[0] = command;
    return instance;
}

SensirionI2CTxFrame SensirionI2CTxFrame::createWithUInt16Command(
    uint16_t command, uint8_t buffer[], size_t bufferSize, CrcPolynomial poly) {
 8022246:	b580      	push	{r7, lr}
 8022248:	b086      	sub	sp, #24
 802224a:	af02      	add	r7, sp, #8
 802224c:	60f8      	str	r0, [r7, #12]
 802224e:	607a      	str	r2, [r7, #4]
 8022250:	603b      	str	r3, [r7, #0]
 8022252:	460b      	mov	r3, r1
 8022254:	817b      	strh	r3, [r7, #10]
    SensirionI2CTxFrame instance =
        SensirionI2CTxFrame(buffer, bufferSize, 2, poly);
 8022256:	7e3b      	ldrb	r3, [r7, #24]
 8022258:	9300      	str	r3, [sp, #0]
 802225a:	2302      	movs	r3, #2
 802225c:	683a      	ldr	r2, [r7, #0]
 802225e:	6879      	ldr	r1, [r7, #4]
 8022260:	68f8      	ldr	r0, [r7, #12]
 8022262:	f7ff ffd3 	bl	802220c <_ZN19SensirionI2CTxFrameC1EPhjj13CrcPolynomial>
    instance._buffer[0] = static_cast<uint8_t>((command & 0xFF00) >> 8);
 8022266:	897b      	ldrh	r3, [r7, #10]
 8022268:	0a1b      	lsrs	r3, r3, #8
 802226a:	b29a      	uxth	r2, r3
 802226c:	68fb      	ldr	r3, [r7, #12]
 802226e:	681b      	ldr	r3, [r3, #0]
 8022270:	b2d2      	uxtb	r2, r2
 8022272:	701a      	strb	r2, [r3, #0]
    instance._buffer[1] = static_cast<uint8_t>((command & 0x00FF) >> 0);
 8022274:	68fb      	ldr	r3, [r7, #12]
 8022276:	681b      	ldr	r3, [r3, #0]
 8022278:	3301      	adds	r3, #1
 802227a:	897a      	ldrh	r2, [r7, #10]
 802227c:	b2d2      	uxtb	r2, r2
 802227e:	701a      	strb	r2, [r3, #0]
    return instance;
 8022280:	bf00      	nop
}
 8022282:	68f8      	ldr	r0, [r7, #12]
 8022284:	3710      	adds	r7, #16
 8022286:	46bd      	mov	sp, r7
 8022288:	bd80      	pop	{r7, pc}

0802228a <_ZN19SensirionI2CTxFrame9addUInt16Et>:

uint16_t SensirionI2CTxFrame::addInt32(int32_t data) {
    return addUInt32(static_cast<uint32_t>(data));
}

uint16_t SensirionI2CTxFrame::addUInt16(uint16_t data) {
 802228a:	b580      	push	{r7, lr}
 802228c:	b084      	sub	sp, #16
 802228e:	af00      	add	r7, sp, #0
 8022290:	6078      	str	r0, [r7, #4]
 8022292:	460b      	mov	r3, r1
 8022294:	807b      	strh	r3, [r7, #2]
    uint16_t error = _addByte(static_cast<uint8_t>((data & 0xFF00) >> 8));
 8022296:	887b      	ldrh	r3, [r7, #2]
 8022298:	0a1b      	lsrs	r3, r3, #8
 802229a:	b29b      	uxth	r3, r3
 802229c:	b2db      	uxtb	r3, r3
 802229e:	4619      	mov	r1, r3
 80222a0:	6878      	ldr	r0, [r7, #4]
 80222a2:	f000 f813 	bl	80222cc <_ZN19SensirionI2CTxFrame8_addByteEh>
 80222a6:	4603      	mov	r3, r0
 80222a8:	81fb      	strh	r3, [r7, #14]
    error |= _addByte(static_cast<uint8_t>((data & 0x00FF) >> 0));
 80222aa:	887b      	ldrh	r3, [r7, #2]
 80222ac:	b2db      	uxtb	r3, r3
 80222ae:	4619      	mov	r1, r3
 80222b0:	6878      	ldr	r0, [r7, #4]
 80222b2:	f000 f80b 	bl	80222cc <_ZN19SensirionI2CTxFrame8_addByteEh>
 80222b6:	4603      	mov	r3, r0
 80222b8:	461a      	mov	r2, r3
 80222ba:	89fb      	ldrh	r3, [r7, #14]
 80222bc:	4313      	orrs	r3, r2
 80222be:	81fb      	strh	r3, [r7, #14]
    return error;
 80222c0:	89fb      	ldrh	r3, [r7, #14]
}
 80222c2:	4618      	mov	r0, r3
 80222c4:	3710      	adds	r7, #16
 80222c6:	46bd      	mov	sp, r7
 80222c8:	bd80      	pop	{r7, pc}
	...

080222cc <_ZN19SensirionI2CTxFrame8_addByteEh>:
        error |= _addByte(data[i]);
    }
    return error;
}

uint16_t SensirionI2CTxFrame::_addByte(uint8_t data) {
 80222cc:	b580      	push	{r7, lr}
 80222ce:	b084      	sub	sp, #16
 80222d0:	af00      	add	r7, sp, #0
 80222d2:	6078      	str	r0, [r7, #4]
 80222d4:	460b      	mov	r3, r1
 80222d6:	70fb      	strb	r3, [r7, #3]
    if (_bufferSize <= _index) {
 80222d8:	687b      	ldr	r3, [r7, #4]
 80222da:	685a      	ldr	r2, [r3, #4]
 80222dc:	687b      	ldr	r3, [r7, #4]
 80222de:	689b      	ldr	r3, [r3, #8]
 80222e0:	429a      	cmp	r2, r3
 80222e2:	d802      	bhi.n	80222ea <_ZN19SensirionI2CTxFrame8_addByteEh+0x1e>
        return TxFrameError | BufferSizeError;
 80222e4:	f240 3302 	movw	r3, #770	; 0x302
 80222e8:	e03a      	b.n	8022360 <_ZN19SensirionI2CTxFrame8_addByteEh+0x94>
    }
    _buffer[_index++] = data;
 80222ea:	687b      	ldr	r3, [r7, #4]
 80222ec:	681a      	ldr	r2, [r3, #0]
 80222ee:	687b      	ldr	r3, [r7, #4]
 80222f0:	689b      	ldr	r3, [r3, #8]
 80222f2:	1c58      	adds	r0, r3, #1
 80222f4:	6879      	ldr	r1, [r7, #4]
 80222f6:	6088      	str	r0, [r1, #8]
 80222f8:	4413      	add	r3, r2
 80222fa:	78fa      	ldrb	r2, [r7, #3]
 80222fc:	701a      	strb	r2, [r3, #0]
    if ((_index - _numCommandBytes) % 3 == 2) {
 80222fe:	687b      	ldr	r3, [r7, #4]
 8022300:	689a      	ldr	r2, [r3, #8]
 8022302:	687b      	ldr	r3, [r7, #4]
 8022304:	68db      	ldr	r3, [r3, #12]
 8022306:	1ad1      	subs	r1, r2, r3
 8022308:	4b17      	ldr	r3, [pc, #92]	; (8022368 <_ZN19SensirionI2CTxFrame8_addByteEh+0x9c>)
 802230a:	fba3 2301 	umull	r2, r3, r3, r1
 802230e:	085a      	lsrs	r2, r3, #1
 8022310:	4613      	mov	r3, r2
 8022312:	005b      	lsls	r3, r3, #1
 8022314:	4413      	add	r3, r2
 8022316:	1aca      	subs	r2, r1, r3
 8022318:	2a02      	cmp	r2, #2
 802231a:	d120      	bne.n	802235e <_ZN19SensirionI2CTxFrame8_addByteEh+0x92>
        if (_bufferSize <= _index) {
 802231c:	687b      	ldr	r3, [r7, #4]
 802231e:	685a      	ldr	r2, [r3, #4]
 8022320:	687b      	ldr	r3, [r7, #4]
 8022322:	689b      	ldr	r3, [r3, #8]
 8022324:	429a      	cmp	r2, r3
 8022326:	d802      	bhi.n	802232e <_ZN19SensirionI2CTxFrame8_addByteEh+0x62>
            return TxFrameError | BufferSizeError;
 8022328:	f240 3302 	movw	r3, #770	; 0x302
 802232c:	e018      	b.n	8022360 <_ZN19SensirionI2CTxFrame8_addByteEh+0x94>
        }
        uint8_t crc = generateCRC(&_buffer[_index - 2], 2, _polynomial_type);
 802232e:	687b      	ldr	r3, [r7, #4]
 8022330:	681a      	ldr	r2, [r3, #0]
 8022332:	687b      	ldr	r3, [r7, #4]
 8022334:	689b      	ldr	r3, [r3, #8]
 8022336:	3b02      	subs	r3, #2
 8022338:	18d0      	adds	r0, r2, r3
 802233a:	687b      	ldr	r3, [r7, #4]
 802233c:	7c1b      	ldrb	r3, [r3, #16]
 802233e:	461a      	mov	r2, r3
 8022340:	2102      	movs	r1, #2
 8022342:	f7ff fe69 	bl	8022018 <_Z11generateCRCPKhj13CrcPolynomial>
 8022346:	4603      	mov	r3, r0
 8022348:	73fb      	strb	r3, [r7, #15]
        _buffer[_index++] = crc;
 802234a:	687b      	ldr	r3, [r7, #4]
 802234c:	681a      	ldr	r2, [r3, #0]
 802234e:	687b      	ldr	r3, [r7, #4]
 8022350:	689b      	ldr	r3, [r3, #8]
 8022352:	1c58      	adds	r0, r3, #1
 8022354:	6879      	ldr	r1, [r7, #4]
 8022356:	6088      	str	r0, [r1, #8]
 8022358:	4413      	add	r3, r2
 802235a:	7bfa      	ldrb	r2, [r7, #15]
 802235c:	701a      	strb	r2, [r3, #0]
    }
    return NoError;
 802235e:	2300      	movs	r3, #0
}
 8022360:	4618      	mov	r0, r3
 8022362:	3710      	adds	r7, #16
 8022364:	46bd      	mov	sp, r7
 8022366:	bd80      	pop	{r7, pc}
 8022368:	aaaaaaab 	.word	0xaaaaaaab

0802236c <_ZN16SensirionRxFrameC1EPhj>:
#include <stdint.h>
#include <stdlib.h>

#include "../../Sensirion_Core/src/SensirionErrors.h"

SensirionRxFrame::SensirionRxFrame(uint8_t buffer[], size_t bufferSize)
 802236c:	b480      	push	{r7}
 802236e:	b085      	sub	sp, #20
 8022370:	af00      	add	r7, sp, #0
 8022372:	60f8      	str	r0, [r7, #12]
 8022374:	60b9      	str	r1, [r7, #8]
 8022376:	607a      	str	r2, [r7, #4]
    : _buffer(buffer), _bufferSize(bufferSize), _index(0), _numBytes(0) {
 8022378:	68fb      	ldr	r3, [r7, #12]
 802237a:	68ba      	ldr	r2, [r7, #8]
 802237c:	601a      	str	r2, [r3, #0]
 802237e:	68fb      	ldr	r3, [r7, #12]
 8022380:	687a      	ldr	r2, [r7, #4]
 8022382:	605a      	str	r2, [r3, #4]
 8022384:	68fb      	ldr	r3, [r7, #12]
 8022386:	2200      	movs	r2, #0
 8022388:	609a      	str	r2, [r3, #8]
 802238a:	68fb      	ldr	r3, [r7, #12]
 802238c:	2200      	movs	r2, #0
 802238e:	60da      	str	r2, [r3, #12]
}
 8022390:	68fb      	ldr	r3, [r7, #12]
 8022392:	4618      	mov	r0, r3
 8022394:	3714      	adds	r7, #20
 8022396:	46bd      	mov	sp, r7
 8022398:	f85d 7b04 	ldr.w	r7, [sp], #4
 802239c:	4770      	bx	lr

0802239e <_ZN16SensirionRxFrame9getUInt16ERt>:
    uint16_t error = getUInt32(ret);
    data = static_cast<int32_t>(ret);
    return error;
}

uint16_t SensirionRxFrame::getUInt16(uint16_t& data) {
 802239e:	b480      	push	{r7}
 80223a0:	b083      	sub	sp, #12
 80223a2:	af00      	add	r7, sp, #0
 80223a4:	6078      	str	r0, [r7, #4]
 80223a6:	6039      	str	r1, [r7, #0]
    if (_numBytes < 2) {
 80223a8:	687b      	ldr	r3, [r7, #4]
 80223aa:	68db      	ldr	r3, [r3, #12]
 80223ac:	2b01      	cmp	r3, #1
 80223ae:	d802      	bhi.n	80223b6 <_ZN16SensirionRxFrame9getUInt16ERt+0x18>
        return RxFrameError | NoDataError;
 80223b0:	f240 4301 	movw	r3, #1025	; 0x401
 80223b4:	e023      	b.n	80223fe <_ZN16SensirionRxFrame9getUInt16ERt+0x60>
    }
    data = static_cast<uint16_t>(_buffer[_index++]) << 8;
 80223b6:	687b      	ldr	r3, [r7, #4]
 80223b8:	681a      	ldr	r2, [r3, #0]
 80223ba:	687b      	ldr	r3, [r7, #4]
 80223bc:	689b      	ldr	r3, [r3, #8]
 80223be:	1c58      	adds	r0, r3, #1
 80223c0:	6879      	ldr	r1, [r7, #4]
 80223c2:	6088      	str	r0, [r1, #8]
 80223c4:	4413      	add	r3, r2
 80223c6:	781b      	ldrb	r3, [r3, #0]
 80223c8:	b29b      	uxth	r3, r3
 80223ca:	021b      	lsls	r3, r3, #8
 80223cc:	b29a      	uxth	r2, r3
 80223ce:	683b      	ldr	r3, [r7, #0]
 80223d0:	801a      	strh	r2, [r3, #0]
    data |= static_cast<uint16_t>(_buffer[_index++]);
 80223d2:	687b      	ldr	r3, [r7, #4]
 80223d4:	681a      	ldr	r2, [r3, #0]
 80223d6:	687b      	ldr	r3, [r7, #4]
 80223d8:	689b      	ldr	r3, [r3, #8]
 80223da:	1c58      	adds	r0, r3, #1
 80223dc:	6879      	ldr	r1, [r7, #4]
 80223de:	6088      	str	r0, [r1, #8]
 80223e0:	4413      	add	r3, r2
 80223e2:	781b      	ldrb	r3, [r3, #0]
 80223e4:	b29a      	uxth	r2, r3
 80223e6:	683b      	ldr	r3, [r7, #0]
 80223e8:	881b      	ldrh	r3, [r3, #0]
 80223ea:	4313      	orrs	r3, r2
 80223ec:	b29a      	uxth	r2, r3
 80223ee:	683b      	ldr	r3, [r7, #0]
 80223f0:	801a      	strh	r2, [r3, #0]
    _numBytes -= 2;
 80223f2:	687b      	ldr	r3, [r7, #4]
 80223f4:	68db      	ldr	r3, [r3, #12]
 80223f6:	1e9a      	subs	r2, r3, #2
 80223f8:	687b      	ldr	r3, [r7, #4]
 80223fa:	60da      	str	r2, [r3, #12]
    return NoError;
 80223fc:	2300      	movs	r3, #0
}
 80223fe:	4618      	mov	r0, r3
 8022400:	370c      	adds	r7, #12
 8022402:	46bd      	mov	sp, r7
 8022404:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022408:	4770      	bx	lr
	...

0802240c <__NVIC_SetPriority>:
{
 802240c:	b480      	push	{r7}
 802240e:	b083      	sub	sp, #12
 8022410:	af00      	add	r7, sp, #0
 8022412:	4603      	mov	r3, r0
 8022414:	6039      	str	r1, [r7, #0]
 8022416:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8022418:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802241c:	2b00      	cmp	r3, #0
 802241e:	db0a      	blt.n	8022436 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8022420:	683b      	ldr	r3, [r7, #0]
 8022422:	b2da      	uxtb	r2, r3
 8022424:	490c      	ldr	r1, [pc, #48]	; (8022458 <__NVIC_SetPriority+0x4c>)
 8022426:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802242a:	0112      	lsls	r2, r2, #4
 802242c:	b2d2      	uxtb	r2, r2
 802242e:	440b      	add	r3, r1
 8022430:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8022434:	e00a      	b.n	802244c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8022436:	683b      	ldr	r3, [r7, #0]
 8022438:	b2da      	uxtb	r2, r3
 802243a:	4908      	ldr	r1, [pc, #32]	; (802245c <__NVIC_SetPriority+0x50>)
 802243c:	79fb      	ldrb	r3, [r7, #7]
 802243e:	f003 030f 	and.w	r3, r3, #15
 8022442:	3b04      	subs	r3, #4
 8022444:	0112      	lsls	r2, r2, #4
 8022446:	b2d2      	uxtb	r2, r2
 8022448:	440b      	add	r3, r1
 802244a:	761a      	strb	r2, [r3, #24]
}
 802244c:	bf00      	nop
 802244e:	370c      	adds	r7, #12
 8022450:	46bd      	mov	sp, r7
 8022452:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022456:	4770      	bx	lr
 8022458:	e000e100 	.word	0xe000e100
 802245c:	e000ed00 	.word	0xe000ed00

08022460 <SysTick_Handler>:

/*
  SysTick handler implementation that also clears overflow flag.
*/
#if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
void SysTick_Handler (void) {
 8022460:	b580      	push	{r7, lr}
 8022462:	af00      	add	r7, sp, #0
  /* Clear overflow flag */
  SysTick->CTRL;
 8022464:	4b05      	ldr	r3, [pc, #20]	; (802247c <SysTick_Handler+0x1c>)
 8022466:	681b      	ldr	r3, [r3, #0]

  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 8022468:	f002 fe32 	bl	80250d0 <xTaskGetSchedulerState>
 802246c:	4603      	mov	r3, r0
 802246e:	2b01      	cmp	r3, #1
 8022470:	d001      	beq.n	8022476 <SysTick_Handler+0x16>
    /* Call tick handler */
    xPortSysTickHandler();
 8022472:	f003 ffd1 	bl	8026418 <xPortSysTickHandler>
  }
}
 8022476:	bf00      	nop
 8022478:	bd80      	pop	{r7, pc}
 802247a:	bf00      	nop
 802247c:	e000e010 	.word	0xe000e010

08022480 <SVC_Setup>:
#endif /* SysTick */

/*
  Setup SVC to reset value.
*/
__STATIC_INLINE void SVC_Setup (void) {
 8022480:	b580      	push	{r7, lr}
 8022482:	af00      	add	r7, sp, #0
#if (__ARM_ARCH_7A__ == 0U)
  /* Service Call interrupt might be configured before kernel start     */
  /* and when its priority is lower or equal to BASEPRI, svc intruction */
  /* causes a Hard Fault.                                               */
  NVIC_SetPriority (SVCall_IRQ_NBR, 0U);
 8022484:	2100      	movs	r1, #0
 8022486:	f06f 0004 	mvn.w	r0, #4
 802248a:	f7ff ffbf 	bl	802240c <__NVIC_SetPriority>
#endif
}
 802248e:	bf00      	nop
 8022490:	bd80      	pop	{r7, pc}
	...

08022494 <osKernelInitialize>:
static uint32_t OS_Tick_GetOverflow (void);
/* Get OS Tick interval */
static uint32_t OS_Tick_GetInterval (void);
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
 8022494:	b480      	push	{r7}
 8022496:	b083      	sub	sp, #12
 8022498:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 802249a:	f3ef 8305 	mrs	r3, IPSR
 802249e:	603b      	str	r3, [r7, #0]
  return(result);
 80224a0:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 80224a2:	2b00      	cmp	r3, #0
 80224a4:	d003      	beq.n	80224ae <osKernelInitialize+0x1a>
    stat = osErrorISR;
 80224a6:	f06f 0305 	mvn.w	r3, #5
 80224aa:	607b      	str	r3, [r7, #4]
 80224ac:	e00c      	b.n	80224c8 <osKernelInitialize+0x34>
  }
  else {
    if (KernelState == osKernelInactive) {
 80224ae:	4b0a      	ldr	r3, [pc, #40]	; (80224d8 <osKernelInitialize+0x44>)
 80224b0:	681b      	ldr	r3, [r3, #0]
 80224b2:	2b00      	cmp	r3, #0
 80224b4:	d105      	bne.n	80224c2 <osKernelInitialize+0x2e>
        EvrFreeRTOSSetup(0U);
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 80224b6:	4b08      	ldr	r3, [pc, #32]	; (80224d8 <osKernelInitialize+0x44>)
 80224b8:	2201      	movs	r2, #1
 80224ba:	601a      	str	r2, [r3, #0]
      stat = osOK;
 80224bc:	2300      	movs	r3, #0
 80224be:	607b      	str	r3, [r7, #4]
 80224c0:	e002      	b.n	80224c8 <osKernelInitialize+0x34>
    } else {
      stat = osError;
 80224c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80224c6:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 80224c8:	687b      	ldr	r3, [r7, #4]
}
 80224ca:	4618      	mov	r0, r3
 80224cc:	370c      	adds	r7, #12
 80224ce:	46bd      	mov	sp, r7
 80224d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80224d4:	4770      	bx	lr
 80224d6:	bf00      	nop
 80224d8:	20003acc 	.word	0x20003acc

080224dc <osKernelStart>:
  }

  return (state);
}

osStatus_t osKernelStart (void) {
 80224dc:	b580      	push	{r7, lr}
 80224de:	b082      	sub	sp, #8
 80224e0:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80224e2:	f3ef 8305 	mrs	r3, IPSR
 80224e6:	603b      	str	r3, [r7, #0]
  return(result);
 80224e8:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 80224ea:	2b00      	cmp	r3, #0
 80224ec:	d003      	beq.n	80224f6 <osKernelStart+0x1a>
    stat = osErrorISR;
 80224ee:	f06f 0305 	mvn.w	r3, #5
 80224f2:	607b      	str	r3, [r7, #4]
 80224f4:	e010      	b.n	8022518 <osKernelStart+0x3c>
  }
  else {
    if (KernelState == osKernelReady) {
 80224f6:	4b0b      	ldr	r3, [pc, #44]	; (8022524 <osKernelStart+0x48>)
 80224f8:	681b      	ldr	r3, [r3, #0]
 80224fa:	2b01      	cmp	r3, #1
 80224fc:	d109      	bne.n	8022512 <osKernelStart+0x36>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
 80224fe:	f7ff ffbf 	bl	8022480 <SVC_Setup>
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 8022502:	4b08      	ldr	r3, [pc, #32]	; (8022524 <osKernelStart+0x48>)
 8022504:	2202      	movs	r2, #2
 8022506:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 8022508:	f002 f976 	bl	80247f8 <vTaskStartScheduler>
      stat = osOK;
 802250c:	2300      	movs	r3, #0
 802250e:	607b      	str	r3, [r7, #4]
 8022510:	e002      	b.n	8022518 <osKernelStart+0x3c>
    } else {
      stat = osError;
 8022512:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022516:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 8022518:	687b      	ldr	r3, [r7, #4]
}
 802251a:	4618      	mov	r0, r3
 802251c:	3708      	adds	r7, #8
 802251e:	46bd      	mov	sp, r7
 8022520:	bd80      	pop	{r7, pc}
 8022522:	bf00      	nop
 8022524:	20003acc 	.word	0x20003acc

08022528 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 8022528:	b580      	push	{r7, lr}
 802252a:	b08e      	sub	sp, #56	; 0x38
 802252c:	af04      	add	r7, sp, #16
 802252e:	60f8      	str	r0, [r7, #12]
 8022530:	60b9      	str	r1, [r7, #8]
 8022532:	607a      	str	r2, [r7, #4]
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 8022534:	2300      	movs	r3, #0
 8022536:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022538:	f3ef 8305 	mrs	r3, IPSR
 802253c:	617b      	str	r3, [r7, #20]
  return(result);
 802253e:	697b      	ldr	r3, [r7, #20]

  if (!IS_IRQ() && (func != NULL)) {
 8022540:	2b00      	cmp	r3, #0
 8022542:	d17e      	bne.n	8022642 <osThreadNew+0x11a>
 8022544:	68fb      	ldr	r3, [r7, #12]
 8022546:	2b00      	cmp	r3, #0
 8022548:	d07b      	beq.n	8022642 <osThreadNew+0x11a>
    stack = configMINIMAL_STACK_SIZE;
 802254a:	2380      	movs	r3, #128	; 0x80
 802254c:	623b      	str	r3, [r7, #32]
    prio  = (UBaseType_t)osPriorityNormal;
 802254e:	2318      	movs	r3, #24
 8022550:	61fb      	str	r3, [r7, #28]

    name = NULL;
 8022552:	2300      	movs	r3, #0
 8022554:	627b      	str	r3, [r7, #36]	; 0x24
    mem  = -1;
 8022556:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 802255a:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 802255c:	687b      	ldr	r3, [r7, #4]
 802255e:	2b00      	cmp	r3, #0
 8022560:	d045      	beq.n	80225ee <osThreadNew+0xc6>
      if (attr->name != NULL) {
 8022562:	687b      	ldr	r3, [r7, #4]
 8022564:	681b      	ldr	r3, [r3, #0]
 8022566:	2b00      	cmp	r3, #0
 8022568:	d002      	beq.n	8022570 <osThreadNew+0x48>
        name = attr->name;
 802256a:	687b      	ldr	r3, [r7, #4]
 802256c:	681b      	ldr	r3, [r3, #0]
 802256e:	627b      	str	r3, [r7, #36]	; 0x24
      }
      if (attr->priority != osPriorityNone) {
 8022570:	687b      	ldr	r3, [r7, #4]
 8022572:	699b      	ldr	r3, [r3, #24]
 8022574:	2b00      	cmp	r3, #0
 8022576:	d002      	beq.n	802257e <osThreadNew+0x56>
        prio = (UBaseType_t)attr->priority;
 8022578:	687b      	ldr	r3, [r7, #4]
 802257a:	699b      	ldr	r3, [r3, #24]
 802257c:	61fb      	str	r3, [r7, #28]
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 802257e:	69fb      	ldr	r3, [r7, #28]
 8022580:	2b00      	cmp	r3, #0
 8022582:	d008      	beq.n	8022596 <osThreadNew+0x6e>
 8022584:	69fb      	ldr	r3, [r7, #28]
 8022586:	2b38      	cmp	r3, #56	; 0x38
 8022588:	d805      	bhi.n	8022596 <osThreadNew+0x6e>
 802258a:	687b      	ldr	r3, [r7, #4]
 802258c:	685b      	ldr	r3, [r3, #4]
 802258e:	f003 0301 	and.w	r3, r3, #1
 8022592:	2b00      	cmp	r3, #0
 8022594:	d001      	beq.n	802259a <osThreadNew+0x72>
        return (NULL);
 8022596:	2300      	movs	r3, #0
 8022598:	e054      	b.n	8022644 <osThreadNew+0x11c>
      }

      if (attr->stack_size > 0U) {
 802259a:	687b      	ldr	r3, [r7, #4]
 802259c:	695b      	ldr	r3, [r3, #20]
 802259e:	2b00      	cmp	r3, #0
 80225a0:	d003      	beq.n	80225aa <osThreadNew+0x82>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 80225a2:	687b      	ldr	r3, [r7, #4]
 80225a4:	695b      	ldr	r3, [r3, #20]
 80225a6:	089b      	lsrs	r3, r3, #2
 80225a8:	623b      	str	r3, [r7, #32]
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 80225aa:	687b      	ldr	r3, [r7, #4]
 80225ac:	689b      	ldr	r3, [r3, #8]
 80225ae:	2b00      	cmp	r3, #0
 80225b0:	d00e      	beq.n	80225d0 <osThreadNew+0xa8>
 80225b2:	687b      	ldr	r3, [r7, #4]
 80225b4:	68db      	ldr	r3, [r3, #12]
 80225b6:	2bbb      	cmp	r3, #187	; 0xbb
 80225b8:	d90a      	bls.n	80225d0 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 80225ba:	687b      	ldr	r3, [r7, #4]
 80225bc:	691b      	ldr	r3, [r3, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 80225be:	2b00      	cmp	r3, #0
 80225c0:	d006      	beq.n	80225d0 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 80225c2:	687b      	ldr	r3, [r7, #4]
 80225c4:	695b      	ldr	r3, [r3, #20]
 80225c6:	2b00      	cmp	r3, #0
 80225c8:	d002      	beq.n	80225d0 <osThreadNew+0xa8>
        mem = 1;
 80225ca:	2301      	movs	r3, #1
 80225cc:	61bb      	str	r3, [r7, #24]
 80225ce:	e010      	b.n	80225f2 <osThreadNew+0xca>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 80225d0:	687b      	ldr	r3, [r7, #4]
 80225d2:	689b      	ldr	r3, [r3, #8]
 80225d4:	2b00      	cmp	r3, #0
 80225d6:	d10c      	bne.n	80225f2 <osThreadNew+0xca>
 80225d8:	687b      	ldr	r3, [r7, #4]
 80225da:	68db      	ldr	r3, [r3, #12]
 80225dc:	2b00      	cmp	r3, #0
 80225de:	d108      	bne.n	80225f2 <osThreadNew+0xca>
 80225e0:	687b      	ldr	r3, [r7, #4]
 80225e2:	691b      	ldr	r3, [r3, #16]
 80225e4:	2b00      	cmp	r3, #0
 80225e6:	d104      	bne.n	80225f2 <osThreadNew+0xca>
          mem = 0;
 80225e8:	2300      	movs	r3, #0
 80225ea:	61bb      	str	r3, [r7, #24]
 80225ec:	e001      	b.n	80225f2 <osThreadNew+0xca>
        }
      }
    }
    else {
      mem = 0;
 80225ee:	2300      	movs	r3, #0
 80225f0:	61bb      	str	r3, [r7, #24]
    }

    if (mem == 1) {
 80225f2:	69bb      	ldr	r3, [r7, #24]
 80225f4:	2b01      	cmp	r3, #1
 80225f6:	d110      	bne.n	802261a <osThreadNew+0xf2>
      #if (configSUPPORT_STATIC_ALLOCATION == 1)
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 80225f8:	687b      	ldr	r3, [r7, #4]
 80225fa:	691b      	ldr	r3, [r3, #16]
                                                                                      (StaticTask_t *)attr->cb_mem);
 80225fc:	687a      	ldr	r2, [r7, #4]
 80225fe:	6892      	ldr	r2, [r2, #8]
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8022600:	9202      	str	r2, [sp, #8]
 8022602:	9301      	str	r3, [sp, #4]
 8022604:	69fb      	ldr	r3, [r7, #28]
 8022606:	9300      	str	r3, [sp, #0]
 8022608:	68bb      	ldr	r3, [r7, #8]
 802260a:	6a3a      	ldr	r2, [r7, #32]
 802260c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 802260e:	68f8      	ldr	r0, [r7, #12]
 8022610:	f001 ff06 	bl	8024420 <xTaskCreateStatic>
 8022614:	4603      	mov	r3, r0
 8022616:	613b      	str	r3, [r7, #16]
 8022618:	e013      	b.n	8022642 <osThreadNew+0x11a>
      #endif
    }
    else {
      if (mem == 0) {
 802261a:	69bb      	ldr	r3, [r7, #24]
 802261c:	2b00      	cmp	r3, #0
 802261e:	d110      	bne.n	8022642 <osThreadNew+0x11a>
        #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
          if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 8022620:	6a3b      	ldr	r3, [r7, #32]
 8022622:	b29a      	uxth	r2, r3
 8022624:	f107 0310 	add.w	r3, r7, #16
 8022628:	9301      	str	r3, [sp, #4]
 802262a:	69fb      	ldr	r3, [r7, #28]
 802262c:	9300      	str	r3, [sp, #0]
 802262e:	68bb      	ldr	r3, [r7, #8]
 8022630:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8022632:	68f8      	ldr	r0, [r7, #12]
 8022634:	f001 ff51 	bl	80244da <xTaskCreate>
 8022638:	4603      	mov	r3, r0
 802263a:	2b01      	cmp	r3, #1
 802263c:	d001      	beq.n	8022642 <osThreadNew+0x11a>
            hTask = NULL;
 802263e:	2300      	movs	r3, #0
 8022640:	613b      	str	r3, [r7, #16]
        #endif
      }
    }
  }

  return ((osThreadId_t)hTask);
 8022642:	693b      	ldr	r3, [r7, #16]
}
 8022644:	4618      	mov	r0, r3
 8022646:	3728      	adds	r7, #40	; 0x28
 8022648:	46bd      	mov	sp, r7
 802264a:	bd80      	pop	{r7, pc}

0802264c <osThreadFlagsSet>:
  return (count);
}
#endif /* (configUSE_OS2_THREAD_ENUMERATE == 1) */

#if (configUSE_OS2_THREAD_FLAGS == 1)
uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
 802264c:	b580      	push	{r7, lr}
 802264e:	b088      	sub	sp, #32
 8022650:	af02      	add	r7, sp, #8
 8022652:	6078      	str	r0, [r7, #4]
 8022654:	6039      	str	r1, [r7, #0]
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
 8022656:	687b      	ldr	r3, [r7, #4]
 8022658:	617b      	str	r3, [r7, #20]
  uint32_t rflags;
  BaseType_t yield;

  if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
 802265a:	697b      	ldr	r3, [r7, #20]
 802265c:	2b00      	cmp	r3, #0
 802265e:	d002      	beq.n	8022666 <osThreadFlagsSet+0x1a>
 8022660:	683b      	ldr	r3, [r7, #0]
 8022662:	2b00      	cmp	r3, #0
 8022664:	da03      	bge.n	802266e <osThreadFlagsSet+0x22>
    rflags = (uint32_t)osErrorParameter;
 8022666:	f06f 0303 	mvn.w	r3, #3
 802266a:	60fb      	str	r3, [r7, #12]
 802266c:	e035      	b.n	80226da <osThreadFlagsSet+0x8e>
  }
  else {
    rflags = (uint32_t)osError;
 802266e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022672:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022674:	f3ef 8305 	mrs	r3, IPSR
 8022678:	613b      	str	r3, [r7, #16]
  return(result);
 802267a:	693b      	ldr	r3, [r7, #16]

    if (IS_IRQ()) {
 802267c:	2b00      	cmp	r3, #0
 802267e:	d01f      	beq.n	80226c0 <osThreadFlagsSet+0x74>
      yield = pdFALSE;
 8022680:	2300      	movs	r3, #0
 8022682:	60bb      	str	r3, [r7, #8]

      (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
 8022684:	f107 0308 	add.w	r3, r7, #8
 8022688:	9300      	str	r3, [sp, #0]
 802268a:	2300      	movs	r3, #0
 802268c:	2201      	movs	r2, #1
 802268e:	6839      	ldr	r1, [r7, #0]
 8022690:	6978      	ldr	r0, [r7, #20]
 8022692:	f002 ffc5 	bl	8025620 <xTaskGenericNotifyFromISR>
      (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
 8022696:	f107 030c 	add.w	r3, r7, #12
 802269a:	2200      	movs	r2, #0
 802269c:	9200      	str	r2, [sp, #0]
 802269e:	2200      	movs	r2, #0
 80226a0:	2100      	movs	r1, #0
 80226a2:	6978      	ldr	r0, [r7, #20]
 80226a4:	f002 ffbc 	bl	8025620 <xTaskGenericNotifyFromISR>

      portYIELD_FROM_ISR (yield);
 80226a8:	68bb      	ldr	r3, [r7, #8]
 80226aa:	2b00      	cmp	r3, #0
 80226ac:	d015      	beq.n	80226da <osThreadFlagsSet+0x8e>
 80226ae:	4b0d      	ldr	r3, [pc, #52]	; (80226e4 <osThreadFlagsSet+0x98>)
 80226b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80226b4:	601a      	str	r2, [r3, #0]
 80226b6:	f3bf 8f4f 	dsb	sy
 80226ba:	f3bf 8f6f 	isb	sy
 80226be:	e00c      	b.n	80226da <osThreadFlagsSet+0x8e>
    }
    else {
      (void)xTaskNotify (hTask, flags, eSetBits);
 80226c0:	2300      	movs	r3, #0
 80226c2:	2201      	movs	r2, #1
 80226c4:	6839      	ldr	r1, [r7, #0]
 80226c6:	6978      	ldr	r0, [r7, #20]
 80226c8:	f002 feec 	bl	80254a4 <xTaskGenericNotify>
      (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
 80226cc:	f107 030c 	add.w	r3, r7, #12
 80226d0:	2200      	movs	r2, #0
 80226d2:	2100      	movs	r1, #0
 80226d4:	6978      	ldr	r0, [r7, #20]
 80226d6:	f002 fee5 	bl	80254a4 <xTaskGenericNotify>
    }
  }
  /* Return flags after setting */
  return (rflags);
 80226da:	68fb      	ldr	r3, [r7, #12]
}
 80226dc:	4618      	mov	r0, r3
 80226de:	3718      	adds	r7, #24
 80226e0:	46bd      	mov	sp, r7
 80226e2:	bd80      	pop	{r7, pc}
 80226e4:	e000ed04 	.word	0xe000ed04

080226e8 <osThreadFlagsWait>:
  }

  return (rflags);
}

uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
 80226e8:	b580      	push	{r7, lr}
 80226ea:	b08c      	sub	sp, #48	; 0x30
 80226ec:	af00      	add	r7, sp, #0
 80226ee:	60f8      	str	r0, [r7, #12]
 80226f0:	60b9      	str	r1, [r7, #8]
 80226f2:	607a      	str	r2, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80226f4:	f3ef 8305 	mrs	r3, IPSR
 80226f8:	617b      	str	r3, [r7, #20]
  return(result);
 80226fa:	697b      	ldr	r3, [r7, #20]
  uint32_t rflags, nval;
  uint32_t clear;
  TickType_t t0, td, tout;
  BaseType_t rval;

  if (IS_IRQ()) {
 80226fc:	2b00      	cmp	r3, #0
 80226fe:	d003      	beq.n	8022708 <osThreadFlagsWait+0x20>
    rflags = (uint32_t)osErrorISR;
 8022700:	f06f 0305 	mvn.w	r3, #5
 8022704:	62fb      	str	r3, [r7, #44]	; 0x2c
 8022706:	e06b      	b.n	80227e0 <osThreadFlagsWait+0xf8>
  }
  else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
 8022708:	68fb      	ldr	r3, [r7, #12]
 802270a:	2b00      	cmp	r3, #0
 802270c:	da03      	bge.n	8022716 <osThreadFlagsWait+0x2e>
    rflags = (uint32_t)osErrorParameter;
 802270e:	f06f 0303 	mvn.w	r3, #3
 8022712:	62fb      	str	r3, [r7, #44]	; 0x2c
 8022714:	e064      	b.n	80227e0 <osThreadFlagsWait+0xf8>
  }
  else {
    if ((options & osFlagsNoClear) == osFlagsNoClear) {
 8022716:	68bb      	ldr	r3, [r7, #8]
 8022718:	f003 0302 	and.w	r3, r3, #2
 802271c:	2b00      	cmp	r3, #0
 802271e:	d002      	beq.n	8022726 <osThreadFlagsWait+0x3e>
      clear = 0U;
 8022720:	2300      	movs	r3, #0
 8022722:	62bb      	str	r3, [r7, #40]	; 0x28
 8022724:	e001      	b.n	802272a <osThreadFlagsWait+0x42>
    } else {
      clear = flags;
 8022726:	68fb      	ldr	r3, [r7, #12]
 8022728:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    rflags = 0U;
 802272a:	2300      	movs	r3, #0
 802272c:	62fb      	str	r3, [r7, #44]	; 0x2c
    tout   = timeout;
 802272e:	687b      	ldr	r3, [r7, #4]
 8022730:	627b      	str	r3, [r7, #36]	; 0x24

    t0 = xTaskGetTickCount();
 8022732:	f002 f97d 	bl	8024a30 <xTaskGetTickCount>
 8022736:	6238      	str	r0, [r7, #32]
    do {
      rval = xTaskNotifyWait (0, clear, &nval, tout);
 8022738:	f107 0210 	add.w	r2, r7, #16
 802273c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802273e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8022740:	2000      	movs	r0, #0
 8022742:	f002 fe4f 	bl	80253e4 <xTaskNotifyWait>
 8022746:	61f8      	str	r0, [r7, #28]

      if (rval == pdPASS) {
 8022748:	69fb      	ldr	r3, [r7, #28]
 802274a:	2b01      	cmp	r3, #1
 802274c:	d137      	bne.n	80227be <osThreadFlagsWait+0xd6>
        rflags &= flags;
 802274e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8022750:	68fb      	ldr	r3, [r7, #12]
 8022752:	4013      	ands	r3, r2
 8022754:	62fb      	str	r3, [r7, #44]	; 0x2c
        rflags |= nval;
 8022756:	693b      	ldr	r3, [r7, #16]
 8022758:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802275a:	4313      	orrs	r3, r2
 802275c:	62fb      	str	r3, [r7, #44]	; 0x2c

        if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
 802275e:	68bb      	ldr	r3, [r7, #8]
 8022760:	f003 0301 	and.w	r3, r3, #1
 8022764:	2b00      	cmp	r3, #0
 8022766:	d00c      	beq.n	8022782 <osThreadFlagsWait+0x9a>
          if ((flags & rflags) == flags) {
 8022768:	68fa      	ldr	r2, [r7, #12]
 802276a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802276c:	4013      	ands	r3, r2
 802276e:	68fa      	ldr	r2, [r7, #12]
 8022770:	429a      	cmp	r2, r3
 8022772:	d032      	beq.n	80227da <osThreadFlagsWait+0xf2>
            break;
          } else {
            if (timeout == 0U) {
 8022774:	687b      	ldr	r3, [r7, #4]
 8022776:	2b00      	cmp	r3, #0
 8022778:	d10f      	bne.n	802279a <osThreadFlagsWait+0xb2>
              rflags = (uint32_t)osErrorResource;
 802277a:	f06f 0302 	mvn.w	r3, #2
 802277e:	62fb      	str	r3, [r7, #44]	; 0x2c
              break;
 8022780:	e02e      	b.n	80227e0 <osThreadFlagsWait+0xf8>
            }
          }
        }
        else {
          if ((flags & rflags) != 0) {
 8022782:	68fa      	ldr	r2, [r7, #12]
 8022784:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8022786:	4013      	ands	r3, r2
 8022788:	2b00      	cmp	r3, #0
 802278a:	d128      	bne.n	80227de <osThreadFlagsWait+0xf6>
            break;
          } else {
            if (timeout == 0U) {
 802278c:	687b      	ldr	r3, [r7, #4]
 802278e:	2b00      	cmp	r3, #0
 8022790:	d103      	bne.n	802279a <osThreadFlagsWait+0xb2>
              rflags = (uint32_t)osErrorResource;
 8022792:	f06f 0302 	mvn.w	r3, #2
 8022796:	62fb      	str	r3, [r7, #44]	; 0x2c
              break;
 8022798:	e022      	b.n	80227e0 <osThreadFlagsWait+0xf8>
            }
          }
        }

        /* Update timeout */
        td = xTaskGetTickCount() - t0;
 802279a:	f002 f949 	bl	8024a30 <xTaskGetTickCount>
 802279e:	4602      	mov	r2, r0
 80227a0:	6a3b      	ldr	r3, [r7, #32]
 80227a2:	1ad3      	subs	r3, r2, r3
 80227a4:	61bb      	str	r3, [r7, #24]

        if (td > tout) {
 80227a6:	69ba      	ldr	r2, [r7, #24]
 80227a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80227aa:	429a      	cmp	r2, r3
 80227ac:	d902      	bls.n	80227b4 <osThreadFlagsWait+0xcc>
          tout  = 0;
 80227ae:	2300      	movs	r3, #0
 80227b0:	627b      	str	r3, [r7, #36]	; 0x24
 80227b2:	e00e      	b.n	80227d2 <osThreadFlagsWait+0xea>
        } else {
          tout -= td;
 80227b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80227b6:	69bb      	ldr	r3, [r7, #24]
 80227b8:	1ad3      	subs	r3, r2, r3
 80227ba:	627b      	str	r3, [r7, #36]	; 0x24
 80227bc:	e009      	b.n	80227d2 <osThreadFlagsWait+0xea>
        }
      }
      else {
        if (timeout == 0) {
 80227be:	687b      	ldr	r3, [r7, #4]
 80227c0:	2b00      	cmp	r3, #0
 80227c2:	d103      	bne.n	80227cc <osThreadFlagsWait+0xe4>
          rflags = (uint32_t)osErrorResource;
 80227c4:	f06f 0302 	mvn.w	r3, #2
 80227c8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80227ca:	e002      	b.n	80227d2 <osThreadFlagsWait+0xea>
        } else {
          rflags = (uint32_t)osErrorTimeout;
 80227cc:	f06f 0301 	mvn.w	r3, #1
 80227d0:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
      }
    }
    while (rval != pdFAIL);
 80227d2:	69fb      	ldr	r3, [r7, #28]
 80227d4:	2b00      	cmp	r3, #0
 80227d6:	d1af      	bne.n	8022738 <osThreadFlagsWait+0x50>
 80227d8:	e002      	b.n	80227e0 <osThreadFlagsWait+0xf8>
            break;
 80227da:	bf00      	nop
 80227dc:	e000      	b.n	80227e0 <osThreadFlagsWait+0xf8>
            break;
 80227de:	bf00      	nop
  }

  /* Return flags before clearing */
  return (rflags);
 80227e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 80227e2:	4618      	mov	r0, r3
 80227e4:	3730      	adds	r7, #48	; 0x30
 80227e6:	46bd      	mov	sp, r7
 80227e8:	bd80      	pop	{r7, pc}

080227ea <osDelay>:
#endif /* (configUSE_OS2_THREAD_FLAGS == 1) */

osStatus_t osDelay (uint32_t ticks) {
 80227ea:	b580      	push	{r7, lr}
 80227ec:	b084      	sub	sp, #16
 80227ee:	af00      	add	r7, sp, #0
 80227f0:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80227f2:	f3ef 8305 	mrs	r3, IPSR
 80227f6:	60bb      	str	r3, [r7, #8]
  return(result);
 80227f8:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;

  if (IS_IRQ()) {
 80227fa:	2b00      	cmp	r3, #0
 80227fc:	d003      	beq.n	8022806 <osDelay+0x1c>
    stat = osErrorISR;
 80227fe:	f06f 0305 	mvn.w	r3, #5
 8022802:	60fb      	str	r3, [r7, #12]
 8022804:	e007      	b.n	8022816 <osDelay+0x2c>
  }
  else {
    stat = osOK;
 8022806:	2300      	movs	r3, #0
 8022808:	60fb      	str	r3, [r7, #12]

    if (ticks != 0U) {
 802280a:	687b      	ldr	r3, [r7, #4]
 802280c:	2b00      	cmp	r3, #0
 802280e:	d002      	beq.n	8022816 <osDelay+0x2c>
      vTaskDelay(ticks);
 8022810:	6878      	ldr	r0, [r7, #4]
 8022812:	f001 ffbd 	bl	8024790 <vTaskDelay>
    }
  }

  return (stat);
 8022816:	68fb      	ldr	r3, [r7, #12]
}
 8022818:	4618      	mov	r0, r3
 802281a:	3710      	adds	r7, #16
 802281c:	46bd      	mov	sp, r7
 802281e:	bd80      	pop	{r7, pc}

08022820 <TimerCallback>:
}

/*---------------------------------------------------------------------------*/
#if (configUSE_OS2_TIMER == 1)

static void TimerCallback (TimerHandle_t hTimer) {
 8022820:	b580      	push	{r7, lr}
 8022822:	b084      	sub	sp, #16
 8022824:	af00      	add	r7, sp, #0
 8022826:	6078      	str	r0, [r7, #4]
  TimerCallback_t *callb;

  callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
 8022828:	6878      	ldr	r0, [r7, #4]
 802282a:	f003 fc19 	bl	8026060 <pvTimerGetTimerID>
 802282e:	60f8      	str	r0, [r7, #12]

  if (callb != NULL) {
 8022830:	68fb      	ldr	r3, [r7, #12]
 8022832:	2b00      	cmp	r3, #0
 8022834:	d005      	beq.n	8022842 <TimerCallback+0x22>
    callb->func (callb->arg);
 8022836:	68fb      	ldr	r3, [r7, #12]
 8022838:	681b      	ldr	r3, [r3, #0]
 802283a:	68fa      	ldr	r2, [r7, #12]
 802283c:	6852      	ldr	r2, [r2, #4]
 802283e:	4610      	mov	r0, r2
 8022840:	4798      	blx	r3
  }
}
 8022842:	bf00      	nop
 8022844:	3710      	adds	r7, #16
 8022846:	46bd      	mov	sp, r7
 8022848:	bd80      	pop	{r7, pc}
	...

0802284c <osTimerNew>:

osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
 802284c:	b580      	push	{r7, lr}
 802284e:	b08c      	sub	sp, #48	; 0x30
 8022850:	af02      	add	r7, sp, #8
 8022852:	60f8      	str	r0, [r7, #12]
 8022854:	607a      	str	r2, [r7, #4]
 8022856:	603b      	str	r3, [r7, #0]
 8022858:	460b      	mov	r3, r1
 802285a:	72fb      	strb	r3, [r7, #11]
  TimerHandle_t hTimer;
  TimerCallback_t *callb;
  UBaseType_t reload;
  int32_t mem;

  hTimer = NULL;
 802285c:	2300      	movs	r3, #0
 802285e:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022860:	f3ef 8305 	mrs	r3, IPSR
 8022864:	613b      	str	r3, [r7, #16]
  return(result);
 8022866:	693b      	ldr	r3, [r7, #16]

  if (!IS_IRQ() && (func != NULL)) {
 8022868:	2b00      	cmp	r3, #0
 802286a:	d163      	bne.n	8022934 <osTimerNew+0xe8>
 802286c:	68fb      	ldr	r3, [r7, #12]
 802286e:	2b00      	cmp	r3, #0
 8022870:	d060      	beq.n	8022934 <osTimerNew+0xe8>
    /* Allocate memory to store callback function and argument */
    callb = pvPortMalloc (sizeof(TimerCallback_t));
 8022872:	2008      	movs	r0, #8
 8022874:	f003 fe60 	bl	8026538 <pvPortMalloc>
 8022878:	6178      	str	r0, [r7, #20]

    if (callb != NULL) {
 802287a:	697b      	ldr	r3, [r7, #20]
 802287c:	2b00      	cmp	r3, #0
 802287e:	d059      	beq.n	8022934 <osTimerNew+0xe8>
      callb->func = func;
 8022880:	697b      	ldr	r3, [r7, #20]
 8022882:	68fa      	ldr	r2, [r7, #12]
 8022884:	601a      	str	r2, [r3, #0]
      callb->arg  = argument;
 8022886:	697b      	ldr	r3, [r7, #20]
 8022888:	687a      	ldr	r2, [r7, #4]
 802288a:	605a      	str	r2, [r3, #4]

      if (type == osTimerOnce) {
 802288c:	7afb      	ldrb	r3, [r7, #11]
 802288e:	2b00      	cmp	r3, #0
 8022890:	d102      	bne.n	8022898 <osTimerNew+0x4c>
        reload = pdFALSE;
 8022892:	2300      	movs	r3, #0
 8022894:	61fb      	str	r3, [r7, #28]
 8022896:	e001      	b.n	802289c <osTimerNew+0x50>
      } else {
        reload = pdTRUE;
 8022898:	2301      	movs	r3, #1
 802289a:	61fb      	str	r3, [r7, #28]
      }

      mem  = -1;
 802289c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80228a0:	61bb      	str	r3, [r7, #24]
      name = NULL;
 80228a2:	2300      	movs	r3, #0
 80228a4:	627b      	str	r3, [r7, #36]	; 0x24

      if (attr != NULL) {
 80228a6:	683b      	ldr	r3, [r7, #0]
 80228a8:	2b00      	cmp	r3, #0
 80228aa:	d01c      	beq.n	80228e6 <osTimerNew+0x9a>
        if (attr->name != NULL) {
 80228ac:	683b      	ldr	r3, [r7, #0]
 80228ae:	681b      	ldr	r3, [r3, #0]
 80228b0:	2b00      	cmp	r3, #0
 80228b2:	d002      	beq.n	80228ba <osTimerNew+0x6e>
          name = attr->name;
 80228b4:	683b      	ldr	r3, [r7, #0]
 80228b6:	681b      	ldr	r3, [r3, #0]
 80228b8:	627b      	str	r3, [r7, #36]	; 0x24
        }

        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
 80228ba:	683b      	ldr	r3, [r7, #0]
 80228bc:	689b      	ldr	r3, [r3, #8]
 80228be:	2b00      	cmp	r3, #0
 80228c0:	d006      	beq.n	80228d0 <osTimerNew+0x84>
 80228c2:	683b      	ldr	r3, [r7, #0]
 80228c4:	68db      	ldr	r3, [r3, #12]
 80228c6:	2b2b      	cmp	r3, #43	; 0x2b
 80228c8:	d902      	bls.n	80228d0 <osTimerNew+0x84>
          mem = 1;
 80228ca:	2301      	movs	r3, #1
 80228cc:	61bb      	str	r3, [r7, #24]
 80228ce:	e00c      	b.n	80228ea <osTimerNew+0x9e>
        }
        else {
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 80228d0:	683b      	ldr	r3, [r7, #0]
 80228d2:	689b      	ldr	r3, [r3, #8]
 80228d4:	2b00      	cmp	r3, #0
 80228d6:	d108      	bne.n	80228ea <osTimerNew+0x9e>
 80228d8:	683b      	ldr	r3, [r7, #0]
 80228da:	68db      	ldr	r3, [r3, #12]
 80228dc:	2b00      	cmp	r3, #0
 80228de:	d104      	bne.n	80228ea <osTimerNew+0x9e>
            mem = 0;
 80228e0:	2300      	movs	r3, #0
 80228e2:	61bb      	str	r3, [r7, #24]
 80228e4:	e001      	b.n	80228ea <osTimerNew+0x9e>
          }
        }
      }
      else {
        mem = 0;
 80228e6:	2300      	movs	r3, #0
 80228e8:	61bb      	str	r3, [r7, #24]
      }

      if (mem == 1) {
 80228ea:	69bb      	ldr	r3, [r7, #24]
 80228ec:	2b01      	cmp	r3, #1
 80228ee:	d10c      	bne.n	802290a <osTimerNew+0xbe>
        #if (configSUPPORT_STATIC_ALLOCATION == 1)
          hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
 80228f0:	683b      	ldr	r3, [r7, #0]
 80228f2:	689b      	ldr	r3, [r3, #8]
 80228f4:	9301      	str	r3, [sp, #4]
 80228f6:	4b12      	ldr	r3, [pc, #72]	; (8022940 <osTimerNew+0xf4>)
 80228f8:	9300      	str	r3, [sp, #0]
 80228fa:	697b      	ldr	r3, [r7, #20]
 80228fc:	69fa      	ldr	r2, [r7, #28]
 80228fe:	2101      	movs	r1, #1
 8022900:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8022902:	f003 f82e 	bl	8025962 <xTimerCreateStatic>
 8022906:	6238      	str	r0, [r7, #32]
 8022908:	e00b      	b.n	8022922 <osTimerNew+0xd6>
        #endif
      }
      else {
        if (mem == 0) {
 802290a:	69bb      	ldr	r3, [r7, #24]
 802290c:	2b00      	cmp	r3, #0
 802290e:	d108      	bne.n	8022922 <osTimerNew+0xd6>
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
 8022910:	4b0b      	ldr	r3, [pc, #44]	; (8022940 <osTimerNew+0xf4>)
 8022912:	9300      	str	r3, [sp, #0]
 8022914:	697b      	ldr	r3, [r7, #20]
 8022916:	69fa      	ldr	r2, [r7, #28]
 8022918:	2101      	movs	r1, #1
 802291a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 802291c:	f003 f800 	bl	8025920 <xTimerCreate>
 8022920:	6238      	str	r0, [r7, #32]
          #endif
        }
      }

      if ((hTimer == NULL) && (callb != NULL)) {
 8022922:	6a3b      	ldr	r3, [r7, #32]
 8022924:	2b00      	cmp	r3, #0
 8022926:	d105      	bne.n	8022934 <osTimerNew+0xe8>
 8022928:	697b      	ldr	r3, [r7, #20]
 802292a:	2b00      	cmp	r3, #0
 802292c:	d002      	beq.n	8022934 <osTimerNew+0xe8>
        vPortFree (callb);
 802292e:	6978      	ldr	r0, [r7, #20]
 8022930:	f003 fece 	bl	80266d0 <vPortFree>
      }
    }
  }

  return ((osTimerId_t)hTimer);
 8022934:	6a3b      	ldr	r3, [r7, #32]
}
 8022936:	4618      	mov	r0, r3
 8022938:	3728      	adds	r7, #40	; 0x28
 802293a:	46bd      	mov	sp, r7
 802293c:	bd80      	pop	{r7, pc}
 802293e:	bf00      	nop
 8022940:	08022821 	.word	0x08022821

08022944 <osTimerStart>:
  }

  return (p);
}

osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
 8022944:	b580      	push	{r7, lr}
 8022946:	b088      	sub	sp, #32
 8022948:	af02      	add	r7, sp, #8
 802294a:	6078      	str	r0, [r7, #4]
 802294c:	6039      	str	r1, [r7, #0]
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
 802294e:	687b      	ldr	r3, [r7, #4]
 8022950:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022952:	f3ef 8305 	mrs	r3, IPSR
 8022956:	60fb      	str	r3, [r7, #12]
  return(result);
 8022958:	68fb      	ldr	r3, [r7, #12]
  osStatus_t stat;

  if (IS_IRQ()) {
 802295a:	2b00      	cmp	r3, #0
 802295c:	d003      	beq.n	8022966 <osTimerStart+0x22>
    stat = osErrorISR;
 802295e:	f06f 0305 	mvn.w	r3, #5
 8022962:	617b      	str	r3, [r7, #20]
 8022964:	e017      	b.n	8022996 <osTimerStart+0x52>
  }
  else if (hTimer == NULL) {
 8022966:	693b      	ldr	r3, [r7, #16]
 8022968:	2b00      	cmp	r3, #0
 802296a:	d103      	bne.n	8022974 <osTimerStart+0x30>
    stat = osErrorParameter;
 802296c:	f06f 0303 	mvn.w	r3, #3
 8022970:	617b      	str	r3, [r7, #20]
 8022972:	e010      	b.n	8022996 <osTimerStart+0x52>
  }
  else {
    if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
 8022974:	2300      	movs	r3, #0
 8022976:	9300      	str	r3, [sp, #0]
 8022978:	2300      	movs	r3, #0
 802297a:	683a      	ldr	r2, [r7, #0]
 802297c:	2104      	movs	r1, #4
 802297e:	6938      	ldr	r0, [r7, #16]
 8022980:	f003 f868 	bl	8025a54 <xTimerGenericCommand>
 8022984:	4603      	mov	r3, r0
 8022986:	2b01      	cmp	r3, #1
 8022988:	d102      	bne.n	8022990 <osTimerStart+0x4c>
      stat = osOK;
 802298a:	2300      	movs	r3, #0
 802298c:	617b      	str	r3, [r7, #20]
 802298e:	e002      	b.n	8022996 <osTimerStart+0x52>
    } else {
      stat = osErrorResource;
 8022990:	f06f 0302 	mvn.w	r3, #2
 8022994:	617b      	str	r3, [r7, #20]
    }
  }

  return (stat);
 8022996:	697b      	ldr	r3, [r7, #20]
}
 8022998:	4618      	mov	r0, r3
 802299a:	3718      	adds	r7, #24
 802299c:	46bd      	mov	sp, r7
 802299e:	bd80      	pop	{r7, pc}

080229a0 <osTimerDelete>:
  }

  return (running);
}

osStatus_t osTimerDelete (osTimerId_t timer_id) {
 80229a0:	b580      	push	{r7, lr}
 80229a2:	b088      	sub	sp, #32
 80229a4:	af02      	add	r7, sp, #8
 80229a6:	6078      	str	r0, [r7, #4]
  TimerHandle_t hTimer = (TimerHandle_t)timer_id;
 80229a8:	687b      	ldr	r3, [r7, #4]
 80229aa:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80229ac:	f3ef 8305 	mrs	r3, IPSR
 80229b0:	60bb      	str	r3, [r7, #8]
  return(result);
 80229b2:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;
#ifndef USE_FreeRTOS_HEAP_1
  TimerCallback_t *callb;

  if (IS_IRQ()) {
 80229b4:	2b00      	cmp	r3, #0
 80229b6:	d003      	beq.n	80229c0 <osTimerDelete+0x20>
    stat = osErrorISR;
 80229b8:	f06f 0305 	mvn.w	r3, #5
 80229bc:	617b      	str	r3, [r7, #20]
 80229be:	e01e      	b.n	80229fe <osTimerDelete+0x5e>
  }
  else if (hTimer == NULL) {
 80229c0:	693b      	ldr	r3, [r7, #16]
 80229c2:	2b00      	cmp	r3, #0
 80229c4:	d103      	bne.n	80229ce <osTimerDelete+0x2e>
    stat = osErrorParameter;
 80229c6:	f06f 0303 	mvn.w	r3, #3
 80229ca:	617b      	str	r3, [r7, #20]
 80229cc:	e017      	b.n	80229fe <osTimerDelete+0x5e>
  }
  else {
    callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
 80229ce:	6938      	ldr	r0, [r7, #16]
 80229d0:	f003 fb46 	bl	8026060 <pvTimerGetTimerID>
 80229d4:	60f8      	str	r0, [r7, #12]

    if (xTimerDelete (hTimer, 0) == pdPASS) {
 80229d6:	2300      	movs	r3, #0
 80229d8:	9300      	str	r3, [sp, #0]
 80229da:	2300      	movs	r3, #0
 80229dc:	2200      	movs	r2, #0
 80229de:	2105      	movs	r1, #5
 80229e0:	6938      	ldr	r0, [r7, #16]
 80229e2:	f003 f837 	bl	8025a54 <xTimerGenericCommand>
 80229e6:	4603      	mov	r3, r0
 80229e8:	2b01      	cmp	r3, #1
 80229ea:	d105      	bne.n	80229f8 <osTimerDelete+0x58>
      vPortFree (callb);
 80229ec:	68f8      	ldr	r0, [r7, #12]
 80229ee:	f003 fe6f 	bl	80266d0 <vPortFree>
      stat = osOK;
 80229f2:	2300      	movs	r3, #0
 80229f4:	617b      	str	r3, [r7, #20]
 80229f6:	e002      	b.n	80229fe <osTimerDelete+0x5e>
    } else {
      stat = osErrorResource;
 80229f8:	f06f 0302 	mvn.w	r3, #2
 80229fc:	617b      	str	r3, [r7, #20]
  }
#else
  stat = osError;
#endif

  return (stat);
 80229fe:	697b      	ldr	r3, [r7, #20]
}
 8022a00:	4618      	mov	r0, r3
 8022a02:	3718      	adds	r7, #24
 8022a04:	46bd      	mov	sp, r7
 8022a06:	bd80      	pop	{r7, pc}

08022a08 <osMutexNew>:
}

/*---------------------------------------------------------------------------*/
#if (configUSE_OS2_MUTEX == 1)

osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
 8022a08:	b580      	push	{r7, lr}
 8022a0a:	b088      	sub	sp, #32
 8022a0c:	af00      	add	r7, sp, #0
 8022a0e:	6078      	str	r0, [r7, #4]
  int32_t  mem;
  #if (configQUEUE_REGISTRY_SIZE > 0)
  const char *name;
  #endif

  hMutex = NULL;
 8022a10:	2300      	movs	r3, #0
 8022a12:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022a14:	f3ef 8305 	mrs	r3, IPSR
 8022a18:	60bb      	str	r3, [r7, #8]
  return(result);
 8022a1a:	68bb      	ldr	r3, [r7, #8]

  if (!IS_IRQ()) {
 8022a1c:	2b00      	cmp	r3, #0
 8022a1e:	d174      	bne.n	8022b0a <osMutexNew+0x102>
    if (attr != NULL) {
 8022a20:	687b      	ldr	r3, [r7, #4]
 8022a22:	2b00      	cmp	r3, #0
 8022a24:	d003      	beq.n	8022a2e <osMutexNew+0x26>
      type = attr->attr_bits;
 8022a26:	687b      	ldr	r3, [r7, #4]
 8022a28:	685b      	ldr	r3, [r3, #4]
 8022a2a:	61bb      	str	r3, [r7, #24]
 8022a2c:	e001      	b.n	8022a32 <osMutexNew+0x2a>
    } else {
      type = 0U;
 8022a2e:	2300      	movs	r3, #0
 8022a30:	61bb      	str	r3, [r7, #24]
    }

    if ((type & osMutexRecursive) == osMutexRecursive) {
 8022a32:	69bb      	ldr	r3, [r7, #24]
 8022a34:	f003 0301 	and.w	r3, r3, #1
 8022a38:	2b00      	cmp	r3, #0
 8022a3a:	d002      	beq.n	8022a42 <osMutexNew+0x3a>
      rmtx = 1U;
 8022a3c:	2301      	movs	r3, #1
 8022a3e:	617b      	str	r3, [r7, #20]
 8022a40:	e001      	b.n	8022a46 <osMutexNew+0x3e>
    } else {
      rmtx = 0U;
 8022a42:	2300      	movs	r3, #0
 8022a44:	617b      	str	r3, [r7, #20]
    }

    if ((type & osMutexRobust) != osMutexRobust) {
 8022a46:	69bb      	ldr	r3, [r7, #24]
 8022a48:	f003 0308 	and.w	r3, r3, #8
 8022a4c:	2b00      	cmp	r3, #0
 8022a4e:	d15c      	bne.n	8022b0a <osMutexNew+0x102>
      mem = -1;
 8022a50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022a54:	613b      	str	r3, [r7, #16]

      if (attr != NULL) {
 8022a56:	687b      	ldr	r3, [r7, #4]
 8022a58:	2b00      	cmp	r3, #0
 8022a5a:	d015      	beq.n	8022a88 <osMutexNew+0x80>
        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 8022a5c:	687b      	ldr	r3, [r7, #4]
 8022a5e:	689b      	ldr	r3, [r3, #8]
 8022a60:	2b00      	cmp	r3, #0
 8022a62:	d006      	beq.n	8022a72 <osMutexNew+0x6a>
 8022a64:	687b      	ldr	r3, [r7, #4]
 8022a66:	68db      	ldr	r3, [r3, #12]
 8022a68:	2b4f      	cmp	r3, #79	; 0x4f
 8022a6a:	d902      	bls.n	8022a72 <osMutexNew+0x6a>
          mem = 1;
 8022a6c:	2301      	movs	r3, #1
 8022a6e:	613b      	str	r3, [r7, #16]
 8022a70:	e00c      	b.n	8022a8c <osMutexNew+0x84>
        }
        else {
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 8022a72:	687b      	ldr	r3, [r7, #4]
 8022a74:	689b      	ldr	r3, [r3, #8]
 8022a76:	2b00      	cmp	r3, #0
 8022a78:	d108      	bne.n	8022a8c <osMutexNew+0x84>
 8022a7a:	687b      	ldr	r3, [r7, #4]
 8022a7c:	68db      	ldr	r3, [r3, #12]
 8022a7e:	2b00      	cmp	r3, #0
 8022a80:	d104      	bne.n	8022a8c <osMutexNew+0x84>
            mem = 0;
 8022a82:	2300      	movs	r3, #0
 8022a84:	613b      	str	r3, [r7, #16]
 8022a86:	e001      	b.n	8022a8c <osMutexNew+0x84>
          }
        }
      }
      else {
        mem = 0;
 8022a88:	2300      	movs	r3, #0
 8022a8a:	613b      	str	r3, [r7, #16]
      }

      if (mem == 1) {
 8022a8c:	693b      	ldr	r3, [r7, #16]
 8022a8e:	2b01      	cmp	r3, #1
 8022a90:	d112      	bne.n	8022ab8 <osMutexNew+0xb0>
        #if (configSUPPORT_STATIC_ALLOCATION == 1)
          if (rmtx != 0U) {
 8022a92:	697b      	ldr	r3, [r7, #20]
 8022a94:	2b00      	cmp	r3, #0
 8022a96:	d007      	beq.n	8022aa8 <osMutexNew+0xa0>
            #if (configUSE_RECURSIVE_MUTEXES == 1)
            hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
 8022a98:	687b      	ldr	r3, [r7, #4]
 8022a9a:	689b      	ldr	r3, [r3, #8]
 8022a9c:	4619      	mov	r1, r3
 8022a9e:	2004      	movs	r0, #4
 8022aa0:	f000 fd69 	bl	8023576 <xQueueCreateMutexStatic>
 8022aa4:	61f8      	str	r0, [r7, #28]
 8022aa6:	e016      	b.n	8022ad6 <osMutexNew+0xce>
            #endif
          }
          else {
            hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
 8022aa8:	687b      	ldr	r3, [r7, #4]
 8022aaa:	689b      	ldr	r3, [r3, #8]
 8022aac:	4619      	mov	r1, r3
 8022aae:	2001      	movs	r0, #1
 8022ab0:	f000 fd61 	bl	8023576 <xQueueCreateMutexStatic>
 8022ab4:	61f8      	str	r0, [r7, #28]
 8022ab6:	e00e      	b.n	8022ad6 <osMutexNew+0xce>
          }
        #endif
      }
      else {
        if (mem == 0) {
 8022ab8:	693b      	ldr	r3, [r7, #16]
 8022aba:	2b00      	cmp	r3, #0
 8022abc:	d10b      	bne.n	8022ad6 <osMutexNew+0xce>
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            if (rmtx != 0U) {
 8022abe:	697b      	ldr	r3, [r7, #20]
 8022ac0:	2b00      	cmp	r3, #0
 8022ac2:	d004      	beq.n	8022ace <osMutexNew+0xc6>
              #if (configUSE_RECURSIVE_MUTEXES == 1)
              hMutex = xSemaphoreCreateRecursiveMutex ();
 8022ac4:	2004      	movs	r0, #4
 8022ac6:	f000 fd3e 	bl	8023546 <xQueueCreateMutex>
 8022aca:	61f8      	str	r0, [r7, #28]
 8022acc:	e003      	b.n	8022ad6 <osMutexNew+0xce>
              #endif
            } else {
              hMutex = xSemaphoreCreateMutex ();
 8022ace:	2001      	movs	r0, #1
 8022ad0:	f000 fd39 	bl	8023546 <xQueueCreateMutex>
 8022ad4:	61f8      	str	r0, [r7, #28]
          #endif
        }
      }

      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hMutex != NULL) {
 8022ad6:	69fb      	ldr	r3, [r7, #28]
 8022ad8:	2b00      	cmp	r3, #0
 8022ada:	d00c      	beq.n	8022af6 <osMutexNew+0xee>
        if (attr != NULL) {
 8022adc:	687b      	ldr	r3, [r7, #4]
 8022ade:	2b00      	cmp	r3, #0
 8022ae0:	d003      	beq.n	8022aea <osMutexNew+0xe2>
          name = attr->name;
 8022ae2:	687b      	ldr	r3, [r7, #4]
 8022ae4:	681b      	ldr	r3, [r3, #0]
 8022ae6:	60fb      	str	r3, [r7, #12]
 8022ae8:	e001      	b.n	8022aee <osMutexNew+0xe6>
        } else {
          name = NULL;
 8022aea:	2300      	movs	r3, #0
 8022aec:	60fb      	str	r3, [r7, #12]
        }
        vQueueAddToRegistry (hMutex, name);
 8022aee:	68f9      	ldr	r1, [r7, #12]
 8022af0:	69f8      	ldr	r0, [r7, #28]
 8022af2:	f001 fc0d 	bl	8024310 <vQueueAddToRegistry>
      }
      #endif

      if ((hMutex != NULL) && (rmtx != 0U)) {
 8022af6:	69fb      	ldr	r3, [r7, #28]
 8022af8:	2b00      	cmp	r3, #0
 8022afa:	d006      	beq.n	8022b0a <osMutexNew+0x102>
 8022afc:	697b      	ldr	r3, [r7, #20]
 8022afe:	2b00      	cmp	r3, #0
 8022b00:	d003      	beq.n	8022b0a <osMutexNew+0x102>
        hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
 8022b02:	69fb      	ldr	r3, [r7, #28]
 8022b04:	f043 0301 	orr.w	r3, r3, #1
 8022b08:	61fb      	str	r3, [r7, #28]
      }
    }
  }

  return ((osMutexId_t)hMutex);
 8022b0a:	69fb      	ldr	r3, [r7, #28]
}
 8022b0c:	4618      	mov	r0, r3
 8022b0e:	3720      	adds	r7, #32
 8022b10:	46bd      	mov	sp, r7
 8022b12:	bd80      	pop	{r7, pc}

08022b14 <osMutexAcquire>:

osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
 8022b14:	b580      	push	{r7, lr}
 8022b16:	b086      	sub	sp, #24
 8022b18:	af00      	add	r7, sp, #0
 8022b1a:	6078      	str	r0, [r7, #4]
 8022b1c:	6039      	str	r1, [r7, #0]
  SemaphoreHandle_t hMutex;
  osStatus_t stat;
  uint32_t rmtx;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
 8022b1e:	687b      	ldr	r3, [r7, #4]
 8022b20:	f023 0301 	bic.w	r3, r3, #1
 8022b24:	613b      	str	r3, [r7, #16]

  rmtx = (uint32_t)mutex_id & 1U;
 8022b26:	687b      	ldr	r3, [r7, #4]
 8022b28:	f003 0301 	and.w	r3, r3, #1
 8022b2c:	60fb      	str	r3, [r7, #12]

  stat = osOK;
 8022b2e:	2300      	movs	r3, #0
 8022b30:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022b32:	f3ef 8305 	mrs	r3, IPSR
 8022b36:	60bb      	str	r3, [r7, #8]
  return(result);
 8022b38:	68bb      	ldr	r3, [r7, #8]

  if (IS_IRQ()) {
 8022b3a:	2b00      	cmp	r3, #0
 8022b3c:	d003      	beq.n	8022b46 <osMutexAcquire+0x32>
    stat = osErrorISR;
 8022b3e:	f06f 0305 	mvn.w	r3, #5
 8022b42:	617b      	str	r3, [r7, #20]
 8022b44:	e02c      	b.n	8022ba0 <osMutexAcquire+0x8c>
  }
  else if (hMutex == NULL) {
 8022b46:	693b      	ldr	r3, [r7, #16]
 8022b48:	2b00      	cmp	r3, #0
 8022b4a:	d103      	bne.n	8022b54 <osMutexAcquire+0x40>
    stat = osErrorParameter;
 8022b4c:	f06f 0303 	mvn.w	r3, #3
 8022b50:	617b      	str	r3, [r7, #20]
 8022b52:	e025      	b.n	8022ba0 <osMutexAcquire+0x8c>
  }
  else {
    if (rmtx != 0U) {
 8022b54:	68fb      	ldr	r3, [r7, #12]
 8022b56:	2b00      	cmp	r3, #0
 8022b58:	d011      	beq.n	8022b7e <osMutexAcquire+0x6a>
      #if (configUSE_RECURSIVE_MUTEXES == 1)
      if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
 8022b5a:	6839      	ldr	r1, [r7, #0]
 8022b5c:	6938      	ldr	r0, [r7, #16]
 8022b5e:	f000 fd59 	bl	8023614 <xQueueTakeMutexRecursive>
 8022b62:	4603      	mov	r3, r0
 8022b64:	2b01      	cmp	r3, #1
 8022b66:	d01b      	beq.n	8022ba0 <osMutexAcquire+0x8c>
        if (timeout != 0U) {
 8022b68:	683b      	ldr	r3, [r7, #0]
 8022b6a:	2b00      	cmp	r3, #0
 8022b6c:	d003      	beq.n	8022b76 <osMutexAcquire+0x62>
          stat = osErrorTimeout;
 8022b6e:	f06f 0301 	mvn.w	r3, #1
 8022b72:	617b      	str	r3, [r7, #20]
 8022b74:	e014      	b.n	8022ba0 <osMutexAcquire+0x8c>
        } else {
          stat = osErrorResource;
 8022b76:	f06f 0302 	mvn.w	r3, #2
 8022b7a:	617b      	str	r3, [r7, #20]
 8022b7c:	e010      	b.n	8022ba0 <osMutexAcquire+0x8c>
        }
      }
      #endif
    }
    else {
      if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
 8022b7e:	6839      	ldr	r1, [r7, #0]
 8022b80:	6938      	ldr	r0, [r7, #16]
 8022b82:	f001 f8ed 	bl	8023d60 <xQueueSemaphoreTake>
 8022b86:	4603      	mov	r3, r0
 8022b88:	2b01      	cmp	r3, #1
 8022b8a:	d009      	beq.n	8022ba0 <osMutexAcquire+0x8c>
        if (timeout != 0U) {
 8022b8c:	683b      	ldr	r3, [r7, #0]
 8022b8e:	2b00      	cmp	r3, #0
 8022b90:	d003      	beq.n	8022b9a <osMutexAcquire+0x86>
          stat = osErrorTimeout;
 8022b92:	f06f 0301 	mvn.w	r3, #1
 8022b96:	617b      	str	r3, [r7, #20]
 8022b98:	e002      	b.n	8022ba0 <osMutexAcquire+0x8c>
        } else {
          stat = osErrorResource;
 8022b9a:	f06f 0302 	mvn.w	r3, #2
 8022b9e:	617b      	str	r3, [r7, #20]
        }
      }
    }
  }

  return (stat);
 8022ba0:	697b      	ldr	r3, [r7, #20]
}
 8022ba2:	4618      	mov	r0, r3
 8022ba4:	3718      	adds	r7, #24
 8022ba6:	46bd      	mov	sp, r7
 8022ba8:	bd80      	pop	{r7, pc}

08022baa <osMutexRelease>:

osStatus_t osMutexRelease (osMutexId_t mutex_id) {
 8022baa:	b580      	push	{r7, lr}
 8022bac:	b086      	sub	sp, #24
 8022bae:	af00      	add	r7, sp, #0
 8022bb0:	6078      	str	r0, [r7, #4]
  SemaphoreHandle_t hMutex;
  osStatus_t stat;
  uint32_t rmtx;

  hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
 8022bb2:	687b      	ldr	r3, [r7, #4]
 8022bb4:	f023 0301 	bic.w	r3, r3, #1
 8022bb8:	613b      	str	r3, [r7, #16]

  rmtx = (uint32_t)mutex_id & 1U;
 8022bba:	687b      	ldr	r3, [r7, #4]
 8022bbc:	f003 0301 	and.w	r3, r3, #1
 8022bc0:	60fb      	str	r3, [r7, #12]

  stat = osOK;
 8022bc2:	2300      	movs	r3, #0
 8022bc4:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022bc6:	f3ef 8305 	mrs	r3, IPSR
 8022bca:	60bb      	str	r3, [r7, #8]
  return(result);
 8022bcc:	68bb      	ldr	r3, [r7, #8]

  if (IS_IRQ()) {
 8022bce:	2b00      	cmp	r3, #0
 8022bd0:	d003      	beq.n	8022bda <osMutexRelease+0x30>
    stat = osErrorISR;
 8022bd2:	f06f 0305 	mvn.w	r3, #5
 8022bd6:	617b      	str	r3, [r7, #20]
 8022bd8:	e01f      	b.n	8022c1a <osMutexRelease+0x70>
  }
  else if (hMutex == NULL) {
 8022bda:	693b      	ldr	r3, [r7, #16]
 8022bdc:	2b00      	cmp	r3, #0
 8022bde:	d103      	bne.n	8022be8 <osMutexRelease+0x3e>
    stat = osErrorParameter;
 8022be0:	f06f 0303 	mvn.w	r3, #3
 8022be4:	617b      	str	r3, [r7, #20]
 8022be6:	e018      	b.n	8022c1a <osMutexRelease+0x70>
  }
  else {
    if (rmtx != 0U) {
 8022be8:	68fb      	ldr	r3, [r7, #12]
 8022bea:	2b00      	cmp	r3, #0
 8022bec:	d009      	beq.n	8022c02 <osMutexRelease+0x58>
      #if (configUSE_RECURSIVE_MUTEXES == 1)
      if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
 8022bee:	6938      	ldr	r0, [r7, #16]
 8022bf0:	f000 fcdc 	bl	80235ac <xQueueGiveMutexRecursive>
 8022bf4:	4603      	mov	r3, r0
 8022bf6:	2b01      	cmp	r3, #1
 8022bf8:	d00f      	beq.n	8022c1a <osMutexRelease+0x70>
        stat = osErrorResource;
 8022bfa:	f06f 0302 	mvn.w	r3, #2
 8022bfe:	617b      	str	r3, [r7, #20]
 8022c00:	e00b      	b.n	8022c1a <osMutexRelease+0x70>
      }
      #endif
    }
    else {
      if (xSemaphoreGive (hMutex) != pdPASS) {
 8022c02:	2300      	movs	r3, #0
 8022c04:	2200      	movs	r2, #0
 8022c06:	2100      	movs	r1, #0
 8022c08:	6938      	ldr	r0, [r7, #16]
 8022c0a:	f000 fda3 	bl	8023754 <xQueueGenericSend>
 8022c0e:	4603      	mov	r3, r0
 8022c10:	2b01      	cmp	r3, #1
 8022c12:	d002      	beq.n	8022c1a <osMutexRelease+0x70>
        stat = osErrorResource;
 8022c14:	f06f 0302 	mvn.w	r3, #2
 8022c18:	617b      	str	r3, [r7, #20]
      }
    }
  }

  return (stat);
 8022c1a:	697b      	ldr	r3, [r7, #20]
}
 8022c1c:	4618      	mov	r0, r3
 8022c1e:	3718      	adds	r7, #24
 8022c20:	46bd      	mov	sp, r7
 8022c22:	bd80      	pop	{r7, pc}

08022c24 <osSemaphoreNew>:
}
#endif /* (configUSE_OS2_MUTEX == 1) */

/*---------------------------------------------------------------------------*/

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
 8022c24:	b580      	push	{r7, lr}
 8022c26:	b08a      	sub	sp, #40	; 0x28
 8022c28:	af02      	add	r7, sp, #8
 8022c2a:	60f8      	str	r0, [r7, #12]
 8022c2c:	60b9      	str	r1, [r7, #8]
 8022c2e:	607a      	str	r2, [r7, #4]
  int32_t mem;
  #if (configQUEUE_REGISTRY_SIZE > 0)
  const char *name;
  #endif

  hSemaphore = NULL;
 8022c30:	2300      	movs	r3, #0
 8022c32:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022c34:	f3ef 8305 	mrs	r3, IPSR
 8022c38:	613b      	str	r3, [r7, #16]
  return(result);
 8022c3a:	693b      	ldr	r3, [r7, #16]

  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 8022c3c:	2b00      	cmp	r3, #0
 8022c3e:	d175      	bne.n	8022d2c <osSemaphoreNew+0x108>
 8022c40:	68fb      	ldr	r3, [r7, #12]
 8022c42:	2b00      	cmp	r3, #0
 8022c44:	d072      	beq.n	8022d2c <osSemaphoreNew+0x108>
 8022c46:	68ba      	ldr	r2, [r7, #8]
 8022c48:	68fb      	ldr	r3, [r7, #12]
 8022c4a:	429a      	cmp	r2, r3
 8022c4c:	d86e      	bhi.n	8022d2c <osSemaphoreNew+0x108>
    mem = -1;
 8022c4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022c52:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 8022c54:	687b      	ldr	r3, [r7, #4]
 8022c56:	2b00      	cmp	r3, #0
 8022c58:	d015      	beq.n	8022c86 <osSemaphoreNew+0x62>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 8022c5a:	687b      	ldr	r3, [r7, #4]
 8022c5c:	689b      	ldr	r3, [r3, #8]
 8022c5e:	2b00      	cmp	r3, #0
 8022c60:	d006      	beq.n	8022c70 <osSemaphoreNew+0x4c>
 8022c62:	687b      	ldr	r3, [r7, #4]
 8022c64:	68db      	ldr	r3, [r3, #12]
 8022c66:	2b4f      	cmp	r3, #79	; 0x4f
 8022c68:	d902      	bls.n	8022c70 <osSemaphoreNew+0x4c>
        mem = 1;
 8022c6a:	2301      	movs	r3, #1
 8022c6c:	61bb      	str	r3, [r7, #24]
 8022c6e:	e00c      	b.n	8022c8a <osSemaphoreNew+0x66>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 8022c70:	687b      	ldr	r3, [r7, #4]
 8022c72:	689b      	ldr	r3, [r3, #8]
 8022c74:	2b00      	cmp	r3, #0
 8022c76:	d108      	bne.n	8022c8a <osSemaphoreNew+0x66>
 8022c78:	687b      	ldr	r3, [r7, #4]
 8022c7a:	68db      	ldr	r3, [r3, #12]
 8022c7c:	2b00      	cmp	r3, #0
 8022c7e:	d104      	bne.n	8022c8a <osSemaphoreNew+0x66>
          mem = 0;
 8022c80:	2300      	movs	r3, #0
 8022c82:	61bb      	str	r3, [r7, #24]
 8022c84:	e001      	b.n	8022c8a <osSemaphoreNew+0x66>
        }
      }
    }
    else {
      mem = 0;
 8022c86:	2300      	movs	r3, #0
 8022c88:	61bb      	str	r3, [r7, #24]
    }

    if (mem != -1) {
 8022c8a:	69bb      	ldr	r3, [r7, #24]
 8022c8c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8022c90:	d04c      	beq.n	8022d2c <osSemaphoreNew+0x108>
      if (max_count == 1U) {
 8022c92:	68fb      	ldr	r3, [r7, #12]
 8022c94:	2b01      	cmp	r3, #1
 8022c96:	d128      	bne.n	8022cea <osSemaphoreNew+0xc6>
        if (mem == 1) {
 8022c98:	69bb      	ldr	r3, [r7, #24]
 8022c9a:	2b01      	cmp	r3, #1
 8022c9c:	d10a      	bne.n	8022cb4 <osSemaphoreNew+0x90>
          #if (configSUPPORT_STATIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
 8022c9e:	687b      	ldr	r3, [r7, #4]
 8022ca0:	689b      	ldr	r3, [r3, #8]
 8022ca2:	2203      	movs	r2, #3
 8022ca4:	9200      	str	r2, [sp, #0]
 8022ca6:	2200      	movs	r2, #0
 8022ca8:	2100      	movs	r1, #0
 8022caa:	2001      	movs	r0, #1
 8022cac:	f000 fb5c 	bl	8023368 <xQueueGenericCreateStatic>
 8022cb0:	61f8      	str	r0, [r7, #28]
 8022cb2:	e005      	b.n	8022cc0 <osSemaphoreNew+0x9c>
          #endif
        }
        else {
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateBinary();
 8022cb4:	2203      	movs	r2, #3
 8022cb6:	2100      	movs	r1, #0
 8022cb8:	2001      	movs	r0, #1
 8022cba:	f000 fbcd 	bl	8023458 <xQueueGenericCreate>
 8022cbe:	61f8      	str	r0, [r7, #28]
          #endif
        }

        if ((hSemaphore != NULL) && (initial_count != 0U)) {
 8022cc0:	69fb      	ldr	r3, [r7, #28]
 8022cc2:	2b00      	cmp	r3, #0
 8022cc4:	d022      	beq.n	8022d0c <osSemaphoreNew+0xe8>
 8022cc6:	68bb      	ldr	r3, [r7, #8]
 8022cc8:	2b00      	cmp	r3, #0
 8022cca:	d01f      	beq.n	8022d0c <osSemaphoreNew+0xe8>
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
 8022ccc:	2300      	movs	r3, #0
 8022cce:	2200      	movs	r2, #0
 8022cd0:	2100      	movs	r1, #0
 8022cd2:	69f8      	ldr	r0, [r7, #28]
 8022cd4:	f000 fd3e 	bl	8023754 <xQueueGenericSend>
 8022cd8:	4603      	mov	r3, r0
 8022cda:	2b01      	cmp	r3, #1
 8022cdc:	d016      	beq.n	8022d0c <osSemaphoreNew+0xe8>
            vSemaphoreDelete (hSemaphore);
 8022cde:	69f8      	ldr	r0, [r7, #28]
 8022ce0:	f001 f9ca 	bl	8024078 <vQueueDelete>
            hSemaphore = NULL;
 8022ce4:	2300      	movs	r3, #0
 8022ce6:	61fb      	str	r3, [r7, #28]
 8022ce8:	e010      	b.n	8022d0c <osSemaphoreNew+0xe8>
          }
        }
      }
      else {
        if (mem == 1) {
 8022cea:	69bb      	ldr	r3, [r7, #24]
 8022cec:	2b01      	cmp	r3, #1
 8022cee:	d108      	bne.n	8022d02 <osSemaphoreNew+0xde>
          #if (configSUPPORT_STATIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
 8022cf0:	687b      	ldr	r3, [r7, #4]
 8022cf2:	689b      	ldr	r3, [r3, #8]
 8022cf4:	461a      	mov	r2, r3
 8022cf6:	68b9      	ldr	r1, [r7, #8]
 8022cf8:	68f8      	ldr	r0, [r7, #12]
 8022cfa:	f000 fcc1 	bl	8023680 <xQueueCreateCountingSemaphoreStatic>
 8022cfe:	61f8      	str	r0, [r7, #28]
 8022d00:	e004      	b.n	8022d0c <osSemaphoreNew+0xe8>
          #endif
        }
        else {
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
 8022d02:	68b9      	ldr	r1, [r7, #8]
 8022d04:	68f8      	ldr	r0, [r7, #12]
 8022d06:	f000 fcf2 	bl	80236ee <xQueueCreateCountingSemaphore>
 8022d0a:	61f8      	str	r0, [r7, #28]
          #endif
        }
      }
      
      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hSemaphore != NULL) {
 8022d0c:	69fb      	ldr	r3, [r7, #28]
 8022d0e:	2b00      	cmp	r3, #0
 8022d10:	d00c      	beq.n	8022d2c <osSemaphoreNew+0x108>
        if (attr != NULL) {
 8022d12:	687b      	ldr	r3, [r7, #4]
 8022d14:	2b00      	cmp	r3, #0
 8022d16:	d003      	beq.n	8022d20 <osSemaphoreNew+0xfc>
          name = attr->name;
 8022d18:	687b      	ldr	r3, [r7, #4]
 8022d1a:	681b      	ldr	r3, [r3, #0]
 8022d1c:	617b      	str	r3, [r7, #20]
 8022d1e:	e001      	b.n	8022d24 <osSemaphoreNew+0x100>
        } else {
          name = NULL;
 8022d20:	2300      	movs	r3, #0
 8022d22:	617b      	str	r3, [r7, #20]
        }
        vQueueAddToRegistry (hSemaphore, name);
 8022d24:	6979      	ldr	r1, [r7, #20]
 8022d26:	69f8      	ldr	r0, [r7, #28]
 8022d28:	f001 faf2 	bl	8024310 <vQueueAddToRegistry>
      }
      #endif
    }
  }

  return ((osSemaphoreId_t)hSemaphore);
 8022d2c:	69fb      	ldr	r3, [r7, #28]
}
 8022d2e:	4618      	mov	r0, r3
 8022d30:	3720      	adds	r7, #32
 8022d32:	46bd      	mov	sp, r7
 8022d34:	bd80      	pop	{r7, pc}
	...

08022d38 <osSemaphoreAcquire>:

osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
 8022d38:	b580      	push	{r7, lr}
 8022d3a:	b086      	sub	sp, #24
 8022d3c:	af00      	add	r7, sp, #0
 8022d3e:	6078      	str	r0, [r7, #4]
 8022d40:	6039      	str	r1, [r7, #0]
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
 8022d42:	687b      	ldr	r3, [r7, #4]
 8022d44:	613b      	str	r3, [r7, #16]
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;
 8022d46:	2300      	movs	r3, #0
 8022d48:	617b      	str	r3, [r7, #20]

  if (hSemaphore == NULL) {
 8022d4a:	693b      	ldr	r3, [r7, #16]
 8022d4c:	2b00      	cmp	r3, #0
 8022d4e:	d103      	bne.n	8022d58 <osSemaphoreAcquire+0x20>
    stat = osErrorParameter;
 8022d50:	f06f 0303 	mvn.w	r3, #3
 8022d54:	617b      	str	r3, [r7, #20]
 8022d56:	e039      	b.n	8022dcc <osSemaphoreAcquire+0x94>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022d58:	f3ef 8305 	mrs	r3, IPSR
 8022d5c:	60fb      	str	r3, [r7, #12]
  return(result);
 8022d5e:	68fb      	ldr	r3, [r7, #12]
  }
  else if (IS_IRQ()) {
 8022d60:	2b00      	cmp	r3, #0
 8022d62:	d022      	beq.n	8022daa <osSemaphoreAcquire+0x72>
    if (timeout != 0U) {
 8022d64:	683b      	ldr	r3, [r7, #0]
 8022d66:	2b00      	cmp	r3, #0
 8022d68:	d003      	beq.n	8022d72 <osSemaphoreAcquire+0x3a>
      stat = osErrorParameter;
 8022d6a:	f06f 0303 	mvn.w	r3, #3
 8022d6e:	617b      	str	r3, [r7, #20]
 8022d70:	e02c      	b.n	8022dcc <osSemaphoreAcquire+0x94>
    }
    else {
      yield = pdFALSE;
 8022d72:	2300      	movs	r3, #0
 8022d74:	60bb      	str	r3, [r7, #8]

      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
 8022d76:	f107 0308 	add.w	r3, r7, #8
 8022d7a:	461a      	mov	r2, r3
 8022d7c:	2100      	movs	r1, #0
 8022d7e:	6938      	ldr	r0, [r7, #16]
 8022d80:	f001 f8fa 	bl	8023f78 <xQueueReceiveFromISR>
 8022d84:	4603      	mov	r3, r0
 8022d86:	2b01      	cmp	r3, #1
 8022d88:	d003      	beq.n	8022d92 <osSemaphoreAcquire+0x5a>
        stat = osErrorResource;
 8022d8a:	f06f 0302 	mvn.w	r3, #2
 8022d8e:	617b      	str	r3, [r7, #20]
 8022d90:	e01c      	b.n	8022dcc <osSemaphoreAcquire+0x94>
      } else {
        portYIELD_FROM_ISR (yield);
 8022d92:	68bb      	ldr	r3, [r7, #8]
 8022d94:	2b00      	cmp	r3, #0
 8022d96:	d019      	beq.n	8022dcc <osSemaphoreAcquire+0x94>
 8022d98:	4b0f      	ldr	r3, [pc, #60]	; (8022dd8 <osSemaphoreAcquire+0xa0>)
 8022d9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8022d9e:	601a      	str	r2, [r3, #0]
 8022da0:	f3bf 8f4f 	dsb	sy
 8022da4:	f3bf 8f6f 	isb	sy
 8022da8:	e010      	b.n	8022dcc <osSemaphoreAcquire+0x94>
      }
    }
  }
  else {
    if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
 8022daa:	6839      	ldr	r1, [r7, #0]
 8022dac:	6938      	ldr	r0, [r7, #16]
 8022dae:	f000 ffd7 	bl	8023d60 <xQueueSemaphoreTake>
 8022db2:	4603      	mov	r3, r0
 8022db4:	2b01      	cmp	r3, #1
 8022db6:	d009      	beq.n	8022dcc <osSemaphoreAcquire+0x94>
      if (timeout != 0U) {
 8022db8:	683b      	ldr	r3, [r7, #0]
 8022dba:	2b00      	cmp	r3, #0
 8022dbc:	d003      	beq.n	8022dc6 <osSemaphoreAcquire+0x8e>
        stat = osErrorTimeout;
 8022dbe:	f06f 0301 	mvn.w	r3, #1
 8022dc2:	617b      	str	r3, [r7, #20]
 8022dc4:	e002      	b.n	8022dcc <osSemaphoreAcquire+0x94>
      } else {
        stat = osErrorResource;
 8022dc6:	f06f 0302 	mvn.w	r3, #2
 8022dca:	617b      	str	r3, [r7, #20]
      }
    }
  }

  return (stat);
 8022dcc:	697b      	ldr	r3, [r7, #20]
}
 8022dce:	4618      	mov	r0, r3
 8022dd0:	3718      	adds	r7, #24
 8022dd2:	46bd      	mov	sp, r7
 8022dd4:	bd80      	pop	{r7, pc}
 8022dd6:	bf00      	nop
 8022dd8:	e000ed04 	.word	0xe000ed04

08022ddc <osSemaphoreRelease>:

osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
 8022ddc:	b580      	push	{r7, lr}
 8022dde:	b086      	sub	sp, #24
 8022de0:	af00      	add	r7, sp, #0
 8022de2:	6078      	str	r0, [r7, #4]
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
 8022de4:	687b      	ldr	r3, [r7, #4]
 8022de6:	613b      	str	r3, [r7, #16]
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;
 8022de8:	2300      	movs	r3, #0
 8022dea:	617b      	str	r3, [r7, #20]

  if (hSemaphore == NULL) {
 8022dec:	693b      	ldr	r3, [r7, #16]
 8022dee:	2b00      	cmp	r3, #0
 8022df0:	d103      	bne.n	8022dfa <osSemaphoreRelease+0x1e>
    stat = osErrorParameter;
 8022df2:	f06f 0303 	mvn.w	r3, #3
 8022df6:	617b      	str	r3, [r7, #20]
 8022df8:	e02c      	b.n	8022e54 <osSemaphoreRelease+0x78>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022dfa:	f3ef 8305 	mrs	r3, IPSR
 8022dfe:	60fb      	str	r3, [r7, #12]
  return(result);
 8022e00:	68fb      	ldr	r3, [r7, #12]
  }
  else if (IS_IRQ()) {
 8022e02:	2b00      	cmp	r3, #0
 8022e04:	d01a      	beq.n	8022e3c <osSemaphoreRelease+0x60>
    yield = pdFALSE;
 8022e06:	2300      	movs	r3, #0
 8022e08:	60bb      	str	r3, [r7, #8]

    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
 8022e0a:	f107 0308 	add.w	r3, r7, #8
 8022e0e:	4619      	mov	r1, r3
 8022e10:	6938      	ldr	r0, [r7, #16]
 8022e12:	f000 fe38 	bl	8023a86 <xQueueGiveFromISR>
 8022e16:	4603      	mov	r3, r0
 8022e18:	2b01      	cmp	r3, #1
 8022e1a:	d003      	beq.n	8022e24 <osSemaphoreRelease+0x48>
      stat = osErrorResource;
 8022e1c:	f06f 0302 	mvn.w	r3, #2
 8022e20:	617b      	str	r3, [r7, #20]
 8022e22:	e017      	b.n	8022e54 <osSemaphoreRelease+0x78>
    } else {
      portYIELD_FROM_ISR (yield);
 8022e24:	68bb      	ldr	r3, [r7, #8]
 8022e26:	2b00      	cmp	r3, #0
 8022e28:	d014      	beq.n	8022e54 <osSemaphoreRelease+0x78>
 8022e2a:	4b0d      	ldr	r3, [pc, #52]	; (8022e60 <osSemaphoreRelease+0x84>)
 8022e2c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8022e30:	601a      	str	r2, [r3, #0]
 8022e32:	f3bf 8f4f 	dsb	sy
 8022e36:	f3bf 8f6f 	isb	sy
 8022e3a:	e00b      	b.n	8022e54 <osSemaphoreRelease+0x78>
    }
  }
  else {
    if (xSemaphoreGive (hSemaphore) != pdPASS) {
 8022e3c:	2300      	movs	r3, #0
 8022e3e:	2200      	movs	r2, #0
 8022e40:	2100      	movs	r1, #0
 8022e42:	6938      	ldr	r0, [r7, #16]
 8022e44:	f000 fc86 	bl	8023754 <xQueueGenericSend>
 8022e48:	4603      	mov	r3, r0
 8022e4a:	2b01      	cmp	r3, #1
 8022e4c:	d002      	beq.n	8022e54 <osSemaphoreRelease+0x78>
      stat = osErrorResource;
 8022e4e:	f06f 0302 	mvn.w	r3, #2
 8022e52:	617b      	str	r3, [r7, #20]
    }
  }

  return (stat);
 8022e54:	697b      	ldr	r3, [r7, #20]
}
 8022e56:	4618      	mov	r0, r3
 8022e58:	3718      	adds	r7, #24
 8022e5a:	46bd      	mov	sp, r7
 8022e5c:	bd80      	pop	{r7, pc}
 8022e5e:	bf00      	nop
 8022e60:	e000ed04 	.word	0xe000ed04

08022e64 <osMessageQueueNew>:
  return (stat);
}

/*---------------------------------------------------------------------------*/

osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
 8022e64:	b580      	push	{r7, lr}
 8022e66:	b08a      	sub	sp, #40	; 0x28
 8022e68:	af02      	add	r7, sp, #8
 8022e6a:	60f8      	str	r0, [r7, #12]
 8022e6c:	60b9      	str	r1, [r7, #8]
 8022e6e:	607a      	str	r2, [r7, #4]
  int32_t mem;
  #if (configQUEUE_REGISTRY_SIZE > 0)
  const char *name;
  #endif

  hQueue = NULL;
 8022e70:	2300      	movs	r3, #0
 8022e72:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022e74:	f3ef 8305 	mrs	r3, IPSR
 8022e78:	613b      	str	r3, [r7, #16]
  return(result);
 8022e7a:	693b      	ldr	r3, [r7, #16]

  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 8022e7c:	2b00      	cmp	r3, #0
 8022e7e:	d15f      	bne.n	8022f40 <osMessageQueueNew+0xdc>
 8022e80:	68fb      	ldr	r3, [r7, #12]
 8022e82:	2b00      	cmp	r3, #0
 8022e84:	d05c      	beq.n	8022f40 <osMessageQueueNew+0xdc>
 8022e86:	68bb      	ldr	r3, [r7, #8]
 8022e88:	2b00      	cmp	r3, #0
 8022e8a:	d059      	beq.n	8022f40 <osMessageQueueNew+0xdc>
    mem = -1;
 8022e8c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8022e90:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 8022e92:	687b      	ldr	r3, [r7, #4]
 8022e94:	2b00      	cmp	r3, #0
 8022e96:	d029      	beq.n	8022eec <osMessageQueueNew+0x88>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 8022e98:	687b      	ldr	r3, [r7, #4]
 8022e9a:	689b      	ldr	r3, [r3, #8]
 8022e9c:	2b00      	cmp	r3, #0
 8022e9e:	d012      	beq.n	8022ec6 <osMessageQueueNew+0x62>
 8022ea0:	687b      	ldr	r3, [r7, #4]
 8022ea2:	68db      	ldr	r3, [r3, #12]
 8022ea4:	2b4f      	cmp	r3, #79	; 0x4f
 8022ea6:	d90e      	bls.n	8022ec6 <osMessageQueueNew+0x62>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 8022ea8:	687b      	ldr	r3, [r7, #4]
 8022eaa:	691b      	ldr	r3, [r3, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 8022eac:	2b00      	cmp	r3, #0
 8022eae:	d00a      	beq.n	8022ec6 <osMessageQueueNew+0x62>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 8022eb0:	687b      	ldr	r3, [r7, #4]
 8022eb2:	695a      	ldr	r2, [r3, #20]
 8022eb4:	68fb      	ldr	r3, [r7, #12]
 8022eb6:	68b9      	ldr	r1, [r7, #8]
 8022eb8:	fb01 f303 	mul.w	r3, r1, r3
 8022ebc:	429a      	cmp	r2, r3
 8022ebe:	d302      	bcc.n	8022ec6 <osMessageQueueNew+0x62>
        mem = 1;
 8022ec0:	2301      	movs	r3, #1
 8022ec2:	61bb      	str	r3, [r7, #24]
 8022ec4:	e014      	b.n	8022ef0 <osMessageQueueNew+0x8c>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 8022ec6:	687b      	ldr	r3, [r7, #4]
 8022ec8:	689b      	ldr	r3, [r3, #8]
 8022eca:	2b00      	cmp	r3, #0
 8022ecc:	d110      	bne.n	8022ef0 <osMessageQueueNew+0x8c>
 8022ece:	687b      	ldr	r3, [r7, #4]
 8022ed0:	68db      	ldr	r3, [r3, #12]
 8022ed2:	2b00      	cmp	r3, #0
 8022ed4:	d10c      	bne.n	8022ef0 <osMessageQueueNew+0x8c>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 8022ed6:	687b      	ldr	r3, [r7, #4]
 8022ed8:	691b      	ldr	r3, [r3, #16]
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 8022eda:	2b00      	cmp	r3, #0
 8022edc:	d108      	bne.n	8022ef0 <osMessageQueueNew+0x8c>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 8022ede:	687b      	ldr	r3, [r7, #4]
 8022ee0:	695b      	ldr	r3, [r3, #20]
 8022ee2:	2b00      	cmp	r3, #0
 8022ee4:	d104      	bne.n	8022ef0 <osMessageQueueNew+0x8c>
          mem = 0;
 8022ee6:	2300      	movs	r3, #0
 8022ee8:	61bb      	str	r3, [r7, #24]
 8022eea:	e001      	b.n	8022ef0 <osMessageQueueNew+0x8c>
        }
      }
    }
    else {
      mem = 0;
 8022eec:	2300      	movs	r3, #0
 8022eee:	61bb      	str	r3, [r7, #24]
    }

    if (mem == 1) {
 8022ef0:	69bb      	ldr	r3, [r7, #24]
 8022ef2:	2b01      	cmp	r3, #1
 8022ef4:	d10b      	bne.n	8022f0e <osMessageQueueNew+0xaa>
      #if (configSUPPORT_STATIC_ALLOCATION == 1)
        hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
 8022ef6:	687b      	ldr	r3, [r7, #4]
 8022ef8:	691a      	ldr	r2, [r3, #16]
 8022efa:	687b      	ldr	r3, [r7, #4]
 8022efc:	689b      	ldr	r3, [r3, #8]
 8022efe:	2100      	movs	r1, #0
 8022f00:	9100      	str	r1, [sp, #0]
 8022f02:	68b9      	ldr	r1, [r7, #8]
 8022f04:	68f8      	ldr	r0, [r7, #12]
 8022f06:	f000 fa2f 	bl	8023368 <xQueueGenericCreateStatic>
 8022f0a:	61f8      	str	r0, [r7, #28]
 8022f0c:	e008      	b.n	8022f20 <osMessageQueueNew+0xbc>
      #endif
    }
    else {
      if (mem == 0) {
 8022f0e:	69bb      	ldr	r3, [r7, #24]
 8022f10:	2b00      	cmp	r3, #0
 8022f12:	d105      	bne.n	8022f20 <osMessageQueueNew+0xbc>
        #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
          hQueue = xQueueCreate (msg_count, msg_size);
 8022f14:	2200      	movs	r2, #0
 8022f16:	68b9      	ldr	r1, [r7, #8]
 8022f18:	68f8      	ldr	r0, [r7, #12]
 8022f1a:	f000 fa9d 	bl	8023458 <xQueueGenericCreate>
 8022f1e:	61f8      	str	r0, [r7, #28]
        #endif
      }
    }

    #if (configQUEUE_REGISTRY_SIZE > 0)
    if (hQueue != NULL) {
 8022f20:	69fb      	ldr	r3, [r7, #28]
 8022f22:	2b00      	cmp	r3, #0
 8022f24:	d00c      	beq.n	8022f40 <osMessageQueueNew+0xdc>
      if (attr != NULL) {
 8022f26:	687b      	ldr	r3, [r7, #4]
 8022f28:	2b00      	cmp	r3, #0
 8022f2a:	d003      	beq.n	8022f34 <osMessageQueueNew+0xd0>
        name = attr->name;
 8022f2c:	687b      	ldr	r3, [r7, #4]
 8022f2e:	681b      	ldr	r3, [r3, #0]
 8022f30:	617b      	str	r3, [r7, #20]
 8022f32:	e001      	b.n	8022f38 <osMessageQueueNew+0xd4>
      } else {
        name = NULL;
 8022f34:	2300      	movs	r3, #0
 8022f36:	617b      	str	r3, [r7, #20]
      }
      vQueueAddToRegistry (hQueue, name);
 8022f38:	6979      	ldr	r1, [r7, #20]
 8022f3a:	69f8      	ldr	r0, [r7, #28]
 8022f3c:	f001 f9e8 	bl	8024310 <vQueueAddToRegistry>
    }
    #endif

  }

  return ((osMessageQueueId_t)hQueue);
 8022f40:	69fb      	ldr	r3, [r7, #28]
}
 8022f42:	4618      	mov	r0, r3
 8022f44:	3720      	adds	r7, #32
 8022f46:	46bd      	mov	sp, r7
 8022f48:	bd80      	pop	{r7, pc}
	...

08022f4c <osMessageQueuePut>:

osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
 8022f4c:	b580      	push	{r7, lr}
 8022f4e:	b088      	sub	sp, #32
 8022f50:	af00      	add	r7, sp, #0
 8022f52:	60f8      	str	r0, [r7, #12]
 8022f54:	60b9      	str	r1, [r7, #8]
 8022f56:	603b      	str	r3, [r7, #0]
 8022f58:	4613      	mov	r3, r2
 8022f5a:	71fb      	strb	r3, [r7, #7]
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
 8022f5c:	68fb      	ldr	r3, [r7, #12]
 8022f5e:	61bb      	str	r3, [r7, #24]
  osStatus_t stat;
  BaseType_t yield;

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;
 8022f60:	2300      	movs	r3, #0
 8022f62:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8022f64:	f3ef 8305 	mrs	r3, IPSR
 8022f68:	617b      	str	r3, [r7, #20]
  return(result);
 8022f6a:	697b      	ldr	r3, [r7, #20]

  if (IS_IRQ()) {
 8022f6c:	2b00      	cmp	r3, #0
 8022f6e:	d028      	beq.n	8022fc2 <osMessageQueuePut+0x76>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 8022f70:	69bb      	ldr	r3, [r7, #24]
 8022f72:	2b00      	cmp	r3, #0
 8022f74:	d005      	beq.n	8022f82 <osMessageQueuePut+0x36>
 8022f76:	68bb      	ldr	r3, [r7, #8]
 8022f78:	2b00      	cmp	r3, #0
 8022f7a:	d002      	beq.n	8022f82 <osMessageQueuePut+0x36>
 8022f7c:	683b      	ldr	r3, [r7, #0]
 8022f7e:	2b00      	cmp	r3, #0
 8022f80:	d003      	beq.n	8022f8a <osMessageQueuePut+0x3e>
      stat = osErrorParameter;
 8022f82:	f06f 0303 	mvn.w	r3, #3
 8022f86:	61fb      	str	r3, [r7, #28]
 8022f88:	e038      	b.n	8022ffc <osMessageQueuePut+0xb0>
    }
    else {
      yield = pdFALSE;
 8022f8a:	2300      	movs	r3, #0
 8022f8c:	613b      	str	r3, [r7, #16]

      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 8022f8e:	f107 0210 	add.w	r2, r7, #16
 8022f92:	2300      	movs	r3, #0
 8022f94:	68b9      	ldr	r1, [r7, #8]
 8022f96:	69b8      	ldr	r0, [r7, #24]
 8022f98:	f000 fcda 	bl	8023950 <xQueueGenericSendFromISR>
 8022f9c:	4603      	mov	r3, r0
 8022f9e:	2b01      	cmp	r3, #1
 8022fa0:	d003      	beq.n	8022faa <osMessageQueuePut+0x5e>
        stat = osErrorResource;
 8022fa2:	f06f 0302 	mvn.w	r3, #2
 8022fa6:	61fb      	str	r3, [r7, #28]
 8022fa8:	e028      	b.n	8022ffc <osMessageQueuePut+0xb0>
      } else {
        portYIELD_FROM_ISR (yield);
 8022faa:	693b      	ldr	r3, [r7, #16]
 8022fac:	2b00      	cmp	r3, #0
 8022fae:	d025      	beq.n	8022ffc <osMessageQueuePut+0xb0>
 8022fb0:	4b15      	ldr	r3, [pc, #84]	; (8023008 <osMessageQueuePut+0xbc>)
 8022fb2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8022fb6:	601a      	str	r2, [r3, #0]
 8022fb8:	f3bf 8f4f 	dsb	sy
 8022fbc:	f3bf 8f6f 	isb	sy
 8022fc0:	e01c      	b.n	8022ffc <osMessageQueuePut+0xb0>
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 8022fc2:	69bb      	ldr	r3, [r7, #24]
 8022fc4:	2b00      	cmp	r3, #0
 8022fc6:	d002      	beq.n	8022fce <osMessageQueuePut+0x82>
 8022fc8:	68bb      	ldr	r3, [r7, #8]
 8022fca:	2b00      	cmp	r3, #0
 8022fcc:	d103      	bne.n	8022fd6 <osMessageQueuePut+0x8a>
      stat = osErrorParameter;
 8022fce:	f06f 0303 	mvn.w	r3, #3
 8022fd2:	61fb      	str	r3, [r7, #28]
 8022fd4:	e012      	b.n	8022ffc <osMessageQueuePut+0xb0>
    }
    else {
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 8022fd6:	2300      	movs	r3, #0
 8022fd8:	683a      	ldr	r2, [r7, #0]
 8022fda:	68b9      	ldr	r1, [r7, #8]
 8022fdc:	69b8      	ldr	r0, [r7, #24]
 8022fde:	f000 fbb9 	bl	8023754 <xQueueGenericSend>
 8022fe2:	4603      	mov	r3, r0
 8022fe4:	2b01      	cmp	r3, #1
 8022fe6:	d009      	beq.n	8022ffc <osMessageQueuePut+0xb0>
        if (timeout != 0U) {
 8022fe8:	683b      	ldr	r3, [r7, #0]
 8022fea:	2b00      	cmp	r3, #0
 8022fec:	d003      	beq.n	8022ff6 <osMessageQueuePut+0xaa>
          stat = osErrorTimeout;
 8022fee:	f06f 0301 	mvn.w	r3, #1
 8022ff2:	61fb      	str	r3, [r7, #28]
 8022ff4:	e002      	b.n	8022ffc <osMessageQueuePut+0xb0>
        } else {
          stat = osErrorResource;
 8022ff6:	f06f 0302 	mvn.w	r3, #2
 8022ffa:	61fb      	str	r3, [r7, #28]
        }
      }
    }
  }

  return (stat);
 8022ffc:	69fb      	ldr	r3, [r7, #28]
}
 8022ffe:	4618      	mov	r0, r3
 8023000:	3720      	adds	r7, #32
 8023002:	46bd      	mov	sp, r7
 8023004:	bd80      	pop	{r7, pc}
 8023006:	bf00      	nop
 8023008:	e000ed04 	.word	0xe000ed04

0802300c <osMessageQueueGet>:

osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
 802300c:	b580      	push	{r7, lr}
 802300e:	b088      	sub	sp, #32
 8023010:	af00      	add	r7, sp, #0
 8023012:	60f8      	str	r0, [r7, #12]
 8023014:	60b9      	str	r1, [r7, #8]
 8023016:	607a      	str	r2, [r7, #4]
 8023018:	603b      	str	r3, [r7, #0]
  QueueHandle_t hQueue = (QueueHandle_t)mq_id;
 802301a:	68fb      	ldr	r3, [r7, #12]
 802301c:	61bb      	str	r3, [r7, #24]
  osStatus_t stat;
  BaseType_t yield;

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;
 802301e:	2300      	movs	r3, #0
 8023020:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8023022:	f3ef 8305 	mrs	r3, IPSR
 8023026:	617b      	str	r3, [r7, #20]
  return(result);
 8023028:	697b      	ldr	r3, [r7, #20]

  if (IS_IRQ()) {
 802302a:	2b00      	cmp	r3, #0
 802302c:	d028      	beq.n	8023080 <osMessageQueueGet+0x74>
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 802302e:	69bb      	ldr	r3, [r7, #24]
 8023030:	2b00      	cmp	r3, #0
 8023032:	d005      	beq.n	8023040 <osMessageQueueGet+0x34>
 8023034:	68bb      	ldr	r3, [r7, #8]
 8023036:	2b00      	cmp	r3, #0
 8023038:	d002      	beq.n	8023040 <osMessageQueueGet+0x34>
 802303a:	683b      	ldr	r3, [r7, #0]
 802303c:	2b00      	cmp	r3, #0
 802303e:	d003      	beq.n	8023048 <osMessageQueueGet+0x3c>
      stat = osErrorParameter;
 8023040:	f06f 0303 	mvn.w	r3, #3
 8023044:	61fb      	str	r3, [r7, #28]
 8023046:	e037      	b.n	80230b8 <osMessageQueueGet+0xac>
    }
    else {
      yield = pdFALSE;
 8023048:	2300      	movs	r3, #0
 802304a:	613b      	str	r3, [r7, #16]

      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 802304c:	f107 0310 	add.w	r3, r7, #16
 8023050:	461a      	mov	r2, r3
 8023052:	68b9      	ldr	r1, [r7, #8]
 8023054:	69b8      	ldr	r0, [r7, #24]
 8023056:	f000 ff8f 	bl	8023f78 <xQueueReceiveFromISR>
 802305a:	4603      	mov	r3, r0
 802305c:	2b01      	cmp	r3, #1
 802305e:	d003      	beq.n	8023068 <osMessageQueueGet+0x5c>
        stat = osErrorResource;
 8023060:	f06f 0302 	mvn.w	r3, #2
 8023064:	61fb      	str	r3, [r7, #28]
 8023066:	e027      	b.n	80230b8 <osMessageQueueGet+0xac>
      } else {
        portYIELD_FROM_ISR (yield);
 8023068:	693b      	ldr	r3, [r7, #16]
 802306a:	2b00      	cmp	r3, #0
 802306c:	d024      	beq.n	80230b8 <osMessageQueueGet+0xac>
 802306e:	4b15      	ldr	r3, [pc, #84]	; (80230c4 <osMessageQueueGet+0xb8>)
 8023070:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023074:	601a      	str	r2, [r3, #0]
 8023076:	f3bf 8f4f 	dsb	sy
 802307a:	f3bf 8f6f 	isb	sy
 802307e:	e01b      	b.n	80230b8 <osMessageQueueGet+0xac>
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 8023080:	69bb      	ldr	r3, [r7, #24]
 8023082:	2b00      	cmp	r3, #0
 8023084:	d002      	beq.n	802308c <osMessageQueueGet+0x80>
 8023086:	68bb      	ldr	r3, [r7, #8]
 8023088:	2b00      	cmp	r3, #0
 802308a:	d103      	bne.n	8023094 <osMessageQueueGet+0x88>
      stat = osErrorParameter;
 802308c:	f06f 0303 	mvn.w	r3, #3
 8023090:	61fb      	str	r3, [r7, #28]
 8023092:	e011      	b.n	80230b8 <osMessageQueueGet+0xac>
    }
    else {
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 8023094:	683a      	ldr	r2, [r7, #0]
 8023096:	68b9      	ldr	r1, [r7, #8]
 8023098:	69b8      	ldr	r0, [r7, #24]
 802309a:	f000 fd81 	bl	8023ba0 <xQueueReceive>
 802309e:	4603      	mov	r3, r0
 80230a0:	2b01      	cmp	r3, #1
 80230a2:	d009      	beq.n	80230b8 <osMessageQueueGet+0xac>
        if (timeout != 0U) {
 80230a4:	683b      	ldr	r3, [r7, #0]
 80230a6:	2b00      	cmp	r3, #0
 80230a8:	d003      	beq.n	80230b2 <osMessageQueueGet+0xa6>
          stat = osErrorTimeout;
 80230aa:	f06f 0301 	mvn.w	r3, #1
 80230ae:	61fb      	str	r3, [r7, #28]
 80230b0:	e002      	b.n	80230b8 <osMessageQueueGet+0xac>
        } else {
          stat = osErrorResource;
 80230b2:	f06f 0302 	mvn.w	r3, #2
 80230b6:	61fb      	str	r3, [r7, #28]
        }
      }
    }
  }

  return (stat);
 80230b8:	69fb      	ldr	r3, [r7, #28]
}
 80230ba:	4618      	mov	r0, r3
 80230bc:	3720      	adds	r7, #32
 80230be:	46bd      	mov	sp, r7
 80230c0:	bd80      	pop	{r7, pc}
 80230c2:	bf00      	nop
 80230c4:	e000ed04 	.word	0xe000ed04

080230c8 <vApplicationGetIdleTaskMemory>:

/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 80230c8:	b480      	push	{r7}
 80230ca:	b085      	sub	sp, #20
 80230cc:	af00      	add	r7, sp, #0
 80230ce:	60f8      	str	r0, [r7, #12]
 80230d0:	60b9      	str	r1, [r7, #8]
 80230d2:	607a      	str	r2, [r7, #4]
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 80230d4:	68fb      	ldr	r3, [r7, #12]
 80230d6:	4a07      	ldr	r2, [pc, #28]	; (80230f4 <vApplicationGetIdleTaskMemory+0x2c>)
 80230d8:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 80230da:	68bb      	ldr	r3, [r7, #8]
 80230dc:	4a06      	ldr	r2, [pc, #24]	; (80230f8 <vApplicationGetIdleTaskMemory+0x30>)
 80230de:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 80230e0:	687b      	ldr	r3, [r7, #4]
 80230e2:	2280      	movs	r2, #128	; 0x80
 80230e4:	601a      	str	r2, [r3, #0]
}
 80230e6:	bf00      	nop
 80230e8:	3714      	adds	r7, #20
 80230ea:	46bd      	mov	sp, r7
 80230ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80230f0:	4770      	bx	lr
 80230f2:	bf00      	nop
 80230f4:	20003ad0 	.word	0x20003ad0
 80230f8:	20003b8c 	.word	0x20003b8c

080230fc <vApplicationGetTimerTaskMemory>:

/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 80230fc:	b480      	push	{r7}
 80230fe:	b085      	sub	sp, #20
 8023100:	af00      	add	r7, sp, #0
 8023102:	60f8      	str	r0, [r7, #12]
 8023104:	60b9      	str	r1, [r7, #8]
 8023106:	607a      	str	r2, [r7, #4]
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 8023108:	68fb      	ldr	r3, [r7, #12]
 802310a:	4a07      	ldr	r2, [pc, #28]	; (8023128 <vApplicationGetTimerTaskMemory+0x2c>)
 802310c:	601a      	str	r2, [r3, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 802310e:	68bb      	ldr	r3, [r7, #8]
 8023110:	4a06      	ldr	r2, [pc, #24]	; (802312c <vApplicationGetTimerTaskMemory+0x30>)
 8023112:	601a      	str	r2, [r3, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 8023114:	687b      	ldr	r3, [r7, #4]
 8023116:	f44f 7280 	mov.w	r2, #256	; 0x100
 802311a:	601a      	str	r2, [r3, #0]
}
 802311c:	bf00      	nop
 802311e:	3714      	adds	r7, #20
 8023120:	46bd      	mov	sp, r7
 8023122:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023126:	4770      	bx	lr
 8023128:	20003d8c 	.word	0x20003d8c
 802312c:	20003e48 	.word	0x20003e48

08023130 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8023130:	b480      	push	{r7}
 8023132:	b083      	sub	sp, #12
 8023134:	af00      	add	r7, sp, #0
 8023136:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8023138:	687b      	ldr	r3, [r7, #4]
 802313a:	f103 0208 	add.w	r2, r3, #8
 802313e:	687b      	ldr	r3, [r7, #4]
 8023140:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8023142:	687b      	ldr	r3, [r7, #4]
 8023144:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8023148:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 802314a:	687b      	ldr	r3, [r7, #4]
 802314c:	f103 0208 	add.w	r2, r3, #8
 8023150:	687b      	ldr	r3, [r7, #4]
 8023152:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8023154:	687b      	ldr	r3, [r7, #4]
 8023156:	f103 0208 	add.w	r2, r3, #8
 802315a:	687b      	ldr	r3, [r7, #4]
 802315c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 802315e:	687b      	ldr	r3, [r7, #4]
 8023160:	2200      	movs	r2, #0
 8023162:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8023164:	bf00      	nop
 8023166:	370c      	adds	r7, #12
 8023168:	46bd      	mov	sp, r7
 802316a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802316e:	4770      	bx	lr

08023170 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8023170:	b480      	push	{r7}
 8023172:	b083      	sub	sp, #12
 8023174:	af00      	add	r7, sp, #0
 8023176:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8023178:	687b      	ldr	r3, [r7, #4]
 802317a:	2200      	movs	r2, #0
 802317c:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 802317e:	bf00      	nop
 8023180:	370c      	adds	r7, #12
 8023182:	46bd      	mov	sp, r7
 8023184:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023188:	4770      	bx	lr

0802318a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 802318a:	b480      	push	{r7}
 802318c:	b085      	sub	sp, #20
 802318e:	af00      	add	r7, sp, #0
 8023190:	6078      	str	r0, [r7, #4]
 8023192:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8023194:	687b      	ldr	r3, [r7, #4]
 8023196:	685b      	ldr	r3, [r3, #4]
 8023198:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 802319a:	683b      	ldr	r3, [r7, #0]
 802319c:	68fa      	ldr	r2, [r7, #12]
 802319e:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80231a0:	68fb      	ldr	r3, [r7, #12]
 80231a2:	689a      	ldr	r2, [r3, #8]
 80231a4:	683b      	ldr	r3, [r7, #0]
 80231a6:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80231a8:	68fb      	ldr	r3, [r7, #12]
 80231aa:	689b      	ldr	r3, [r3, #8]
 80231ac:	683a      	ldr	r2, [r7, #0]
 80231ae:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80231b0:	68fb      	ldr	r3, [r7, #12]
 80231b2:	683a      	ldr	r2, [r7, #0]
 80231b4:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 80231b6:	683b      	ldr	r3, [r7, #0]
 80231b8:	687a      	ldr	r2, [r7, #4]
 80231ba:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80231bc:	687b      	ldr	r3, [r7, #4]
 80231be:	681b      	ldr	r3, [r3, #0]
 80231c0:	1c5a      	adds	r2, r3, #1
 80231c2:	687b      	ldr	r3, [r7, #4]
 80231c4:	601a      	str	r2, [r3, #0]
}
 80231c6:	bf00      	nop
 80231c8:	3714      	adds	r7, #20
 80231ca:	46bd      	mov	sp, r7
 80231cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80231d0:	4770      	bx	lr

080231d2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80231d2:	b480      	push	{r7}
 80231d4:	b085      	sub	sp, #20
 80231d6:	af00      	add	r7, sp, #0
 80231d8:	6078      	str	r0, [r7, #4]
 80231da:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80231dc:	683b      	ldr	r3, [r7, #0]
 80231de:	681b      	ldr	r3, [r3, #0]
 80231e0:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80231e2:	68bb      	ldr	r3, [r7, #8]
 80231e4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80231e8:	d103      	bne.n	80231f2 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80231ea:	687b      	ldr	r3, [r7, #4]
 80231ec:	691b      	ldr	r3, [r3, #16]
 80231ee:	60fb      	str	r3, [r7, #12]
 80231f0:	e00c      	b.n	802320c <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80231f2:	687b      	ldr	r3, [r7, #4]
 80231f4:	3308      	adds	r3, #8
 80231f6:	60fb      	str	r3, [r7, #12]
 80231f8:	e002      	b.n	8023200 <vListInsert+0x2e>
 80231fa:	68fb      	ldr	r3, [r7, #12]
 80231fc:	685b      	ldr	r3, [r3, #4]
 80231fe:	60fb      	str	r3, [r7, #12]
 8023200:	68fb      	ldr	r3, [r7, #12]
 8023202:	685b      	ldr	r3, [r3, #4]
 8023204:	681b      	ldr	r3, [r3, #0]
 8023206:	68ba      	ldr	r2, [r7, #8]
 8023208:	429a      	cmp	r2, r3
 802320a:	d2f6      	bcs.n	80231fa <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 802320c:	68fb      	ldr	r3, [r7, #12]
 802320e:	685a      	ldr	r2, [r3, #4]
 8023210:	683b      	ldr	r3, [r7, #0]
 8023212:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8023214:	683b      	ldr	r3, [r7, #0]
 8023216:	685b      	ldr	r3, [r3, #4]
 8023218:	683a      	ldr	r2, [r7, #0]
 802321a:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 802321c:	683b      	ldr	r3, [r7, #0]
 802321e:	68fa      	ldr	r2, [r7, #12]
 8023220:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 8023222:	68fb      	ldr	r3, [r7, #12]
 8023224:	683a      	ldr	r2, [r7, #0]
 8023226:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 8023228:	683b      	ldr	r3, [r7, #0]
 802322a:	687a      	ldr	r2, [r7, #4]
 802322c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 802322e:	687b      	ldr	r3, [r7, #4]
 8023230:	681b      	ldr	r3, [r3, #0]
 8023232:	1c5a      	adds	r2, r3, #1
 8023234:	687b      	ldr	r3, [r7, #4]
 8023236:	601a      	str	r2, [r3, #0]
}
 8023238:	bf00      	nop
 802323a:	3714      	adds	r7, #20
 802323c:	46bd      	mov	sp, r7
 802323e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023242:	4770      	bx	lr

08023244 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8023244:	b480      	push	{r7}
 8023246:	b085      	sub	sp, #20
 8023248:	af00      	add	r7, sp, #0
 802324a:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 802324c:	687b      	ldr	r3, [r7, #4]
 802324e:	691b      	ldr	r3, [r3, #16]
 8023250:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8023252:	687b      	ldr	r3, [r7, #4]
 8023254:	685b      	ldr	r3, [r3, #4]
 8023256:	687a      	ldr	r2, [r7, #4]
 8023258:	6892      	ldr	r2, [r2, #8]
 802325a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 802325c:	687b      	ldr	r3, [r7, #4]
 802325e:	689b      	ldr	r3, [r3, #8]
 8023260:	687a      	ldr	r2, [r7, #4]
 8023262:	6852      	ldr	r2, [r2, #4]
 8023264:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8023266:	68fb      	ldr	r3, [r7, #12]
 8023268:	685b      	ldr	r3, [r3, #4]
 802326a:	687a      	ldr	r2, [r7, #4]
 802326c:	429a      	cmp	r2, r3
 802326e:	d103      	bne.n	8023278 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8023270:	687b      	ldr	r3, [r7, #4]
 8023272:	689a      	ldr	r2, [r3, #8]
 8023274:	68fb      	ldr	r3, [r7, #12]
 8023276:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8023278:	687b      	ldr	r3, [r7, #4]
 802327a:	2200      	movs	r2, #0
 802327c:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 802327e:	68fb      	ldr	r3, [r7, #12]
 8023280:	681b      	ldr	r3, [r3, #0]
 8023282:	1e5a      	subs	r2, r3, #1
 8023284:	68fb      	ldr	r3, [r7, #12]
 8023286:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8023288:	68fb      	ldr	r3, [r7, #12]
 802328a:	681b      	ldr	r3, [r3, #0]
}
 802328c:	4618      	mov	r0, r3
 802328e:	3714      	adds	r7, #20
 8023290:	46bd      	mov	sp, r7
 8023292:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023296:	4770      	bx	lr

08023298 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 8023298:	b580      	push	{r7, lr}
 802329a:	b084      	sub	sp, #16
 802329c:	af00      	add	r7, sp, #0
 802329e:	6078      	str	r0, [r7, #4]
 80232a0:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
 80232a2:	687b      	ldr	r3, [r7, #4]
 80232a4:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 80232a6:	68fb      	ldr	r3, [r7, #12]
 80232a8:	2b00      	cmp	r3, #0
 80232aa:	d10a      	bne.n	80232c2 <xQueueGenericReset+0x2a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80232ac:	f04f 0350 	mov.w	r3, #80	; 0x50
 80232b0:	f383 8811 	msr	BASEPRI, r3
 80232b4:	f3bf 8f6f 	isb	sy
 80232b8:	f3bf 8f4f 	dsb	sy
 80232bc:	60bb      	str	r3, [r7, #8]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 80232be:	bf00      	nop
 80232c0:	e7fe      	b.n	80232c0 <xQueueGenericReset+0x28>

	taskENTER_CRITICAL();
 80232c2:	f003 f817 	bl	80262f4 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80232c6:	68fb      	ldr	r3, [r7, #12]
 80232c8:	681a      	ldr	r2, [r3, #0]
 80232ca:	68fb      	ldr	r3, [r7, #12]
 80232cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80232ce:	68f9      	ldr	r1, [r7, #12]
 80232d0:	6c09      	ldr	r1, [r1, #64]	; 0x40
 80232d2:	fb01 f303 	mul.w	r3, r1, r3
 80232d6:	441a      	add	r2, r3
 80232d8:	68fb      	ldr	r3, [r7, #12]
 80232da:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80232dc:	68fb      	ldr	r3, [r7, #12]
 80232de:	2200      	movs	r2, #0
 80232e0:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80232e2:	68fb      	ldr	r3, [r7, #12]
 80232e4:	681a      	ldr	r2, [r3, #0]
 80232e6:	68fb      	ldr	r3, [r7, #12]
 80232e8:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80232ea:	68fb      	ldr	r3, [r7, #12]
 80232ec:	681a      	ldr	r2, [r3, #0]
 80232ee:	68fb      	ldr	r3, [r7, #12]
 80232f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80232f2:	3b01      	subs	r3, #1
 80232f4:	68f9      	ldr	r1, [r7, #12]
 80232f6:	6c09      	ldr	r1, [r1, #64]	; 0x40
 80232f8:	fb01 f303 	mul.w	r3, r1, r3
 80232fc:	441a      	add	r2, r3
 80232fe:	68fb      	ldr	r3, [r7, #12]
 8023300:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8023302:	68fb      	ldr	r3, [r7, #12]
 8023304:	22ff      	movs	r2, #255	; 0xff
 8023306:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 802330a:	68fb      	ldr	r3, [r7, #12]
 802330c:	22ff      	movs	r2, #255	; 0xff
 802330e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 8023312:	683b      	ldr	r3, [r7, #0]
 8023314:	2b00      	cmp	r3, #0
 8023316:	d114      	bne.n	8023342 <xQueueGenericReset+0xaa>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8023318:	68fb      	ldr	r3, [r7, #12]
 802331a:	691b      	ldr	r3, [r3, #16]
 802331c:	2b00      	cmp	r3, #0
 802331e:	d01a      	beq.n	8023356 <xQueueGenericReset+0xbe>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8023320:	68fb      	ldr	r3, [r7, #12]
 8023322:	3310      	adds	r3, #16
 8023324:	4618      	mov	r0, r3
 8023326:	f001 fd01 	bl	8024d2c <xTaskRemoveFromEventList>
 802332a:	4603      	mov	r3, r0
 802332c:	2b00      	cmp	r3, #0
 802332e:	d012      	beq.n	8023356 <xQueueGenericReset+0xbe>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8023330:	4b0c      	ldr	r3, [pc, #48]	; (8023364 <xQueueGenericReset+0xcc>)
 8023332:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023336:	601a      	str	r2, [r3, #0]
 8023338:	f3bf 8f4f 	dsb	sy
 802333c:	f3bf 8f6f 	isb	sy
 8023340:	e009      	b.n	8023356 <xQueueGenericReset+0xbe>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8023342:	68fb      	ldr	r3, [r7, #12]
 8023344:	3310      	adds	r3, #16
 8023346:	4618      	mov	r0, r3
 8023348:	f7ff fef2 	bl	8023130 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 802334c:	68fb      	ldr	r3, [r7, #12]
 802334e:	3324      	adds	r3, #36	; 0x24
 8023350:	4618      	mov	r0, r3
 8023352:	f7ff feed 	bl	8023130 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8023356:	f002 fffd 	bl	8026354 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 802335a:	2301      	movs	r3, #1
}
 802335c:	4618      	mov	r0, r3
 802335e:	3710      	adds	r7, #16
 8023360:	46bd      	mov	sp, r7
 8023362:	bd80      	pop	{r7, pc}
 8023364:	e000ed04 	.word	0xe000ed04

08023368 <xQueueGenericCreateStatic>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_STATIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
 8023368:	b580      	push	{r7, lr}
 802336a:	b08e      	sub	sp, #56	; 0x38
 802336c:	af02      	add	r7, sp, #8
 802336e:	60f8      	str	r0, [r7, #12]
 8023370:	60b9      	str	r1, [r7, #8]
 8023372:	607a      	str	r2, [r7, #4]
 8023374:	603b      	str	r3, [r7, #0]
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8023376:	68fb      	ldr	r3, [r7, #12]
 8023378:	2b00      	cmp	r3, #0
 802337a:	d10a      	bne.n	8023392 <xQueueGenericCreateStatic+0x2a>
	__asm volatile
 802337c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023380:	f383 8811 	msr	BASEPRI, r3
 8023384:	f3bf 8f6f 	isb	sy
 8023388:	f3bf 8f4f 	dsb	sy
 802338c:	62bb      	str	r3, [r7, #40]	; 0x28
}
 802338e:	bf00      	nop
 8023390:	e7fe      	b.n	8023390 <xQueueGenericCreateStatic+0x28>

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );
 8023392:	683b      	ldr	r3, [r7, #0]
 8023394:	2b00      	cmp	r3, #0
 8023396:	d10a      	bne.n	80233ae <xQueueGenericCreateStatic+0x46>
	__asm volatile
 8023398:	f04f 0350 	mov.w	r3, #80	; 0x50
 802339c:	f383 8811 	msr	BASEPRI, r3
 80233a0:	f3bf 8f6f 	isb	sy
 80233a4:	f3bf 8f4f 	dsb	sy
 80233a8:	627b      	str	r3, [r7, #36]	; 0x24
}
 80233aa:	bf00      	nop
 80233ac:	e7fe      	b.n	80233ac <xQueueGenericCreateStatic+0x44>

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 80233ae:	687b      	ldr	r3, [r7, #4]
 80233b0:	2b00      	cmp	r3, #0
 80233b2:	d002      	beq.n	80233ba <xQueueGenericCreateStatic+0x52>
 80233b4:	68bb      	ldr	r3, [r7, #8]
 80233b6:	2b00      	cmp	r3, #0
 80233b8:	d001      	beq.n	80233be <xQueueGenericCreateStatic+0x56>
 80233ba:	2301      	movs	r3, #1
 80233bc:	e000      	b.n	80233c0 <xQueueGenericCreateStatic+0x58>
 80233be:	2300      	movs	r3, #0
 80233c0:	2b00      	cmp	r3, #0
 80233c2:	d10a      	bne.n	80233da <xQueueGenericCreateStatic+0x72>
	__asm volatile
 80233c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80233c8:	f383 8811 	msr	BASEPRI, r3
 80233cc:	f3bf 8f6f 	isb	sy
 80233d0:	f3bf 8f4f 	dsb	sy
 80233d4:	623b      	str	r3, [r7, #32]
}
 80233d6:	bf00      	nop
 80233d8:	e7fe      	b.n	80233d8 <xQueueGenericCreateStatic+0x70>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 80233da:	687b      	ldr	r3, [r7, #4]
 80233dc:	2b00      	cmp	r3, #0
 80233de:	d102      	bne.n	80233e6 <xQueueGenericCreateStatic+0x7e>
 80233e0:	68bb      	ldr	r3, [r7, #8]
 80233e2:	2b00      	cmp	r3, #0
 80233e4:	d101      	bne.n	80233ea <xQueueGenericCreateStatic+0x82>
 80233e6:	2301      	movs	r3, #1
 80233e8:	e000      	b.n	80233ec <xQueueGenericCreateStatic+0x84>
 80233ea:	2300      	movs	r3, #0
 80233ec:	2b00      	cmp	r3, #0
 80233ee:	d10a      	bne.n	8023406 <xQueueGenericCreateStatic+0x9e>
	__asm volatile
 80233f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80233f4:	f383 8811 	msr	BASEPRI, r3
 80233f8:	f3bf 8f6f 	isb	sy
 80233fc:	f3bf 8f4f 	dsb	sy
 8023400:	61fb      	str	r3, [r7, #28]
}
 8023402:	bf00      	nop
 8023404:	e7fe      	b.n	8023404 <xQueueGenericCreateStatic+0x9c>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
 8023406:	2350      	movs	r3, #80	; 0x50
 8023408:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( Queue_t ) );
 802340a:	697b      	ldr	r3, [r7, #20]
 802340c:	2b50      	cmp	r3, #80	; 0x50
 802340e:	d00a      	beq.n	8023426 <xQueueGenericCreateStatic+0xbe>
	__asm volatile
 8023410:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023414:	f383 8811 	msr	BASEPRI, r3
 8023418:	f3bf 8f6f 	isb	sy
 802341c:	f3bf 8f4f 	dsb	sy
 8023420:	61bb      	str	r3, [r7, #24]
}
 8023422:	bf00      	nop
 8023424:	e7fe      	b.n	8023424 <xQueueGenericCreateStatic+0xbc>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8023426:	697b      	ldr	r3, [r7, #20]
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 8023428:	683b      	ldr	r3, [r7, #0]
 802342a:	62fb      	str	r3, [r7, #44]	; 0x2c

		if( pxNewQueue != NULL )
 802342c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802342e:	2b00      	cmp	r3, #0
 8023430:	d00d      	beq.n	802344e <xQueueGenericCreateStatic+0xe6>
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8023432:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023434:	2201      	movs	r2, #1
 8023436:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 802343a:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
 802343e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023440:	9300      	str	r3, [sp, #0]
 8023442:	4613      	mov	r3, r2
 8023444:	687a      	ldr	r2, [r7, #4]
 8023446:	68b9      	ldr	r1, [r7, #8]
 8023448:	68f8      	ldr	r0, [r7, #12]
 802344a:	f000 f83f 	bl	80234cc <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 802344e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
 8023450:	4618      	mov	r0, r3
 8023452:	3730      	adds	r7, #48	; 0x30
 8023454:	46bd      	mov	sp, r7
 8023456:	bd80      	pop	{r7, pc}

08023458 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 8023458:	b580      	push	{r7, lr}
 802345a:	b08a      	sub	sp, #40	; 0x28
 802345c:	af02      	add	r7, sp, #8
 802345e:	60f8      	str	r0, [r7, #12]
 8023460:	60b9      	str	r1, [r7, #8]
 8023462:	4613      	mov	r3, r2
 8023464:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8023466:	68fb      	ldr	r3, [r7, #12]
 8023468:	2b00      	cmp	r3, #0
 802346a:	d10a      	bne.n	8023482 <xQueueGenericCreate+0x2a>
	__asm volatile
 802346c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023470:	f383 8811 	msr	BASEPRI, r3
 8023474:	f3bf 8f6f 	isb	sy
 8023478:	f3bf 8f4f 	dsb	sy
 802347c:	613b      	str	r3, [r7, #16]
}
 802347e:	bf00      	nop
 8023480:	e7fe      	b.n	8023480 <xQueueGenericCreate+0x28>

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8023482:	68fb      	ldr	r3, [r7, #12]
 8023484:	68ba      	ldr	r2, [r7, #8]
 8023486:	fb02 f303 	mul.w	r3, r2, r3
 802348a:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 802348c:	69fb      	ldr	r3, [r7, #28]
 802348e:	3350      	adds	r3, #80	; 0x50
 8023490:	4618      	mov	r0, r3
 8023492:	f003 f851 	bl	8026538 <pvPortMalloc>
 8023496:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
 8023498:	69bb      	ldr	r3, [r7, #24]
 802349a:	2b00      	cmp	r3, #0
 802349c:	d011      	beq.n	80234c2 <xQueueGenericCreate+0x6a>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 802349e:	69bb      	ldr	r3, [r7, #24]
 80234a0:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80234a2:	697b      	ldr	r3, [r7, #20]
 80234a4:	3350      	adds	r3, #80	; 0x50
 80234a6:	617b      	str	r3, [r7, #20]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 80234a8:	69bb      	ldr	r3, [r7, #24]
 80234aa:	2200      	movs	r2, #0
 80234ac:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 80234b0:	79fa      	ldrb	r2, [r7, #7]
 80234b2:	69bb      	ldr	r3, [r7, #24]
 80234b4:	9300      	str	r3, [sp, #0]
 80234b6:	4613      	mov	r3, r2
 80234b8:	697a      	ldr	r2, [r7, #20]
 80234ba:	68b9      	ldr	r1, [r7, #8]
 80234bc:	68f8      	ldr	r0, [r7, #12]
 80234be:	f000 f805 	bl	80234cc <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 80234c2:	69bb      	ldr	r3, [r7, #24]
	}
 80234c4:	4618      	mov	r0, r3
 80234c6:	3720      	adds	r7, #32
 80234c8:	46bd      	mov	sp, r7
 80234ca:	bd80      	pop	{r7, pc}

080234cc <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 80234cc:	b580      	push	{r7, lr}
 80234ce:	b084      	sub	sp, #16
 80234d0:	af00      	add	r7, sp, #0
 80234d2:	60f8      	str	r0, [r7, #12]
 80234d4:	60b9      	str	r1, [r7, #8]
 80234d6:	607a      	str	r2, [r7, #4]
 80234d8:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 80234da:	68bb      	ldr	r3, [r7, #8]
 80234dc:	2b00      	cmp	r3, #0
 80234de:	d103      	bne.n	80234e8 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80234e0:	69bb      	ldr	r3, [r7, #24]
 80234e2:	69ba      	ldr	r2, [r7, #24]
 80234e4:	601a      	str	r2, [r3, #0]
 80234e6:	e002      	b.n	80234ee <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80234e8:	69bb      	ldr	r3, [r7, #24]
 80234ea:	687a      	ldr	r2, [r7, #4]
 80234ec:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 80234ee:	69bb      	ldr	r3, [r7, #24]
 80234f0:	68fa      	ldr	r2, [r7, #12]
 80234f2:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80234f4:	69bb      	ldr	r3, [r7, #24]
 80234f6:	68ba      	ldr	r2, [r7, #8]
 80234f8:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80234fa:	2101      	movs	r1, #1
 80234fc:	69b8      	ldr	r0, [r7, #24]
 80234fe:	f7ff fecb 	bl	8023298 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 8023502:	69bb      	ldr	r3, [r7, #24]
 8023504:	78fa      	ldrb	r2, [r7, #3]
 8023506:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 802350a:	bf00      	nop
 802350c:	3710      	adds	r7, #16
 802350e:	46bd      	mov	sp, r7
 8023510:	bd80      	pop	{r7, pc}

08023512 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 8023512:	b580      	push	{r7, lr}
 8023514:	b082      	sub	sp, #8
 8023516:	af00      	add	r7, sp, #0
 8023518:	6078      	str	r0, [r7, #4]
		if( pxNewQueue != NULL )
 802351a:	687b      	ldr	r3, [r7, #4]
 802351c:	2b00      	cmp	r3, #0
 802351e:	d00e      	beq.n	802353e <prvInitialiseMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8023520:	687b      	ldr	r3, [r7, #4]
 8023522:	2200      	movs	r2, #0
 8023524:	609a      	str	r2, [r3, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8023526:	687b      	ldr	r3, [r7, #4]
 8023528:	2200      	movs	r2, #0
 802352a:	601a      	str	r2, [r3, #0]

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 802352c:	687b      	ldr	r3, [r7, #4]
 802352e:	2200      	movs	r2, #0
 8023530:	60da      	str	r2, [r3, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8023532:	2300      	movs	r3, #0
 8023534:	2200      	movs	r2, #0
 8023536:	2100      	movs	r1, #0
 8023538:	6878      	ldr	r0, [r7, #4]
 802353a:	f000 f90b 	bl	8023754 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 802353e:	bf00      	nop
 8023540:	3708      	adds	r7, #8
 8023542:	46bd      	mov	sp, r7
 8023544:	bd80      	pop	{r7, pc}

08023546 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 8023546:	b580      	push	{r7, lr}
 8023548:	b086      	sub	sp, #24
 802354a:	af00      	add	r7, sp, #0
 802354c:	4603      	mov	r3, r0
 802354e:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 8023550:	2301      	movs	r3, #1
 8023552:	617b      	str	r3, [r7, #20]
 8023554:	2300      	movs	r3, #0
 8023556:	613b      	str	r3, [r7, #16]

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 8023558:	79fb      	ldrb	r3, [r7, #7]
 802355a:	461a      	mov	r2, r3
 802355c:	6939      	ldr	r1, [r7, #16]
 802355e:	6978      	ldr	r0, [r7, #20]
 8023560:	f7ff ff7a 	bl	8023458 <xQueueGenericCreate>
 8023564:	60f8      	str	r0, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 8023566:	68f8      	ldr	r0, [r7, #12]
 8023568:	f7ff ffd3 	bl	8023512 <prvInitialiseMutex>

		return xNewQueue;
 802356c:	68fb      	ldr	r3, [r7, #12]
	}
 802356e:	4618      	mov	r0, r3
 8023570:	3718      	adds	r7, #24
 8023572:	46bd      	mov	sp, r7
 8023574:	bd80      	pop	{r7, pc}

08023576 <xQueueCreateMutexStatic>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
	{
 8023576:	b580      	push	{r7, lr}
 8023578:	b088      	sub	sp, #32
 802357a:	af02      	add	r7, sp, #8
 802357c:	4603      	mov	r3, r0
 802357e:	6039      	str	r1, [r7, #0]
 8023580:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 8023582:	2301      	movs	r3, #1
 8023584:	617b      	str	r3, [r7, #20]
 8023586:	2300      	movs	r3, #0
 8023588:	613b      	str	r3, [r7, #16]

		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
 802358a:	79fb      	ldrb	r3, [r7, #7]
 802358c:	9300      	str	r3, [sp, #0]
 802358e:	683b      	ldr	r3, [r7, #0]
 8023590:	2200      	movs	r2, #0
 8023592:	6939      	ldr	r1, [r7, #16]
 8023594:	6978      	ldr	r0, [r7, #20]
 8023596:	f7ff fee7 	bl	8023368 <xQueueGenericCreateStatic>
 802359a:	60f8      	str	r0, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 802359c:	68f8      	ldr	r0, [r7, #12]
 802359e:	f7ff ffb8 	bl	8023512 <prvInitialiseMutex>

		return xNewQueue;
 80235a2:	68fb      	ldr	r3, [r7, #12]
	}
 80235a4:	4618      	mov	r0, r3
 80235a6:	3718      	adds	r7, #24
 80235a8:	46bd      	mov	sp, r7
 80235aa:	bd80      	pop	{r7, pc}

080235ac <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 80235ac:	b590      	push	{r4, r7, lr}
 80235ae:	b087      	sub	sp, #28
 80235b0:	af00      	add	r7, sp, #0
 80235b2:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 80235b4:	687b      	ldr	r3, [r7, #4]
 80235b6:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
 80235b8:	693b      	ldr	r3, [r7, #16]
 80235ba:	2b00      	cmp	r3, #0
 80235bc:	d10a      	bne.n	80235d4 <xQueueGiveMutexRecursive+0x28>
	__asm volatile
 80235be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80235c2:	f383 8811 	msr	BASEPRI, r3
 80235c6:	f3bf 8f6f 	isb	sy
 80235ca:	f3bf 8f4f 	dsb	sy
 80235ce:	60fb      	str	r3, [r7, #12]
}
 80235d0:	bf00      	nop
 80235d2:	e7fe      	b.n	80235d2 <xQueueGiveMutexRecursive+0x26>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 80235d4:	693b      	ldr	r3, [r7, #16]
 80235d6:	689c      	ldr	r4, [r3, #8]
 80235d8:	f001 fd6a 	bl	80250b0 <xTaskGetCurrentTaskHandle>
 80235dc:	4603      	mov	r3, r0
 80235de:	429c      	cmp	r4, r3
 80235e0:	d111      	bne.n	8023606 <xQueueGiveMutexRecursive+0x5a>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 80235e2:	693b      	ldr	r3, [r7, #16]
 80235e4:	68db      	ldr	r3, [r3, #12]
 80235e6:	1e5a      	subs	r2, r3, #1
 80235e8:	693b      	ldr	r3, [r7, #16]
 80235ea:	60da      	str	r2, [r3, #12]

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 80235ec:	693b      	ldr	r3, [r7, #16]
 80235ee:	68db      	ldr	r3, [r3, #12]
 80235f0:	2b00      	cmp	r3, #0
 80235f2:	d105      	bne.n	8023600 <xQueueGiveMutexRecursive+0x54>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 80235f4:	2300      	movs	r3, #0
 80235f6:	2200      	movs	r2, #0
 80235f8:	2100      	movs	r1, #0
 80235fa:	6938      	ldr	r0, [r7, #16]
 80235fc:	f000 f8aa 	bl	8023754 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 8023600:	2301      	movs	r3, #1
 8023602:	617b      	str	r3, [r7, #20]
 8023604:	e001      	b.n	802360a <xQueueGiveMutexRecursive+0x5e>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 8023606:	2300      	movs	r3, #0
 8023608:	617b      	str	r3, [r7, #20]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 802360a:	697b      	ldr	r3, [r7, #20]
	}
 802360c:	4618      	mov	r0, r3
 802360e:	371c      	adds	r7, #28
 8023610:	46bd      	mov	sp, r7
 8023612:	bd90      	pop	{r4, r7, pc}

08023614 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 8023614:	b590      	push	{r4, r7, lr}
 8023616:	b087      	sub	sp, #28
 8023618:	af00      	add	r7, sp, #0
 802361a:	6078      	str	r0, [r7, #4]
 802361c:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 802361e:	687b      	ldr	r3, [r7, #4]
 8023620:	613b      	str	r3, [r7, #16]

		configASSERT( pxMutex );
 8023622:	693b      	ldr	r3, [r7, #16]
 8023624:	2b00      	cmp	r3, #0
 8023626:	d10a      	bne.n	802363e <xQueueTakeMutexRecursive+0x2a>
	__asm volatile
 8023628:	f04f 0350 	mov.w	r3, #80	; 0x50
 802362c:	f383 8811 	msr	BASEPRI, r3
 8023630:	f3bf 8f6f 	isb	sy
 8023634:	f3bf 8f4f 	dsb	sy
 8023638:	60fb      	str	r3, [r7, #12]
}
 802363a:	bf00      	nop
 802363c:	e7fe      	b.n	802363c <xQueueTakeMutexRecursive+0x28>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 802363e:	693b      	ldr	r3, [r7, #16]
 8023640:	689c      	ldr	r4, [r3, #8]
 8023642:	f001 fd35 	bl	80250b0 <xTaskGetCurrentTaskHandle>
 8023646:	4603      	mov	r3, r0
 8023648:	429c      	cmp	r4, r3
 802364a:	d107      	bne.n	802365c <xQueueTakeMutexRecursive+0x48>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 802364c:	693b      	ldr	r3, [r7, #16]
 802364e:	68db      	ldr	r3, [r3, #12]
 8023650:	1c5a      	adds	r2, r3, #1
 8023652:	693b      	ldr	r3, [r7, #16]
 8023654:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
 8023656:	2301      	movs	r3, #1
 8023658:	617b      	str	r3, [r7, #20]
 802365a:	e00c      	b.n	8023676 <xQueueTakeMutexRecursive+0x62>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 802365c:	6839      	ldr	r1, [r7, #0]
 802365e:	6938      	ldr	r0, [r7, #16]
 8023660:	f000 fb7e 	bl	8023d60 <xQueueSemaphoreTake>
 8023664:	6178      	str	r0, [r7, #20]

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 8023666:	697b      	ldr	r3, [r7, #20]
 8023668:	2b00      	cmp	r3, #0
 802366a:	d004      	beq.n	8023676 <xQueueTakeMutexRecursive+0x62>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 802366c:	693b      	ldr	r3, [r7, #16]
 802366e:	68db      	ldr	r3, [r3, #12]
 8023670:	1c5a      	adds	r2, r3, #1
 8023672:	693b      	ldr	r3, [r7, #16]
 8023674:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 8023676:	697b      	ldr	r3, [r7, #20]
	}
 8023678:	4618      	mov	r0, r3
 802367a:	371c      	adds	r7, #28
 802367c:	46bd      	mov	sp, r7
 802367e:	bd90      	pop	{r4, r7, pc}

08023680 <xQueueCreateCountingSemaphoreStatic>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
	{
 8023680:	b580      	push	{r7, lr}
 8023682:	b08a      	sub	sp, #40	; 0x28
 8023684:	af02      	add	r7, sp, #8
 8023686:	60f8      	str	r0, [r7, #12]
 8023688:	60b9      	str	r1, [r7, #8]
 802368a:	607a      	str	r2, [r7, #4]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 802368c:	68fb      	ldr	r3, [r7, #12]
 802368e:	2b00      	cmp	r3, #0
 8023690:	d10a      	bne.n	80236a8 <xQueueCreateCountingSemaphoreStatic+0x28>
	__asm volatile
 8023692:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023696:	f383 8811 	msr	BASEPRI, r3
 802369a:	f3bf 8f6f 	isb	sy
 802369e:	f3bf 8f4f 	dsb	sy
 80236a2:	61bb      	str	r3, [r7, #24]
}
 80236a4:	bf00      	nop
 80236a6:	e7fe      	b.n	80236a6 <xQueueCreateCountingSemaphoreStatic+0x26>
		configASSERT( uxInitialCount <= uxMaxCount );
 80236a8:	68ba      	ldr	r2, [r7, #8]
 80236aa:	68fb      	ldr	r3, [r7, #12]
 80236ac:	429a      	cmp	r2, r3
 80236ae:	d90a      	bls.n	80236c6 <xQueueCreateCountingSemaphoreStatic+0x46>
	__asm volatile
 80236b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80236b4:	f383 8811 	msr	BASEPRI, r3
 80236b8:	f3bf 8f6f 	isb	sy
 80236bc:	f3bf 8f4f 	dsb	sy
 80236c0:	617b      	str	r3, [r7, #20]
}
 80236c2:	bf00      	nop
 80236c4:	e7fe      	b.n	80236c4 <xQueueCreateCountingSemaphoreStatic+0x44>

		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80236c6:	2302      	movs	r3, #2
 80236c8:	9300      	str	r3, [sp, #0]
 80236ca:	687b      	ldr	r3, [r7, #4]
 80236cc:	2200      	movs	r2, #0
 80236ce:	2100      	movs	r1, #0
 80236d0:	68f8      	ldr	r0, [r7, #12]
 80236d2:	f7ff fe49 	bl	8023368 <xQueueGenericCreateStatic>
 80236d6:	61f8      	str	r0, [r7, #28]

		if( xHandle != NULL )
 80236d8:	69fb      	ldr	r3, [r7, #28]
 80236da:	2b00      	cmp	r3, #0
 80236dc:	d002      	beq.n	80236e4 <xQueueCreateCountingSemaphoreStatic+0x64>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80236de:	69fb      	ldr	r3, [r7, #28]
 80236e0:	68ba      	ldr	r2, [r7, #8]
 80236e2:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 80236e4:	69fb      	ldr	r3, [r7, #28]
	}
 80236e6:	4618      	mov	r0, r3
 80236e8:	3720      	adds	r7, #32
 80236ea:	46bd      	mov	sp, r7
 80236ec:	bd80      	pop	{r7, pc}

080236ee <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 80236ee:	b580      	push	{r7, lr}
 80236f0:	b086      	sub	sp, #24
 80236f2:	af00      	add	r7, sp, #0
 80236f4:	6078      	str	r0, [r7, #4]
 80236f6:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 80236f8:	687b      	ldr	r3, [r7, #4]
 80236fa:	2b00      	cmp	r3, #0
 80236fc:	d10a      	bne.n	8023714 <xQueueCreateCountingSemaphore+0x26>
	__asm volatile
 80236fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023702:	f383 8811 	msr	BASEPRI, r3
 8023706:	f3bf 8f6f 	isb	sy
 802370a:	f3bf 8f4f 	dsb	sy
 802370e:	613b      	str	r3, [r7, #16]
}
 8023710:	bf00      	nop
 8023712:	e7fe      	b.n	8023712 <xQueueCreateCountingSemaphore+0x24>
		configASSERT( uxInitialCount <= uxMaxCount );
 8023714:	683a      	ldr	r2, [r7, #0]
 8023716:	687b      	ldr	r3, [r7, #4]
 8023718:	429a      	cmp	r2, r3
 802371a:	d90a      	bls.n	8023732 <xQueueCreateCountingSemaphore+0x44>
	__asm volatile
 802371c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023720:	f383 8811 	msr	BASEPRI, r3
 8023724:	f3bf 8f6f 	isb	sy
 8023728:	f3bf 8f4f 	dsb	sy
 802372c:	60fb      	str	r3, [r7, #12]
}
 802372e:	bf00      	nop
 8023730:	e7fe      	b.n	8023730 <xQueueCreateCountingSemaphore+0x42>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8023732:	2202      	movs	r2, #2
 8023734:	2100      	movs	r1, #0
 8023736:	6878      	ldr	r0, [r7, #4]
 8023738:	f7ff fe8e 	bl	8023458 <xQueueGenericCreate>
 802373c:	6178      	str	r0, [r7, #20]

		if( xHandle != NULL )
 802373e:	697b      	ldr	r3, [r7, #20]
 8023740:	2b00      	cmp	r3, #0
 8023742:	d002      	beq.n	802374a <xQueueCreateCountingSemaphore+0x5c>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8023744:	697b      	ldr	r3, [r7, #20]
 8023746:	683a      	ldr	r2, [r7, #0]
 8023748:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 802374a:	697b      	ldr	r3, [r7, #20]
	}
 802374c:	4618      	mov	r0, r3
 802374e:	3718      	adds	r7, #24
 8023750:	46bd      	mov	sp, r7
 8023752:	bd80      	pop	{r7, pc}

08023754 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 8023754:	b580      	push	{r7, lr}
 8023756:	b08e      	sub	sp, #56	; 0x38
 8023758:	af00      	add	r7, sp, #0
 802375a:	60f8      	str	r0, [r7, #12]
 802375c:	60b9      	str	r1, [r7, #8]
 802375e:	607a      	str	r2, [r7, #4]
 8023760:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 8023762:	2300      	movs	r3, #0
 8023764:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 8023766:	68fb      	ldr	r3, [r7, #12]
 8023768:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 802376a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802376c:	2b00      	cmp	r3, #0
 802376e:	d10a      	bne.n	8023786 <xQueueGenericSend+0x32>
	__asm volatile
 8023770:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023774:	f383 8811 	msr	BASEPRI, r3
 8023778:	f3bf 8f6f 	isb	sy
 802377c:	f3bf 8f4f 	dsb	sy
 8023780:	62bb      	str	r3, [r7, #40]	; 0x28
}
 8023782:	bf00      	nop
 8023784:	e7fe      	b.n	8023784 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8023786:	68bb      	ldr	r3, [r7, #8]
 8023788:	2b00      	cmp	r3, #0
 802378a:	d103      	bne.n	8023794 <xQueueGenericSend+0x40>
 802378c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802378e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023790:	2b00      	cmp	r3, #0
 8023792:	d101      	bne.n	8023798 <xQueueGenericSend+0x44>
 8023794:	2301      	movs	r3, #1
 8023796:	e000      	b.n	802379a <xQueueGenericSend+0x46>
 8023798:	2300      	movs	r3, #0
 802379a:	2b00      	cmp	r3, #0
 802379c:	d10a      	bne.n	80237b4 <xQueueGenericSend+0x60>
	__asm volatile
 802379e:	f04f 0350 	mov.w	r3, #80	; 0x50
 80237a2:	f383 8811 	msr	BASEPRI, r3
 80237a6:	f3bf 8f6f 	isb	sy
 80237aa:	f3bf 8f4f 	dsb	sy
 80237ae:	627b      	str	r3, [r7, #36]	; 0x24
}
 80237b0:	bf00      	nop
 80237b2:	e7fe      	b.n	80237b2 <xQueueGenericSend+0x5e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80237b4:	683b      	ldr	r3, [r7, #0]
 80237b6:	2b02      	cmp	r3, #2
 80237b8:	d103      	bne.n	80237c2 <xQueueGenericSend+0x6e>
 80237ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80237bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80237be:	2b01      	cmp	r3, #1
 80237c0:	d101      	bne.n	80237c6 <xQueueGenericSend+0x72>
 80237c2:	2301      	movs	r3, #1
 80237c4:	e000      	b.n	80237c8 <xQueueGenericSend+0x74>
 80237c6:	2300      	movs	r3, #0
 80237c8:	2b00      	cmp	r3, #0
 80237ca:	d10a      	bne.n	80237e2 <xQueueGenericSend+0x8e>
	__asm volatile
 80237cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80237d0:	f383 8811 	msr	BASEPRI, r3
 80237d4:	f3bf 8f6f 	isb	sy
 80237d8:	f3bf 8f4f 	dsb	sy
 80237dc:	623b      	str	r3, [r7, #32]
}
 80237de:	bf00      	nop
 80237e0:	e7fe      	b.n	80237e0 <xQueueGenericSend+0x8c>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80237e2:	f001 fc75 	bl	80250d0 <xTaskGetSchedulerState>
 80237e6:	4603      	mov	r3, r0
 80237e8:	2b00      	cmp	r3, #0
 80237ea:	d102      	bne.n	80237f2 <xQueueGenericSend+0x9e>
 80237ec:	687b      	ldr	r3, [r7, #4]
 80237ee:	2b00      	cmp	r3, #0
 80237f0:	d101      	bne.n	80237f6 <xQueueGenericSend+0xa2>
 80237f2:	2301      	movs	r3, #1
 80237f4:	e000      	b.n	80237f8 <xQueueGenericSend+0xa4>
 80237f6:	2300      	movs	r3, #0
 80237f8:	2b00      	cmp	r3, #0
 80237fa:	d10a      	bne.n	8023812 <xQueueGenericSend+0xbe>
	__asm volatile
 80237fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023800:	f383 8811 	msr	BASEPRI, r3
 8023804:	f3bf 8f6f 	isb	sy
 8023808:	f3bf 8f4f 	dsb	sy
 802380c:	61fb      	str	r3, [r7, #28]
}
 802380e:	bf00      	nop
 8023810:	e7fe      	b.n	8023810 <xQueueGenericSend+0xbc>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8023812:	f002 fd6f 	bl	80262f4 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8023816:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023818:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 802381a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802381c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802381e:	429a      	cmp	r2, r3
 8023820:	d302      	bcc.n	8023828 <xQueueGenericSend+0xd4>
 8023822:	683b      	ldr	r3, [r7, #0]
 8023824:	2b02      	cmp	r3, #2
 8023826:	d129      	bne.n	802387c <xQueueGenericSend+0x128>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8023828:	683a      	ldr	r2, [r7, #0]
 802382a:	68b9      	ldr	r1, [r7, #8]
 802382c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802382e:	f000 fc5e 	bl	80240ee <prvCopyDataToQueue>
 8023832:	62f8      	str	r0, [r7, #44]	; 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8023834:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023836:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023838:	2b00      	cmp	r3, #0
 802383a:	d010      	beq.n	802385e <xQueueGenericSend+0x10a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802383c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802383e:	3324      	adds	r3, #36	; 0x24
 8023840:	4618      	mov	r0, r3
 8023842:	f001 fa73 	bl	8024d2c <xTaskRemoveFromEventList>
 8023846:	4603      	mov	r3, r0
 8023848:	2b00      	cmp	r3, #0
 802384a:	d013      	beq.n	8023874 <xQueueGenericSend+0x120>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 802384c:	4b3f      	ldr	r3, [pc, #252]	; (802394c <xQueueGenericSend+0x1f8>)
 802384e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023852:	601a      	str	r2, [r3, #0]
 8023854:	f3bf 8f4f 	dsb	sy
 8023858:	f3bf 8f6f 	isb	sy
 802385c:	e00a      	b.n	8023874 <xQueueGenericSend+0x120>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 802385e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023860:	2b00      	cmp	r3, #0
 8023862:	d007      	beq.n	8023874 <xQueueGenericSend+0x120>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 8023864:	4b39      	ldr	r3, [pc, #228]	; (802394c <xQueueGenericSend+0x1f8>)
 8023866:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802386a:	601a      	str	r2, [r3, #0]
 802386c:	f3bf 8f4f 	dsb	sy
 8023870:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8023874:	f002 fd6e 	bl	8026354 <vPortExitCritical>
				return pdPASS;
 8023878:	2301      	movs	r3, #1
 802387a:	e063      	b.n	8023944 <xQueueGenericSend+0x1f0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 802387c:	687b      	ldr	r3, [r7, #4]
 802387e:	2b00      	cmp	r3, #0
 8023880:	d103      	bne.n	802388a <xQueueGenericSend+0x136>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8023882:	f002 fd67 	bl	8026354 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8023886:	2300      	movs	r3, #0
 8023888:	e05c      	b.n	8023944 <xQueueGenericSend+0x1f0>
				}
				else if( xEntryTimeSet == pdFALSE )
 802388a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802388c:	2b00      	cmp	r3, #0
 802388e:	d106      	bne.n	802389e <xQueueGenericSend+0x14a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 8023890:	f107 0314 	add.w	r3, r7, #20
 8023894:	4618      	mov	r0, r3
 8023896:	f001 faad 	bl	8024df4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 802389a:	2301      	movs	r3, #1
 802389c:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 802389e:	f002 fd59 	bl	8026354 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80238a2:	f001 f819 	bl	80248d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80238a6:	f002 fd25 	bl	80262f4 <vPortEnterCritical>
 80238aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80238ac:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80238b0:	b25b      	sxtb	r3, r3
 80238b2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80238b6:	d103      	bne.n	80238c0 <xQueueGenericSend+0x16c>
 80238b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80238ba:	2200      	movs	r2, #0
 80238bc:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80238c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80238c2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80238c6:	b25b      	sxtb	r3, r3
 80238c8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80238cc:	d103      	bne.n	80238d6 <xQueueGenericSend+0x182>
 80238ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80238d0:	2200      	movs	r2, #0
 80238d2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80238d6:	f002 fd3d 	bl	8026354 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80238da:	1d3a      	adds	r2, r7, #4
 80238dc:	f107 0314 	add.w	r3, r7, #20
 80238e0:	4611      	mov	r1, r2
 80238e2:	4618      	mov	r0, r3
 80238e4:	f001 fa9c 	bl	8024e20 <xTaskCheckForTimeOut>
 80238e8:	4603      	mov	r3, r0
 80238ea:	2b00      	cmp	r3, #0
 80238ec:	d124      	bne.n	8023938 <xQueueGenericSend+0x1e4>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 80238ee:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80238f0:	f000 fcf5 	bl	80242de <prvIsQueueFull>
 80238f4:	4603      	mov	r3, r0
 80238f6:	2b00      	cmp	r3, #0
 80238f8:	d018      	beq.n	802392c <xQueueGenericSend+0x1d8>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80238fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80238fc:	3310      	adds	r3, #16
 80238fe:	687a      	ldr	r2, [r7, #4]
 8023900:	4611      	mov	r1, r2
 8023902:	4618      	mov	r0, r3
 8023904:	f001 f9c2 	bl	8024c8c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8023908:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802390a:	f000 fc80 	bl	802420e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 802390e:	f000 fff1 	bl	80248f4 <xTaskResumeAll>
 8023912:	4603      	mov	r3, r0
 8023914:	2b00      	cmp	r3, #0
 8023916:	f47f af7c 	bne.w	8023812 <xQueueGenericSend+0xbe>
				{
					portYIELD_WITHIN_API();
 802391a:	4b0c      	ldr	r3, [pc, #48]	; (802394c <xQueueGenericSend+0x1f8>)
 802391c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023920:	601a      	str	r2, [r3, #0]
 8023922:	f3bf 8f4f 	dsb	sy
 8023926:	f3bf 8f6f 	isb	sy
 802392a:	e772      	b.n	8023812 <xQueueGenericSend+0xbe>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 802392c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802392e:	f000 fc6e 	bl	802420e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8023932:	f000 ffdf 	bl	80248f4 <xTaskResumeAll>
 8023936:	e76c      	b.n	8023812 <xQueueGenericSend+0xbe>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8023938:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802393a:	f000 fc68 	bl	802420e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 802393e:	f000 ffd9 	bl	80248f4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8023942:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
 8023944:	4618      	mov	r0, r3
 8023946:	3738      	adds	r7, #56	; 0x38
 8023948:	46bd      	mov	sp, r7
 802394a:	bd80      	pop	{r7, pc}
 802394c:	e000ed04 	.word	0xe000ed04

08023950 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 8023950:	b580      	push	{r7, lr}
 8023952:	b090      	sub	sp, #64	; 0x40
 8023954:	af00      	add	r7, sp, #0
 8023956:	60f8      	str	r0, [r7, #12]
 8023958:	60b9      	str	r1, [r7, #8]
 802395a:	607a      	str	r2, [r7, #4]
 802395c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 802395e:	68fb      	ldr	r3, [r7, #12]
 8023960:	63bb      	str	r3, [r7, #56]	; 0x38

	configASSERT( pxQueue );
 8023962:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023964:	2b00      	cmp	r3, #0
 8023966:	d10a      	bne.n	802397e <xQueueGenericSendFromISR+0x2e>
	__asm volatile
 8023968:	f04f 0350 	mov.w	r3, #80	; 0x50
 802396c:	f383 8811 	msr	BASEPRI, r3
 8023970:	f3bf 8f6f 	isb	sy
 8023974:	f3bf 8f4f 	dsb	sy
 8023978:	62bb      	str	r3, [r7, #40]	; 0x28
}
 802397a:	bf00      	nop
 802397c:	e7fe      	b.n	802397c <xQueueGenericSendFromISR+0x2c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802397e:	68bb      	ldr	r3, [r7, #8]
 8023980:	2b00      	cmp	r3, #0
 8023982:	d103      	bne.n	802398c <xQueueGenericSendFromISR+0x3c>
 8023984:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023986:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023988:	2b00      	cmp	r3, #0
 802398a:	d101      	bne.n	8023990 <xQueueGenericSendFromISR+0x40>
 802398c:	2301      	movs	r3, #1
 802398e:	e000      	b.n	8023992 <xQueueGenericSendFromISR+0x42>
 8023990:	2300      	movs	r3, #0
 8023992:	2b00      	cmp	r3, #0
 8023994:	d10a      	bne.n	80239ac <xQueueGenericSendFromISR+0x5c>
	__asm volatile
 8023996:	f04f 0350 	mov.w	r3, #80	; 0x50
 802399a:	f383 8811 	msr	BASEPRI, r3
 802399e:	f3bf 8f6f 	isb	sy
 80239a2:	f3bf 8f4f 	dsb	sy
 80239a6:	627b      	str	r3, [r7, #36]	; 0x24
}
 80239a8:	bf00      	nop
 80239aa:	e7fe      	b.n	80239aa <xQueueGenericSendFromISR+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80239ac:	683b      	ldr	r3, [r7, #0]
 80239ae:	2b02      	cmp	r3, #2
 80239b0:	d103      	bne.n	80239ba <xQueueGenericSendFromISR+0x6a>
 80239b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80239b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80239b6:	2b01      	cmp	r3, #1
 80239b8:	d101      	bne.n	80239be <xQueueGenericSendFromISR+0x6e>
 80239ba:	2301      	movs	r3, #1
 80239bc:	e000      	b.n	80239c0 <xQueueGenericSendFromISR+0x70>
 80239be:	2300      	movs	r3, #0
 80239c0:	2b00      	cmp	r3, #0
 80239c2:	d10a      	bne.n	80239da <xQueueGenericSendFromISR+0x8a>
	__asm volatile
 80239c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80239c8:	f383 8811 	msr	BASEPRI, r3
 80239cc:	f3bf 8f6f 	isb	sy
 80239d0:	f3bf 8f4f 	dsb	sy
 80239d4:	623b      	str	r3, [r7, #32]
}
 80239d6:	bf00      	nop
 80239d8:	e7fe      	b.n	80239d8 <xQueueGenericSendFromISR+0x88>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80239da:	f002 fd6d 	bl	80264b8 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80239de:	f3ef 8211 	mrs	r2, BASEPRI
 80239e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80239e6:	f383 8811 	msr	BASEPRI, r3
 80239ea:	f3bf 8f6f 	isb	sy
 80239ee:	f3bf 8f4f 	dsb	sy
 80239f2:	61fa      	str	r2, [r7, #28]
 80239f4:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
 80239f6:	69fb      	ldr	r3, [r7, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80239f8:	637b      	str	r3, [r7, #52]	; 0x34
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80239fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80239fc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80239fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8023a02:	429a      	cmp	r2, r3
 8023a04:	d302      	bcc.n	8023a0c <xQueueGenericSendFromISR+0xbc>
 8023a06:	683b      	ldr	r3, [r7, #0]
 8023a08:	2b02      	cmp	r3, #2
 8023a0a:	d12f      	bne.n	8023a6c <xQueueGenericSendFromISR+0x11c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 8023a0c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a0e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8023a12:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 8023a16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a18:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8023a1a:	62fb      	str	r3, [r7, #44]	; 0x2c
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8023a1c:	683a      	ldr	r2, [r7, #0]
 8023a1e:	68b9      	ldr	r1, [r7, #8]
 8023a20:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8023a22:	f000 fb64 	bl	80240ee <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 8023a26:	f997 3033 	ldrsb.w	r3, [r7, #51]	; 0x33
 8023a2a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023a2e:	d112      	bne.n	8023a56 <xQueueGenericSendFromISR+0x106>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8023a30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023a34:	2b00      	cmp	r3, #0
 8023a36:	d016      	beq.n	8023a66 <xQueueGenericSendFromISR+0x116>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8023a38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a3a:	3324      	adds	r3, #36	; 0x24
 8023a3c:	4618      	mov	r0, r3
 8023a3e:	f001 f975 	bl	8024d2c <xTaskRemoveFromEventList>
 8023a42:	4603      	mov	r3, r0
 8023a44:	2b00      	cmp	r3, #0
 8023a46:	d00e      	beq.n	8023a66 <xQueueGenericSendFromISR+0x116>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8023a48:	687b      	ldr	r3, [r7, #4]
 8023a4a:	2b00      	cmp	r3, #0
 8023a4c:	d00b      	beq.n	8023a66 <xQueueGenericSendFromISR+0x116>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8023a4e:	687b      	ldr	r3, [r7, #4]
 8023a50:	2201      	movs	r2, #1
 8023a52:	601a      	str	r2, [r3, #0]
 8023a54:	e007      	b.n	8023a66 <xQueueGenericSendFromISR+0x116>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8023a56:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8023a5a:	3301      	adds	r3, #1
 8023a5c:	b2db      	uxtb	r3, r3
 8023a5e:	b25a      	sxtb	r2, r3
 8023a60:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8023a62:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 8023a66:	2301      	movs	r3, #1
 8023a68:	63fb      	str	r3, [r7, #60]	; 0x3c
		{
 8023a6a:	e001      	b.n	8023a70 <xQueueGenericSendFromISR+0x120>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8023a6c:	2300      	movs	r3, #0
 8023a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8023a70:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8023a72:	617b      	str	r3, [r7, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8023a74:	697b      	ldr	r3, [r7, #20]
 8023a76:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 8023a7a:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 8023a7c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 8023a7e:	4618      	mov	r0, r3
 8023a80:	3740      	adds	r7, #64	; 0x40
 8023a82:	46bd      	mov	sp, r7
 8023a84:	bd80      	pop	{r7, pc}

08023a86 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 8023a86:	b580      	push	{r7, lr}
 8023a88:	b08e      	sub	sp, #56	; 0x38
 8023a8a:	af00      	add	r7, sp, #0
 8023a8c:	6078      	str	r0, [r7, #4]
 8023a8e:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 8023a90:	687b      	ldr	r3, [r7, #4]
 8023a92:	633b      	str	r3, [r7, #48]	; 0x30
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
 8023a94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023a96:	2b00      	cmp	r3, #0
 8023a98:	d10a      	bne.n	8023ab0 <xQueueGiveFromISR+0x2a>
	__asm volatile
 8023a9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023a9e:	f383 8811 	msr	BASEPRI, r3
 8023aa2:	f3bf 8f6f 	isb	sy
 8023aa6:	f3bf 8f4f 	dsb	sy
 8023aaa:	623b      	str	r3, [r7, #32]
}
 8023aac:	bf00      	nop
 8023aae:	e7fe      	b.n	8023aae <xQueueGiveFromISR+0x28>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 8023ab0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023ab2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023ab4:	2b00      	cmp	r3, #0
 8023ab6:	d00a      	beq.n	8023ace <xQueueGiveFromISR+0x48>
	__asm volatile
 8023ab8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023abc:	f383 8811 	msr	BASEPRI, r3
 8023ac0:	f3bf 8f6f 	isb	sy
 8023ac4:	f3bf 8f4f 	dsb	sy
 8023ac8:	61fb      	str	r3, [r7, #28]
}
 8023aca:	bf00      	nop
 8023acc:	e7fe      	b.n	8023acc <xQueueGiveFromISR+0x46>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8023ace:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023ad0:	681b      	ldr	r3, [r3, #0]
 8023ad2:	2b00      	cmp	r3, #0
 8023ad4:	d103      	bne.n	8023ade <xQueueGiveFromISR+0x58>
 8023ad6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023ad8:	689b      	ldr	r3, [r3, #8]
 8023ada:	2b00      	cmp	r3, #0
 8023adc:	d101      	bne.n	8023ae2 <xQueueGiveFromISR+0x5c>
 8023ade:	2301      	movs	r3, #1
 8023ae0:	e000      	b.n	8023ae4 <xQueueGiveFromISR+0x5e>
 8023ae2:	2300      	movs	r3, #0
 8023ae4:	2b00      	cmp	r3, #0
 8023ae6:	d10a      	bne.n	8023afe <xQueueGiveFromISR+0x78>
	__asm volatile
 8023ae8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023aec:	f383 8811 	msr	BASEPRI, r3
 8023af0:	f3bf 8f6f 	isb	sy
 8023af4:	f3bf 8f4f 	dsb	sy
 8023af8:	61bb      	str	r3, [r7, #24]
}
 8023afa:	bf00      	nop
 8023afc:	e7fe      	b.n	8023afc <xQueueGiveFromISR+0x76>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8023afe:	f002 fcdb 	bl	80264b8 <vPortValidateInterruptPriority>
	__asm volatile
 8023b02:	f3ef 8211 	mrs	r2, BASEPRI
 8023b06:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023b0a:	f383 8811 	msr	BASEPRI, r3
 8023b0e:	f3bf 8f6f 	isb	sy
 8023b12:	f3bf 8f4f 	dsb	sy
 8023b16:	617a      	str	r2, [r7, #20]
 8023b18:	613b      	str	r3, [r7, #16]
	return ulOriginalBASEPRI;
 8023b1a:	697b      	ldr	r3, [r7, #20]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8023b1c:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8023b1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b20:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8023b22:	62bb      	str	r3, [r7, #40]	; 0x28

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 8023b24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b26:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8023b28:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8023b2a:	429a      	cmp	r2, r3
 8023b2c:	d22b      	bcs.n	8023b86 <xQueueGiveFromISR+0x100>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 8023b2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b30:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8023b34:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8023b38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023b3a:	1c5a      	adds	r2, r3, #1
 8023b3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b3e:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 8023b40:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 8023b44:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023b48:	d112      	bne.n	8023b70 <xQueueGiveFromISR+0xea>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8023b4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023b4e:	2b00      	cmp	r3, #0
 8023b50:	d016      	beq.n	8023b80 <xQueueGiveFromISR+0xfa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8023b52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b54:	3324      	adds	r3, #36	; 0x24
 8023b56:	4618      	mov	r0, r3
 8023b58:	f001 f8e8 	bl	8024d2c <xTaskRemoveFromEventList>
 8023b5c:	4603      	mov	r3, r0
 8023b5e:	2b00      	cmp	r3, #0
 8023b60:	d00e      	beq.n	8023b80 <xQueueGiveFromISR+0xfa>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8023b62:	683b      	ldr	r3, [r7, #0]
 8023b64:	2b00      	cmp	r3, #0
 8023b66:	d00b      	beq.n	8023b80 <xQueueGiveFromISR+0xfa>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8023b68:	683b      	ldr	r3, [r7, #0]
 8023b6a:	2201      	movs	r2, #1
 8023b6c:	601a      	str	r2, [r3, #0]
 8023b6e:	e007      	b.n	8023b80 <xQueueGiveFromISR+0xfa>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8023b70:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8023b74:	3301      	adds	r3, #1
 8023b76:	b2db      	uxtb	r3, r3
 8023b78:	b25a      	sxtb	r2, r3
 8023b7a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023b7c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 8023b80:	2301      	movs	r3, #1
 8023b82:	637b      	str	r3, [r7, #52]	; 0x34
 8023b84:	e001      	b.n	8023b8a <xQueueGiveFromISR+0x104>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8023b86:	2300      	movs	r3, #0
 8023b88:	637b      	str	r3, [r7, #52]	; 0x34
 8023b8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023b8c:	60fb      	str	r3, [r7, #12]
	__asm volatile
 8023b8e:	68fb      	ldr	r3, [r7, #12]
 8023b90:	f383 8811 	msr	BASEPRI, r3
}
 8023b94:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 8023b96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8023b98:	4618      	mov	r0, r3
 8023b9a:	3738      	adds	r7, #56	; 0x38
 8023b9c:	46bd      	mov	sp, r7
 8023b9e:	bd80      	pop	{r7, pc}

08023ba0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 8023ba0:	b580      	push	{r7, lr}
 8023ba2:	b08c      	sub	sp, #48	; 0x30
 8023ba4:	af00      	add	r7, sp, #0
 8023ba6:	60f8      	str	r0, [r7, #12]
 8023ba8:	60b9      	str	r1, [r7, #8]
 8023baa:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
 8023bac:	2300      	movs	r3, #0
 8023bae:	62fb      	str	r3, [r7, #44]	; 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 8023bb0:	68fb      	ldr	r3, [r7, #12]
 8023bb2:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 8023bb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023bb6:	2b00      	cmp	r3, #0
 8023bb8:	d10a      	bne.n	8023bd0 <xQueueReceive+0x30>
	__asm volatile
 8023bba:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023bbe:	f383 8811 	msr	BASEPRI, r3
 8023bc2:	f3bf 8f6f 	isb	sy
 8023bc6:	f3bf 8f4f 	dsb	sy
 8023bca:	623b      	str	r3, [r7, #32]
}
 8023bcc:	bf00      	nop
 8023bce:	e7fe      	b.n	8023bce <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8023bd0:	68bb      	ldr	r3, [r7, #8]
 8023bd2:	2b00      	cmp	r3, #0
 8023bd4:	d103      	bne.n	8023bde <xQueueReceive+0x3e>
 8023bd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023bd8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023bda:	2b00      	cmp	r3, #0
 8023bdc:	d101      	bne.n	8023be2 <xQueueReceive+0x42>
 8023bde:	2301      	movs	r3, #1
 8023be0:	e000      	b.n	8023be4 <xQueueReceive+0x44>
 8023be2:	2300      	movs	r3, #0
 8023be4:	2b00      	cmp	r3, #0
 8023be6:	d10a      	bne.n	8023bfe <xQueueReceive+0x5e>
	__asm volatile
 8023be8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023bec:	f383 8811 	msr	BASEPRI, r3
 8023bf0:	f3bf 8f6f 	isb	sy
 8023bf4:	f3bf 8f4f 	dsb	sy
 8023bf8:	61fb      	str	r3, [r7, #28]
}
 8023bfa:	bf00      	nop
 8023bfc:	e7fe      	b.n	8023bfc <xQueueReceive+0x5c>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8023bfe:	f001 fa67 	bl	80250d0 <xTaskGetSchedulerState>
 8023c02:	4603      	mov	r3, r0
 8023c04:	2b00      	cmp	r3, #0
 8023c06:	d102      	bne.n	8023c0e <xQueueReceive+0x6e>
 8023c08:	687b      	ldr	r3, [r7, #4]
 8023c0a:	2b00      	cmp	r3, #0
 8023c0c:	d101      	bne.n	8023c12 <xQueueReceive+0x72>
 8023c0e:	2301      	movs	r3, #1
 8023c10:	e000      	b.n	8023c14 <xQueueReceive+0x74>
 8023c12:	2300      	movs	r3, #0
 8023c14:	2b00      	cmp	r3, #0
 8023c16:	d10a      	bne.n	8023c2e <xQueueReceive+0x8e>
	__asm volatile
 8023c18:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023c1c:	f383 8811 	msr	BASEPRI, r3
 8023c20:	f3bf 8f6f 	isb	sy
 8023c24:	f3bf 8f4f 	dsb	sy
 8023c28:	61bb      	str	r3, [r7, #24]
}
 8023c2a:	bf00      	nop
 8023c2c:	e7fe      	b.n	8023c2c <xQueueReceive+0x8c>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8023c2e:	f002 fb61 	bl	80262f4 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8023c32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023c34:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8023c36:	627b      	str	r3, [r7, #36]	; 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8023c38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023c3a:	2b00      	cmp	r3, #0
 8023c3c:	d01f      	beq.n	8023c7e <xQueueReceive+0xde>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8023c3e:	68b9      	ldr	r1, [r7, #8]
 8023c40:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023c42:	f000 fabe 	bl	80241c2 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8023c46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023c48:	1e5a      	subs	r2, r3, #1
 8023c4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023c4c:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8023c4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023c50:	691b      	ldr	r3, [r3, #16]
 8023c52:	2b00      	cmp	r3, #0
 8023c54:	d00f      	beq.n	8023c76 <xQueueReceive+0xd6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8023c56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023c58:	3310      	adds	r3, #16
 8023c5a:	4618      	mov	r0, r3
 8023c5c:	f001 f866 	bl	8024d2c <xTaskRemoveFromEventList>
 8023c60:	4603      	mov	r3, r0
 8023c62:	2b00      	cmp	r3, #0
 8023c64:	d007      	beq.n	8023c76 <xQueueReceive+0xd6>
					{
						queueYIELD_IF_USING_PREEMPTION();
 8023c66:	4b3d      	ldr	r3, [pc, #244]	; (8023d5c <xQueueReceive+0x1bc>)
 8023c68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023c6c:	601a      	str	r2, [r3, #0]
 8023c6e:	f3bf 8f4f 	dsb	sy
 8023c72:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 8023c76:	f002 fb6d 	bl	8026354 <vPortExitCritical>
				return pdPASS;
 8023c7a:	2301      	movs	r3, #1
 8023c7c:	e069      	b.n	8023d52 <xQueueReceive+0x1b2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8023c7e:	687b      	ldr	r3, [r7, #4]
 8023c80:	2b00      	cmp	r3, #0
 8023c82:	d103      	bne.n	8023c8c <xQueueReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8023c84:	f002 fb66 	bl	8026354 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8023c88:	2300      	movs	r3, #0
 8023c8a:	e062      	b.n	8023d52 <xQueueReceive+0x1b2>
				}
				else if( xEntryTimeSet == pdFALSE )
 8023c8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023c8e:	2b00      	cmp	r3, #0
 8023c90:	d106      	bne.n	8023ca0 <xQueueReceive+0x100>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 8023c92:	f107 0310 	add.w	r3, r7, #16
 8023c96:	4618      	mov	r0, r3
 8023c98:	f001 f8ac 	bl	8024df4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8023c9c:	2301      	movs	r3, #1
 8023c9e:	62fb      	str	r3, [r7, #44]	; 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8023ca0:	f002 fb58 	bl	8026354 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8023ca4:	f000 fe18 	bl	80248d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8023ca8:	f002 fb24 	bl	80262f4 <vPortEnterCritical>
 8023cac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023cae:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8023cb2:	b25b      	sxtb	r3, r3
 8023cb4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023cb8:	d103      	bne.n	8023cc2 <xQueueReceive+0x122>
 8023cba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023cbc:	2200      	movs	r2, #0
 8023cbe:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8023cc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023cc4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8023cc8:	b25b      	sxtb	r3, r3
 8023cca:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023cce:	d103      	bne.n	8023cd8 <xQueueReceive+0x138>
 8023cd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023cd2:	2200      	movs	r2, #0
 8023cd4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8023cd8:	f002 fb3c 	bl	8026354 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8023cdc:	1d3a      	adds	r2, r7, #4
 8023cde:	f107 0310 	add.w	r3, r7, #16
 8023ce2:	4611      	mov	r1, r2
 8023ce4:	4618      	mov	r0, r3
 8023ce6:	f001 f89b 	bl	8024e20 <xTaskCheckForTimeOut>
 8023cea:	4603      	mov	r3, r0
 8023cec:	2b00      	cmp	r3, #0
 8023cee:	d123      	bne.n	8023d38 <xQueueReceive+0x198>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8023cf0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023cf2:	f000 fade 	bl	80242b2 <prvIsQueueEmpty>
 8023cf6:	4603      	mov	r3, r0
 8023cf8:	2b00      	cmp	r3, #0
 8023cfa:	d017      	beq.n	8023d2c <xQueueReceive+0x18c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8023cfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023cfe:	3324      	adds	r3, #36	; 0x24
 8023d00:	687a      	ldr	r2, [r7, #4]
 8023d02:	4611      	mov	r1, r2
 8023d04:	4618      	mov	r0, r3
 8023d06:	f000 ffc1 	bl	8024c8c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8023d0a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023d0c:	f000 fa7f 	bl	802420e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8023d10:	f000 fdf0 	bl	80248f4 <xTaskResumeAll>
 8023d14:	4603      	mov	r3, r0
 8023d16:	2b00      	cmp	r3, #0
 8023d18:	d189      	bne.n	8023c2e <xQueueReceive+0x8e>
				{
					portYIELD_WITHIN_API();
 8023d1a:	4b10      	ldr	r3, [pc, #64]	; (8023d5c <xQueueReceive+0x1bc>)
 8023d1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023d20:	601a      	str	r2, [r3, #0]
 8023d22:	f3bf 8f4f 	dsb	sy
 8023d26:	f3bf 8f6f 	isb	sy
 8023d2a:	e780      	b.n	8023c2e <xQueueReceive+0x8e>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 8023d2c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023d2e:	f000 fa6e 	bl	802420e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8023d32:	f000 fddf 	bl	80248f4 <xTaskResumeAll>
 8023d36:	e77a      	b.n	8023c2e <xQueueReceive+0x8e>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 8023d38:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023d3a:	f000 fa68 	bl	802420e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8023d3e:	f000 fdd9 	bl	80248f4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8023d42:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8023d44:	f000 fab5 	bl	80242b2 <prvIsQueueEmpty>
 8023d48:	4603      	mov	r3, r0
 8023d4a:	2b00      	cmp	r3, #0
 8023d4c:	f43f af6f 	beq.w	8023c2e <xQueueReceive+0x8e>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 8023d50:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 8023d52:	4618      	mov	r0, r3
 8023d54:	3730      	adds	r7, #48	; 0x30
 8023d56:	46bd      	mov	sp, r7
 8023d58:	bd80      	pop	{r7, pc}
 8023d5a:	bf00      	nop
 8023d5c:	e000ed04 	.word	0xe000ed04

08023d60 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 8023d60:	b580      	push	{r7, lr}
 8023d62:	b08e      	sub	sp, #56	; 0x38
 8023d64:	af00      	add	r7, sp, #0
 8023d66:	6078      	str	r0, [r7, #4]
 8023d68:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 8023d6a:	2300      	movs	r3, #0
 8023d6c:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 8023d6e:	687b      	ldr	r3, [r7, #4]
 8023d70:	62fb      	str	r3, [r7, #44]	; 0x2c

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 8023d72:	2300      	movs	r3, #0
 8023d74:	633b      	str	r3, [r7, #48]	; 0x30
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 8023d76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023d78:	2b00      	cmp	r3, #0
 8023d7a:	d10a      	bne.n	8023d92 <xQueueSemaphoreTake+0x32>
	__asm volatile
 8023d7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023d80:	f383 8811 	msr	BASEPRI, r3
 8023d84:	f3bf 8f6f 	isb	sy
 8023d88:	f3bf 8f4f 	dsb	sy
 8023d8c:	623b      	str	r3, [r7, #32]
}
 8023d8e:	bf00      	nop
 8023d90:	e7fe      	b.n	8023d90 <xQueueSemaphoreTake+0x30>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 8023d92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023d94:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023d96:	2b00      	cmp	r3, #0
 8023d98:	d00a      	beq.n	8023db0 <xQueueSemaphoreTake+0x50>
	__asm volatile
 8023d9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023d9e:	f383 8811 	msr	BASEPRI, r3
 8023da2:	f3bf 8f6f 	isb	sy
 8023da6:	f3bf 8f4f 	dsb	sy
 8023daa:	61fb      	str	r3, [r7, #28]
}
 8023dac:	bf00      	nop
 8023dae:	e7fe      	b.n	8023dae <xQueueSemaphoreTake+0x4e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8023db0:	f001 f98e 	bl	80250d0 <xTaskGetSchedulerState>
 8023db4:	4603      	mov	r3, r0
 8023db6:	2b00      	cmp	r3, #0
 8023db8:	d102      	bne.n	8023dc0 <xQueueSemaphoreTake+0x60>
 8023dba:	683b      	ldr	r3, [r7, #0]
 8023dbc:	2b00      	cmp	r3, #0
 8023dbe:	d101      	bne.n	8023dc4 <xQueueSemaphoreTake+0x64>
 8023dc0:	2301      	movs	r3, #1
 8023dc2:	e000      	b.n	8023dc6 <xQueueSemaphoreTake+0x66>
 8023dc4:	2300      	movs	r3, #0
 8023dc6:	2b00      	cmp	r3, #0
 8023dc8:	d10a      	bne.n	8023de0 <xQueueSemaphoreTake+0x80>
	__asm volatile
 8023dca:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023dce:	f383 8811 	msr	BASEPRI, r3
 8023dd2:	f3bf 8f6f 	isb	sy
 8023dd6:	f3bf 8f4f 	dsb	sy
 8023dda:	61bb      	str	r3, [r7, #24]
}
 8023ddc:	bf00      	nop
 8023dde:	e7fe      	b.n	8023dde <xQueueSemaphoreTake+0x7e>
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8023de0:	f002 fa88 	bl	80262f4 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8023de4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023de6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8023de8:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8023dea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023dec:	2b00      	cmp	r3, #0
 8023dee:	d024      	beq.n	8023e3a <xQueueSemaphoreTake+0xda>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8023df0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023df2:	1e5a      	subs	r2, r3, #1
 8023df4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023df6:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8023df8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023dfa:	681b      	ldr	r3, [r3, #0]
 8023dfc:	2b00      	cmp	r3, #0
 8023dfe:	d104      	bne.n	8023e0a <xQueueSemaphoreTake+0xaa>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8023e00:	f001 fadc 	bl	80253bc <pvTaskIncrementMutexHeldCount>
 8023e04:	4602      	mov	r2, r0
 8023e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e08:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8023e0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e0c:	691b      	ldr	r3, [r3, #16]
 8023e0e:	2b00      	cmp	r3, #0
 8023e10:	d00f      	beq.n	8023e32 <xQueueSemaphoreTake+0xd2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8023e12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e14:	3310      	adds	r3, #16
 8023e16:	4618      	mov	r0, r3
 8023e18:	f000 ff88 	bl	8024d2c <xTaskRemoveFromEventList>
 8023e1c:	4603      	mov	r3, r0
 8023e1e:	2b00      	cmp	r3, #0
 8023e20:	d007      	beq.n	8023e32 <xQueueSemaphoreTake+0xd2>
					{
						queueYIELD_IF_USING_PREEMPTION();
 8023e22:	4b54      	ldr	r3, [pc, #336]	; (8023f74 <xQueueSemaphoreTake+0x214>)
 8023e24:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023e28:	601a      	str	r2, [r3, #0]
 8023e2a:	f3bf 8f4f 	dsb	sy
 8023e2e:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 8023e32:	f002 fa8f 	bl	8026354 <vPortExitCritical>
				return pdPASS;
 8023e36:	2301      	movs	r3, #1
 8023e38:	e097      	b.n	8023f6a <xQueueSemaphoreTake+0x20a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8023e3a:	683b      	ldr	r3, [r7, #0]
 8023e3c:	2b00      	cmp	r3, #0
 8023e3e:	d111      	bne.n	8023e64 <xQueueSemaphoreTake+0x104>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
 8023e40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023e42:	2b00      	cmp	r3, #0
 8023e44:	d00a      	beq.n	8023e5c <xQueueSemaphoreTake+0xfc>
	__asm volatile
 8023e46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023e4a:	f383 8811 	msr	BASEPRI, r3
 8023e4e:	f3bf 8f6f 	isb	sy
 8023e52:	f3bf 8f4f 	dsb	sy
 8023e56:	617b      	str	r3, [r7, #20]
}
 8023e58:	bf00      	nop
 8023e5a:	e7fe      	b.n	8023e5a <xQueueSemaphoreTake+0xfa>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 8023e5c:	f002 fa7a 	bl	8026354 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8023e60:	2300      	movs	r3, #0
 8023e62:	e082      	b.n	8023f6a <xQueueSemaphoreTake+0x20a>
				}
				else if( xEntryTimeSet == pdFALSE )
 8023e64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8023e66:	2b00      	cmp	r3, #0
 8023e68:	d106      	bne.n	8023e78 <xQueueSemaphoreTake+0x118>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 8023e6a:	f107 030c 	add.w	r3, r7, #12
 8023e6e:	4618      	mov	r0, r3
 8023e70:	f000 ffc0 	bl	8024df4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8023e74:	2301      	movs	r3, #1
 8023e76:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8023e78:	f002 fa6c 	bl	8026354 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 8023e7c:	f000 fd2c 	bl	80248d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8023e80:	f002 fa38 	bl	80262f4 <vPortEnterCritical>
 8023e84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e86:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8023e8a:	b25b      	sxtb	r3, r3
 8023e8c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023e90:	d103      	bne.n	8023e9a <xQueueSemaphoreTake+0x13a>
 8023e92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e94:	2200      	movs	r2, #0
 8023e96:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8023e9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023e9c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8023ea0:	b25b      	sxtb	r3, r3
 8023ea2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8023ea6:	d103      	bne.n	8023eb0 <xQueueSemaphoreTake+0x150>
 8023ea8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023eaa:	2200      	movs	r2, #0
 8023eac:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8023eb0:	f002 fa50 	bl	8026354 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8023eb4:	463a      	mov	r2, r7
 8023eb6:	f107 030c 	add.w	r3, r7, #12
 8023eba:	4611      	mov	r1, r2
 8023ebc:	4618      	mov	r0, r3
 8023ebe:	f000 ffaf 	bl	8024e20 <xTaskCheckForTimeOut>
 8023ec2:	4603      	mov	r3, r0
 8023ec4:	2b00      	cmp	r3, #0
 8023ec6:	d132      	bne.n	8023f2e <xQueueSemaphoreTake+0x1ce>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8023ec8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023eca:	f000 f9f2 	bl	80242b2 <prvIsQueueEmpty>
 8023ece:	4603      	mov	r3, r0
 8023ed0:	2b00      	cmp	r3, #0
 8023ed2:	d026      	beq.n	8023f22 <xQueueSemaphoreTake+0x1c2>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8023ed4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023ed6:	681b      	ldr	r3, [r3, #0]
 8023ed8:	2b00      	cmp	r3, #0
 8023eda:	d109      	bne.n	8023ef0 <xQueueSemaphoreTake+0x190>
					{
						taskENTER_CRITICAL();
 8023edc:	f002 fa0a 	bl	80262f4 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8023ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023ee2:	689b      	ldr	r3, [r3, #8]
 8023ee4:	4618      	mov	r0, r3
 8023ee6:	f001 f911 	bl	802510c <xTaskPriorityInherit>
 8023eea:	6338      	str	r0, [r7, #48]	; 0x30
						}
						taskEXIT_CRITICAL();
 8023eec:	f002 fa32 	bl	8026354 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8023ef0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023ef2:	3324      	adds	r3, #36	; 0x24
 8023ef4:	683a      	ldr	r2, [r7, #0]
 8023ef6:	4611      	mov	r1, r2
 8023ef8:	4618      	mov	r0, r3
 8023efa:	f000 fec7 	bl	8024c8c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8023efe:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023f00:	f000 f985 	bl	802420e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8023f04:	f000 fcf6 	bl	80248f4 <xTaskResumeAll>
 8023f08:	4603      	mov	r3, r0
 8023f0a:	2b00      	cmp	r3, #0
 8023f0c:	f47f af68 	bne.w	8023de0 <xQueueSemaphoreTake+0x80>
				{
					portYIELD_WITHIN_API();
 8023f10:	4b18      	ldr	r3, [pc, #96]	; (8023f74 <xQueueSemaphoreTake+0x214>)
 8023f12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8023f16:	601a      	str	r2, [r3, #0]
 8023f18:	f3bf 8f4f 	dsb	sy
 8023f1c:	f3bf 8f6f 	isb	sy
 8023f20:	e75e      	b.n	8023de0 <xQueueSemaphoreTake+0x80>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 8023f22:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023f24:	f000 f973 	bl	802420e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8023f28:	f000 fce4 	bl	80248f4 <xTaskResumeAll>
 8023f2c:	e758      	b.n	8023de0 <xQueueSemaphoreTake+0x80>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 8023f2e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023f30:	f000 f96d 	bl	802420e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8023f34:	f000 fcde 	bl	80248f4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8023f38:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023f3a:	f000 f9ba 	bl	80242b2 <prvIsQueueEmpty>
 8023f3e:	4603      	mov	r3, r0
 8023f40:	2b00      	cmp	r3, #0
 8023f42:	f43f af4d 	beq.w	8023de0 <xQueueSemaphoreTake+0x80>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 8023f46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023f48:	2b00      	cmp	r3, #0
 8023f4a:	d00d      	beq.n	8023f68 <xQueueSemaphoreTake+0x208>
					{
						taskENTER_CRITICAL();
 8023f4c:	f002 f9d2 	bl	80262f4 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 8023f50:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023f52:	f000 f8b4 	bl	80240be <prvGetDisinheritPriorityAfterTimeout>
 8023f56:	6278      	str	r0, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8023f58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023f5a:	689b      	ldr	r3, [r3, #8]
 8023f5c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8023f5e:	4618      	mov	r0, r3
 8023f60:	f001 f9aa 	bl	80252b8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 8023f64:	f002 f9f6 	bl	8026354 <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 8023f68:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 8023f6a:	4618      	mov	r0, r3
 8023f6c:	3738      	adds	r7, #56	; 0x38
 8023f6e:	46bd      	mov	sp, r7
 8023f70:	bd80      	pop	{r7, pc}
 8023f72:	bf00      	nop
 8023f74:	e000ed04 	.word	0xe000ed04

08023f78 <xQueueReceiveFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 8023f78:	b580      	push	{r7, lr}
 8023f7a:	b08e      	sub	sp, #56	; 0x38
 8023f7c:	af00      	add	r7, sp, #0
 8023f7e:	60f8      	str	r0, [r7, #12]
 8023f80:	60b9      	str	r1, [r7, #8]
 8023f82:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 8023f84:	68fb      	ldr	r3, [r7, #12]
 8023f86:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 8023f88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023f8a:	2b00      	cmp	r3, #0
 8023f8c:	d10a      	bne.n	8023fa4 <xQueueReceiveFromISR+0x2c>
	__asm volatile
 8023f8e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023f92:	f383 8811 	msr	BASEPRI, r3
 8023f96:	f3bf 8f6f 	isb	sy
 8023f9a:	f3bf 8f4f 	dsb	sy
 8023f9e:	623b      	str	r3, [r7, #32]
}
 8023fa0:	bf00      	nop
 8023fa2:	e7fe      	b.n	8023fa2 <xQueueReceiveFromISR+0x2a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8023fa4:	68bb      	ldr	r3, [r7, #8]
 8023fa6:	2b00      	cmp	r3, #0
 8023fa8:	d103      	bne.n	8023fb2 <xQueueReceiveFromISR+0x3a>
 8023faa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023fac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023fae:	2b00      	cmp	r3, #0
 8023fb0:	d101      	bne.n	8023fb6 <xQueueReceiveFromISR+0x3e>
 8023fb2:	2301      	movs	r3, #1
 8023fb4:	e000      	b.n	8023fb8 <xQueueReceiveFromISR+0x40>
 8023fb6:	2300      	movs	r3, #0
 8023fb8:	2b00      	cmp	r3, #0
 8023fba:	d10a      	bne.n	8023fd2 <xQueueReceiveFromISR+0x5a>
	__asm volatile
 8023fbc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023fc0:	f383 8811 	msr	BASEPRI, r3
 8023fc4:	f3bf 8f6f 	isb	sy
 8023fc8:	f3bf 8f4f 	dsb	sy
 8023fcc:	61fb      	str	r3, [r7, #28]
}
 8023fce:	bf00      	nop
 8023fd0:	e7fe      	b.n	8023fd0 <xQueueReceiveFromISR+0x58>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8023fd2:	f002 fa71 	bl	80264b8 <vPortValidateInterruptPriority>
	__asm volatile
 8023fd6:	f3ef 8211 	mrs	r2, BASEPRI
 8023fda:	f04f 0350 	mov.w	r3, #80	; 0x50
 8023fde:	f383 8811 	msr	BASEPRI, r3
 8023fe2:	f3bf 8f6f 	isb	sy
 8023fe6:	f3bf 8f4f 	dsb	sy
 8023fea:	61ba      	str	r2, [r7, #24]
 8023fec:	617b      	str	r3, [r7, #20]
	return ulOriginalBASEPRI;
 8023fee:	69bb      	ldr	r3, [r7, #24]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8023ff0:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8023ff2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8023ff4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8023ff6:	62bb      	str	r3, [r7, #40]	; 0x28

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8023ff8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023ffa:	2b00      	cmp	r3, #0
 8023ffc:	d02f      	beq.n	802405e <xQueueReceiveFromISR+0xe6>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 8023ffe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024000:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8024004:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8024008:	68b9      	ldr	r1, [r7, #8]
 802400a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802400c:	f000 f8d9 	bl	80241c2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8024010:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024012:	1e5a      	subs	r2, r3, #1
 8024014:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024016:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 8024018:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 802401c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8024020:	d112      	bne.n	8024048 <xQueueReceiveFromISR+0xd0>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8024022:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024024:	691b      	ldr	r3, [r3, #16]
 8024026:	2b00      	cmp	r3, #0
 8024028:	d016      	beq.n	8024058 <xQueueReceiveFromISR+0xe0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 802402a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802402c:	3310      	adds	r3, #16
 802402e:	4618      	mov	r0, r3
 8024030:	f000 fe7c 	bl	8024d2c <xTaskRemoveFromEventList>
 8024034:	4603      	mov	r3, r0
 8024036:	2b00      	cmp	r3, #0
 8024038:	d00e      	beq.n	8024058 <xQueueReceiveFromISR+0xe0>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 802403a:	687b      	ldr	r3, [r7, #4]
 802403c:	2b00      	cmp	r3, #0
 802403e:	d00b      	beq.n	8024058 <xQueueReceiveFromISR+0xe0>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8024040:	687b      	ldr	r3, [r7, #4]
 8024042:	2201      	movs	r2, #1
 8024044:	601a      	str	r2, [r3, #0]
 8024046:	e007      	b.n	8024058 <xQueueReceiveFromISR+0xe0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8024048:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 802404c:	3301      	adds	r3, #1
 802404e:	b2db      	uxtb	r3, r3
 8024050:	b25a      	sxtb	r2, r3
 8024052:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024054:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
 8024058:	2301      	movs	r3, #1
 802405a:	637b      	str	r3, [r7, #52]	; 0x34
 802405c:	e001      	b.n	8024062 <xQueueReceiveFromISR+0xea>
		}
		else
		{
			xReturn = pdFAIL;
 802405e:	2300      	movs	r3, #0
 8024060:	637b      	str	r3, [r7, #52]	; 0x34
 8024062:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024064:	613b      	str	r3, [r7, #16]
	__asm volatile
 8024066:	693b      	ldr	r3, [r7, #16]
 8024068:	f383 8811 	msr	BASEPRI, r3
}
 802406c:	bf00      	nop
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 802406e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8024070:	4618      	mov	r0, r3
 8024072:	3738      	adds	r7, #56	; 0x38
 8024074:	46bd      	mov	sp, r7
 8024076:	bd80      	pop	{r7, pc}

08024078 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 8024078:	b580      	push	{r7, lr}
 802407a:	b084      	sub	sp, #16
 802407c:	af00      	add	r7, sp, #0
 802407e:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
 8024080:	687b      	ldr	r3, [r7, #4]
 8024082:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 8024084:	68fb      	ldr	r3, [r7, #12]
 8024086:	2b00      	cmp	r3, #0
 8024088:	d10a      	bne.n	80240a0 <vQueueDelete+0x28>
	__asm volatile
 802408a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802408e:	f383 8811 	msr	BASEPRI, r3
 8024092:	f3bf 8f6f 	isb	sy
 8024096:	f3bf 8f4f 	dsb	sy
 802409a:	60bb      	str	r3, [r7, #8]
}
 802409c:	bf00      	nop
 802409e:	e7fe      	b.n	802409e <vQueueDelete+0x26>
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
 80240a0:	68f8      	ldr	r0, [r7, #12]
 80240a2:	f000 f95f 	bl	8024364 <vQueueUnregisterQueue>
	}
	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
	{
		/* The queue could have been allocated statically or dynamically, so
		check before attempting to free the memory. */
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 80240a6:	68fb      	ldr	r3, [r7, #12]
 80240a8:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 80240ac:	2b00      	cmp	r3, #0
 80240ae:	d102      	bne.n	80240b6 <vQueueDelete+0x3e>
		{
			vPortFree( pxQueue );
 80240b0:	68f8      	ldr	r0, [r7, #12]
 80240b2:	f002 fb0d 	bl	80266d0 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 80240b6:	bf00      	nop
 80240b8:	3710      	adds	r7, #16
 80240ba:	46bd      	mov	sp, r7
 80240bc:	bd80      	pop	{r7, pc}

080240be <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 80240be:	b480      	push	{r7}
 80240c0:	b085      	sub	sp, #20
 80240c2:	af00      	add	r7, sp, #0
 80240c4:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 80240c6:	687b      	ldr	r3, [r7, #4]
 80240c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80240ca:	2b00      	cmp	r3, #0
 80240cc:	d006      	beq.n	80240dc <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 80240ce:	687b      	ldr	r3, [r7, #4]
 80240d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80240d2:	681b      	ldr	r3, [r3, #0]
 80240d4:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 80240d8:	60fb      	str	r3, [r7, #12]
 80240da:	e001      	b.n	80240e0 <prvGetDisinheritPriorityAfterTimeout+0x22>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 80240dc:	2300      	movs	r3, #0
 80240de:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
 80240e0:	68fb      	ldr	r3, [r7, #12]
	}
 80240e2:	4618      	mov	r0, r3
 80240e4:	3714      	adds	r7, #20
 80240e6:	46bd      	mov	sp, r7
 80240e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80240ec:	4770      	bx	lr

080240ee <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 80240ee:	b580      	push	{r7, lr}
 80240f0:	b086      	sub	sp, #24
 80240f2:	af00      	add	r7, sp, #0
 80240f4:	60f8      	str	r0, [r7, #12]
 80240f6:	60b9      	str	r1, [r7, #8]
 80240f8:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 80240fa:	2300      	movs	r3, #0
 80240fc:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80240fe:	68fb      	ldr	r3, [r7, #12]
 8024100:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8024102:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8024104:	68fb      	ldr	r3, [r7, #12]
 8024106:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8024108:	2b00      	cmp	r3, #0
 802410a:	d10d      	bne.n	8024128 <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 802410c:	68fb      	ldr	r3, [r7, #12]
 802410e:	681b      	ldr	r3, [r3, #0]
 8024110:	2b00      	cmp	r3, #0
 8024112:	d14d      	bne.n	80241b0 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8024114:	68fb      	ldr	r3, [r7, #12]
 8024116:	689b      	ldr	r3, [r3, #8]
 8024118:	4618      	mov	r0, r3
 802411a:	f001 f85f 	bl	80251dc <xTaskPriorityDisinherit>
 802411e:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8024120:	68fb      	ldr	r3, [r7, #12]
 8024122:	2200      	movs	r2, #0
 8024124:	609a      	str	r2, [r3, #8]
 8024126:	e043      	b.n	80241b0 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8024128:	687b      	ldr	r3, [r7, #4]
 802412a:	2b00      	cmp	r3, #0
 802412c:	d119      	bne.n	8024162 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 802412e:	68fb      	ldr	r3, [r7, #12]
 8024130:	6858      	ldr	r0, [r3, #4]
 8024132:	68fb      	ldr	r3, [r7, #12]
 8024134:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8024136:	461a      	mov	r2, r3
 8024138:	68b9      	ldr	r1, [r7, #8]
 802413a:	f007 ffd1 	bl	802c0e0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 802413e:	68fb      	ldr	r3, [r7, #12]
 8024140:	685a      	ldr	r2, [r3, #4]
 8024142:	68fb      	ldr	r3, [r7, #12]
 8024144:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8024146:	441a      	add	r2, r3
 8024148:	68fb      	ldr	r3, [r7, #12]
 802414a:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 802414c:	68fb      	ldr	r3, [r7, #12]
 802414e:	685a      	ldr	r2, [r3, #4]
 8024150:	68fb      	ldr	r3, [r7, #12]
 8024152:	689b      	ldr	r3, [r3, #8]
 8024154:	429a      	cmp	r2, r3
 8024156:	d32b      	bcc.n	80241b0 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8024158:	68fb      	ldr	r3, [r7, #12]
 802415a:	681a      	ldr	r2, [r3, #0]
 802415c:	68fb      	ldr	r3, [r7, #12]
 802415e:	605a      	str	r2, [r3, #4]
 8024160:	e026      	b.n	80241b0 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8024162:	68fb      	ldr	r3, [r7, #12]
 8024164:	68d8      	ldr	r0, [r3, #12]
 8024166:	68fb      	ldr	r3, [r7, #12]
 8024168:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802416a:	461a      	mov	r2, r3
 802416c:	68b9      	ldr	r1, [r7, #8]
 802416e:	f007 ffb7 	bl	802c0e0 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8024172:	68fb      	ldr	r3, [r7, #12]
 8024174:	68da      	ldr	r2, [r3, #12]
 8024176:	68fb      	ldr	r3, [r7, #12]
 8024178:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802417a:	425b      	negs	r3, r3
 802417c:	441a      	add	r2, r3
 802417e:	68fb      	ldr	r3, [r7, #12]
 8024180:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8024182:	68fb      	ldr	r3, [r7, #12]
 8024184:	68da      	ldr	r2, [r3, #12]
 8024186:	68fb      	ldr	r3, [r7, #12]
 8024188:	681b      	ldr	r3, [r3, #0]
 802418a:	429a      	cmp	r2, r3
 802418c:	d207      	bcs.n	802419e <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 802418e:	68fb      	ldr	r3, [r7, #12]
 8024190:	689a      	ldr	r2, [r3, #8]
 8024192:	68fb      	ldr	r3, [r7, #12]
 8024194:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8024196:	425b      	negs	r3, r3
 8024198:	441a      	add	r2, r3
 802419a:	68fb      	ldr	r3, [r7, #12]
 802419c:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 802419e:	687b      	ldr	r3, [r7, #4]
 80241a0:	2b02      	cmp	r3, #2
 80241a2:	d105      	bne.n	80241b0 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80241a4:	693b      	ldr	r3, [r7, #16]
 80241a6:	2b00      	cmp	r3, #0
 80241a8:	d002      	beq.n	80241b0 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 80241aa:	693b      	ldr	r3, [r7, #16]
 80241ac:	3b01      	subs	r3, #1
 80241ae:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80241b0:	693b      	ldr	r3, [r7, #16]
 80241b2:	1c5a      	adds	r2, r3, #1
 80241b4:	68fb      	ldr	r3, [r7, #12]
 80241b6:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
 80241b8:	697b      	ldr	r3, [r7, #20]
}
 80241ba:	4618      	mov	r0, r3
 80241bc:	3718      	adds	r7, #24
 80241be:	46bd      	mov	sp, r7
 80241c0:	bd80      	pop	{r7, pc}

080241c2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80241c2:	b580      	push	{r7, lr}
 80241c4:	b082      	sub	sp, #8
 80241c6:	af00      	add	r7, sp, #0
 80241c8:	6078      	str	r0, [r7, #4]
 80241ca:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80241cc:	687b      	ldr	r3, [r7, #4]
 80241ce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80241d0:	2b00      	cmp	r3, #0
 80241d2:	d018      	beq.n	8024206 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80241d4:	687b      	ldr	r3, [r7, #4]
 80241d6:	68da      	ldr	r2, [r3, #12]
 80241d8:	687b      	ldr	r3, [r7, #4]
 80241da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80241dc:	441a      	add	r2, r3
 80241de:	687b      	ldr	r3, [r7, #4]
 80241e0:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80241e2:	687b      	ldr	r3, [r7, #4]
 80241e4:	68da      	ldr	r2, [r3, #12]
 80241e6:	687b      	ldr	r3, [r7, #4]
 80241e8:	689b      	ldr	r3, [r3, #8]
 80241ea:	429a      	cmp	r2, r3
 80241ec:	d303      	bcc.n	80241f6 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 80241ee:	687b      	ldr	r3, [r7, #4]
 80241f0:	681a      	ldr	r2, [r3, #0]
 80241f2:	687b      	ldr	r3, [r7, #4]
 80241f4:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80241f6:	687b      	ldr	r3, [r7, #4]
 80241f8:	68d9      	ldr	r1, [r3, #12]
 80241fa:	687b      	ldr	r3, [r7, #4]
 80241fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80241fe:	461a      	mov	r2, r3
 8024200:	6838      	ldr	r0, [r7, #0]
 8024202:	f007 ff6d 	bl	802c0e0 <memcpy>
	}
}
 8024206:	bf00      	nop
 8024208:	3708      	adds	r7, #8
 802420a:	46bd      	mov	sp, r7
 802420c:	bd80      	pop	{r7, pc}

0802420e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 802420e:	b580      	push	{r7, lr}
 8024210:	b084      	sub	sp, #16
 8024212:	af00      	add	r7, sp, #0
 8024214:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8024216:	f002 f86d 	bl	80262f4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 802421a:	687b      	ldr	r3, [r7, #4]
 802421c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8024220:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8024222:	e011      	b.n	8024248 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8024224:	687b      	ldr	r3, [r7, #4]
 8024226:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024228:	2b00      	cmp	r3, #0
 802422a:	d012      	beq.n	8024252 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802422c:	687b      	ldr	r3, [r7, #4]
 802422e:	3324      	adds	r3, #36	; 0x24
 8024230:	4618      	mov	r0, r3
 8024232:	f000 fd7b 	bl	8024d2c <xTaskRemoveFromEventList>
 8024236:	4603      	mov	r3, r0
 8024238:	2b00      	cmp	r3, #0
 802423a:	d001      	beq.n	8024240 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 802423c:	f000 fe52 	bl	8024ee4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 8024240:	7bfb      	ldrb	r3, [r7, #15]
 8024242:	3b01      	subs	r3, #1
 8024244:	b2db      	uxtb	r3, r3
 8024246:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8024248:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802424c:	2b00      	cmp	r3, #0
 802424e:	dce9      	bgt.n	8024224 <prvUnlockQueue+0x16>
 8024250:	e000      	b.n	8024254 <prvUnlockQueue+0x46>
					break;
 8024252:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8024254:	687b      	ldr	r3, [r7, #4]
 8024256:	22ff      	movs	r2, #255	; 0xff
 8024258:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 802425c:	f002 f87a 	bl	8026354 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8024260:	f002 f848 	bl	80262f4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8024264:	687b      	ldr	r3, [r7, #4]
 8024266:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 802426a:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 802426c:	e011      	b.n	8024292 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 802426e:	687b      	ldr	r3, [r7, #4]
 8024270:	691b      	ldr	r3, [r3, #16]
 8024272:	2b00      	cmp	r3, #0
 8024274:	d012      	beq.n	802429c <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8024276:	687b      	ldr	r3, [r7, #4]
 8024278:	3310      	adds	r3, #16
 802427a:	4618      	mov	r0, r3
 802427c:	f000 fd56 	bl	8024d2c <xTaskRemoveFromEventList>
 8024280:	4603      	mov	r3, r0
 8024282:	2b00      	cmp	r3, #0
 8024284:	d001      	beq.n	802428a <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 8024286:	f000 fe2d 	bl	8024ee4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 802428a:	7bbb      	ldrb	r3, [r7, #14]
 802428c:	3b01      	subs	r3, #1
 802428e:	b2db      	uxtb	r3, r3
 8024290:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8024292:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8024296:	2b00      	cmp	r3, #0
 8024298:	dce9      	bgt.n	802426e <prvUnlockQueue+0x60>
 802429a:	e000      	b.n	802429e <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 802429c:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 802429e:	687b      	ldr	r3, [r7, #4]
 80242a0:	22ff      	movs	r2, #255	; 0xff
 80242a2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80242a6:	f002 f855 	bl	8026354 <vPortExitCritical>
}
 80242aa:	bf00      	nop
 80242ac:	3710      	adds	r7, #16
 80242ae:	46bd      	mov	sp, r7
 80242b0:	bd80      	pop	{r7, pc}

080242b2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 80242b2:	b580      	push	{r7, lr}
 80242b4:	b084      	sub	sp, #16
 80242b6:	af00      	add	r7, sp, #0
 80242b8:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80242ba:	f002 f81b 	bl	80262f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80242be:	687b      	ldr	r3, [r7, #4]
 80242c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80242c2:	2b00      	cmp	r3, #0
 80242c4:	d102      	bne.n	80242cc <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 80242c6:	2301      	movs	r3, #1
 80242c8:	60fb      	str	r3, [r7, #12]
 80242ca:	e001      	b.n	80242d0 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 80242cc:	2300      	movs	r3, #0
 80242ce:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 80242d0:	f002 f840 	bl	8026354 <vPortExitCritical>

	return xReturn;
 80242d4:	68fb      	ldr	r3, [r7, #12]
}
 80242d6:	4618      	mov	r0, r3
 80242d8:	3710      	adds	r7, #16
 80242da:	46bd      	mov	sp, r7
 80242dc:	bd80      	pop	{r7, pc}

080242de <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 80242de:	b580      	push	{r7, lr}
 80242e0:	b084      	sub	sp, #16
 80242e2:	af00      	add	r7, sp, #0
 80242e4:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80242e6:	f002 f805 	bl	80262f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80242ea:	687b      	ldr	r3, [r7, #4]
 80242ec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80242ee:	687b      	ldr	r3, [r7, #4]
 80242f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80242f2:	429a      	cmp	r2, r3
 80242f4:	d102      	bne.n	80242fc <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 80242f6:	2301      	movs	r3, #1
 80242f8:	60fb      	str	r3, [r7, #12]
 80242fa:	e001      	b.n	8024300 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 80242fc:	2300      	movs	r3, #0
 80242fe:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8024300:	f002 f828 	bl	8026354 <vPortExitCritical>

	return xReturn;
 8024304:	68fb      	ldr	r3, [r7, #12]
}
 8024306:	4618      	mov	r0, r3
 8024308:	3710      	adds	r7, #16
 802430a:	46bd      	mov	sp, r7
 802430c:	bd80      	pop	{r7, pc}
	...

08024310 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8024310:	b480      	push	{r7}
 8024312:	b085      	sub	sp, #20
 8024314:	af00      	add	r7, sp, #0
 8024316:	6078      	str	r0, [r7, #4]
 8024318:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802431a:	2300      	movs	r3, #0
 802431c:	60fb      	str	r3, [r7, #12]
 802431e:	e014      	b.n	802434a <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8024320:	4a0f      	ldr	r2, [pc, #60]	; (8024360 <vQueueAddToRegistry+0x50>)
 8024322:	68fb      	ldr	r3, [r7, #12]
 8024324:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8024328:	2b00      	cmp	r3, #0
 802432a:	d10b      	bne.n	8024344 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 802432c:	490c      	ldr	r1, [pc, #48]	; (8024360 <vQueueAddToRegistry+0x50>)
 802432e:	68fb      	ldr	r3, [r7, #12]
 8024330:	683a      	ldr	r2, [r7, #0]
 8024332:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8024336:	4a0a      	ldr	r2, [pc, #40]	; (8024360 <vQueueAddToRegistry+0x50>)
 8024338:	68fb      	ldr	r3, [r7, #12]
 802433a:	00db      	lsls	r3, r3, #3
 802433c:	4413      	add	r3, r2
 802433e:	687a      	ldr	r2, [r7, #4]
 8024340:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 8024342:	e006      	b.n	8024352 <vQueueAddToRegistry+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8024344:	68fb      	ldr	r3, [r7, #12]
 8024346:	3301      	adds	r3, #1
 8024348:	60fb      	str	r3, [r7, #12]
 802434a:	68fb      	ldr	r3, [r7, #12]
 802434c:	2b07      	cmp	r3, #7
 802434e:	d9e7      	bls.n	8024320 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8024350:	bf00      	nop
 8024352:	bf00      	nop
 8024354:	3714      	adds	r7, #20
 8024356:	46bd      	mov	sp, r7
 8024358:	f85d 7b04 	ldr.w	r7, [sp], #4
 802435c:	4770      	bx	lr
 802435e:	bf00      	nop
 8024360:	2001233c 	.word	0x2001233c

08024364 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
 8024364:	b480      	push	{r7}
 8024366:	b085      	sub	sp, #20
 8024368:	af00      	add	r7, sp, #0
 802436a:	6078      	str	r0, [r7, #4]
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802436c:	2300      	movs	r3, #0
 802436e:	60fb      	str	r3, [r7, #12]
 8024370:	e016      	b.n	80243a0 <vQueueUnregisterQueue+0x3c>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8024372:	4a10      	ldr	r2, [pc, #64]	; (80243b4 <vQueueUnregisterQueue+0x50>)
 8024374:	68fb      	ldr	r3, [r7, #12]
 8024376:	00db      	lsls	r3, r3, #3
 8024378:	4413      	add	r3, r2
 802437a:	685b      	ldr	r3, [r3, #4]
 802437c:	687a      	ldr	r2, [r7, #4]
 802437e:	429a      	cmp	r2, r3
 8024380:	d10b      	bne.n	802439a <vQueueUnregisterQueue+0x36>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 8024382:	4a0c      	ldr	r2, [pc, #48]	; (80243b4 <vQueueUnregisterQueue+0x50>)
 8024384:	68fb      	ldr	r3, [r7, #12]
 8024386:	2100      	movs	r1, #0
 8024388:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 802438c:	4a09      	ldr	r2, [pc, #36]	; (80243b4 <vQueueUnregisterQueue+0x50>)
 802438e:	68fb      	ldr	r3, [r7, #12]
 8024390:	00db      	lsls	r3, r3, #3
 8024392:	4413      	add	r3, r2
 8024394:	2200      	movs	r2, #0
 8024396:	605a      	str	r2, [r3, #4]
				break;
 8024398:	e006      	b.n	80243a8 <vQueueUnregisterQueue+0x44>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802439a:	68fb      	ldr	r3, [r7, #12]
 802439c:	3301      	adds	r3, #1
 802439e:	60fb      	str	r3, [r7, #12]
 80243a0:	68fb      	ldr	r3, [r7, #12]
 80243a2:	2b07      	cmp	r3, #7
 80243a4:	d9e5      	bls.n	8024372 <vQueueUnregisterQueue+0xe>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 80243a6:	bf00      	nop
 80243a8:	bf00      	nop
 80243aa:	3714      	adds	r7, #20
 80243ac:	46bd      	mov	sp, r7
 80243ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80243b2:	4770      	bx	lr
 80243b4:	2001233c 	.word	0x2001233c

080243b8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 80243b8:	b580      	push	{r7, lr}
 80243ba:	b086      	sub	sp, #24
 80243bc:	af00      	add	r7, sp, #0
 80243be:	60f8      	str	r0, [r7, #12]
 80243c0:	60b9      	str	r1, [r7, #8]
 80243c2:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
 80243c4:	68fb      	ldr	r3, [r7, #12]
 80243c6:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80243c8:	f001 ff94 	bl	80262f4 <vPortEnterCritical>
 80243cc:	697b      	ldr	r3, [r7, #20]
 80243ce:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 80243d2:	b25b      	sxtb	r3, r3
 80243d4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80243d8:	d103      	bne.n	80243e2 <vQueueWaitForMessageRestricted+0x2a>
 80243da:	697b      	ldr	r3, [r7, #20]
 80243dc:	2200      	movs	r2, #0
 80243de:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80243e2:	697b      	ldr	r3, [r7, #20]
 80243e4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 80243e8:	b25b      	sxtb	r3, r3
 80243ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80243ee:	d103      	bne.n	80243f8 <vQueueWaitForMessageRestricted+0x40>
 80243f0:	697b      	ldr	r3, [r7, #20]
 80243f2:	2200      	movs	r2, #0
 80243f4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 80243f8:	f001 ffac 	bl	8026354 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80243fc:	697b      	ldr	r3, [r7, #20]
 80243fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8024400:	2b00      	cmp	r3, #0
 8024402:	d106      	bne.n	8024412 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8024404:	697b      	ldr	r3, [r7, #20]
 8024406:	3324      	adds	r3, #36	; 0x24
 8024408:	687a      	ldr	r2, [r7, #4]
 802440a:	68b9      	ldr	r1, [r7, #8]
 802440c:	4618      	mov	r0, r3
 802440e:	f000 fc61 	bl	8024cd4 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8024412:	6978      	ldr	r0, [r7, #20]
 8024414:	f7ff fefb 	bl	802420e <prvUnlockQueue>
	}
 8024418:	bf00      	nop
 802441a:	3718      	adds	r7, #24
 802441c:	46bd      	mov	sp, r7
 802441e:	bd80      	pop	{r7, pc}

08024420 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
 8024420:	b580      	push	{r7, lr}
 8024422:	b08e      	sub	sp, #56	; 0x38
 8024424:	af04      	add	r7, sp, #16
 8024426:	60f8      	str	r0, [r7, #12]
 8024428:	60b9      	str	r1, [r7, #8]
 802442a:	607a      	str	r2, [r7, #4]
 802442c:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
 802442e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8024430:	2b00      	cmp	r3, #0
 8024432:	d10a      	bne.n	802444a <xTaskCreateStatic+0x2a>
	__asm volatile
 8024434:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024438:	f383 8811 	msr	BASEPRI, r3
 802443c:	f3bf 8f6f 	isb	sy
 8024440:	f3bf 8f4f 	dsb	sy
 8024444:	623b      	str	r3, [r7, #32]
}
 8024446:	bf00      	nop
 8024448:	e7fe      	b.n	8024448 <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 802444a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802444c:	2b00      	cmp	r3, #0
 802444e:	d10a      	bne.n	8024466 <xTaskCreateStatic+0x46>
	__asm volatile
 8024450:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024454:	f383 8811 	msr	BASEPRI, r3
 8024458:	f3bf 8f6f 	isb	sy
 802445c:	f3bf 8f4f 	dsb	sy
 8024460:	61fb      	str	r3, [r7, #28]
}
 8024462:	bf00      	nop
 8024464:	e7fe      	b.n	8024464 <xTaskCreateStatic+0x44>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
 8024466:	23bc      	movs	r3, #188	; 0xbc
 8024468:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 802446a:	693b      	ldr	r3, [r7, #16]
 802446c:	2bbc      	cmp	r3, #188	; 0xbc
 802446e:	d00a      	beq.n	8024486 <xTaskCreateStatic+0x66>
	__asm volatile
 8024470:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024474:	f383 8811 	msr	BASEPRI, r3
 8024478:	f3bf 8f6f 	isb	sy
 802447c:	f3bf 8f4f 	dsb	sy
 8024480:	61bb      	str	r3, [r7, #24]
}
 8024482:	bf00      	nop
 8024484:	e7fe      	b.n	8024484 <xTaskCreateStatic+0x64>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8024486:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 8024488:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802448a:	2b00      	cmp	r3, #0
 802448c:	d01e      	beq.n	80244cc <xTaskCreateStatic+0xac>
 802448e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8024490:	2b00      	cmp	r3, #0
 8024492:	d01b      	beq.n	80244cc <xTaskCreateStatic+0xac>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 8024494:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8024496:	627b      	str	r3, [r7, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8024498:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802449a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802449c:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 802449e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80244a0:	2202      	movs	r2, #2
 80244a2:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80244a6:	2300      	movs	r3, #0
 80244a8:	9303      	str	r3, [sp, #12]
 80244aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80244ac:	9302      	str	r3, [sp, #8]
 80244ae:	f107 0314 	add.w	r3, r7, #20
 80244b2:	9301      	str	r3, [sp, #4]
 80244b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80244b6:	9300      	str	r3, [sp, #0]
 80244b8:	683b      	ldr	r3, [r7, #0]
 80244ba:	687a      	ldr	r2, [r7, #4]
 80244bc:	68b9      	ldr	r1, [r7, #8]
 80244be:	68f8      	ldr	r0, [r7, #12]
 80244c0:	f000 f850 	bl	8024564 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 80244c4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80244c6:	f000 f8f3 	bl	80246b0 <prvAddNewTaskToReadyList>
 80244ca:	e001      	b.n	80244d0 <xTaskCreateStatic+0xb0>
		}
		else
		{
			xReturn = NULL;
 80244cc:	2300      	movs	r3, #0
 80244ce:	617b      	str	r3, [r7, #20]
		}

		return xReturn;
 80244d0:	697b      	ldr	r3, [r7, #20]
	}
 80244d2:	4618      	mov	r0, r3
 80244d4:	3728      	adds	r7, #40	; 0x28
 80244d6:	46bd      	mov	sp, r7
 80244d8:	bd80      	pop	{r7, pc}

080244da <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 80244da:	b580      	push	{r7, lr}
 80244dc:	b08c      	sub	sp, #48	; 0x30
 80244de:	af04      	add	r7, sp, #16
 80244e0:	60f8      	str	r0, [r7, #12]
 80244e2:	60b9      	str	r1, [r7, #8]
 80244e4:	603b      	str	r3, [r7, #0]
 80244e6:	4613      	mov	r3, r2
 80244e8:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 80244ea:	88fb      	ldrh	r3, [r7, #6]
 80244ec:	009b      	lsls	r3, r3, #2
 80244ee:	4618      	mov	r0, r3
 80244f0:	f002 f822 	bl	8026538 <pvPortMalloc>
 80244f4:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 80244f6:	697b      	ldr	r3, [r7, #20]
 80244f8:	2b00      	cmp	r3, #0
 80244fa:	d00e      	beq.n	802451a <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80244fc:	20bc      	movs	r0, #188	; 0xbc
 80244fe:	f002 f81b 	bl	8026538 <pvPortMalloc>
 8024502:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 8024504:	69fb      	ldr	r3, [r7, #28]
 8024506:	2b00      	cmp	r3, #0
 8024508:	d003      	beq.n	8024512 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 802450a:	69fb      	ldr	r3, [r7, #28]
 802450c:	697a      	ldr	r2, [r7, #20]
 802450e:	631a      	str	r2, [r3, #48]	; 0x30
 8024510:	e005      	b.n	802451e <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 8024512:	6978      	ldr	r0, [r7, #20]
 8024514:	f002 f8dc 	bl	80266d0 <vPortFree>
 8024518:	e001      	b.n	802451e <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 802451a:	2300      	movs	r3, #0
 802451c:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 802451e:	69fb      	ldr	r3, [r7, #28]
 8024520:	2b00      	cmp	r3, #0
 8024522:	d017      	beq.n	8024554 <xTaskCreate+0x7a>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8024524:	69fb      	ldr	r3, [r7, #28]
 8024526:	2200      	movs	r2, #0
 8024528:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 802452c:	88fa      	ldrh	r2, [r7, #6]
 802452e:	2300      	movs	r3, #0
 8024530:	9303      	str	r3, [sp, #12]
 8024532:	69fb      	ldr	r3, [r7, #28]
 8024534:	9302      	str	r3, [sp, #8]
 8024536:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024538:	9301      	str	r3, [sp, #4]
 802453a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802453c:	9300      	str	r3, [sp, #0]
 802453e:	683b      	ldr	r3, [r7, #0]
 8024540:	68b9      	ldr	r1, [r7, #8]
 8024542:	68f8      	ldr	r0, [r7, #12]
 8024544:	f000 f80e 	bl	8024564 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8024548:	69f8      	ldr	r0, [r7, #28]
 802454a:	f000 f8b1 	bl	80246b0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 802454e:	2301      	movs	r3, #1
 8024550:	61bb      	str	r3, [r7, #24]
 8024552:	e002      	b.n	802455a <xTaskCreate+0x80>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8024554:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8024558:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 802455a:	69bb      	ldr	r3, [r7, #24]
	}
 802455c:	4618      	mov	r0, r3
 802455e:	3720      	adds	r7, #32
 8024560:	46bd      	mov	sp, r7
 8024562:	bd80      	pop	{r7, pc}

08024564 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 8024564:	b580      	push	{r7, lr}
 8024566:	b088      	sub	sp, #32
 8024568:	af00      	add	r7, sp, #0
 802456a:	60f8      	str	r0, [r7, #12]
 802456c:	60b9      	str	r1, [r7, #8]
 802456e:	607a      	str	r2, [r7, #4]
 8024570:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8024572:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024574:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8024576:	687b      	ldr	r3, [r7, #4]
 8024578:	009b      	lsls	r3, r3, #2
 802457a:	461a      	mov	r2, r3
 802457c:	21a5      	movs	r1, #165	; 0xa5
 802457e:	f007 fdbd 	bl	802c0fc <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8024582:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024584:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8024586:	687b      	ldr	r3, [r7, #4]
 8024588:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 802458c:	3b01      	subs	r3, #1
 802458e:	009b      	lsls	r3, r3, #2
 8024590:	4413      	add	r3, r2
 8024592:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8024594:	69bb      	ldr	r3, [r7, #24]
 8024596:	f023 0307 	bic.w	r3, r3, #7
 802459a:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 802459c:	69bb      	ldr	r3, [r7, #24]
 802459e:	f003 0307 	and.w	r3, r3, #7
 80245a2:	2b00      	cmp	r3, #0
 80245a4:	d00a      	beq.n	80245bc <prvInitialiseNewTask+0x58>
	__asm volatile
 80245a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80245aa:	f383 8811 	msr	BASEPRI, r3
 80245ae:	f3bf 8f6f 	isb	sy
 80245b2:	f3bf 8f4f 	dsb	sy
 80245b6:	617b      	str	r3, [r7, #20]
}
 80245b8:	bf00      	nop
 80245ba:	e7fe      	b.n	80245ba <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 80245bc:	68bb      	ldr	r3, [r7, #8]
 80245be:	2b00      	cmp	r3, #0
 80245c0:	d01f      	beq.n	8024602 <prvInitialiseNewTask+0x9e>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80245c2:	2300      	movs	r3, #0
 80245c4:	61fb      	str	r3, [r7, #28]
 80245c6:	e012      	b.n	80245ee <prvInitialiseNewTask+0x8a>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80245c8:	68ba      	ldr	r2, [r7, #8]
 80245ca:	69fb      	ldr	r3, [r7, #28]
 80245cc:	4413      	add	r3, r2
 80245ce:	7819      	ldrb	r1, [r3, #0]
 80245d0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80245d2:	69fb      	ldr	r3, [r7, #28]
 80245d4:	4413      	add	r3, r2
 80245d6:	3334      	adds	r3, #52	; 0x34
 80245d8:	460a      	mov	r2, r1
 80245da:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 80245dc:	68ba      	ldr	r2, [r7, #8]
 80245de:	69fb      	ldr	r3, [r7, #28]
 80245e0:	4413      	add	r3, r2
 80245e2:	781b      	ldrb	r3, [r3, #0]
 80245e4:	2b00      	cmp	r3, #0
 80245e6:	d006      	beq.n	80245f6 <prvInitialiseNewTask+0x92>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80245e8:	69fb      	ldr	r3, [r7, #28]
 80245ea:	3301      	adds	r3, #1
 80245ec:	61fb      	str	r3, [r7, #28]
 80245ee:	69fb      	ldr	r3, [r7, #28]
 80245f0:	2b0f      	cmp	r3, #15
 80245f2:	d9e9      	bls.n	80245c8 <prvInitialiseNewTask+0x64>
 80245f4:	e000      	b.n	80245f8 <prvInitialiseNewTask+0x94>
			{
				break;
 80245f6:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80245f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80245fa:	2200      	movs	r2, #0
 80245fc:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 8024600:	e003      	b.n	802460a <prvInitialiseNewTask+0xa6>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8024602:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024604:	2200      	movs	r2, #0
 8024606:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 802460a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802460c:	2b37      	cmp	r3, #55	; 0x37
 802460e:	d901      	bls.n	8024614 <prvInitialiseNewTask+0xb0>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8024610:	2337      	movs	r3, #55	; 0x37
 8024612:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 8024614:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024616:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024618:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 802461a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802461c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802461e:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8024620:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024622:	2200      	movs	r2, #0
 8024624:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8024626:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024628:	3304      	adds	r3, #4
 802462a:	4618      	mov	r0, r3
 802462c:	f7fe fda0 	bl	8023170 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8024630:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024632:	3318      	adds	r3, #24
 8024634:	4618      	mov	r0, r3
 8024636:	f7fe fd9b 	bl	8023170 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 802463a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802463c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802463e:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024640:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024642:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8024646:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024648:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 802464a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802464c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802464e:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 8024650:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024652:	2200      	movs	r2, #0
 8024654:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8024658:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802465a:	2200      	movs	r2, #0
 802465c:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	#if ( configUSE_NEWLIB_REENTRANT == 1 )
	{
		/* Initialise this task's Newlib reent structure.
		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
		for additional information. */
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8024660:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024662:	3354      	adds	r3, #84	; 0x54
 8024664:	2260      	movs	r2, #96	; 0x60
 8024666:	2100      	movs	r1, #0
 8024668:	4618      	mov	r0, r3
 802466a:	f007 fd47 	bl	802c0fc <memset>
 802466e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024670:	4a0c      	ldr	r2, [pc, #48]	; (80246a4 <prvInitialiseNewTask+0x140>)
 8024672:	659a      	str	r2, [r3, #88]	; 0x58
 8024674:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8024676:	4a0c      	ldr	r2, [pc, #48]	; (80246a8 <prvInitialiseNewTask+0x144>)
 8024678:	65da      	str	r2, [r3, #92]	; 0x5c
 802467a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802467c:	4a0b      	ldr	r2, [pc, #44]	; (80246ac <prvInitialiseNewTask+0x148>)
 802467e:	661a      	str	r2, [r3, #96]	; 0x60
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8024680:	683a      	ldr	r2, [r7, #0]
 8024682:	68f9      	ldr	r1, [r7, #12]
 8024684:	69b8      	ldr	r0, [r7, #24]
 8024686:	f001 fd0b 	bl	80260a0 <pxPortInitialiseStack>
 802468a:	4602      	mov	r2, r0
 802468c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802468e:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 8024690:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024692:	2b00      	cmp	r3, #0
 8024694:	d002      	beq.n	802469c <prvInitialiseNewTask+0x138>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8024696:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8024698:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802469a:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 802469c:	bf00      	nop
 802469e:	3720      	adds	r7, #32
 80246a0:	46bd      	mov	sp, r7
 80246a2:	bd80      	pop	{r7, pc}
 80246a4:	0802dd70 	.word	0x0802dd70
 80246a8:	0802dd90 	.word	0x0802dd90
 80246ac:	0802dd50 	.word	0x0802dd50

080246b0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 80246b0:	b580      	push	{r7, lr}
 80246b2:	b082      	sub	sp, #8
 80246b4:	af00      	add	r7, sp, #0
 80246b6:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 80246b8:	f001 fe1c 	bl	80262f4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 80246bc:	4b2d      	ldr	r3, [pc, #180]	; (8024774 <prvAddNewTaskToReadyList+0xc4>)
 80246be:	681b      	ldr	r3, [r3, #0]
 80246c0:	3301      	adds	r3, #1
 80246c2:	4a2c      	ldr	r2, [pc, #176]	; (8024774 <prvAddNewTaskToReadyList+0xc4>)
 80246c4:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 80246c6:	4b2c      	ldr	r3, [pc, #176]	; (8024778 <prvAddNewTaskToReadyList+0xc8>)
 80246c8:	681b      	ldr	r3, [r3, #0]
 80246ca:	2b00      	cmp	r3, #0
 80246cc:	d109      	bne.n	80246e2 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 80246ce:	4a2a      	ldr	r2, [pc, #168]	; (8024778 <prvAddNewTaskToReadyList+0xc8>)
 80246d0:	687b      	ldr	r3, [r7, #4]
 80246d2:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80246d4:	4b27      	ldr	r3, [pc, #156]	; (8024774 <prvAddNewTaskToReadyList+0xc4>)
 80246d6:	681b      	ldr	r3, [r3, #0]
 80246d8:	2b01      	cmp	r3, #1
 80246da:	d110      	bne.n	80246fe <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 80246dc:	f000 fc26 	bl	8024f2c <prvInitialiseTaskLists>
 80246e0:	e00d      	b.n	80246fe <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 80246e2:	4b26      	ldr	r3, [pc, #152]	; (802477c <prvAddNewTaskToReadyList+0xcc>)
 80246e4:	681b      	ldr	r3, [r3, #0]
 80246e6:	2b00      	cmp	r3, #0
 80246e8:	d109      	bne.n	80246fe <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80246ea:	4b23      	ldr	r3, [pc, #140]	; (8024778 <prvAddNewTaskToReadyList+0xc8>)
 80246ec:	681b      	ldr	r3, [r3, #0]
 80246ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80246f0:	687b      	ldr	r3, [r7, #4]
 80246f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80246f4:	429a      	cmp	r2, r3
 80246f6:	d802      	bhi.n	80246fe <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 80246f8:	4a1f      	ldr	r2, [pc, #124]	; (8024778 <prvAddNewTaskToReadyList+0xc8>)
 80246fa:	687b      	ldr	r3, [r7, #4]
 80246fc:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 80246fe:	4b20      	ldr	r3, [pc, #128]	; (8024780 <prvAddNewTaskToReadyList+0xd0>)
 8024700:	681b      	ldr	r3, [r3, #0]
 8024702:	3301      	adds	r3, #1
 8024704:	4a1e      	ldr	r2, [pc, #120]	; (8024780 <prvAddNewTaskToReadyList+0xd0>)
 8024706:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8024708:	4b1d      	ldr	r3, [pc, #116]	; (8024780 <prvAddNewTaskToReadyList+0xd0>)
 802470a:	681a      	ldr	r2, [r3, #0]
 802470c:	687b      	ldr	r3, [r7, #4]
 802470e:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8024710:	687b      	ldr	r3, [r7, #4]
 8024712:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024714:	4b1b      	ldr	r3, [pc, #108]	; (8024784 <prvAddNewTaskToReadyList+0xd4>)
 8024716:	681b      	ldr	r3, [r3, #0]
 8024718:	429a      	cmp	r2, r3
 802471a:	d903      	bls.n	8024724 <prvAddNewTaskToReadyList+0x74>
 802471c:	687b      	ldr	r3, [r7, #4]
 802471e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024720:	4a18      	ldr	r2, [pc, #96]	; (8024784 <prvAddNewTaskToReadyList+0xd4>)
 8024722:	6013      	str	r3, [r2, #0]
 8024724:	687b      	ldr	r3, [r7, #4]
 8024726:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024728:	4613      	mov	r3, r2
 802472a:	009b      	lsls	r3, r3, #2
 802472c:	4413      	add	r3, r2
 802472e:	009b      	lsls	r3, r3, #2
 8024730:	4a15      	ldr	r2, [pc, #84]	; (8024788 <prvAddNewTaskToReadyList+0xd8>)
 8024732:	441a      	add	r2, r3
 8024734:	687b      	ldr	r3, [r7, #4]
 8024736:	3304      	adds	r3, #4
 8024738:	4619      	mov	r1, r3
 802473a:	4610      	mov	r0, r2
 802473c:	f7fe fd25 	bl	802318a <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8024740:	f001 fe08 	bl	8026354 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8024744:	4b0d      	ldr	r3, [pc, #52]	; (802477c <prvAddNewTaskToReadyList+0xcc>)
 8024746:	681b      	ldr	r3, [r3, #0]
 8024748:	2b00      	cmp	r3, #0
 802474a:	d00e      	beq.n	802476a <prvAddNewTaskToReadyList+0xba>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 802474c:	4b0a      	ldr	r3, [pc, #40]	; (8024778 <prvAddNewTaskToReadyList+0xc8>)
 802474e:	681b      	ldr	r3, [r3, #0]
 8024750:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024752:	687b      	ldr	r3, [r7, #4]
 8024754:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024756:	429a      	cmp	r2, r3
 8024758:	d207      	bcs.n	802476a <prvAddNewTaskToReadyList+0xba>
		{
			taskYIELD_IF_USING_PREEMPTION();
 802475a:	4b0c      	ldr	r3, [pc, #48]	; (802478c <prvAddNewTaskToReadyList+0xdc>)
 802475c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024760:	601a      	str	r2, [r3, #0]
 8024762:	f3bf 8f4f 	dsb	sy
 8024766:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 802476a:	bf00      	nop
 802476c:	3708      	adds	r7, #8
 802476e:	46bd      	mov	sp, r7
 8024770:	bd80      	pop	{r7, pc}
 8024772:	bf00      	nop
 8024774:	2000471c 	.word	0x2000471c
 8024778:	20004248 	.word	0x20004248
 802477c:	20004728 	.word	0x20004728
 8024780:	20004738 	.word	0x20004738
 8024784:	20004724 	.word	0x20004724
 8024788:	2000424c 	.word	0x2000424c
 802478c:	e000ed04 	.word	0xe000ed04

08024790 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8024790:	b580      	push	{r7, lr}
 8024792:	b084      	sub	sp, #16
 8024794:	af00      	add	r7, sp, #0
 8024796:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 8024798:	2300      	movs	r3, #0
 802479a:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 802479c:	687b      	ldr	r3, [r7, #4]
 802479e:	2b00      	cmp	r3, #0
 80247a0:	d017      	beq.n	80247d2 <vTaskDelay+0x42>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 80247a2:	4b13      	ldr	r3, [pc, #76]	; (80247f0 <vTaskDelay+0x60>)
 80247a4:	681b      	ldr	r3, [r3, #0]
 80247a6:	2b00      	cmp	r3, #0
 80247a8:	d00a      	beq.n	80247c0 <vTaskDelay+0x30>
	__asm volatile
 80247aa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80247ae:	f383 8811 	msr	BASEPRI, r3
 80247b2:	f3bf 8f6f 	isb	sy
 80247b6:	f3bf 8f4f 	dsb	sy
 80247ba:	60bb      	str	r3, [r7, #8]
}
 80247bc:	bf00      	nop
 80247be:	e7fe      	b.n	80247be <vTaskDelay+0x2e>
			vTaskSuspendAll();
 80247c0:	f000 f88a 	bl	80248d8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80247c4:	2100      	movs	r1, #0
 80247c6:	6878      	ldr	r0, [r7, #4]
 80247c8:	f001 f80e 	bl	80257e8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 80247cc:	f000 f892 	bl	80248f4 <xTaskResumeAll>
 80247d0:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80247d2:	68fb      	ldr	r3, [r7, #12]
 80247d4:	2b00      	cmp	r3, #0
 80247d6:	d107      	bne.n	80247e8 <vTaskDelay+0x58>
		{
			portYIELD_WITHIN_API();
 80247d8:	4b06      	ldr	r3, [pc, #24]	; (80247f4 <vTaskDelay+0x64>)
 80247da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80247de:	601a      	str	r2, [r3, #0]
 80247e0:	f3bf 8f4f 	dsb	sy
 80247e4:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80247e8:	bf00      	nop
 80247ea:	3710      	adds	r7, #16
 80247ec:	46bd      	mov	sp, r7
 80247ee:	bd80      	pop	{r7, pc}
 80247f0:	20004744 	.word	0x20004744
 80247f4:	e000ed04 	.word	0xe000ed04

080247f8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80247f8:	b580      	push	{r7, lr}
 80247fa:	b08a      	sub	sp, #40	; 0x28
 80247fc:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 80247fe:	2300      	movs	r3, #0
 8024800:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8024802:	2300      	movs	r3, #0
 8024804:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8024806:	463a      	mov	r2, r7
 8024808:	1d39      	adds	r1, r7, #4
 802480a:	f107 0308 	add.w	r3, r7, #8
 802480e:	4618      	mov	r0, r3
 8024810:	f7fe fc5a 	bl	80230c8 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8024814:	6839      	ldr	r1, [r7, #0]
 8024816:	687b      	ldr	r3, [r7, #4]
 8024818:	68ba      	ldr	r2, [r7, #8]
 802481a:	9202      	str	r2, [sp, #8]
 802481c:	9301      	str	r3, [sp, #4]
 802481e:	2300      	movs	r3, #0
 8024820:	9300      	str	r3, [sp, #0]
 8024822:	2300      	movs	r3, #0
 8024824:	460a      	mov	r2, r1
 8024826:	4924      	ldr	r1, [pc, #144]	; (80248b8 <vTaskStartScheduler+0xc0>)
 8024828:	4824      	ldr	r0, [pc, #144]	; (80248bc <vTaskStartScheduler+0xc4>)
 802482a:	f7ff fdf9 	bl	8024420 <xTaskCreateStatic>
 802482e:	4603      	mov	r3, r0
 8024830:	4a23      	ldr	r2, [pc, #140]	; (80248c0 <vTaskStartScheduler+0xc8>)
 8024832:	6013      	str	r3, [r2, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
 8024834:	4b22      	ldr	r3, [pc, #136]	; (80248c0 <vTaskStartScheduler+0xc8>)
 8024836:	681b      	ldr	r3, [r3, #0]
 8024838:	2b00      	cmp	r3, #0
 802483a:	d002      	beq.n	8024842 <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
 802483c:	2301      	movs	r3, #1
 802483e:	617b      	str	r3, [r7, #20]
 8024840:	e001      	b.n	8024846 <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
 8024842:	2300      	movs	r3, #0
 8024844:	617b      	str	r3, [r7, #20]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8024846:	697b      	ldr	r3, [r7, #20]
 8024848:	2b01      	cmp	r3, #1
 802484a:	d102      	bne.n	8024852 <vTaskStartScheduler+0x5a>
		{
			xReturn = xTimerCreateTimerTask();
 802484c:	f001 f820 	bl	8025890 <xTimerCreateTimerTask>
 8024850:	6178      	str	r0, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8024852:	697b      	ldr	r3, [r7, #20]
 8024854:	2b01      	cmp	r3, #1
 8024856:	d11b      	bne.n	8024890 <vTaskStartScheduler+0x98>
	__asm volatile
 8024858:	f04f 0350 	mov.w	r3, #80	; 0x50
 802485c:	f383 8811 	msr	BASEPRI, r3
 8024860:	f3bf 8f6f 	isb	sy
 8024864:	f3bf 8f4f 	dsb	sy
 8024868:	613b      	str	r3, [r7, #16]
}
 802486a:	bf00      	nop
		{
			/* Switch Newlib's _impure_ptr variable to point to the _reent
			structure specific to the task that will run first.
			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 802486c:	4b15      	ldr	r3, [pc, #84]	; (80248c4 <vTaskStartScheduler+0xcc>)
 802486e:	681b      	ldr	r3, [r3, #0]
 8024870:	3354      	adds	r3, #84	; 0x54
 8024872:	4a15      	ldr	r2, [pc, #84]	; (80248c8 <vTaskStartScheduler+0xd0>)
 8024874:	6013      	str	r3, [r2, #0]
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 8024876:	4b15      	ldr	r3, [pc, #84]	; (80248cc <vTaskStartScheduler+0xd4>)
 8024878:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 802487c:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 802487e:	4b14      	ldr	r3, [pc, #80]	; (80248d0 <vTaskStartScheduler+0xd8>)
 8024880:	2201      	movs	r2, #1
 8024882:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8024884:	4b13      	ldr	r3, [pc, #76]	; (80248d4 <vTaskStartScheduler+0xdc>)
 8024886:	2200      	movs	r2, #0
 8024888:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 802488a:	f001 fc91 	bl	80261b0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 802488e:	e00e      	b.n	80248ae <vTaskStartScheduler+0xb6>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8024890:	697b      	ldr	r3, [r7, #20]
 8024892:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8024896:	d10a      	bne.n	80248ae <vTaskStartScheduler+0xb6>
	__asm volatile
 8024898:	f04f 0350 	mov.w	r3, #80	; 0x50
 802489c:	f383 8811 	msr	BASEPRI, r3
 80248a0:	f3bf 8f6f 	isb	sy
 80248a4:	f3bf 8f4f 	dsb	sy
 80248a8:	60fb      	str	r3, [r7, #12]
}
 80248aa:	bf00      	nop
 80248ac:	e7fe      	b.n	80248ac <vTaskStartScheduler+0xb4>
}
 80248ae:	bf00      	nop
 80248b0:	3718      	adds	r7, #24
 80248b2:	46bd      	mov	sp, r7
 80248b4:	bd80      	pop	{r7, pc}
 80248b6:	bf00      	nop
 80248b8:	0802c648 	.word	0x0802c648
 80248bc:	08024efd 	.word	0x08024efd
 80248c0:	20004740 	.word	0x20004740
 80248c4:	20004248 	.word	0x20004248
 80248c8:	200001b4 	.word	0x200001b4
 80248cc:	2000473c 	.word	0x2000473c
 80248d0:	20004728 	.word	0x20004728
 80248d4:	20004720 	.word	0x20004720

080248d8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 80248d8:	b480      	push	{r7}
 80248da:	af00      	add	r7, sp, #0
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 80248dc:	4b04      	ldr	r3, [pc, #16]	; (80248f0 <vTaskSuspendAll+0x18>)
 80248de:	681b      	ldr	r3, [r3, #0]
 80248e0:	3301      	adds	r3, #1
 80248e2:	4a03      	ldr	r2, [pc, #12]	; (80248f0 <vTaskSuspendAll+0x18>)
 80248e4:	6013      	str	r3, [r2, #0]

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 80248e6:	bf00      	nop
 80248e8:	46bd      	mov	sp, r7
 80248ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80248ee:	4770      	bx	lr
 80248f0:	20004744 	.word	0x20004744

080248f4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 80248f4:	b580      	push	{r7, lr}
 80248f6:	b084      	sub	sp, #16
 80248f8:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 80248fa:	2300      	movs	r3, #0
 80248fc:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 80248fe:	2300      	movs	r3, #0
 8024900:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8024902:	4b42      	ldr	r3, [pc, #264]	; (8024a0c <xTaskResumeAll+0x118>)
 8024904:	681b      	ldr	r3, [r3, #0]
 8024906:	2b00      	cmp	r3, #0
 8024908:	d10a      	bne.n	8024920 <xTaskResumeAll+0x2c>
	__asm volatile
 802490a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802490e:	f383 8811 	msr	BASEPRI, r3
 8024912:	f3bf 8f6f 	isb	sy
 8024916:	f3bf 8f4f 	dsb	sy
 802491a:	603b      	str	r3, [r7, #0]
}
 802491c:	bf00      	nop
 802491e:	e7fe      	b.n	802491e <xTaskResumeAll+0x2a>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8024920:	f001 fce8 	bl	80262f4 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8024924:	4b39      	ldr	r3, [pc, #228]	; (8024a0c <xTaskResumeAll+0x118>)
 8024926:	681b      	ldr	r3, [r3, #0]
 8024928:	3b01      	subs	r3, #1
 802492a:	4a38      	ldr	r2, [pc, #224]	; (8024a0c <xTaskResumeAll+0x118>)
 802492c:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 802492e:	4b37      	ldr	r3, [pc, #220]	; (8024a0c <xTaskResumeAll+0x118>)
 8024930:	681b      	ldr	r3, [r3, #0]
 8024932:	2b00      	cmp	r3, #0
 8024934:	d162      	bne.n	80249fc <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8024936:	4b36      	ldr	r3, [pc, #216]	; (8024a10 <xTaskResumeAll+0x11c>)
 8024938:	681b      	ldr	r3, [r3, #0]
 802493a:	2b00      	cmp	r3, #0
 802493c:	d05e      	beq.n	80249fc <xTaskResumeAll+0x108>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 802493e:	e02f      	b.n	80249a0 <xTaskResumeAll+0xac>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024940:	4b34      	ldr	r3, [pc, #208]	; (8024a14 <xTaskResumeAll+0x120>)
 8024942:	68db      	ldr	r3, [r3, #12]
 8024944:	68db      	ldr	r3, [r3, #12]
 8024946:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8024948:	68fb      	ldr	r3, [r7, #12]
 802494a:	3318      	adds	r3, #24
 802494c:	4618      	mov	r0, r3
 802494e:	f7fe fc79 	bl	8023244 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8024952:	68fb      	ldr	r3, [r7, #12]
 8024954:	3304      	adds	r3, #4
 8024956:	4618      	mov	r0, r3
 8024958:	f7fe fc74 	bl	8023244 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 802495c:	68fb      	ldr	r3, [r7, #12]
 802495e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024960:	4b2d      	ldr	r3, [pc, #180]	; (8024a18 <xTaskResumeAll+0x124>)
 8024962:	681b      	ldr	r3, [r3, #0]
 8024964:	429a      	cmp	r2, r3
 8024966:	d903      	bls.n	8024970 <xTaskResumeAll+0x7c>
 8024968:	68fb      	ldr	r3, [r7, #12]
 802496a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802496c:	4a2a      	ldr	r2, [pc, #168]	; (8024a18 <xTaskResumeAll+0x124>)
 802496e:	6013      	str	r3, [r2, #0]
 8024970:	68fb      	ldr	r3, [r7, #12]
 8024972:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024974:	4613      	mov	r3, r2
 8024976:	009b      	lsls	r3, r3, #2
 8024978:	4413      	add	r3, r2
 802497a:	009b      	lsls	r3, r3, #2
 802497c:	4a27      	ldr	r2, [pc, #156]	; (8024a1c <xTaskResumeAll+0x128>)
 802497e:	441a      	add	r2, r3
 8024980:	68fb      	ldr	r3, [r7, #12]
 8024982:	3304      	adds	r3, #4
 8024984:	4619      	mov	r1, r3
 8024986:	4610      	mov	r0, r2
 8024988:	f7fe fbff 	bl	802318a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 802498c:	68fb      	ldr	r3, [r7, #12]
 802498e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024990:	4b23      	ldr	r3, [pc, #140]	; (8024a20 <xTaskResumeAll+0x12c>)
 8024992:	681b      	ldr	r3, [r3, #0]
 8024994:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024996:	429a      	cmp	r2, r3
 8024998:	d302      	bcc.n	80249a0 <xTaskResumeAll+0xac>
					{
						xYieldPending = pdTRUE;
 802499a:	4b22      	ldr	r3, [pc, #136]	; (8024a24 <xTaskResumeAll+0x130>)
 802499c:	2201      	movs	r2, #1
 802499e:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80249a0:	4b1c      	ldr	r3, [pc, #112]	; (8024a14 <xTaskResumeAll+0x120>)
 80249a2:	681b      	ldr	r3, [r3, #0]
 80249a4:	2b00      	cmp	r3, #0
 80249a6:	d1cb      	bne.n	8024940 <xTaskResumeAll+0x4c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 80249a8:	68fb      	ldr	r3, [r7, #12]
 80249aa:	2b00      	cmp	r3, #0
 80249ac:	d001      	beq.n	80249b2 <xTaskResumeAll+0xbe>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 80249ae:	f000 fb5f 	bl	8025070 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 80249b2:	4b1d      	ldr	r3, [pc, #116]	; (8024a28 <xTaskResumeAll+0x134>)
 80249b4:	681b      	ldr	r3, [r3, #0]
 80249b6:	607b      	str	r3, [r7, #4]

					if( xPendedCounts > ( TickType_t ) 0U )
 80249b8:	687b      	ldr	r3, [r7, #4]
 80249ba:	2b00      	cmp	r3, #0
 80249bc:	d010      	beq.n	80249e0 <xTaskResumeAll+0xec>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 80249be:	f000 f847 	bl	8024a50 <xTaskIncrementTick>
 80249c2:	4603      	mov	r3, r0
 80249c4:	2b00      	cmp	r3, #0
 80249c6:	d002      	beq.n	80249ce <xTaskResumeAll+0xda>
							{
								xYieldPending = pdTRUE;
 80249c8:	4b16      	ldr	r3, [pc, #88]	; (8024a24 <xTaskResumeAll+0x130>)
 80249ca:	2201      	movs	r2, #1
 80249cc:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 80249ce:	687b      	ldr	r3, [r7, #4]
 80249d0:	3b01      	subs	r3, #1
 80249d2:	607b      	str	r3, [r7, #4]
						} while( xPendedCounts > ( TickType_t ) 0U );
 80249d4:	687b      	ldr	r3, [r7, #4]
 80249d6:	2b00      	cmp	r3, #0
 80249d8:	d1f1      	bne.n	80249be <xTaskResumeAll+0xca>

						xPendedTicks = 0;
 80249da:	4b13      	ldr	r3, [pc, #76]	; (8024a28 <xTaskResumeAll+0x134>)
 80249dc:	2200      	movs	r2, #0
 80249de:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 80249e0:	4b10      	ldr	r3, [pc, #64]	; (8024a24 <xTaskResumeAll+0x130>)
 80249e2:	681b      	ldr	r3, [r3, #0]
 80249e4:	2b00      	cmp	r3, #0
 80249e6:	d009      	beq.n	80249fc <xTaskResumeAll+0x108>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 80249e8:	2301      	movs	r3, #1
 80249ea:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 80249ec:	4b0f      	ldr	r3, [pc, #60]	; (8024a2c <xTaskResumeAll+0x138>)
 80249ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80249f2:	601a      	str	r2, [r3, #0]
 80249f4:	f3bf 8f4f 	dsb	sy
 80249f8:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 80249fc:	f001 fcaa 	bl	8026354 <vPortExitCritical>

	return xAlreadyYielded;
 8024a00:	68bb      	ldr	r3, [r7, #8]
}
 8024a02:	4618      	mov	r0, r3
 8024a04:	3710      	adds	r7, #16
 8024a06:	46bd      	mov	sp, r7
 8024a08:	bd80      	pop	{r7, pc}
 8024a0a:	bf00      	nop
 8024a0c:	20004744 	.word	0x20004744
 8024a10:	2000471c 	.word	0x2000471c
 8024a14:	200046dc 	.word	0x200046dc
 8024a18:	20004724 	.word	0x20004724
 8024a1c:	2000424c 	.word	0x2000424c
 8024a20:	20004248 	.word	0x20004248
 8024a24:	20004730 	.word	0x20004730
 8024a28:	2000472c 	.word	0x2000472c
 8024a2c:	e000ed04 	.word	0xe000ed04

08024a30 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 8024a30:	b480      	push	{r7}
 8024a32:	b083      	sub	sp, #12
 8024a34:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 8024a36:	4b05      	ldr	r3, [pc, #20]	; (8024a4c <xTaskGetTickCount+0x1c>)
 8024a38:	681b      	ldr	r3, [r3, #0]
 8024a3a:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 8024a3c:	687b      	ldr	r3, [r7, #4]
}
 8024a3e:	4618      	mov	r0, r3
 8024a40:	370c      	adds	r7, #12
 8024a42:	46bd      	mov	sp, r7
 8024a44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024a48:	4770      	bx	lr
 8024a4a:	bf00      	nop
 8024a4c:	20004720 	.word	0x20004720

08024a50 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8024a50:	b580      	push	{r7, lr}
 8024a52:	b086      	sub	sp, #24
 8024a54:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8024a56:	2300      	movs	r3, #0
 8024a58:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8024a5a:	4b4f      	ldr	r3, [pc, #316]	; (8024b98 <xTaskIncrementTick+0x148>)
 8024a5c:	681b      	ldr	r3, [r3, #0]
 8024a5e:	2b00      	cmp	r3, #0
 8024a60:	f040 808f 	bne.w	8024b82 <xTaskIncrementTick+0x132>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8024a64:	4b4d      	ldr	r3, [pc, #308]	; (8024b9c <xTaskIncrementTick+0x14c>)
 8024a66:	681b      	ldr	r3, [r3, #0]
 8024a68:	3301      	adds	r3, #1
 8024a6a:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8024a6c:	4a4b      	ldr	r2, [pc, #300]	; (8024b9c <xTaskIncrementTick+0x14c>)
 8024a6e:	693b      	ldr	r3, [r7, #16]
 8024a70:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8024a72:	693b      	ldr	r3, [r7, #16]
 8024a74:	2b00      	cmp	r3, #0
 8024a76:	d120      	bne.n	8024aba <xTaskIncrementTick+0x6a>
		{
			taskSWITCH_DELAYED_LISTS();
 8024a78:	4b49      	ldr	r3, [pc, #292]	; (8024ba0 <xTaskIncrementTick+0x150>)
 8024a7a:	681b      	ldr	r3, [r3, #0]
 8024a7c:	681b      	ldr	r3, [r3, #0]
 8024a7e:	2b00      	cmp	r3, #0
 8024a80:	d00a      	beq.n	8024a98 <xTaskIncrementTick+0x48>
	__asm volatile
 8024a82:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024a86:	f383 8811 	msr	BASEPRI, r3
 8024a8a:	f3bf 8f6f 	isb	sy
 8024a8e:	f3bf 8f4f 	dsb	sy
 8024a92:	603b      	str	r3, [r7, #0]
}
 8024a94:	bf00      	nop
 8024a96:	e7fe      	b.n	8024a96 <xTaskIncrementTick+0x46>
 8024a98:	4b41      	ldr	r3, [pc, #260]	; (8024ba0 <xTaskIncrementTick+0x150>)
 8024a9a:	681b      	ldr	r3, [r3, #0]
 8024a9c:	60fb      	str	r3, [r7, #12]
 8024a9e:	4b41      	ldr	r3, [pc, #260]	; (8024ba4 <xTaskIncrementTick+0x154>)
 8024aa0:	681b      	ldr	r3, [r3, #0]
 8024aa2:	4a3f      	ldr	r2, [pc, #252]	; (8024ba0 <xTaskIncrementTick+0x150>)
 8024aa4:	6013      	str	r3, [r2, #0]
 8024aa6:	4a3f      	ldr	r2, [pc, #252]	; (8024ba4 <xTaskIncrementTick+0x154>)
 8024aa8:	68fb      	ldr	r3, [r7, #12]
 8024aaa:	6013      	str	r3, [r2, #0]
 8024aac:	4b3e      	ldr	r3, [pc, #248]	; (8024ba8 <xTaskIncrementTick+0x158>)
 8024aae:	681b      	ldr	r3, [r3, #0]
 8024ab0:	3301      	adds	r3, #1
 8024ab2:	4a3d      	ldr	r2, [pc, #244]	; (8024ba8 <xTaskIncrementTick+0x158>)
 8024ab4:	6013      	str	r3, [r2, #0]
 8024ab6:	f000 fadb 	bl	8025070 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 8024aba:	4b3c      	ldr	r3, [pc, #240]	; (8024bac <xTaskIncrementTick+0x15c>)
 8024abc:	681b      	ldr	r3, [r3, #0]
 8024abe:	693a      	ldr	r2, [r7, #16]
 8024ac0:	429a      	cmp	r2, r3
 8024ac2:	d349      	bcc.n	8024b58 <xTaskIncrementTick+0x108>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8024ac4:	4b36      	ldr	r3, [pc, #216]	; (8024ba0 <xTaskIncrementTick+0x150>)
 8024ac6:	681b      	ldr	r3, [r3, #0]
 8024ac8:	681b      	ldr	r3, [r3, #0]
 8024aca:	2b00      	cmp	r3, #0
 8024acc:	d104      	bne.n	8024ad8 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024ace:	4b37      	ldr	r3, [pc, #220]	; (8024bac <xTaskIncrementTick+0x15c>)
 8024ad0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8024ad4:	601a      	str	r2, [r3, #0]
					break;
 8024ad6:	e03f      	b.n	8024b58 <xTaskIncrementTick+0x108>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024ad8:	4b31      	ldr	r3, [pc, #196]	; (8024ba0 <xTaskIncrementTick+0x150>)
 8024ada:	681b      	ldr	r3, [r3, #0]
 8024adc:	68db      	ldr	r3, [r3, #12]
 8024ade:	68db      	ldr	r3, [r3, #12]
 8024ae0:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8024ae2:	68bb      	ldr	r3, [r7, #8]
 8024ae4:	685b      	ldr	r3, [r3, #4]
 8024ae6:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 8024ae8:	693a      	ldr	r2, [r7, #16]
 8024aea:	687b      	ldr	r3, [r7, #4]
 8024aec:	429a      	cmp	r2, r3
 8024aee:	d203      	bcs.n	8024af8 <xTaskIncrementTick+0xa8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 8024af0:	4a2e      	ldr	r2, [pc, #184]	; (8024bac <xTaskIncrementTick+0x15c>)
 8024af2:	687b      	ldr	r3, [r7, #4]
 8024af4:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8024af6:	e02f      	b.n	8024b58 <xTaskIncrementTick+0x108>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8024af8:	68bb      	ldr	r3, [r7, #8]
 8024afa:	3304      	adds	r3, #4
 8024afc:	4618      	mov	r0, r3
 8024afe:	f7fe fba1 	bl	8023244 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8024b02:	68bb      	ldr	r3, [r7, #8]
 8024b04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8024b06:	2b00      	cmp	r3, #0
 8024b08:	d004      	beq.n	8024b14 <xTaskIncrementTick+0xc4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8024b0a:	68bb      	ldr	r3, [r7, #8]
 8024b0c:	3318      	adds	r3, #24
 8024b0e:	4618      	mov	r0, r3
 8024b10:	f7fe fb98 	bl	8023244 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 8024b14:	68bb      	ldr	r3, [r7, #8]
 8024b16:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024b18:	4b25      	ldr	r3, [pc, #148]	; (8024bb0 <xTaskIncrementTick+0x160>)
 8024b1a:	681b      	ldr	r3, [r3, #0]
 8024b1c:	429a      	cmp	r2, r3
 8024b1e:	d903      	bls.n	8024b28 <xTaskIncrementTick+0xd8>
 8024b20:	68bb      	ldr	r3, [r7, #8]
 8024b22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024b24:	4a22      	ldr	r2, [pc, #136]	; (8024bb0 <xTaskIncrementTick+0x160>)
 8024b26:	6013      	str	r3, [r2, #0]
 8024b28:	68bb      	ldr	r3, [r7, #8]
 8024b2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024b2c:	4613      	mov	r3, r2
 8024b2e:	009b      	lsls	r3, r3, #2
 8024b30:	4413      	add	r3, r2
 8024b32:	009b      	lsls	r3, r3, #2
 8024b34:	4a1f      	ldr	r2, [pc, #124]	; (8024bb4 <xTaskIncrementTick+0x164>)
 8024b36:	441a      	add	r2, r3
 8024b38:	68bb      	ldr	r3, [r7, #8]
 8024b3a:	3304      	adds	r3, #4
 8024b3c:	4619      	mov	r1, r3
 8024b3e:	4610      	mov	r0, r2
 8024b40:	f7fe fb23 	bl	802318a <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8024b44:	68bb      	ldr	r3, [r7, #8]
 8024b46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024b48:	4b1b      	ldr	r3, [pc, #108]	; (8024bb8 <xTaskIncrementTick+0x168>)
 8024b4a:	681b      	ldr	r3, [r3, #0]
 8024b4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024b4e:	429a      	cmp	r2, r3
 8024b50:	d3b8      	bcc.n	8024ac4 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
 8024b52:	2301      	movs	r3, #1
 8024b54:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8024b56:	e7b5      	b.n	8024ac4 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8024b58:	4b17      	ldr	r3, [pc, #92]	; (8024bb8 <xTaskIncrementTick+0x168>)
 8024b5a:	681b      	ldr	r3, [r3, #0]
 8024b5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024b5e:	4915      	ldr	r1, [pc, #84]	; (8024bb4 <xTaskIncrementTick+0x164>)
 8024b60:	4613      	mov	r3, r2
 8024b62:	009b      	lsls	r3, r3, #2
 8024b64:	4413      	add	r3, r2
 8024b66:	009b      	lsls	r3, r3, #2
 8024b68:	440b      	add	r3, r1
 8024b6a:	681b      	ldr	r3, [r3, #0]
 8024b6c:	2b01      	cmp	r3, #1
 8024b6e:	d901      	bls.n	8024b74 <xTaskIncrementTick+0x124>
			{
				xSwitchRequired = pdTRUE;
 8024b70:	2301      	movs	r3, #1
 8024b72:	617b      	str	r3, [r7, #20]
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 8024b74:	4b11      	ldr	r3, [pc, #68]	; (8024bbc <xTaskIncrementTick+0x16c>)
 8024b76:	681b      	ldr	r3, [r3, #0]
 8024b78:	2b00      	cmp	r3, #0
 8024b7a:	d007      	beq.n	8024b8c <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
 8024b7c:	2301      	movs	r3, #1
 8024b7e:	617b      	str	r3, [r7, #20]
 8024b80:	e004      	b.n	8024b8c <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 8024b82:	4b0f      	ldr	r3, [pc, #60]	; (8024bc0 <xTaskIncrementTick+0x170>)
 8024b84:	681b      	ldr	r3, [r3, #0]
 8024b86:	3301      	adds	r3, #1
 8024b88:	4a0d      	ldr	r2, [pc, #52]	; (8024bc0 <xTaskIncrementTick+0x170>)
 8024b8a:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 8024b8c:	697b      	ldr	r3, [r7, #20]
}
 8024b8e:	4618      	mov	r0, r3
 8024b90:	3718      	adds	r7, #24
 8024b92:	46bd      	mov	sp, r7
 8024b94:	bd80      	pop	{r7, pc}
 8024b96:	bf00      	nop
 8024b98:	20004744 	.word	0x20004744
 8024b9c:	20004720 	.word	0x20004720
 8024ba0:	200046d4 	.word	0x200046d4
 8024ba4:	200046d8 	.word	0x200046d8
 8024ba8:	20004734 	.word	0x20004734
 8024bac:	2000473c 	.word	0x2000473c
 8024bb0:	20004724 	.word	0x20004724
 8024bb4:	2000424c 	.word	0x2000424c
 8024bb8:	20004248 	.word	0x20004248
 8024bbc:	20004730 	.word	0x20004730
 8024bc0:	2000472c 	.word	0x2000472c

08024bc4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8024bc4:	b480      	push	{r7}
 8024bc6:	b085      	sub	sp, #20
 8024bc8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8024bca:	4b2a      	ldr	r3, [pc, #168]	; (8024c74 <vTaskSwitchContext+0xb0>)
 8024bcc:	681b      	ldr	r3, [r3, #0]
 8024bce:	2b00      	cmp	r3, #0
 8024bd0:	d003      	beq.n	8024bda <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8024bd2:	4b29      	ldr	r3, [pc, #164]	; (8024c78 <vTaskSwitchContext+0xb4>)
 8024bd4:	2201      	movs	r2, #1
 8024bd6:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 8024bd8:	e046      	b.n	8024c68 <vTaskSwitchContext+0xa4>
		xYieldPending = pdFALSE;
 8024bda:	4b27      	ldr	r3, [pc, #156]	; (8024c78 <vTaskSwitchContext+0xb4>)
 8024bdc:	2200      	movs	r2, #0
 8024bde:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024be0:	4b26      	ldr	r3, [pc, #152]	; (8024c7c <vTaskSwitchContext+0xb8>)
 8024be2:	681b      	ldr	r3, [r3, #0]
 8024be4:	60fb      	str	r3, [r7, #12]
 8024be6:	e010      	b.n	8024c0a <vTaskSwitchContext+0x46>
 8024be8:	68fb      	ldr	r3, [r7, #12]
 8024bea:	2b00      	cmp	r3, #0
 8024bec:	d10a      	bne.n	8024c04 <vTaskSwitchContext+0x40>
	__asm volatile
 8024bee:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024bf2:	f383 8811 	msr	BASEPRI, r3
 8024bf6:	f3bf 8f6f 	isb	sy
 8024bfa:	f3bf 8f4f 	dsb	sy
 8024bfe:	607b      	str	r3, [r7, #4]
}
 8024c00:	bf00      	nop
 8024c02:	e7fe      	b.n	8024c02 <vTaskSwitchContext+0x3e>
 8024c04:	68fb      	ldr	r3, [r7, #12]
 8024c06:	3b01      	subs	r3, #1
 8024c08:	60fb      	str	r3, [r7, #12]
 8024c0a:	491d      	ldr	r1, [pc, #116]	; (8024c80 <vTaskSwitchContext+0xbc>)
 8024c0c:	68fa      	ldr	r2, [r7, #12]
 8024c0e:	4613      	mov	r3, r2
 8024c10:	009b      	lsls	r3, r3, #2
 8024c12:	4413      	add	r3, r2
 8024c14:	009b      	lsls	r3, r3, #2
 8024c16:	440b      	add	r3, r1
 8024c18:	681b      	ldr	r3, [r3, #0]
 8024c1a:	2b00      	cmp	r3, #0
 8024c1c:	d0e4      	beq.n	8024be8 <vTaskSwitchContext+0x24>
 8024c1e:	68fa      	ldr	r2, [r7, #12]
 8024c20:	4613      	mov	r3, r2
 8024c22:	009b      	lsls	r3, r3, #2
 8024c24:	4413      	add	r3, r2
 8024c26:	009b      	lsls	r3, r3, #2
 8024c28:	4a15      	ldr	r2, [pc, #84]	; (8024c80 <vTaskSwitchContext+0xbc>)
 8024c2a:	4413      	add	r3, r2
 8024c2c:	60bb      	str	r3, [r7, #8]
 8024c2e:	68bb      	ldr	r3, [r7, #8]
 8024c30:	685b      	ldr	r3, [r3, #4]
 8024c32:	685a      	ldr	r2, [r3, #4]
 8024c34:	68bb      	ldr	r3, [r7, #8]
 8024c36:	605a      	str	r2, [r3, #4]
 8024c38:	68bb      	ldr	r3, [r7, #8]
 8024c3a:	685a      	ldr	r2, [r3, #4]
 8024c3c:	68bb      	ldr	r3, [r7, #8]
 8024c3e:	3308      	adds	r3, #8
 8024c40:	429a      	cmp	r2, r3
 8024c42:	d104      	bne.n	8024c4e <vTaskSwitchContext+0x8a>
 8024c44:	68bb      	ldr	r3, [r7, #8]
 8024c46:	685b      	ldr	r3, [r3, #4]
 8024c48:	685a      	ldr	r2, [r3, #4]
 8024c4a:	68bb      	ldr	r3, [r7, #8]
 8024c4c:	605a      	str	r2, [r3, #4]
 8024c4e:	68bb      	ldr	r3, [r7, #8]
 8024c50:	685b      	ldr	r3, [r3, #4]
 8024c52:	68db      	ldr	r3, [r3, #12]
 8024c54:	4a0b      	ldr	r2, [pc, #44]	; (8024c84 <vTaskSwitchContext+0xc0>)
 8024c56:	6013      	str	r3, [r2, #0]
 8024c58:	4a08      	ldr	r2, [pc, #32]	; (8024c7c <vTaskSwitchContext+0xb8>)
 8024c5a:	68fb      	ldr	r3, [r7, #12]
 8024c5c:	6013      	str	r3, [r2, #0]
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8024c5e:	4b09      	ldr	r3, [pc, #36]	; (8024c84 <vTaskSwitchContext+0xc0>)
 8024c60:	681b      	ldr	r3, [r3, #0]
 8024c62:	3354      	adds	r3, #84	; 0x54
 8024c64:	4a08      	ldr	r2, [pc, #32]	; (8024c88 <vTaskSwitchContext+0xc4>)
 8024c66:	6013      	str	r3, [r2, #0]
}
 8024c68:	bf00      	nop
 8024c6a:	3714      	adds	r7, #20
 8024c6c:	46bd      	mov	sp, r7
 8024c6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024c72:	4770      	bx	lr
 8024c74:	20004744 	.word	0x20004744
 8024c78:	20004730 	.word	0x20004730
 8024c7c:	20004724 	.word	0x20004724
 8024c80:	2000424c 	.word	0x2000424c
 8024c84:	20004248 	.word	0x20004248
 8024c88:	200001b4 	.word	0x200001b4

08024c8c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8024c8c:	b580      	push	{r7, lr}
 8024c8e:	b084      	sub	sp, #16
 8024c90:	af00      	add	r7, sp, #0
 8024c92:	6078      	str	r0, [r7, #4]
 8024c94:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 8024c96:	687b      	ldr	r3, [r7, #4]
 8024c98:	2b00      	cmp	r3, #0
 8024c9a:	d10a      	bne.n	8024cb2 <vTaskPlaceOnEventList+0x26>
	__asm volatile
 8024c9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024ca0:	f383 8811 	msr	BASEPRI, r3
 8024ca4:	f3bf 8f6f 	isb	sy
 8024ca8:	f3bf 8f4f 	dsb	sy
 8024cac:	60fb      	str	r3, [r7, #12]
}
 8024cae:	bf00      	nop
 8024cb0:	e7fe      	b.n	8024cb0 <vTaskPlaceOnEventList+0x24>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8024cb2:	4b07      	ldr	r3, [pc, #28]	; (8024cd0 <vTaskPlaceOnEventList+0x44>)
 8024cb4:	681b      	ldr	r3, [r3, #0]
 8024cb6:	3318      	adds	r3, #24
 8024cb8:	4619      	mov	r1, r3
 8024cba:	6878      	ldr	r0, [r7, #4]
 8024cbc:	f7fe fa89 	bl	80231d2 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8024cc0:	2101      	movs	r1, #1
 8024cc2:	6838      	ldr	r0, [r7, #0]
 8024cc4:	f000 fd90 	bl	80257e8 <prvAddCurrentTaskToDelayedList>
}
 8024cc8:	bf00      	nop
 8024cca:	3710      	adds	r7, #16
 8024ccc:	46bd      	mov	sp, r7
 8024cce:	bd80      	pop	{r7, pc}
 8024cd0:	20004248 	.word	0x20004248

08024cd4 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8024cd4:	b580      	push	{r7, lr}
 8024cd6:	b086      	sub	sp, #24
 8024cd8:	af00      	add	r7, sp, #0
 8024cda:	60f8      	str	r0, [r7, #12]
 8024cdc:	60b9      	str	r1, [r7, #8]
 8024cde:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 8024ce0:	68fb      	ldr	r3, [r7, #12]
 8024ce2:	2b00      	cmp	r3, #0
 8024ce4:	d10a      	bne.n	8024cfc <vTaskPlaceOnEventListRestricted+0x28>
	__asm volatile
 8024ce6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024cea:	f383 8811 	msr	BASEPRI, r3
 8024cee:	f3bf 8f6f 	isb	sy
 8024cf2:	f3bf 8f4f 	dsb	sy
 8024cf6:	617b      	str	r3, [r7, #20]
}
 8024cf8:	bf00      	nop
 8024cfa:	e7fe      	b.n	8024cfa <vTaskPlaceOnEventListRestricted+0x26>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8024cfc:	4b0a      	ldr	r3, [pc, #40]	; (8024d28 <vTaskPlaceOnEventListRestricted+0x54>)
 8024cfe:	681b      	ldr	r3, [r3, #0]
 8024d00:	3318      	adds	r3, #24
 8024d02:	4619      	mov	r1, r3
 8024d04:	68f8      	ldr	r0, [r7, #12]
 8024d06:	f7fe fa40 	bl	802318a <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 8024d0a:	687b      	ldr	r3, [r7, #4]
 8024d0c:	2b00      	cmp	r3, #0
 8024d0e:	d002      	beq.n	8024d16 <vTaskPlaceOnEventListRestricted+0x42>
		{
			xTicksToWait = portMAX_DELAY;
 8024d10:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8024d14:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8024d16:	6879      	ldr	r1, [r7, #4]
 8024d18:	68b8      	ldr	r0, [r7, #8]
 8024d1a:	f000 fd65 	bl	80257e8 <prvAddCurrentTaskToDelayedList>
	}
 8024d1e:	bf00      	nop
 8024d20:	3718      	adds	r7, #24
 8024d22:	46bd      	mov	sp, r7
 8024d24:	bd80      	pop	{r7, pc}
 8024d26:	bf00      	nop
 8024d28:	20004248 	.word	0x20004248

08024d2c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 8024d2c:	b580      	push	{r7, lr}
 8024d2e:	b086      	sub	sp, #24
 8024d30:	af00      	add	r7, sp, #0
 8024d32:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024d34:	687b      	ldr	r3, [r7, #4]
 8024d36:	68db      	ldr	r3, [r3, #12]
 8024d38:	68db      	ldr	r3, [r3, #12]
 8024d3a:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 8024d3c:	693b      	ldr	r3, [r7, #16]
 8024d3e:	2b00      	cmp	r3, #0
 8024d40:	d10a      	bne.n	8024d58 <xTaskRemoveFromEventList+0x2c>
	__asm volatile
 8024d42:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024d46:	f383 8811 	msr	BASEPRI, r3
 8024d4a:	f3bf 8f6f 	isb	sy
 8024d4e:	f3bf 8f4f 	dsb	sy
 8024d52:	60fb      	str	r3, [r7, #12]
}
 8024d54:	bf00      	nop
 8024d56:	e7fe      	b.n	8024d56 <xTaskRemoveFromEventList+0x2a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8024d58:	693b      	ldr	r3, [r7, #16]
 8024d5a:	3318      	adds	r3, #24
 8024d5c:	4618      	mov	r0, r3
 8024d5e:	f7fe fa71 	bl	8023244 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8024d62:	4b1e      	ldr	r3, [pc, #120]	; (8024ddc <xTaskRemoveFromEventList+0xb0>)
 8024d64:	681b      	ldr	r3, [r3, #0]
 8024d66:	2b00      	cmp	r3, #0
 8024d68:	d11d      	bne.n	8024da6 <xTaskRemoveFromEventList+0x7a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8024d6a:	693b      	ldr	r3, [r7, #16]
 8024d6c:	3304      	adds	r3, #4
 8024d6e:	4618      	mov	r0, r3
 8024d70:	f7fe fa68 	bl	8023244 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8024d74:	693b      	ldr	r3, [r7, #16]
 8024d76:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024d78:	4b19      	ldr	r3, [pc, #100]	; (8024de0 <xTaskRemoveFromEventList+0xb4>)
 8024d7a:	681b      	ldr	r3, [r3, #0]
 8024d7c:	429a      	cmp	r2, r3
 8024d7e:	d903      	bls.n	8024d88 <xTaskRemoveFromEventList+0x5c>
 8024d80:	693b      	ldr	r3, [r7, #16]
 8024d82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024d84:	4a16      	ldr	r2, [pc, #88]	; (8024de0 <xTaskRemoveFromEventList+0xb4>)
 8024d86:	6013      	str	r3, [r2, #0]
 8024d88:	693b      	ldr	r3, [r7, #16]
 8024d8a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024d8c:	4613      	mov	r3, r2
 8024d8e:	009b      	lsls	r3, r3, #2
 8024d90:	4413      	add	r3, r2
 8024d92:	009b      	lsls	r3, r3, #2
 8024d94:	4a13      	ldr	r2, [pc, #76]	; (8024de4 <xTaskRemoveFromEventList+0xb8>)
 8024d96:	441a      	add	r2, r3
 8024d98:	693b      	ldr	r3, [r7, #16]
 8024d9a:	3304      	adds	r3, #4
 8024d9c:	4619      	mov	r1, r3
 8024d9e:	4610      	mov	r0, r2
 8024da0:	f7fe f9f3 	bl	802318a <vListInsertEnd>
 8024da4:	e005      	b.n	8024db2 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8024da6:	693b      	ldr	r3, [r7, #16]
 8024da8:	3318      	adds	r3, #24
 8024daa:	4619      	mov	r1, r3
 8024dac:	480e      	ldr	r0, [pc, #56]	; (8024de8 <xTaskRemoveFromEventList+0xbc>)
 8024dae:	f7fe f9ec 	bl	802318a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8024db2:	693b      	ldr	r3, [r7, #16]
 8024db4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8024db6:	4b0d      	ldr	r3, [pc, #52]	; (8024dec <xTaskRemoveFromEventList+0xc0>)
 8024db8:	681b      	ldr	r3, [r3, #0]
 8024dba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8024dbc:	429a      	cmp	r2, r3
 8024dbe:	d905      	bls.n	8024dcc <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 8024dc0:	2301      	movs	r3, #1
 8024dc2:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8024dc4:	4b0a      	ldr	r3, [pc, #40]	; (8024df0 <xTaskRemoveFromEventList+0xc4>)
 8024dc6:	2201      	movs	r2, #1
 8024dc8:	601a      	str	r2, [r3, #0]
 8024dca:	e001      	b.n	8024dd0 <xTaskRemoveFromEventList+0xa4>
	}
	else
	{
		xReturn = pdFALSE;
 8024dcc:	2300      	movs	r3, #0
 8024dce:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 8024dd0:	697b      	ldr	r3, [r7, #20]
}
 8024dd2:	4618      	mov	r0, r3
 8024dd4:	3718      	adds	r7, #24
 8024dd6:	46bd      	mov	sp, r7
 8024dd8:	bd80      	pop	{r7, pc}
 8024dda:	bf00      	nop
 8024ddc:	20004744 	.word	0x20004744
 8024de0:	20004724 	.word	0x20004724
 8024de4:	2000424c 	.word	0x2000424c
 8024de8:	200046dc 	.word	0x200046dc
 8024dec:	20004248 	.word	0x20004248
 8024df0:	20004730 	.word	0x20004730

08024df4 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8024df4:	b480      	push	{r7}
 8024df6:	b083      	sub	sp, #12
 8024df8:	af00      	add	r7, sp, #0
 8024dfa:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8024dfc:	4b06      	ldr	r3, [pc, #24]	; (8024e18 <vTaskInternalSetTimeOutState+0x24>)
 8024dfe:	681a      	ldr	r2, [r3, #0]
 8024e00:	687b      	ldr	r3, [r7, #4]
 8024e02:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8024e04:	4b05      	ldr	r3, [pc, #20]	; (8024e1c <vTaskInternalSetTimeOutState+0x28>)
 8024e06:	681a      	ldr	r2, [r3, #0]
 8024e08:	687b      	ldr	r3, [r7, #4]
 8024e0a:	605a      	str	r2, [r3, #4]
}
 8024e0c:	bf00      	nop
 8024e0e:	370c      	adds	r7, #12
 8024e10:	46bd      	mov	sp, r7
 8024e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e16:	4770      	bx	lr
 8024e18:	20004734 	.word	0x20004734
 8024e1c:	20004720 	.word	0x20004720

08024e20 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8024e20:	b580      	push	{r7, lr}
 8024e22:	b088      	sub	sp, #32
 8024e24:	af00      	add	r7, sp, #0
 8024e26:	6078      	str	r0, [r7, #4]
 8024e28:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 8024e2a:	687b      	ldr	r3, [r7, #4]
 8024e2c:	2b00      	cmp	r3, #0
 8024e2e:	d10a      	bne.n	8024e46 <xTaskCheckForTimeOut+0x26>
	__asm volatile
 8024e30:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e34:	f383 8811 	msr	BASEPRI, r3
 8024e38:	f3bf 8f6f 	isb	sy
 8024e3c:	f3bf 8f4f 	dsb	sy
 8024e40:	613b      	str	r3, [r7, #16]
}
 8024e42:	bf00      	nop
 8024e44:	e7fe      	b.n	8024e44 <xTaskCheckForTimeOut+0x24>
	configASSERT( pxTicksToWait );
 8024e46:	683b      	ldr	r3, [r7, #0]
 8024e48:	2b00      	cmp	r3, #0
 8024e4a:	d10a      	bne.n	8024e62 <xTaskCheckForTimeOut+0x42>
	__asm volatile
 8024e4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e50:	f383 8811 	msr	BASEPRI, r3
 8024e54:	f3bf 8f6f 	isb	sy
 8024e58:	f3bf 8f4f 	dsb	sy
 8024e5c:	60fb      	str	r3, [r7, #12]
}
 8024e5e:	bf00      	nop
 8024e60:	e7fe      	b.n	8024e60 <xTaskCheckForTimeOut+0x40>

	taskENTER_CRITICAL();
 8024e62:	f001 fa47 	bl	80262f4 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8024e66:	4b1d      	ldr	r3, [pc, #116]	; (8024edc <xTaskCheckForTimeOut+0xbc>)
 8024e68:	681b      	ldr	r3, [r3, #0]
 8024e6a:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8024e6c:	687b      	ldr	r3, [r7, #4]
 8024e6e:	685b      	ldr	r3, [r3, #4]
 8024e70:	69ba      	ldr	r2, [r7, #24]
 8024e72:	1ad3      	subs	r3, r2, r3
 8024e74:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 8024e76:	683b      	ldr	r3, [r7, #0]
 8024e78:	681b      	ldr	r3, [r3, #0]
 8024e7a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8024e7e:	d102      	bne.n	8024e86 <xTaskCheckForTimeOut+0x66>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 8024e80:	2300      	movs	r3, #0
 8024e82:	61fb      	str	r3, [r7, #28]
 8024e84:	e023      	b.n	8024ece <xTaskCheckForTimeOut+0xae>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8024e86:	687b      	ldr	r3, [r7, #4]
 8024e88:	681a      	ldr	r2, [r3, #0]
 8024e8a:	4b15      	ldr	r3, [pc, #84]	; (8024ee0 <xTaskCheckForTimeOut+0xc0>)
 8024e8c:	681b      	ldr	r3, [r3, #0]
 8024e8e:	429a      	cmp	r2, r3
 8024e90:	d007      	beq.n	8024ea2 <xTaskCheckForTimeOut+0x82>
 8024e92:	687b      	ldr	r3, [r7, #4]
 8024e94:	685b      	ldr	r3, [r3, #4]
 8024e96:	69ba      	ldr	r2, [r7, #24]
 8024e98:	429a      	cmp	r2, r3
 8024e9a:	d302      	bcc.n	8024ea2 <xTaskCheckForTimeOut+0x82>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 8024e9c:	2301      	movs	r3, #1
 8024e9e:	61fb      	str	r3, [r7, #28]
 8024ea0:	e015      	b.n	8024ece <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8024ea2:	683b      	ldr	r3, [r7, #0]
 8024ea4:	681b      	ldr	r3, [r3, #0]
 8024ea6:	697a      	ldr	r2, [r7, #20]
 8024ea8:	429a      	cmp	r2, r3
 8024eaa:	d20b      	bcs.n	8024ec4 <xTaskCheckForTimeOut+0xa4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 8024eac:	683b      	ldr	r3, [r7, #0]
 8024eae:	681a      	ldr	r2, [r3, #0]
 8024eb0:	697b      	ldr	r3, [r7, #20]
 8024eb2:	1ad2      	subs	r2, r2, r3
 8024eb4:	683b      	ldr	r3, [r7, #0]
 8024eb6:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 8024eb8:	6878      	ldr	r0, [r7, #4]
 8024eba:	f7ff ff9b 	bl	8024df4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 8024ebe:	2300      	movs	r3, #0
 8024ec0:	61fb      	str	r3, [r7, #28]
 8024ec2:	e004      	b.n	8024ece <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
 8024ec4:	683b      	ldr	r3, [r7, #0]
 8024ec6:	2200      	movs	r2, #0
 8024ec8:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
 8024eca:	2301      	movs	r3, #1
 8024ecc:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
 8024ece:	f001 fa41 	bl	8026354 <vPortExitCritical>

	return xReturn;
 8024ed2:	69fb      	ldr	r3, [r7, #28]
}
 8024ed4:	4618      	mov	r0, r3
 8024ed6:	3720      	adds	r7, #32
 8024ed8:	46bd      	mov	sp, r7
 8024eda:	bd80      	pop	{r7, pc}
 8024edc:	20004720 	.word	0x20004720
 8024ee0:	20004734 	.word	0x20004734

08024ee4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8024ee4:	b480      	push	{r7}
 8024ee6:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 8024ee8:	4b03      	ldr	r3, [pc, #12]	; (8024ef8 <vTaskMissedYield+0x14>)
 8024eea:	2201      	movs	r2, #1
 8024eec:	601a      	str	r2, [r3, #0]
}
 8024eee:	bf00      	nop
 8024ef0:	46bd      	mov	sp, r7
 8024ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024ef6:	4770      	bx	lr
 8024ef8:	20004730 	.word	0x20004730

08024efc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8024efc:	b580      	push	{r7, lr}
 8024efe:	b082      	sub	sp, #8
 8024f00:	af00      	add	r7, sp, #0
 8024f02:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 8024f04:	f000 f852 	bl	8024fac <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8024f08:	4b06      	ldr	r3, [pc, #24]	; (8024f24 <prvIdleTask+0x28>)
 8024f0a:	681b      	ldr	r3, [r3, #0]
 8024f0c:	2b01      	cmp	r3, #1
 8024f0e:	d9f9      	bls.n	8024f04 <prvIdleTask+0x8>
			{
				taskYIELD();
 8024f10:	4b05      	ldr	r3, [pc, #20]	; (8024f28 <prvIdleTask+0x2c>)
 8024f12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024f16:	601a      	str	r2, [r3, #0]
 8024f18:	f3bf 8f4f 	dsb	sy
 8024f1c:	f3bf 8f6f 	isb	sy
		prvCheckTasksWaitingTermination();
 8024f20:	e7f0      	b.n	8024f04 <prvIdleTask+0x8>
 8024f22:	bf00      	nop
 8024f24:	2000424c 	.word	0x2000424c
 8024f28:	e000ed04 	.word	0xe000ed04

08024f2c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8024f2c:	b580      	push	{r7, lr}
 8024f2e:	b082      	sub	sp, #8
 8024f30:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8024f32:	2300      	movs	r3, #0
 8024f34:	607b      	str	r3, [r7, #4]
 8024f36:	e00c      	b.n	8024f52 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8024f38:	687a      	ldr	r2, [r7, #4]
 8024f3a:	4613      	mov	r3, r2
 8024f3c:	009b      	lsls	r3, r3, #2
 8024f3e:	4413      	add	r3, r2
 8024f40:	009b      	lsls	r3, r3, #2
 8024f42:	4a12      	ldr	r2, [pc, #72]	; (8024f8c <prvInitialiseTaskLists+0x60>)
 8024f44:	4413      	add	r3, r2
 8024f46:	4618      	mov	r0, r3
 8024f48:	f7fe f8f2 	bl	8023130 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8024f4c:	687b      	ldr	r3, [r7, #4]
 8024f4e:	3301      	adds	r3, #1
 8024f50:	607b      	str	r3, [r7, #4]
 8024f52:	687b      	ldr	r3, [r7, #4]
 8024f54:	2b37      	cmp	r3, #55	; 0x37
 8024f56:	d9ef      	bls.n	8024f38 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 8024f58:	480d      	ldr	r0, [pc, #52]	; (8024f90 <prvInitialiseTaskLists+0x64>)
 8024f5a:	f7fe f8e9 	bl	8023130 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8024f5e:	480d      	ldr	r0, [pc, #52]	; (8024f94 <prvInitialiseTaskLists+0x68>)
 8024f60:	f7fe f8e6 	bl	8023130 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8024f64:	480c      	ldr	r0, [pc, #48]	; (8024f98 <prvInitialiseTaskLists+0x6c>)
 8024f66:	f7fe f8e3 	bl	8023130 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8024f6a:	480c      	ldr	r0, [pc, #48]	; (8024f9c <prvInitialiseTaskLists+0x70>)
 8024f6c:	f7fe f8e0 	bl	8023130 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8024f70:	480b      	ldr	r0, [pc, #44]	; (8024fa0 <prvInitialiseTaskLists+0x74>)
 8024f72:	f7fe f8dd 	bl	8023130 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8024f76:	4b0b      	ldr	r3, [pc, #44]	; (8024fa4 <prvInitialiseTaskLists+0x78>)
 8024f78:	4a05      	ldr	r2, [pc, #20]	; (8024f90 <prvInitialiseTaskLists+0x64>)
 8024f7a:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8024f7c:	4b0a      	ldr	r3, [pc, #40]	; (8024fa8 <prvInitialiseTaskLists+0x7c>)
 8024f7e:	4a05      	ldr	r2, [pc, #20]	; (8024f94 <prvInitialiseTaskLists+0x68>)
 8024f80:	601a      	str	r2, [r3, #0]
}
 8024f82:	bf00      	nop
 8024f84:	3708      	adds	r7, #8
 8024f86:	46bd      	mov	sp, r7
 8024f88:	bd80      	pop	{r7, pc}
 8024f8a:	bf00      	nop
 8024f8c:	2000424c 	.word	0x2000424c
 8024f90:	200046ac 	.word	0x200046ac
 8024f94:	200046c0 	.word	0x200046c0
 8024f98:	200046dc 	.word	0x200046dc
 8024f9c:	200046f0 	.word	0x200046f0
 8024fa0:	20004708 	.word	0x20004708
 8024fa4:	200046d4 	.word	0x200046d4
 8024fa8:	200046d8 	.word	0x200046d8

08024fac <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8024fac:	b580      	push	{r7, lr}
 8024fae:	b082      	sub	sp, #8
 8024fb0:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8024fb2:	e019      	b.n	8024fe8 <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
 8024fb4:	f001 f99e 	bl	80262f4 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8024fb8:	4b10      	ldr	r3, [pc, #64]	; (8024ffc <prvCheckTasksWaitingTermination+0x50>)
 8024fba:	68db      	ldr	r3, [r3, #12]
 8024fbc:	68db      	ldr	r3, [r3, #12]
 8024fbe:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8024fc0:	687b      	ldr	r3, [r7, #4]
 8024fc2:	3304      	adds	r3, #4
 8024fc4:	4618      	mov	r0, r3
 8024fc6:	f7fe f93d 	bl	8023244 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8024fca:	4b0d      	ldr	r3, [pc, #52]	; (8025000 <prvCheckTasksWaitingTermination+0x54>)
 8024fcc:	681b      	ldr	r3, [r3, #0]
 8024fce:	3b01      	subs	r3, #1
 8024fd0:	4a0b      	ldr	r2, [pc, #44]	; (8025000 <prvCheckTasksWaitingTermination+0x54>)
 8024fd2:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 8024fd4:	4b0b      	ldr	r3, [pc, #44]	; (8025004 <prvCheckTasksWaitingTermination+0x58>)
 8024fd6:	681b      	ldr	r3, [r3, #0]
 8024fd8:	3b01      	subs	r3, #1
 8024fda:	4a0a      	ldr	r2, [pc, #40]	; (8025004 <prvCheckTasksWaitingTermination+0x58>)
 8024fdc:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
 8024fde:	f001 f9b9 	bl	8026354 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 8024fe2:	6878      	ldr	r0, [r7, #4]
 8024fe4:	f000 f810 	bl	8025008 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8024fe8:	4b06      	ldr	r3, [pc, #24]	; (8025004 <prvCheckTasksWaitingTermination+0x58>)
 8024fea:	681b      	ldr	r3, [r3, #0]
 8024fec:	2b00      	cmp	r3, #0
 8024fee:	d1e1      	bne.n	8024fb4 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 8024ff0:	bf00      	nop
 8024ff2:	bf00      	nop
 8024ff4:	3708      	adds	r7, #8
 8024ff6:	46bd      	mov	sp, r7
 8024ff8:	bd80      	pop	{r7, pc}
 8024ffa:	bf00      	nop
 8024ffc:	200046f0 	.word	0x200046f0
 8025000:	2000471c 	.word	0x2000471c
 8025004:	20004704 	.word	0x20004704

08025008 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 8025008:	b580      	push	{r7, lr}
 802500a:	b084      	sub	sp, #16
 802500c:	af00      	add	r7, sp, #0
 802500e:	6078      	str	r0, [r7, #4]
		to the task to free any memory allocated at the application level.
		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
		for additional information. */
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
 8025010:	687b      	ldr	r3, [r7, #4]
 8025012:	3354      	adds	r3, #84	; 0x54
 8025014:	4618      	mov	r0, r3
 8025016:	f007 f931 	bl	802c27c <_reclaim_reent>
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 802501a:	687b      	ldr	r3, [r7, #4]
 802501c:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
 8025020:	2b00      	cmp	r3, #0
 8025022:	d108      	bne.n	8025036 <prvDeleteTCB+0x2e>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
 8025024:	687b      	ldr	r3, [r7, #4]
 8025026:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025028:	4618      	mov	r0, r3
 802502a:	f001 fb51 	bl	80266d0 <vPortFree>
				vPortFree( pxTCB );
 802502e:	6878      	ldr	r0, [r7, #4]
 8025030:	f001 fb4e 	bl	80266d0 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 8025034:	e018      	b.n	8025068 <prvDeleteTCB+0x60>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8025036:	687b      	ldr	r3, [r7, #4]
 8025038:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
 802503c:	2b01      	cmp	r3, #1
 802503e:	d103      	bne.n	8025048 <prvDeleteTCB+0x40>
				vPortFree( pxTCB );
 8025040:	6878      	ldr	r0, [r7, #4]
 8025042:	f001 fb45 	bl	80266d0 <vPortFree>
	}
 8025046:	e00f      	b.n	8025068 <prvDeleteTCB+0x60>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8025048:	687b      	ldr	r3, [r7, #4]
 802504a:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
 802504e:	2b02      	cmp	r3, #2
 8025050:	d00a      	beq.n	8025068 <prvDeleteTCB+0x60>
	__asm volatile
 8025052:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025056:	f383 8811 	msr	BASEPRI, r3
 802505a:	f3bf 8f6f 	isb	sy
 802505e:	f3bf 8f4f 	dsb	sy
 8025062:	60fb      	str	r3, [r7, #12]
}
 8025064:	bf00      	nop
 8025066:	e7fe      	b.n	8025066 <prvDeleteTCB+0x5e>
	}
 8025068:	bf00      	nop
 802506a:	3710      	adds	r7, #16
 802506c:	46bd      	mov	sp, r7
 802506e:	bd80      	pop	{r7, pc}

08025070 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 8025070:	b480      	push	{r7}
 8025072:	b083      	sub	sp, #12
 8025074:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8025076:	4b0c      	ldr	r3, [pc, #48]	; (80250a8 <prvResetNextTaskUnblockTime+0x38>)
 8025078:	681b      	ldr	r3, [r3, #0]
 802507a:	681b      	ldr	r3, [r3, #0]
 802507c:	2b00      	cmp	r3, #0
 802507e:	d104      	bne.n	802508a <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8025080:	4b0a      	ldr	r3, [pc, #40]	; (80250ac <prvResetNextTaskUnblockTime+0x3c>)
 8025082:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8025086:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 8025088:	e008      	b.n	802509c <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 802508a:	4b07      	ldr	r3, [pc, #28]	; (80250a8 <prvResetNextTaskUnblockTime+0x38>)
 802508c:	681b      	ldr	r3, [r3, #0]
 802508e:	68db      	ldr	r3, [r3, #12]
 8025090:	68db      	ldr	r3, [r3, #12]
 8025092:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8025094:	687b      	ldr	r3, [r7, #4]
 8025096:	685b      	ldr	r3, [r3, #4]
 8025098:	4a04      	ldr	r2, [pc, #16]	; (80250ac <prvResetNextTaskUnblockTime+0x3c>)
 802509a:	6013      	str	r3, [r2, #0]
}
 802509c:	bf00      	nop
 802509e:	370c      	adds	r7, #12
 80250a0:	46bd      	mov	sp, r7
 80250a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80250a6:	4770      	bx	lr
 80250a8:	200046d4 	.word	0x200046d4
 80250ac:	2000473c 	.word	0x2000473c

080250b0 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 80250b0:	b480      	push	{r7}
 80250b2:	b083      	sub	sp, #12
 80250b4:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 80250b6:	4b05      	ldr	r3, [pc, #20]	; (80250cc <xTaskGetCurrentTaskHandle+0x1c>)
 80250b8:	681b      	ldr	r3, [r3, #0]
 80250ba:	607b      	str	r3, [r7, #4]

		return xReturn;
 80250bc:	687b      	ldr	r3, [r7, #4]
	}
 80250be:	4618      	mov	r0, r3
 80250c0:	370c      	adds	r7, #12
 80250c2:	46bd      	mov	sp, r7
 80250c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80250c8:	4770      	bx	lr
 80250ca:	bf00      	nop
 80250cc:	20004248 	.word	0x20004248

080250d0 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 80250d0:	b480      	push	{r7}
 80250d2:	b083      	sub	sp, #12
 80250d4:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80250d6:	4b0b      	ldr	r3, [pc, #44]	; (8025104 <xTaskGetSchedulerState+0x34>)
 80250d8:	681b      	ldr	r3, [r3, #0]
 80250da:	2b00      	cmp	r3, #0
 80250dc:	d102      	bne.n	80250e4 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80250de:	2301      	movs	r3, #1
 80250e0:	607b      	str	r3, [r7, #4]
 80250e2:	e008      	b.n	80250f6 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80250e4:	4b08      	ldr	r3, [pc, #32]	; (8025108 <xTaskGetSchedulerState+0x38>)
 80250e6:	681b      	ldr	r3, [r3, #0]
 80250e8:	2b00      	cmp	r3, #0
 80250ea:	d102      	bne.n	80250f2 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 80250ec:	2302      	movs	r3, #2
 80250ee:	607b      	str	r3, [r7, #4]
 80250f0:	e001      	b.n	80250f6 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80250f2:	2300      	movs	r3, #0
 80250f4:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 80250f6:	687b      	ldr	r3, [r7, #4]
	}
 80250f8:	4618      	mov	r0, r3
 80250fa:	370c      	adds	r7, #12
 80250fc:	46bd      	mov	sp, r7
 80250fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025102:	4770      	bx	lr
 8025104:	20004728 	.word	0x20004728
 8025108:	20004744 	.word	0x20004744

0802510c <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 802510c:	b580      	push	{r7, lr}
 802510e:	b084      	sub	sp, #16
 8025110:	af00      	add	r7, sp, #0
 8025112:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 8025114:	687b      	ldr	r3, [r7, #4]
 8025116:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
 8025118:	2300      	movs	r3, #0
 802511a:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 802511c:	687b      	ldr	r3, [r7, #4]
 802511e:	2b00      	cmp	r3, #0
 8025120:	d051      	beq.n	80251c6 <xTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8025122:	68bb      	ldr	r3, [r7, #8]
 8025124:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025126:	4b2a      	ldr	r3, [pc, #168]	; (80251d0 <xTaskPriorityInherit+0xc4>)
 8025128:	681b      	ldr	r3, [r3, #0]
 802512a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802512c:	429a      	cmp	r2, r3
 802512e:	d241      	bcs.n	80251b4 <xTaskPriorityInherit+0xa8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8025130:	68bb      	ldr	r3, [r7, #8]
 8025132:	699b      	ldr	r3, [r3, #24]
 8025134:	2b00      	cmp	r3, #0
 8025136:	db06      	blt.n	8025146 <xTaskPriorityInherit+0x3a>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025138:	4b25      	ldr	r3, [pc, #148]	; (80251d0 <xTaskPriorityInherit+0xc4>)
 802513a:	681b      	ldr	r3, [r3, #0]
 802513c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802513e:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8025142:	68bb      	ldr	r3, [r7, #8]
 8025144:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8025146:	68bb      	ldr	r3, [r7, #8]
 8025148:	6959      	ldr	r1, [r3, #20]
 802514a:	68bb      	ldr	r3, [r7, #8]
 802514c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802514e:	4613      	mov	r3, r2
 8025150:	009b      	lsls	r3, r3, #2
 8025152:	4413      	add	r3, r2
 8025154:	009b      	lsls	r3, r3, #2
 8025156:	4a1f      	ldr	r2, [pc, #124]	; (80251d4 <xTaskPriorityInherit+0xc8>)
 8025158:	4413      	add	r3, r2
 802515a:	4299      	cmp	r1, r3
 802515c:	d122      	bne.n	80251a4 <xTaskPriorityInherit+0x98>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 802515e:	68bb      	ldr	r3, [r7, #8]
 8025160:	3304      	adds	r3, #4
 8025162:	4618      	mov	r0, r3
 8025164:	f7fe f86e 	bl	8023244 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8025168:	4b19      	ldr	r3, [pc, #100]	; (80251d0 <xTaskPriorityInherit+0xc4>)
 802516a:	681b      	ldr	r3, [r3, #0]
 802516c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802516e:	68bb      	ldr	r3, [r7, #8]
 8025170:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8025172:	68bb      	ldr	r3, [r7, #8]
 8025174:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025176:	4b18      	ldr	r3, [pc, #96]	; (80251d8 <xTaskPriorityInherit+0xcc>)
 8025178:	681b      	ldr	r3, [r3, #0]
 802517a:	429a      	cmp	r2, r3
 802517c:	d903      	bls.n	8025186 <xTaskPriorityInherit+0x7a>
 802517e:	68bb      	ldr	r3, [r7, #8]
 8025180:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025182:	4a15      	ldr	r2, [pc, #84]	; (80251d8 <xTaskPriorityInherit+0xcc>)
 8025184:	6013      	str	r3, [r2, #0]
 8025186:	68bb      	ldr	r3, [r7, #8]
 8025188:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802518a:	4613      	mov	r3, r2
 802518c:	009b      	lsls	r3, r3, #2
 802518e:	4413      	add	r3, r2
 8025190:	009b      	lsls	r3, r3, #2
 8025192:	4a10      	ldr	r2, [pc, #64]	; (80251d4 <xTaskPriorityInherit+0xc8>)
 8025194:	441a      	add	r2, r3
 8025196:	68bb      	ldr	r3, [r7, #8]
 8025198:	3304      	adds	r3, #4
 802519a:	4619      	mov	r1, r3
 802519c:	4610      	mov	r0, r2
 802519e:	f7fd fff4 	bl	802318a <vListInsertEnd>
 80251a2:	e004      	b.n	80251ae <xTaskPriorityInherit+0xa2>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80251a4:	4b0a      	ldr	r3, [pc, #40]	; (80251d0 <xTaskPriorityInherit+0xc4>)
 80251a6:	681b      	ldr	r3, [r3, #0]
 80251a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80251aa:	68bb      	ldr	r3, [r7, #8]
 80251ac:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 80251ae:	2301      	movs	r3, #1
 80251b0:	60fb      	str	r3, [r7, #12]
 80251b2:	e008      	b.n	80251c6 <xTaskPriorityInherit+0xba>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 80251b4:	68bb      	ldr	r3, [r7, #8]
 80251b6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80251b8:	4b05      	ldr	r3, [pc, #20]	; (80251d0 <xTaskPriorityInherit+0xc4>)
 80251ba:	681b      	ldr	r3, [r3, #0]
 80251bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80251be:	429a      	cmp	r2, r3
 80251c0:	d201      	bcs.n	80251c6 <xTaskPriorityInherit+0xba>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 80251c2:	2301      	movs	r3, #1
 80251c4:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 80251c6:	68fb      	ldr	r3, [r7, #12]
	}
 80251c8:	4618      	mov	r0, r3
 80251ca:	3710      	adds	r7, #16
 80251cc:	46bd      	mov	sp, r7
 80251ce:	bd80      	pop	{r7, pc}
 80251d0:	20004248 	.word	0x20004248
 80251d4:	2000424c 	.word	0x2000424c
 80251d8:	20004724 	.word	0x20004724

080251dc <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 80251dc:	b580      	push	{r7, lr}
 80251de:	b086      	sub	sp, #24
 80251e0:	af00      	add	r7, sp, #0
 80251e2:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
 80251e4:	687b      	ldr	r3, [r7, #4]
 80251e6:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 80251e8:	2300      	movs	r3, #0
 80251ea:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 80251ec:	687b      	ldr	r3, [r7, #4]
 80251ee:	2b00      	cmp	r3, #0
 80251f0:	d056      	beq.n	80252a0 <xTaskPriorityDisinherit+0xc4>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 80251f2:	4b2e      	ldr	r3, [pc, #184]	; (80252ac <xTaskPriorityDisinherit+0xd0>)
 80251f4:	681b      	ldr	r3, [r3, #0]
 80251f6:	693a      	ldr	r2, [r7, #16]
 80251f8:	429a      	cmp	r2, r3
 80251fa:	d00a      	beq.n	8025212 <xTaskPriorityDisinherit+0x36>
	__asm volatile
 80251fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025200:	f383 8811 	msr	BASEPRI, r3
 8025204:	f3bf 8f6f 	isb	sy
 8025208:	f3bf 8f4f 	dsb	sy
 802520c:	60fb      	str	r3, [r7, #12]
}
 802520e:	bf00      	nop
 8025210:	e7fe      	b.n	8025210 <xTaskPriorityDisinherit+0x34>
			configASSERT( pxTCB->uxMutexesHeld );
 8025212:	693b      	ldr	r3, [r7, #16]
 8025214:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8025216:	2b00      	cmp	r3, #0
 8025218:	d10a      	bne.n	8025230 <xTaskPriorityDisinherit+0x54>
	__asm volatile
 802521a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802521e:	f383 8811 	msr	BASEPRI, r3
 8025222:	f3bf 8f6f 	isb	sy
 8025226:	f3bf 8f4f 	dsb	sy
 802522a:	60bb      	str	r3, [r7, #8]
}
 802522c:	bf00      	nop
 802522e:	e7fe      	b.n	802522e <xTaskPriorityDisinherit+0x52>
			( pxTCB->uxMutexesHeld )--;
 8025230:	693b      	ldr	r3, [r7, #16]
 8025232:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8025234:	1e5a      	subs	r2, r3, #1
 8025236:	693b      	ldr	r3, [r7, #16]
 8025238:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 802523a:	693b      	ldr	r3, [r7, #16]
 802523c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802523e:	693b      	ldr	r3, [r7, #16]
 8025240:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8025242:	429a      	cmp	r2, r3
 8025244:	d02c      	beq.n	80252a0 <xTaskPriorityDisinherit+0xc4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8025246:	693b      	ldr	r3, [r7, #16]
 8025248:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802524a:	2b00      	cmp	r3, #0
 802524c:	d128      	bne.n	80252a0 <xTaskPriorityDisinherit+0xc4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 802524e:	693b      	ldr	r3, [r7, #16]
 8025250:	3304      	adds	r3, #4
 8025252:	4618      	mov	r0, r3
 8025254:	f7fd fff6 	bl	8023244 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8025258:	693b      	ldr	r3, [r7, #16]
 802525a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802525c:	693b      	ldr	r3, [r7, #16]
 802525e:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025260:	693b      	ldr	r3, [r7, #16]
 8025262:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025264:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8025268:	693b      	ldr	r3, [r7, #16]
 802526a:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 802526c:	693b      	ldr	r3, [r7, #16]
 802526e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025270:	4b0f      	ldr	r3, [pc, #60]	; (80252b0 <xTaskPriorityDisinherit+0xd4>)
 8025272:	681b      	ldr	r3, [r3, #0]
 8025274:	429a      	cmp	r2, r3
 8025276:	d903      	bls.n	8025280 <xTaskPriorityDisinherit+0xa4>
 8025278:	693b      	ldr	r3, [r7, #16]
 802527a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802527c:	4a0c      	ldr	r2, [pc, #48]	; (80252b0 <xTaskPriorityDisinherit+0xd4>)
 802527e:	6013      	str	r3, [r2, #0]
 8025280:	693b      	ldr	r3, [r7, #16]
 8025282:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025284:	4613      	mov	r3, r2
 8025286:	009b      	lsls	r3, r3, #2
 8025288:	4413      	add	r3, r2
 802528a:	009b      	lsls	r3, r3, #2
 802528c:	4a09      	ldr	r2, [pc, #36]	; (80252b4 <xTaskPriorityDisinherit+0xd8>)
 802528e:	441a      	add	r2, r3
 8025290:	693b      	ldr	r3, [r7, #16]
 8025292:	3304      	adds	r3, #4
 8025294:	4619      	mov	r1, r3
 8025296:	4610      	mov	r0, r2
 8025298:	f7fd ff77 	bl	802318a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 802529c:	2301      	movs	r3, #1
 802529e:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 80252a0:	697b      	ldr	r3, [r7, #20]
	}
 80252a2:	4618      	mov	r0, r3
 80252a4:	3718      	adds	r7, #24
 80252a6:	46bd      	mov	sp, r7
 80252a8:	bd80      	pop	{r7, pc}
 80252aa:	bf00      	nop
 80252ac:	20004248 	.word	0x20004248
 80252b0:	20004724 	.word	0x20004724
 80252b4:	2000424c 	.word	0x2000424c

080252b8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 80252b8:	b580      	push	{r7, lr}
 80252ba:	b088      	sub	sp, #32
 80252bc:	af00      	add	r7, sp, #0
 80252be:	6078      	str	r0, [r7, #4]
 80252c0:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
 80252c2:	687b      	ldr	r3, [r7, #4]
 80252c4:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 80252c6:	2301      	movs	r3, #1
 80252c8:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 80252ca:	687b      	ldr	r3, [r7, #4]
 80252cc:	2b00      	cmp	r3, #0
 80252ce:	d06a      	beq.n	80253a6 <vTaskPriorityDisinheritAfterTimeout+0xee>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
 80252d0:	69bb      	ldr	r3, [r7, #24]
 80252d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80252d4:	2b00      	cmp	r3, #0
 80252d6:	d10a      	bne.n	80252ee <vTaskPriorityDisinheritAfterTimeout+0x36>
	__asm volatile
 80252d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80252dc:	f383 8811 	msr	BASEPRI, r3
 80252e0:	f3bf 8f6f 	isb	sy
 80252e4:	f3bf 8f4f 	dsb	sy
 80252e8:	60fb      	str	r3, [r7, #12]
}
 80252ea:	bf00      	nop
 80252ec:	e7fe      	b.n	80252ec <vTaskPriorityDisinheritAfterTimeout+0x34>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 80252ee:	69bb      	ldr	r3, [r7, #24]
 80252f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80252f2:	683a      	ldr	r2, [r7, #0]
 80252f4:	429a      	cmp	r2, r3
 80252f6:	d902      	bls.n	80252fe <vTaskPriorityDisinheritAfterTimeout+0x46>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 80252f8:	683b      	ldr	r3, [r7, #0]
 80252fa:	61fb      	str	r3, [r7, #28]
 80252fc:	e002      	b.n	8025304 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 80252fe:	69bb      	ldr	r3, [r7, #24]
 8025300:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8025302:	61fb      	str	r3, [r7, #28]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 8025304:	69bb      	ldr	r3, [r7, #24]
 8025306:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025308:	69fa      	ldr	r2, [r7, #28]
 802530a:	429a      	cmp	r2, r3
 802530c:	d04b      	beq.n	80253a6 <vTaskPriorityDisinheritAfterTimeout+0xee>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 802530e:	69bb      	ldr	r3, [r7, #24]
 8025310:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8025312:	697a      	ldr	r2, [r7, #20]
 8025314:	429a      	cmp	r2, r3
 8025316:	d146      	bne.n	80253a6 <vTaskPriorityDisinheritAfterTimeout+0xee>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
 8025318:	4b25      	ldr	r3, [pc, #148]	; (80253b0 <vTaskPriorityDisinheritAfterTimeout+0xf8>)
 802531a:	681b      	ldr	r3, [r3, #0]
 802531c:	69ba      	ldr	r2, [r7, #24]
 802531e:	429a      	cmp	r2, r3
 8025320:	d10a      	bne.n	8025338 <vTaskPriorityDisinheritAfterTimeout+0x80>
	__asm volatile
 8025322:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025326:	f383 8811 	msr	BASEPRI, r3
 802532a:	f3bf 8f6f 	isb	sy
 802532e:	f3bf 8f4f 	dsb	sy
 8025332:	60bb      	str	r3, [r7, #8]
}
 8025334:	bf00      	nop
 8025336:	e7fe      	b.n	8025336 <vTaskPriorityDisinheritAfterTimeout+0x7e>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8025338:	69bb      	ldr	r3, [r7, #24]
 802533a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802533c:	613b      	str	r3, [r7, #16]
					pxTCB->uxPriority = uxPriorityToUse;
 802533e:	69bb      	ldr	r3, [r7, #24]
 8025340:	69fa      	ldr	r2, [r7, #28]
 8025342:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8025344:	69bb      	ldr	r3, [r7, #24]
 8025346:	699b      	ldr	r3, [r3, #24]
 8025348:	2b00      	cmp	r3, #0
 802534a:	db04      	blt.n	8025356 <vTaskPriorityDisinheritAfterTimeout+0x9e>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 802534c:	69fb      	ldr	r3, [r7, #28]
 802534e:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
 8025352:	69bb      	ldr	r3, [r7, #24]
 8025354:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8025356:	69bb      	ldr	r3, [r7, #24]
 8025358:	6959      	ldr	r1, [r3, #20]
 802535a:	693a      	ldr	r2, [r7, #16]
 802535c:	4613      	mov	r3, r2
 802535e:	009b      	lsls	r3, r3, #2
 8025360:	4413      	add	r3, r2
 8025362:	009b      	lsls	r3, r3, #2
 8025364:	4a13      	ldr	r2, [pc, #76]	; (80253b4 <vTaskPriorityDisinheritAfterTimeout+0xfc>)
 8025366:	4413      	add	r3, r2
 8025368:	4299      	cmp	r1, r3
 802536a:	d11c      	bne.n	80253a6 <vTaskPriorityDisinheritAfterTimeout+0xee>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 802536c:	69bb      	ldr	r3, [r7, #24]
 802536e:	3304      	adds	r3, #4
 8025370:	4618      	mov	r0, r3
 8025372:	f7fd ff67 	bl	8023244 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 8025376:	69bb      	ldr	r3, [r7, #24]
 8025378:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802537a:	4b0f      	ldr	r3, [pc, #60]	; (80253b8 <vTaskPriorityDisinheritAfterTimeout+0x100>)
 802537c:	681b      	ldr	r3, [r3, #0]
 802537e:	429a      	cmp	r2, r3
 8025380:	d903      	bls.n	802538a <vTaskPriorityDisinheritAfterTimeout+0xd2>
 8025382:	69bb      	ldr	r3, [r7, #24]
 8025384:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025386:	4a0c      	ldr	r2, [pc, #48]	; (80253b8 <vTaskPriorityDisinheritAfterTimeout+0x100>)
 8025388:	6013      	str	r3, [r2, #0]
 802538a:	69bb      	ldr	r3, [r7, #24]
 802538c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802538e:	4613      	mov	r3, r2
 8025390:	009b      	lsls	r3, r3, #2
 8025392:	4413      	add	r3, r2
 8025394:	009b      	lsls	r3, r3, #2
 8025396:	4a07      	ldr	r2, [pc, #28]	; (80253b4 <vTaskPriorityDisinheritAfterTimeout+0xfc>)
 8025398:	441a      	add	r2, r3
 802539a:	69bb      	ldr	r3, [r7, #24]
 802539c:	3304      	adds	r3, #4
 802539e:	4619      	mov	r1, r3
 80253a0:	4610      	mov	r0, r2
 80253a2:	f7fd fef2 	bl	802318a <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80253a6:	bf00      	nop
 80253a8:	3720      	adds	r7, #32
 80253aa:	46bd      	mov	sp, r7
 80253ac:	bd80      	pop	{r7, pc}
 80253ae:	bf00      	nop
 80253b0:	20004248 	.word	0x20004248
 80253b4:	2000424c 	.word	0x2000424c
 80253b8:	20004724 	.word	0x20004724

080253bc <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 80253bc:	b480      	push	{r7}
 80253be:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 80253c0:	4b07      	ldr	r3, [pc, #28]	; (80253e0 <pvTaskIncrementMutexHeldCount+0x24>)
 80253c2:	681b      	ldr	r3, [r3, #0]
 80253c4:	2b00      	cmp	r3, #0
 80253c6:	d004      	beq.n	80253d2 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 80253c8:	4b05      	ldr	r3, [pc, #20]	; (80253e0 <pvTaskIncrementMutexHeldCount+0x24>)
 80253ca:	681b      	ldr	r3, [r3, #0]
 80253cc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80253ce:	3201      	adds	r2, #1
 80253d0:	651a      	str	r2, [r3, #80]	; 0x50
		}

		return pxCurrentTCB;
 80253d2:	4b03      	ldr	r3, [pc, #12]	; (80253e0 <pvTaskIncrementMutexHeldCount+0x24>)
 80253d4:	681b      	ldr	r3, [r3, #0]
	}
 80253d6:	4618      	mov	r0, r3
 80253d8:	46bd      	mov	sp, r7
 80253da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80253de:	4770      	bx	lr
 80253e0:	20004248 	.word	0x20004248

080253e4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 80253e4:	b580      	push	{r7, lr}
 80253e6:	b086      	sub	sp, #24
 80253e8:	af00      	add	r7, sp, #0
 80253ea:	60f8      	str	r0, [r7, #12]
 80253ec:	60b9      	str	r1, [r7, #8]
 80253ee:	607a      	str	r2, [r7, #4]
 80253f0:	603b      	str	r3, [r7, #0]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 80253f2:	f000 ff7f 	bl	80262f4 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 80253f6:	4b29      	ldr	r3, [pc, #164]	; (802549c <xTaskNotifyWait+0xb8>)
 80253f8:	681b      	ldr	r3, [r3, #0]
 80253fa:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
 80253fe:	b2db      	uxtb	r3, r3
 8025400:	2b02      	cmp	r3, #2
 8025402:	d01c      	beq.n	802543e <xTaskNotifyWait+0x5a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 8025404:	4b25      	ldr	r3, [pc, #148]	; (802549c <xTaskNotifyWait+0xb8>)
 8025406:	681b      	ldr	r3, [r3, #0]
 8025408:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
 802540c:	68fa      	ldr	r2, [r7, #12]
 802540e:	43d2      	mvns	r2, r2
 8025410:	400a      	ands	r2, r1
 8025412:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 8025416:	4b21      	ldr	r3, [pc, #132]	; (802549c <xTaskNotifyWait+0xb8>)
 8025418:	681b      	ldr	r3, [r3, #0]
 802541a:	2201      	movs	r2, #1
 802541c:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

				if( xTicksToWait > ( TickType_t ) 0 )
 8025420:	683b      	ldr	r3, [r7, #0]
 8025422:	2b00      	cmp	r3, #0
 8025424:	d00b      	beq.n	802543e <xTaskNotifyWait+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8025426:	2101      	movs	r1, #1
 8025428:	6838      	ldr	r0, [r7, #0]
 802542a:	f000 f9dd 	bl	80257e8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 802542e:	4b1c      	ldr	r3, [pc, #112]	; (80254a0 <xTaskNotifyWait+0xbc>)
 8025430:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025434:	601a      	str	r2, [r3, #0]
 8025436:	f3bf 8f4f 	dsb	sy
 802543a:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 802543e:	f000 ff89 	bl	8026354 <vPortExitCritical>

		taskENTER_CRITICAL();
 8025442:	f000 ff57 	bl	80262f4 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 8025446:	687b      	ldr	r3, [r7, #4]
 8025448:	2b00      	cmp	r3, #0
 802544a:	d005      	beq.n	8025458 <xTaskNotifyWait+0x74>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 802544c:	4b13      	ldr	r3, [pc, #76]	; (802549c <xTaskNotifyWait+0xb8>)
 802544e:	681b      	ldr	r3, [r3, #0]
 8025450:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8025454:	687b      	ldr	r3, [r7, #4]
 8025456:	601a      	str	r2, [r3, #0]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 8025458:	4b10      	ldr	r3, [pc, #64]	; (802549c <xTaskNotifyWait+0xb8>)
 802545a:	681b      	ldr	r3, [r3, #0]
 802545c:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
 8025460:	b2db      	uxtb	r3, r3
 8025462:	2b02      	cmp	r3, #2
 8025464:	d002      	beq.n	802546c <xTaskNotifyWait+0x88>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 8025466:	2300      	movs	r3, #0
 8025468:	617b      	str	r3, [r7, #20]
 802546a:	e00a      	b.n	8025482 <xTaskNotifyWait+0x9e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 802546c:	4b0b      	ldr	r3, [pc, #44]	; (802549c <xTaskNotifyWait+0xb8>)
 802546e:	681b      	ldr	r3, [r3, #0]
 8025470:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
 8025474:	68ba      	ldr	r2, [r7, #8]
 8025476:	43d2      	mvns	r2, r2
 8025478:	400a      	ands	r2, r1
 802547a:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
				xReturn = pdTRUE;
 802547e:	2301      	movs	r3, #1
 8025480:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8025482:	4b06      	ldr	r3, [pc, #24]	; (802549c <xTaskNotifyWait+0xb8>)
 8025484:	681b      	ldr	r3, [r3, #0]
 8025486:	2200      	movs	r2, #0
 8025488:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
		}
		taskEXIT_CRITICAL();
 802548c:	f000 ff62 	bl	8026354 <vPortExitCritical>

		return xReturn;
 8025490:	697b      	ldr	r3, [r7, #20]
	}
 8025492:	4618      	mov	r0, r3
 8025494:	3718      	adds	r7, #24
 8025496:	46bd      	mov	sp, r7
 8025498:	bd80      	pop	{r7, pc}
 802549a:	bf00      	nop
 802549c:	20004248 	.word	0x20004248
 80254a0:	e000ed04 	.word	0xe000ed04

080254a4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 80254a4:	b580      	push	{r7, lr}
 80254a6:	b08a      	sub	sp, #40	; 0x28
 80254a8:	af00      	add	r7, sp, #0
 80254aa:	60f8      	str	r0, [r7, #12]
 80254ac:	60b9      	str	r1, [r7, #8]
 80254ae:	603b      	str	r3, [r7, #0]
 80254b0:	4613      	mov	r3, r2
 80254b2:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 80254b4:	2301      	movs	r3, #1
 80254b6:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
 80254b8:	68fb      	ldr	r3, [r7, #12]
 80254ba:	2b00      	cmp	r3, #0
 80254bc:	d10a      	bne.n	80254d4 <xTaskGenericNotify+0x30>
	__asm volatile
 80254be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80254c2:	f383 8811 	msr	BASEPRI, r3
 80254c6:	f3bf 8f6f 	isb	sy
 80254ca:	f3bf 8f4f 	dsb	sy
 80254ce:	61bb      	str	r3, [r7, #24]
}
 80254d0:	bf00      	nop
 80254d2:	e7fe      	b.n	80254d2 <xTaskGenericNotify+0x2e>
		pxTCB = xTaskToNotify;
 80254d4:	68fb      	ldr	r3, [r7, #12]
 80254d6:	623b      	str	r3, [r7, #32]

		taskENTER_CRITICAL();
 80254d8:	f000 ff0c 	bl	80262f4 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 80254dc:	683b      	ldr	r3, [r7, #0]
 80254de:	2b00      	cmp	r3, #0
 80254e0:	d004      	beq.n	80254ec <xTaskGenericNotify+0x48>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 80254e2:	6a3b      	ldr	r3, [r7, #32]
 80254e4:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 80254e8:	683b      	ldr	r3, [r7, #0]
 80254ea:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 80254ec:	6a3b      	ldr	r3, [r7, #32]
 80254ee:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
 80254f2:	77fb      	strb	r3, [r7, #31]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 80254f4:	6a3b      	ldr	r3, [r7, #32]
 80254f6:	2202      	movs	r2, #2
 80254f8:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

			switch( eAction )
 80254fc:	79fb      	ldrb	r3, [r7, #7]
 80254fe:	2b04      	cmp	r3, #4
 8025500:	d82d      	bhi.n	802555e <xTaskGenericNotify+0xba>
 8025502:	a201      	add	r2, pc, #4	; (adr r2, 8025508 <xTaskGenericNotify+0x64>)
 8025504:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025508:	08025581 	.word	0x08025581
 802550c:	0802551d 	.word	0x0802551d
 8025510:	0802552f 	.word	0x0802552f
 8025514:	0802553f 	.word	0x0802553f
 8025518:	08025549 	.word	0x08025549
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 802551c:	6a3b      	ldr	r3, [r7, #32]
 802551e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8025522:	68bb      	ldr	r3, [r7, #8]
 8025524:	431a      	orrs	r2, r3
 8025526:	6a3b      	ldr	r3, [r7, #32]
 8025528:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 802552c:	e02b      	b.n	8025586 <xTaskGenericNotify+0xe2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 802552e:	6a3b      	ldr	r3, [r7, #32]
 8025530:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8025534:	1c5a      	adds	r2, r3, #1
 8025536:	6a3b      	ldr	r3, [r7, #32]
 8025538:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 802553c:	e023      	b.n	8025586 <xTaskGenericNotify+0xe2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 802553e:	6a3b      	ldr	r3, [r7, #32]
 8025540:	68ba      	ldr	r2, [r7, #8]
 8025542:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 8025546:	e01e      	b.n	8025586 <xTaskGenericNotify+0xe2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8025548:	7ffb      	ldrb	r3, [r7, #31]
 802554a:	2b02      	cmp	r3, #2
 802554c:	d004      	beq.n	8025558 <xTaskGenericNotify+0xb4>
					{
						pxTCB->ulNotifiedValue = ulValue;
 802554e:	6a3b      	ldr	r3, [r7, #32]
 8025550:	68ba      	ldr	r2, [r7, #8]
 8025552:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 8025556:	e016      	b.n	8025586 <xTaskGenericNotify+0xe2>
						xReturn = pdFAIL;
 8025558:	2300      	movs	r3, #0
 802555a:	627b      	str	r3, [r7, #36]	; 0x24
					break;
 802555c:	e013      	b.n	8025586 <xTaskGenericNotify+0xe2>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
 802555e:	6a3b      	ldr	r3, [r7, #32]
 8025560:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8025564:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8025568:	d00c      	beq.n	8025584 <xTaskGenericNotify+0xe0>
	__asm volatile
 802556a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802556e:	f383 8811 	msr	BASEPRI, r3
 8025572:	f3bf 8f6f 	isb	sy
 8025576:	f3bf 8f4f 	dsb	sy
 802557a:	617b      	str	r3, [r7, #20]
}
 802557c:	bf00      	nop
 802557e:	e7fe      	b.n	802557e <xTaskGenericNotify+0xda>
					break;
 8025580:	bf00      	nop
 8025582:	e000      	b.n	8025586 <xTaskGenericNotify+0xe2>

					break;
 8025584:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8025586:	7ffb      	ldrb	r3, [r7, #31]
 8025588:	2b01      	cmp	r3, #1
 802558a:	d13a      	bne.n	8025602 <xTaskGenericNotify+0x15e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 802558c:	6a3b      	ldr	r3, [r7, #32]
 802558e:	3304      	adds	r3, #4
 8025590:	4618      	mov	r0, r3
 8025592:	f7fd fe57 	bl	8023244 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8025596:	6a3b      	ldr	r3, [r7, #32]
 8025598:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802559a:	4b1d      	ldr	r3, [pc, #116]	; (8025610 <xTaskGenericNotify+0x16c>)
 802559c:	681b      	ldr	r3, [r3, #0]
 802559e:	429a      	cmp	r2, r3
 80255a0:	d903      	bls.n	80255aa <xTaskGenericNotify+0x106>
 80255a2:	6a3b      	ldr	r3, [r7, #32]
 80255a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80255a6:	4a1a      	ldr	r2, [pc, #104]	; (8025610 <xTaskGenericNotify+0x16c>)
 80255a8:	6013      	str	r3, [r2, #0]
 80255aa:	6a3b      	ldr	r3, [r7, #32]
 80255ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80255ae:	4613      	mov	r3, r2
 80255b0:	009b      	lsls	r3, r3, #2
 80255b2:	4413      	add	r3, r2
 80255b4:	009b      	lsls	r3, r3, #2
 80255b6:	4a17      	ldr	r2, [pc, #92]	; (8025614 <xTaskGenericNotify+0x170>)
 80255b8:	441a      	add	r2, r3
 80255ba:	6a3b      	ldr	r3, [r7, #32]
 80255bc:	3304      	adds	r3, #4
 80255be:	4619      	mov	r1, r3
 80255c0:	4610      	mov	r0, r2
 80255c2:	f7fd fde2 	bl	802318a <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80255c6:	6a3b      	ldr	r3, [r7, #32]
 80255c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80255ca:	2b00      	cmp	r3, #0
 80255cc:	d00a      	beq.n	80255e4 <xTaskGenericNotify+0x140>
	__asm volatile
 80255ce:	f04f 0350 	mov.w	r3, #80	; 0x50
 80255d2:	f383 8811 	msr	BASEPRI, r3
 80255d6:	f3bf 8f6f 	isb	sy
 80255da:	f3bf 8f4f 	dsb	sy
 80255de:	613b      	str	r3, [r7, #16]
}
 80255e0:	bf00      	nop
 80255e2:	e7fe      	b.n	80255e2 <xTaskGenericNotify+0x13e>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80255e4:	6a3b      	ldr	r3, [r7, #32]
 80255e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80255e8:	4b0b      	ldr	r3, [pc, #44]	; (8025618 <xTaskGenericNotify+0x174>)
 80255ea:	681b      	ldr	r3, [r3, #0]
 80255ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80255ee:	429a      	cmp	r2, r3
 80255f0:	d907      	bls.n	8025602 <xTaskGenericNotify+0x15e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 80255f2:	4b0a      	ldr	r3, [pc, #40]	; (802561c <xTaskGenericNotify+0x178>)
 80255f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80255f8:	601a      	str	r2, [r3, #0]
 80255fa:	f3bf 8f4f 	dsb	sy
 80255fe:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8025602:	f000 fea7 	bl	8026354 <vPortExitCritical>

		return xReturn;
 8025606:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
 8025608:	4618      	mov	r0, r3
 802560a:	3728      	adds	r7, #40	; 0x28
 802560c:	46bd      	mov	sp, r7
 802560e:	bd80      	pop	{r7, pc}
 8025610:	20004724 	.word	0x20004724
 8025614:	2000424c 	.word	0x2000424c
 8025618:	20004248 	.word	0x20004248
 802561c:	e000ed04 	.word	0xe000ed04

08025620 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 8025620:	b580      	push	{r7, lr}
 8025622:	b08e      	sub	sp, #56	; 0x38
 8025624:	af00      	add	r7, sp, #0
 8025626:	60f8      	str	r0, [r7, #12]
 8025628:	60b9      	str	r1, [r7, #8]
 802562a:	603b      	str	r3, [r7, #0]
 802562c:	4613      	mov	r3, r2
 802562e:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 8025630:	2301      	movs	r3, #1
 8025632:	637b      	str	r3, [r7, #52]	; 0x34
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 8025634:	68fb      	ldr	r3, [r7, #12]
 8025636:	2b00      	cmp	r3, #0
 8025638:	d10a      	bne.n	8025650 <xTaskGenericNotifyFromISR+0x30>
	__asm volatile
 802563a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802563e:	f383 8811 	msr	BASEPRI, r3
 8025642:	f3bf 8f6f 	isb	sy
 8025646:	f3bf 8f4f 	dsb	sy
 802564a:	627b      	str	r3, [r7, #36]	; 0x24
}
 802564c:	bf00      	nop
 802564e:	e7fe      	b.n	802564e <xTaskGenericNotifyFromISR+0x2e>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8025650:	f000 ff32 	bl	80264b8 <vPortValidateInterruptPriority>

		pxTCB = xTaskToNotify;
 8025654:	68fb      	ldr	r3, [r7, #12]
 8025656:	633b      	str	r3, [r7, #48]	; 0x30
	__asm volatile
 8025658:	f3ef 8211 	mrs	r2, BASEPRI
 802565c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025660:	f383 8811 	msr	BASEPRI, r3
 8025664:	f3bf 8f6f 	isb	sy
 8025668:	f3bf 8f4f 	dsb	sy
 802566c:	623a      	str	r2, [r7, #32]
 802566e:	61fb      	str	r3, [r7, #28]
	return ulOriginalBASEPRI;
 8025670:	6a3b      	ldr	r3, [r7, #32]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8025672:	62fb      	str	r3, [r7, #44]	; 0x2c
		{
			if( pulPreviousNotificationValue != NULL )
 8025674:	683b      	ldr	r3, [r7, #0]
 8025676:	2b00      	cmp	r3, #0
 8025678:	d004      	beq.n	8025684 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 802567a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802567c:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8025680:	683b      	ldr	r3, [r7, #0]
 8025682:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8025684:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025686:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
 802568a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 802568e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025690:	2202      	movs	r2, #2
 8025692:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8

			switch( eAction )
 8025696:	79fb      	ldrb	r3, [r7, #7]
 8025698:	2b04      	cmp	r3, #4
 802569a:	d82f      	bhi.n	80256fc <xTaskGenericNotifyFromISR+0xdc>
 802569c:	a201      	add	r2, pc, #4	; (adr r2, 80256a4 <xTaskGenericNotifyFromISR+0x84>)
 802569e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80256a2:	bf00      	nop
 80256a4:	0802571f 	.word	0x0802571f
 80256a8:	080256b9 	.word	0x080256b9
 80256ac:	080256cb 	.word	0x080256cb
 80256b0:	080256db 	.word	0x080256db
 80256b4:	080256e5 	.word	0x080256e5
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 80256b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256ba:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 80256be:	68bb      	ldr	r3, [r7, #8]
 80256c0:	431a      	orrs	r2, r3
 80256c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256c4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 80256c8:	e02c      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 80256ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80256d0:	1c5a      	adds	r2, r3, #1
 80256d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256d4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 80256d8:	e024      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 80256da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256dc:	68ba      	ldr	r2, [r7, #8]
 80256de:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					break;
 80256e2:	e01f      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 80256e4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80256e8:	2b02      	cmp	r3, #2
 80256ea:	d004      	beq.n	80256f6 <xTaskGenericNotifyFromISR+0xd6>
					{
						pxTCB->ulNotifiedValue = ulValue;
 80256ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256ee:	68ba      	ldr	r2, [r7, #8]
 80256f0:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 80256f4:	e016      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>
						xReturn = pdFAIL;
 80256f6:	2300      	movs	r3, #0
 80256f8:	637b      	str	r3, [r7, #52]	; 0x34
					break;
 80256fa:	e013      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
 80256fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80256fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8025702:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8025706:	d00c      	beq.n	8025722 <xTaskGenericNotifyFromISR+0x102>
	__asm volatile
 8025708:	f04f 0350 	mov.w	r3, #80	; 0x50
 802570c:	f383 8811 	msr	BASEPRI, r3
 8025710:	f3bf 8f6f 	isb	sy
 8025714:	f3bf 8f4f 	dsb	sy
 8025718:	61bb      	str	r3, [r7, #24]
}
 802571a:	bf00      	nop
 802571c:	e7fe      	b.n	802571c <xTaskGenericNotifyFromISR+0xfc>
					break;
 802571e:	bf00      	nop
 8025720:	e000      	b.n	8025724 <xTaskGenericNotifyFromISR+0x104>
					break;
 8025722:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8025724:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8025728:	2b01      	cmp	r3, #1
 802572a:	d146      	bne.n	80257ba <xTaskGenericNotifyFromISR+0x19a>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 802572c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802572e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025730:	2b00      	cmp	r3, #0
 8025732:	d00a      	beq.n	802574a <xTaskGenericNotifyFromISR+0x12a>
	__asm volatile
 8025734:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025738:	f383 8811 	msr	BASEPRI, r3
 802573c:	f3bf 8f6f 	isb	sy
 8025740:	f3bf 8f4f 	dsb	sy
 8025744:	617b      	str	r3, [r7, #20]
}
 8025746:	bf00      	nop
 8025748:	e7fe      	b.n	8025748 <xTaskGenericNotifyFromISR+0x128>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 802574a:	4b21      	ldr	r3, [pc, #132]	; (80257d0 <xTaskGenericNotifyFromISR+0x1b0>)
 802574c:	681b      	ldr	r3, [r3, #0]
 802574e:	2b00      	cmp	r3, #0
 8025750:	d11d      	bne.n	802578e <xTaskGenericNotifyFromISR+0x16e>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8025752:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025754:	3304      	adds	r3, #4
 8025756:	4618      	mov	r0, r3
 8025758:	f7fd fd74 	bl	8023244 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 802575c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802575e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025760:	4b1c      	ldr	r3, [pc, #112]	; (80257d4 <xTaskGenericNotifyFromISR+0x1b4>)
 8025762:	681b      	ldr	r3, [r3, #0]
 8025764:	429a      	cmp	r2, r3
 8025766:	d903      	bls.n	8025770 <xTaskGenericNotifyFromISR+0x150>
 8025768:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802576a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802576c:	4a19      	ldr	r2, [pc, #100]	; (80257d4 <xTaskGenericNotifyFromISR+0x1b4>)
 802576e:	6013      	str	r3, [r2, #0]
 8025770:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025772:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025774:	4613      	mov	r3, r2
 8025776:	009b      	lsls	r3, r3, #2
 8025778:	4413      	add	r3, r2
 802577a:	009b      	lsls	r3, r3, #2
 802577c:	4a16      	ldr	r2, [pc, #88]	; (80257d8 <xTaskGenericNotifyFromISR+0x1b8>)
 802577e:	441a      	add	r2, r3
 8025780:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025782:	3304      	adds	r3, #4
 8025784:	4619      	mov	r1, r3
 8025786:	4610      	mov	r0, r2
 8025788:	f7fd fcff 	bl	802318a <vListInsertEnd>
 802578c:	e005      	b.n	802579a <xTaskGenericNotifyFromISR+0x17a>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 802578e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8025790:	3318      	adds	r3, #24
 8025792:	4619      	mov	r1, r3
 8025794:	4811      	ldr	r0, [pc, #68]	; (80257dc <xTaskGenericNotifyFromISR+0x1bc>)
 8025796:	f7fd fcf8 	bl	802318a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 802579a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802579c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802579e:	4b10      	ldr	r3, [pc, #64]	; (80257e0 <xTaskGenericNotifyFromISR+0x1c0>)
 80257a0:	681b      	ldr	r3, [r3, #0]
 80257a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80257a4:	429a      	cmp	r2, r3
 80257a6:	d908      	bls.n	80257ba <xTaskGenericNotifyFromISR+0x19a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 80257a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80257aa:	2b00      	cmp	r3, #0
 80257ac:	d002      	beq.n	80257b4 <xTaskGenericNotifyFromISR+0x194>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 80257ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80257b0:	2201      	movs	r2, #1
 80257b2:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 80257b4:	4b0b      	ldr	r3, [pc, #44]	; (80257e4 <xTaskGenericNotifyFromISR+0x1c4>)
 80257b6:	2201      	movs	r2, #1
 80257b8:	601a      	str	r2, [r3, #0]
 80257ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80257bc:	613b      	str	r3, [r7, #16]
	__asm volatile
 80257be:	693b      	ldr	r3, [r7, #16]
 80257c0:	f383 8811 	msr	BASEPRI, r3
}
 80257c4:	bf00      	nop
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 80257c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
	}
 80257c8:	4618      	mov	r0, r3
 80257ca:	3738      	adds	r7, #56	; 0x38
 80257cc:	46bd      	mov	sp, r7
 80257ce:	bd80      	pop	{r7, pc}
 80257d0:	20004744 	.word	0x20004744
 80257d4:	20004724 	.word	0x20004724
 80257d8:	2000424c 	.word	0x2000424c
 80257dc:	200046dc 	.word	0x200046dc
 80257e0:	20004248 	.word	0x20004248
 80257e4:	20004730 	.word	0x20004730

080257e8 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80257e8:	b580      	push	{r7, lr}
 80257ea:	b084      	sub	sp, #16
 80257ec:	af00      	add	r7, sp, #0
 80257ee:	6078      	str	r0, [r7, #4]
 80257f0:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80257f2:	4b21      	ldr	r3, [pc, #132]	; (8025878 <prvAddCurrentTaskToDelayedList+0x90>)
 80257f4:	681b      	ldr	r3, [r3, #0]
 80257f6:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80257f8:	4b20      	ldr	r3, [pc, #128]	; (802587c <prvAddCurrentTaskToDelayedList+0x94>)
 80257fa:	681b      	ldr	r3, [r3, #0]
 80257fc:	3304      	adds	r3, #4
 80257fe:	4618      	mov	r0, r3
 8025800:	f7fd fd20 	bl	8023244 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8025804:	687b      	ldr	r3, [r7, #4]
 8025806:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 802580a:	d10a      	bne.n	8025822 <prvAddCurrentTaskToDelayedList+0x3a>
 802580c:	683b      	ldr	r3, [r7, #0]
 802580e:	2b00      	cmp	r3, #0
 8025810:	d007      	beq.n	8025822 <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8025812:	4b1a      	ldr	r3, [pc, #104]	; (802587c <prvAddCurrentTaskToDelayedList+0x94>)
 8025814:	681b      	ldr	r3, [r3, #0]
 8025816:	3304      	adds	r3, #4
 8025818:	4619      	mov	r1, r3
 802581a:	4819      	ldr	r0, [pc, #100]	; (8025880 <prvAddCurrentTaskToDelayedList+0x98>)
 802581c:	f7fd fcb5 	bl	802318a <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8025820:	e026      	b.n	8025870 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8025822:	68fa      	ldr	r2, [r7, #12]
 8025824:	687b      	ldr	r3, [r7, #4]
 8025826:	4413      	add	r3, r2
 8025828:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 802582a:	4b14      	ldr	r3, [pc, #80]	; (802587c <prvAddCurrentTaskToDelayedList+0x94>)
 802582c:	681b      	ldr	r3, [r3, #0]
 802582e:	68ba      	ldr	r2, [r7, #8]
 8025830:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8025832:	68ba      	ldr	r2, [r7, #8]
 8025834:	68fb      	ldr	r3, [r7, #12]
 8025836:	429a      	cmp	r2, r3
 8025838:	d209      	bcs.n	802584e <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 802583a:	4b12      	ldr	r3, [pc, #72]	; (8025884 <prvAddCurrentTaskToDelayedList+0x9c>)
 802583c:	681a      	ldr	r2, [r3, #0]
 802583e:	4b0f      	ldr	r3, [pc, #60]	; (802587c <prvAddCurrentTaskToDelayedList+0x94>)
 8025840:	681b      	ldr	r3, [r3, #0]
 8025842:	3304      	adds	r3, #4
 8025844:	4619      	mov	r1, r3
 8025846:	4610      	mov	r0, r2
 8025848:	f7fd fcc3 	bl	80231d2 <vListInsert>
}
 802584c:	e010      	b.n	8025870 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 802584e:	4b0e      	ldr	r3, [pc, #56]	; (8025888 <prvAddCurrentTaskToDelayedList+0xa0>)
 8025850:	681a      	ldr	r2, [r3, #0]
 8025852:	4b0a      	ldr	r3, [pc, #40]	; (802587c <prvAddCurrentTaskToDelayedList+0x94>)
 8025854:	681b      	ldr	r3, [r3, #0]
 8025856:	3304      	adds	r3, #4
 8025858:	4619      	mov	r1, r3
 802585a:	4610      	mov	r0, r2
 802585c:	f7fd fcb9 	bl	80231d2 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8025860:	4b0a      	ldr	r3, [pc, #40]	; (802588c <prvAddCurrentTaskToDelayedList+0xa4>)
 8025862:	681b      	ldr	r3, [r3, #0]
 8025864:	68ba      	ldr	r2, [r7, #8]
 8025866:	429a      	cmp	r2, r3
 8025868:	d202      	bcs.n	8025870 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
 802586a:	4a08      	ldr	r2, [pc, #32]	; (802588c <prvAddCurrentTaskToDelayedList+0xa4>)
 802586c:	68bb      	ldr	r3, [r7, #8]
 802586e:	6013      	str	r3, [r2, #0]
}
 8025870:	bf00      	nop
 8025872:	3710      	adds	r7, #16
 8025874:	46bd      	mov	sp, r7
 8025876:	bd80      	pop	{r7, pc}
 8025878:	20004720 	.word	0x20004720
 802587c:	20004248 	.word	0x20004248
 8025880:	20004708 	.word	0x20004708
 8025884:	200046d8 	.word	0x200046d8
 8025888:	200046d4 	.word	0x200046d4
 802588c:	2000473c 	.word	0x2000473c

08025890 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 8025890:	b580      	push	{r7, lr}
 8025892:	b08a      	sub	sp, #40	; 0x28
 8025894:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
 8025896:	2300      	movs	r3, #0
 8025898:	617b      	str	r3, [r7, #20]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 802589a:	f000 fba1 	bl	8025fe0 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 802589e:	4b1c      	ldr	r3, [pc, #112]	; (8025910 <xTimerCreateTimerTask+0x80>)
 80258a0:	681b      	ldr	r3, [r3, #0]
 80258a2:	2b00      	cmp	r3, #0
 80258a4:	d021      	beq.n	80258ea <xTimerCreateTimerTask+0x5a>
	{
		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
		{
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 80258a6:	2300      	movs	r3, #0
 80258a8:	60fb      	str	r3, [r7, #12]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 80258aa:	2300      	movs	r3, #0
 80258ac:	60bb      	str	r3, [r7, #8]
			uint32_t ulTimerTaskStackSize;

			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 80258ae:	1d3a      	adds	r2, r7, #4
 80258b0:	f107 0108 	add.w	r1, r7, #8
 80258b4:	f107 030c 	add.w	r3, r7, #12
 80258b8:	4618      	mov	r0, r3
 80258ba:	f7fd fc1f 	bl	80230fc <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 80258be:	6879      	ldr	r1, [r7, #4]
 80258c0:	68bb      	ldr	r3, [r7, #8]
 80258c2:	68fa      	ldr	r2, [r7, #12]
 80258c4:	9202      	str	r2, [sp, #8]
 80258c6:	9301      	str	r3, [sp, #4]
 80258c8:	2302      	movs	r3, #2
 80258ca:	9300      	str	r3, [sp, #0]
 80258cc:	2300      	movs	r3, #0
 80258ce:	460a      	mov	r2, r1
 80258d0:	4910      	ldr	r1, [pc, #64]	; (8025914 <xTimerCreateTimerTask+0x84>)
 80258d2:	4811      	ldr	r0, [pc, #68]	; (8025918 <xTimerCreateTimerTask+0x88>)
 80258d4:	f7fe fda4 	bl	8024420 <xTaskCreateStatic>
 80258d8:	4603      	mov	r3, r0
 80258da:	4a10      	ldr	r2, [pc, #64]	; (802591c <xTimerCreateTimerTask+0x8c>)
 80258dc:	6013      	str	r3, [r2, #0]
													NULL,
													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
													pxTimerTaskStackBuffer,
													pxTimerTaskTCBBuffer );

			if( xTimerTaskHandle != NULL )
 80258de:	4b0f      	ldr	r3, [pc, #60]	; (802591c <xTimerCreateTimerTask+0x8c>)
 80258e0:	681b      	ldr	r3, [r3, #0]
 80258e2:	2b00      	cmp	r3, #0
 80258e4:	d001      	beq.n	80258ea <xTimerCreateTimerTask+0x5a>
			{
				xReturn = pdPASS;
 80258e6:	2301      	movs	r3, #1
 80258e8:	617b      	str	r3, [r7, #20]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 80258ea:	697b      	ldr	r3, [r7, #20]
 80258ec:	2b00      	cmp	r3, #0
 80258ee:	d10a      	bne.n	8025906 <xTimerCreateTimerTask+0x76>
	__asm volatile
 80258f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80258f4:	f383 8811 	msr	BASEPRI, r3
 80258f8:	f3bf 8f6f 	isb	sy
 80258fc:	f3bf 8f4f 	dsb	sy
 8025900:	613b      	str	r3, [r7, #16]
}
 8025902:	bf00      	nop
 8025904:	e7fe      	b.n	8025904 <xTimerCreateTimerTask+0x74>
	return xReturn;
 8025906:	697b      	ldr	r3, [r7, #20]
}
 8025908:	4618      	mov	r0, r3
 802590a:	3718      	adds	r7, #24
 802590c:	46bd      	mov	sp, r7
 802590e:	bd80      	pop	{r7, pc}
 8025910:	20004778 	.word	0x20004778
 8025914:	0802c650 	.word	0x0802c650
 8025918:	08025b89 	.word	0x08025b89
 802591c:	2000477c 	.word	0x2000477c

08025920 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
 8025920:	b580      	push	{r7, lr}
 8025922:	b088      	sub	sp, #32
 8025924:	af02      	add	r7, sp, #8
 8025926:	60f8      	str	r0, [r7, #12]
 8025928:	60b9      	str	r1, [r7, #8]
 802592a:	607a      	str	r2, [r7, #4]
 802592c:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 802592e:	202c      	movs	r0, #44	; 0x2c
 8025930:	f000 fe02 	bl	8026538 <pvPortMalloc>
 8025934:	6178      	str	r0, [r7, #20]

		if( pxNewTimer != NULL )
 8025936:	697b      	ldr	r3, [r7, #20]
 8025938:	2b00      	cmp	r3, #0
 802593a:	d00d      	beq.n	8025958 <xTimerCreate+0x38>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The auto-reload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
 802593c:	697b      	ldr	r3, [r7, #20]
 802593e:	2200      	movs	r2, #0
 8025940:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 8025944:	697b      	ldr	r3, [r7, #20]
 8025946:	9301      	str	r3, [sp, #4]
 8025948:	6a3b      	ldr	r3, [r7, #32]
 802594a:	9300      	str	r3, [sp, #0]
 802594c:	683b      	ldr	r3, [r7, #0]
 802594e:	687a      	ldr	r2, [r7, #4]
 8025950:	68b9      	ldr	r1, [r7, #8]
 8025952:	68f8      	ldr	r0, [r7, #12]
 8025954:	f000 f843 	bl	80259de <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 8025958:	697b      	ldr	r3, [r7, #20]
	}
 802595a:	4618      	mov	r0, r3
 802595c:	3718      	adds	r7, #24
 802595e:	46bd      	mov	sp, r7
 8025960:	bd80      	pop	{r7, pc}

08025962 <xTimerCreateStatic>:
										const TickType_t xTimerPeriodInTicks,
										const UBaseType_t uxAutoReload,
										void * const pvTimerID,
										TimerCallbackFunction_t pxCallbackFunction,
										StaticTimer_t *pxTimerBuffer )
	{
 8025962:	b580      	push	{r7, lr}
 8025964:	b08a      	sub	sp, #40	; 0x28
 8025966:	af02      	add	r7, sp, #8
 8025968:	60f8      	str	r0, [r7, #12]
 802596a:	60b9      	str	r1, [r7, #8]
 802596c:	607a      	str	r2, [r7, #4]
 802596e:	603b      	str	r3, [r7, #0]
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTimer_t equals the size of the real timer
			structure. */
			volatile size_t xSize = sizeof( StaticTimer_t );
 8025970:	232c      	movs	r3, #44	; 0x2c
 8025972:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( Timer_t ) );
 8025974:	693b      	ldr	r3, [r7, #16]
 8025976:	2b2c      	cmp	r3, #44	; 0x2c
 8025978:	d00a      	beq.n	8025990 <xTimerCreateStatic+0x2e>
	__asm volatile
 802597a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802597e:	f383 8811 	msr	BASEPRI, r3
 8025982:	f3bf 8f6f 	isb	sy
 8025986:	f3bf 8f4f 	dsb	sy
 802598a:	61bb      	str	r3, [r7, #24]
}
 802598c:	bf00      	nop
 802598e:	e7fe      	b.n	802598e <xTimerCreateStatic+0x2c>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8025990:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */

		/* A pointer to a StaticTimer_t structure MUST be provided, use it. */
		configASSERT( pxTimerBuffer );
 8025992:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025994:	2b00      	cmp	r3, #0
 8025996:	d10a      	bne.n	80259ae <xTimerCreateStatic+0x4c>
	__asm volatile
 8025998:	f04f 0350 	mov.w	r3, #80	; 0x50
 802599c:	f383 8811 	msr	BASEPRI, r3
 80259a0:	f3bf 8f6f 	isb	sy
 80259a4:	f3bf 8f4f 	dsb	sy
 80259a8:	617b      	str	r3, [r7, #20]
}
 80259aa:	bf00      	nop
 80259ac:	e7fe      	b.n	80259ac <xTimerCreateStatic+0x4a>
		pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointer to a Timer_t, so guaranteed to be aligned and sized correctly (checked by an assert()), so this is safe. */
 80259ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80259b0:	61fb      	str	r3, [r7, #28]

		if( pxNewTimer != NULL )
 80259b2:	69fb      	ldr	r3, [r7, #28]
 80259b4:	2b00      	cmp	r3, #0
 80259b6:	d00d      	beq.n	80259d4 <xTimerCreateStatic+0x72>
		{
			/* Timers can be created statically or dynamically so note this
			timer was created statically in case it is later deleted.  The
			auto-reload bit may get set in prvInitialiseNewTimer(). */
			pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
 80259b8:	69fb      	ldr	r3, [r7, #28]
 80259ba:	2202      	movs	r2, #2
 80259bc:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 80259c0:	69fb      	ldr	r3, [r7, #28]
 80259c2:	9301      	str	r3, [sp, #4]
 80259c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80259c6:	9300      	str	r3, [sp, #0]
 80259c8:	683b      	ldr	r3, [r7, #0]
 80259ca:	687a      	ldr	r2, [r7, #4]
 80259cc:	68b9      	ldr	r1, [r7, #8]
 80259ce:	68f8      	ldr	r0, [r7, #12]
 80259d0:	f000 f805 	bl	80259de <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 80259d4:	69fb      	ldr	r3, [r7, #28]
	}
 80259d6:	4618      	mov	r0, r3
 80259d8:	3720      	adds	r7, #32
 80259da:	46bd      	mov	sp, r7
 80259dc:	bd80      	pop	{r7, pc}

080259de <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
 80259de:	b580      	push	{r7, lr}
 80259e0:	b086      	sub	sp, #24
 80259e2:	af00      	add	r7, sp, #0
 80259e4:	60f8      	str	r0, [r7, #12]
 80259e6:	60b9      	str	r1, [r7, #8]
 80259e8:	607a      	str	r2, [r7, #4]
 80259ea:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 80259ec:	68bb      	ldr	r3, [r7, #8]
 80259ee:	2b00      	cmp	r3, #0
 80259f0:	d10a      	bne.n	8025a08 <prvInitialiseNewTimer+0x2a>
	__asm volatile
 80259f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80259f6:	f383 8811 	msr	BASEPRI, r3
 80259fa:	f3bf 8f6f 	isb	sy
 80259fe:	f3bf 8f4f 	dsb	sy
 8025a02:	617b      	str	r3, [r7, #20]
}
 8025a04:	bf00      	nop
 8025a06:	e7fe      	b.n	8025a06 <prvInitialiseNewTimer+0x28>

	if( pxNewTimer != NULL )
 8025a08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a0a:	2b00      	cmp	r3, #0
 8025a0c:	d01e      	beq.n	8025a4c <prvInitialiseNewTimer+0x6e>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
 8025a0e:	f000 fae7 	bl	8025fe0 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
 8025a12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a14:	68fa      	ldr	r2, [r7, #12]
 8025a16:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8025a18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a1a:	68ba      	ldr	r2, [r7, #8]
 8025a1c:	619a      	str	r2, [r3, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 8025a1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a20:	683a      	ldr	r2, [r7, #0]
 8025a22:	61da      	str	r2, [r3, #28]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8025a24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a26:	6a3a      	ldr	r2, [r7, #32]
 8025a28:	621a      	str	r2, [r3, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8025a2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a2c:	3304      	adds	r3, #4
 8025a2e:	4618      	mov	r0, r3
 8025a30:	f7fd fb9e 	bl	8023170 <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 8025a34:	687b      	ldr	r3, [r7, #4]
 8025a36:	2b00      	cmp	r3, #0
 8025a38:	d008      	beq.n	8025a4c <prvInitialiseNewTimer+0x6e>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8025a3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a3c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025a40:	f043 0304 	orr.w	r3, r3, #4
 8025a44:	b2da      	uxtb	r2, r3
 8025a46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025a48:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
 8025a4c:	bf00      	nop
 8025a4e:	3718      	adds	r7, #24
 8025a50:	46bd      	mov	sp, r7
 8025a52:	bd80      	pop	{r7, pc}

08025a54 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8025a54:	b580      	push	{r7, lr}
 8025a56:	b08a      	sub	sp, #40	; 0x28
 8025a58:	af00      	add	r7, sp, #0
 8025a5a:	60f8      	str	r0, [r7, #12]
 8025a5c:	60b9      	str	r1, [r7, #8]
 8025a5e:	607a      	str	r2, [r7, #4]
 8025a60:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 8025a62:	2300      	movs	r3, #0
 8025a64:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 8025a66:	68fb      	ldr	r3, [r7, #12]
 8025a68:	2b00      	cmp	r3, #0
 8025a6a:	d10a      	bne.n	8025a82 <xTimerGenericCommand+0x2e>
	__asm volatile
 8025a6c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a70:	f383 8811 	msr	BASEPRI, r3
 8025a74:	f3bf 8f6f 	isb	sy
 8025a78:	f3bf 8f4f 	dsb	sy
 8025a7c:	623b      	str	r3, [r7, #32]
}
 8025a7e:	bf00      	nop
 8025a80:	e7fe      	b.n	8025a80 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8025a82:	4b1a      	ldr	r3, [pc, #104]	; (8025aec <xTimerGenericCommand+0x98>)
 8025a84:	681b      	ldr	r3, [r3, #0]
 8025a86:	2b00      	cmp	r3, #0
 8025a88:	d02a      	beq.n	8025ae0 <xTimerGenericCommand+0x8c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8025a8a:	68bb      	ldr	r3, [r7, #8]
 8025a8c:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8025a8e:	687b      	ldr	r3, [r7, #4]
 8025a90:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8025a92:	68fb      	ldr	r3, [r7, #12]
 8025a94:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8025a96:	68bb      	ldr	r3, [r7, #8]
 8025a98:	2b05      	cmp	r3, #5
 8025a9a:	dc18      	bgt.n	8025ace <xTimerGenericCommand+0x7a>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8025a9c:	f7ff fb18 	bl	80250d0 <xTaskGetSchedulerState>
 8025aa0:	4603      	mov	r3, r0
 8025aa2:	2b02      	cmp	r3, #2
 8025aa4:	d109      	bne.n	8025aba <xTimerGenericCommand+0x66>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8025aa6:	4b11      	ldr	r3, [pc, #68]	; (8025aec <xTimerGenericCommand+0x98>)
 8025aa8:	6818      	ldr	r0, [r3, #0]
 8025aaa:	f107 0110 	add.w	r1, r7, #16
 8025aae:	2300      	movs	r3, #0
 8025ab0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8025ab2:	f7fd fe4f 	bl	8023754 <xQueueGenericSend>
 8025ab6:	6278      	str	r0, [r7, #36]	; 0x24
 8025ab8:	e012      	b.n	8025ae0 <xTimerGenericCommand+0x8c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8025aba:	4b0c      	ldr	r3, [pc, #48]	; (8025aec <xTimerGenericCommand+0x98>)
 8025abc:	6818      	ldr	r0, [r3, #0]
 8025abe:	f107 0110 	add.w	r1, r7, #16
 8025ac2:	2300      	movs	r3, #0
 8025ac4:	2200      	movs	r2, #0
 8025ac6:	f7fd fe45 	bl	8023754 <xQueueGenericSend>
 8025aca:	6278      	str	r0, [r7, #36]	; 0x24
 8025acc:	e008      	b.n	8025ae0 <xTimerGenericCommand+0x8c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8025ace:	4b07      	ldr	r3, [pc, #28]	; (8025aec <xTimerGenericCommand+0x98>)
 8025ad0:	6818      	ldr	r0, [r3, #0]
 8025ad2:	f107 0110 	add.w	r1, r7, #16
 8025ad6:	2300      	movs	r3, #0
 8025ad8:	683a      	ldr	r2, [r7, #0]
 8025ada:	f7fd ff39 	bl	8023950 <xQueueGenericSendFromISR>
 8025ade:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 8025ae0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8025ae2:	4618      	mov	r0, r3
 8025ae4:	3728      	adds	r7, #40	; 0x28
 8025ae6:	46bd      	mov	sp, r7
 8025ae8:	bd80      	pop	{r7, pc}
 8025aea:	bf00      	nop
 8025aec:	20004778 	.word	0x20004778

08025af0 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 8025af0:	b580      	push	{r7, lr}
 8025af2:	b088      	sub	sp, #32
 8025af4:	af02      	add	r7, sp, #8
 8025af6:	6078      	str	r0, [r7, #4]
 8025af8:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025afa:	4b22      	ldr	r3, [pc, #136]	; (8025b84 <prvProcessExpiredTimer+0x94>)
 8025afc:	681b      	ldr	r3, [r3, #0]
 8025afe:	68db      	ldr	r3, [r3, #12]
 8025b00:	68db      	ldr	r3, [r3, #12]
 8025b02:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8025b04:	697b      	ldr	r3, [r7, #20]
 8025b06:	3304      	adds	r3, #4
 8025b08:	4618      	mov	r0, r3
 8025b0a:	f7fd fb9b 	bl	8023244 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8025b0e:	697b      	ldr	r3, [r7, #20]
 8025b10:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025b14:	f003 0304 	and.w	r3, r3, #4
 8025b18:	2b00      	cmp	r3, #0
 8025b1a:	d022      	beq.n	8025b62 <prvProcessExpiredTimer+0x72>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8025b1c:	697b      	ldr	r3, [r7, #20]
 8025b1e:	699a      	ldr	r2, [r3, #24]
 8025b20:	687b      	ldr	r3, [r7, #4]
 8025b22:	18d1      	adds	r1, r2, r3
 8025b24:	687b      	ldr	r3, [r7, #4]
 8025b26:	683a      	ldr	r2, [r7, #0]
 8025b28:	6978      	ldr	r0, [r7, #20]
 8025b2a:	f000 f8d1 	bl	8025cd0 <prvInsertTimerInActiveList>
 8025b2e:	4603      	mov	r3, r0
 8025b30:	2b00      	cmp	r3, #0
 8025b32:	d01f      	beq.n	8025b74 <prvProcessExpiredTimer+0x84>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8025b34:	2300      	movs	r3, #0
 8025b36:	9300      	str	r3, [sp, #0]
 8025b38:	2300      	movs	r3, #0
 8025b3a:	687a      	ldr	r2, [r7, #4]
 8025b3c:	2100      	movs	r1, #0
 8025b3e:	6978      	ldr	r0, [r7, #20]
 8025b40:	f7ff ff88 	bl	8025a54 <xTimerGenericCommand>
 8025b44:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 8025b46:	693b      	ldr	r3, [r7, #16]
 8025b48:	2b00      	cmp	r3, #0
 8025b4a:	d113      	bne.n	8025b74 <prvProcessExpiredTimer+0x84>
	__asm volatile
 8025b4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025b50:	f383 8811 	msr	BASEPRI, r3
 8025b54:	f3bf 8f6f 	isb	sy
 8025b58:	f3bf 8f4f 	dsb	sy
 8025b5c:	60fb      	str	r3, [r7, #12]
}
 8025b5e:	bf00      	nop
 8025b60:	e7fe      	b.n	8025b60 <prvProcessExpiredTimer+0x70>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8025b62:	697b      	ldr	r3, [r7, #20]
 8025b64:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025b68:	f023 0301 	bic.w	r3, r3, #1
 8025b6c:	b2da      	uxtb	r2, r3
 8025b6e:	697b      	ldr	r3, [r7, #20]
 8025b70:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8025b74:	697b      	ldr	r3, [r7, #20]
 8025b76:	6a1b      	ldr	r3, [r3, #32]
 8025b78:	6978      	ldr	r0, [r7, #20]
 8025b7a:	4798      	blx	r3
}
 8025b7c:	bf00      	nop
 8025b7e:	3718      	adds	r7, #24
 8025b80:	46bd      	mov	sp, r7
 8025b82:	bd80      	pop	{r7, pc}
 8025b84:	20004770 	.word	0x20004770

08025b88 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 8025b88:	b580      	push	{r7, lr}
 8025b8a:	b084      	sub	sp, #16
 8025b8c:	af00      	add	r7, sp, #0
 8025b8e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8025b90:	f107 0308 	add.w	r3, r7, #8
 8025b94:	4618      	mov	r0, r3
 8025b96:	f000 f857 	bl	8025c48 <prvGetNextExpireTime>
 8025b9a:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8025b9c:	68bb      	ldr	r3, [r7, #8]
 8025b9e:	4619      	mov	r1, r3
 8025ba0:	68f8      	ldr	r0, [r7, #12]
 8025ba2:	f000 f803 	bl	8025bac <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 8025ba6:	f000 f8d5 	bl	8025d54 <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8025baa:	e7f1      	b.n	8025b90 <prvTimerTask+0x8>

08025bac <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 8025bac:	b580      	push	{r7, lr}
 8025bae:	b084      	sub	sp, #16
 8025bb0:	af00      	add	r7, sp, #0
 8025bb2:	6078      	str	r0, [r7, #4]
 8025bb4:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8025bb6:	f7fe fe8f 	bl	80248d8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8025bba:	f107 0308 	add.w	r3, r7, #8
 8025bbe:	4618      	mov	r0, r3
 8025bc0:	f000 f866 	bl	8025c90 <prvSampleTimeNow>
 8025bc4:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 8025bc6:	68bb      	ldr	r3, [r7, #8]
 8025bc8:	2b00      	cmp	r3, #0
 8025bca:	d130      	bne.n	8025c2e <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8025bcc:	683b      	ldr	r3, [r7, #0]
 8025bce:	2b00      	cmp	r3, #0
 8025bd0:	d10a      	bne.n	8025be8 <prvProcessTimerOrBlockTask+0x3c>
 8025bd2:	687a      	ldr	r2, [r7, #4]
 8025bd4:	68fb      	ldr	r3, [r7, #12]
 8025bd6:	429a      	cmp	r2, r3
 8025bd8:	d806      	bhi.n	8025be8 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 8025bda:	f7fe fe8b 	bl	80248f4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 8025bde:	68f9      	ldr	r1, [r7, #12]
 8025be0:	6878      	ldr	r0, [r7, #4]
 8025be2:	f7ff ff85 	bl	8025af0 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 8025be6:	e024      	b.n	8025c32 <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 8025be8:	683b      	ldr	r3, [r7, #0]
 8025bea:	2b00      	cmp	r3, #0
 8025bec:	d008      	beq.n	8025c00 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8025bee:	4b13      	ldr	r3, [pc, #76]	; (8025c3c <prvProcessTimerOrBlockTask+0x90>)
 8025bf0:	681b      	ldr	r3, [r3, #0]
 8025bf2:	681b      	ldr	r3, [r3, #0]
 8025bf4:	2b00      	cmp	r3, #0
 8025bf6:	d101      	bne.n	8025bfc <prvProcessTimerOrBlockTask+0x50>
 8025bf8:	2301      	movs	r3, #1
 8025bfa:	e000      	b.n	8025bfe <prvProcessTimerOrBlockTask+0x52>
 8025bfc:	2300      	movs	r3, #0
 8025bfe:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8025c00:	4b0f      	ldr	r3, [pc, #60]	; (8025c40 <prvProcessTimerOrBlockTask+0x94>)
 8025c02:	6818      	ldr	r0, [r3, #0]
 8025c04:	687a      	ldr	r2, [r7, #4]
 8025c06:	68fb      	ldr	r3, [r7, #12]
 8025c08:	1ad3      	subs	r3, r2, r3
 8025c0a:	683a      	ldr	r2, [r7, #0]
 8025c0c:	4619      	mov	r1, r3
 8025c0e:	f7fe fbd3 	bl	80243b8 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8025c12:	f7fe fe6f 	bl	80248f4 <xTaskResumeAll>
 8025c16:	4603      	mov	r3, r0
 8025c18:	2b00      	cmp	r3, #0
 8025c1a:	d10a      	bne.n	8025c32 <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 8025c1c:	4b09      	ldr	r3, [pc, #36]	; (8025c44 <prvProcessTimerOrBlockTask+0x98>)
 8025c1e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025c22:	601a      	str	r2, [r3, #0]
 8025c24:	f3bf 8f4f 	dsb	sy
 8025c28:	f3bf 8f6f 	isb	sy
}
 8025c2c:	e001      	b.n	8025c32 <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 8025c2e:	f7fe fe61 	bl	80248f4 <xTaskResumeAll>
}
 8025c32:	bf00      	nop
 8025c34:	3710      	adds	r7, #16
 8025c36:	46bd      	mov	sp, r7
 8025c38:	bd80      	pop	{r7, pc}
 8025c3a:	bf00      	nop
 8025c3c:	20004774 	.word	0x20004774
 8025c40:	20004778 	.word	0x20004778
 8025c44:	e000ed04 	.word	0xe000ed04

08025c48 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 8025c48:	b480      	push	{r7}
 8025c4a:	b085      	sub	sp, #20
 8025c4c:	af00      	add	r7, sp, #0
 8025c4e:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8025c50:	4b0e      	ldr	r3, [pc, #56]	; (8025c8c <prvGetNextExpireTime+0x44>)
 8025c52:	681b      	ldr	r3, [r3, #0]
 8025c54:	681b      	ldr	r3, [r3, #0]
 8025c56:	2b00      	cmp	r3, #0
 8025c58:	d101      	bne.n	8025c5e <prvGetNextExpireTime+0x16>
 8025c5a:	2201      	movs	r2, #1
 8025c5c:	e000      	b.n	8025c60 <prvGetNextExpireTime+0x18>
 8025c5e:	2200      	movs	r2, #0
 8025c60:	687b      	ldr	r3, [r7, #4]
 8025c62:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 8025c64:	687b      	ldr	r3, [r7, #4]
 8025c66:	681b      	ldr	r3, [r3, #0]
 8025c68:	2b00      	cmp	r3, #0
 8025c6a:	d105      	bne.n	8025c78 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8025c6c:	4b07      	ldr	r3, [pc, #28]	; (8025c8c <prvGetNextExpireTime+0x44>)
 8025c6e:	681b      	ldr	r3, [r3, #0]
 8025c70:	68db      	ldr	r3, [r3, #12]
 8025c72:	681b      	ldr	r3, [r3, #0]
 8025c74:	60fb      	str	r3, [r7, #12]
 8025c76:	e001      	b.n	8025c7c <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8025c78:	2300      	movs	r3, #0
 8025c7a:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 8025c7c:	68fb      	ldr	r3, [r7, #12]
}
 8025c7e:	4618      	mov	r0, r3
 8025c80:	3714      	adds	r7, #20
 8025c82:	46bd      	mov	sp, r7
 8025c84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025c88:	4770      	bx	lr
 8025c8a:	bf00      	nop
 8025c8c:	20004770 	.word	0x20004770

08025c90 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 8025c90:	b580      	push	{r7, lr}
 8025c92:	b084      	sub	sp, #16
 8025c94:	af00      	add	r7, sp, #0
 8025c96:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8025c98:	f7fe feca 	bl	8024a30 <xTaskGetTickCount>
 8025c9c:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 8025c9e:	4b0b      	ldr	r3, [pc, #44]	; (8025ccc <prvSampleTimeNow+0x3c>)
 8025ca0:	681b      	ldr	r3, [r3, #0]
 8025ca2:	68fa      	ldr	r2, [r7, #12]
 8025ca4:	429a      	cmp	r2, r3
 8025ca6:	d205      	bcs.n	8025cb4 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 8025ca8:	f000 f936 	bl	8025f18 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8025cac:	687b      	ldr	r3, [r7, #4]
 8025cae:	2201      	movs	r2, #1
 8025cb0:	601a      	str	r2, [r3, #0]
 8025cb2:	e002      	b.n	8025cba <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8025cb4:	687b      	ldr	r3, [r7, #4]
 8025cb6:	2200      	movs	r2, #0
 8025cb8:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 8025cba:	4a04      	ldr	r2, [pc, #16]	; (8025ccc <prvSampleTimeNow+0x3c>)
 8025cbc:	68fb      	ldr	r3, [r7, #12]
 8025cbe:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 8025cc0:	68fb      	ldr	r3, [r7, #12]
}
 8025cc2:	4618      	mov	r0, r3
 8025cc4:	3710      	adds	r7, #16
 8025cc6:	46bd      	mov	sp, r7
 8025cc8:	bd80      	pop	{r7, pc}
 8025cca:	bf00      	nop
 8025ccc:	20004780 	.word	0x20004780

08025cd0 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8025cd0:	b580      	push	{r7, lr}
 8025cd2:	b086      	sub	sp, #24
 8025cd4:	af00      	add	r7, sp, #0
 8025cd6:	60f8      	str	r0, [r7, #12]
 8025cd8:	60b9      	str	r1, [r7, #8]
 8025cda:	607a      	str	r2, [r7, #4]
 8025cdc:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 8025cde:	2300      	movs	r3, #0
 8025ce0:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8025ce2:	68fb      	ldr	r3, [r7, #12]
 8025ce4:	68ba      	ldr	r2, [r7, #8]
 8025ce6:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8025ce8:	68fb      	ldr	r3, [r7, #12]
 8025cea:	68fa      	ldr	r2, [r7, #12]
 8025cec:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 8025cee:	68ba      	ldr	r2, [r7, #8]
 8025cf0:	687b      	ldr	r3, [r7, #4]
 8025cf2:	429a      	cmp	r2, r3
 8025cf4:	d812      	bhi.n	8025d1c <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025cf6:	687a      	ldr	r2, [r7, #4]
 8025cf8:	683b      	ldr	r3, [r7, #0]
 8025cfa:	1ad2      	subs	r2, r2, r3
 8025cfc:	68fb      	ldr	r3, [r7, #12]
 8025cfe:	699b      	ldr	r3, [r3, #24]
 8025d00:	429a      	cmp	r2, r3
 8025d02:	d302      	bcc.n	8025d0a <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8025d04:	2301      	movs	r3, #1
 8025d06:	617b      	str	r3, [r7, #20]
 8025d08:	e01b      	b.n	8025d42 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8025d0a:	4b10      	ldr	r3, [pc, #64]	; (8025d4c <prvInsertTimerInActiveList+0x7c>)
 8025d0c:	681a      	ldr	r2, [r3, #0]
 8025d0e:	68fb      	ldr	r3, [r7, #12]
 8025d10:	3304      	adds	r3, #4
 8025d12:	4619      	mov	r1, r3
 8025d14:	4610      	mov	r0, r2
 8025d16:	f7fd fa5c 	bl	80231d2 <vListInsert>
 8025d1a:	e012      	b.n	8025d42 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8025d1c:	687a      	ldr	r2, [r7, #4]
 8025d1e:	683b      	ldr	r3, [r7, #0]
 8025d20:	429a      	cmp	r2, r3
 8025d22:	d206      	bcs.n	8025d32 <prvInsertTimerInActiveList+0x62>
 8025d24:	68ba      	ldr	r2, [r7, #8]
 8025d26:	683b      	ldr	r3, [r7, #0]
 8025d28:	429a      	cmp	r2, r3
 8025d2a:	d302      	bcc.n	8025d32 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 8025d2c:	2301      	movs	r3, #1
 8025d2e:	617b      	str	r3, [r7, #20]
 8025d30:	e007      	b.n	8025d42 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8025d32:	4b07      	ldr	r3, [pc, #28]	; (8025d50 <prvInsertTimerInActiveList+0x80>)
 8025d34:	681a      	ldr	r2, [r3, #0]
 8025d36:	68fb      	ldr	r3, [r7, #12]
 8025d38:	3304      	adds	r3, #4
 8025d3a:	4619      	mov	r1, r3
 8025d3c:	4610      	mov	r0, r2
 8025d3e:	f7fd fa48 	bl	80231d2 <vListInsert>
		}
	}

	return xProcessTimerNow;
 8025d42:	697b      	ldr	r3, [r7, #20]
}
 8025d44:	4618      	mov	r0, r3
 8025d46:	3718      	adds	r7, #24
 8025d48:	46bd      	mov	sp, r7
 8025d4a:	bd80      	pop	{r7, pc}
 8025d4c:	20004774 	.word	0x20004774
 8025d50:	20004770 	.word	0x20004770

08025d54 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 8025d54:	b580      	push	{r7, lr}
 8025d56:	b08e      	sub	sp, #56	; 0x38
 8025d58:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8025d5a:	e0ca      	b.n	8025ef2 <prvProcessReceivedCommands+0x19e>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8025d5c:	687b      	ldr	r3, [r7, #4]
 8025d5e:	2b00      	cmp	r3, #0
 8025d60:	da18      	bge.n	8025d94 <prvProcessReceivedCommands+0x40>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
 8025d62:	1d3b      	adds	r3, r7, #4
 8025d64:	3304      	adds	r3, #4
 8025d66:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
 8025d68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d6a:	2b00      	cmp	r3, #0
 8025d6c:	d10a      	bne.n	8025d84 <prvProcessReceivedCommands+0x30>
	__asm volatile
 8025d6e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025d72:	f383 8811 	msr	BASEPRI, r3
 8025d76:	f3bf 8f6f 	isb	sy
 8025d7a:	f3bf 8f4f 	dsb	sy
 8025d7e:	61fb      	str	r3, [r7, #28]
}
 8025d80:	bf00      	nop
 8025d82:	e7fe      	b.n	8025d82 <prvProcessReceivedCommands+0x2e>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 8025d84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d86:	681b      	ldr	r3, [r3, #0]
 8025d88:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025d8a:	6850      	ldr	r0, [r2, #4]
 8025d8c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8025d8e:	6892      	ldr	r2, [r2, #8]
 8025d90:	4611      	mov	r1, r2
 8025d92:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8025d94:	687b      	ldr	r3, [r7, #4]
 8025d96:	2b00      	cmp	r3, #0
 8025d98:	f2c0 80aa 	blt.w	8025ef0 <prvProcessReceivedCommands+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8025d9c:	68fb      	ldr	r3, [r7, #12]
 8025d9e:	62bb      	str	r3, [r7, #40]	; 0x28

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8025da0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025da2:	695b      	ldr	r3, [r3, #20]
 8025da4:	2b00      	cmp	r3, #0
 8025da6:	d004      	beq.n	8025db2 <prvProcessReceivedCommands+0x5e>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8025da8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025daa:	3304      	adds	r3, #4
 8025dac:	4618      	mov	r0, r3
 8025dae:	f7fd fa49 	bl	8023244 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8025db2:	463b      	mov	r3, r7
 8025db4:	4618      	mov	r0, r3
 8025db6:	f7ff ff6b 	bl	8025c90 <prvSampleTimeNow>
 8025dba:	6278      	str	r0, [r7, #36]	; 0x24

			switch( xMessage.xMessageID )
 8025dbc:	687b      	ldr	r3, [r7, #4]
 8025dbe:	2b09      	cmp	r3, #9
 8025dc0:	f200 8097 	bhi.w	8025ef2 <prvProcessReceivedCommands+0x19e>
 8025dc4:	a201      	add	r2, pc, #4	; (adr r2, 8025dcc <prvProcessReceivedCommands+0x78>)
 8025dc6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025dca:	bf00      	nop
 8025dcc:	08025df5 	.word	0x08025df5
 8025dd0:	08025df5 	.word	0x08025df5
 8025dd4:	08025df5 	.word	0x08025df5
 8025dd8:	08025e69 	.word	0x08025e69
 8025ddc:	08025e7d 	.word	0x08025e7d
 8025de0:	08025ec7 	.word	0x08025ec7
 8025de4:	08025df5 	.word	0x08025df5
 8025de8:	08025df5 	.word	0x08025df5
 8025dec:	08025e69 	.word	0x08025e69
 8025df0:	08025e7d 	.word	0x08025e7d
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8025df4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025df6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025dfa:	f043 0301 	orr.w	r3, r3, #1
 8025dfe:	b2da      	uxtb	r2, r3
 8025e00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e02:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8025e06:	68ba      	ldr	r2, [r7, #8]
 8025e08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e0a:	699b      	ldr	r3, [r3, #24]
 8025e0c:	18d1      	adds	r1, r2, r3
 8025e0e:	68bb      	ldr	r3, [r7, #8]
 8025e10:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025e12:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8025e14:	f7ff ff5c 	bl	8025cd0 <prvInsertTimerInActiveList>
 8025e18:	4603      	mov	r3, r0
 8025e1a:	2b00      	cmp	r3, #0
 8025e1c:	d069      	beq.n	8025ef2 <prvProcessReceivedCommands+0x19e>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8025e1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e20:	6a1b      	ldr	r3, [r3, #32]
 8025e22:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8025e24:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8025e26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e28:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025e2c:	f003 0304 	and.w	r3, r3, #4
 8025e30:	2b00      	cmp	r3, #0
 8025e32:	d05e      	beq.n	8025ef2 <prvProcessReceivedCommands+0x19e>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8025e34:	68ba      	ldr	r2, [r7, #8]
 8025e36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e38:	699b      	ldr	r3, [r3, #24]
 8025e3a:	441a      	add	r2, r3
 8025e3c:	2300      	movs	r3, #0
 8025e3e:	9300      	str	r3, [sp, #0]
 8025e40:	2300      	movs	r3, #0
 8025e42:	2100      	movs	r1, #0
 8025e44:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8025e46:	f7ff fe05 	bl	8025a54 <xTimerGenericCommand>
 8025e4a:	6238      	str	r0, [r7, #32]
							configASSERT( xResult );
 8025e4c:	6a3b      	ldr	r3, [r7, #32]
 8025e4e:	2b00      	cmp	r3, #0
 8025e50:	d14f      	bne.n	8025ef2 <prvProcessReceivedCommands+0x19e>
	__asm volatile
 8025e52:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025e56:	f383 8811 	msr	BASEPRI, r3
 8025e5a:	f3bf 8f6f 	isb	sy
 8025e5e:	f3bf 8f4f 	dsb	sy
 8025e62:	61bb      	str	r3, [r7, #24]
}
 8025e64:	bf00      	nop
 8025e66:	e7fe      	b.n	8025e66 <prvProcessReceivedCommands+0x112>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8025e68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e6a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025e6e:	f023 0301 	bic.w	r3, r3, #1
 8025e72:	b2da      	uxtb	r2, r3
 8025e74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e76:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					break;
 8025e7a:	e03a      	b.n	8025ef2 <prvProcessReceivedCommands+0x19e>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8025e7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e7e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025e82:	f043 0301 	orr.w	r3, r3, #1
 8025e86:	b2da      	uxtb	r2, r3
 8025e88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e8a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8025e8e:	68ba      	ldr	r2, [r7, #8]
 8025e90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e92:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8025e94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025e96:	699b      	ldr	r3, [r3, #24]
 8025e98:	2b00      	cmp	r3, #0
 8025e9a:	d10a      	bne.n	8025eb2 <prvProcessReceivedCommands+0x15e>
	__asm volatile
 8025e9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025ea0:	f383 8811 	msr	BASEPRI, r3
 8025ea4:	f3bf 8f6f 	isb	sy
 8025ea8:	f3bf 8f4f 	dsb	sy
 8025eac:	617b      	str	r3, [r7, #20]
}
 8025eae:	bf00      	nop
 8025eb0:	e7fe      	b.n	8025eb0 <prvProcessReceivedCommands+0x15c>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8025eb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025eb4:	699a      	ldr	r2, [r3, #24]
 8025eb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025eb8:	18d1      	adds	r1, r2, r3
 8025eba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025ebc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8025ebe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8025ec0:	f7ff ff06 	bl	8025cd0 <prvInsertTimerInActiveList>
					break;
 8025ec4:	e015      	b.n	8025ef2 <prvProcessReceivedCommands+0x19e>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8025ec6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025ec8:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025ecc:	f003 0302 	and.w	r3, r3, #2
 8025ed0:	2b00      	cmp	r3, #0
 8025ed2:	d103      	bne.n	8025edc <prvProcessReceivedCommands+0x188>
						{
							vPortFree( pxTimer );
 8025ed4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8025ed6:	f000 fbfb 	bl	80266d0 <vPortFree>
 8025eda:	e00a      	b.n	8025ef2 <prvProcessReceivedCommands+0x19e>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8025edc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025ede:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025ee2:	f023 0301 	bic.w	r3, r3, #1
 8025ee6:	b2da      	uxtb	r2, r3
 8025ee8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025eea:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 8025eee:	e000      	b.n	8025ef2 <prvProcessReceivedCommands+0x19e>

				default	:
					/* Don't expect to get here. */
					break;
			}
		}
 8025ef0:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8025ef2:	4b08      	ldr	r3, [pc, #32]	; (8025f14 <prvProcessReceivedCommands+0x1c0>)
 8025ef4:	681b      	ldr	r3, [r3, #0]
 8025ef6:	1d39      	adds	r1, r7, #4
 8025ef8:	2200      	movs	r2, #0
 8025efa:	4618      	mov	r0, r3
 8025efc:	f7fd fe50 	bl	8023ba0 <xQueueReceive>
 8025f00:	4603      	mov	r3, r0
 8025f02:	2b00      	cmp	r3, #0
 8025f04:	f47f af2a 	bne.w	8025d5c <prvProcessReceivedCommands+0x8>
	}
}
 8025f08:	bf00      	nop
 8025f0a:	bf00      	nop
 8025f0c:	3730      	adds	r7, #48	; 0x30
 8025f0e:	46bd      	mov	sp, r7
 8025f10:	bd80      	pop	{r7, pc}
 8025f12:	bf00      	nop
 8025f14:	20004778 	.word	0x20004778

08025f18 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8025f18:	b580      	push	{r7, lr}
 8025f1a:	b088      	sub	sp, #32
 8025f1c:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8025f1e:	e048      	b.n	8025fb2 <prvSwitchTimerLists+0x9a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8025f20:	4b2d      	ldr	r3, [pc, #180]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025f22:	681b      	ldr	r3, [r3, #0]
 8025f24:	68db      	ldr	r3, [r3, #12]
 8025f26:	681b      	ldr	r3, [r3, #0]
 8025f28:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025f2a:	4b2b      	ldr	r3, [pc, #172]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025f2c:	681b      	ldr	r3, [r3, #0]
 8025f2e:	68db      	ldr	r3, [r3, #12]
 8025f30:	68db      	ldr	r3, [r3, #12]
 8025f32:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8025f34:	68fb      	ldr	r3, [r7, #12]
 8025f36:	3304      	adds	r3, #4
 8025f38:	4618      	mov	r0, r3
 8025f3a:	f7fd f983 	bl	8023244 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8025f3e:	68fb      	ldr	r3, [r7, #12]
 8025f40:	6a1b      	ldr	r3, [r3, #32]
 8025f42:	68f8      	ldr	r0, [r7, #12]
 8025f44:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8025f46:	68fb      	ldr	r3, [r7, #12]
 8025f48:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8025f4c:	f003 0304 	and.w	r3, r3, #4
 8025f50:	2b00      	cmp	r3, #0
 8025f52:	d02e      	beq.n	8025fb2 <prvSwitchTimerLists+0x9a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8025f54:	68fb      	ldr	r3, [r7, #12]
 8025f56:	699b      	ldr	r3, [r3, #24]
 8025f58:	693a      	ldr	r2, [r7, #16]
 8025f5a:	4413      	add	r3, r2
 8025f5c:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
 8025f5e:	68ba      	ldr	r2, [r7, #8]
 8025f60:	693b      	ldr	r3, [r7, #16]
 8025f62:	429a      	cmp	r2, r3
 8025f64:	d90e      	bls.n	8025f84 <prvSwitchTimerLists+0x6c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8025f66:	68fb      	ldr	r3, [r7, #12]
 8025f68:	68ba      	ldr	r2, [r7, #8]
 8025f6a:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8025f6c:	68fb      	ldr	r3, [r7, #12]
 8025f6e:	68fa      	ldr	r2, [r7, #12]
 8025f70:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8025f72:	4b19      	ldr	r3, [pc, #100]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025f74:	681a      	ldr	r2, [r3, #0]
 8025f76:	68fb      	ldr	r3, [r7, #12]
 8025f78:	3304      	adds	r3, #4
 8025f7a:	4619      	mov	r1, r3
 8025f7c:	4610      	mov	r0, r2
 8025f7e:	f7fd f928 	bl	80231d2 <vListInsert>
 8025f82:	e016      	b.n	8025fb2 <prvSwitchTimerLists+0x9a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8025f84:	2300      	movs	r3, #0
 8025f86:	9300      	str	r3, [sp, #0]
 8025f88:	2300      	movs	r3, #0
 8025f8a:	693a      	ldr	r2, [r7, #16]
 8025f8c:	2100      	movs	r1, #0
 8025f8e:	68f8      	ldr	r0, [r7, #12]
 8025f90:	f7ff fd60 	bl	8025a54 <xTimerGenericCommand>
 8025f94:	6078      	str	r0, [r7, #4]
				configASSERT( xResult );
 8025f96:	687b      	ldr	r3, [r7, #4]
 8025f98:	2b00      	cmp	r3, #0
 8025f9a:	d10a      	bne.n	8025fb2 <prvSwitchTimerLists+0x9a>
	__asm volatile
 8025f9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025fa0:	f383 8811 	msr	BASEPRI, r3
 8025fa4:	f3bf 8f6f 	isb	sy
 8025fa8:	f3bf 8f4f 	dsb	sy
 8025fac:	603b      	str	r3, [r7, #0]
}
 8025fae:	bf00      	nop
 8025fb0:	e7fe      	b.n	8025fb0 <prvSwitchTimerLists+0x98>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8025fb2:	4b09      	ldr	r3, [pc, #36]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025fb4:	681b      	ldr	r3, [r3, #0]
 8025fb6:	681b      	ldr	r3, [r3, #0]
 8025fb8:	2b00      	cmp	r3, #0
 8025fba:	d1b1      	bne.n	8025f20 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 8025fbc:	4b06      	ldr	r3, [pc, #24]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025fbe:	681b      	ldr	r3, [r3, #0]
 8025fc0:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 8025fc2:	4b06      	ldr	r3, [pc, #24]	; (8025fdc <prvSwitchTimerLists+0xc4>)
 8025fc4:	681b      	ldr	r3, [r3, #0]
 8025fc6:	4a04      	ldr	r2, [pc, #16]	; (8025fd8 <prvSwitchTimerLists+0xc0>)
 8025fc8:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8025fca:	4a04      	ldr	r2, [pc, #16]	; (8025fdc <prvSwitchTimerLists+0xc4>)
 8025fcc:	697b      	ldr	r3, [r7, #20]
 8025fce:	6013      	str	r3, [r2, #0]
}
 8025fd0:	bf00      	nop
 8025fd2:	3718      	adds	r7, #24
 8025fd4:	46bd      	mov	sp, r7
 8025fd6:	bd80      	pop	{r7, pc}
 8025fd8:	20004770 	.word	0x20004770
 8025fdc:	20004774 	.word	0x20004774

08025fe0 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8025fe0:	b580      	push	{r7, lr}
 8025fe2:	b082      	sub	sp, #8
 8025fe4:	af02      	add	r7, sp, #8
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8025fe6:	f000 f985 	bl	80262f4 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8025fea:	4b15      	ldr	r3, [pc, #84]	; (8026040 <prvCheckForValidListAndQueue+0x60>)
 8025fec:	681b      	ldr	r3, [r3, #0]
 8025fee:	2b00      	cmp	r3, #0
 8025ff0:	d120      	bne.n	8026034 <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
 8025ff2:	4814      	ldr	r0, [pc, #80]	; (8026044 <prvCheckForValidListAndQueue+0x64>)
 8025ff4:	f7fd f89c 	bl	8023130 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8025ff8:	4813      	ldr	r0, [pc, #76]	; (8026048 <prvCheckForValidListAndQueue+0x68>)
 8025ffa:	f7fd f899 	bl	8023130 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 8025ffe:	4b13      	ldr	r3, [pc, #76]	; (802604c <prvCheckForValidListAndQueue+0x6c>)
 8026000:	4a10      	ldr	r2, [pc, #64]	; (8026044 <prvCheckForValidListAndQueue+0x64>)
 8026002:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 8026004:	4b12      	ldr	r3, [pc, #72]	; (8026050 <prvCheckForValidListAndQueue+0x70>)
 8026006:	4a10      	ldr	r2, [pc, #64]	; (8026048 <prvCheckForValidListAndQueue+0x68>)
 8026008:	601a      	str	r2, [r3, #0]
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 802600a:	2300      	movs	r3, #0
 802600c:	9300      	str	r3, [sp, #0]
 802600e:	4b11      	ldr	r3, [pc, #68]	; (8026054 <prvCheckForValidListAndQueue+0x74>)
 8026010:	4a11      	ldr	r2, [pc, #68]	; (8026058 <prvCheckForValidListAndQueue+0x78>)
 8026012:	2110      	movs	r1, #16
 8026014:	200a      	movs	r0, #10
 8026016:	f7fd f9a7 	bl	8023368 <xQueueGenericCreateStatic>
 802601a:	4603      	mov	r3, r0
 802601c:	4a08      	ldr	r2, [pc, #32]	; (8026040 <prvCheckForValidListAndQueue+0x60>)
 802601e:	6013      	str	r3, [r2, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 8026020:	4b07      	ldr	r3, [pc, #28]	; (8026040 <prvCheckForValidListAndQueue+0x60>)
 8026022:	681b      	ldr	r3, [r3, #0]
 8026024:	2b00      	cmp	r3, #0
 8026026:	d005      	beq.n	8026034 <prvCheckForValidListAndQueue+0x54>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8026028:	4b05      	ldr	r3, [pc, #20]	; (8026040 <prvCheckForValidListAndQueue+0x60>)
 802602a:	681b      	ldr	r3, [r3, #0]
 802602c:	490b      	ldr	r1, [pc, #44]	; (802605c <prvCheckForValidListAndQueue+0x7c>)
 802602e:	4618      	mov	r0, r3
 8026030:	f7fe f96e 	bl	8024310 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8026034:	f000 f98e 	bl	8026354 <vPortExitCritical>
}
 8026038:	bf00      	nop
 802603a:	46bd      	mov	sp, r7
 802603c:	bd80      	pop	{r7, pc}
 802603e:	bf00      	nop
 8026040:	20004778 	.word	0x20004778
 8026044:	20004748 	.word	0x20004748
 8026048:	2000475c 	.word	0x2000475c
 802604c:	20004770 	.word	0x20004770
 8026050:	20004774 	.word	0x20004774
 8026054:	20004824 	.word	0x20004824
 8026058:	20004784 	.word	0x20004784
 802605c:	0802c658 	.word	0x0802c658

08026060 <pvTimerGetTimerID>:
	return xReturn;
} /*lint !e818 Can't be pointer to const due to the typedef. */
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 8026060:	b580      	push	{r7, lr}
 8026062:	b086      	sub	sp, #24
 8026064:	af00      	add	r7, sp, #0
 8026066:	6078      	str	r0, [r7, #4]
Timer_t * const pxTimer = xTimer;
 8026068:	687b      	ldr	r3, [r7, #4]
 802606a:	617b      	str	r3, [r7, #20]
void *pvReturn;

	configASSERT( xTimer );
 802606c:	687b      	ldr	r3, [r7, #4]
 802606e:	2b00      	cmp	r3, #0
 8026070:	d10a      	bne.n	8026088 <pvTimerGetTimerID+0x28>
	__asm volatile
 8026072:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026076:	f383 8811 	msr	BASEPRI, r3
 802607a:	f3bf 8f6f 	isb	sy
 802607e:	f3bf 8f4f 	dsb	sy
 8026082:	60fb      	str	r3, [r7, #12]
}
 8026084:	bf00      	nop
 8026086:	e7fe      	b.n	8026086 <pvTimerGetTimerID+0x26>

	taskENTER_CRITICAL();
 8026088:	f000 f934 	bl	80262f4 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 802608c:	697b      	ldr	r3, [r7, #20]
 802608e:	69db      	ldr	r3, [r3, #28]
 8026090:	613b      	str	r3, [r7, #16]
	}
	taskEXIT_CRITICAL();
 8026092:	f000 f95f 	bl	8026354 <vPortExitCritical>

	return pvReturn;
 8026096:	693b      	ldr	r3, [r7, #16]
}
 8026098:	4618      	mov	r0, r3
 802609a:	3718      	adds	r7, #24
 802609c:	46bd      	mov	sp, r7
 802609e:	bd80      	pop	{r7, pc}

080260a0 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 80260a0:	b480      	push	{r7}
 80260a2:	b085      	sub	sp, #20
 80260a4:	af00      	add	r7, sp, #0
 80260a6:	60f8      	str	r0, [r7, #12]
 80260a8:	60b9      	str	r1, [r7, #8]
 80260aa:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 80260ac:	68fb      	ldr	r3, [r7, #12]
 80260ae:	3b04      	subs	r3, #4
 80260b0:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80260b2:	68fb      	ldr	r3, [r7, #12]
 80260b4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80260b8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 80260ba:	68fb      	ldr	r3, [r7, #12]
 80260bc:	3b04      	subs	r3, #4
 80260be:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80260c0:	68bb      	ldr	r3, [r7, #8]
 80260c2:	f023 0201 	bic.w	r2, r3, #1
 80260c6:	68fb      	ldr	r3, [r7, #12]
 80260c8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 80260ca:	68fb      	ldr	r3, [r7, #12]
 80260cc:	3b04      	subs	r3, #4
 80260ce:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80260d0:	4a0c      	ldr	r2, [pc, #48]	; (8026104 <pxPortInitialiseStack+0x64>)
 80260d2:	68fb      	ldr	r3, [r7, #12]
 80260d4:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 80260d6:	68fb      	ldr	r3, [r7, #12]
 80260d8:	3b14      	subs	r3, #20
 80260da:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80260dc:	687a      	ldr	r2, [r7, #4]
 80260de:	68fb      	ldr	r3, [r7, #12]
 80260e0:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 80260e2:	68fb      	ldr	r3, [r7, #12]
 80260e4:	3b04      	subs	r3, #4
 80260e6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80260e8:	68fb      	ldr	r3, [r7, #12]
 80260ea:	f06f 0202 	mvn.w	r2, #2
 80260ee:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 80260f0:	68fb      	ldr	r3, [r7, #12]
 80260f2:	3b20      	subs	r3, #32
 80260f4:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 80260f6:	68fb      	ldr	r3, [r7, #12]
}
 80260f8:	4618      	mov	r0, r3
 80260fa:	3714      	adds	r7, #20
 80260fc:	46bd      	mov	sp, r7
 80260fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026102:	4770      	bx	lr
 8026104:	08026109 	.word	0x08026109

08026108 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8026108:	b480      	push	{r7}
 802610a:	b085      	sub	sp, #20
 802610c:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
 802610e:	2300      	movs	r3, #0
 8026110:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8026112:	4b12      	ldr	r3, [pc, #72]	; (802615c <prvTaskExitError+0x54>)
 8026114:	681b      	ldr	r3, [r3, #0]
 8026116:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 802611a:	d00a      	beq.n	8026132 <prvTaskExitError+0x2a>
	__asm volatile
 802611c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026120:	f383 8811 	msr	BASEPRI, r3
 8026124:	f3bf 8f6f 	isb	sy
 8026128:	f3bf 8f4f 	dsb	sy
 802612c:	60fb      	str	r3, [r7, #12]
}
 802612e:	bf00      	nop
 8026130:	e7fe      	b.n	8026130 <prvTaskExitError+0x28>
	__asm volatile
 8026132:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026136:	f383 8811 	msr	BASEPRI, r3
 802613a:	f3bf 8f6f 	isb	sy
 802613e:	f3bf 8f4f 	dsb	sy
 8026142:	60bb      	str	r3, [r7, #8]
}
 8026144:	bf00      	nop
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8026146:	bf00      	nop
 8026148:	687b      	ldr	r3, [r7, #4]
 802614a:	2b00      	cmp	r3, #0
 802614c:	d0fc      	beq.n	8026148 <prvTaskExitError+0x40>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 802614e:	bf00      	nop
 8026150:	bf00      	nop
 8026152:	3714      	adds	r7, #20
 8026154:	46bd      	mov	sp, r7
 8026156:	f85d 7b04 	ldr.w	r7, [sp], #4
 802615a:	4770      	bx	lr
 802615c:	2000012c 	.word	0x2000012c

08026160 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8026160:	4b07      	ldr	r3, [pc, #28]	; (8026180 <pxCurrentTCBConst2>)
 8026162:	6819      	ldr	r1, [r3, #0]
 8026164:	6808      	ldr	r0, [r1, #0]
 8026166:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802616a:	f380 8809 	msr	PSP, r0
 802616e:	f3bf 8f6f 	isb	sy
 8026172:	f04f 0000 	mov.w	r0, #0
 8026176:	f380 8811 	msr	BASEPRI, r0
 802617a:	4770      	bx	lr
 802617c:	f3af 8000 	nop.w

08026180 <pxCurrentTCBConst2>:
 8026180:	20004248 	.word	0x20004248
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 8026184:	bf00      	nop
 8026186:	bf00      	nop

08026188 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8026188:	4808      	ldr	r0, [pc, #32]	; (80261ac <prvPortStartFirstTask+0x24>)
 802618a:	6800      	ldr	r0, [r0, #0]
 802618c:	6800      	ldr	r0, [r0, #0]
 802618e:	f380 8808 	msr	MSP, r0
 8026192:	f04f 0000 	mov.w	r0, #0
 8026196:	f380 8814 	msr	CONTROL, r0
 802619a:	b662      	cpsie	i
 802619c:	b661      	cpsie	f
 802619e:	f3bf 8f4f 	dsb	sy
 80261a2:	f3bf 8f6f 	isb	sy
 80261a6:	df00      	svc	0
 80261a8:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 80261aa:	bf00      	nop
 80261ac:	e000ed08 	.word	0xe000ed08

080261b0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80261b0:	b580      	push	{r7, lr}
 80261b2:	b086      	sub	sp, #24
 80261b4:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80261b6:	4b46      	ldr	r3, [pc, #280]	; (80262d0 <xPortStartScheduler+0x120>)
 80261b8:	681b      	ldr	r3, [r3, #0]
 80261ba:	4a46      	ldr	r2, [pc, #280]	; (80262d4 <xPortStartScheduler+0x124>)
 80261bc:	4293      	cmp	r3, r2
 80261be:	d10a      	bne.n	80261d6 <xPortStartScheduler+0x26>
	__asm volatile
 80261c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80261c4:	f383 8811 	msr	BASEPRI, r3
 80261c8:	f3bf 8f6f 	isb	sy
 80261cc:	f3bf 8f4f 	dsb	sy
 80261d0:	613b      	str	r3, [r7, #16]
}
 80261d2:	bf00      	nop
 80261d4:	e7fe      	b.n	80261d4 <xPortStartScheduler+0x24>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80261d6:	4b3e      	ldr	r3, [pc, #248]	; (80262d0 <xPortStartScheduler+0x120>)
 80261d8:	681b      	ldr	r3, [r3, #0]
 80261da:	4a3f      	ldr	r2, [pc, #252]	; (80262d8 <xPortStartScheduler+0x128>)
 80261dc:	4293      	cmp	r3, r2
 80261de:	d10a      	bne.n	80261f6 <xPortStartScheduler+0x46>
	__asm volatile
 80261e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80261e4:	f383 8811 	msr	BASEPRI, r3
 80261e8:	f3bf 8f6f 	isb	sy
 80261ec:	f3bf 8f4f 	dsb	sy
 80261f0:	60fb      	str	r3, [r7, #12]
}
 80261f2:	bf00      	nop
 80261f4:	e7fe      	b.n	80261f4 <xPortStartScheduler+0x44>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 80261f6:	4b39      	ldr	r3, [pc, #228]	; (80262dc <xPortStartScheduler+0x12c>)
 80261f8:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80261fa:	697b      	ldr	r3, [r7, #20]
 80261fc:	781b      	ldrb	r3, [r3, #0]
 80261fe:	b2db      	uxtb	r3, r3
 8026200:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8026202:	697b      	ldr	r3, [r7, #20]
 8026204:	22ff      	movs	r2, #255	; 0xff
 8026206:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8026208:	697b      	ldr	r3, [r7, #20]
 802620a:	781b      	ldrb	r3, [r3, #0]
 802620c:	b2db      	uxtb	r3, r3
 802620e:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8026210:	78fb      	ldrb	r3, [r7, #3]
 8026212:	b2db      	uxtb	r3, r3
 8026214:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8026218:	b2da      	uxtb	r2, r3
 802621a:	4b31      	ldr	r3, [pc, #196]	; (80262e0 <xPortStartScheduler+0x130>)
 802621c:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 802621e:	4b31      	ldr	r3, [pc, #196]	; (80262e4 <xPortStartScheduler+0x134>)
 8026220:	2207      	movs	r2, #7
 8026222:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8026224:	e009      	b.n	802623a <xPortStartScheduler+0x8a>
		{
			ulMaxPRIGROUPValue--;
 8026226:	4b2f      	ldr	r3, [pc, #188]	; (80262e4 <xPortStartScheduler+0x134>)
 8026228:	681b      	ldr	r3, [r3, #0]
 802622a:	3b01      	subs	r3, #1
 802622c:	4a2d      	ldr	r2, [pc, #180]	; (80262e4 <xPortStartScheduler+0x134>)
 802622e:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8026230:	78fb      	ldrb	r3, [r7, #3]
 8026232:	b2db      	uxtb	r3, r3
 8026234:	005b      	lsls	r3, r3, #1
 8026236:	b2db      	uxtb	r3, r3
 8026238:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 802623a:	78fb      	ldrb	r3, [r7, #3]
 802623c:	b2db      	uxtb	r3, r3
 802623e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8026242:	2b80      	cmp	r3, #128	; 0x80
 8026244:	d0ef      	beq.n	8026226 <xPortStartScheduler+0x76>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8026246:	4b27      	ldr	r3, [pc, #156]	; (80262e4 <xPortStartScheduler+0x134>)
 8026248:	681b      	ldr	r3, [r3, #0]
 802624a:	f1c3 0307 	rsb	r3, r3, #7
 802624e:	2b04      	cmp	r3, #4
 8026250:	d00a      	beq.n	8026268 <xPortStartScheduler+0xb8>
	__asm volatile
 8026252:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026256:	f383 8811 	msr	BASEPRI, r3
 802625a:	f3bf 8f6f 	isb	sy
 802625e:	f3bf 8f4f 	dsb	sy
 8026262:	60bb      	str	r3, [r7, #8]
}
 8026264:	bf00      	nop
 8026266:	e7fe      	b.n	8026266 <xPortStartScheduler+0xb6>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8026268:	4b1e      	ldr	r3, [pc, #120]	; (80262e4 <xPortStartScheduler+0x134>)
 802626a:	681b      	ldr	r3, [r3, #0]
 802626c:	021b      	lsls	r3, r3, #8
 802626e:	4a1d      	ldr	r2, [pc, #116]	; (80262e4 <xPortStartScheduler+0x134>)
 8026270:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8026272:	4b1c      	ldr	r3, [pc, #112]	; (80262e4 <xPortStartScheduler+0x134>)
 8026274:	681b      	ldr	r3, [r3, #0]
 8026276:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 802627a:	4a1a      	ldr	r2, [pc, #104]	; (80262e4 <xPortStartScheduler+0x134>)
 802627c:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 802627e:	687b      	ldr	r3, [r7, #4]
 8026280:	b2da      	uxtb	r2, r3
 8026282:	697b      	ldr	r3, [r7, #20]
 8026284:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8026286:	4b18      	ldr	r3, [pc, #96]	; (80262e8 <xPortStartScheduler+0x138>)
 8026288:	681b      	ldr	r3, [r3, #0]
 802628a:	4a17      	ldr	r2, [pc, #92]	; (80262e8 <xPortStartScheduler+0x138>)
 802628c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8026290:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8026292:	4b15      	ldr	r3, [pc, #84]	; (80262e8 <xPortStartScheduler+0x138>)
 8026294:	681b      	ldr	r3, [r3, #0]
 8026296:	4a14      	ldr	r2, [pc, #80]	; (80262e8 <xPortStartScheduler+0x138>)
 8026298:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 802629c:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 802629e:	f000 f8dd 	bl	802645c <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 80262a2:	4b12      	ldr	r3, [pc, #72]	; (80262ec <xPortStartScheduler+0x13c>)
 80262a4:	2200      	movs	r2, #0
 80262a6:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 80262a8:	f000 f8fc 	bl	80264a4 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80262ac:	4b10      	ldr	r3, [pc, #64]	; (80262f0 <xPortStartScheduler+0x140>)
 80262ae:	681b      	ldr	r3, [r3, #0]
 80262b0:	4a0f      	ldr	r2, [pc, #60]	; (80262f0 <xPortStartScheduler+0x140>)
 80262b2:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80262b6:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 80262b8:	f7ff ff66 	bl	8026188 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 80262bc:	f7fe fc82 	bl	8024bc4 <vTaskSwitchContext>
	prvTaskExitError();
 80262c0:	f7ff ff22 	bl	8026108 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 80262c4:	2300      	movs	r3, #0
}
 80262c6:	4618      	mov	r0, r3
 80262c8:	3718      	adds	r7, #24
 80262ca:	46bd      	mov	sp, r7
 80262cc:	bd80      	pop	{r7, pc}
 80262ce:	bf00      	nop
 80262d0:	e000ed00 	.word	0xe000ed00
 80262d4:	410fc271 	.word	0x410fc271
 80262d8:	410fc270 	.word	0x410fc270
 80262dc:	e000e400 	.word	0xe000e400
 80262e0:	20004874 	.word	0x20004874
 80262e4:	20004878 	.word	0x20004878
 80262e8:	e000ed20 	.word	0xe000ed20
 80262ec:	2000012c 	.word	0x2000012c
 80262f0:	e000ef34 	.word	0xe000ef34

080262f4 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 80262f4:	b480      	push	{r7}
 80262f6:	b083      	sub	sp, #12
 80262f8:	af00      	add	r7, sp, #0
	__asm volatile
 80262fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80262fe:	f383 8811 	msr	BASEPRI, r3
 8026302:	f3bf 8f6f 	isb	sy
 8026306:	f3bf 8f4f 	dsb	sy
 802630a:	607b      	str	r3, [r7, #4]
}
 802630c:	bf00      	nop
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 802630e:	4b0f      	ldr	r3, [pc, #60]	; (802634c <vPortEnterCritical+0x58>)
 8026310:	681b      	ldr	r3, [r3, #0]
 8026312:	3301      	adds	r3, #1
 8026314:	4a0d      	ldr	r2, [pc, #52]	; (802634c <vPortEnterCritical+0x58>)
 8026316:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8026318:	4b0c      	ldr	r3, [pc, #48]	; (802634c <vPortEnterCritical+0x58>)
 802631a:	681b      	ldr	r3, [r3, #0]
 802631c:	2b01      	cmp	r3, #1
 802631e:	d10f      	bne.n	8026340 <vPortEnterCritical+0x4c>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8026320:	4b0b      	ldr	r3, [pc, #44]	; (8026350 <vPortEnterCritical+0x5c>)
 8026322:	681b      	ldr	r3, [r3, #0]
 8026324:	b2db      	uxtb	r3, r3
 8026326:	2b00      	cmp	r3, #0
 8026328:	d00a      	beq.n	8026340 <vPortEnterCritical+0x4c>
	__asm volatile
 802632a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802632e:	f383 8811 	msr	BASEPRI, r3
 8026332:	f3bf 8f6f 	isb	sy
 8026336:	f3bf 8f4f 	dsb	sy
 802633a:	603b      	str	r3, [r7, #0]
}
 802633c:	bf00      	nop
 802633e:	e7fe      	b.n	802633e <vPortEnterCritical+0x4a>
	}
}
 8026340:	bf00      	nop
 8026342:	370c      	adds	r7, #12
 8026344:	46bd      	mov	sp, r7
 8026346:	f85d 7b04 	ldr.w	r7, [sp], #4
 802634a:	4770      	bx	lr
 802634c:	2000012c 	.word	0x2000012c
 8026350:	e000ed04 	.word	0xe000ed04

08026354 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8026354:	b480      	push	{r7}
 8026356:	b083      	sub	sp, #12
 8026358:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 802635a:	4b12      	ldr	r3, [pc, #72]	; (80263a4 <vPortExitCritical+0x50>)
 802635c:	681b      	ldr	r3, [r3, #0]
 802635e:	2b00      	cmp	r3, #0
 8026360:	d10a      	bne.n	8026378 <vPortExitCritical+0x24>
	__asm volatile
 8026362:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026366:	f383 8811 	msr	BASEPRI, r3
 802636a:	f3bf 8f6f 	isb	sy
 802636e:	f3bf 8f4f 	dsb	sy
 8026372:	607b      	str	r3, [r7, #4]
}
 8026374:	bf00      	nop
 8026376:	e7fe      	b.n	8026376 <vPortExitCritical+0x22>
	uxCriticalNesting--;
 8026378:	4b0a      	ldr	r3, [pc, #40]	; (80263a4 <vPortExitCritical+0x50>)
 802637a:	681b      	ldr	r3, [r3, #0]
 802637c:	3b01      	subs	r3, #1
 802637e:	4a09      	ldr	r2, [pc, #36]	; (80263a4 <vPortExitCritical+0x50>)
 8026380:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8026382:	4b08      	ldr	r3, [pc, #32]	; (80263a4 <vPortExitCritical+0x50>)
 8026384:	681b      	ldr	r3, [r3, #0]
 8026386:	2b00      	cmp	r3, #0
 8026388:	d105      	bne.n	8026396 <vPortExitCritical+0x42>
 802638a:	2300      	movs	r3, #0
 802638c:	603b      	str	r3, [r7, #0]
	__asm volatile
 802638e:	683b      	ldr	r3, [r7, #0]
 8026390:	f383 8811 	msr	BASEPRI, r3
}
 8026394:	bf00      	nop
	{
		portENABLE_INTERRUPTS();
	}
}
 8026396:	bf00      	nop
 8026398:	370c      	adds	r7, #12
 802639a:	46bd      	mov	sp, r7
 802639c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263a0:	4770      	bx	lr
 80263a2:	bf00      	nop
 80263a4:	2000012c 	.word	0x2000012c
	...

080263b0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80263b0:	f3ef 8009 	mrs	r0, PSP
 80263b4:	f3bf 8f6f 	isb	sy
 80263b8:	4b15      	ldr	r3, [pc, #84]	; (8026410 <pxCurrentTCBConst>)
 80263ba:	681a      	ldr	r2, [r3, #0]
 80263bc:	f01e 0f10 	tst.w	lr, #16
 80263c0:	bf08      	it	eq
 80263c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80263c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80263ca:	6010      	str	r0, [r2, #0]
 80263cc:	e92d 0009 	stmdb	sp!, {r0, r3}
 80263d0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80263d4:	f380 8811 	msr	BASEPRI, r0
 80263d8:	f3bf 8f4f 	dsb	sy
 80263dc:	f3bf 8f6f 	isb	sy
 80263e0:	f7fe fbf0 	bl	8024bc4 <vTaskSwitchContext>
 80263e4:	f04f 0000 	mov.w	r0, #0
 80263e8:	f380 8811 	msr	BASEPRI, r0
 80263ec:	bc09      	pop	{r0, r3}
 80263ee:	6819      	ldr	r1, [r3, #0]
 80263f0:	6808      	ldr	r0, [r1, #0]
 80263f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80263f6:	f01e 0f10 	tst.w	lr, #16
 80263fa:	bf08      	it	eq
 80263fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8026400:	f380 8809 	msr	PSP, r0
 8026404:	f3bf 8f6f 	isb	sy
 8026408:	4770      	bx	lr
 802640a:	bf00      	nop
 802640c:	f3af 8000 	nop.w

08026410 <pxCurrentTCBConst>:
 8026410:	20004248 	.word	0x20004248
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 8026414:	bf00      	nop
 8026416:	bf00      	nop

08026418 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8026418:	b580      	push	{r7, lr}
 802641a:	b082      	sub	sp, #8
 802641c:	af00      	add	r7, sp, #0
	__asm volatile
 802641e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026422:	f383 8811 	msr	BASEPRI, r3
 8026426:	f3bf 8f6f 	isb	sy
 802642a:	f3bf 8f4f 	dsb	sy
 802642e:	607b      	str	r3, [r7, #4]
}
 8026430:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8026432:	f7fe fb0d 	bl	8024a50 <xTaskIncrementTick>
 8026436:	4603      	mov	r3, r0
 8026438:	2b00      	cmp	r3, #0
 802643a:	d003      	beq.n	8026444 <xPortSysTickHandler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 802643c:	4b06      	ldr	r3, [pc, #24]	; (8026458 <xPortSysTickHandler+0x40>)
 802643e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8026442:	601a      	str	r2, [r3, #0]
 8026444:	2300      	movs	r3, #0
 8026446:	603b      	str	r3, [r7, #0]
	__asm volatile
 8026448:	683b      	ldr	r3, [r7, #0]
 802644a:	f383 8811 	msr	BASEPRI, r3
}
 802644e:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 8026450:	bf00      	nop
 8026452:	3708      	adds	r7, #8
 8026454:	46bd      	mov	sp, r7
 8026456:	bd80      	pop	{r7, pc}
 8026458:	e000ed04 	.word	0xe000ed04

0802645c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 802645c:	b480      	push	{r7}
 802645e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8026460:	4b0b      	ldr	r3, [pc, #44]	; (8026490 <vPortSetupTimerInterrupt+0x34>)
 8026462:	2200      	movs	r2, #0
 8026464:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8026466:	4b0b      	ldr	r3, [pc, #44]	; (8026494 <vPortSetupTimerInterrupt+0x38>)
 8026468:	2200      	movs	r2, #0
 802646a:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 802646c:	4b0a      	ldr	r3, [pc, #40]	; (8026498 <vPortSetupTimerInterrupt+0x3c>)
 802646e:	681b      	ldr	r3, [r3, #0]
 8026470:	4a0a      	ldr	r2, [pc, #40]	; (802649c <vPortSetupTimerInterrupt+0x40>)
 8026472:	fba2 2303 	umull	r2, r3, r2, r3
 8026476:	099b      	lsrs	r3, r3, #6
 8026478:	4a09      	ldr	r2, [pc, #36]	; (80264a0 <vPortSetupTimerInterrupt+0x44>)
 802647a:	3b01      	subs	r3, #1
 802647c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 802647e:	4b04      	ldr	r3, [pc, #16]	; (8026490 <vPortSetupTimerInterrupt+0x34>)
 8026480:	2207      	movs	r2, #7
 8026482:	601a      	str	r2, [r3, #0]
}
 8026484:	bf00      	nop
 8026486:	46bd      	mov	sp, r7
 8026488:	f85d 7b04 	ldr.w	r7, [sp], #4
 802648c:	4770      	bx	lr
 802648e:	bf00      	nop
 8026490:	e000e010 	.word	0xe000e010
 8026494:	e000e018 	.word	0xe000e018
 8026498:	20000010 	.word	0x20000010
 802649c:	10624dd3 	.word	0x10624dd3
 80264a0:	e000e014 	.word	0xe000e014

080264a4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80264a4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80264b4 <vPortEnableVFP+0x10>
 80264a8:	6801      	ldr	r1, [r0, #0]
 80264aa:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80264ae:	6001      	str	r1, [r0, #0]
 80264b0:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 80264b2:	bf00      	nop
 80264b4:	e000ed88 	.word	0xe000ed88

080264b8 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 80264b8:	b480      	push	{r7}
 80264ba:	b085      	sub	sp, #20
 80264bc:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 80264be:	f3ef 8305 	mrs	r3, IPSR
 80264c2:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 80264c4:	68fb      	ldr	r3, [r7, #12]
 80264c6:	2b0f      	cmp	r3, #15
 80264c8:	d914      	bls.n	80264f4 <vPortValidateInterruptPriority+0x3c>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 80264ca:	4a17      	ldr	r2, [pc, #92]	; (8026528 <vPortValidateInterruptPriority+0x70>)
 80264cc:	68fb      	ldr	r3, [r7, #12]
 80264ce:	4413      	add	r3, r2
 80264d0:	781b      	ldrb	r3, [r3, #0]
 80264d2:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 80264d4:	4b15      	ldr	r3, [pc, #84]	; (802652c <vPortValidateInterruptPriority+0x74>)
 80264d6:	781b      	ldrb	r3, [r3, #0]
 80264d8:	7afa      	ldrb	r2, [r7, #11]
 80264da:	429a      	cmp	r2, r3
 80264dc:	d20a      	bcs.n	80264f4 <vPortValidateInterruptPriority+0x3c>
	__asm volatile
 80264de:	f04f 0350 	mov.w	r3, #80	; 0x50
 80264e2:	f383 8811 	msr	BASEPRI, r3
 80264e6:	f3bf 8f6f 	isb	sy
 80264ea:	f3bf 8f4f 	dsb	sy
 80264ee:	607b      	str	r3, [r7, #4]
}
 80264f0:	bf00      	nop
 80264f2:	e7fe      	b.n	80264f2 <vPortValidateInterruptPriority+0x3a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 80264f4:	4b0e      	ldr	r3, [pc, #56]	; (8026530 <vPortValidateInterruptPriority+0x78>)
 80264f6:	681b      	ldr	r3, [r3, #0]
 80264f8:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 80264fc:	4b0d      	ldr	r3, [pc, #52]	; (8026534 <vPortValidateInterruptPriority+0x7c>)
 80264fe:	681b      	ldr	r3, [r3, #0]
 8026500:	429a      	cmp	r2, r3
 8026502:	d90a      	bls.n	802651a <vPortValidateInterruptPriority+0x62>
	__asm volatile
 8026504:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026508:	f383 8811 	msr	BASEPRI, r3
 802650c:	f3bf 8f6f 	isb	sy
 8026510:	f3bf 8f4f 	dsb	sy
 8026514:	603b      	str	r3, [r7, #0]
}
 8026516:	bf00      	nop
 8026518:	e7fe      	b.n	8026518 <vPortValidateInterruptPriority+0x60>
	}
 802651a:	bf00      	nop
 802651c:	3714      	adds	r7, #20
 802651e:	46bd      	mov	sp, r7
 8026520:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026524:	4770      	bx	lr
 8026526:	bf00      	nop
 8026528:	e000e3f0 	.word	0xe000e3f0
 802652c:	20004874 	.word	0x20004874
 8026530:	e000ed0c 	.word	0xe000ed0c
 8026534:	20004878 	.word	0x20004878

08026538 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8026538:	b580      	push	{r7, lr}
 802653a:	b08a      	sub	sp, #40	; 0x28
 802653c:	af00      	add	r7, sp, #0
 802653e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 8026540:	2300      	movs	r3, #0
 8026542:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 8026544:	f7fe f9c8 	bl	80248d8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 8026548:	4b5b      	ldr	r3, [pc, #364]	; (80266b8 <pvPortMalloc+0x180>)
 802654a:	681b      	ldr	r3, [r3, #0]
 802654c:	2b00      	cmp	r3, #0
 802654e:	d101      	bne.n	8026554 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 8026550:	f000 f920 	bl	8026794 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8026554:	4b59      	ldr	r3, [pc, #356]	; (80266bc <pvPortMalloc+0x184>)
 8026556:	681a      	ldr	r2, [r3, #0]
 8026558:	687b      	ldr	r3, [r7, #4]
 802655a:	4013      	ands	r3, r2
 802655c:	2b00      	cmp	r3, #0
 802655e:	f040 8093 	bne.w	8026688 <pvPortMalloc+0x150>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 8026562:	687b      	ldr	r3, [r7, #4]
 8026564:	2b00      	cmp	r3, #0
 8026566:	d01d      	beq.n	80265a4 <pvPortMalloc+0x6c>
			{
				xWantedSize += xHeapStructSize;
 8026568:	2208      	movs	r2, #8
 802656a:	687b      	ldr	r3, [r7, #4]
 802656c:	4413      	add	r3, r2
 802656e:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8026570:	687b      	ldr	r3, [r7, #4]
 8026572:	f003 0307 	and.w	r3, r3, #7
 8026576:	2b00      	cmp	r3, #0
 8026578:	d014      	beq.n	80265a4 <pvPortMalloc+0x6c>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 802657a:	687b      	ldr	r3, [r7, #4]
 802657c:	f023 0307 	bic.w	r3, r3, #7
 8026580:	3308      	adds	r3, #8
 8026582:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 8026584:	687b      	ldr	r3, [r7, #4]
 8026586:	f003 0307 	and.w	r3, r3, #7
 802658a:	2b00      	cmp	r3, #0
 802658c:	d00a      	beq.n	80265a4 <pvPortMalloc+0x6c>
	__asm volatile
 802658e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026592:	f383 8811 	msr	BASEPRI, r3
 8026596:	f3bf 8f6f 	isb	sy
 802659a:	f3bf 8f4f 	dsb	sy
 802659e:	617b      	str	r3, [r7, #20]
}
 80265a0:	bf00      	nop
 80265a2:	e7fe      	b.n	80265a2 <pvPortMalloc+0x6a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80265a4:	687b      	ldr	r3, [r7, #4]
 80265a6:	2b00      	cmp	r3, #0
 80265a8:	d06e      	beq.n	8026688 <pvPortMalloc+0x150>
 80265aa:	4b45      	ldr	r3, [pc, #276]	; (80266c0 <pvPortMalloc+0x188>)
 80265ac:	681b      	ldr	r3, [r3, #0]
 80265ae:	687a      	ldr	r2, [r7, #4]
 80265b0:	429a      	cmp	r2, r3
 80265b2:	d869      	bhi.n	8026688 <pvPortMalloc+0x150>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 80265b4:	4b43      	ldr	r3, [pc, #268]	; (80266c4 <pvPortMalloc+0x18c>)
 80265b6:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
 80265b8:	4b42      	ldr	r3, [pc, #264]	; (80266c4 <pvPortMalloc+0x18c>)
 80265ba:	681b      	ldr	r3, [r3, #0]
 80265bc:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80265be:	e004      	b.n	80265ca <pvPortMalloc+0x92>
				{
					pxPreviousBlock = pxBlock;
 80265c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265c2:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
 80265c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265c6:	681b      	ldr	r3, [r3, #0]
 80265c8:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80265ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265cc:	685b      	ldr	r3, [r3, #4]
 80265ce:	687a      	ldr	r2, [r7, #4]
 80265d0:	429a      	cmp	r2, r3
 80265d2:	d903      	bls.n	80265dc <pvPortMalloc+0xa4>
 80265d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265d6:	681b      	ldr	r3, [r3, #0]
 80265d8:	2b00      	cmp	r3, #0
 80265da:	d1f1      	bne.n	80265c0 <pvPortMalloc+0x88>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 80265dc:	4b36      	ldr	r3, [pc, #216]	; (80266b8 <pvPortMalloc+0x180>)
 80265de:	681b      	ldr	r3, [r3, #0]
 80265e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80265e2:	429a      	cmp	r2, r3
 80265e4:	d050      	beq.n	8026688 <pvPortMalloc+0x150>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80265e6:	6a3b      	ldr	r3, [r7, #32]
 80265e8:	681b      	ldr	r3, [r3, #0]
 80265ea:	2208      	movs	r2, #8
 80265ec:	4413      	add	r3, r2
 80265ee:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80265f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265f2:	681a      	ldr	r2, [r3, #0]
 80265f4:	6a3b      	ldr	r3, [r7, #32]
 80265f6:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80265f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80265fa:	685a      	ldr	r2, [r3, #4]
 80265fc:	687b      	ldr	r3, [r7, #4]
 80265fe:	1ad2      	subs	r2, r2, r3
 8026600:	2308      	movs	r3, #8
 8026602:	005b      	lsls	r3, r3, #1
 8026604:	429a      	cmp	r2, r3
 8026606:	d91f      	bls.n	8026648 <pvPortMalloc+0x110>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8026608:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802660a:	687b      	ldr	r3, [r7, #4]
 802660c:	4413      	add	r3, r2
 802660e:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8026610:	69bb      	ldr	r3, [r7, #24]
 8026612:	f003 0307 	and.w	r3, r3, #7
 8026616:	2b00      	cmp	r3, #0
 8026618:	d00a      	beq.n	8026630 <pvPortMalloc+0xf8>
	__asm volatile
 802661a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802661e:	f383 8811 	msr	BASEPRI, r3
 8026622:	f3bf 8f6f 	isb	sy
 8026626:	f3bf 8f4f 	dsb	sy
 802662a:	613b      	str	r3, [r7, #16]
}
 802662c:	bf00      	nop
 802662e:	e7fe      	b.n	802662e <pvPortMalloc+0xf6>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8026630:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026632:	685a      	ldr	r2, [r3, #4]
 8026634:	687b      	ldr	r3, [r7, #4]
 8026636:	1ad2      	subs	r2, r2, r3
 8026638:	69bb      	ldr	r3, [r7, #24]
 802663a:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 802663c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802663e:	687a      	ldr	r2, [r7, #4]
 8026640:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8026642:	69b8      	ldr	r0, [r7, #24]
 8026644:	f000 f908 	bl	8026858 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8026648:	4b1d      	ldr	r3, [pc, #116]	; (80266c0 <pvPortMalloc+0x188>)
 802664a:	681a      	ldr	r2, [r3, #0]
 802664c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802664e:	685b      	ldr	r3, [r3, #4]
 8026650:	1ad3      	subs	r3, r2, r3
 8026652:	4a1b      	ldr	r2, [pc, #108]	; (80266c0 <pvPortMalloc+0x188>)
 8026654:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8026656:	4b1a      	ldr	r3, [pc, #104]	; (80266c0 <pvPortMalloc+0x188>)
 8026658:	681a      	ldr	r2, [r3, #0]
 802665a:	4b1b      	ldr	r3, [pc, #108]	; (80266c8 <pvPortMalloc+0x190>)
 802665c:	681b      	ldr	r3, [r3, #0]
 802665e:	429a      	cmp	r2, r3
 8026660:	d203      	bcs.n	802666a <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8026662:	4b17      	ldr	r3, [pc, #92]	; (80266c0 <pvPortMalloc+0x188>)
 8026664:	681b      	ldr	r3, [r3, #0]
 8026666:	4a18      	ldr	r2, [pc, #96]	; (80266c8 <pvPortMalloc+0x190>)
 8026668:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 802666a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802666c:	685a      	ldr	r2, [r3, #4]
 802666e:	4b13      	ldr	r3, [pc, #76]	; (80266bc <pvPortMalloc+0x184>)
 8026670:	681b      	ldr	r3, [r3, #0]
 8026672:	431a      	orrs	r2, r3
 8026674:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026676:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8026678:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802667a:	2200      	movs	r2, #0
 802667c:	601a      	str	r2, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 802667e:	4b13      	ldr	r3, [pc, #76]	; (80266cc <pvPortMalloc+0x194>)
 8026680:	681b      	ldr	r3, [r3, #0]
 8026682:	3301      	adds	r3, #1
 8026684:	4a11      	ldr	r2, [pc, #68]	; (80266cc <pvPortMalloc+0x194>)
 8026686:	6013      	str	r3, [r2, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8026688:	f7fe f934 	bl	80248f4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 802668c:	69fb      	ldr	r3, [r7, #28]
 802668e:	f003 0307 	and.w	r3, r3, #7
 8026692:	2b00      	cmp	r3, #0
 8026694:	d00a      	beq.n	80266ac <pvPortMalloc+0x174>
	__asm volatile
 8026696:	f04f 0350 	mov.w	r3, #80	; 0x50
 802669a:	f383 8811 	msr	BASEPRI, r3
 802669e:	f3bf 8f6f 	isb	sy
 80266a2:	f3bf 8f4f 	dsb	sy
 80266a6:	60fb      	str	r3, [r7, #12]
}
 80266a8:	bf00      	nop
 80266aa:	e7fe      	b.n	80266aa <pvPortMalloc+0x172>
	return pvReturn;
 80266ac:	69fb      	ldr	r3, [r7, #28]
}
 80266ae:	4618      	mov	r0, r3
 80266b0:	3728      	adds	r7, #40	; 0x28
 80266b2:	46bd      	mov	sp, r7
 80266b4:	bd80      	pop	{r7, pc}
 80266b6:	bf00      	nop
 80266b8:	20010bd4 	.word	0x20010bd4
 80266bc:	20010be8 	.word	0x20010be8
 80266c0:	20010bd8 	.word	0x20010bd8
 80266c4:	20010bcc 	.word	0x20010bcc
 80266c8:	20010bdc 	.word	0x20010bdc
 80266cc:	20010be0 	.word	0x20010be0

080266d0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 80266d0:	b580      	push	{r7, lr}
 80266d2:	b086      	sub	sp, #24
 80266d4:	af00      	add	r7, sp, #0
 80266d6:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 80266d8:	687b      	ldr	r3, [r7, #4]
 80266da:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 80266dc:	687b      	ldr	r3, [r7, #4]
 80266de:	2b00      	cmp	r3, #0
 80266e0:	d04d      	beq.n	802677e <vPortFree+0xae>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 80266e2:	2308      	movs	r3, #8
 80266e4:	425b      	negs	r3, r3
 80266e6:	697a      	ldr	r2, [r7, #20]
 80266e8:	4413      	add	r3, r2
 80266ea:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 80266ec:	697b      	ldr	r3, [r7, #20]
 80266ee:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80266f0:	693b      	ldr	r3, [r7, #16]
 80266f2:	685a      	ldr	r2, [r3, #4]
 80266f4:	4b24      	ldr	r3, [pc, #144]	; (8026788 <vPortFree+0xb8>)
 80266f6:	681b      	ldr	r3, [r3, #0]
 80266f8:	4013      	ands	r3, r2
 80266fa:	2b00      	cmp	r3, #0
 80266fc:	d10a      	bne.n	8026714 <vPortFree+0x44>
	__asm volatile
 80266fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026702:	f383 8811 	msr	BASEPRI, r3
 8026706:	f3bf 8f6f 	isb	sy
 802670a:	f3bf 8f4f 	dsb	sy
 802670e:	60fb      	str	r3, [r7, #12]
}
 8026710:	bf00      	nop
 8026712:	e7fe      	b.n	8026712 <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8026714:	693b      	ldr	r3, [r7, #16]
 8026716:	681b      	ldr	r3, [r3, #0]
 8026718:	2b00      	cmp	r3, #0
 802671a:	d00a      	beq.n	8026732 <vPortFree+0x62>
	__asm volatile
 802671c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026720:	f383 8811 	msr	BASEPRI, r3
 8026724:	f3bf 8f6f 	isb	sy
 8026728:	f3bf 8f4f 	dsb	sy
 802672c:	60bb      	str	r3, [r7, #8]
}
 802672e:	bf00      	nop
 8026730:	e7fe      	b.n	8026730 <vPortFree+0x60>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8026732:	693b      	ldr	r3, [r7, #16]
 8026734:	685a      	ldr	r2, [r3, #4]
 8026736:	4b14      	ldr	r3, [pc, #80]	; (8026788 <vPortFree+0xb8>)
 8026738:	681b      	ldr	r3, [r3, #0]
 802673a:	4013      	ands	r3, r2
 802673c:	2b00      	cmp	r3, #0
 802673e:	d01e      	beq.n	802677e <vPortFree+0xae>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 8026740:	693b      	ldr	r3, [r7, #16]
 8026742:	681b      	ldr	r3, [r3, #0]
 8026744:	2b00      	cmp	r3, #0
 8026746:	d11a      	bne.n	802677e <vPortFree+0xae>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8026748:	693b      	ldr	r3, [r7, #16]
 802674a:	685a      	ldr	r2, [r3, #4]
 802674c:	4b0e      	ldr	r3, [pc, #56]	; (8026788 <vPortFree+0xb8>)
 802674e:	681b      	ldr	r3, [r3, #0]
 8026750:	43db      	mvns	r3, r3
 8026752:	401a      	ands	r2, r3
 8026754:	693b      	ldr	r3, [r7, #16]
 8026756:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 8026758:	f7fe f8be 	bl	80248d8 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 802675c:	693b      	ldr	r3, [r7, #16]
 802675e:	685a      	ldr	r2, [r3, #4]
 8026760:	4b0a      	ldr	r3, [pc, #40]	; (802678c <vPortFree+0xbc>)
 8026762:	681b      	ldr	r3, [r3, #0]
 8026764:	4413      	add	r3, r2
 8026766:	4a09      	ldr	r2, [pc, #36]	; (802678c <vPortFree+0xbc>)
 8026768:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 802676a:	6938      	ldr	r0, [r7, #16]
 802676c:	f000 f874 	bl	8026858 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 8026770:	4b07      	ldr	r3, [pc, #28]	; (8026790 <vPortFree+0xc0>)
 8026772:	681b      	ldr	r3, [r3, #0]
 8026774:	3301      	adds	r3, #1
 8026776:	4a06      	ldr	r2, [pc, #24]	; (8026790 <vPortFree+0xc0>)
 8026778:	6013      	str	r3, [r2, #0]
				}
				( void ) xTaskResumeAll();
 802677a:	f7fe f8bb 	bl	80248f4 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 802677e:	bf00      	nop
 8026780:	3718      	adds	r7, #24
 8026782:	46bd      	mov	sp, r7
 8026784:	bd80      	pop	{r7, pc}
 8026786:	bf00      	nop
 8026788:	20010be8 	.word	0x20010be8
 802678c:	20010bd8 	.word	0x20010bd8
 8026790:	20010be4 	.word	0x20010be4

08026794 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 8026794:	b480      	push	{r7}
 8026796:	b085      	sub	sp, #20
 8026798:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 802679a:	f24c 3350 	movw	r3, #50000	; 0xc350
 802679e:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 80267a0:	4b27      	ldr	r3, [pc, #156]	; (8026840 <prvHeapInit+0xac>)
 80267a2:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80267a4:	68fb      	ldr	r3, [r7, #12]
 80267a6:	f003 0307 	and.w	r3, r3, #7
 80267aa:	2b00      	cmp	r3, #0
 80267ac:	d00c      	beq.n	80267c8 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80267ae:	68fb      	ldr	r3, [r7, #12]
 80267b0:	3307      	adds	r3, #7
 80267b2:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80267b4:	68fb      	ldr	r3, [r7, #12]
 80267b6:	f023 0307 	bic.w	r3, r3, #7
 80267ba:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80267bc:	68ba      	ldr	r2, [r7, #8]
 80267be:	68fb      	ldr	r3, [r7, #12]
 80267c0:	1ad3      	subs	r3, r2, r3
 80267c2:	4a1f      	ldr	r2, [pc, #124]	; (8026840 <prvHeapInit+0xac>)
 80267c4:	4413      	add	r3, r2
 80267c6:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 80267c8:	68fb      	ldr	r3, [r7, #12]
 80267ca:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80267cc:	4a1d      	ldr	r2, [pc, #116]	; (8026844 <prvHeapInit+0xb0>)
 80267ce:	687b      	ldr	r3, [r7, #4]
 80267d0:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 80267d2:	4b1c      	ldr	r3, [pc, #112]	; (8026844 <prvHeapInit+0xb0>)
 80267d4:	2200      	movs	r2, #0
 80267d6:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80267d8:	687b      	ldr	r3, [r7, #4]
 80267da:	68ba      	ldr	r2, [r7, #8]
 80267dc:	4413      	add	r3, r2
 80267de:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 80267e0:	2208      	movs	r2, #8
 80267e2:	68fb      	ldr	r3, [r7, #12]
 80267e4:	1a9b      	subs	r3, r3, r2
 80267e6:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80267e8:	68fb      	ldr	r3, [r7, #12]
 80267ea:	f023 0307 	bic.w	r3, r3, #7
 80267ee:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 80267f0:	68fb      	ldr	r3, [r7, #12]
 80267f2:	4a15      	ldr	r2, [pc, #84]	; (8026848 <prvHeapInit+0xb4>)
 80267f4:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 80267f6:	4b14      	ldr	r3, [pc, #80]	; (8026848 <prvHeapInit+0xb4>)
 80267f8:	681b      	ldr	r3, [r3, #0]
 80267fa:	2200      	movs	r2, #0
 80267fc:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 80267fe:	4b12      	ldr	r3, [pc, #72]	; (8026848 <prvHeapInit+0xb4>)
 8026800:	681b      	ldr	r3, [r3, #0]
 8026802:	2200      	movs	r2, #0
 8026804:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 8026806:	687b      	ldr	r3, [r7, #4]
 8026808:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 802680a:	683b      	ldr	r3, [r7, #0]
 802680c:	68fa      	ldr	r2, [r7, #12]
 802680e:	1ad2      	subs	r2, r2, r3
 8026810:	683b      	ldr	r3, [r7, #0]
 8026812:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8026814:	4b0c      	ldr	r3, [pc, #48]	; (8026848 <prvHeapInit+0xb4>)
 8026816:	681a      	ldr	r2, [r3, #0]
 8026818:	683b      	ldr	r3, [r7, #0]
 802681a:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 802681c:	683b      	ldr	r3, [r7, #0]
 802681e:	685b      	ldr	r3, [r3, #4]
 8026820:	4a0a      	ldr	r2, [pc, #40]	; (802684c <prvHeapInit+0xb8>)
 8026822:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8026824:	683b      	ldr	r3, [r7, #0]
 8026826:	685b      	ldr	r3, [r3, #4]
 8026828:	4a09      	ldr	r2, [pc, #36]	; (8026850 <prvHeapInit+0xbc>)
 802682a:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 802682c:	4b09      	ldr	r3, [pc, #36]	; (8026854 <prvHeapInit+0xc0>)
 802682e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8026832:	601a      	str	r2, [r3, #0]
}
 8026834:	bf00      	nop
 8026836:	3714      	adds	r7, #20
 8026838:	46bd      	mov	sp, r7
 802683a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802683e:	4770      	bx	lr
 8026840:	2000487c 	.word	0x2000487c
 8026844:	20010bcc 	.word	0x20010bcc
 8026848:	20010bd4 	.word	0x20010bd4
 802684c:	20010bdc 	.word	0x20010bdc
 8026850:	20010bd8 	.word	0x20010bd8
 8026854:	20010be8 	.word	0x20010be8

08026858 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8026858:	b480      	push	{r7}
 802685a:	b085      	sub	sp, #20
 802685c:	af00      	add	r7, sp, #0
 802685e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8026860:	4b28      	ldr	r3, [pc, #160]	; (8026904 <prvInsertBlockIntoFreeList+0xac>)
 8026862:	60fb      	str	r3, [r7, #12]
 8026864:	e002      	b.n	802686c <prvInsertBlockIntoFreeList+0x14>
 8026866:	68fb      	ldr	r3, [r7, #12]
 8026868:	681b      	ldr	r3, [r3, #0]
 802686a:	60fb      	str	r3, [r7, #12]
 802686c:	68fb      	ldr	r3, [r7, #12]
 802686e:	681b      	ldr	r3, [r3, #0]
 8026870:	687a      	ldr	r2, [r7, #4]
 8026872:	429a      	cmp	r2, r3
 8026874:	d8f7      	bhi.n	8026866 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 8026876:	68fb      	ldr	r3, [r7, #12]
 8026878:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 802687a:	68fb      	ldr	r3, [r7, #12]
 802687c:	685b      	ldr	r3, [r3, #4]
 802687e:	68ba      	ldr	r2, [r7, #8]
 8026880:	4413      	add	r3, r2
 8026882:	687a      	ldr	r2, [r7, #4]
 8026884:	429a      	cmp	r2, r3
 8026886:	d108      	bne.n	802689a <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8026888:	68fb      	ldr	r3, [r7, #12]
 802688a:	685a      	ldr	r2, [r3, #4]
 802688c:	687b      	ldr	r3, [r7, #4]
 802688e:	685b      	ldr	r3, [r3, #4]
 8026890:	441a      	add	r2, r3
 8026892:	68fb      	ldr	r3, [r7, #12]
 8026894:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 8026896:	68fb      	ldr	r3, [r7, #12]
 8026898:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 802689a:	687b      	ldr	r3, [r7, #4]
 802689c:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 802689e:	687b      	ldr	r3, [r7, #4]
 80268a0:	685b      	ldr	r3, [r3, #4]
 80268a2:	68ba      	ldr	r2, [r7, #8]
 80268a4:	441a      	add	r2, r3
 80268a6:	68fb      	ldr	r3, [r7, #12]
 80268a8:	681b      	ldr	r3, [r3, #0]
 80268aa:	429a      	cmp	r2, r3
 80268ac:	d118      	bne.n	80268e0 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80268ae:	68fb      	ldr	r3, [r7, #12]
 80268b0:	681a      	ldr	r2, [r3, #0]
 80268b2:	4b15      	ldr	r3, [pc, #84]	; (8026908 <prvInsertBlockIntoFreeList+0xb0>)
 80268b4:	681b      	ldr	r3, [r3, #0]
 80268b6:	429a      	cmp	r2, r3
 80268b8:	d00d      	beq.n	80268d6 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80268ba:	687b      	ldr	r3, [r7, #4]
 80268bc:	685a      	ldr	r2, [r3, #4]
 80268be:	68fb      	ldr	r3, [r7, #12]
 80268c0:	681b      	ldr	r3, [r3, #0]
 80268c2:	685b      	ldr	r3, [r3, #4]
 80268c4:	441a      	add	r2, r3
 80268c6:	687b      	ldr	r3, [r7, #4]
 80268c8:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80268ca:	68fb      	ldr	r3, [r7, #12]
 80268cc:	681b      	ldr	r3, [r3, #0]
 80268ce:	681a      	ldr	r2, [r3, #0]
 80268d0:	687b      	ldr	r3, [r7, #4]
 80268d2:	601a      	str	r2, [r3, #0]
 80268d4:	e008      	b.n	80268e8 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 80268d6:	4b0c      	ldr	r3, [pc, #48]	; (8026908 <prvInsertBlockIntoFreeList+0xb0>)
 80268d8:	681a      	ldr	r2, [r3, #0]
 80268da:	687b      	ldr	r3, [r7, #4]
 80268dc:	601a      	str	r2, [r3, #0]
 80268de:	e003      	b.n	80268e8 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80268e0:	68fb      	ldr	r3, [r7, #12]
 80268e2:	681a      	ldr	r2, [r3, #0]
 80268e4:	687b      	ldr	r3, [r7, #4]
 80268e6:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80268e8:	68fa      	ldr	r2, [r7, #12]
 80268ea:	687b      	ldr	r3, [r7, #4]
 80268ec:	429a      	cmp	r2, r3
 80268ee:	d002      	beq.n	80268f6 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80268f0:	68fb      	ldr	r3, [r7, #12]
 80268f2:	687a      	ldr	r2, [r7, #4]
 80268f4:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 80268f6:	bf00      	nop
 80268f8:	3714      	adds	r7, #20
 80268fa:	46bd      	mov	sp, r7
 80268fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026900:	4770      	bx	lr
 8026902:	bf00      	nop
 8026904:	20010bcc 	.word	0x20010bcc
 8026908:	20010bd4 	.word	0x20010bd4

0802690c <GasIndexAlgorithm_init_with_sampling_interval>:
GasIndexAlgorithm__adaptive_lowpass__process(GasIndexAlgorithmParams* params,
                                             float sample);

void GasIndexAlgorithm_init_with_sampling_interval(
    GasIndexAlgorithmParams* params, int32_t algorithm_type,
    float sampling_interval) {
 802690c:	b580      	push	{r7, lr}
 802690e:	b084      	sub	sp, #16
 8026910:	af00      	add	r7, sp, #0
 8026912:	60f8      	str	r0, [r7, #12]
 8026914:	60b9      	str	r1, [r7, #8]
 8026916:	ed87 0a01 	vstr	s0, [r7, #4]
    params->mAlgorithm_Type = algorithm_type;
 802691a:	68fb      	ldr	r3, [r7, #12]
 802691c:	68ba      	ldr	r2, [r7, #8]
 802691e:	601a      	str	r2, [r3, #0]
    params->mSamplingInterval = sampling_interval;
 8026920:	68fb      	ldr	r3, [r7, #12]
 8026922:	687a      	ldr	r2, [r7, #4]
 8026924:	605a      	str	r2, [r3, #4]
    if ((algorithm_type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) {
 8026926:	68bb      	ldr	r3, [r7, #8]
 8026928:	2b01      	cmp	r3, #1
 802692a:	d114      	bne.n	8026956 <GasIndexAlgorithm_init_with_sampling_interval+0x4a>
        params->mIndex_Offset = GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT;
 802692c:	68fb      	ldr	r3, [r7, #12]
 802692e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8026932:	609a      	str	r2, [r3, #8]
        params->mSraw_Minimum = GasIndexAlgorithm_NOX_SRAW_MINIMUM;
 8026934:	68fb      	ldr	r3, [r7, #12]
 8026936:	f242 7210 	movw	r2, #10000	; 0x2710
 802693a:	60da      	str	r2, [r3, #12]
        params->mGating_Max_Duration_Minutes =
 802693c:	68fb      	ldr	r3, [r7, #12]
 802693e:	4a19      	ldr	r2, [pc, #100]	; (80269a4 <GasIndexAlgorithm_init_with_sampling_interval+0x98>)
 8026940:	611a      	str	r2, [r3, #16]
            GasIndexAlgorithm_GATING_NOX_MAX_DURATION_MINUTES;
        params->mInit_Duration_Mean = GasIndexAlgorithm_INIT_DURATION_MEAN_NOX;
 8026942:	68fb      	ldr	r3, [r7, #12]
 8026944:	4a18      	ldr	r2, [pc, #96]	; (80269a8 <GasIndexAlgorithm_init_with_sampling_interval+0x9c>)
 8026946:	615a      	str	r2, [r3, #20]
        params->mInit_Duration_Variance =
 8026948:	68fb      	ldr	r3, [r7, #12]
 802694a:	4a18      	ldr	r2, [pc, #96]	; (80269ac <GasIndexAlgorithm_init_with_sampling_interval+0xa0>)
 802694c:	619a      	str	r2, [r3, #24]
            GasIndexAlgorithm_INIT_DURATION_VARIANCE_NOX;
        params->mGating_Threshold = GasIndexAlgorithm_GATING_THRESHOLD_NOX;
 802694e:	68fb      	ldr	r3, [r7, #12]
 8026950:	4a17      	ldr	r2, [pc, #92]	; (80269b0 <GasIndexAlgorithm_init_with_sampling_interval+0xa4>)
 8026952:	61da      	str	r2, [r3, #28]
 8026954:	e012      	b.n	802697c <GasIndexAlgorithm_init_with_sampling_interval+0x70>
    } else {
        params->mIndex_Offset = GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT;
 8026956:	68fb      	ldr	r3, [r7, #12]
 8026958:	4a16      	ldr	r2, [pc, #88]	; (80269b4 <GasIndexAlgorithm_init_with_sampling_interval+0xa8>)
 802695a:	609a      	str	r2, [r3, #8]
        params->mSraw_Minimum = GasIndexAlgorithm_VOC_SRAW_MINIMUM;
 802695c:	68fb      	ldr	r3, [r7, #12]
 802695e:	f644 6220 	movw	r2, #20000	; 0x4e20
 8026962:	60da      	str	r2, [r3, #12]
        params->mGating_Max_Duration_Minutes =
 8026964:	68fb      	ldr	r3, [r7, #12]
 8026966:	4a14      	ldr	r2, [pc, #80]	; (80269b8 <GasIndexAlgorithm_init_with_sampling_interval+0xac>)
 8026968:	611a      	str	r2, [r3, #16]
            GasIndexAlgorithm_GATING_VOC_MAX_DURATION_MINUTES;
        params->mInit_Duration_Mean = GasIndexAlgorithm_INIT_DURATION_MEAN_VOC;
 802696a:	68fb      	ldr	r3, [r7, #12]
 802696c:	4a13      	ldr	r2, [pc, #76]	; (80269bc <GasIndexAlgorithm_init_with_sampling_interval+0xb0>)
 802696e:	615a      	str	r2, [r3, #20]
        params->mInit_Duration_Variance =
 8026970:	68fb      	ldr	r3, [r7, #12]
 8026972:	4a13      	ldr	r2, [pc, #76]	; (80269c0 <GasIndexAlgorithm_init_with_sampling_interval+0xb4>)
 8026974:	619a      	str	r2, [r3, #24]
            GasIndexAlgorithm_INIT_DURATION_VARIANCE_VOC;
        params->mGating_Threshold = GasIndexAlgorithm_GATING_THRESHOLD_VOC;
 8026976:	68fb      	ldr	r3, [r7, #12]
 8026978:	4a12      	ldr	r2, [pc, #72]	; (80269c4 <GasIndexAlgorithm_init_with_sampling_interval+0xb8>)
 802697a:	61da      	str	r2, [r3, #28]
    }
    params->mIndex_Gain = GasIndexAlgorithm_INDEX_GAIN;
 802697c:	68fb      	ldr	r3, [r7, #12]
 802697e:	4a12      	ldr	r2, [pc, #72]	; (80269c8 <GasIndexAlgorithm_init_with_sampling_interval+0xbc>)
 8026980:	621a      	str	r2, [r3, #32]
    params->mTau_Mean_Hours = GasIndexAlgorithm_TAU_MEAN_HOURS;
 8026982:	68fb      	ldr	r3, [r7, #12]
 8026984:	4a11      	ldr	r2, [pc, #68]	; (80269cc <GasIndexAlgorithm_init_with_sampling_interval+0xc0>)
 8026986:	625a      	str	r2, [r3, #36]	; 0x24
    params->mTau_Variance_Hours = GasIndexAlgorithm_TAU_VARIANCE_HOURS;
 8026988:	68fb      	ldr	r3, [r7, #12]
 802698a:	4a10      	ldr	r2, [pc, #64]	; (80269cc <GasIndexAlgorithm_init_with_sampling_interval+0xc0>)
 802698c:	629a      	str	r2, [r3, #40]	; 0x28
    params->mSraw_Std_Initial = GasIndexAlgorithm_SRAW_STD_INITIAL;
 802698e:	68fb      	ldr	r3, [r7, #12]
 8026990:	4a0f      	ldr	r2, [pc, #60]	; (80269d0 <GasIndexAlgorithm_init_with_sampling_interval+0xc4>)
 8026992:	62da      	str	r2, [r3, #44]	; 0x2c
    GasIndexAlgorithm_reset(params);
 8026994:	68f8      	ldr	r0, [r7, #12]
 8026996:	f000 f82c 	bl	80269f2 <GasIndexAlgorithm_reset>
}
 802699a:	bf00      	nop
 802699c:	3710      	adds	r7, #16
 802699e:	46bd      	mov	sp, r7
 80269a0:	bd80      	pop	{r7, pc}
 80269a2:	bf00      	nop
 80269a4:	44340000 	.word	0x44340000
 80269a8:	46859800 	.word	0x46859800
 80269ac:	46a05000 	.word	0x46a05000
 80269b0:	41f00000 	.word	0x41f00000
 80269b4:	42c80000 	.word	0x42c80000
 80269b8:	43340000 	.word	0x43340000
 80269bc:	4528c000 	.word	0x4528c000
 80269c0:	45a32000 	.word	0x45a32000
 80269c4:	43aa0000 	.word	0x43aa0000
 80269c8:	43660000 	.word	0x43660000
 80269cc:	41400000 	.word	0x41400000
 80269d0:	42480000 	.word	0x42480000

080269d4 <GasIndexAlgorithm_init>:

void GasIndexAlgorithm_init(GasIndexAlgorithmParams* params,
                            int32_t algorithm_type) {
 80269d4:	b580      	push	{r7, lr}
 80269d6:	b082      	sub	sp, #8
 80269d8:	af00      	add	r7, sp, #0
 80269da:	6078      	str	r0, [r7, #4]
 80269dc:	6039      	str	r1, [r7, #0]
    GasIndexAlgorithm_init_with_sampling_interval(
 80269de:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80269e2:	6839      	ldr	r1, [r7, #0]
 80269e4:	6878      	ldr	r0, [r7, #4]
 80269e6:	f7ff ff91 	bl	802690c <GasIndexAlgorithm_init_with_sampling_interval>
        params, algorithm_type, GasIndexAlgorithm_DEFAULT_SAMPLING_INTERVAL);
}
 80269ea:	bf00      	nop
 80269ec:	3708      	adds	r7, #8
 80269ee:	46bd      	mov	sp, r7
 80269f0:	bd80      	pop	{r7, pc}

080269f2 <GasIndexAlgorithm_reset>:

void GasIndexAlgorithm_reset(GasIndexAlgorithmParams* params) {
 80269f2:	b580      	push	{r7, lr}
 80269f4:	b082      	sub	sp, #8
 80269f6:	af00      	add	r7, sp, #0
 80269f8:	6078      	str	r0, [r7, #4]
    params->mUptime = 0.f;
 80269fa:	687b      	ldr	r3, [r7, #4]
 80269fc:	f04f 0200 	mov.w	r2, #0
 8026a00:	631a      	str	r2, [r3, #48]	; 0x30
    params->mSraw = 0.f;
 8026a02:	687b      	ldr	r3, [r7, #4]
 8026a04:	f04f 0200 	mov.w	r2, #0
 8026a08:	635a      	str	r2, [r3, #52]	; 0x34
    params->mGas_Index = 0;
 8026a0a:	687b      	ldr	r3, [r7, #4]
 8026a0c:	f04f 0200 	mov.w	r2, #0
 8026a10:	639a      	str	r2, [r3, #56]	; 0x38
    GasIndexAlgorithm__init_instances(params);
 8026a12:	6878      	ldr	r0, [r7, #4]
 8026a14:	f000 f804 	bl	8026a20 <GasIndexAlgorithm__init_instances>
}
 8026a18:	bf00      	nop
 8026a1a:	3708      	adds	r7, #8
 8026a1c:	46bd      	mov	sp, r7
 8026a1e:	bd80      	pop	{r7, pc}

08026a20 <GasIndexAlgorithm__init_instances>:

static void GasIndexAlgorithm__init_instances(GasIndexAlgorithmParams* params) {
 8026a20:	b580      	push	{r7, lr}
 8026a22:	ed2d 8b02 	vpush	{d8}
 8026a26:	b082      	sub	sp, #8
 8026a28:	af00      	add	r7, sp, #0
 8026a2a:	6078      	str	r0, [r7, #4]

    GasIndexAlgorithm__mean_variance_estimator__set_parameters(params);
 8026a2c:	6878      	ldr	r0, [r7, #4]
 8026a2e:	f000 f8ff 	bl	8026c30 <GasIndexAlgorithm__mean_variance_estimator__set_parameters>
    GasIndexAlgorithm__mox_model__set_parameters(
 8026a32:	6878      	ldr	r0, [r7, #4]
 8026a34:	f000 f9aa 	bl	8026d8c <GasIndexAlgorithm__mean_variance_estimator__get_std>
 8026a38:	eeb0 8a40 	vmov.f32	s16, s0
 8026a3c:	6878      	ldr	r0, [r7, #4]
 8026a3e:	f000 f9b4 	bl	8026daa <GasIndexAlgorithm__mean_variance_estimator__get_mean>
 8026a42:	eef0 7a40 	vmov.f32	s15, s0
 8026a46:	eef0 0a67 	vmov.f32	s1, s15
 8026a4a:	eeb0 0a48 	vmov.f32	s0, s16
 8026a4e:	6878      	ldr	r0, [r7, #4]
 8026a50:	f000 fc54 	bl	80272fc <GasIndexAlgorithm__mox_model__set_parameters>
        params, GasIndexAlgorithm__mean_variance_estimator__get_std(params),
        GasIndexAlgorithm__mean_variance_estimator__get_mean(params));
    if ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) {
 8026a54:	687b      	ldr	r3, [r7, #4]
 8026a56:	681b      	ldr	r3, [r3, #0]
 8026a58:	2b01      	cmp	r3, #1
 8026a5a:	d109      	bne.n	8026a70 <GasIndexAlgorithm__init_instances+0x50>
        GasIndexAlgorithm__sigmoid_scaled__set_parameters(
 8026a5c:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8026a60:	eddf 0a0c 	vldr	s1, [pc, #48]	; 8026a94 <GasIndexAlgorithm__init_instances+0x74>
 8026a64:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 8026a98 <GasIndexAlgorithm__init_instances+0x78>
 8026a68:	6878      	ldr	r0, [r7, #4]
 8026a6a:	f000 fc99 	bl	80273a0 <GasIndexAlgorithm__sigmoid_scaled__set_parameters>
 8026a6e:	e008      	b.n	8026a82 <GasIndexAlgorithm__init_instances+0x62>
            params, GasIndexAlgorithm_SIGMOID_X0_NOX,
            GasIndexAlgorithm_SIGMOID_K_NOX,
            GasIndexAlgorithm_NOX_INDEX_OFFSET_DEFAULT);
    } else {
        GasIndexAlgorithm__sigmoid_scaled__set_parameters(
 8026a70:	ed9f 1a0a 	vldr	s2, [pc, #40]	; 8026a9c <GasIndexAlgorithm__init_instances+0x7c>
 8026a74:	eddf 0a0a 	vldr	s1, [pc, #40]	; 8026aa0 <GasIndexAlgorithm__init_instances+0x80>
 8026a78:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8026aa4 <GasIndexAlgorithm__init_instances+0x84>
 8026a7c:	6878      	ldr	r0, [r7, #4]
 8026a7e:	f000 fc8f 	bl	80273a0 <GasIndexAlgorithm__sigmoid_scaled__set_parameters>
            params, GasIndexAlgorithm_SIGMOID_X0_VOC,
            GasIndexAlgorithm_SIGMOID_K_VOC,
            GasIndexAlgorithm_VOC_INDEX_OFFSET_DEFAULT);
    }
    GasIndexAlgorithm__adaptive_lowpass__set_parameters(params);
 8026a82:	6878      	ldr	r0, [r7, #4]
 8026a84:	f000 fd46 	bl	8027514 <GasIndexAlgorithm__adaptive_lowpass__set_parameters>
}
 8026a88:	bf00      	nop
 8026a8a:	3708      	adds	r7, #8
 8026a8c:	46bd      	mov	sp, r7
 8026a8e:	ecbd 8b02 	vpop	{d8}
 8026a92:	bd80      	pop	{r7, pc}
 8026a94:	bc257a78 	.word	0xbc257a78
 8026a98:	44198000 	.word	0x44198000
 8026a9c:	42c80000 	.word	0x42c80000
 8026aa0:	bbd4fdf4 	.word	0xbbd4fdf4
 8026aa4:	43550000 	.word	0x43550000

08026aa8 <GasIndexAlgorithm_process>:
    *gain_factor = ((int32_t)(params->mIndex_Gain));
    return;
}

void GasIndexAlgorithm_process(GasIndexAlgorithmParams* params, int32_t sraw,
                               int32_t* gas_index) {
 8026aa8:	b580      	push	{r7, lr}
 8026aaa:	ed2d 8b02 	vpush	{d8}
 8026aae:	b084      	sub	sp, #16
 8026ab0:	af00      	add	r7, sp, #0
 8026ab2:	60f8      	str	r0, [r7, #12]
 8026ab4:	60b9      	str	r1, [r7, #8]
 8026ab6:	607a      	str	r2, [r7, #4]

    if ((params->mUptime <= GasIndexAlgorithm_INITIAL_BLACKOUT)) {
 8026ab8:	68fb      	ldr	r3, [r7, #12]
 8026aba:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8026abe:	ed9f 7a5b 	vldr	s14, [pc, #364]	; 8026c2c <GasIndexAlgorithm_process+0x184>
 8026ac2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026ac6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026aca:	d80b      	bhi.n	8026ae4 <GasIndexAlgorithm_process+0x3c>
        params->mUptime = (params->mUptime + params->mSamplingInterval);
 8026acc:	68fb      	ldr	r3, [r7, #12]
 8026ace:	ed93 7a0c 	vldr	s14, [r3, #48]	; 0x30
 8026ad2:	68fb      	ldr	r3, [r7, #12]
 8026ad4:	edd3 7a01 	vldr	s15, [r3, #4]
 8026ad8:	ee77 7a27 	vadd.f32	s15, s14, s15
 8026adc:	68fb      	ldr	r3, [r7, #12]
 8026ade:	edc3 7a0c 	vstr	s15, [r3, #48]	; 0x30
 8026ae2:	e08f      	b.n	8026c04 <GasIndexAlgorithm_process+0x15c>
    } else {
        if (((sraw > 0) && (sraw < 65000))) {
 8026ae4:	68bb      	ldr	r3, [r7, #8]
 8026ae6:	2b00      	cmp	r3, #0
 8026ae8:	dd27      	ble.n	8026b3a <GasIndexAlgorithm_process+0x92>
 8026aea:	68bb      	ldr	r3, [r7, #8]
 8026aec:	f64f 52e7 	movw	r2, #64999	; 0xfde7
 8026af0:	4293      	cmp	r3, r2
 8026af2:	dc22      	bgt.n	8026b3a <GasIndexAlgorithm_process+0x92>
            if ((sraw < (params->mSraw_Minimum + 1))) {
 8026af4:	68fb      	ldr	r3, [r7, #12]
 8026af6:	68db      	ldr	r3, [r3, #12]
 8026af8:	68ba      	ldr	r2, [r7, #8]
 8026afa:	429a      	cmp	r2, r3
 8026afc:	dc04      	bgt.n	8026b08 <GasIndexAlgorithm_process+0x60>
                sraw = (params->mSraw_Minimum + 1);
 8026afe:	68fb      	ldr	r3, [r7, #12]
 8026b00:	68db      	ldr	r3, [r3, #12]
 8026b02:	3301      	adds	r3, #1
 8026b04:	60bb      	str	r3, [r7, #8]
 8026b06:	e00d      	b.n	8026b24 <GasIndexAlgorithm_process+0x7c>
            } else if ((sraw > (params->mSraw_Minimum + 32767))) {
 8026b08:	68fb      	ldr	r3, [r7, #12]
 8026b0a:	68db      	ldr	r3, [r3, #12]
 8026b0c:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
 8026b10:	337f      	adds	r3, #127	; 0x7f
 8026b12:	68ba      	ldr	r2, [r7, #8]
 8026b14:	429a      	cmp	r2, r3
 8026b16:	dd05      	ble.n	8026b24 <GasIndexAlgorithm_process+0x7c>
                sraw = (params->mSraw_Minimum + 32767);
 8026b18:	68fb      	ldr	r3, [r7, #12]
 8026b1a:	68db      	ldr	r3, [r3, #12]
 8026b1c:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
 8026b20:	337f      	adds	r3, #127	; 0x7f
 8026b22:	60bb      	str	r3, [r7, #8]
            }
            params->mSraw = ((float)((sraw - params->mSraw_Minimum)));
 8026b24:	68fb      	ldr	r3, [r7, #12]
 8026b26:	68db      	ldr	r3, [r3, #12]
 8026b28:	68ba      	ldr	r2, [r7, #8]
 8026b2a:	1ad3      	subs	r3, r2, r3
 8026b2c:	ee07 3a90 	vmov	s15, r3
 8026b30:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8026b34:	68fb      	ldr	r3, [r7, #12]
 8026b36:	edc3 7a0d 	vstr	s15, [r3, #52]	; 0x34
        }
        if (((params->mAlgorithm_Type ==
 8026b3a:	68fb      	ldr	r3, [r7, #12]
 8026b3c:	681b      	ldr	r3, [r3, #0]
 8026b3e:	2b00      	cmp	r3, #0
 8026b40:	d005      	beq.n	8026b4e <GasIndexAlgorithm_process+0xa6>
              GasIndexAlgorithm_ALGORITHM_TYPE_VOC) ||
             GasIndexAlgorithm__mean_variance_estimator__is_initialized(
 8026b42:	68f8      	ldr	r0, [r7, #12]
 8026b44:	f000 f944 	bl	8026dd0 <GasIndexAlgorithm__mean_variance_estimator__is_initialized>
 8026b48:	4603      	mov	r3, r0
              GasIndexAlgorithm_ALGORITHM_TYPE_VOC) ||
 8026b4a:	2b00      	cmp	r3, #0
 8026b4c:	d01a      	beq.n	8026b84 <GasIndexAlgorithm_process+0xdc>
                 params))) {
            params->mGas_Index =
                GasIndexAlgorithm__mox_model__process(params, params->mSraw);
 8026b4e:	68fb      	ldr	r3, [r7, #12]
 8026b50:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8026b54:	eeb0 0a67 	vmov.f32	s0, s15
 8026b58:	68f8      	ldr	r0, [r7, #12]
 8026b5a:	f000 fbe3 	bl	8027324 <GasIndexAlgorithm__mox_model__process>
 8026b5e:	eef0 7a40 	vmov.f32	s15, s0
            params->mGas_Index =
 8026b62:	68fb      	ldr	r3, [r7, #12]
 8026b64:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
            params->mGas_Index = GasIndexAlgorithm__sigmoid_scaled__process(
 8026b68:	68fb      	ldr	r3, [r7, #12]
 8026b6a:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026b6e:	eeb0 0a67 	vmov.f32	s0, s15
 8026b72:	68f8      	ldr	r0, [r7, #12]
 8026b74:	f000 fc30 	bl	80273d8 <GasIndexAlgorithm__sigmoid_scaled__process>
 8026b78:	eef0 7a40 	vmov.f32	s15, s0
 8026b7c:	68fb      	ldr	r3, [r7, #12]
 8026b7e:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
 8026b82:	e003      	b.n	8026b8c <GasIndexAlgorithm_process+0xe4>
                params, params->mGas_Index);
        } else {
            params->mGas_Index = params->mIndex_Offset;
 8026b84:	68fb      	ldr	r3, [r7, #12]
 8026b86:	689a      	ldr	r2, [r3, #8]
 8026b88:	68fb      	ldr	r3, [r7, #12]
 8026b8a:	639a      	str	r2, [r3, #56]	; 0x38
        }
        params->mGas_Index = GasIndexAlgorithm__adaptive_lowpass__process(
 8026b8c:	68fb      	ldr	r3, [r7, #12]
 8026b8e:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026b92:	eeb0 0a67 	vmov.f32	s0, s15
 8026b96:	68f8      	ldr	r0, [r7, #12]
 8026b98:	f000 fcea 	bl	8027570 <GasIndexAlgorithm__adaptive_lowpass__process>
 8026b9c:	eef0 7a40 	vmov.f32	s15, s0
 8026ba0:	68fb      	ldr	r3, [r7, #12]
 8026ba2:	edc3 7a0e 	vstr	s15, [r3, #56]	; 0x38
            params, params->mGas_Index);
        if ((params->mGas_Index < 0.5f)) {
 8026ba6:	68fb      	ldr	r3, [r7, #12]
 8026ba8:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026bac:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8026bb0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026bb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026bb8:	d503      	bpl.n	8026bc2 <GasIndexAlgorithm_process+0x11a>
            params->mGas_Index = 0.5f;
 8026bba:	68fb      	ldr	r3, [r7, #12]
 8026bbc:	f04f 527c 	mov.w	r2, #1056964608	; 0x3f000000
 8026bc0:	639a      	str	r2, [r3, #56]	; 0x38
        }
        if ((params->mSraw > 0.f)) {
 8026bc2:	68fb      	ldr	r3, [r7, #12]
 8026bc4:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8026bc8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8026bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026bd0:	dd18      	ble.n	8026c04 <GasIndexAlgorithm_process+0x15c>
            GasIndexAlgorithm__mean_variance_estimator__process(params,
 8026bd2:	68fb      	ldr	r3, [r7, #12]
 8026bd4:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8026bd8:	eeb0 0a67 	vmov.f32	s0, s15
 8026bdc:	68f8      	ldr	r0, [r7, #12]
 8026bde:	f000 fa47 	bl	8027070 <GasIndexAlgorithm__mean_variance_estimator__process>
                                                                params->mSraw);
            GasIndexAlgorithm__mox_model__set_parameters(
 8026be2:	68f8      	ldr	r0, [r7, #12]
 8026be4:	f000 f8d2 	bl	8026d8c <GasIndexAlgorithm__mean_variance_estimator__get_std>
 8026be8:	eeb0 8a40 	vmov.f32	s16, s0
 8026bec:	68f8      	ldr	r0, [r7, #12]
 8026bee:	f000 f8dc 	bl	8026daa <GasIndexAlgorithm__mean_variance_estimator__get_mean>
 8026bf2:	eef0 7a40 	vmov.f32	s15, s0
 8026bf6:	eef0 0a67 	vmov.f32	s1, s15
 8026bfa:	eeb0 0a48 	vmov.f32	s0, s16
 8026bfe:	68f8      	ldr	r0, [r7, #12]
 8026c00:	f000 fb7c 	bl	80272fc <GasIndexAlgorithm__mox_model__set_parameters>
                params,
                GasIndexAlgorithm__mean_variance_estimator__get_std(params),
                GasIndexAlgorithm__mean_variance_estimator__get_mean(params));
        }
    }
    *gas_index = ((int32_t)((params->mGas_Index + 0.5f)));
 8026c04:	68fb      	ldr	r3, [r7, #12]
 8026c06:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026c0a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8026c0e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8026c12:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8026c16:	ee17 2a90 	vmov	r2, s15
 8026c1a:	687b      	ldr	r3, [r7, #4]
 8026c1c:	601a      	str	r2, [r3, #0]
    return;
 8026c1e:	bf00      	nop
}
 8026c20:	3710      	adds	r7, #16
 8026c22:	46bd      	mov	sp, r7
 8026c24:	ecbd 8b02 	vpop	{d8}
 8026c28:	bd80      	pop	{r7, pc}
 8026c2a:	bf00      	nop
 8026c2c:	42340000 	.word	0x42340000

08026c30 <GasIndexAlgorithm__mean_variance_estimator__set_parameters>:

static void GasIndexAlgorithm__mean_variance_estimator__set_parameters(
    GasIndexAlgorithmParams* params) {
 8026c30:	b480      	push	{r7}
 8026c32:	b083      	sub	sp, #12
 8026c34:	af00      	add	r7, sp, #0
 8026c36:	6078      	str	r0, [r7, #4]

    params->m_Mean_Variance_Estimator___Initialized = false;
 8026c38:	687b      	ldr	r3, [r7, #4]
 8026c3a:	2200      	movs	r2, #0
 8026c3c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    params->m_Mean_Variance_Estimator___Mean = 0.f;
 8026c40:	687b      	ldr	r3, [r7, #4]
 8026c42:	f04f 0200 	mov.w	r2, #0
 8026c46:	641a      	str	r2, [r3, #64]	; 0x40
    params->m_Mean_Variance_Estimator___Sraw_Offset = 0.f;
 8026c48:	687b      	ldr	r3, [r7, #4]
 8026c4a:	f04f 0200 	mov.w	r2, #0
 8026c4e:	645a      	str	r2, [r3, #68]	; 0x44
    params->m_Mean_Variance_Estimator___Std = params->mSraw_Std_Initial;
 8026c50:	687b      	ldr	r3, [r7, #4]
 8026c52:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8026c54:	687b      	ldr	r3, [r7, #4]
 8026c56:	649a      	str	r2, [r3, #72]	; 0x48
    params->m_Mean_Variance_Estimator___Gamma_Mean =
        (((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *
           GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
          (params->mSamplingInterval / 3600.f)) /
 8026c58:	687b      	ldr	r3, [r7, #4]
 8026c5a:	ed93 7a01 	vldr	s14, [r3, #4]
 8026c5e:	eddf 6a46 	vldr	s13, [pc, #280]	; 8026d78 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x148>
 8026c62:	eec7 7a26 	vdiv.f32	s15, s14, s13
           GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
 8026c66:	ed9f 7a45 	vldr	s14, [pc, #276]	; 8026d7c <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x14c>
 8026c6a:	ee67 6a87 	vmul.f32	s13, s15, s14
         (params->mTau_Mean_Hours + (params->mSamplingInterval / 3600.f)));
 8026c6e:	687b      	ldr	r3, [r7, #4]
 8026c70:	ed93 7a09 	vldr	s14, [r3, #36]	; 0x24
 8026c74:	687b      	ldr	r3, [r7, #4]
 8026c76:	ed93 6a01 	vldr	s12, [r3, #4]
 8026c7a:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8026d78 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x148>
 8026c7e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8026c82:	ee37 7a27 	vadd.f32	s14, s14, s15
          (params->mSamplingInterval / 3600.f)) /
 8026c86:	eec6 7a87 	vdiv.f32	s15, s13, s14
    params->m_Mean_Variance_Estimator___Gamma_Mean =
 8026c8a:	687b      	ldr	r3, [r7, #4]
 8026c8c:	edc3 7a13 	vstr	s15, [r3, #76]	; 0x4c
    params->m_Mean_Variance_Estimator___Gamma_Variance =
        ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *
          (params->mSamplingInterval / 3600.f)) /
 8026c90:	687b      	ldr	r3, [r7, #4]
 8026c92:	ed93 7a01 	vldr	s14, [r3, #4]
 8026c96:	eddf 6a38 	vldr	s13, [pc, #224]	; 8026d78 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x148>
 8026c9a:	eec7 7a26 	vdiv.f32	s15, s14, s13
        ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *
 8026c9e:	ed9f 7a38 	vldr	s14, [pc, #224]	; 8026d80 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x150>
 8026ca2:	ee67 6a87 	vmul.f32	s13, s15, s14
         (params->mTau_Variance_Hours + (params->mSamplingInterval / 3600.f)));
 8026ca6:	687b      	ldr	r3, [r7, #4]
 8026ca8:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 8026cac:	687b      	ldr	r3, [r7, #4]
 8026cae:	ed93 6a01 	vldr	s12, [r3, #4]
 8026cb2:	eddf 5a31 	vldr	s11, [pc, #196]	; 8026d78 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x148>
 8026cb6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8026cba:	ee37 7a27 	vadd.f32	s14, s14, s15
          (params->mSamplingInterval / 3600.f)) /
 8026cbe:	eec6 7a87 	vdiv.f32	s15, s13, s14
    params->m_Mean_Variance_Estimator___Gamma_Variance =
 8026cc2:	687b      	ldr	r3, [r7, #4]
 8026cc4:	edc3 7a14 	vstr	s15, [r3, #80]	; 0x50
    if ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) {
 8026cc8:	687b      	ldr	r3, [r7, #4]
 8026cca:	681b      	ldr	r3, [r3, #0]
 8026ccc:	2b01      	cmp	r3, #1
 8026cce:	d113      	bne.n	8026cf8 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0xc8>
        params->m_Mean_Variance_Estimator___Gamma_Initial_Mean =
            (((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *
               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
              params->mSamplingInterval) /
 8026cd0:	687b      	ldr	r3, [r7, #4]
 8026cd2:	edd3 7a01 	vldr	s15, [r3, #4]
               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
 8026cd6:	ed9f 7a29 	vldr	s14, [pc, #164]	; 8026d7c <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x14c>
 8026cda:	ee67 6a87 	vmul.f32	s13, s15, s14
             (GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX +
              params->mSamplingInterval));
 8026cde:	687b      	ldr	r3, [r7, #4]
 8026ce0:	edd3 7a01 	vldr	s15, [r3, #4]
             (GasIndexAlgorithm_TAU_INITIAL_MEAN_NOX +
 8026ce4:	ed9f 7a27 	vldr	s14, [pc, #156]	; 8026d84 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x154>
 8026ce8:	ee37 7a87 	vadd.f32	s14, s15, s14
              params->mSamplingInterval) /
 8026cec:	eec6 7a87 	vdiv.f32	s15, s13, s14
        params->m_Mean_Variance_Estimator___Gamma_Initial_Mean =
 8026cf0:	687b      	ldr	r3, [r7, #4]
 8026cf2:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
 8026cf6:	e012      	b.n	8026d1e <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0xee>
    } else {
        params->m_Mean_Variance_Estimator___Gamma_Initial_Mean =
            (((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING *
               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
              params->mSamplingInterval) /
 8026cf8:	687b      	ldr	r3, [r7, #4]
 8026cfa:	edd3 7a01 	vldr	s15, [r3, #4]
               GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING) *
 8026cfe:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8026d7c <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x14c>
 8026d02:	ee67 6a87 	vmul.f32	s13, s15, s14
             (GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC +
              params->mSamplingInterval));
 8026d06:	687b      	ldr	r3, [r7, #4]
 8026d08:	edd3 7a01 	vldr	s15, [r3, #4]
             (GasIndexAlgorithm_TAU_INITIAL_MEAN_VOC +
 8026d0c:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 8026d10:	ee37 7a87 	vadd.f32	s14, s15, s14
              params->mSamplingInterval) /
 8026d14:	eec6 7a87 	vdiv.f32	s15, s13, s14
        params->m_Mean_Variance_Estimator___Gamma_Initial_Mean =
 8026d18:	687b      	ldr	r3, [r7, #4]
 8026d1a:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
    }
    params->m_Mean_Variance_Estimator___Gamma_Initial_Variance =
        ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *
          params->mSamplingInterval) /
 8026d1e:	687b      	ldr	r3, [r7, #4]
 8026d20:	edd3 7a01 	vldr	s15, [r3, #4]
        ((GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *
 8026d24:	ed9f 7a16 	vldr	s14, [pc, #88]	; 8026d80 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x150>
 8026d28:	ee67 6a87 	vmul.f32	s13, s15, s14
         (GasIndexAlgorithm_TAU_INITIAL_VARIANCE + params->mSamplingInterval));
 8026d2c:	687b      	ldr	r3, [r7, #4]
 8026d2e:	edd3 7a01 	vldr	s15, [r3, #4]
 8026d32:	ed9f 7a15 	vldr	s14, [pc, #84]	; 8026d88 <GasIndexAlgorithm__mean_variance_estimator__set_parameters+0x158>
 8026d36:	ee37 7a87 	vadd.f32	s14, s15, s14
          params->mSamplingInterval) /
 8026d3a:	eec6 7a87 	vdiv.f32	s15, s13, s14
    params->m_Mean_Variance_Estimator___Gamma_Initial_Variance =
 8026d3e:	687b      	ldr	r3, [r7, #4]
 8026d40:	edc3 7a16 	vstr	s15, [r3, #88]	; 0x58
    params->m_Mean_Variance_Estimator__Gamma_Mean = 0.f;
 8026d44:	687b      	ldr	r3, [r7, #4]
 8026d46:	f04f 0200 	mov.w	r2, #0
 8026d4a:	65da      	str	r2, [r3, #92]	; 0x5c
    params->m_Mean_Variance_Estimator__Gamma_Variance = 0.f;
 8026d4c:	687b      	ldr	r3, [r7, #4]
 8026d4e:	f04f 0200 	mov.w	r2, #0
 8026d52:	661a      	str	r2, [r3, #96]	; 0x60
    params->m_Mean_Variance_Estimator___Uptime_Gamma = 0.f;
 8026d54:	687b      	ldr	r3, [r7, #4]
 8026d56:	f04f 0200 	mov.w	r2, #0
 8026d5a:	665a      	str	r2, [r3, #100]	; 0x64
    params->m_Mean_Variance_Estimator___Uptime_Gating = 0.f;
 8026d5c:	687b      	ldr	r3, [r7, #4]
 8026d5e:	f04f 0200 	mov.w	r2, #0
 8026d62:	669a      	str	r2, [r3, #104]	; 0x68
    params->m_Mean_Variance_Estimator___Gating_Duration_Minutes = 0.f;
 8026d64:	687b      	ldr	r3, [r7, #4]
 8026d66:	f04f 0200 	mov.w	r2, #0
 8026d6a:	66da      	str	r2, [r3, #108]	; 0x6c
}
 8026d6c:	bf00      	nop
 8026d6e:	370c      	adds	r7, #12
 8026d70:	46bd      	mov	sp, r7
 8026d72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026d76:	4770      	bx	lr
 8026d78:	45610000 	.word	0x45610000
 8026d7c:	44000000 	.word	0x44000000
 8026d80:	42800000 	.word	0x42800000
 8026d84:	44960000 	.word	0x44960000
 8026d88:	451c4000 	.word	0x451c4000

08026d8c <GasIndexAlgorithm__mean_variance_estimator__get_std>:
    params->m_Mean_Variance_Estimator___Uptime_Gamma = uptime_gamma;
    params->m_Mean_Variance_Estimator___Initialized = true;
}

static float GasIndexAlgorithm__mean_variance_estimator__get_std(
    const GasIndexAlgorithmParams* params) {
 8026d8c:	b480      	push	{r7}
 8026d8e:	b083      	sub	sp, #12
 8026d90:	af00      	add	r7, sp, #0
 8026d92:	6078      	str	r0, [r7, #4]

    return params->m_Mean_Variance_Estimator___Std;
 8026d94:	687b      	ldr	r3, [r7, #4]
 8026d96:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8026d98:	ee07 3a90 	vmov	s15, r3
}
 8026d9c:	eeb0 0a67 	vmov.f32	s0, s15
 8026da0:	370c      	adds	r7, #12
 8026da2:	46bd      	mov	sp, r7
 8026da4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026da8:	4770      	bx	lr

08026daa <GasIndexAlgorithm__mean_variance_estimator__get_mean>:

static float GasIndexAlgorithm__mean_variance_estimator__get_mean(
    const GasIndexAlgorithmParams* params) {
 8026daa:	b480      	push	{r7}
 8026dac:	b083      	sub	sp, #12
 8026dae:	af00      	add	r7, sp, #0
 8026db0:	6078      	str	r0, [r7, #4]

    return (params->m_Mean_Variance_Estimator___Mean +
 8026db2:	687b      	ldr	r3, [r7, #4]
 8026db4:	ed93 7a10 	vldr	s14, [r3, #64]	; 0x40
            params->m_Mean_Variance_Estimator___Sraw_Offset);
 8026db8:	687b      	ldr	r3, [r7, #4]
 8026dba:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
    return (params->m_Mean_Variance_Estimator___Mean +
 8026dbe:	ee77 7a27 	vadd.f32	s15, s14, s15
}
 8026dc2:	eeb0 0a67 	vmov.f32	s0, s15
 8026dc6:	370c      	adds	r7, #12
 8026dc8:	46bd      	mov	sp, r7
 8026dca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026dce:	4770      	bx	lr

08026dd0 <GasIndexAlgorithm__mean_variance_estimator__is_initialized>:

static bool GasIndexAlgorithm__mean_variance_estimator__is_initialized(
    GasIndexAlgorithmParams* params) {
 8026dd0:	b480      	push	{r7}
 8026dd2:	b083      	sub	sp, #12
 8026dd4:	af00      	add	r7, sp, #0
 8026dd6:	6078      	str	r0, [r7, #4]

    return params->m_Mean_Variance_Estimator___Initialized;
 8026dd8:	687b      	ldr	r3, [r7, #4]
 8026dda:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
}
 8026dde:	4618      	mov	r0, r3
 8026de0:	370c      	adds	r7, #12
 8026de2:	46bd      	mov	sp, r7
 8026de4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026de8:	4770      	bx	lr
	...

08026dec <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma>:

static void GasIndexAlgorithm__mean_variance_estimator___calculate_gamma(
    GasIndexAlgorithmParams* params) {
 8026dec:	b580      	push	{r7, lr}
 8026dee:	ed2d 8b02 	vpush	{d8}
 8026df2:	b08c      	sub	sp, #48	; 0x30
 8026df4:	af00      	add	r7, sp, #0
 8026df6:	6078      	str	r0, [r7, #4]
    float gamma_variance;
    float gating_threshold_variance;
    float sigmoid_gating_variance;

    uptime_limit = (GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX -
                    params->mSamplingInterval);
 8026df8:	687b      	ldr	r3, [r7, #4]
 8026dfa:	edd3 7a01 	vldr	s15, [r3, #4]
    uptime_limit = (GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__FIX16_MAX -
 8026dfe:	ed9f 7a95 	vldr	s14, [pc, #596]	; 8027054 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x268>
 8026e02:	ee77 7a67 	vsub.f32	s15, s14, s15
 8026e06:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    if ((params->m_Mean_Variance_Estimator___Uptime_Gamma < uptime_limit)) {
 8026e0a:	687b      	ldr	r3, [r7, #4]
 8026e0c:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 8026e10:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 8026e14:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8026e18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026e1c:	dd0a      	ble.n	8026e34 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x48>
        params->m_Mean_Variance_Estimator___Uptime_Gamma =
            (params->m_Mean_Variance_Estimator___Uptime_Gamma +
 8026e1e:	687b      	ldr	r3, [r7, #4]
 8026e20:	ed93 7a19 	vldr	s14, [r3, #100]	; 0x64
             params->mSamplingInterval);
 8026e24:	687b      	ldr	r3, [r7, #4]
 8026e26:	edd3 7a01 	vldr	s15, [r3, #4]
            (params->m_Mean_Variance_Estimator___Uptime_Gamma +
 8026e2a:	ee77 7a27 	vadd.f32	s15, s14, s15
        params->m_Mean_Variance_Estimator___Uptime_Gamma =
 8026e2e:	687b      	ldr	r3, [r7, #4]
 8026e30:	edc3 7a19 	vstr	s15, [r3, #100]	; 0x64
    }
    if ((params->m_Mean_Variance_Estimator___Uptime_Gating < uptime_limit)) {
 8026e34:	687b      	ldr	r3, [r7, #4]
 8026e36:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 8026e3a:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
 8026e3e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8026e42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026e46:	dd0a      	ble.n	8026e5e <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x72>
        params->m_Mean_Variance_Estimator___Uptime_Gating =
            (params->m_Mean_Variance_Estimator___Uptime_Gating +
 8026e48:	687b      	ldr	r3, [r7, #4]
 8026e4a:	ed93 7a1a 	vldr	s14, [r3, #104]	; 0x68
             params->mSamplingInterval);
 8026e4e:	687b      	ldr	r3, [r7, #4]
 8026e50:	edd3 7a01 	vldr	s15, [r3, #4]
            (params->m_Mean_Variance_Estimator___Uptime_Gating +
 8026e54:	ee77 7a27 	vadd.f32	s15, s14, s15
        params->m_Mean_Variance_Estimator___Uptime_Gating =
 8026e58:	687b      	ldr	r3, [r7, #4]
 8026e5a:	edc3 7a1a 	vstr	s15, [r3, #104]	; 0x68
    }
    GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(
 8026e5e:	687b      	ldr	r3, [r7, #4]
 8026e60:	edd3 7a05 	vldr	s15, [r3, #20]
 8026e64:	eddf 0a7c 	vldr	s1, [pc, #496]	; 8027058 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x26c>
 8026e68:	eeb0 0a67 	vmov.f32	s0, s15
 8026e6c:	6878      	ldr	r0, [r7, #4]
 8026e6e:	f000 f9eb 	bl	8027248 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters>
        params, params->mInit_Duration_Mean,
        GasIndexAlgorithm_INIT_TRANSITION_MEAN);
    sigmoid_gamma_mean =
        GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026e72:	687b      	ldr	r3, [r7, #4]
 8026e74:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 8026e78:	eeb0 0a67 	vmov.f32	s0, s15
 8026e7c:	6878      	ldr	r0, [r7, #4]
 8026e7e:	f000 f9f7 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026e82:	ed87 0a0a 	vstr	s0, [r7, #40]	; 0x28
            params, params->m_Mean_Variance_Estimator___Uptime_Gamma);
    gamma_mean = (params->m_Mean_Variance_Estimator___Gamma_Mean +
 8026e86:	687b      	ldr	r3, [r7, #4]
 8026e88:	ed93 7a13 	vldr	s14, [r3, #76]	; 0x4c
                  ((params->m_Mean_Variance_Estimator___Gamma_Initial_Mean -
 8026e8c:	687b      	ldr	r3, [r7, #4]
 8026e8e:	edd3 6a15 	vldr	s13, [r3, #84]	; 0x54
                    params->m_Mean_Variance_Estimator___Gamma_Mean) *
 8026e92:	687b      	ldr	r3, [r7, #4]
 8026e94:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
                  ((params->m_Mean_Variance_Estimator___Gamma_Initial_Mean -
 8026e98:	ee76 6ae7 	vsub.f32	s13, s13, s15
                    params->m_Mean_Variance_Estimator___Gamma_Mean) *
 8026e9c:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8026ea0:	ee66 7aa7 	vmul.f32	s15, s13, s15
    gamma_mean = (params->m_Mean_Variance_Estimator___Gamma_Mean +
 8026ea4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8026ea8:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
                   sigmoid_gamma_mean));
    gating_threshold_mean =
        (params->mGating_Threshold +
 8026eac:	687b      	ldr	r3, [r7, #4]
 8026eae:	ed93 8a07 	vldr	s16, [r3, #28]
         ((GasIndexAlgorithm_GATING_THRESHOLD_INITIAL -
           params->mGating_Threshold) *
 8026eb2:	687b      	ldr	r3, [r7, #4]
 8026eb4:	edd3 7a07 	vldr	s15, [r3, #28]
         ((GasIndexAlgorithm_GATING_THRESHOLD_INITIAL -
 8026eb8:	ed9f 7a68 	vldr	s14, [pc, #416]	; 802705c <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x270>
 8026ebc:	ee77 8a67 	vsub.f32	s17, s14, s15
          GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026ec0:	687b      	ldr	r3, [r7, #4]
 8026ec2:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 8026ec6:	eeb0 0a67 	vmov.f32	s0, s15
 8026eca:	6878      	ldr	r0, [r7, #4]
 8026ecc:	f000 f9d0 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026ed0:	eef0 7a40 	vmov.f32	s15, s0
           params->mGating_Threshold) *
 8026ed4:	ee68 7aa7 	vmul.f32	s15, s17, s15
    gating_threshold_mean =
 8026ed8:	ee78 7a27 	vadd.f32	s15, s16, s15
 8026edc:	edc7 7a08 	vstr	s15, [r7, #32]
              params, params->m_Mean_Variance_Estimator___Uptime_Gating)));
    GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(
 8026ee0:	eddf 0a5f 	vldr	s1, [pc, #380]	; 8027060 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x274>
 8026ee4:	ed97 0a08 	vldr	s0, [r7, #32]
 8026ee8:	6878      	ldr	r0, [r7, #4]
 8026eea:	f000 f9ad 	bl	8027248 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters>
        params, gating_threshold_mean,
        GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION);
    sigmoid_gating_mean =
        GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026eee:	687b      	ldr	r3, [r7, #4]
 8026ef0:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026ef4:	eeb0 0a67 	vmov.f32	s0, s15
 8026ef8:	6878      	ldr	r0, [r7, #4]
 8026efa:	f000 f9b9 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026efe:	ed87 0a07 	vstr	s0, [r7, #28]
            params, params->mGas_Index);
    params->m_Mean_Variance_Estimator__Gamma_Mean =
        (sigmoid_gating_mean * gamma_mean);
 8026f02:	ed97 7a07 	vldr	s14, [r7, #28]
 8026f06:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 8026f0a:	ee67 7a27 	vmul.f32	s15, s14, s15
    params->m_Mean_Variance_Estimator__Gamma_Mean =
 8026f0e:	687b      	ldr	r3, [r7, #4]
 8026f10:	edc3 7a17 	vstr	s15, [r3, #92]	; 0x5c
    GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(
 8026f14:	687b      	ldr	r3, [r7, #4]
 8026f16:	edd3 7a06 	vldr	s15, [r3, #24]
 8026f1a:	eddf 0a4f 	vldr	s1, [pc, #316]	; 8027058 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x26c>
 8026f1e:	eeb0 0a67 	vmov.f32	s0, s15
 8026f22:	6878      	ldr	r0, [r7, #4]
 8026f24:	f000 f990 	bl	8027248 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters>
        params, params->mInit_Duration_Variance,
        GasIndexAlgorithm_INIT_TRANSITION_VARIANCE);
    sigmoid_gamma_variance =
        GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026f28:	687b      	ldr	r3, [r7, #4]
 8026f2a:	edd3 7a19 	vldr	s15, [r3, #100]	; 0x64
 8026f2e:	eeb0 0a67 	vmov.f32	s0, s15
 8026f32:	6878      	ldr	r0, [r7, #4]
 8026f34:	f000 f99c 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026f38:	ed87 0a06 	vstr	s0, [r7, #24]
            params, params->m_Mean_Variance_Estimator___Uptime_Gamma);
    gamma_variance =
        (params->m_Mean_Variance_Estimator___Gamma_Variance +
 8026f3c:	687b      	ldr	r3, [r7, #4]
 8026f3e:	ed93 7a14 	vldr	s14, [r3, #80]	; 0x50
         ((params->m_Mean_Variance_Estimator___Gamma_Initial_Variance -
 8026f42:	687b      	ldr	r3, [r7, #4]
 8026f44:	edd3 6a16 	vldr	s13, [r3, #88]	; 0x58
           params->m_Mean_Variance_Estimator___Gamma_Variance) *
 8026f48:	687b      	ldr	r3, [r7, #4]
 8026f4a:	edd3 7a14 	vldr	s15, [r3, #80]	; 0x50
         ((params->m_Mean_Variance_Estimator___Gamma_Initial_Variance -
 8026f4e:	ee76 6ae7 	vsub.f32	s13, s13, s15
          (sigmoid_gamma_variance - sigmoid_gamma_mean)));
 8026f52:	ed97 6a06 	vldr	s12, [r7, #24]
 8026f56:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
 8026f5a:	ee76 7a67 	vsub.f32	s15, s12, s15
           params->m_Mean_Variance_Estimator___Gamma_Variance) *
 8026f5e:	ee66 7aa7 	vmul.f32	s15, s13, s15
    gamma_variance =
 8026f62:	ee77 7a27 	vadd.f32	s15, s14, s15
 8026f66:	edc7 7a05 	vstr	s15, [r7, #20]
    gating_threshold_variance =
        (params->mGating_Threshold +
 8026f6a:	687b      	ldr	r3, [r7, #4]
 8026f6c:	ed93 8a07 	vldr	s16, [r3, #28]
         ((GasIndexAlgorithm_GATING_THRESHOLD_INITIAL -
           params->mGating_Threshold) *
 8026f70:	687b      	ldr	r3, [r7, #4]
 8026f72:	edd3 7a07 	vldr	s15, [r3, #28]
         ((GasIndexAlgorithm_GATING_THRESHOLD_INITIAL -
 8026f76:	ed9f 7a39 	vldr	s14, [pc, #228]	; 802705c <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x270>
 8026f7a:	ee77 8a67 	vsub.f32	s17, s14, s15
          GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026f7e:	687b      	ldr	r3, [r7, #4]
 8026f80:	edd3 7a1a 	vldr	s15, [r3, #104]	; 0x68
 8026f84:	eeb0 0a67 	vmov.f32	s0, s15
 8026f88:	6878      	ldr	r0, [r7, #4]
 8026f8a:	f000 f971 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026f8e:	eef0 7a40 	vmov.f32	s15, s0
           params->mGating_Threshold) *
 8026f92:	ee68 7aa7 	vmul.f32	s15, s17, s15
    gating_threshold_variance =
 8026f96:	ee78 7a27 	vadd.f32	s15, s16, s15
 8026f9a:	edc7 7a04 	vstr	s15, [r7, #16]
              params, params->m_Mean_Variance_Estimator___Uptime_Gating)));
    GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(
 8026f9e:	eddf 0a30 	vldr	s1, [pc, #192]	; 8027060 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x274>
 8026fa2:	ed97 0a04 	vldr	s0, [r7, #16]
 8026fa6:	6878      	ldr	r0, [r7, #4]
 8026fa8:	f000 f94e 	bl	8027248 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters>
        params, gating_threshold_variance,
        GasIndexAlgorithm_GATING_THRESHOLD_TRANSITION);
    sigmoid_gating_variance =
        GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
 8026fac:	687b      	ldr	r3, [r7, #4]
 8026fae:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8026fb2:	eeb0 0a67 	vmov.f32	s0, s15
 8026fb6:	6878      	ldr	r0, [r7, #4]
 8026fb8:	f000 f95a 	bl	8027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>
 8026fbc:	ed87 0a03 	vstr	s0, [r7, #12]
            params, params->mGas_Index);
    params->m_Mean_Variance_Estimator__Gamma_Variance =
        (sigmoid_gating_variance * gamma_variance);
 8026fc0:	ed97 7a03 	vldr	s14, [r7, #12]
 8026fc4:	edd7 7a05 	vldr	s15, [r7, #20]
 8026fc8:	ee67 7a27 	vmul.f32	s15, s14, s15
    params->m_Mean_Variance_Estimator__Gamma_Variance =
 8026fcc:	687b      	ldr	r3, [r7, #4]
 8026fce:	edc3 7a18 	vstr	s15, [r3, #96]	; 0x60
    params->m_Mean_Variance_Estimator___Gating_Duration_Minutes =
        (params->m_Mean_Variance_Estimator___Gating_Duration_Minutes +
 8026fd2:	687b      	ldr	r3, [r7, #4]
 8026fd4:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
         ((params->mSamplingInterval / 60.f) *
 8026fd8:	687b      	ldr	r3, [r7, #4]
 8026fda:	edd3 7a01 	vldr	s15, [r3, #4]
 8026fde:	ed9f 6a21 	vldr	s12, [pc, #132]	; 8027064 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x278>
 8026fe2:	eec7 6a86 	vdiv.f32	s13, s15, s12
          (((1.f - sigmoid_gating_mean) *
 8026fe6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8026fea:	edd7 7a07 	vldr	s15, [r7, #28]
 8026fee:	ee76 7a67 	vsub.f32	s15, s12, s15
 8026ff2:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8027068 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x27c>
 8026ff6:	ee67 7a86 	vmul.f32	s15, s15, s12
            (1.f + GasIndexAlgorithm_GATING_MAX_RATIO)) -
 8026ffa:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 802706c <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x280>
 8026ffe:	ee77 7ac6 	vsub.f32	s15, s15, s12
         ((params->mSamplingInterval / 60.f) *
 8027002:	ee66 7aa7 	vmul.f32	s15, s13, s15
        (params->m_Mean_Variance_Estimator___Gating_Duration_Minutes +
 8027006:	ee77 7a27 	vadd.f32	s15, s14, s15
    params->m_Mean_Variance_Estimator___Gating_Duration_Minutes =
 802700a:	687b      	ldr	r3, [r7, #4]
 802700c:	edc3 7a1b 	vstr	s15, [r3, #108]	; 0x6c
           GasIndexAlgorithm_GATING_MAX_RATIO)));
    if ((params->m_Mean_Variance_Estimator___Gating_Duration_Minutes < 0.f)) {
 8027010:	687b      	ldr	r3, [r7, #4]
 8027012:	edd3 7a1b 	vldr	s15, [r3, #108]	; 0x6c
 8027016:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802701a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802701e:	d503      	bpl.n	8027028 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x23c>
        params->m_Mean_Variance_Estimator___Gating_Duration_Minutes = 0.f;
 8027020:	687b      	ldr	r3, [r7, #4]
 8027022:	f04f 0200 	mov.w	r2, #0
 8027026:	66da      	str	r2, [r3, #108]	; 0x6c
    }
    if ((params->m_Mean_Variance_Estimator___Gating_Duration_Minutes >
 8027028:	687b      	ldr	r3, [r7, #4]
 802702a:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
         params->mGating_Max_Duration_Minutes)) {
 802702e:	687b      	ldr	r3, [r7, #4]
 8027030:	edd3 7a04 	vldr	s15, [r3, #16]
    if ((params->m_Mean_Variance_Estimator___Gating_Duration_Minutes >
 8027034:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8027038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802703c:	dc00      	bgt.n	8027040 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x254>
        params->m_Mean_Variance_Estimator___Uptime_Gating = 0.f;
    }
}
 802703e:	e003      	b.n	8027048 <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma+0x25c>
        params->m_Mean_Variance_Estimator___Uptime_Gating = 0.f;
 8027040:	687b      	ldr	r3, [r7, #4]
 8027042:	f04f 0200 	mov.w	r2, #0
 8027046:	669a      	str	r2, [r3, #104]	; 0x68
}
 8027048:	bf00      	nop
 802704a:	3730      	adds	r7, #48	; 0x30
 802704c:	46bd      	mov	sp, r7
 802704e:	ecbd 8b02 	vpop	{d8}
 8027052:	bd80      	pop	{r7, pc}
 8027054:	46fffe00 	.word	0x46fffe00
 8027058:	3c23d70a 	.word	0x3c23d70a
 802705c:	43ff0000 	.word	0x43ff0000
 8027060:	3db851ec 	.word	0x3db851ec
 8027064:	42700000 	.word	0x42700000
 8027068:	3fa66666 	.word	0x3fa66666
 802706c:	3e99999a 	.word	0x3e99999a

08027070 <GasIndexAlgorithm__mean_variance_estimator__process>:

static void GasIndexAlgorithm__mean_variance_estimator__process(
    GasIndexAlgorithmParams* params, float sraw) {
 8027070:	b580      	push	{r7, lr}
 8027072:	ed2d 8b02 	vpush	{d8}
 8027076:	b086      	sub	sp, #24
 8027078:	af00      	add	r7, sp, #0
 802707a:	6078      	str	r0, [r7, #4]
 802707c:	ed87 0a00 	vstr	s0, [r7]

    float delta_sgp;
    float c;
    float additional_scaling;

    if ((params->m_Mean_Variance_Estimator___Initialized == false)) {
 8027080:	687b      	ldr	r3, [r7, #4]
 8027082:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8027086:	f083 0301 	eor.w	r3, r3, #1
 802708a:	b2db      	uxtb	r3, r3
 802708c:	2b00      	cmp	r3, #0
 802708e:	d00b      	beq.n	80270a8 <GasIndexAlgorithm__mean_variance_estimator__process+0x38>
        params->m_Mean_Variance_Estimator___Initialized = true;
 8027090:	687b      	ldr	r3, [r7, #4]
 8027092:	2201      	movs	r2, #1
 8027094:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        params->m_Mean_Variance_Estimator___Sraw_Offset = sraw;
 8027098:	687b      	ldr	r3, [r7, #4]
 802709a:	683a      	ldr	r2, [r7, #0]
 802709c:	645a      	str	r2, [r3, #68]	; 0x44
        params->m_Mean_Variance_Estimator___Mean = 0.f;
 802709e:	687b      	ldr	r3, [r7, #4]
 80270a0:	f04f 0200 	mov.w	r2, #0
 80270a4:	641a      	str	r2, [r3, #64]	; 0x40
        params->m_Mean_Variance_Estimator___Mean =
            (params->m_Mean_Variance_Estimator___Mean +
             ((params->m_Mean_Variance_Estimator__Gamma_Mean * delta_sgp) /
              GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__ADDITIONAL_GAMMA_MEAN_SCALING));
    }
}
 80270a6:	e0c1      	b.n	802722c <GasIndexAlgorithm__mean_variance_estimator__process+0x1bc>
        if (((params->m_Mean_Variance_Estimator___Mean >= 100.f) ||
 80270a8:	687b      	ldr	r3, [r7, #4]
 80270aa:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 80270ae:	ed9f 7a62 	vldr	s14, [pc, #392]	; 8027238 <GasIndexAlgorithm__mean_variance_estimator__process+0x1c8>
 80270b2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80270b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80270ba:	da09      	bge.n	80270d0 <GasIndexAlgorithm__mean_variance_estimator__process+0x60>
             (params->m_Mean_Variance_Estimator___Mean <= -100.f))) {
 80270bc:	687b      	ldr	r3, [r7, #4]
 80270be:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
        if (((params->m_Mean_Variance_Estimator___Mean >= 100.f) ||
 80270c2:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 802723c <GasIndexAlgorithm__mean_variance_estimator__process+0x1cc>
 80270c6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80270ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80270ce:	d80e      	bhi.n	80270ee <GasIndexAlgorithm__mean_variance_estimator__process+0x7e>
                (params->m_Mean_Variance_Estimator___Sraw_Offset +
 80270d0:	687b      	ldr	r3, [r7, #4]
 80270d2:	ed93 7a11 	vldr	s14, [r3, #68]	; 0x44
                 params->m_Mean_Variance_Estimator___Mean);
 80270d6:	687b      	ldr	r3, [r7, #4]
 80270d8:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
                (params->m_Mean_Variance_Estimator___Sraw_Offset +
 80270dc:	ee77 7a27 	vadd.f32	s15, s14, s15
            params->m_Mean_Variance_Estimator___Sraw_Offset =
 80270e0:	687b      	ldr	r3, [r7, #4]
 80270e2:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            params->m_Mean_Variance_Estimator___Mean = 0.f;
 80270e6:	687b      	ldr	r3, [r7, #4]
 80270e8:	f04f 0200 	mov.w	r2, #0
 80270ec:	641a      	str	r2, [r3, #64]	; 0x40
        sraw = (sraw - params->m_Mean_Variance_Estimator___Sraw_Offset);
 80270ee:	687b      	ldr	r3, [r7, #4]
 80270f0:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
 80270f4:	ed97 7a00 	vldr	s14, [r7]
 80270f8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80270fc:	edc7 7a00 	vstr	s15, [r7]
        GasIndexAlgorithm__mean_variance_estimator___calculate_gamma(params);
 8027100:	6878      	ldr	r0, [r7, #4]
 8027102:	f7ff fe73 	bl	8026dec <GasIndexAlgorithm__mean_variance_estimator___calculate_gamma>
        delta_sgp = ((sraw - params->m_Mean_Variance_Estimator___Mean) /
 8027106:	687b      	ldr	r3, [r7, #4]
 8027108:	edd3 7a10 	vldr	s15, [r3, #64]	; 0x40
 802710c:	ed97 7a00 	vldr	s14, [r7]
 8027110:	ee37 7a67 	vsub.f32	s14, s14, s15
 8027114:	eddf 6a4a 	vldr	s13, [pc, #296]	; 8027240 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d0>
 8027118:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802711c:	edc7 7a03 	vstr	s15, [r7, #12]
        if ((delta_sgp < 0.f)) {
 8027120:	edd7 7a03 	vldr	s15, [r7, #12]
 8027124:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027128:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802712c:	d509      	bpl.n	8027142 <GasIndexAlgorithm__mean_variance_estimator__process+0xd2>
            c = (params->m_Mean_Variance_Estimator___Std - delta_sgp);
 802712e:	687b      	ldr	r3, [r7, #4]
 8027130:	ed93 7a12 	vldr	s14, [r3, #72]	; 0x48
 8027134:	edd7 7a03 	vldr	s15, [r7, #12]
 8027138:	ee77 7a67 	vsub.f32	s15, s14, s15
 802713c:	edc7 7a05 	vstr	s15, [r7, #20]
 8027140:	e008      	b.n	8027154 <GasIndexAlgorithm__mean_variance_estimator__process+0xe4>
            c = (params->m_Mean_Variance_Estimator___Std + delta_sgp);
 8027142:	687b      	ldr	r3, [r7, #4]
 8027144:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
 8027148:	ed97 7a03 	vldr	s14, [r7, #12]
 802714c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8027150:	edc7 7a05 	vstr	s15, [r7, #20]
        additional_scaling = 1.f;
 8027154:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8027158:	613b      	str	r3, [r7, #16]
        if ((c > 1440.f)) {
 802715a:	edd7 7a05 	vldr	s15, [r7, #20]
 802715e:	ed9f 7a39 	vldr	s14, [pc, #228]	; 8027244 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d4>
 8027162:	eef4 7ac7 	vcmpe.f32	s15, s14
 8027166:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802716a:	dd0f      	ble.n	802718c <GasIndexAlgorithm__mean_variance_estimator__process+0x11c>
            additional_scaling = ((c / 1440.f) * (c / 1440.f));
 802716c:	edd7 7a05 	vldr	s15, [r7, #20]
 8027170:	eddf 6a34 	vldr	s13, [pc, #208]	; 8027244 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d4>
 8027174:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8027178:	edd7 6a05 	vldr	s13, [r7, #20]
 802717c:	ed9f 6a31 	vldr	s12, [pc, #196]	; 8027244 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d4>
 8027180:	eec6 7a86 	vdiv.f32	s15, s13, s12
 8027184:	ee67 7a27 	vmul.f32	s15, s14, s15
 8027188:	edc7 7a04 	vstr	s15, [r7, #16]
                     params->m_Mean_Variance_Estimator__Gamma_Variance))) *
 802718c:	687b      	ldr	r3, [r7, #4]
 802718e:	edd3 7a18 	vldr	s15, [r3, #96]	; 0x60
                    (GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING -
 8027192:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 8027240 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d0>
 8027196:	ee37 7a67 	vsub.f32	s14, s14, s15
            (sqrtf((additional_scaling *
 802719a:	edd7 7a04 	vldr	s15, [r7, #16]
 802719e:	ee67 7a27 	vmul.f32	s15, s14, s15
 80271a2:	eeb0 0a67 	vmov.f32	s0, s15
 80271a6:	f002 fcf1 	bl	8029b8c <sqrtf>
 80271aa:	eeb0 8a40 	vmov.f32	s16, s0
                 ((params->m_Mean_Variance_Estimator___Std *
 80271ae:	687b      	ldr	r3, [r7, #4]
 80271b0:	ed93 7a12 	vldr	s14, [r3, #72]	; 0x48
                   (params->m_Mean_Variance_Estimator___Std /
 80271b4:	687b      	ldr	r3, [r7, #4]
 80271b6:	ed93 6a12 	vldr	s12, [r3, #72]	; 0x48
                    (GasIndexAlgorithm_MEAN_VARIANCE_ESTIMATOR__GAMMA_SCALING *
 80271ba:	edd7 7a04 	vldr	s15, [r7, #16]
 80271be:	eddf 6a20 	vldr	s13, [pc, #128]	; 8027240 <GasIndexAlgorithm__mean_variance_estimator__process+0x1d0>
 80271c2:	ee67 6aa6 	vmul.f32	s13, s15, s13
                   (params->m_Mean_Variance_Estimator___Std /
 80271c6:	eec6 7a26 	vdiv.f32	s15, s12, s13
                 ((params->m_Mean_Variance_Estimator___Std *
 80271ca:	ee27 7a27 	vmul.f32	s14, s14, s15
                  (((params->m_Mean_Variance_Estimator__Gamma_Variance *
 80271ce:	687b      	ldr	r3, [r7, #4]
 80271d0:	edd3 6a18 	vldr	s13, [r3, #96]	; 0x60
 80271d4:	edd7 7a03 	vldr	s15, [r7, #12]
 80271d8:	ee26 6aa7 	vmul.f32	s12, s13, s15
                     delta_sgp) /
 80271dc:	edd7 7a04 	vldr	s15, [r7, #16]
 80271e0:	eec6 6a27 	vdiv.f32	s13, s12, s15
                    additional_scaling) *
 80271e4:	edd7 7a03 	vldr	s15, [r7, #12]
 80271e8:	ee66 7aa7 	vmul.f32	s15, s13, s15
             sqrtf(
 80271ec:	ee77 7a27 	vadd.f32	s15, s14, s15
 80271f0:	eeb0 0a67 	vmov.f32	s0, s15
 80271f4:	f002 fcca 	bl	8029b8c <sqrtf>
 80271f8:	eef0 7a40 	vmov.f32	s15, s0
                     params->m_Mean_Variance_Estimator__Gamma_Variance))) *
 80271fc:	ee68 7a27 	vmul.f32	s15, s16, s15
        params->m_Mean_Variance_Estimator___Std =
 8027200:	687b      	ldr	r3, [r7, #4]
 8027202:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            (params->m_Mean_Variance_Estimator___Mean +
 8027206:	687b      	ldr	r3, [r7, #4]
 8027208:	ed93 7a10 	vldr	s14, [r3, #64]	; 0x40
             ((params->m_Mean_Variance_Estimator__Gamma_Mean * delta_sgp) /
 802720c:	687b      	ldr	r3, [r7, #4]
 802720e:	edd3 6a17 	vldr	s13, [r3, #92]	; 0x5c
 8027212:	edd7 7a03 	vldr	s15, [r7, #12]
 8027216:	ee66 6aa7 	vmul.f32	s13, s13, s15
 802721a:	eeb2 6a00 	vmov.f32	s12, #32	; 0x41000000  8.0
 802721e:	eec6 7a86 	vdiv.f32	s15, s13, s12
            (params->m_Mean_Variance_Estimator___Mean +
 8027222:	ee77 7a27 	vadd.f32	s15, s14, s15
        params->m_Mean_Variance_Estimator___Mean =
 8027226:	687b      	ldr	r3, [r7, #4]
 8027228:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
 802722c:	bf00      	nop
 802722e:	3718      	adds	r7, #24
 8027230:	46bd      	mov	sp, r7
 8027232:	ecbd 8b02 	vpop	{d8}
 8027236:	bd80      	pop	{r7, pc}
 8027238:	42c80000 	.word	0x42c80000
 802723c:	c2c80000 	.word	0xc2c80000
 8027240:	42800000 	.word	0x42800000
 8027244:	44b40000 	.word	0x44b40000

08027248 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters>:

static void
GasIndexAlgorithm__mean_variance_estimator___sigmoid__set_parameters(
    GasIndexAlgorithmParams* params, float X0, float K) {
 8027248:	b480      	push	{r7}
 802724a:	b085      	sub	sp, #20
 802724c:	af00      	add	r7, sp, #0
 802724e:	60f8      	str	r0, [r7, #12]
 8027250:	ed87 0a02 	vstr	s0, [r7, #8]
 8027254:	edc7 0a01 	vstr	s1, [r7, #4]

    params->m_Mean_Variance_Estimator___Sigmoid__K = K;
 8027258:	68fb      	ldr	r3, [r7, #12]
 802725a:	687a      	ldr	r2, [r7, #4]
 802725c:	671a      	str	r2, [r3, #112]	; 0x70
    params->m_Mean_Variance_Estimator___Sigmoid__X0 = X0;
 802725e:	68fb      	ldr	r3, [r7, #12]
 8027260:	68ba      	ldr	r2, [r7, #8]
 8027262:	675a      	str	r2, [r3, #116]	; 0x74
}
 8027264:	bf00      	nop
 8027266:	3714      	adds	r7, #20
 8027268:	46bd      	mov	sp, r7
 802726a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802726e:	4770      	bx	lr

08027270 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process>:

static float GasIndexAlgorithm__mean_variance_estimator___sigmoid__process(
    GasIndexAlgorithmParams* params, float sample) {
 8027270:	b580      	push	{r7, lr}
 8027272:	b084      	sub	sp, #16
 8027274:	af00      	add	r7, sp, #0
 8027276:	6078      	str	r0, [r7, #4]
 8027278:	ed87 0a00 	vstr	s0, [r7]

    float x;

    x = (params->m_Mean_Variance_Estimator___Sigmoid__K *
 802727c:	687b      	ldr	r3, [r7, #4]
 802727e:	ed93 7a1c 	vldr	s14, [r3, #112]	; 0x70
         (sample - params->m_Mean_Variance_Estimator___Sigmoid__X0));
 8027282:	687b      	ldr	r3, [r7, #4]
 8027284:	edd3 7a1d 	vldr	s15, [r3, #116]	; 0x74
 8027288:	edd7 6a00 	vldr	s13, [r7]
 802728c:	ee76 7ae7 	vsub.f32	s15, s13, s15
    x = (params->m_Mean_Variance_Estimator___Sigmoid__K *
 8027290:	ee67 7a27 	vmul.f32	s15, s14, s15
 8027294:	edc7 7a03 	vstr	s15, [r7, #12]
    if ((x < -50.f)) {
 8027298:	edd7 7a03 	vldr	s15, [r7, #12]
 802729c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 80272f0 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x80>
 80272a0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80272a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80272a8:	d502      	bpl.n	80272b0 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x40>
        return 1.f;
 80272aa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80272ae:	e019      	b.n	80272e4 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x74>
    } else if ((x > 50.f)) {
 80272b0:	edd7 7a03 	vldr	s15, [r7, #12]
 80272b4:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 80272f4 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x84>
 80272b8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80272bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80272c0:	dd02      	ble.n	80272c8 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x58>
        return 0.f;
 80272c2:	eddf 7a0d 	vldr	s15, [pc, #52]	; 80272f8 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x88>
 80272c6:	e00d      	b.n	80272e4 <GasIndexAlgorithm__mean_variance_estimator___sigmoid__process+0x74>
    } else {
        return (1.f / (1.f + expf(x)));
 80272c8:	ed97 0a03 	vldr	s0, [r7, #12]
 80272cc:	f002 fb1c 	bl	8029908 <expf>
 80272d0:	eef0 7a40 	vmov.f32	s15, s0
 80272d4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80272d8:	ee37 7a87 	vadd.f32	s14, s15, s14
 80272dc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80272e0:	eec6 7a87 	vdiv.f32	s15, s13, s14
    }
}
 80272e4:	eeb0 0a67 	vmov.f32	s0, s15
 80272e8:	3710      	adds	r7, #16
 80272ea:	46bd      	mov	sp, r7
 80272ec:	bd80      	pop	{r7, pc}
 80272ee:	bf00      	nop
 80272f0:	c2480000 	.word	0xc2480000
 80272f4:	42480000 	.word	0x42480000
 80272f8:	00000000 	.word	0x00000000

080272fc <GasIndexAlgorithm__mox_model__set_parameters>:

static void
GasIndexAlgorithm__mox_model__set_parameters(GasIndexAlgorithmParams* params,
                                             float SRAW_STD, float SRAW_MEAN) {
 80272fc:	b480      	push	{r7}
 80272fe:	b085      	sub	sp, #20
 8027300:	af00      	add	r7, sp, #0
 8027302:	60f8      	str	r0, [r7, #12]
 8027304:	ed87 0a02 	vstr	s0, [r7, #8]
 8027308:	edc7 0a01 	vstr	s1, [r7, #4]

    params->m_Mox_Model__Sraw_Std = SRAW_STD;
 802730c:	68fb      	ldr	r3, [r7, #12]
 802730e:	68ba      	ldr	r2, [r7, #8]
 8027310:	679a      	str	r2, [r3, #120]	; 0x78
    params->m_Mox_Model__Sraw_Mean = SRAW_MEAN;
 8027312:	68fb      	ldr	r3, [r7, #12]
 8027314:	687a      	ldr	r2, [r7, #4]
 8027316:	67da      	str	r2, [r3, #124]	; 0x7c
}
 8027318:	bf00      	nop
 802731a:	3714      	adds	r7, #20
 802731c:	46bd      	mov	sp, r7
 802731e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027322:	4770      	bx	lr

08027324 <GasIndexAlgorithm__mox_model__process>:

static float
GasIndexAlgorithm__mox_model__process(GasIndexAlgorithmParams* params,
                                      float sraw) {
 8027324:	b480      	push	{r7}
 8027326:	b083      	sub	sp, #12
 8027328:	af00      	add	r7, sp, #0
 802732a:	6078      	str	r0, [r7, #4]
 802732c:	ed87 0a00 	vstr	s0, [r7]

    if ((params->mAlgorithm_Type == GasIndexAlgorithm_ALGORITHM_TYPE_NOX)) {
 8027330:	687b      	ldr	r3, [r7, #4]
 8027332:	681b      	ldr	r3, [r3, #0]
 8027334:	2b01      	cmp	r3, #1
 8027336:	d110      	bne.n	802735a <GasIndexAlgorithm__mox_model__process+0x36>
        return (((sraw - params->m_Mox_Model__Sraw_Mean) /
 8027338:	687b      	ldr	r3, [r7, #4]
 802733a:	edd3 7a1f 	vldr	s15, [r3, #124]	; 0x7c
 802733e:	ed97 7a00 	vldr	s14, [r7]
 8027342:	ee77 7a67 	vsub.f32	s15, s14, s15
 8027346:	eddf 6a14 	vldr	s13, [pc, #80]	; 8027398 <GasIndexAlgorithm__mox_model__process+0x74>
 802734a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
                 GasIndexAlgorithm_SRAW_STD_NOX) *
                params->mIndex_Gain);
 802734e:	687b      	ldr	r3, [r7, #4]
 8027350:	edd3 7a08 	vldr	s15, [r3, #32]
                 GasIndexAlgorithm_SRAW_STD_NOX) *
 8027354:	ee67 7a27 	vmul.f32	s15, s14, s15
 8027358:	e016      	b.n	8027388 <GasIndexAlgorithm__mox_model__process+0x64>
    } else {
        return (((sraw - params->m_Mox_Model__Sraw_Mean) /
 802735a:	687b      	ldr	r3, [r7, #4]
 802735c:	edd3 7a1f 	vldr	s15, [r3, #124]	; 0x7c
 8027360:	ed97 7a00 	vldr	s14, [r7]
 8027364:	ee77 7a67 	vsub.f32	s15, s14, s15
 8027368:	eef1 6a67 	vneg.f32	s13, s15
                 (-1.f * (params->m_Mox_Model__Sraw_Std +
 802736c:	687b      	ldr	r3, [r7, #4]
 802736e:	edd3 7a1e 	vldr	s15, [r3, #120]	; 0x78
 8027372:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 802739c <GasIndexAlgorithm__mox_model__process+0x78>
 8027376:	ee77 7a87 	vadd.f32	s15, s15, s14
        return (((sraw - params->m_Mox_Model__Sraw_Mean) /
 802737a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
                          GasIndexAlgorithm_SRAW_STD_BONUS_VOC))) *
                params->mIndex_Gain);
 802737e:	687b      	ldr	r3, [r7, #4]
 8027380:	edd3 7a08 	vldr	s15, [r3, #32]
                          GasIndexAlgorithm_SRAW_STD_BONUS_VOC))) *
 8027384:	ee67 7a27 	vmul.f32	s15, s14, s15
    }
}
 8027388:	eeb0 0a67 	vmov.f32	s0, s15
 802738c:	370c      	adds	r7, #12
 802738e:	46bd      	mov	sp, r7
 8027390:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027394:	4770      	bx	lr
 8027396:	bf00      	nop
 8027398:	44fa0000 	.word	0x44fa0000
 802739c:	435c0000 	.word	0x435c0000

080273a0 <GasIndexAlgorithm__sigmoid_scaled__set_parameters>:

static void GasIndexAlgorithm__sigmoid_scaled__set_parameters(
    GasIndexAlgorithmParams* params, float X0, float K, float offset_default) {
 80273a0:	b480      	push	{r7}
 80273a2:	b085      	sub	sp, #20
 80273a4:	af00      	add	r7, sp, #0
 80273a6:	60f8      	str	r0, [r7, #12]
 80273a8:	ed87 0a02 	vstr	s0, [r7, #8]
 80273ac:	edc7 0a01 	vstr	s1, [r7, #4]
 80273b0:	ed87 1a00 	vstr	s2, [r7]

    params->m_Sigmoid_Scaled__K = K;
 80273b4:	68fb      	ldr	r3, [r7, #12]
 80273b6:	687a      	ldr	r2, [r7, #4]
 80273b8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    params->m_Sigmoid_Scaled__X0 = X0;
 80273bc:	68fb      	ldr	r3, [r7, #12]
 80273be:	68ba      	ldr	r2, [r7, #8]
 80273c0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    params->m_Sigmoid_Scaled__Offset_Default = offset_default;
 80273c4:	68fb      	ldr	r3, [r7, #12]
 80273c6:	683a      	ldr	r2, [r7, #0]
 80273c8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
 80273cc:	bf00      	nop
 80273ce:	3714      	adds	r7, #20
 80273d0:	46bd      	mov	sp, r7
 80273d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273d6:	4770      	bx	lr

080273d8 <GasIndexAlgorithm__sigmoid_scaled__process>:

static float
GasIndexAlgorithm__sigmoid_scaled__process(GasIndexAlgorithmParams* params,
                                           float sample) {
 80273d8:	b580      	push	{r7, lr}
 80273da:	ed2d 8b02 	vpush	{d8}
 80273de:	b084      	sub	sp, #16
 80273e0:	af00      	add	r7, sp, #0
 80273e2:	6078      	str	r0, [r7, #4]
 80273e4:	ed87 0a00 	vstr	s0, [r7]

    float x;
    float shift;

    x = (params->m_Sigmoid_Scaled__K * (sample - params->m_Sigmoid_Scaled__X0));
 80273e8:	687b      	ldr	r3, [r7, #4]
 80273ea:	ed93 7a20 	vldr	s14, [r3, #128]	; 0x80
 80273ee:	687b      	ldr	r3, [r7, #4]
 80273f0:	edd3 7a21 	vldr	s15, [r3, #132]	; 0x84
 80273f4:	edd7 6a00 	vldr	s13, [r7]
 80273f8:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80273fc:	ee67 7a27 	vmul.f32	s15, s14, s15
 8027400:	edc7 7a02 	vstr	s15, [r7, #8]
    if ((x < -50.f)) {
 8027404:	edd7 7a02 	vldr	s15, [r7, #8]
 8027408:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 8027500 <GasIndexAlgorithm__sigmoid_scaled__process+0x128>
 802740c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8027410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027414:	d502      	bpl.n	802741c <GasIndexAlgorithm__sigmoid_scaled__process+0x44>
        return GasIndexAlgorithm_SIGMOID_L;
 8027416:	eddf 7a3b 	vldr	s15, [pc, #236]	; 8027504 <GasIndexAlgorithm__sigmoid_scaled__process+0x12c>
 802741a:	e06a      	b.n	80274f2 <GasIndexAlgorithm__sigmoid_scaled__process+0x11a>
    } else if ((x > 50.f)) {
 802741c:	edd7 7a02 	vldr	s15, [r7, #8]
 8027420:	ed9f 7a39 	vldr	s14, [pc, #228]	; 8027508 <GasIndexAlgorithm__sigmoid_scaled__process+0x130>
 8027424:	eef4 7ac7 	vcmpe.f32	s15, s14
 8027428:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802742c:	dd02      	ble.n	8027434 <GasIndexAlgorithm__sigmoid_scaled__process+0x5c>
        return 0.f;
 802742e:	eddf 7a37 	vldr	s15, [pc, #220]	; 802750c <GasIndexAlgorithm__sigmoid_scaled__process+0x134>
 8027432:	e05e      	b.n	80274f2 <GasIndexAlgorithm__sigmoid_scaled__process+0x11a>
    } else {
        if ((sample >= 0.f)) {
 8027434:	edd7 7a00 	vldr	s15, [r7]
 8027438:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802743c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027440:	db3f      	blt.n	80274c2 <GasIndexAlgorithm__sigmoid_scaled__process+0xea>
            if ((params->m_Sigmoid_Scaled__Offset_Default == 1.f)) {
 8027442:	687b      	ldr	r3, [r7, #4]
 8027444:	edd3 7a22 	vldr	s15, [r3, #136]	; 0x88
 8027448:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802744c:	eef4 7a47 	vcmp.f32	s15, s14
 8027450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027454:	d10d      	bne.n	8027472 <GasIndexAlgorithm__sigmoid_scaled__process+0x9a>
                shift = ((500.f / 499.f) * (1.f - params->mIndex_Offset));
 8027456:	687b      	ldr	r3, [r7, #4]
 8027458:	edd3 7a02 	vldr	s15, [r3, #8]
 802745c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8027460:	ee77 7a67 	vsub.f32	s15, s14, s15
 8027464:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 8027510 <GasIndexAlgorithm__sigmoid_scaled__process+0x138>
 8027468:	ee67 7a87 	vmul.f32	s15, s15, s14
 802746c:	edc7 7a03 	vstr	s15, [r7, #12]
 8027470:	e010      	b.n	8027494 <GasIndexAlgorithm__sigmoid_scaled__process+0xbc>
            } else {
                shift = ((GasIndexAlgorithm_SIGMOID_L -
                          (5.f * params->mIndex_Offset)) /
 8027472:	687b      	ldr	r3, [r7, #4]
 8027474:	edd3 7a02 	vldr	s15, [r3, #8]
 8027478:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
 802747c:	ee67 7a87 	vmul.f32	s15, s15, s14
                shift = ((GasIndexAlgorithm_SIGMOID_L -
 8027480:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8027504 <GasIndexAlgorithm__sigmoid_scaled__process+0x12c>
 8027484:	ee37 7a67 	vsub.f32	s14, s14, s15
 8027488:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802748c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8027490:	edc7 7a03 	vstr	s15, [r7, #12]
                         4.f);
            }
            return (((GasIndexAlgorithm_SIGMOID_L + shift) / (1.f + expf(x))) -
 8027494:	edd7 7a03 	vldr	s15, [r7, #12]
 8027498:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 8027504 <GasIndexAlgorithm__sigmoid_scaled__process+0x12c>
 802749c:	ee37 8a87 	vadd.f32	s16, s15, s14
 80274a0:	ed97 0a02 	vldr	s0, [r7, #8]
 80274a4:	f002 fa30 	bl	8029908 <expf>
 80274a8:	eef0 7a40 	vmov.f32	s15, s0
 80274ac:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80274b0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80274b4:	ee88 7a27 	vdiv.f32	s14, s16, s15
 80274b8:	edd7 7a03 	vldr	s15, [r7, #12]
 80274bc:	ee77 7a67 	vsub.f32	s15, s14, s15
 80274c0:	e017      	b.n	80274f2 <GasIndexAlgorithm__sigmoid_scaled__process+0x11a>
                    shift);
        } else {
            return ((params->mIndex_Offset /
 80274c2:	687b      	ldr	r3, [r7, #4]
 80274c4:	ed93 7a02 	vldr	s14, [r3, #8]
                     params->m_Sigmoid_Scaled__Offset_Default) *
 80274c8:	687b      	ldr	r3, [r7, #4]
 80274ca:	edd3 7a22 	vldr	s15, [r3, #136]	; 0x88
            return ((params->mIndex_Offset /
 80274ce:	ee87 8a27 	vdiv.f32	s16, s14, s15
                    (GasIndexAlgorithm_SIGMOID_L / (1.f + expf(x))));
 80274d2:	ed97 0a02 	vldr	s0, [r7, #8]
 80274d6:	f002 fa17 	bl	8029908 <expf>
 80274da:	eef0 7a40 	vmov.f32	s15, s0
 80274de:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80274e2:	ee37 7a87 	vadd.f32	s14, s15, s14
 80274e6:	eddf 6a07 	vldr	s13, [pc, #28]	; 8027504 <GasIndexAlgorithm__sigmoid_scaled__process+0x12c>
 80274ea:	eec6 7a87 	vdiv.f32	s15, s13, s14
                     params->m_Sigmoid_Scaled__Offset_Default) *
 80274ee:	ee68 7a27 	vmul.f32	s15, s16, s15
        }
    }
}
 80274f2:	eeb0 0a67 	vmov.f32	s0, s15
 80274f6:	3710      	adds	r7, #16
 80274f8:	46bd      	mov	sp, r7
 80274fa:	ecbd 8b02 	vpop	{d8}
 80274fe:	bd80      	pop	{r7, pc}
 8027500:	c2480000 	.word	0xc2480000
 8027504:	43fa0000 	.word	0x43fa0000
 8027508:	42480000 	.word	0x42480000
 802750c:	00000000 	.word	0x00000000
 8027510:	3f8041ab 	.word	0x3f8041ab

08027514 <GasIndexAlgorithm__adaptive_lowpass__set_parameters>:

static void GasIndexAlgorithm__adaptive_lowpass__set_parameters(
    GasIndexAlgorithmParams* params) {
 8027514:	b480      	push	{r7}
 8027516:	b083      	sub	sp, #12
 8027518:	af00      	add	r7, sp, #0
 802751a:	6078      	str	r0, [r7, #4]

    params->m_Adaptive_Lowpass__A1 =
        (params->mSamplingInterval /
 802751c:	687b      	ldr	r3, [r7, #4]
 802751e:	edd3 6a01 	vldr	s13, [r3, #4]
         (GasIndexAlgorithm_LP_TAU_FAST + params->mSamplingInterval));
 8027522:	687b      	ldr	r3, [r7, #4]
 8027524:	edd3 7a01 	vldr	s15, [r3, #4]
 8027528:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 802752c:	ee37 7a87 	vadd.f32	s14, s15, s14
        (params->mSamplingInterval /
 8027530:	eec6 7a87 	vdiv.f32	s15, s13, s14
    params->m_Adaptive_Lowpass__A1 =
 8027534:	687b      	ldr	r3, [r7, #4]
 8027536:	edc3 7a23 	vstr	s15, [r3, #140]	; 0x8c
    params->m_Adaptive_Lowpass__A2 =
        (params->mSamplingInterval /
 802753a:	687b      	ldr	r3, [r7, #4]
 802753c:	edd3 6a01 	vldr	s13, [r3, #4]
         (GasIndexAlgorithm_LP_TAU_SLOW + params->mSamplingInterval));
 8027540:	687b      	ldr	r3, [r7, #4]
 8027542:	edd3 7a01 	vldr	s15, [r3, #4]
 8027546:	ed9f 7a09 	vldr	s14, [pc, #36]	; 802756c <GasIndexAlgorithm__adaptive_lowpass__set_parameters+0x58>
 802754a:	ee37 7a87 	vadd.f32	s14, s15, s14
        (params->mSamplingInterval /
 802754e:	eec6 7a87 	vdiv.f32	s15, s13, s14
    params->m_Adaptive_Lowpass__A2 =
 8027552:	687b      	ldr	r3, [r7, #4]
 8027554:	edc3 7a24 	vstr	s15, [r3, #144]	; 0x90
    params->m_Adaptive_Lowpass___Initialized = false;
 8027558:	687b      	ldr	r3, [r7, #4]
 802755a:	2200      	movs	r2, #0
 802755c:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
}
 8027560:	bf00      	nop
 8027562:	370c      	adds	r7, #12
 8027564:	46bd      	mov	sp, r7
 8027566:	f85d 7b04 	ldr.w	r7, [sp], #4
 802756a:	4770      	bx	lr
 802756c:	43fa0000 	.word	0x43fa0000

08027570 <GasIndexAlgorithm__adaptive_lowpass__process>:

static float
GasIndexAlgorithm__adaptive_lowpass__process(GasIndexAlgorithmParams* params,
                                             float sample) {
 8027570:	b580      	push	{r7, lr}
 8027572:	b086      	sub	sp, #24
 8027574:	af00      	add	r7, sp, #0
 8027576:	6078      	str	r0, [r7, #4]
 8027578:	ed87 0a00 	vstr	s0, [r7]
    float abs_delta;
    float F1;
    float tau_a;
    float a3;

    if ((params->m_Adaptive_Lowpass___Initialized == false)) {
 802757c:	687b      	ldr	r3, [r7, #4]
 802757e:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8027582:	f083 0301 	eor.w	r3, r3, #1
 8027586:	b2db      	uxtb	r3, r3
 8027588:	2b00      	cmp	r3, #0
 802758a:	d00f      	beq.n	80275ac <GasIndexAlgorithm__adaptive_lowpass__process+0x3c>
        params->m_Adaptive_Lowpass___X1 = sample;
 802758c:	687b      	ldr	r3, [r7, #4]
 802758e:	683a      	ldr	r2, [r7, #0]
 8027590:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        params->m_Adaptive_Lowpass___X2 = sample;
 8027594:	687b      	ldr	r3, [r7, #4]
 8027596:	683a      	ldr	r2, [r7, #0]
 8027598:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
        params->m_Adaptive_Lowpass___X3 = sample;
 802759c:	687b      	ldr	r3, [r7, #4]
 802759e:	683a      	ldr	r2, [r7, #0]
 80275a0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
        params->m_Adaptive_Lowpass___Initialized = true;
 80275a4:	687b      	ldr	r3, [r7, #4]
 80275a6:	2201      	movs	r2, #1
 80275a8:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
    }
    params->m_Adaptive_Lowpass___X1 =
        (((1.f - params->m_Adaptive_Lowpass__A1) *
 80275ac:	687b      	ldr	r3, [r7, #4]
 80275ae:	edd3 7a23 	vldr	s15, [r3, #140]	; 0x8c
 80275b2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80275b6:	ee37 7a67 	vsub.f32	s14, s14, s15
          params->m_Adaptive_Lowpass___X1) +
 80275ba:	687b      	ldr	r3, [r7, #4]
 80275bc:	edd3 7a26 	vldr	s15, [r3, #152]	; 0x98
        (((1.f - params->m_Adaptive_Lowpass__A1) *
 80275c0:	ee27 7a27 	vmul.f32	s14, s14, s15
         (params->m_Adaptive_Lowpass__A1 * sample));
 80275c4:	687b      	ldr	r3, [r7, #4]
 80275c6:	edd3 6a23 	vldr	s13, [r3, #140]	; 0x8c
 80275ca:	edd7 7a00 	vldr	s15, [r7]
 80275ce:	ee66 7aa7 	vmul.f32	s15, s13, s15
          params->m_Adaptive_Lowpass___X1) +
 80275d2:	ee77 7a27 	vadd.f32	s15, s14, s15
    params->m_Adaptive_Lowpass___X1 =
 80275d6:	687b      	ldr	r3, [r7, #4]
 80275d8:	edc3 7a26 	vstr	s15, [r3, #152]	; 0x98
    params->m_Adaptive_Lowpass___X2 =
        (((1.f - params->m_Adaptive_Lowpass__A2) *
 80275dc:	687b      	ldr	r3, [r7, #4]
 80275de:	edd3 7a24 	vldr	s15, [r3, #144]	; 0x90
 80275e2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80275e6:	ee37 7a67 	vsub.f32	s14, s14, s15
          params->m_Adaptive_Lowpass___X2) +
 80275ea:	687b      	ldr	r3, [r7, #4]
 80275ec:	edd3 7a27 	vldr	s15, [r3, #156]	; 0x9c
        (((1.f - params->m_Adaptive_Lowpass__A2) *
 80275f0:	ee27 7a27 	vmul.f32	s14, s14, s15
         (params->m_Adaptive_Lowpass__A2 * sample));
 80275f4:	687b      	ldr	r3, [r7, #4]
 80275f6:	edd3 6a24 	vldr	s13, [r3, #144]	; 0x90
 80275fa:	edd7 7a00 	vldr	s15, [r7]
 80275fe:	ee66 7aa7 	vmul.f32	s15, s13, s15
          params->m_Adaptive_Lowpass___X2) +
 8027602:	ee77 7a27 	vadd.f32	s15, s14, s15
    params->m_Adaptive_Lowpass___X2 =
 8027606:	687b      	ldr	r3, [r7, #4]
 8027608:	edc3 7a27 	vstr	s15, [r3, #156]	; 0x9c
    abs_delta =
        (params->m_Adaptive_Lowpass___X1 - params->m_Adaptive_Lowpass___X2);
 802760c:	687b      	ldr	r3, [r7, #4]
 802760e:	ed93 7a26 	vldr	s14, [r3, #152]	; 0x98
 8027612:	687b      	ldr	r3, [r7, #4]
 8027614:	edd3 7a27 	vldr	s15, [r3, #156]	; 0x9c
    abs_delta =
 8027618:	ee77 7a67 	vsub.f32	s15, s14, s15
 802761c:	edc7 7a05 	vstr	s15, [r7, #20]
    if ((abs_delta < 0.f)) {
 8027620:	edd7 7a05 	vldr	s15, [r7, #20]
 8027624:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027628:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802762c:	d505      	bpl.n	802763a <GasIndexAlgorithm__adaptive_lowpass__process+0xca>
        abs_delta = (-1.f * abs_delta);
 802762e:	edd7 7a05 	vldr	s15, [r7, #20]
 8027632:	eef1 7a67 	vneg.f32	s15, s15
 8027636:	edc7 7a05 	vstr	s15, [r7, #20]
    }
    F1 = expf((GasIndexAlgorithm_LP_ALPHA * abs_delta));
 802763a:	edd7 7a05 	vldr	s15, [r7, #20]
 802763e:	ed9f 7a22 	vldr	s14, [pc, #136]	; 80276c8 <GasIndexAlgorithm__adaptive_lowpass__process+0x158>
 8027642:	ee67 7a87 	vmul.f32	s15, s15, s14
 8027646:	eeb0 0a67 	vmov.f32	s0, s15
 802764a:	f002 f95d 	bl	8029908 <expf>
 802764e:	ed87 0a04 	vstr	s0, [r7, #16]
    tau_a = (((GasIndexAlgorithm_LP_TAU_SLOW - GasIndexAlgorithm_LP_TAU_FAST) *
 8027652:	edd7 7a04 	vldr	s15, [r7, #16]
 8027656:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 80276cc <GasIndexAlgorithm__adaptive_lowpass__process+0x15c>
 802765a:	ee67 7a87 	vmul.f32	s15, s15, s14
 802765e:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 8027662:	ee77 7a87 	vadd.f32	s15, s15, s14
 8027666:	edc7 7a03 	vstr	s15, [r7, #12]
              F1) +
             GasIndexAlgorithm_LP_TAU_FAST);
    a3 = (params->mSamplingInterval / (params->mSamplingInterval + tau_a));
 802766a:	687b      	ldr	r3, [r7, #4]
 802766c:	edd3 6a01 	vldr	s13, [r3, #4]
 8027670:	687b      	ldr	r3, [r7, #4]
 8027672:	ed93 7a01 	vldr	s14, [r3, #4]
 8027676:	edd7 7a03 	vldr	s15, [r7, #12]
 802767a:	ee37 7a27 	vadd.f32	s14, s14, s15
 802767e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8027682:	edc7 7a02 	vstr	s15, [r7, #8]
    params->m_Adaptive_Lowpass___X3 =
        (((1.f - a3) * params->m_Adaptive_Lowpass___X3) + (a3 * sample));
 8027686:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802768a:	edd7 7a02 	vldr	s15, [r7, #8]
 802768e:	ee37 7a67 	vsub.f32	s14, s14, s15
 8027692:	687b      	ldr	r3, [r7, #4]
 8027694:	edd3 7a28 	vldr	s15, [r3, #160]	; 0xa0
 8027698:	ee27 7a27 	vmul.f32	s14, s14, s15
 802769c:	edd7 6a02 	vldr	s13, [r7, #8]
 80276a0:	edd7 7a00 	vldr	s15, [r7]
 80276a4:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80276a8:	ee77 7a27 	vadd.f32	s15, s14, s15
    params->m_Adaptive_Lowpass___X3 =
 80276ac:	687b      	ldr	r3, [r7, #4]
 80276ae:	edc3 7a28 	vstr	s15, [r3, #160]	; 0xa0
    return params->m_Adaptive_Lowpass___X3;
 80276b2:	687b      	ldr	r3, [r7, #4]
 80276b4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 80276b8:	ee07 3a90 	vmov	s15, r3
}
 80276bc:	eeb0 0a67 	vmov.f32	s0, s15
 80276c0:	3718      	adds	r7, #24
 80276c2:	46bd      	mov	sp, r7
 80276c4:	bd80      	pop	{r7, pc}
 80276c6:	bf00      	nop
 80276c8:	be4ccccd 	.word	0xbe4ccccd
 80276cc:	43f00000 	.word	0x43f00000

080276d0 <LL_FLASH_GetUDN>:
  * @note   The 64-bit UID64 may be used by Firmware to derive BLE 48-bit Device Address EUI-48 or
  *         802.15.4 64-bit Device Address EUI-64.
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
 80276d0:	b480      	push	{r7}
 80276d2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_REG(*((uint32_t *)UID64_BASE)));
 80276d4:	4b03      	ldr	r3, [pc, #12]	; (80276e4 <LL_FLASH_GetUDN+0x14>)
 80276d6:	681b      	ldr	r3, [r3, #0]
}
 80276d8:	4618      	mov	r0, r3
 80276da:	46bd      	mov	sp, r7
 80276dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80276e0:	4770      	bx	lr
 80276e2:	bf00      	nop
 80276e4:	1fff7580 	.word	0x1fff7580

080276e8 <LL_FLASH_GetDeviceID>:
  *         802.15.4 64-bit Device Address EUI-64.
  *         For STM32WBxxxx devices, the device ID is 0x26
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x26 for STM32WB55x)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
 80276e8:	b480      	push	{r7}
 80276ea:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 80276ec:	4b03      	ldr	r3, [pc, #12]	; (80276fc <LL_FLASH_GetDeviceID+0x14>)
 80276ee:	681b      	ldr	r3, [r3, #0]
 80276f0:	b2db      	uxtb	r3, r3
}
 80276f2:	4618      	mov	r0, r3
 80276f4:	46bd      	mov	sp, r7
 80276f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80276fa:	4770      	bx	lr
 80276fc:	1fff7584 	.word	0x1fff7584

08027700 <LL_FLASH_GetSTCompanyID>:
  *         802.15.4 64-bit Device Address EUI-64.
  *         For STM32WBxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
 8027700:	b480      	push	{r7}
 8027702:	af00      	add	r7, sp, #0
  return (uint32_t)(((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U ) & 0x00FFFFFFU);
 8027704:	4b03      	ldr	r3, [pc, #12]	; (8027714 <LL_FLASH_GetSTCompanyID+0x14>)
 8027706:	681b      	ldr	r3, [r3, #0]
 8027708:	0a1b      	lsrs	r3, r3, #8
}
 802770a:	4618      	mov	r0, r3
 802770c:	46bd      	mov	sp, r7
 802770e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027712:	4770      	bx	lr
 8027714:	1fff7584 	.word	0x1fff7584

08027718 <APP_BLE_Init>:

/* USER CODE END EV */

/* Functions Definition ------------------------------------------------------*/
void APP_BLE_Init( void )
{
 8027718:	b5b0      	push	{r4, r5, r7, lr}
 802771a:	b08e      	sub	sp, #56	; 0x38
 802771c:	af00      	add	r7, sp, #0
/* USER CODE BEGIN APP_BLE_Init_1 */
//#ifndef CUSTOM_BT_PARAMETERS
/* USER CODE END APP_BLE_Init_1 */
  SHCI_C2_Ble_Init_Cmd_Packet_t ble_init_cmd_packet =
 802771e:	4b2b      	ldr	r3, [pc, #172]	; (80277cc <APP_BLE_Init+0xb4>)
 8027720:	1d3c      	adds	r4, r7, #4
 8027722:	461d      	mov	r5, r3
 8027724:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8027726:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8027728:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802772a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802772c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802772e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8027730:	682b      	ldr	r3, [r5, #0]
 8027732:	7023      	strb	r3, [r4, #0]
  };

  /**
   * Initialize Ble Transport Layer
   */
  Ble_Tl_Init( );
 8027734:	f000 f91e 	bl	8027974 <Ble_Tl_Init>

  /**
   * Do not allow standby in the application
   */
  UTIL_LPM_SetOffMode(1 << CFG_LPM_APP_BLE, UTIL_LPM_DISABLE);
 8027738:	2101      	movs	r1, #1
 802773a:	2002      	movs	r0, #2
 802773c:	f001 fd52 	bl	80291e4 <UTIL_LPM_SetOffMode>

  /**
   * Register the hci transport layer to handle BLE User Asynchronous Events
   */
  HciUserEvtProcessId = osThreadNew(HciUserEvtProcess, NULL, &HciUserEvtProcess_attr);
 8027740:	4a23      	ldr	r2, [pc, #140]	; (80277d0 <APP_BLE_Init+0xb8>)
 8027742:	2100      	movs	r1, #0
 8027744:	4823      	ldr	r0, [pc, #140]	; (80277d4 <APP_BLE_Init+0xbc>)
 8027746:	f7fa feef 	bl	8022528 <osThreadNew>
 802774a:	4603      	mov	r3, r0
 802774c:	4a22      	ldr	r2, [pc, #136]	; (80277d8 <APP_BLE_Init+0xc0>)
 802774e:	6013      	str	r3, [r2, #0]

  /**
   * Starts the BLE Stack on CPU2
   */
  if (SHCI_C2_BLE_Init( &ble_init_cmd_packet ) != SHCI_Success)
 8027750:	1d3b      	adds	r3, r7, #4
 8027752:	4618      	mov	r0, r3
 8027754:	f7f3 fd64 	bl	801b220 <SHCI_C2_BLE_Init>
 8027758:	4603      	mov	r3, r0
 802775a:	2b00      	cmp	r3, #0
 802775c:	d001      	beq.n	8027762 <APP_BLE_Init+0x4a>
  {
    Error_Handler();
 802775e:	f7e3 fbc5 	bl	800aeec <Error_Handler>
  }

  /**
   * Initialization of HCI & GATT & GAP layer
   */
  Ble_Hci_Gap_Gatt_Init();
 8027762:	f000 f92f 	bl	80279c4 <Ble_Hci_Gap_Gatt_Init>

  /**
   * Initialization of the BLE Services
   */
  SVCCTL_Init();
 8027766:	f7f3 fcb5 	bl	801b0d4 <SVCCTL_Init>

  /**
   * Initialization of the BLE App Context
   */
  BleApplicationContext.Device_Connection_Status = APP_BLE_IDLE;
 802776a:	4b1c      	ldr	r3, [pc, #112]	; (80277dc <APP_BLE_Init+0xc4>)
 802776c:	2200      	movs	r2, #0
 802776e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
  BleApplicationContext.BleApplicationContext_legacy.connectionHandle = 0xFFFF;
 8027772:	4b1a      	ldr	r3, [pc, #104]	; (80277dc <APP_BLE_Init+0xc4>)
 8027774:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8027778:	82da      	strh	r2, [r3, #22]
  /**
   * From here, all initialization are BLE application specific
   */
  AdvUpdateProcessId = osThreadNew(AdvUpdateProcess, NULL, &AdvUpdateProcess_attr);
 802777a:	4a19      	ldr	r2, [pc, #100]	; (80277e0 <APP_BLE_Init+0xc8>)
 802777c:	2100      	movs	r1, #0
 802777e:	4819      	ldr	r0, [pc, #100]	; (80277e4 <APP_BLE_Init+0xcc>)
 8027780:	f7fa fed2 	bl	8022528 <osThreadNew>
 8027784:	4603      	mov	r3, r0
 8027786:	4a18      	ldr	r2, [pc, #96]	; (80277e8 <APP_BLE_Init+0xd0>)
 8027788:	6013      	str	r3, [r2, #0]
//  HRSAPP_Init();

/* USER CODE BEGIN APP_BLE_Init_3 */
//  DTS_STM_Init();
//  DTC_App_Init();
  startThreads();
 802778a:	f7e1 fcc5 	bl	8009118 <startThreads>

  ledDisconnectNotification();
 802778e:	f7e3 f925 	bl	800a9dc <ledDisconnectNotification>

  /**
   * Create timer to handle the connection state machine
   */

  HW_TS_Create(CFG_TIM_PROC_ID_ISR, &(BleApplicationContext.Advertising_mgr_timer_Id), hw_ts_SingleShot, Adv_Mgr);
 8027792:	4b16      	ldr	r3, [pc, #88]	; (80277ec <APP_BLE_Init+0xd4>)
 8027794:	2200      	movs	r2, #0
 8027796:	4916      	ldr	r1, [pc, #88]	; (80277f0 <APP_BLE_Init+0xd8>)
 8027798:	2000      	movs	r0, #0
 802779a:	f7e2 fcd1 	bl	800a140 <HW_TS_Create>

  /**
   * Make device discoverable
   */
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[0] = AD_TYPE_16_BIT_SERV_UUID;
 802779e:	4b0f      	ldr	r3, [pc, #60]	; (80277dc <APP_BLE_Init+0xc4>)
 80277a0:	2202      	movs	r2, #2
 80277a2:	765a      	strb	r2, [r3, #25]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen = 1;
 80277a4:	4b0d      	ldr	r3, [pc, #52]	; (80277dc <APP_BLE_Init+0xc4>)
 80277a6:	2201      	movs	r2, #1
 80277a8:	761a      	strb	r2, [r3, #24]

//  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[0] = AD_TYPE_128_BIT_SERV_UUID;
//  BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen = 1;

    Add_Advertisment_Service_UUID(DATA_TRANSFER_SERVICE_UUID);
 80277aa:	f64f 6080 	movw	r0, #65152	; 0xfe80
 80277ae:	f000 fa7b 	bl	8027ca8 <Add_Advertisment_Service_UUID>
//  Add_Advertisment_Service_UUID_128(DT_REQ_CHAR_UUID);


  /* Initialize intervals for reconnexion without intervals update */
  AdvIntervalMin = CFG_FAST_CONN_ADV_INTERVAL_MIN;
 80277b2:	4b10      	ldr	r3, [pc, #64]	; (80277f4 <APP_BLE_Init+0xdc>)
 80277b4:	2280      	movs	r2, #128	; 0x80
 80277b6:	801a      	strh	r2, [r3, #0]
  AdvIntervalMax = CFG_FAST_CONN_ADV_INTERVAL_MAX;
 80277b8:	4b0f      	ldr	r3, [pc, #60]	; (80277f8 <APP_BLE_Init+0xe0>)
 80277ba:	22a0      	movs	r2, #160	; 0xa0
 80277bc:	801a      	strh	r2, [r3, #0]

  /**
  * Start to Advertise to be connected by Collector
   */
   Adv_Request(APP_BLE_FAST_ADV);
 80277be:	2001      	movs	r0, #1
 80277c0:	f000 f9be 	bl	8027b40 <Adv_Request>
//	Adv_Request(APP_BLE_FAST_ADV);
//
////	InitThreads();
//#endif
/* USER CODE END APP_BLE_Init_2 */
  return;
 80277c4:	bf00      	nop
}
 80277c6:	3738      	adds	r7, #56	; 0x38
 80277c8:	46bd      	mov	sp, r7
 80277ca:	bdb0      	pop	{r4, r5, r7, pc}
 80277cc:	0802c698 	.word	0x0802c698
 80277d0:	0802d52c 	.word	0x0802d52c
 80277d4:	08027d41 	.word	0x08027d41
 80277d8:	20012380 	.word	0x20012380
 80277dc:	2000030c 	.word	0x2000030c
 80277e0:	0802d508 	.word	0x0802d508
 80277e4:	08027d19 	.word	0x08027d19
 80277e8:	20012398 	.word	0x20012398
 80277ec:	08027d01 	.word	0x08027d01
 80277f0:	2000038d 	.word	0x2000038d
 80277f4:	20000390 	.word	0x20000390
 80277f8:	20000392 	.word	0x20000392

080277fc <SVCCTL_App_Notification>:

SVCCTL_UserEvtFlowStatus_t SVCCTL_App_Notification( void *pckt )
{
 80277fc:	b580      	push	{r7, lr}
 80277fe:	b08a      	sub	sp, #40	; 0x28
 8027800:	af00      	add	r7, sp, #0
 8027802:	6078      	str	r0, [r7, #4]
  hci_event_pckt *event_pckt;
  evt_le_meta_event *meta_evt;
  evt_blecore_aci *blecore_evt;
  hci_le_phy_update_complete_event_rp0 *evt_le_phy_update_complete;
  uint8_t TX_PHY, RX_PHY;
  tBleStatus ret = BLE_STATUS_INVALID_PARAMS;
 8027804:	2392      	movs	r3, #146	; 0x92
 8027806:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  event_pckt = (hci_event_pckt*) ((hci_uart_pckt *) pckt)->data;
 802780a:	687b      	ldr	r3, [r7, #4]
 802780c:	3301      	adds	r3, #1
 802780e:	623b      	str	r3, [r7, #32]

  /* USER CODE BEGIN SVCCTL_App_Notification */
//#ifndef CUSTOM_BT_PARAMETERS
  /* USER CODE END SVCCTL_App_Notification */

  switch (event_pckt->evt)
 8027810:	6a3b      	ldr	r3, [r7, #32]
 8027812:	781b      	ldrb	r3, [r3, #0]
 8027814:	2bff      	cmp	r3, #255	; 0xff
 8027816:	d06b      	beq.n	80278f0 <SVCCTL_App_Notification+0xf4>
 8027818:	2bff      	cmp	r3, #255	; 0xff
 802781a:	dc76      	bgt.n	802790a <SVCCTL_App_Notification+0x10e>
 802781c:	2b05      	cmp	r3, #5
 802781e:	d002      	beq.n	8027826 <SVCCTL_App_Notification+0x2a>
 8027820:	2b3e      	cmp	r3, #62	; 0x3e
 8027822:	d01e      	beq.n	8027862 <SVCCTL_App_Notification+0x66>

      default:
      /* USER CODE BEGIN ECODE_DEFAULT*/

      /* USER CODE END ECODE_DEFAULT*/
      break;
 8027824:	e071      	b.n	802790a <SVCCTL_App_Notification+0x10e>
      disconnection_complete_event = (hci_disconnection_complete_event_rp0 *) event_pckt->data;
 8027826:	6a3b      	ldr	r3, [r7, #32]
 8027828:	3302      	adds	r3, #2
 802782a:	60fb      	str	r3, [r7, #12]
      if (disconnection_complete_event->Connection_Handle == BleApplicationContext.BleApplicationContext_legacy.connectionHandle)
 802782c:	68fb      	ldr	r3, [r7, #12]
 802782e:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8027832:	b29a      	uxth	r2, r3
 8027834:	4b39      	ldr	r3, [pc, #228]	; (802791c <SVCCTL_App_Notification+0x120>)
 8027836:	8adb      	ldrh	r3, [r3, #22]
 8027838:	429a      	cmp	r2, r3
 802783a:	d106      	bne.n	802784a <SVCCTL_App_Notification+0x4e>
        BleApplicationContext.BleApplicationContext_legacy.connectionHandle = 0;
 802783c:	4b37      	ldr	r3, [pc, #220]	; (802791c <SVCCTL_App_Notification+0x120>)
 802783e:	2200      	movs	r2, #0
 8027840:	82da      	strh	r2, [r3, #22]
        BleApplicationContext.Device_Connection_Status = APP_BLE_IDLE;
 8027842:	4b36      	ldr	r3, [pc, #216]	; (802791c <SVCCTL_App_Notification+0x120>)
 8027844:	2200      	movs	r2, #0
 8027846:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
      Adv_Request(APP_BLE_FAST_ADV);
 802784a:	2001      	movs	r0, #1
 802784c:	f000 f978 	bl	8027b40 <Adv_Request>
      ledDisconnectNotification();
 8027850:	f7e3 f8c4 	bl	800a9dc <ledDisconnectNotification>
		osThreadFlagsSet(AdvUpdateProcessId, 1);
 8027854:	4b32      	ldr	r3, [pc, #200]	; (8027920 <SVCCTL_App_Notification+0x124>)
 8027856:	681b      	ldr	r3, [r3, #0]
 8027858:	2101      	movs	r1, #1
 802785a:	4618      	mov	r0, r3
 802785c:	f7fa fef6 	bl	802264c <osThreadFlagsSet>
    break; /* HCI_DISCONNECTION_COMPLETE_EVT_CODE */
 8027860:	e056      	b.n	8027910 <SVCCTL_App_Notification+0x114>
      meta_evt = (evt_le_meta_event*) event_pckt->data;
 8027862:	6a3b      	ldr	r3, [r7, #32]
 8027864:	3302      	adds	r3, #2
 8027866:	61bb      	str	r3, [r7, #24]
      switch (meta_evt->subevent)
 8027868:	69bb      	ldr	r3, [r7, #24]
 802786a:	781b      	ldrb	r3, [r3, #0]
 802786c:	2b0c      	cmp	r3, #12
 802786e:	d005      	beq.n	802787c <SVCCTL_App_Notification+0x80>
 8027870:	2b0c      	cmp	r3, #12
 8027872:	dc39      	bgt.n	80278e8 <SVCCTL_App_Notification+0xec>
 8027874:	2b01      	cmp	r3, #1
 8027876:	d017      	beq.n	80278a8 <SVCCTL_App_Notification+0xac>
 8027878:	2b03      	cmp	r3, #3
          break;
 802787a:	e035      	b.n	80278e8 <SVCCTL_App_Notification+0xec>
          evt_le_phy_update_complete = (hci_le_phy_update_complete_event_rp0*)meta_evt->data;
 802787c:	69bb      	ldr	r3, [r7, #24]
 802787e:	3301      	adds	r3, #1
 8027880:	617b      	str	r3, [r7, #20]
          ret = hci_le_read_phy(BleApplicationContext.BleApplicationContext_legacy.connectionHandle,&TX_PHY,&RX_PHY);
 8027882:	4b26      	ldr	r3, [pc, #152]	; (802791c <SVCCTL_App_Notification+0x120>)
 8027884:	8adb      	ldrh	r3, [r3, #22]
 8027886:	f107 020a 	add.w	r2, r7, #10
 802788a:	f107 010b 	add.w	r1, r7, #11
 802788e:	4618      	mov	r0, r3
 8027890:	f7f3 f915 	bl	801aabe <hci_le_read_phy>
 8027894:	4603      	mov	r3, r0
 8027896:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
          if (ret == BLE_STATUS_SUCCESS)
 802789a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 802789e:	2b00      	cmp	r3, #0
 80278a0:	d124      	bne.n	80278ec <SVCCTL_App_Notification+0xf0>
            if ((TX_PHY == TX_2M) && (RX_PHY == RX_2M))
 80278a2:	7afb      	ldrb	r3, [r7, #11]
 80278a4:	2b02      	cmp	r3, #2
          break;
 80278a6:	e021      	b.n	80278ec <SVCCTL_App_Notification+0xf0>
          connection_complete_event = (hci_le_connection_complete_event_rp0 *) meta_evt->data;
 80278a8:	69bb      	ldr	r3, [r7, #24]
 80278aa:	3301      	adds	r3, #1
 80278ac:	613b      	str	r3, [r7, #16]
          HW_TS_Stop(BleApplicationContext.Advertising_mgr_timer_Id);
 80278ae:	4b1b      	ldr	r3, [pc, #108]	; (802791c <SVCCTL_App_Notification+0x120>)
 80278b0:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 80278b4:	4618      	mov	r0, r3
 80278b6:	f7e2 fcbd 	bl	800a234 <HW_TS_Stop>
          if (BleApplicationContext.Device_Connection_Status == APP_BLE_LP_CONNECTING)
 80278ba:	4b18      	ldr	r3, [pc, #96]	; (802791c <SVCCTL_App_Notification+0x120>)
 80278bc:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 80278c0:	2b04      	cmp	r3, #4
 80278c2:	d104      	bne.n	80278ce <SVCCTL_App_Notification+0xd2>
            BleApplicationContext.Device_Connection_Status = APP_BLE_CONNECTED_CLIENT;
 80278c4:	4b15      	ldr	r3, [pc, #84]	; (802791c <SVCCTL_App_Notification+0x120>)
 80278c6:	2206      	movs	r2, #6
 80278c8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
 80278cc:	e003      	b.n	80278d6 <SVCCTL_App_Notification+0xda>
            BleApplicationContext.Device_Connection_Status = APP_BLE_CONNECTED_SERVER;
 80278ce:	4b13      	ldr	r3, [pc, #76]	; (802791c <SVCCTL_App_Notification+0x120>)
 80278d0:	2205      	movs	r2, #5
 80278d2:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
          BleApplicationContext.BleApplicationContext_legacy.connectionHandle = connection_complete_event->Connection_Handle;
 80278d6:	693b      	ldr	r3, [r7, #16]
 80278d8:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 80278dc:	b29a      	uxth	r2, r3
 80278de:	4b0f      	ldr	r3, [pc, #60]	; (802791c <SVCCTL_App_Notification+0x120>)
 80278e0:	82da      	strh	r2, [r3, #22]
          ledConnectNotification();
 80278e2:	f7e3 f89d 	bl	800aa20 <ledConnectNotification>
        break; /* HCI_LE_CONNECTION_COMPLETE_SUBEVT_CODE */
 80278e6:	e002      	b.n	80278ee <SVCCTL_App_Notification+0xf2>
          break;
 80278e8:	bf00      	nop
 80278ea:	e011      	b.n	8027910 <SVCCTL_App_Notification+0x114>
          break;
 80278ec:	bf00      	nop
    break; /* HCI_LE_META_EVT_CODE */
 80278ee:	e00f      	b.n	8027910 <SVCCTL_App_Notification+0x114>
      blecore_evt = (evt_blecore_aci*) event_pckt->data;
 80278f0:	6a3b      	ldr	r3, [r7, #32]
 80278f2:	3302      	adds	r3, #2
 80278f4:	61fb      	str	r3, [r7, #28]
      switch (blecore_evt->ecode)
 80278f6:	69fb      	ldr	r3, [r7, #28]
 80278f8:	881b      	ldrh	r3, [r3, #0]
 80278fa:	b29b      	uxth	r3, r3
 80278fc:	461a      	mov	r2, r3
 80278fe:	f240 4307 	movw	r3, #1031	; 0x407
 8027902:	429a      	cmp	r2, r3
 8027904:	d103      	bne.n	802790e <SVCCTL_App_Notification+0x112>
          break; /* ACI_GAP_PROC_COMPLETE_VSEVT_CODE */
 8027906:	bf00      	nop
      break; /* HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE */
 8027908:	e001      	b.n	802790e <SVCCTL_App_Notification+0x112>
      break;
 802790a:	bf00      	nop
 802790c:	e000      	b.n	8027910 <SVCCTL_App_Notification+0x114>
      break; /* HCI_VENDOR_SPECIFIC_DEBUG_EVT_CODE */
 802790e:	bf00      	nop
  }

  return (SVCCTL_UserEvtFlowEnable);
 8027910:	2301      	movs	r3, #1
}
 8027912:	4618      	mov	r0, r3
 8027914:	3728      	adds	r7, #40	; 0x28
 8027916:	46bd      	mov	sp, r7
 8027918:	bd80      	pop	{r7, pc}
 802791a:	bf00      	nop
 802791c:	2000030c 	.word	0x2000030c
 8027920:	20012398 	.word	0x20012398

08027924 <BLE_SVC_L2CAP_Conn_Update_7_5>:
	}
	return (CRC8);
}

uint8_t index_con_int, mutex;
void BLE_SVC_L2CAP_Conn_Update_7_5(void) {
 8027924:	b590      	push	{r4, r7, lr}
 8027926:	b087      	sub	sp, #28
 8027928:	af02      	add	r7, sp, #8
	/* USER CODE BEGIN BLE_SVC_L2CAP_Conn_Update_1 */

	/* USER CODE END BLE_SVC_L2CAP_Conn_Update_1 */
	if (mutex == 1) {
 802792a:	4b10      	ldr	r3, [pc, #64]	; (802796c <BLE_SVC_L2CAP_Conn_Update_7_5+0x48>)
 802792c:	781b      	ldrb	r3, [r3, #0]
 802792e:	2b01      	cmp	r3, #1
 8027930:	d118      	bne.n	8027964 <BLE_SVC_L2CAP_Conn_Update_7_5+0x40>
		mutex = 0;
 8027932:	4b0e      	ldr	r3, [pc, #56]	; (802796c <BLE_SVC_L2CAP_Conn_Update_7_5+0x48>)
 8027934:	2200      	movs	r2, #0
 8027936:	701a      	strb	r2, [r3, #0]
		uint16_t interval_min = CONN_P(7.5);
 8027938:	2306      	movs	r3, #6
 802793a:	81fb      	strh	r3, [r7, #14]
		uint16_t interval_max = CONN_P(7.5);
 802793c:	2306      	movs	r3, #6
 802793e:	81bb      	strh	r3, [r7, #12]
		uint16_t slave_latency = L2CAP_SLAVE_LATENCY;
 8027940:	2300      	movs	r3, #0
 8027942:	817b      	strh	r3, [r7, #10]
		uint16_t timeout_multiplier = L2CAP_TIMEOUT_MULTIPLIER;
 8027944:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8027948:	813b      	strh	r3, [r7, #8]
		tBleStatus result;

		result = aci_l2cap_connection_parameter_update_req(
 802794a:	4b09      	ldr	r3, [pc, #36]	; (8027970 <BLE_SVC_L2CAP_Conn_Update_7_5+0x4c>)
 802794c:	8ad8      	ldrh	r0, [r3, #22]
 802794e:	897c      	ldrh	r4, [r7, #10]
 8027950:	89ba      	ldrh	r2, [r7, #12]
 8027952:	89f9      	ldrh	r1, [r7, #14]
 8027954:	893b      	ldrh	r3, [r7, #8]
 8027956:	9300      	str	r3, [sp, #0]
 8027958:	4623      	mov	r3, r4
 802795a:	f7f3 f97f 	bl	801ac5c <aci_l2cap_connection_parameter_update_req>
 802795e:	4603      	mov	r3, r0
 8027960:	71fb      	strb	r3, [r7, #7]
		}
	}
	/* USER CODE BEGIN BLE_SVC_L2CAP_Conn_Update_2 */

	/* USER CODE END BLE_SVC_L2CAP_Conn_Update_2 */
	return;
 8027962:	bf00      	nop
 8027964:	bf00      	nop
}
 8027966:	3714      	adds	r7, #20
 8027968:	46bd      	mov	sp, r7
 802796a:	bd90      	pop	{r4, r7, pc}
 802796c:	2001238c 	.word	0x2001238c
 8027970:	2000030c 	.word	0x2000030c

08027974 <Ble_Tl_Init>:
 *
 * LOCAL FUNCTIONS
 *
 *************************************************************/
static void Ble_Tl_Init( void )
{
 8027974:	b580      	push	{r7, lr}
 8027976:	b082      	sub	sp, #8
 8027978:	af00      	add	r7, sp, #0
  HCI_TL_HciInitConf_t Hci_Tl_Init_Conf;

  MtxHciId = osMutexNew( NULL );
 802797a:	2000      	movs	r0, #0
 802797c:	f7fb f844 	bl	8022a08 <osMutexNew>
 8027980:	4603      	mov	r3, r0
 8027982:	4a0b      	ldr	r2, [pc, #44]	; (80279b0 <Ble_Tl_Init+0x3c>)
 8027984:	6013      	str	r3, [r2, #0]
  SemHciId = osSemaphoreNew( 1, 0, NULL ); /*< Create the semaphore and make it busy at initialization */
 8027986:	2200      	movs	r2, #0
 8027988:	2100      	movs	r1, #0
 802798a:	2001      	movs	r0, #1
 802798c:	f7fb f94a 	bl	8022c24 <osSemaphoreNew>
 8027990:	4603      	mov	r3, r0
 8027992:	4a08      	ldr	r2, [pc, #32]	; (80279b4 <Ble_Tl_Init+0x40>)
 8027994:	6013      	str	r3, [r2, #0]

  Hci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&BleCmdBuffer;
 8027996:	4b08      	ldr	r3, [pc, #32]	; (80279b8 <Ble_Tl_Init+0x44>)
 8027998:	603b      	str	r3, [r7, #0]
  Hci_Tl_Init_Conf.StatusNotCallBack = BLE_StatusNot;
 802799a:	4b08      	ldr	r3, [pc, #32]	; (80279bc <Ble_Tl_Init+0x48>)
 802799c:	607b      	str	r3, [r7, #4]
  hci_init(BLE_UserEvtRx, (void*) &Hci_Tl_Init_Conf);
 802799e:	463b      	mov	r3, r7
 80279a0:	4619      	mov	r1, r3
 80279a2:	4807      	ldr	r0, [pc, #28]	; (80279c0 <Ble_Tl_Init+0x4c>)
 80279a4:	f7f3 fd2e 	bl	801b404 <hci_init>

  return;
 80279a8:	bf00      	nop
}
 80279aa:	3708      	adds	r7, #8
 80279ac:	46bd      	mov	sp, r7
 80279ae:	bd80      	pop	{r7, pc}
 80279b0:	20012390 	.word	0x20012390
 80279b4:	2001237c 	.word	0x2001237c
 80279b8:	200300d4 	.word	0x200300d4
 80279bc:	08027df9 	.word	0x08027df9
 80279c0:	08027dc1 	.word	0x08027dc1

080279c4 <Ble_Hci_Gap_Gatt_Init>:

static void Ble_Hci_Gap_Gatt_Init(void){
 80279c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80279c6:	b08d      	sub	sp, #52	; 0x34
 80279c8:	af06      	add	r7, sp, #24

  uint8_t role;
  uint16_t gap_service_handle, gap_dev_name_char_handle, gap_appearance_char_handle;
  const uint8_t *bd_addr;
  uint16_t appearance[1] = { BLE_CFG_GAP_APPEARANCE };
 80279ca:	f44f 7350 	mov.w	r3, #832	; 0x340
 80279ce:	80bb      	strh	r3, [r7, #4]

  /**
   * Initialize HCI layer
   */
  /*HCI Reset to synchronise BLE Stack*/
  hci_reset();
 80279d0:	f7f3 f851 	bl	801aa76 <hci_reset>

  /**
   * Write the BD Address
   */

  bd_addr = BleGetBdAddress();
 80279d4:	f000 f924 	bl	8027c20 <BleGetBdAddress>
 80279d8:	6178      	str	r0, [r7, #20]
  aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET,
 80279da:	697a      	ldr	r2, [r7, #20]
 80279dc:	2106      	movs	r1, #6
 80279de:	2000      	movs	r0, #0
 80279e0:	f7f2 ff89 	bl	801a8f6 <aci_hal_write_config_data>
                            CONFIG_DATA_PUBADDR_LEN,
                            (uint8_t*) bd_addr);

#if (CFG_BLE_ADDRESS_TYPE == PUBLIC_ADDR)
  /* BLE MAC in ADV Packet */
  manuf_data[ sizeof(manuf_data)-6] = bd_addr[5];
 80279e4:	697b      	ldr	r3, [r7, #20]
 80279e6:	795a      	ldrb	r2, [r3, #5]
 80279e8:	4b4f      	ldr	r3, [pc, #316]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 80279ea:	721a      	strb	r2, [r3, #8]
  manuf_data[ sizeof(manuf_data)-5] = bd_addr[4];
 80279ec:	697b      	ldr	r3, [r7, #20]
 80279ee:	791a      	ldrb	r2, [r3, #4]
 80279f0:	4b4d      	ldr	r3, [pc, #308]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 80279f2:	725a      	strb	r2, [r3, #9]
  manuf_data[ sizeof(manuf_data)-4] = bd_addr[3];
 80279f4:	697b      	ldr	r3, [r7, #20]
 80279f6:	78da      	ldrb	r2, [r3, #3]
 80279f8:	4b4b      	ldr	r3, [pc, #300]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 80279fa:	729a      	strb	r2, [r3, #10]
  manuf_data[ sizeof(manuf_data)-3] = bd_addr[2];
 80279fc:	697b      	ldr	r3, [r7, #20]
 80279fe:	789a      	ldrb	r2, [r3, #2]
 8027a00:	4b49      	ldr	r3, [pc, #292]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 8027a02:	72da      	strb	r2, [r3, #11]
  manuf_data[ sizeof(manuf_data)-2] = bd_addr[1];
 8027a04:	697b      	ldr	r3, [r7, #20]
 8027a06:	785a      	ldrb	r2, [r3, #1]
 8027a08:	4b47      	ldr	r3, [pc, #284]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 8027a0a:	731a      	strb	r2, [r3, #12]
  manuf_data[ sizeof(manuf_data)-1] = bd_addr[0];
 8027a0c:	697b      	ldr	r3, [r7, #20]
 8027a0e:	781a      	ldrb	r2, [r3, #0]
 8027a10:	4b45      	ldr	r3, [pc, #276]	; (8027b28 <Ble_Hci_Gap_Gatt_Init+0x164>)
 8027a12:	735a      	strb	r2, [r3, #13]
#endif

  /**
   * Write Identity root key used to derive LTK and CSRK
   */
    aci_hal_write_config_data(CONFIG_DATA_IR_OFFSET,
 8027a14:	4a45      	ldr	r2, [pc, #276]	; (8027b2c <Ble_Hci_Gap_Gatt_Init+0x168>)
 8027a16:	2110      	movs	r1, #16
 8027a18:	2018      	movs	r0, #24
 8027a1a:	f7f2 ff6c 	bl	801a8f6 <aci_hal_write_config_data>
                            (uint8_t*) BLE_CFG_IR_VALUE);

  /**
   * Write Encryption root key used to derive LTK and CSRK
   */
    aci_hal_write_config_data(CONFIG_DATA_ER_OFFSET,
 8027a1e:	4a44      	ldr	r2, [pc, #272]	; (8027b30 <Ble_Hci_Gap_Gatt_Init+0x16c>)
 8027a20:	2110      	movs	r1, #16
 8027a22:	2008      	movs	r0, #8
 8027a24:	f7f2 ff67 	bl	801a8f6 <aci_hal_write_config_data>
#endif

  /**
   * Write Identity root key used to derive LTK and CSRK
   */
  aci_hal_write_config_data( CONFIG_DATA_IR_OFFSET, CONFIG_DATA_IR_LEN, (uint8_t*)BLE_CFG_IR_VALUE );
 8027a28:	4a40      	ldr	r2, [pc, #256]	; (8027b2c <Ble_Hci_Gap_Gatt_Init+0x168>)
 8027a2a:	2110      	movs	r1, #16
 8027a2c:	2018      	movs	r0, #24
 8027a2e:	f7f2 ff62 	bl	801a8f6 <aci_hal_write_config_data>

  /**
   * Write Encryption root key used to derive LTK and CSRK
   */
  aci_hal_write_config_data( CONFIG_DATA_ER_OFFSET, CONFIG_DATA_ER_LEN, (uint8_t*)BLE_CFG_ER_VALUE );
 8027a32:	4a3f      	ldr	r2, [pc, #252]	; (8027b30 <Ble_Hci_Gap_Gatt_Init+0x16c>)
 8027a34:	2110      	movs	r1, #16
 8027a36:	2008      	movs	r0, #8
 8027a38:	f7f2 ff5d 	bl	801a8f6 <aci_hal_write_config_data>

  /**
   * Set TX Power to 0dBm.
   */
  aci_hal_set_tx_power_level(1, CFG_TX_POWER);
 8027a3c:	2119      	movs	r1, #25
 8027a3e:	2001      	movs	r0, #1
 8027a40:	f7f2 ffc2 	bl	801a9c8 <aci_hal_set_tx_power_level>

  /**
   * Initialize GATT interface
   */
  aci_gatt_init();
 8027a44:	f7f2 fbda 	bl	801a1fc <aci_gatt_init>

  /**
   * Initialize GAP interface
   */
  role = 0;
 8027a48:	2300      	movs	r3, #0
 8027a4a:	74fb      	strb	r3, [r7, #19]

#if (BLE_CFG_PERIPHERAL == 1)
  role |= GAP_PERIPHERAL_ROLE;
 8027a4c:	7cfb      	ldrb	r3, [r7, #19]
 8027a4e:	f043 0301 	orr.w	r3, r3, #1
 8027a52:	74fb      	strb	r3, [r7, #19]

#if (BLE_CFG_CENTRAL == 1)
  role |= GAP_CENTRAL_ROLE;
#endif

  if (role > 0)
 8027a54:	7cfb      	ldrb	r3, [r7, #19]
 8027a56:	2b00      	cmp	r3, #0
 8027a58:	d01d      	beq.n	8027a96 <Ble_Hci_Gap_Gatt_Init+0xd2>
  {
    const char *name = "STM32WB";
 8027a5a:	4b36      	ldr	r3, [pc, #216]	; (8027b34 <Ble_Hci_Gap_Gatt_Init+0x170>)
 8027a5c:	60fb      	str	r3, [r7, #12]
    aci_gap_init(role,
 8027a5e:	f107 020a 	add.w	r2, r7, #10
 8027a62:	7cf8      	ldrb	r0, [r7, #19]
 8027a64:	1dbb      	adds	r3, r7, #6
 8027a66:	9301      	str	r3, [sp, #4]
 8027a68:	f107 0308 	add.w	r3, r7, #8
 8027a6c:	9300      	str	r3, [sp, #0]
 8027a6e:	4613      	mov	r3, r2
 8027a70:	2207      	movs	r2, #7
 8027a72:	2100      	movs	r1, #0
 8027a74:	f7f2 fab7 	bl	8019fe6 <aci_gap_init>
                 APPBLE_GAP_DEVICE_NAME_LENGTH,
                 &gap_service_handle,
                 &gap_dev_name_char_handle,
                 &gap_appearance_char_handle);

    if (aci_gatt_update_char_value(gap_service_handle, gap_dev_name_char_handle, 0, strlen(name), (uint8_t *) name))
 8027a78:	897c      	ldrh	r4, [r7, #10]
 8027a7a:	893d      	ldrh	r5, [r7, #8]
 8027a7c:	68f8      	ldr	r0, [r7, #12]
 8027a7e:	f7df fe77 	bl	8007770 <strlen>
 8027a82:	4603      	mov	r3, r0
 8027a84:	b2da      	uxtb	r2, r3
 8027a86:	68fb      	ldr	r3, [r7, #12]
 8027a88:	9300      	str	r3, [sp, #0]
 8027a8a:	4613      	mov	r3, r2
 8027a8c:	2200      	movs	r2, #0
 8027a8e:	4629      	mov	r1, r5
 8027a90:	4620      	mov	r0, r4
 8027a92:	f7f2 fd71 	bl	801a578 <aci_gatt_update_char_value>
    {
      BLE_DBG_SVCCTL_MSG("Device Name aci_gatt_update_char_value failed.\n");
    }
  }

  if(aci_gatt_update_char_value(gap_service_handle,
 8027a96:	8978      	ldrh	r0, [r7, #10]
 8027a98:	88f9      	ldrh	r1, [r7, #6]
 8027a9a:	1d3b      	adds	r3, r7, #4
 8027a9c:	9300      	str	r3, [sp, #0]
 8027a9e:	2302      	movs	r3, #2
 8027aa0:	2200      	movs	r2, #0
 8027aa2:	f7f2 fd69 	bl	801a578 <aci_gatt_update_char_value>
    BLE_DBG_SVCCTL_MSG("Appearance aci_gatt_update_char_value failed.\n");
  }
  /**
   * Initialize Default PHY
   */
  hci_le_set_default_phy(ALL_PHYS_PREFERENCE,TX_2M_PREFERRED,RX_2M_PREFERRED);
 8027aa6:	2202      	movs	r2, #2
 8027aa8:	2102      	movs	r1, #2
 8027aaa:	2000      	movs	r0, #0
 8027aac:	f7f3 f86f 	bl	801ab8e <hci_le_set_default_phy>

  /**
   * Initialize IO capability
   */
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.ioCapability = CFG_IO_CAPABILITY;
 8027ab0:	4b21      	ldr	r3, [pc, #132]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ab2:	2201      	movs	r2, #1
 8027ab4:	701a      	strb	r2, [r3, #0]
  aci_gap_set_io_capability(BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.ioCapability);
 8027ab6:	4b20      	ldr	r3, [pc, #128]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ab8:	781b      	ldrb	r3, [r3, #0]
 8027aba:	4618      	mov	r0, r3
 8027abc:	f7f2 f9a1 	bl	8019e02 <aci_gap_set_io_capability>

  /**
   * Initialize authentication
   */
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.mitm_mode = CFG_MITM_PROTECTION;
 8027ac0:	4b1d      	ldr	r3, [pc, #116]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ac2:	2201      	movs	r2, #1
 8027ac4:	705a      	strb	r2, [r3, #1]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.encryptionKeySizeMin = CFG_ENCRYPTION_KEY_SIZE_MIN;
 8027ac6:	4b1c      	ldr	r3, [pc, #112]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ac8:	2208      	movs	r2, #8
 8027aca:	711a      	strb	r2, [r3, #4]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.encryptionKeySizeMax = CFG_ENCRYPTION_KEY_SIZE_MAX;
 8027acc:	4b1a      	ldr	r3, [pc, #104]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ace:	2210      	movs	r2, #16
 8027ad0:	715a      	strb	r2, [r3, #5]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.Use_Fixed_Pin = CFG_USED_FIXED_PIN;
 8027ad2:	4b19      	ldr	r3, [pc, #100]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ad4:	2200      	movs	r2, #0
 8027ad6:	70da      	strb	r2, [r3, #3]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.Fixed_Pin = CFG_FIXED_PIN;
 8027ad8:	4b17      	ldr	r3, [pc, #92]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ada:	4a18      	ldr	r2, [pc, #96]	; (8027b3c <Ble_Hci_Gap_Gatt_Init+0x178>)
 8027adc:	609a      	str	r2, [r3, #8]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode = CFG_BONDING_MODE;
 8027ade:	4b16      	ldr	r3, [pc, #88]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ae0:	2201      	movs	r2, #1
 8027ae2:	709a      	strb	r2, [r3, #2]

  aci_gap_set_authentication_requirement(BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode,
 8027ae4:	4b14      	ldr	r3, [pc, #80]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027ae6:	789c      	ldrb	r4, [r3, #2]
 8027ae8:	4b13      	ldr	r3, [pc, #76]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027aea:	785d      	ldrb	r5, [r3, #1]
 8027aec:	4b12      	ldr	r3, [pc, #72]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027aee:	791b      	ldrb	r3, [r3, #4]
 8027af0:	4a11      	ldr	r2, [pc, #68]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027af2:	7952      	ldrb	r2, [r2, #5]
 8027af4:	4910      	ldr	r1, [pc, #64]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027af6:	78c9      	ldrb	r1, [r1, #3]
 8027af8:	480f      	ldr	r0, [pc, #60]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027afa:	6880      	ldr	r0, [r0, #8]
 8027afc:	2600      	movs	r6, #0
 8027afe:	9604      	str	r6, [sp, #16]
 8027b00:	9003      	str	r0, [sp, #12]
 8027b02:	9102      	str	r1, [sp, #8]
 8027b04:	9201      	str	r2, [sp, #4]
 8027b06:	9300      	str	r3, [sp, #0]
 8027b08:	2300      	movs	r3, #0
 8027b0a:	2201      	movs	r2, #1
 8027b0c:	4629      	mov	r1, r5
 8027b0e:	4620      	mov	r0, r4
 8027b10:	f7f2 f9c1 	bl	8019e96 <aci_gap_set_authentication_requirement>
                                         );

  /**
   * Initialize whitelist
   */
   if (BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode)
 8027b14:	4b08      	ldr	r3, [pc, #32]	; (8027b38 <Ble_Hci_Gap_Gatt_Init+0x174>)
 8027b16:	789b      	ldrb	r3, [r3, #2]
 8027b18:	2b00      	cmp	r3, #0
 8027b1a:	d001      	beq.n	8027b20 <Ble_Hci_Gap_Gatt_Init+0x15c>
   {
     aci_gap_configure_whitelist();
 8027b1c:	f7f2 fb4a 	bl	801a1b4 <aci_gap_configure_whitelist>
   }
}
 8027b20:	bf00      	nop
 8027b22:	371c      	adds	r7, #28
 8027b24:	46bd      	mov	sp, r7
 8027b26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027b28:	20000130 	.word	0x20000130
 8027b2c:	0802d4dc 	.word	0x0802d4dc
 8027b30:	0802d4ec 	.word	0x0802d4ec
 8027b34:	0802c6cc 	.word	0x0802c6cc
 8027b38:	2000030c 	.word	0x2000030c
 8027b3c:	0001b207 	.word	0x0001b207

08027b40 <Adv_Request>:

static void Adv_Request(APP_BLE_ConnStatus_t New_Status)
{
 8027b40:	b580      	push	{r7, lr}
 8027b42:	b08c      	sub	sp, #48	; 0x30
 8027b44:	af08      	add	r7, sp, #32
 8027b46:	4603      	mov	r3, r0
 8027b48:	71fb      	strb	r3, [r7, #7]
  tBleStatus ret = BLE_STATUS_INVALID_PARAMS;
 8027b4a:	2392      	movs	r3, #146	; 0x92
 8027b4c:	72fb      	strb	r3, [r7, #11]
  uint16_t Min_Inter, Max_Inter;

  if (New_Status == APP_BLE_FAST_ADV)
 8027b4e:	79fb      	ldrb	r3, [r7, #7]
 8027b50:	2b01      	cmp	r3, #1
 8027b52:	d106      	bne.n	8027b62 <Adv_Request+0x22>
  {
    Min_Inter = AdvIntervalMin;
 8027b54:	4b2b      	ldr	r3, [pc, #172]	; (8027c04 <Adv_Request+0xc4>)
 8027b56:	881b      	ldrh	r3, [r3, #0]
 8027b58:	81fb      	strh	r3, [r7, #14]
    Max_Inter = AdvIntervalMax;
 8027b5a:	4b2b      	ldr	r3, [pc, #172]	; (8027c08 <Adv_Request+0xc8>)
 8027b5c:	881b      	ldrh	r3, [r3, #0]
 8027b5e:	81bb      	strh	r3, [r7, #12]
 8027b60:	e005      	b.n	8027b6e <Adv_Request+0x2e>
  }
  else
  {
    Min_Inter = CFG_LP_CONN_ADV_INTERVAL_MIN;
 8027b62:	f44f 63c8 	mov.w	r3, #1600	; 0x640
 8027b66:	81fb      	strh	r3, [r7, #14]
    Max_Inter = CFG_LP_CONN_ADV_INTERVAL_MAX;
 8027b68:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 8027b6c:	81bb      	strh	r3, [r7, #12]

    /**
     * Stop the timer, it will be restarted for a new shot
     * It does not hurt if the timer was not running
     */
    HW_TS_Stop(BleApplicationContext.Advertising_mgr_timer_Id);
 8027b6e:	4b27      	ldr	r3, [pc, #156]	; (8027c0c <Adv_Request+0xcc>)
 8027b70:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8027b74:	4618      	mov	r0, r3
 8027b76:	f7e2 fb5d 	bl	800a234 <HW_TS_Stop>

    APP_DBG_MSG("First index in %d state \n", BleApplicationContext.Device_Connection_Status);

    if ((New_Status == APP_BLE_LP_ADV)
 8027b7a:	79fb      	ldrb	r3, [r7, #7]
 8027b7c:	2b02      	cmp	r3, #2
 8027b7e:	d10d      	bne.n	8027b9c <Adv_Request+0x5c>
        && ((BleApplicationContext.Device_Connection_Status == APP_BLE_FAST_ADV)
 8027b80:	4b22      	ldr	r3, [pc, #136]	; (8027c0c <Adv_Request+0xcc>)
 8027b82:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8027b86:	2b01      	cmp	r3, #1
 8027b88:	d004      	beq.n	8027b94 <Adv_Request+0x54>
            || (BleApplicationContext.Device_Connection_Status == APP_BLE_LP_ADV)))
 8027b8a:	4b20      	ldr	r3, [pc, #128]	; (8027c0c <Adv_Request+0xcc>)
 8027b8c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8027b90:	2b02      	cmp	r3, #2
 8027b92:	d103      	bne.n	8027b9c <Adv_Request+0x5c>
    {
      /* Connection in ADVERTISE mode have to stop the current advertising */
      ret = aci_gap_set_non_discoverable();
 8027b94:	f7f2 f833 	bl	8019bfe <aci_gap_set_non_discoverable>
 8027b98:	4603      	mov	r3, r0
 8027b9a:	72fb      	strb	r3, [r7, #11]
      {
        APP_DBG_MSG("Stop Advertising Failed , result: %d \n", ret);
      }
    }

    BleApplicationContext.Device_Connection_Status = New_Status;
 8027b9c:	4a1b      	ldr	r2, [pc, #108]	; (8027c0c <Adv_Request+0xcc>)
 8027b9e:	79fb      	ldrb	r3, [r7, #7]
 8027ba0:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
    /* Start Fast or Low Power Advertising */
    ret = aci_gap_set_discoverable(
 8027ba4:	4b19      	ldr	r3, [pc, #100]	; (8027c0c <Adv_Request+0xcc>)
 8027ba6:	7e1b      	ldrb	r3, [r3, #24]
 8027ba8:	89ba      	ldrh	r2, [r7, #12]
 8027baa:	89f9      	ldrh	r1, [r7, #14]
 8027bac:	2000      	movs	r0, #0
 8027bae:	9006      	str	r0, [sp, #24]
 8027bb0:	2000      	movs	r0, #0
 8027bb2:	9005      	str	r0, [sp, #20]
 8027bb4:	4816      	ldr	r0, [pc, #88]	; (8027c10 <Adv_Request+0xd0>)
 8027bb6:	9004      	str	r0, [sp, #16]
 8027bb8:	9303      	str	r3, [sp, #12]
 8027bba:	4b16      	ldr	r3, [pc, #88]	; (8027c14 <Adv_Request+0xd4>)
 8027bbc:	9302      	str	r3, [sp, #8]
 8027bbe:	2309      	movs	r3, #9
 8027bc0:	9301      	str	r3, [sp, #4]
 8027bc2:	2300      	movs	r3, #0
 8027bc4:	9300      	str	r3, [sp, #0]
 8027bc6:	2300      	movs	r3, #0
 8027bc8:	2000      	movs	r0, #0
 8027bca:	f7f2 f83c 	bl	8019c46 <aci_gap_set_discoverable>
 8027bce:	4603      	mov	r3, r0
 8027bd0:	72fb      	strb	r3, [r7, #11]
        BleApplicationContext.BleApplicationContext_legacy.advtServUUID,
        0,
        0);

    /* Update Advertising data */
    ret = aci_gap_update_adv_data(sizeof(manuf_data), (uint8_t*) manuf_data);
 8027bd2:	4911      	ldr	r1, [pc, #68]	; (8027c18 <Adv_Request+0xd8>)
 8027bd4:	200e      	movs	r0, #14
 8027bd6:	f7f2 fa91 	bl	801a0fc <aci_gap_update_adv_data>
 8027bda:	4603      	mov	r3, r0
 8027bdc:	72fb      	strb	r3, [r7, #11]
    if (ret == BLE_STATUS_SUCCESS)
 8027bde:	7afb      	ldrb	r3, [r7, #11]
 8027be0:	2b00      	cmp	r3, #0
 8027be2:	d10a      	bne.n	8027bfa <Adv_Request+0xba>
    {
      if (New_Status == APP_BLE_FAST_ADV)
 8027be4:	79fb      	ldrb	r3, [r7, #7]
 8027be6:	2b01      	cmp	r3, #1
 8027be8:	d107      	bne.n	8027bfa <Adv_Request+0xba>
      {
        APP_DBG_MSG("Successfully Start Fast Advertising \n" );
        /* Start Timer to STOP ADV - TIMEOUT */
        HW_TS_Start(BleApplicationContext.Advertising_mgr_timer_Id, INITIAL_ADV_TIMEOUT);
 8027bea:	4b08      	ldr	r3, [pc, #32]	; (8027c0c <Adv_Request+0xcc>)
 8027bec:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8027bf0:	490a      	ldr	r1, [pc, #40]	; (8027c1c <Adv_Request+0xdc>)
 8027bf2:	4618      	mov	r0, r3
 8027bf4:	f7e2 fbaa 	bl	800a34c <HW_TS_Start>
      {
        APP_DBG_MSG("Start Low Power Advertising Failed , result: %d \n", ret);
      }
    }

  return;
 8027bf8:	bf00      	nop
 8027bfa:	bf00      	nop
}
 8027bfc:	3710      	adds	r7, #16
 8027bfe:	46bd      	mov	sp, r7
 8027c00:	bd80      	pop	{r7, pc}
 8027c02:	bf00      	nop
 8027c04:	20000390 	.word	0x20000390
 8027c08:	20000392 	.word	0x20000392
 8027c0c:	2000030c 	.word	0x2000030c
 8027c10:	20000325 	.word	0x20000325
 8027c14:	0802d4fc 	.word	0x0802d4fc
 8027c18:	20000130 	.word	0x20000130
 8027c1c:	0001e046 	.word	0x0001e046

08027c20 <BleGetBdAddress>:

const uint8_t* BleGetBdAddress( void )
{
 8027c20:	b580      	push	{r7, lr}
 8027c22:	b086      	sub	sp, #24
 8027c24:	af00      	add	r7, sp, #0
  const uint8_t *bd_addr;
  uint32_t udn;
  uint32_t company_id;
  uint32_t device_id;

  udn = LL_FLASH_GetUDN();
 8027c26:	f7ff fd53 	bl	80276d0 <LL_FLASH_GetUDN>
 8027c2a:	6138      	str	r0, [r7, #16]

  if(udn != 0xFFFFFFFF)
 8027c2c:	693b      	ldr	r3, [r7, #16]
 8027c2e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8027c32:	d023      	beq.n	8027c7c <BleGetBdAddress+0x5c>
  {
    company_id = LL_FLASH_GetSTCompanyID();
 8027c34:	f7ff fd64 	bl	8027700 <LL_FLASH_GetSTCompanyID>
 8027c38:	60b8      	str	r0, [r7, #8]
    device_id = LL_FLASH_GetDeviceID();
 8027c3a:	f7ff fd55 	bl	80276e8 <LL_FLASH_GetDeviceID>
 8027c3e:	6078      	str	r0, [r7, #4]
 * bit[23:16] : Device ID.
 * bit[15:0] : The last 16bits from the UDN
 * Note: In order to use the Public Address in a final product, a dedicated
 * 24bits company ID (OUI) shall be bought.
 */
    bd_addr_udn[0] = (uint8_t)(udn & 0x000000FF);
 8027c40:	693b      	ldr	r3, [r7, #16]
 8027c42:	b2da      	uxtb	r2, r3
 8027c44:	4b16      	ldr	r3, [pc, #88]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c46:	701a      	strb	r2, [r3, #0]
    bd_addr_udn[1] = (uint8_t)( (udn & 0x0000FF00) >> 8 );
 8027c48:	693b      	ldr	r3, [r7, #16]
 8027c4a:	0a1b      	lsrs	r3, r3, #8
 8027c4c:	b2da      	uxtb	r2, r3
 8027c4e:	4b14      	ldr	r3, [pc, #80]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c50:	705a      	strb	r2, [r3, #1]
    bd_addr_udn[2] = (uint8_t)device_id;
 8027c52:	687b      	ldr	r3, [r7, #4]
 8027c54:	b2da      	uxtb	r2, r3
 8027c56:	4b12      	ldr	r3, [pc, #72]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c58:	709a      	strb	r2, [r3, #2]
    bd_addr_udn[3] = (uint8_t)(company_id & 0x000000FF);
 8027c5a:	68bb      	ldr	r3, [r7, #8]
 8027c5c:	b2da      	uxtb	r2, r3
 8027c5e:	4b10      	ldr	r3, [pc, #64]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c60:	70da      	strb	r2, [r3, #3]
    bd_addr_udn[4] = (uint8_t)( (company_id & 0x0000FF00) >> 8 );
 8027c62:	68bb      	ldr	r3, [r7, #8]
 8027c64:	0a1b      	lsrs	r3, r3, #8
 8027c66:	b2da      	uxtb	r2, r3
 8027c68:	4b0d      	ldr	r3, [pc, #52]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c6a:	711a      	strb	r2, [r3, #4]
    bd_addr_udn[5] = (uint8_t)( (company_id & 0x00FF0000) >> 16 );
 8027c6c:	68bb      	ldr	r3, [r7, #8]
 8027c6e:	0c1b      	lsrs	r3, r3, #16
 8027c70:	b2da      	uxtb	r2, r3
 8027c72:	4b0b      	ldr	r3, [pc, #44]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c74:	715a      	strb	r2, [r3, #5]

    bd_addr = (const uint8_t *)bd_addr_udn;
 8027c76:	4b0a      	ldr	r3, [pc, #40]	; (8027ca0 <BleGetBdAddress+0x80>)
 8027c78:	617b      	str	r3, [r7, #20]
 8027c7a:	e00b      	b.n	8027c94 <BleGetBdAddress+0x74>
  }
  else
  {
    otp_addr = OTP_Read(0);
 8027c7c:	2000      	movs	r0, #0
 8027c7e:	f7f4 f8d3 	bl	801be28 <OTP_Read>
 8027c82:	60f8      	str	r0, [r7, #12]
    if(otp_addr)
 8027c84:	68fb      	ldr	r3, [r7, #12]
 8027c86:	2b00      	cmp	r3, #0
 8027c88:	d002      	beq.n	8027c90 <BleGetBdAddress+0x70>
    {
      bd_addr = ((OTP_ID0_t*)otp_addr)->bd_address;
 8027c8a:	68fb      	ldr	r3, [r7, #12]
 8027c8c:	617b      	str	r3, [r7, #20]
 8027c8e:	e001      	b.n	8027c94 <BleGetBdAddress+0x74>
    }
    else
    {
      bd_addr = M_bd_addr;
 8027c90:	4b04      	ldr	r3, [pc, #16]	; (8027ca4 <BleGetBdAddress+0x84>)
 8027c92:	617b      	str	r3, [r7, #20]
    }
  }

  return bd_addr;
 8027c94:	697b      	ldr	r3, [r7, #20]
}
 8027c96:	4618      	mov	r0, r3
 8027c98:	3718      	adds	r7, #24
 8027c9a:	46bd      	mov	sp, r7
 8027c9c:	bd80      	pop	{r7, pc}
 8027c9e:	bf00      	nop
 8027ca0:	20010bec 	.word	0x20010bec
 8027ca4:	0802d4d4 	.word	0x0802d4d4

08027ca8 <Add_Advertisment_Service_UUID>:

  return;
}

static void Add_Advertisment_Service_UUID( uint16_t servUUID )
{
 8027ca8:	b480      	push	{r7}
 8027caa:	b083      	sub	sp, #12
 8027cac:	af00      	add	r7, sp, #0
 8027cae:	4603      	mov	r3, r0
 8027cb0:	80fb      	strh	r3, [r7, #6]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen] =
 8027cb2:	4b12      	ldr	r3, [pc, #72]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cb4:	7e1b      	ldrb	r3, [r3, #24]
 8027cb6:	4619      	mov	r1, r3
      (uint8_t) (servUUID & 0xFF);
 8027cb8:	88fb      	ldrh	r3, [r7, #6]
 8027cba:	b2da      	uxtb	r2, r3
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen] =
 8027cbc:	4b0f      	ldr	r3, [pc, #60]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cbe:	440b      	add	r3, r1
 8027cc0:	765a      	strb	r2, [r3, #25]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen++;
 8027cc2:	4b0e      	ldr	r3, [pc, #56]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cc4:	7e1b      	ldrb	r3, [r3, #24]
 8027cc6:	3301      	adds	r3, #1
 8027cc8:	b2da      	uxtb	r2, r3
 8027cca:	4b0c      	ldr	r3, [pc, #48]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027ccc:	761a      	strb	r2, [r3, #24]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen] =
      (uint8_t) (servUUID >> 8) & 0xFF;
 8027cce:	88fb      	ldrh	r3, [r7, #6]
 8027cd0:	0a1b      	lsrs	r3, r3, #8
 8027cd2:	b29a      	uxth	r2, r3
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen] =
 8027cd4:	4b09      	ldr	r3, [pc, #36]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cd6:	7e1b      	ldrb	r3, [r3, #24]
 8027cd8:	4619      	mov	r1, r3
      (uint8_t) (servUUID >> 8) & 0xFF;
 8027cda:	b2d2      	uxtb	r2, r2
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen] =
 8027cdc:	4b07      	ldr	r3, [pc, #28]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cde:	440b      	add	r3, r1
 8027ce0:	765a      	strb	r2, [r3, #25]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen++;
 8027ce2:	4b06      	ldr	r3, [pc, #24]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027ce4:	7e1b      	ldrb	r3, [r3, #24]
 8027ce6:	3301      	adds	r3, #1
 8027ce8:	b2da      	uxtb	r2, r3
 8027cea:	4b04      	ldr	r3, [pc, #16]	; (8027cfc <Add_Advertisment_Service_UUID+0x54>)
 8027cec:	761a      	strb	r2, [r3, #24]

  return;
 8027cee:	bf00      	nop
}
 8027cf0:	370c      	adds	r7, #12
 8027cf2:	46bd      	mov	sp, r7
 8027cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027cf8:	4770      	bx	lr
 8027cfa:	bf00      	nop
 8027cfc:	2000030c 	.word	0x2000030c

08027d00 <Adv_Mgr>:

static void Adv_Mgr( void )
{
 8027d00:	b580      	push	{r7, lr}
 8027d02:	af00      	add	r7, sp, #0
  /**
   * The code shall be executed in the background as an aci command may be sent
   * The background is the only place where the application can make sure a new aci command
   * is not sent if there is a pending one
   */
  osThreadFlagsSet( AdvUpdateProcessId, 1 );
 8027d04:	4b03      	ldr	r3, [pc, #12]	; (8027d14 <Adv_Mgr+0x14>)
 8027d06:	681b      	ldr	r3, [r3, #0]
 8027d08:	2101      	movs	r1, #1
 8027d0a:	4618      	mov	r0, r3
 8027d0c:	f7fa fc9e 	bl	802264c <osThreadFlagsSet>

  return;
 8027d10:	bf00      	nop
}
 8027d12:	bd80      	pop	{r7, pc}
 8027d14:	20012398 	.word	0x20012398

08027d18 <AdvUpdateProcess>:

static void AdvUpdateProcess(void *argument)
{
 8027d18:	b580      	push	{r7, lr}
 8027d1a:	b082      	sub	sp, #8
 8027d1c:	af00      	add	r7, sp, #0
 8027d1e:	6078      	str	r0, [r7, #4]
  UNUSED(argument);

  for(;;)
  {
    osThreadFlagsWait( 1, osFlagsWaitAny, osWaitForever);
 8027d20:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8027d24:	2100      	movs	r1, #0
 8027d26:	2001      	movs	r0, #1
 8027d28:	f7fa fcde 	bl	80226e8 <osThreadFlagsWait>
    Adv_Update( );
 8027d2c:	f000 f801 	bl	8027d32 <Adv_Update>
    osThreadFlagsWait( 1, osFlagsWaitAny, osWaitForever);
 8027d30:	e7f6      	b.n	8027d20 <AdvUpdateProcess+0x8>

08027d32 <Adv_Update>:
  }
}

static void Adv_Update( void )
{
 8027d32:	b580      	push	{r7, lr}
 8027d34:	af00      	add	r7, sp, #0
  Adv_Request(APP_BLE_LP_ADV);
 8027d36:	2002      	movs	r0, #2
 8027d38:	f7ff ff02 	bl	8027b40 <Adv_Request>

  return;
 8027d3c:	bf00      	nop
}
 8027d3e:	bd80      	pop	{r7, pc}

08027d40 <HciUserEvtProcess>:

static void HciUserEvtProcess(void *argument)
{
 8027d40:	b580      	push	{r7, lr}
 8027d42:	b082      	sub	sp, #8
 8027d44:	af00      	add	r7, sp, #0
 8027d46:	6078      	str	r0, [r7, #4]
  UNUSED(argument);

  for(;;)
  {
    osThreadFlagsWait( 1, osFlagsWaitAny, osWaitForever);
 8027d48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8027d4c:	2100      	movs	r1, #0
 8027d4e:	2001      	movs	r0, #1
 8027d50:	f7fa fcca 	bl	80226e8 <osThreadFlagsWait>
    hci_user_evt_proc( );
 8027d54:	f7f3 fb72 	bl	801b43c <hci_user_evt_proc>
    osThreadFlagsWait( 1, osFlagsWaitAny, osWaitForever);
 8027d58:	e7f6      	b.n	8027d48 <HciUserEvtProcess+0x8>
	...

08027d5c <hci_notify_asynch_evt>:
 *
 * WRAP FUNCTIONS
 *
 *************************************************************/
void hci_notify_asynch_evt(void* pdata)
{
 8027d5c:	b580      	push	{r7, lr}
 8027d5e:	b082      	sub	sp, #8
 8027d60:	af00      	add	r7, sp, #0
 8027d62:	6078      	str	r0, [r7, #4]
  UNUSED(pdata);
  osThreadFlagsSet( HciUserEvtProcessId, 1 );
 8027d64:	4b04      	ldr	r3, [pc, #16]	; (8027d78 <hci_notify_asynch_evt+0x1c>)
 8027d66:	681b      	ldr	r3, [r3, #0]
 8027d68:	2101      	movs	r1, #1
 8027d6a:	4618      	mov	r0, r3
 8027d6c:	f7fa fc6e 	bl	802264c <osThreadFlagsSet>
  return;
 8027d70:	bf00      	nop
}
 8027d72:	3708      	adds	r7, #8
 8027d74:	46bd      	mov	sp, r7
 8027d76:	bd80      	pop	{r7, pc}
 8027d78:	20012380 	.word	0x20012380

08027d7c <hci_cmd_resp_release>:

void hci_cmd_resp_release(uint32_t flag)
{
 8027d7c:	b580      	push	{r7, lr}
 8027d7e:	b082      	sub	sp, #8
 8027d80:	af00      	add	r7, sp, #0
 8027d82:	6078      	str	r0, [r7, #4]
  UNUSED(flag);
  osSemaphoreRelease( SemHciId );
 8027d84:	4b04      	ldr	r3, [pc, #16]	; (8027d98 <hci_cmd_resp_release+0x1c>)
 8027d86:	681b      	ldr	r3, [r3, #0]
 8027d88:	4618      	mov	r0, r3
 8027d8a:	f7fb f827 	bl	8022ddc <osSemaphoreRelease>
  return;
 8027d8e:	bf00      	nop
}
 8027d90:	3708      	adds	r7, #8
 8027d92:	46bd      	mov	sp, r7
 8027d94:	bd80      	pop	{r7, pc}
 8027d96:	bf00      	nop
 8027d98:	2001237c 	.word	0x2001237c

08027d9c <hci_cmd_resp_wait>:

void hci_cmd_resp_wait(uint32_t timeout)
{
 8027d9c:	b580      	push	{r7, lr}
 8027d9e:	b082      	sub	sp, #8
 8027da0:	af00      	add	r7, sp, #0
 8027da2:	6078      	str	r0, [r7, #4]
  UNUSED(timeout);
  osSemaphoreAcquire( SemHciId, osWaitForever );
 8027da4:	4b05      	ldr	r3, [pc, #20]	; (8027dbc <hci_cmd_resp_wait+0x20>)
 8027da6:	681b      	ldr	r3, [r3, #0]
 8027da8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8027dac:	4618      	mov	r0, r3
 8027dae:	f7fa ffc3 	bl	8022d38 <osSemaphoreAcquire>
  return;
 8027db2:	bf00      	nop
}
 8027db4:	3708      	adds	r7, #8
 8027db6:	46bd      	mov	sp, r7
 8027db8:	bd80      	pop	{r7, pc}
 8027dba:	bf00      	nop
 8027dbc:	2001237c 	.word	0x2001237c

08027dc0 <BLE_UserEvtRx>:

static void BLE_UserEvtRx( void * pPayload )
{
 8027dc0:	b580      	push	{r7, lr}
 8027dc2:	b084      	sub	sp, #16
 8027dc4:	af00      	add	r7, sp, #0
 8027dc6:	6078      	str	r0, [r7, #4]
  SVCCTL_UserEvtFlowStatus_t svctl_return_status;
  tHCI_UserEvtRxParam *pParam;

  pParam = (tHCI_UserEvtRxParam *)pPayload;
 8027dc8:	687b      	ldr	r3, [r7, #4]
 8027dca:	60fb      	str	r3, [r7, #12]

  svctl_return_status = SVCCTL_UserEvtRx((void *)&(pParam->pckt->evtserial));
 8027dcc:	68fb      	ldr	r3, [r7, #12]
 8027dce:	685b      	ldr	r3, [r3, #4]
 8027dd0:	3308      	adds	r3, #8
 8027dd2:	4618      	mov	r0, r3
 8027dd4:	f7f3 f9d0 	bl	801b178 <SVCCTL_UserEvtRx>
 8027dd8:	4603      	mov	r3, r0
 8027dda:	72fb      	strb	r3, [r7, #11]
  if (svctl_return_status != SVCCTL_UserEvtFlowDisable)
 8027ddc:	7afb      	ldrb	r3, [r7, #11]
 8027dde:	2b00      	cmp	r3, #0
 8027de0:	d003      	beq.n	8027dea <BLE_UserEvtRx+0x2a>
  {
    pParam->status = HCI_TL_UserEventFlow_Enable;
 8027de2:	68fb      	ldr	r3, [r7, #12]
 8027de4:	2201      	movs	r2, #1
 8027de6:	701a      	strb	r2, [r3, #0]
  else
  {
    pParam->status = HCI_TL_UserEventFlow_Disable;
  }

  return;
 8027de8:	e003      	b.n	8027df2 <BLE_UserEvtRx+0x32>
    pParam->status = HCI_TL_UserEventFlow_Disable;
 8027dea:	68fb      	ldr	r3, [r7, #12]
 8027dec:	2200      	movs	r2, #0
 8027dee:	701a      	strb	r2, [r3, #0]
  return;
 8027df0:	bf00      	nop
}
 8027df2:	3710      	adds	r7, #16
 8027df4:	46bd      	mov	sp, r7
 8027df6:	bd80      	pop	{r7, pc}

08027df8 <BLE_StatusNot>:

static void BLE_StatusNot( HCI_TL_CmdStatus_t status )
{
 8027df8:	b580      	push	{r7, lr}
 8027dfa:	b082      	sub	sp, #8
 8027dfc:	af00      	add	r7, sp, #0
 8027dfe:	4603      	mov	r3, r0
 8027e00:	71fb      	strb	r3, [r7, #7]
  switch (status)
 8027e02:	79fb      	ldrb	r3, [r7, #7]
 8027e04:	2b00      	cmp	r3, #0
 8027e06:	d002      	beq.n	8027e0e <BLE_StatusNot+0x16>
 8027e08:	2b01      	cmp	r3, #1
 8027e0a:	d008      	beq.n	8027e1e <BLE_StatusNot+0x26>
    case HCI_TL_CmdAvailable:
      osMutexRelease( MtxHciId );
      break;

    default:
      break;
 8027e0c:	e00d      	b.n	8027e2a <BLE_StatusNot+0x32>
      osMutexAcquire( MtxHciId, osWaitForever );
 8027e0e:	4b09      	ldr	r3, [pc, #36]	; (8027e34 <BLE_StatusNot+0x3c>)
 8027e10:	681b      	ldr	r3, [r3, #0]
 8027e12:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8027e16:	4618      	mov	r0, r3
 8027e18:	f7fa fe7c 	bl	8022b14 <osMutexAcquire>
      break;
 8027e1c:	e005      	b.n	8027e2a <BLE_StatusNot+0x32>
      osMutexRelease( MtxHciId );
 8027e1e:	4b05      	ldr	r3, [pc, #20]	; (8027e34 <BLE_StatusNot+0x3c>)
 8027e20:	681b      	ldr	r3, [r3, #0]
 8027e22:	4618      	mov	r0, r3
 8027e24:	f7fa fec1 	bl	8022baa <osMutexRelease>
      break;
 8027e28:	bf00      	nop
  }
  return;
 8027e2a:	bf00      	nop
}
 8027e2c:	3708      	adds	r7, #8
 8027e2e:	46bd      	mov	sp, r7
 8027e30:	bd80      	pop	{r7, pc}
 8027e32:	bf00      	nop
 8027e34:	20012390 	.word	0x20012390

08027e38 <SVCCTL_InitCustomSvc>:
  hci_resume_flow();
  return;
}

/* USER CODE BEGIN FD_WRAP_FUNCTIONS */
void SVCCTL_InitCustomSvc(void) {
 8027e38:	b580      	push	{r7, lr}
 8027e3a:	af00      	add	r7, sp, #0
	DTS_STM_Init();
 8027e3c:	f000 f9c0 	bl	80281c0 <DTS_STM_Init>
}
 8027e40:	bf00      	nop
 8027e42:	bd80      	pop	{r7, pc}

08027e44 <DTS_Notification>:
/*************************************************************
 *
 * CALLBACK FUNCTIONS
 *
 *************************************************************/
void DTS_Notification(DTS_STM_App_Notification_evt_t *pNotification) {
 8027e44:	b580      	push	{r7, lr}
 8027e46:	b082      	sub	sp, #8
 8027e48:	af00      	add	r7, sp, #0
 8027e4a:	6078      	str	r0, [r7, #4]
	switch (pNotification->Evt_Opcode) {
 8027e4c:	687b      	ldr	r3, [r7, #4]
 8027e4e:	785b      	ldrb	r3, [r3, #1]
 8027e50:	2b05      	cmp	r3, #5
 8027e52:	d832      	bhi.n	8027eba <DTS_Notification+0x76>
 8027e54:	a201      	add	r2, pc, #4	; (adr r2, 8027e5c <DTS_Notification+0x18>)
 8027e56:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027e5a:	bf00      	nop
 8027e5c:	08027e75 	.word	0x08027e75
 8027e60:	08027e7d 	.word	0x08027e7d
 8027e64:	08027eb3 	.word	0x08027eb3
 8027e68:	08027e85 	.word	0x08027e85
 8027e6c:	08027ebb 	.word	0x08027ebb
 8027e70:	08027e8b 	.word	0x08027e8b
	case DTS_STM__NOTIFICATION_ENABLED:
		DataTransferServerContext.NotificationTransferReq =
 8027e74:	4b13      	ldr	r3, [pc, #76]	; (8027ec4 <DTS_Notification+0x80>)
 8027e76:	2201      	movs	r2, #1
 8027e78:	741a      	strb	r2, [r3, #16]
				DTS_APP_TRANSFER_REQ_ON;
//      UTIL_SEQ_SetTask(1 << CFG_TASK_DATA_TRANSFER_UPDATE_ID, CFG_SCH_PRIO_0);
//		osThreadFlagsSet(DataTransferProcessId, 1);
		break;
 8027e7a:	e01f      	b.n	8027ebc <DTS_Notification+0x78>

	case DTS_STM_NOTIFICATION_DISABLED:
		DataTransferServerContext.NotificationTransferReq =
 8027e7c:	4b11      	ldr	r3, [pc, #68]	; (8027ec4 <DTS_Notification+0x80>)
 8027e7e:	2200      	movs	r2, #0
 8027e80:	741a      	strb	r2, [r3, #16]
				DTS_APP_TRANSFER_REQ_OFF;
		break;
 8027e82:	e01b      	b.n	8027ebc <DTS_Notification+0x78>

	case DTC_NOTIFICATION_ENABLED:
		BLE_SVC_L2CAP_Conn_Update_7_5();
 8027e84:	f7ff fd4e 	bl	8027924 <BLE_SVC_L2CAP_Conn_Update_7_5>
//      BLE_SVC_L2CAP_Conn_Update(BleApplicationContext.BleApplicationContext_legacy.connectionHandle);

//DataTransferServerContext.NotificationClientTransferFlag = 0x01;
		break;
 8027e88:	e018      	b.n	8027ebc <DTS_Notification+0x78>
		//DataTransferServerContext.NotificationClientTransferFlag = 0x00;
		APP_DBG_MSG("write data notification disabled \n");
		break;

	case DTS_STM_DATA_RECEIVED:
		if (DataReceived == 0) {
 8027e8a:	4b0f      	ldr	r3, [pc, #60]	; (8027ec8 <DTS_Notification+0x84>)
 8027e8c:	681b      	ldr	r3, [r3, #0]
 8027e8e:	2b00      	cmp	r3, #0
 8027e90:	d107      	bne.n	8027ea2 <DTS_Notification+0x5e>
			/* start timer */
			DataReceived += pNotification->DataTransfered.Length;
 8027e92:	687b      	ldr	r3, [r7, #4]
 8027e94:	691a      	ldr	r2, [r3, #16]
 8027e96:	4b0c      	ldr	r3, [pc, #48]	; (8027ec8 <DTS_Notification+0x84>)
 8027e98:	681b      	ldr	r3, [r3, #0]
 8027e9a:	4413      	add	r3, r2
 8027e9c:	4a0a      	ldr	r2, [pc, #40]	; (8027ec8 <DTS_Notification+0x84>)
 8027e9e:	6013      	str	r3, [r2, #0]
//			HW_TS_Start(TimerDataThroughputWrite_Id, DELAY_1s);
		} else {
			DataReceived += pNotification->DataTransfered.Length;
		}
		break;
 8027ea0:	e00c      	b.n	8027ebc <DTS_Notification+0x78>
			DataReceived += pNotification->DataTransfered.Length;
 8027ea2:	687b      	ldr	r3, [r7, #4]
 8027ea4:	691a      	ldr	r2, [r3, #16]
 8027ea6:	4b08      	ldr	r3, [pc, #32]	; (8027ec8 <DTS_Notification+0x84>)
 8027ea8:	681b      	ldr	r3, [r3, #0]
 8027eaa:	4413      	add	r3, r2
 8027eac:	4a06      	ldr	r2, [pc, #24]	; (8027ec8 <DTS_Notification+0x84>)
 8027eae:	6013      	str	r3, [r2, #0]
		break;
 8027eb0:	e004      	b.n	8027ebc <DTS_Notification+0x78>

	case DTS_STM_GATT_TX_POOL_AVAILABLE:
		DataTransferServerContext.DtFlowStatus = DTS_APP_FLOW_ON;
 8027eb2:	4b04      	ldr	r3, [pc, #16]	; (8027ec4 <DTS_Notification+0x80>)
 8027eb4:	2201      	movs	r2, #1
 8027eb6:	749a      	strb	r2, [r3, #18]
//      UTIL_SEQ_SetTask(1 << CFG_TASK_DATA_TRANSFER_UPDATE_ID, CFG_SCH_PRIO_0);
//		osThreadFlagsSet(DataTransferProcessId, 1);
		break;
 8027eb8:	e000      	b.n	8027ebc <DTS_Notification+0x78>

	default:
		break;
 8027eba:	bf00      	nop
	}

	return;
 8027ebc:	bf00      	nop
}
 8027ebe:	3708      	adds	r7, #8
 8027ec0:	46bd      	mov	sp, r7
 8027ec2:	bd80      	pop	{r7, pc}
 8027ec4:	200123b0 	.word	0x200123b0
 8027ec8:	200123ac 	.word	0x200123ac

08027ecc <Resume_Notification>:
	}else{
	    return PACKET_UNDEFINED_ERR;
	}
}

void Resume_Notification(void) {
 8027ecc:	b480      	push	{r7}
 8027ece:	af00      	add	r7, sp, #0
	DataTransferServerContext.DtFlowStatus = DTS_APP_FLOW_ON;
 8027ed0:	4b03      	ldr	r3, [pc, #12]	; (8027ee0 <Resume_Notification+0x14>)
 8027ed2:	2201      	movs	r2, #1
 8027ed4:	749a      	strb	r2, [r3, #18]
}
 8027ed6:	bf00      	nop
 8027ed8:	46bd      	mov	sp, r7
 8027eda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ede:	4770      	bx	lr
 8027ee0:	200123b0 	.word	0x200123b0

08027ee4 <DTS_Event_Handler>:
/**
 * @brief  Event handler
 * @param  Event: Address of the buffer holding the Event
 * @retval Ack: Return whether the Event has been managed or not
 */
static SVCCTL_EvtAckStatus_t DTS_Event_Handler(void *Event) {
 8027ee4:	b5b0      	push	{r4, r5, r7, lr}
 8027ee6:	b090      	sub	sp, #64	; 0x40
 8027ee8:	af02      	add	r7, sp, #8
 8027eea:	6078      	str	r0, [r7, #4]
	aci_att_exchange_mtu_resp_event_rp0 *exchange_mtu_resp;
	aci_gatt_write_permit_req_event_rp0 *write_permit_req;

	DTS_STM_App_Notification_evt_t Notification;

	return_value = SVCCTL_EvtNotAck;
 8027eec:	2300      	movs	r3, #0
 8027eee:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	event_pckt = (hci_event_pckt*) (((hci_uart_pckt*) Event)->data);
 8027ef2:	687b      	ldr	r3, [r7, #4]
 8027ef4:	3301      	adds	r3, #1
 8027ef6:	633b      	str	r3, [r7, #48]	; 0x30

	switch (event_pckt->evt) {
 8027ef8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8027efa:	781b      	ldrb	r3, [r3, #0]
 8027efc:	2bff      	cmp	r3, #255	; 0xff
 8027efe:	f040 80e5 	bne.w	80280cc <DTS_Event_Handler+0x1e8>
	case EVT_VENDOR: {
		blue_evt = (evt_blue_aci*) event_pckt->data;
 8027f02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8027f04:	3302      	adds	r3, #2
 8027f06:	62fb      	str	r3, [r7, #44]	; 0x2c

		switch (blue_evt->ecode) {
 8027f08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027f0a:	881b      	ldrh	r3, [r3, #0]
 8027f0c:	b29b      	uxth	r3, r3
 8027f0e:	f6a3 4301 	subw	r3, r3, #3073	; 0xc01
 8027f12:	2b15      	cmp	r3, #21
 8027f14:	f200 80d6 	bhi.w	80280c4 <DTS_Event_Handler+0x1e0>
 8027f18:	a201      	add	r2, pc, #4	; (adr r2, 8027f20 <DTS_Event_Handler+0x3c>)
 8027f1a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027f1e:	bf00      	nop
 8027f20:	08027f8b 	.word	0x08027f8b
 8027f24:	080280c5 	.word	0x080280c5
 8027f28:	08027f79 	.word	0x08027f79
 8027f2c:	080280c5 	.word	0x080280c5
 8027f30:	080280c5 	.word	0x080280c5
 8027f34:	080280c5 	.word	0x080280c5
 8027f38:	080280c5 	.word	0x080280c5
 8027f3c:	080280c5 	.word	0x080280c5
 8027f40:	080280c5 	.word	0x080280c5
 8027f44:	080280c5 	.word	0x080280c5
 8027f48:	080280c5 	.word	0x080280c5
 8027f4c:	080280c5 	.word	0x080280c5
 8027f50:	080280c5 	.word	0x080280c5
 8027f54:	080280c5 	.word	0x080280c5
 8027f58:	080280c5 	.word	0x080280c5
 8027f5c:	080280c5 	.word	0x080280c5
 8027f60:	080280c5 	.word	0x080280c5
 8027f64:	080280c5 	.word	0x080280c5
 8027f68:	0802809d 	.word	0x0802809d
 8027f6c:	080280c5 	.word	0x080280c5
 8027f70:	080280c5 	.word	0x080280c5
 8027f74:	08028097 	.word	0x08028097
		case EVT_BLUE_ATT_EXCHANGE_MTU_RESP:
#ifdef NUCLEO_LED_ACTIVE
        	 BSP_LED_On(LED_BLUE);
#endif
			APP_DBG_MSG("EVT_BLUE_ATT_EXCHANGE_MTU_RESP \n");
			exchange_mtu_resp =
 8027f78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027f7a:	3302      	adds	r3, #2
 8027f7c:	627b      	str	r3, [r7, #36]	; 0x24
					(aci_att_exchange_mtu_resp_event_rp0*) blue_evt->data;
			APP_DBG_MSG("MTU_size = %d \n",exchange_mtu_resp->Server_RX_MTU );
			Att_Mtu_Exchanged = exchange_mtu_resp->Server_RX_MTU;
 8027f7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8027f80:	885b      	ldrh	r3, [r3, #2]
 8027f82:	b29a      	uxth	r2, r3
 8027f84:	4b55      	ldr	r3, [pc, #340]	; (80280dc <DTS_Event_Handler+0x1f8>)
 8027f86:	801a      	strh	r2, [r3, #0]
#ifdef NUCLEO_LED_ACTIVE
     	 BSP_LED_On(LED_GREEN);
#endif
			break;
 8027f88:	e09f      	b.n	80280ca <DTS_Event_Handler+0x1e6>
			/* server */
		case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED: {
			attribute_modified =
 8027f8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8027f8c:	3302      	adds	r3, #2
 8027f8e:	623b      	str	r3, [r7, #32]
					(aci_gatt_attribute_modified_event_rp0*) blue_evt->data;
			if (attribute_modified->Attr_Handle
 8027f90:	6a3b      	ldr	r3, [r7, #32]
 8027f92:	885b      	ldrh	r3, [r3, #2]
 8027f94:	b29b      	uxth	r3, r3
 8027f96:	461a      	mov	r2, r3
					== (aDataTransferContext.DataTransferTxCharHdle + 2)) {
 8027f98:	4b51      	ldr	r3, [pc, #324]	; (80280e0 <DTS_Event_Handler+0x1fc>)
 8027f9a:	885b      	ldrh	r3, [r3, #2]
 8027f9c:	3302      	adds	r3, #2
			if (attribute_modified->Attr_Handle
 8027f9e:	429a      	cmp	r2, r3
 8027fa0:	d114      	bne.n	8027fcc <DTS_Event_Handler+0xe8>
				/**
				 * Notify to application to start measurement
				 */
				if (attribute_modified->Attr_Data[0]
 8027fa2:	6a3b      	ldr	r3, [r7, #32]
 8027fa4:	7a1b      	ldrb	r3, [r3, #8]
						& DTS_STM_NOTIFICATION_MASK) {
 8027fa6:	f003 0301 	and.w	r3, r3, #1
				if (attribute_modified->Attr_Data[0]
 8027faa:	2b00      	cmp	r3, #0
 8027fac:	d007      	beq.n	8027fbe <DTS_Event_Handler+0xda>
					APP_DBG_MSG("notification enabled\n");
					Notification.Evt_Opcode = DTS_STM__NOTIFICATION_ENABLED;
 8027fae:	2300      	movs	r3, #0
 8027fb0:	737b      	strb	r3, [r7, #13]
					DTS_Notification(&Notification);
 8027fb2:	f107 030c 	add.w	r3, r7, #12
 8027fb6:	4618      	mov	r0, r3
 8027fb8:	f7ff ff44 	bl	8027e44 <DTS_Notification>
 8027fbc:	e006      	b.n	8027fcc <DTS_Event_Handler+0xe8>
				} else {
					APP_DBG_MSG("notification disabled\n");
					Notification.Evt_Opcode = DTS_STM_NOTIFICATION_DISABLED;
 8027fbe:	2301      	movs	r3, #1
 8027fc0:	737b      	strb	r3, [r7, #13]
					DTS_Notification(&Notification);
 8027fc2:	f107 030c 	add.w	r3, r7, #12
 8027fc6:	4618      	mov	r0, r3
 8027fc8:	f7ff ff3c 	bl	8027e44 <DTS_Notification>
				}
			}

			if (attribute_modified->Attr_Handle
 8027fcc:	6a3b      	ldr	r3, [r7, #32]
 8027fce:	885b      	ldrh	r3, [r3, #2]
 8027fd0:	b29b      	uxth	r3, r3
 8027fd2:	461a      	mov	r2, r3
					== (aDataTransferContext.DataTransferRxCharHdle + 2)) {
 8027fd4:	4b42      	ldr	r3, [pc, #264]	; (80280e0 <DTS_Event_Handler+0x1fc>)
 8027fd6:	889b      	ldrh	r3, [r3, #4]
 8027fd8:	3302      	adds	r3, #2
			if (attribute_modified->Attr_Handle
 8027fda:	429a      	cmp	r2, r3
 8027fdc:	d10d      	bne.n	8027ffa <DTS_Event_Handler+0x116>
				return_value = SVCCTL_EvtAckFlowEnable;
 8027fde:	2301      	movs	r3, #1
 8027fe0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

				Notification.Evt_Opcode = DTS_STM_DATA_RECEIVED;
 8027fe4:	2305      	movs	r3, #5
 8027fe6:	737b      	strb	r3, [r7, #13]
				Notification.DataTransfered.Length =
						attribute_modified->Attr_Data_Length;
 8027fe8:	6a3b      	ldr	r3, [r7, #32]
 8027fea:	88db      	ldrh	r3, [r3, #6]
 8027fec:	b29b      	uxth	r3, r3
				Notification.DataTransfered.Length =
 8027fee:	61fb      	str	r3, [r7, #28]
				DTS_Notification(&Notification);
 8027ff0:	f107 030c 	add.w	r3, r7, #12
 8027ff4:	4618      	mov	r0, r3
 8027ff6:	f7ff ff25 	bl	8027e44 <DTS_Notification>
			}

			// if LED characteristic was modified
			if (attribute_modified->Attr_Handle
 8027ffa:	6a3b      	ldr	r3, [r7, #32]
 8027ffc:	885b      	ldrh	r3, [r3, #2]
 8027ffe:	b29b      	uxth	r3, r3
 8028000:	461a      	mov	r2, r3
					== (aDataTransferContext.DataTransferRxCharLedHdle + 1)) {
 8028002:	4b37      	ldr	r3, [pc, #220]	; (80280e0 <DTS_Event_Handler+0x1fc>)
 8028004:	891b      	ldrh	r3, [r3, #8]
 8028006:	3301      	adds	r3, #1
			if (attribute_modified->Attr_Handle
 8028008:	429a      	cmp	r2, r3
 802800a:	d114      	bne.n	8028036 <DTS_Event_Handler+0x152>
#ifdef NUCLEO_LED_ACTIVE
        	  	  	  	  BSP_LED_Toggle(LED_BLUE);
#endif
				memcpy(&receivedColor, attribute_modified->Attr_Data,
 802800c:	6a3b      	ldr	r3, [r7, #32]
 802800e:	f103 0208 	add.w	r2, r3, #8
 8028012:	4b34      	ldr	r3, [pc, #208]	; (80280e4 <DTS_Event_Handler+0x200>)
 8028014:	6815      	ldr	r5, [r2, #0]
 8028016:	6854      	ldr	r4, [r2, #4]
 8028018:	6890      	ldr	r0, [r2, #8]
 802801a:	68d1      	ldr	r1, [r2, #12]
 802801c:	601d      	str	r5, [r3, #0]
 802801e:	605c      	str	r4, [r3, #4]
 8028020:	6098      	str	r0, [r3, #8]
 8028022:	60d9      	str	r1, [r3, #12]
 8028024:	8a12      	ldrh	r2, [r2, #16]
 8028026:	821a      	strh	r2, [r3, #16]
						sizeof(receivedColor));
				//FrontLightsSet(&receivedColor);
				osMessageQueuePut(lightsComplexQueueHandle, &receivedColor, 0, 0);
 8028028:	4b2f      	ldr	r3, [pc, #188]	; (80280e8 <DTS_Event_Handler+0x204>)
 802802a:	6818      	ldr	r0, [r3, #0]
 802802c:	2300      	movs	r3, #0
 802802e:	2200      	movs	r2, #0
 8028030:	492c      	ldr	r1, [pc, #176]	; (80280e4 <DTS_Event_Handler+0x200>)
 8028032:	f7fa ff8b 	bl	8022f4c <osMessageQueuePut>

			}

			// if system config was modified
			if (attribute_modified->Attr_Handle
 8028036:	6a3b      	ldr	r3, [r7, #32]
 8028038:	885b      	ldrh	r3, [r3, #2]
 802803a:	b29b      	uxth	r3, r3
 802803c:	461a      	mov	r2, r3
					== (aDataTransferContext.DataTransferRxCharControlHdle + 1)) {
 802803e:	4b28      	ldr	r3, [pc, #160]	; (80280e0 <DTS_Event_Handler+0x1fc>)
 8028040:	895b      	ldrh	r3, [r3, #10]
 8028042:	3301      	adds	r3, #1
			if (attribute_modified->Attr_Handle
 8028044:	429a      	cmp	r2, r3
 8028046:	d107      	bne.n	8028058 <DTS_Event_Handler+0x174>
#ifdef NUCLEO_LED_ACTIVE
        	  BSP_LED_Toggle(LED_GREEN);
#endif
				memcpy(&receivedCntrlPacket, attribute_modified->Attr_Data,
 8028048:	6a3b      	ldr	r3, [r7, #32]
 802804a:	f103 0208 	add.w	r2, r3, #8
 802804e:	4b27      	ldr	r3, [pc, #156]	; (80280ec <DTS_Event_Handler+0x208>)
 8028050:	6811      	ldr	r1, [r2, #0]
 8028052:	6019      	str	r1, [r3, #0]
 8028054:	8892      	ldrh	r2, [r2, #4]
 8028056:	809a      	strh	r2, [r3, #4]
//						0U, 0U);

			}

			// if epoch was set
			if (attribute_modified->Attr_Handle
 8028058:	6a3b      	ldr	r3, [r7, #32]
 802805a:	885b      	ldrh	r3, [r3, #2]
 802805c:	b29b      	uxth	r3, r3
 802805e:	461a      	mov	r2, r3
					== (aDataTransferContext.DataTransferRxCharTimeHdle + 1)) {
 8028060:	4b1f      	ldr	r3, [pc, #124]	; (80280e0 <DTS_Event_Handler+0x1fc>)
 8028062:	899b      	ldrh	r3, [r3, #12]
 8028064:	3301      	adds	r3, #1
			if (attribute_modified->Attr_Handle
 8028066:	429a      	cmp	r2, r3
 8028068:	d12e      	bne.n	80280c8 <DTS_Event_Handler+0x1e4>
#ifdef NUCLEO_LED_ACTIVE
						  BSP_LED_Toggle(LED_GREEN);
#endif
				memcpy(&receivedEpoch, attribute_modified->Attr_Data,
 802806a:	6a3b      	ldr	r3, [r7, #32]
 802806c:	3308      	adds	r3, #8
 802806e:	2208      	movs	r2, #8
 8028070:	4619      	mov	r1, r3
 8028072:	481f      	ldr	r0, [pc, #124]	; (80280f0 <DTS_Event_Handler+0x20c>)
 8028074:	f004 f834 	bl	802c0e0 <memcpy>
						sizeof(receivedEpoch));

				receivedEpoch = receivedEpoch / 1000;
 8028078:	4b1d      	ldr	r3, [pc, #116]	; (80280f0 <DTS_Event_Handler+0x20c>)
 802807a:	e9d3 0100 	ldrd	r0, r1, [r3]
 802807e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8028082:	f04f 0300 	mov.w	r3, #0
 8028086:	f7e0 f98d 	bl	80083a4 <__aeabi_ldivmod>
 802808a:	4602      	mov	r2, r0
 802808c:	460b      	mov	r3, r1
 802808e:	4918      	ldr	r1, [pc, #96]	; (80280f0 <DTS_Event_Handler+0x20c>)
 8028090:	e9c1 2300 	strd	r2, r3, [r1]
//				updateRTC(receivedEpoch);

			}

		}
			break;
 8028094:	e018      	b.n	80280c8 <DTS_Event_Handler+0x1e4>
		case EVT_BLUE_GATT_TX_POOL_AVAILABLE:
			Resume_Notification();
 8028096:	f7ff ff19 	bl	8027ecc <Resume_Notification>
			break;
 802809a:	e016      	b.n	80280ca <DTS_Event_Handler+0x1e6>

		case EVT_BLUE_GATT_WRITE_PERMIT_REQ:
			APP_DBG_MSG("write permit req\r\n");
			write_permit_req =
 802809c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802809e:	3302      	adds	r3, #2
 80280a0:	62bb      	str	r3, [r7, #40]	; 0x28
					(aci_gatt_write_permit_req_event_rp0*) blue_evt->data;
			aci_gatt_write_resp(write_permit_req->Connection_Handle,
 80280a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80280a4:	881b      	ldrh	r3, [r3, #0]
 80280a6:	b298      	uxth	r0, r3
 80280a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80280aa:	885b      	ldrh	r3, [r3, #2]
 80280ac:	b299      	uxth	r1, r3
 80280ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80280b0:	791b      	ldrb	r3, [r3, #4]
					write_permit_req->Attribute_Handle, 0, 0,
					write_permit_req->Data_Length, write_permit_req->Data);
 80280b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80280b4:	3205      	adds	r2, #5
			aci_gatt_write_resp(write_permit_req->Connection_Handle,
 80280b6:	9201      	str	r2, [sp, #4]
 80280b8:	9300      	str	r3, [sp, #0]
 80280ba:	2300      	movs	r3, #0
 80280bc:	2200      	movs	r2, #0
 80280be:	f7f2 fae2 	bl	801a686 <aci_gatt_write_resp>
			break;
 80280c2:	e002      	b.n	80280ca <DTS_Event_Handler+0x1e6>

		default:
			break;
 80280c4:	bf00      	nop
 80280c6:	e002      	b.n	80280ce <DTS_Event_Handler+0x1ea>
			break;
 80280c8:	bf00      	nop
		}
	}
		break; /* HCI_EVT_VENDOR_SPECIFIC */
 80280ca:	e000      	b.n	80280ce <DTS_Event_Handler+0x1ea>

	default:
		break;
 80280cc:	bf00      	nop
	}

	return (return_value);
 80280ce:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}/* end SVCCTL_EvtAckStatus_t */
 80280d2:	4618      	mov	r0, r3
 80280d4:	3738      	adds	r7, #56	; 0x38
 80280d6:	46bd      	mov	sp, r7
 80280d8:	bdb0      	pop	{r4, r5, r7, pc}
 80280da:	bf00      	nop
 80280dc:	2001239c 	.word	0x2001239c
 80280e0:	20010bf4 	.word	0x20010bf4
 80280e4:	20012048 	.word	0x20012048
 80280e8:	200003b4 	.word	0x200003b4
 80280ec:	200123d0 	.word	0x200123d0
 80280f0:	200123c8 	.word	0x200123c8

080280f4 <TX_Update_Char>:
 * @retval None
 */
//https://www.st.com/resource/en/programming_manual/pm0271-stm32wb-ble-stack-programming-guidelines-stmicroelectronics.pdf
# define MAX_PACKET_LENGTH	243 // https://www.compel.ru/wordpress/wp-content/uploads/2019/12/en.dm00598033.pdf

static tBleStatus TX_Update_Char(DTS_STM_Payload_t *pDataValue) {
 80280f4:	b5b0      	push	{r4, r5, r7, lr}
 80280f6:	b088      	sub	sp, #32
 80280f8:	af04      	add	r7, sp, #16
 80280fa:	6078      	str	r0, [r7, #4]
	tBleStatus ret;

	/**
	 *  Notification Data Transfer Packet
	 */
	if(pDataValue->Length < MAX_PACKET_LENGTH){
 80280fc:	687b      	ldr	r3, [r7, #4]
 80280fe:	68db      	ldr	r3, [r3, #12]
 8028100:	2bf2      	cmp	r3, #242	; 0xf2
 8028102:	d810      	bhi.n	8028126 <TX_Update_Char+0x32>
	  ret = aci_gatt_update_char_value(aDataTransferContext.DataTransferSvcHdle,
 8028104:	4b2d      	ldr	r3, [pc, #180]	; (80281bc <TX_Update_Char+0xc8>)
 8028106:	8818      	ldrh	r0, [r3, #0]
 8028108:	4b2c      	ldr	r3, [pc, #176]	; (80281bc <TX_Update_Char+0xc8>)
 802810a:	8859      	ldrh	r1, [r3, #2]
			  aDataTransferContext.DataTransferTxCharHdle, 0, /* charValOffset */
			  pDataValue->Length, /* charValueLen */
 802810c:	687b      	ldr	r3, [r7, #4]
 802810e:	68db      	ldr	r3, [r3, #12]
	  ret = aci_gatt_update_char_value(aDataTransferContext.DataTransferSvcHdle,
 8028110:	b2da      	uxtb	r2, r3
			  (uint8_t*) pDataValue->pPayload);
 8028112:	687b      	ldr	r3, [r7, #4]
 8028114:	681b      	ldr	r3, [r3, #0]
	  ret = aci_gatt_update_char_value(aDataTransferContext.DataTransferSvcHdle,
 8028116:	9300      	str	r3, [sp, #0]
 8028118:	4613      	mov	r3, r2
 802811a:	2200      	movs	r2, #0
 802811c:	f7f2 fa2c 	bl	801a578 <aci_gatt_update_char_value>
 8028120:	4603      	mov	r3, r0
 8028122:	73fb      	strb	r3, [r7, #15]
 8028124:	e044      	b.n	80281b0 <TX_Update_Char+0xbc>
	}
	else if(pDataValue->Length <= DATA_NOTIFICATION_MAX_PACKET_SIZE){
 8028126:	687b      	ldr	r3, [r7, #4]
 8028128:	68db      	ldr	r3, [r3, #12]
 802812a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802812e:	d83f      	bhi.n	80281b0 <TX_Update_Char+0xbc>

	    uint16_t packetLen = pDataValue->Length;
 8028130:	687b      	ldr	r3, [r7, #4]
 8028132:	68db      	ldr	r3, [r3, #12]
 8028134:	81bb      	strh	r3, [r7, #12]
	    uint16_t offset = 0;
 8028136:	2300      	movs	r3, #0
 8028138:	817b      	strh	r3, [r7, #10]

	    while(packetLen > MAX_PACKET_LENGTH){
 802813a:	e01c      	b.n	8028176 <TX_Update_Char+0x82>
	      aci_gatt_update_char_value_ext (0,
 802813c:	4b1f      	ldr	r3, [pc, #124]	; (80281bc <TX_Update_Char+0xc8>)
 802813e:	8818      	ldrh	r0, [r3, #0]
 8028140:	4b1e      	ldr	r3, [pc, #120]	; (80281bc <TX_Update_Char+0xc8>)
 8028142:	885c      	ldrh	r4, [r3, #2]
				       aDataTransferContext.DataTransferSvcHdle,
				       aDataTransferContext.DataTransferTxCharHdle,
					0x00, //dont notify
					pDataValue->Length,
 8028144:	687b      	ldr	r3, [r7, #4]
 8028146:	68db      	ldr	r3, [r3, #12]
	      aci_gatt_update_char_value_ext (0,
 8028148:	b29b      	uxth	r3, r3
					offset,
					MAX_PACKET_LENGTH,
					((uint8_t*) pDataValue->pPayload) + offset);
 802814a:	687a      	ldr	r2, [r7, #4]
 802814c:	6811      	ldr	r1, [r2, #0]
	      aci_gatt_update_char_value_ext (0,
 802814e:	897a      	ldrh	r2, [r7, #10]
					((uint8_t*) pDataValue->pPayload) + offset);
 8028150:	440a      	add	r2, r1
	      aci_gatt_update_char_value_ext (0,
 8028152:	9203      	str	r2, [sp, #12]
 8028154:	22f3      	movs	r2, #243	; 0xf3
 8028156:	9202      	str	r2, [sp, #8]
 8028158:	897a      	ldrh	r2, [r7, #10]
 802815a:	9201      	str	r2, [sp, #4]
 802815c:	9300      	str	r3, [sp, #0]
 802815e:	2300      	movs	r3, #0
 8028160:	4622      	mov	r2, r4
 8028162:	4601      	mov	r1, r0
 8028164:	2000      	movs	r0, #0
 8028166:	f7f2 fb1f 	bl	801a7a8 <aci_gatt_update_char_value_ext>
	      offset += MAX_PACKET_LENGTH;
 802816a:	897b      	ldrh	r3, [r7, #10]
 802816c:	33f3      	adds	r3, #243	; 0xf3
 802816e:	817b      	strh	r3, [r7, #10]
	      packetLen -= MAX_PACKET_LENGTH;
 8028170:	89bb      	ldrh	r3, [r7, #12]
 8028172:	3bf3      	subs	r3, #243	; 0xf3
 8028174:	81bb      	strh	r3, [r7, #12]
	    while(packetLen > MAX_PACKET_LENGTH){
 8028176:	89bb      	ldrh	r3, [r7, #12]
 8028178:	2bf3      	cmp	r3, #243	; 0xf3
 802817a:	d8df      	bhi.n	802813c <TX_Update_Char+0x48>
	    }

	    ret = aci_gatt_update_char_value_ext (0,
 802817c:	4b0f      	ldr	r3, [pc, #60]	; (80281bc <TX_Update_Char+0xc8>)
 802817e:	881c      	ldrh	r4, [r3, #0]
 8028180:	4b0e      	ldr	r3, [pc, #56]	; (80281bc <TX_Update_Char+0xc8>)
 8028182:	885d      	ldrh	r5, [r3, #2]
	    					     aDataTransferContext.DataTransferSvcHdle,
	    					     aDataTransferContext.DataTransferTxCharHdle,
	    	0x01, //notify
		pDataValue->Length,
 8028184:	687b      	ldr	r3, [r7, #4]
 8028186:	68db      	ldr	r3, [r3, #12]
	    ret = aci_gatt_update_char_value_ext (0,
 8028188:	b29b      	uxth	r3, r3
 802818a:	89ba      	ldrh	r2, [r7, #12]
 802818c:	b2d2      	uxtb	r2, r2
		offset,
		packetLen,
	    	((uint8_t*) pDataValue->pPayload) + offset);
 802818e:	6879      	ldr	r1, [r7, #4]
 8028190:	6808      	ldr	r0, [r1, #0]
	    ret = aci_gatt_update_char_value_ext (0,
 8028192:	8979      	ldrh	r1, [r7, #10]
	    	((uint8_t*) pDataValue->pPayload) + offset);
 8028194:	4401      	add	r1, r0
	    ret = aci_gatt_update_char_value_ext (0,
 8028196:	9103      	str	r1, [sp, #12]
 8028198:	9202      	str	r2, [sp, #8]
 802819a:	897a      	ldrh	r2, [r7, #10]
 802819c:	9201      	str	r2, [sp, #4]
 802819e:	9300      	str	r3, [sp, #0]
 80281a0:	2301      	movs	r3, #1
 80281a2:	462a      	mov	r2, r5
 80281a4:	4621      	mov	r1, r4
 80281a6:	2000      	movs	r0, #0
 80281a8:	f7f2 fafe 	bl	801a7a8 <aci_gatt_update_char_value_ext>
 80281ac:	4603      	mov	r3, r0
 80281ae:	73fb      	strb	r3, [r7, #15]
	}

	return ret;
 80281b0:	7bfb      	ldrb	r3, [r7, #15]
}/* end TX_Update_Char() */
 80281b2:	4618      	mov	r0, r3
 80281b4:	3710      	adds	r7, #16
 80281b6:	46bd      	mov	sp, r7
 80281b8:	bdb0      	pop	{r4, r5, r7, pc}
 80281ba:	bf00      	nop
 80281bc:	20010bf4 	.word	0x20010bf4

080281c0 <DTS_STM_Init>:
/**
 * @brief  Service initialization
 * @param  None
 * @retval None
 */
void DTS_STM_Init(void) {
 80281c0:	b580      	push	{r7, lr}
 80281c2:	b088      	sub	sp, #32
 80281c4:	af06      	add	r7, sp, #24
	tBleStatus hciCmdResult = BLE_STATUS_FAILED;
 80281c6:	2391      	movs	r3, #145	; 0x91
 80281c8:	71fb      	strb	r3, [r7, #7]

	/**
	 *	Register the event handler to the BLE controller
	 */
	SVCCTL_RegisterSvcHandler(DTS_Event_Handler);
 80281ca:	481e      	ldr	r0, [pc, #120]	; (8028244 <DTS_STM_Init+0x84>)
 80281cc:	f7f2 ffba 	bl	801b144 <SVCCTL_RegisterSvcHandler>
	/* DT service and characteristics */
//	hciCmdResult = aci_gatt_add_service(DT_UUID_LENGTH,
//				(Service_UUID_t*) DATA_TRANSFER_SERVICE_UUID,
//				PRIMARY_SERVICE, 1 + 3 * NUM_OF_CHARACTERISTICS,
//				&(aDataTransferContext.DataTransferSvcHdle));
	hciCmdResult = aci_gatt_add_service(DT_UUID_LENGTH,
 80281d0:	4b1d      	ldr	r3, [pc, #116]	; (8028248 <DTS_STM_Init+0x88>)
 80281d2:	9300      	str	r3, [sp, #0]
 80281d4:	2313      	movs	r3, #19
 80281d6:	2201      	movs	r2, #1
 80281d8:	491c      	ldr	r1, [pc, #112]	; (802824c <DTS_STM_Init+0x8c>)
 80281da:	2001      	movs	r0, #1
 80281dc:	f7f2 f833 	bl	801a246 <aci_gatt_add_service>
 80281e0:	4603      	mov	r3, r0
 80281e2:	71fb      	strb	r3, [r7, #7]
	}

	/**
	 *  Add Data Transfer TX Characteristic (characteristic that is used to send data)
	 */
	hciCmdResult = aci_gatt_add_char(aDataTransferContext.DataTransferSvcHdle,
 80281e4:	4b18      	ldr	r3, [pc, #96]	; (8028248 <DTS_STM_Init+0x88>)
 80281e6:	8818      	ldrh	r0, [r3, #0]
 80281e8:	4b19      	ldr	r3, [pc, #100]	; (8028250 <DTS_STM_Init+0x90>)
 80281ea:	9305      	str	r3, [sp, #20]
 80281ec:	2301      	movs	r3, #1
 80281ee:	9304      	str	r3, [sp, #16]
 80281f0:	230a      	movs	r3, #10
 80281f2:	9303      	str	r3, [sp, #12]
 80281f4:	2301      	movs	r3, #1
 80281f6:	9302      	str	r3, [sp, #8]
 80281f8:	2300      	movs	r3, #0
 80281fa:	9301      	str	r3, [sp, #4]
 80281fc:	2310      	movs	r3, #16
 80281fe:	9300      	str	r3, [sp, #0]
 8028200:	f44f 7300 	mov.w	r3, #512	; 0x200
 8028204:	4a13      	ldr	r2, [pc, #76]	; (8028254 <DTS_STM_Init+0x94>)
 8028206:	2101      	movs	r1, #1
 8028208:	f7f2 f8cc 	bl	801a3a4 <aci_gatt_add_char>
 802820c:	4603      	mov	r3, r0
 802820e:	71fb      	strb	r3, [r7, #7]
	}

	/**
	 *  Add Data Transfer RX Characteristic (not intended to be used in the end)
	 */
	hciCmdResult = aci_gatt_add_char(aDataTransferContext.DataTransferSvcHdle,
 8028210:	4b0d      	ldr	r3, [pc, #52]	; (8028248 <DTS_STM_Init+0x88>)
 8028212:	8818      	ldrh	r0, [r3, #0]
 8028214:	4b10      	ldr	r3, [pc, #64]	; (8028258 <DTS_STM_Init+0x98>)
 8028216:	9305      	str	r3, [sp, #20]
 8028218:	2301      	movs	r3, #1
 802821a:	9304      	str	r3, [sp, #16]
 802821c:	230a      	movs	r3, #10
 802821e:	9303      	str	r3, [sp, #12]
 8028220:	2301      	movs	r3, #1
 8028222:	9302      	str	r3, [sp, #8]
 8028224:	2300      	movs	r3, #0
 8028226:	9301      	str	r3, [sp, #4]
 8028228:	2304      	movs	r3, #4
 802822a:	9300      	str	r3, [sp, #0]
 802822c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8028230:	4a0a      	ldr	r2, [pc, #40]	; (802825c <DTS_STM_Init+0x9c>)
 8028232:	2101      	movs	r1, #1
 8028234:	f7f2 f8b6 	bl	801a3a4 <aci_gatt_add_char>
 8028238:	4603      	mov	r3, r0
 802823a:	71fb      	strb	r3, [r7, #7]
//#ifdef NUCLEO_LED_ACTIVE
//      BSP_LED_On(LED_RED);
//  #endif
//	}

	return;
 802823c:	bf00      	nop
}
 802823e:	3708      	adds	r7, #8
 8028240:	46bd      	mov	sp, r7
 8028242:	bd80      	pop	{r7, pc}
 8028244:	08027ee5 	.word	0x08027ee5
 8028248:	20010bf4 	.word	0x20010bf4
 802824c:	0802d554 	.word	0x0802d554
 8028250:	20010bf6 	.word	0x20010bf6
 8028254:	20000140 	.word	0x20000140
 8028258:	20010bf8 	.word	0x20010bf8
 802825c:	0802d550 	.word	0x0802d550

08028260 <DTS_STM_UpdateChar>:
 * @brief  Characteristic update
 * @param  UUID: UUID of the characteristic
 * @param  Service_Instance: Instance of the service to which the characteristic belongs
 * 
 */
tBleStatus DTS_STM_UpdateChar(uint16_t UUID, uint8_t *pPayload) {
 8028260:	b580      	push	{r7, lr}
 8028262:	b084      	sub	sp, #16
 8028264:	af00      	add	r7, sp, #0
 8028266:	4603      	mov	r3, r0
 8028268:	6039      	str	r1, [r7, #0]
 802826a:	80fb      	strh	r3, [r7, #6]
	tBleStatus result = BLE_STATUS_INVALID_PARAMS;
 802826c:	2392      	movs	r3, #146	; 0x92
 802826e:	73fb      	strb	r3, [r7, #15]
	switch (UUID) {
 8028270:	88fb      	ldrh	r3, [r7, #6]
 8028272:	f64f 6281 	movw	r2, #65153	; 0xfe81
 8028276:	4293      	cmp	r3, r2
 8028278:	d105      	bne.n	8028286 <DTS_STM_UpdateChar+0x26>
	case DATA_TRANSFER_TX_CHAR_UUID:
		result = TX_Update_Char((DTS_STM_Payload_t*) pPayload);
 802827a:	6838      	ldr	r0, [r7, #0]
 802827c:	f7ff ff3a 	bl	80280f4 <TX_Update_Char>
 8028280:	4603      	mov	r3, r0
 8028282:	73fb      	strb	r3, [r7, #15]
		break;
 8028284:	e000      	b.n	8028288 <DTS_STM_UpdateChar+0x28>

	default:
		break;
 8028286:	bf00      	nop
	}
	return result;
 8028288:	7bfb      	ldrb	r3, [r7, #15]
}/* end DTS_STM_UpdateChar() */
 802828a:	4618      	mov	r0, r3
 802828c:	3710      	adds	r7, #16
 802828e:	46bd      	mov	sp, r7
 8028290:	bd80      	pop	{r7, pc}

08028292 <HRS_Notification>:

/* USER CODE END PFP */

/* Functions Definition ------------------------------------------------------*/
void HRS_Notification(HRS_App_Notification_evt_t *pNotification)
{
 8028292:	b480      	push	{r7}
 8028294:	b083      	sub	sp, #12
 8028296:	af00      	add	r7, sp, #0
 8028298:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN HRS_Notification_1 */

/* USER CODE END HRS_Notification_1 */
  switch(pNotification->HRS_Evt_Opcode)
 802829a:	687b      	ldr	r3, [r7, #4]
 802829c:	781b      	ldrb	r3, [r3, #0]
 802829e:	2b02      	cmp	r3, #2
 80282a0:	d006      	beq.n	80282b0 <HRS_Notification+0x1e>
 80282a2:	2b02      	cmp	r3, #2
 80282a4:	dc06      	bgt.n	80282b4 <HRS_Notification+0x22>
 80282a6:	2b00      	cmp	r3, #0
 80282a8:	d006      	beq.n	80282b8 <HRS_Notification+0x26>
 80282aa:	2b01      	cmp	r3, #1
 80282ac:	d006      	beq.n	80282bc <HRS_Notification+0x2a>

   default:
/* USER CODE BEGIN HRS_Notification_Default */

/* USER CODE END HRS_Notification_Default */
      break;
 80282ae:	e001      	b.n	80282b4 <HRS_Notification+0x22>
      break;
 80282b0:	bf00      	nop
 80282b2:	e004      	b.n	80282be <HRS_Notification+0x2c>
      break;
 80282b4:	bf00      	nop
 80282b6:	e002      	b.n	80282be <HRS_Notification+0x2c>
      break;
 80282b8:	bf00      	nop
 80282ba:	e000      	b.n	80282be <HRS_Notification+0x2c>
      break;
 80282bc:	bf00      	nop
  }
/* USER CODE BEGIN HRS_Notification_2 */

/* USER CODE END HRS_Notification_2 */
  return;
 80282be:	bf00      	nop
}
 80282c0:	370c      	adds	r7, #12
 80282c2:	46bd      	mov	sp, r7
 80282c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80282c8:	4770      	bx	lr
	...

080282cc <LL_PWR_EnableBootC2>:
{
 80282cc:	b480      	push	{r7}
 80282ce:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR4, PWR_CR4_C2BOOT);
 80282d0:	4b05      	ldr	r3, [pc, #20]	; (80282e8 <LL_PWR_EnableBootC2+0x1c>)
 80282d2:	68db      	ldr	r3, [r3, #12]
 80282d4:	4a04      	ldr	r2, [pc, #16]	; (80282e8 <LL_PWR_EnableBootC2+0x1c>)
 80282d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80282da:	60d3      	str	r3, [r2, #12]
}
 80282dc:	bf00      	nop
 80282de:	46bd      	mov	sp, r7
 80282e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80282e4:	4770      	bx	lr
 80282e6:	bf00      	nop
 80282e8:	58000400 	.word	0x58000400

080282ec <LL_C2_EXTI_EnableEvent_32_63>:
{
 80282ec:	b480      	push	{r7}
 80282ee:	b083      	sub	sp, #12
 80282f0:	af00      	add	r7, sp, #0
 80282f2:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->C2EMR2, ExtiLine);
 80282f4:	4b06      	ldr	r3, [pc, #24]	; (8028310 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 80282f6:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 80282fa:	4905      	ldr	r1, [pc, #20]	; (8028310 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 80282fc:	687b      	ldr	r3, [r7, #4]
 80282fe:	4313      	orrs	r3, r2
 8028300:	f8c1 30d4 	str.w	r3, [r1, #212]	; 0xd4
}
 8028304:	bf00      	nop
 8028306:	370c      	adds	r7, #12
 8028308:	46bd      	mov	sp, r7
 802830a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802830e:	4770      	bx	lr
 8028310:	58000800 	.word	0x58000800

08028314 <LL_EXTI_EnableRisingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
 8028314:	b480      	push	{r7}
 8028316:	b083      	sub	sp, #12
 8028318:	af00      	add	r7, sp, #0
 802831a:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR2, ExtiLine);
 802831c:	4b05      	ldr	r3, [pc, #20]	; (8028334 <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 802831e:	6a1a      	ldr	r2, [r3, #32]
 8028320:	4904      	ldr	r1, [pc, #16]	; (8028334 <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8028322:	687b      	ldr	r3, [r7, #4]
 8028324:	4313      	orrs	r3, r2
 8028326:	620b      	str	r3, [r1, #32]
}
 8028328:	bf00      	nop
 802832a:	370c      	adds	r7, #12
 802832c:	46bd      	mov	sp, r7
 802832e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028332:	4770      	bx	lr
 8028334:	58000800 	.word	0x58000800

08028338 <LL_AHB3_GRP1_EnableClock>:
{
 8028338:	b480      	push	{r7}
 802833a:	b085      	sub	sp, #20
 802833c:	af00      	add	r7, sp, #0
 802833e:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 8028340:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028344:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8028346:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802834a:	687b      	ldr	r3, [r7, #4]
 802834c:	4313      	orrs	r3, r2
 802834e:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 8028350:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028354:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8028356:	687b      	ldr	r3, [r7, #4]
 8028358:	4013      	ands	r3, r2
 802835a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 802835c:	68fb      	ldr	r3, [r7, #12]
}
 802835e:	bf00      	nop
 8028360:	3714      	adds	r7, #20
 8028362:	46bd      	mov	sp, r7
 8028364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028368:	4770      	bx	lr

0802836a <LL_C2_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_IPCC
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_FLASH
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 802836a:	b480      	push	{r7}
 802836c:	b085      	sub	sp, #20
 802836e:	af00      	add	r7, sp, #0
 8028370:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 8028372:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028376:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 802837a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 802837e:	687b      	ldr	r3, [r7, #4]
 8028380:	4313      	orrs	r3, r2
 8028382:	f8c1 3150 	str.w	r3, [r1, #336]	; 0x150
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 8028386:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 802838a:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 802838e:	687b      	ldr	r3, [r7, #4]
 8028390:	4013      	ands	r3, r2
 8028392:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8028394:	68fb      	ldr	r3, [r7, #12]
}
 8028396:	bf00      	nop
 8028398:	3714      	adds	r7, #20
 802839a:	46bd      	mov	sp, r7
 802839c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283a0:	4770      	bx	lr

080283a2 <LL_C1_IPCC_EnableIT_TXF>:
{
 80283a2:	b480      	push	{r7}
 80283a4:	b083      	sub	sp, #12
 80283a6:	af00      	add	r7, sp, #0
 80283a8:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_TXFIE);
 80283aa:	687b      	ldr	r3, [r7, #4]
 80283ac:	681b      	ldr	r3, [r3, #0]
 80283ae:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80283b2:	687b      	ldr	r3, [r7, #4]
 80283b4:	601a      	str	r2, [r3, #0]
}
 80283b6:	bf00      	nop
 80283b8:	370c      	adds	r7, #12
 80283ba:	46bd      	mov	sp, r7
 80283bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283c0:	4770      	bx	lr

080283c2 <LL_C1_IPCC_EnableIT_RXO>:
{
 80283c2:	b480      	push	{r7}
 80283c4:	b083      	sub	sp, #12
 80283c6:	af00      	add	r7, sp, #0
 80283c8:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_RXOIE);
 80283ca:	687b      	ldr	r3, [r7, #4]
 80283cc:	681b      	ldr	r3, [r3, #0]
 80283ce:	f043 0201 	orr.w	r2, r3, #1
 80283d2:	687b      	ldr	r3, [r7, #4]
 80283d4:	601a      	str	r2, [r3, #0]
}
 80283d6:	bf00      	nop
 80283d8:	370c      	adds	r7, #12
 80283da:	46bd      	mov	sp, r7
 80283dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283e0:	4770      	bx	lr

080283e2 <LL_C1_IPCC_EnableTransmitChannel>:
{
 80283e2:	b480      	push	{r7}
 80283e4:	b083      	sub	sp, #12
 80283e6:	af00      	add	r7, sp, #0
 80283e8:	6078      	str	r0, [r7, #4]
 80283ea:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 80283ec:	687b      	ldr	r3, [r7, #4]
 80283ee:	685a      	ldr	r2, [r3, #4]
 80283f0:	683b      	ldr	r3, [r7, #0]
 80283f2:	041b      	lsls	r3, r3, #16
 80283f4:	43db      	mvns	r3, r3
 80283f6:	401a      	ands	r2, r3
 80283f8:	687b      	ldr	r3, [r7, #4]
 80283fa:	605a      	str	r2, [r3, #4]
}
 80283fc:	bf00      	nop
 80283fe:	370c      	adds	r7, #12
 8028400:	46bd      	mov	sp, r7
 8028402:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028406:	4770      	bx	lr

08028408 <LL_C1_IPCC_DisableTransmitChannel>:
{
 8028408:	b480      	push	{r7}
 802840a:	b083      	sub	sp, #12
 802840c:	af00      	add	r7, sp, #0
 802840e:	6078      	str	r0, [r7, #4]
 8028410:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8028412:	687b      	ldr	r3, [r7, #4]
 8028414:	685a      	ldr	r2, [r3, #4]
 8028416:	683b      	ldr	r3, [r7, #0]
 8028418:	041b      	lsls	r3, r3, #16
 802841a:	431a      	orrs	r2, r3
 802841c:	687b      	ldr	r3, [r7, #4]
 802841e:	605a      	str	r2, [r3, #4]
}
 8028420:	bf00      	nop
 8028422:	370c      	adds	r7, #12
 8028424:	46bd      	mov	sp, r7
 8028426:	f85d 7b04 	ldr.w	r7, [sp], #4
 802842a:	4770      	bx	lr

0802842c <LL_C1_IPCC_EnableReceiveChannel>:
{
 802842c:	b480      	push	{r7}
 802842e:	b083      	sub	sp, #12
 8028430:	af00      	add	r7, sp, #0
 8028432:	6078      	str	r0, [r7, #4]
 8028434:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel);
 8028436:	687b      	ldr	r3, [r7, #4]
 8028438:	685a      	ldr	r2, [r3, #4]
 802843a:	683b      	ldr	r3, [r7, #0]
 802843c:	43db      	mvns	r3, r3
 802843e:	401a      	ands	r2, r3
 8028440:	687b      	ldr	r3, [r7, #4]
 8028442:	605a      	str	r2, [r3, #4]
}
 8028444:	bf00      	nop
 8028446:	370c      	adds	r7, #12
 8028448:	46bd      	mov	sp, r7
 802844a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802844e:	4770      	bx	lr

08028450 <LL_C1_IPCC_ClearFlag_CHx>:
{
 8028450:	b480      	push	{r7}
 8028452:	b083      	sub	sp, #12
 8028454:	af00      	add	r7, sp, #0
 8028456:	6078      	str	r0, [r7, #4]
 8028458:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel);
 802845a:	687b      	ldr	r3, [r7, #4]
 802845c:	683a      	ldr	r2, [r7, #0]
 802845e:	609a      	str	r2, [r3, #8]
}
 8028460:	bf00      	nop
 8028462:	370c      	adds	r7, #12
 8028464:	46bd      	mov	sp, r7
 8028466:	f85d 7b04 	ldr.w	r7, [sp], #4
 802846a:	4770      	bx	lr

0802846c <LL_C1_IPCC_SetFlag_CHx>:
{
 802846c:	b480      	push	{r7}
 802846e:	b083      	sub	sp, #12
 8028470:	af00      	add	r7, sp, #0
 8028472:	6078      	str	r0, [r7, #4]
 8028474:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 8028476:	683b      	ldr	r3, [r7, #0]
 8028478:	041a      	lsls	r2, r3, #16
 802847a:	687b      	ldr	r3, [r7, #4]
 802847c:	609a      	str	r2, [r3, #8]
}
 802847e:	bf00      	nop
 8028480:	370c      	adds	r7, #12
 8028482:	46bd      	mov	sp, r7
 8028484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028488:	4770      	bx	lr

0802848a <LL_C1_IPCC_IsActiveFlag_CHx>:
{
 802848a:	b480      	push	{r7}
 802848c:	b083      	sub	sp, #12
 802848e:	af00      	add	r7, sp, #0
 8028490:	6078      	str	r0, [r7, #4]
 8028492:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 8028494:	687b      	ldr	r3, [r7, #4]
 8028496:	68da      	ldr	r2, [r3, #12]
 8028498:	683b      	ldr	r3, [r7, #0]
 802849a:	4013      	ands	r3, r2
 802849c:	683a      	ldr	r2, [r7, #0]
 802849e:	429a      	cmp	r2, r3
 80284a0:	d101      	bne.n	80284a6 <LL_C1_IPCC_IsActiveFlag_CHx+0x1c>
 80284a2:	2301      	movs	r3, #1
 80284a4:	e000      	b.n	80284a8 <LL_C1_IPCC_IsActiveFlag_CHx+0x1e>
 80284a6:	2300      	movs	r3, #0
}
 80284a8:	4618      	mov	r0, r3
 80284aa:	370c      	adds	r7, #12
 80284ac:	46bd      	mov	sp, r7
 80284ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80284b2:	4770      	bx	lr

080284b4 <LL_C2_IPCC_IsActiveFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C2_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
 80284b4:	b480      	push	{r7}
 80284b6:	b083      	sub	sp, #12
 80284b8:	af00      	add	r7, sp, #0
 80284ba:	6078      	str	r0, [r7, #4]
 80284bc:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 80284be:	687b      	ldr	r3, [r7, #4]
 80284c0:	69da      	ldr	r2, [r3, #28]
 80284c2:	683b      	ldr	r3, [r7, #0]
 80284c4:	4013      	ands	r3, r2
 80284c6:	683a      	ldr	r2, [r7, #0]
 80284c8:	429a      	cmp	r2, r3
 80284ca:	d101      	bne.n	80284d0 <LL_C2_IPCC_IsActiveFlag_CHx+0x1c>
 80284cc:	2301      	movs	r3, #1
 80284ce:	e000      	b.n	80284d2 <LL_C2_IPCC_IsActiveFlag_CHx+0x1e>
 80284d0:	2300      	movs	r3, #0
}
 80284d2:	4618      	mov	r0, r3
 80284d4:	370c      	adds	r7, #12
 80284d6:	46bd      	mov	sp, r7
 80284d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80284dc:	4770      	bx	lr
	...

080284e0 <HW_IPCC_Rx_Handler>:

/******************************************************************************
 * INTERRUPT HANDLER
 ******************************************************************************/
void HW_IPCC_Rx_Handler( void )
{
 80284e0:	b580      	push	{r7, lr}
 80284e2:	af00      	add	r7, sp, #0
  if (HW_IPCC_RX_PENDING( HW_IPCC_SYSTEM_EVENT_CHANNEL ))
 80284e4:	2102      	movs	r1, #2
 80284e6:	4819      	ldr	r0, [pc, #100]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 80284e8:	f7ff ffe4 	bl	80284b4 <LL_C2_IPCC_IsActiveFlag_CHx>
 80284ec:	4603      	mov	r3, r0
 80284ee:	2b00      	cmp	r3, #0
 80284f0:	d009      	beq.n	8028506 <HW_IPCC_Rx_Handler+0x26>
 80284f2:	4b16      	ldr	r3, [pc, #88]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 80284f4:	685b      	ldr	r3, [r3, #4]
 80284f6:	43db      	mvns	r3, r3
 80284f8:	f003 0302 	and.w	r3, r3, #2
 80284fc:	2b00      	cmp	r3, #0
 80284fe:	d002      	beq.n	8028506 <HW_IPCC_Rx_Handler+0x26>
  {
      HW_IPCC_SYS_EvtHandler();
 8028500:	f000 f8da 	bl	80286b8 <HW_IPCC_SYS_EvtHandler>
 8028504:	e01f      	b.n	8028546 <HW_IPCC_Rx_Handler+0x66>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL ))
  {
    HW_IPCC_ZIGBEE_StackM0RequestHandler();
  }
#endif /* ZIGBEE_WB */
  else if (HW_IPCC_RX_PENDING( HW_IPCC_BLE_EVENT_CHANNEL ))
 8028506:	2101      	movs	r1, #1
 8028508:	4810      	ldr	r0, [pc, #64]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 802850a:	f7ff ffd3 	bl	80284b4 <LL_C2_IPCC_IsActiveFlag_CHx>
 802850e:	4603      	mov	r3, r0
 8028510:	2b00      	cmp	r3, #0
 8028512:	d008      	beq.n	8028526 <HW_IPCC_Rx_Handler+0x46>
 8028514:	4b0d      	ldr	r3, [pc, #52]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 8028516:	685b      	ldr	r3, [r3, #4]
 8028518:	f003 0301 	and.w	r3, r3, #1
 802851c:	2b00      	cmp	r3, #0
 802851e:	d102      	bne.n	8028526 <HW_IPCC_Rx_Handler+0x46>
  {
    HW_IPCC_BLE_EvtHandler();
 8028520:	f000 f88e 	bl	8028640 <HW_IPCC_BLE_EvtHandler>
 8028524:	e00f      	b.n	8028546 <HW_IPCC_Rx_Handler+0x66>
  }
  else if (HW_IPCC_RX_PENDING( HW_IPCC_TRACES_CHANNEL ))
 8028526:	2108      	movs	r1, #8
 8028528:	4808      	ldr	r0, [pc, #32]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 802852a:	f7ff ffc3 	bl	80284b4 <LL_C2_IPCC_IsActiveFlag_CHx>
 802852e:	4603      	mov	r3, r0
 8028530:	2b00      	cmp	r3, #0
 8028532:	d009      	beq.n	8028548 <HW_IPCC_Rx_Handler+0x68>
 8028534:	4b05      	ldr	r3, [pc, #20]	; (802854c <HW_IPCC_Rx_Handler+0x6c>)
 8028536:	685b      	ldr	r3, [r3, #4]
 8028538:	43db      	mvns	r3, r3
 802853a:	f003 0308 	and.w	r3, r3, #8
 802853e:	2b00      	cmp	r3, #0
 8028540:	d002      	beq.n	8028548 <HW_IPCC_Rx_Handler+0x68>
  {
    HW_IPCC_TRACES_EvtHandler();
 8028542:	f000 f905 	bl	8028750 <HW_IPCC_TRACES_EvtHandler>
  }

  return;
 8028546:	bf00      	nop
 8028548:	bf00      	nop
}
 802854a:	bd80      	pop	{r7, pc}
 802854c:	58000c00 	.word	0x58000c00

08028550 <HW_IPCC_Tx_Handler>:

void HW_IPCC_Tx_Handler( void )
{
 8028550:	b580      	push	{r7, lr}
 8028552:	af00      	add	r7, sp, #0
  if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 8028554:	2102      	movs	r1, #2
 8028556:	481a      	ldr	r0, [pc, #104]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 8028558:	f7ff ff97 	bl	802848a <LL_C1_IPCC_IsActiveFlag_CHx>
 802855c:	4603      	mov	r3, r0
 802855e:	2b00      	cmp	r3, #0
 8028560:	d109      	bne.n	8028576 <HW_IPCC_Tx_Handler+0x26>
 8028562:	4b17      	ldr	r3, [pc, #92]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 8028564:	685b      	ldr	r3, [r3, #4]
 8028566:	43db      	mvns	r3, r3
 8028568:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802856c:	2b00      	cmp	r3, #0
 802856e:	d002      	beq.n	8028576 <HW_IPCC_Tx_Handler+0x26>
  {
    HW_IPCC_SYS_CmdEvtHandler();
 8028570:	f000 f896 	bl	80286a0 <HW_IPCC_SYS_CmdEvtHandler>
 8028574:	e020      	b.n	80285b8 <HW_IPCC_Tx_Handler+0x68>
  if (HW_IPCC_TX_PENDING( HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL ))
  {
      HW_IPCC_ZIGBEE_CmdEvtHandler();
  }
#endif /* ZIGBEE_WB */
  else if (HW_IPCC_TX_PENDING( HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ))
 8028576:	2108      	movs	r1, #8
 8028578:	4811      	ldr	r0, [pc, #68]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 802857a:	f7ff ff86 	bl	802848a <LL_C1_IPCC_IsActiveFlag_CHx>
 802857e:	4603      	mov	r3, r0
 8028580:	2b00      	cmp	r3, #0
 8028582:	d109      	bne.n	8028598 <HW_IPCC_Tx_Handler+0x48>
 8028584:	4b0e      	ldr	r3, [pc, #56]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 8028586:	685b      	ldr	r3, [r3, #4]
 8028588:	43db      	mvns	r3, r3
 802858a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802858e:	2b00      	cmp	r3, #0
 8028590:	d002      	beq.n	8028598 <HW_IPCC_Tx_Handler+0x48>
  {
    HW_IPCC_MM_FreeBufHandler();
 8028592:	f000 f8bf 	bl	8028714 <HW_IPCC_MM_FreeBufHandler>
 8028596:	e00f      	b.n	80285b8 <HW_IPCC_Tx_Handler+0x68>
  }
  else if (HW_IPCC_TX_PENDING( HW_IPCC_HCI_ACL_DATA_CHANNEL ))
 8028598:	2120      	movs	r1, #32
 802859a:	4809      	ldr	r0, [pc, #36]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 802859c:	f7ff ff75 	bl	802848a <LL_C1_IPCC_IsActiveFlag_CHx>
 80285a0:	4603      	mov	r3, r0
 80285a2:	2b00      	cmp	r3, #0
 80285a4:	d109      	bne.n	80285ba <HW_IPCC_Tx_Handler+0x6a>
 80285a6:	4b06      	ldr	r3, [pc, #24]	; (80285c0 <HW_IPCC_Tx_Handler+0x70>)
 80285a8:	685b      	ldr	r3, [r3, #4]
 80285aa:	43db      	mvns	r3, r3
 80285ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80285b0:	2b00      	cmp	r3, #0
 80285b2:	d002      	beq.n	80285ba <HW_IPCC_Tx_Handler+0x6a>
  {
    HW_IPCC_BLE_AclDataEvtHandler();
 80285b4:	f000 f850 	bl	8028658 <HW_IPCC_BLE_AclDataEvtHandler>
  }

  return;
 80285b8:	bf00      	nop
 80285ba:	bf00      	nop
}
 80285bc:	bd80      	pop	{r7, pc}
 80285be:	bf00      	nop
 80285c0:	58000c00 	.word	0x58000c00

080285c4 <HW_IPCC_Enable>:
/******************************************************************************
 * GENERAL
 ******************************************************************************/
void HW_IPCC_Enable( void )
{
 80285c4:	b580      	push	{r7, lr}
 80285c6:	af00      	add	r7, sp, #0
  /**
  * Such as IPCC IP available to the CPU2, it is required to keep the IPCC clock running
    when FUS is running on CPU2 and CPU1 enters deep sleep mode
  */
  LL_C2_AHB3_GRP1_EnableClock(LL_C2_AHB3_GRP1_PERIPH_IPCC);
 80285c8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80285cc:	f7ff fecd 	bl	802836a <LL_C2_AHB3_GRP1_EnableClock>

   /**
   * When the device is out of standby, it is required to use the EXTI mechanism to wakeup CPU2
   */
  LL_C2_EXTI_EnableEvent_32_63( LL_EXTI_LINE_41 );
 80285d0:	f44f 7000 	mov.w	r0, #512	; 0x200
 80285d4:	f7ff fe8a 	bl	80282ec <LL_C2_EXTI_EnableEvent_32_63>
  LL_EXTI_EnableRisingTrig_32_63( LL_EXTI_LINE_41 );
 80285d8:	f44f 7000 	mov.w	r0, #512	; 0x200
 80285dc:	f7ff fe9a 	bl	8028314 <LL_EXTI_EnableRisingTrig_32_63>
   * When the CPU2 receives that command, it waits for its event input to be set to restart the CPU2 firmware.
   * This is required because once C2BOOT has been set once, a clear/set on C2BOOT has no effect.
   * When SHCI_C2_Reinit( ) is not called, generating an event to the CPU2 does not have any effect
   * So, by default, the application shall both set the event flag and set the C2BOOT bit.
   */
  __SEV( );       /* Set the internal event flag and send an event to the CPU2 */
 80285e0:	bf40      	sev
  __WFE( );       /* Clear the internal event flag */
 80285e2:	bf20      	wfe
  LL_PWR_EnableBootC2( );
 80285e4:	f7ff fe72 	bl	80282cc <LL_PWR_EnableBootC2>

  return;
 80285e8:	bf00      	nop
}
 80285ea:	bd80      	pop	{r7, pc}

080285ec <HW_IPCC_Init>:

void HW_IPCC_Init( void )
{
 80285ec:	b580      	push	{r7, lr}
 80285ee:	af00      	add	r7, sp, #0
  LL_AHB3_GRP1_EnableClock( LL_AHB3_GRP1_PERIPH_IPCC );
 80285f0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80285f4:	f7ff fea0 	bl	8028338 <LL_AHB3_GRP1_EnableClock>

  LL_C1_IPCC_EnableIT_RXO( IPCC );
 80285f8:	4806      	ldr	r0, [pc, #24]	; (8028614 <HW_IPCC_Init+0x28>)
 80285fa:	f7ff fee2 	bl	80283c2 <LL_C1_IPCC_EnableIT_RXO>
  LL_C1_IPCC_EnableIT_TXF( IPCC );
 80285fe:	4805      	ldr	r0, [pc, #20]	; (8028614 <HW_IPCC_Init+0x28>)
 8028600:	f7ff fecf 	bl	80283a2 <LL_C1_IPCC_EnableIT_TXF>

  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 8028604:	202c      	movs	r0, #44	; 0x2c
 8028606:	f7e5 fa33 	bl	800da70 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 802860a:	202d      	movs	r0, #45	; 0x2d
 802860c:	f7e5 fa30 	bl	800da70 <HAL_NVIC_EnableIRQ>

  return;
 8028610:	bf00      	nop
}
 8028612:	bd80      	pop	{r7, pc}
 8028614:	58000c00 	.word	0x58000c00

08028618 <HW_IPCC_BLE_Init>:

/******************************************************************************
 * BLE
 ******************************************************************************/
void HW_IPCC_BLE_Init( void )
{
 8028618:	b580      	push	{r7, lr}
 802861a:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_BLE_EVENT_CHANNEL );
 802861c:	2101      	movs	r1, #1
 802861e:	4802      	ldr	r0, [pc, #8]	; (8028628 <HW_IPCC_BLE_Init+0x10>)
 8028620:	f7ff ff04 	bl	802842c <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8028624:	bf00      	nop
}
 8028626:	bd80      	pop	{r7, pc}
 8028628:	58000c00 	.word	0x58000c00

0802862c <HW_IPCC_BLE_SendCmd>:

void HW_IPCC_BLE_SendCmd( void )
{
 802862c:	b580      	push	{r7, lr}
 802862e:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_BLE_CMD_CHANNEL );
 8028630:	2101      	movs	r1, #1
 8028632:	4802      	ldr	r0, [pc, #8]	; (802863c <HW_IPCC_BLE_SendCmd+0x10>)
 8028634:	f7ff ff1a 	bl	802846c <LL_C1_IPCC_SetFlag_CHx>

  return;
 8028638:	bf00      	nop
}
 802863a:	bd80      	pop	{r7, pc}
 802863c:	58000c00 	.word	0x58000c00

08028640 <HW_IPCC_BLE_EvtHandler>:

static void HW_IPCC_BLE_EvtHandler( void )
{
 8028640:	b580      	push	{r7, lr}
 8028642:	af00      	add	r7, sp, #0
  HW_IPCC_BLE_RxEvtNot();
 8028644:	f7f3 fa38 	bl	801bab8 <HW_IPCC_BLE_RxEvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_BLE_EVENT_CHANNEL );
 8028648:	2101      	movs	r1, #1
 802864a:	4802      	ldr	r0, [pc, #8]	; (8028654 <HW_IPCC_BLE_EvtHandler+0x14>)
 802864c:	f7ff ff00 	bl	8028450 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8028650:	bf00      	nop
}
 8028652:	bd80      	pop	{r7, pc}
 8028654:	58000c00 	.word	0x58000c00

08028658 <HW_IPCC_BLE_AclDataEvtHandler>:

  return;
}

static void HW_IPCC_BLE_AclDataEvtHandler( void )
{
 8028658:	b580      	push	{r7, lr}
 802865a:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_HCI_ACL_DATA_CHANNEL );
 802865c:	2120      	movs	r1, #32
 802865e:	4803      	ldr	r0, [pc, #12]	; (802866c <HW_IPCC_BLE_AclDataEvtHandler+0x14>)
 8028660:	f7ff fed2 	bl	8028408 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_BLE_AclDataAckNot();
 8028664:	f7f3 fa58 	bl	801bb18 <HW_IPCC_BLE_AclDataAckNot>

  return;
 8028668:	bf00      	nop
}
 802866a:	bd80      	pop	{r7, pc}
 802866c:	58000c00 	.word	0x58000c00

08028670 <HW_IPCC_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
void HW_IPCC_SYS_Init( void )
{
 8028670:	b580      	push	{r7, lr}
 8028672:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 8028674:	2102      	movs	r1, #2
 8028676:	4802      	ldr	r0, [pc, #8]	; (8028680 <HW_IPCC_SYS_Init+0x10>)
 8028678:	f7ff fed8 	bl	802842c <LL_C1_IPCC_EnableReceiveChannel>

  return;
 802867c:	bf00      	nop
}
 802867e:	bd80      	pop	{r7, pc}
 8028680:	58000c00 	.word	0x58000c00

08028684 <HW_IPCC_SYS_SendCmd>:

void HW_IPCC_SYS_SendCmd( void )
{
 8028684:	b580      	push	{r7, lr}
 8028686:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 8028688:	2102      	movs	r1, #2
 802868a:	4804      	ldr	r0, [pc, #16]	; (802869c <HW_IPCC_SYS_SendCmd+0x18>)
 802868c:	f7ff feee 	bl	802846c <LL_C1_IPCC_SetFlag_CHx>
  LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 8028690:	2102      	movs	r1, #2
 8028692:	4802      	ldr	r0, [pc, #8]	; (802869c <HW_IPCC_SYS_SendCmd+0x18>)
 8028694:	f7ff fea5 	bl	80283e2 <LL_C1_IPCC_EnableTransmitChannel>

  return;
 8028698:	bf00      	nop
}
 802869a:	bd80      	pop	{r7, pc}
 802869c:	58000c00 	.word	0x58000c00

080286a0 <HW_IPCC_SYS_CmdEvtHandler>:

static void HW_IPCC_SYS_CmdEvtHandler( void )
{
 80286a0:	b580      	push	{r7, lr}
 80286a2:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 80286a4:	2102      	movs	r1, #2
 80286a6:	4803      	ldr	r0, [pc, #12]	; (80286b4 <HW_IPCC_SYS_CmdEvtHandler+0x14>)
 80286a8:	f7ff feae 	bl	8028408 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_SYS_CmdEvtNot();
 80286ac:	f7f3 fa84 	bl	801bbb8 <HW_IPCC_SYS_CmdEvtNot>

  return;
 80286b0:	bf00      	nop
}
 80286b2:	bd80      	pop	{r7, pc}
 80286b4:	58000c00 	.word	0x58000c00

080286b8 <HW_IPCC_SYS_EvtHandler>:

static void HW_IPCC_SYS_EvtHandler( void )
{
 80286b8:	b580      	push	{r7, lr}
 80286ba:	af00      	add	r7, sp, #0
  HW_IPCC_SYS_EvtNot();
 80286bc:	f7f3 fa92 	bl	801bbe4 <HW_IPCC_SYS_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 80286c0:	2102      	movs	r1, #2
 80286c2:	4802      	ldr	r0, [pc, #8]	; (80286cc <HW_IPCC_SYS_EvtHandler+0x14>)
 80286c4:	f7ff fec4 	bl	8028450 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 80286c8:	bf00      	nop
}
 80286ca:	bd80      	pop	{r7, pc}
 80286cc:	58000c00 	.word	0x58000c00

080286d0 <HW_IPCC_MM_SendFreeBuf>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void HW_IPCC_MM_SendFreeBuf( void (*cb)( void ) )
{
 80286d0:	b580      	push	{r7, lr}
 80286d2:	b082      	sub	sp, #8
 80286d4:	af00      	add	r7, sp, #0
 80286d6:	6078      	str	r0, [r7, #4]
  if ( LL_C1_IPCC_IsActiveFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ) )
 80286d8:	2108      	movs	r1, #8
 80286da:	480c      	ldr	r0, [pc, #48]	; (802870c <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80286dc:	f7ff fed5 	bl	802848a <LL_C1_IPCC_IsActiveFlag_CHx>
 80286e0:	4603      	mov	r3, r0
 80286e2:	2b00      	cmp	r3, #0
 80286e4:	d007      	beq.n	80286f6 <HW_IPCC_MM_SendFreeBuf+0x26>
  {
    FreeBufCb = cb;
 80286e6:	4a0a      	ldr	r2, [pc, #40]	; (8028710 <HW_IPCC_MM_SendFreeBuf+0x40>)
 80286e8:	687b      	ldr	r3, [r7, #4]
 80286ea:	6013      	str	r3, [r2, #0]
    LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 80286ec:	2108      	movs	r1, #8
 80286ee:	4807      	ldr	r0, [pc, #28]	; (802870c <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80286f0:	f7ff fe77 	bl	80283e2 <LL_C1_IPCC_EnableTransmitChannel>
    cb();

    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
  }

  return;
 80286f4:	e006      	b.n	8028704 <HW_IPCC_MM_SendFreeBuf+0x34>
    cb();
 80286f6:	687b      	ldr	r3, [r7, #4]
 80286f8:	4798      	blx	r3
    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 80286fa:	2108      	movs	r1, #8
 80286fc:	4803      	ldr	r0, [pc, #12]	; (802870c <HW_IPCC_MM_SendFreeBuf+0x3c>)
 80286fe:	f7ff feb5 	bl	802846c <LL_C1_IPCC_SetFlag_CHx>
  return;
 8028702:	bf00      	nop
}
 8028704:	3708      	adds	r7, #8
 8028706:	46bd      	mov	sp, r7
 8028708:	bd80      	pop	{r7, pc}
 802870a:	bf00      	nop
 802870c:	58000c00 	.word	0x58000c00
 8028710:	20010c04 	.word	0x20010c04

08028714 <HW_IPCC_MM_FreeBufHandler>:

static void HW_IPCC_MM_FreeBufHandler( void )
{
 8028714:	b580      	push	{r7, lr}
 8028716:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8028718:	2108      	movs	r1, #8
 802871a:	4806      	ldr	r0, [pc, #24]	; (8028734 <HW_IPCC_MM_FreeBufHandler+0x20>)
 802871c:	f7ff fe74 	bl	8028408 <LL_C1_IPCC_DisableTransmitChannel>

  FreeBufCb();
 8028720:	4b05      	ldr	r3, [pc, #20]	; (8028738 <HW_IPCC_MM_FreeBufHandler+0x24>)
 8028722:	681b      	ldr	r3, [r3, #0]
 8028724:	4798      	blx	r3

  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8028726:	2108      	movs	r1, #8
 8028728:	4802      	ldr	r0, [pc, #8]	; (8028734 <HW_IPCC_MM_FreeBufHandler+0x20>)
 802872a:	f7ff fe9f 	bl	802846c <LL_C1_IPCC_SetFlag_CHx>

  return;
 802872e:	bf00      	nop
}
 8028730:	bd80      	pop	{r7, pc}
 8028732:	bf00      	nop
 8028734:	58000c00 	.word	0x58000c00
 8028738:	20010c04 	.word	0x20010c04

0802873c <HW_IPCC_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void HW_IPCC_TRACES_Init( void )
{
 802873c:	b580      	push	{r7, lr}
 802873e:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_TRACES_CHANNEL );
 8028740:	2108      	movs	r1, #8
 8028742:	4802      	ldr	r0, [pc, #8]	; (802874c <HW_IPCC_TRACES_Init+0x10>)
 8028744:	f7ff fe72 	bl	802842c <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8028748:	bf00      	nop
}
 802874a:	bd80      	pop	{r7, pc}
 802874c:	58000c00 	.word	0x58000c00

08028750 <HW_IPCC_TRACES_EvtHandler>:

static void HW_IPCC_TRACES_EvtHandler( void )
{
 8028750:	b580      	push	{r7, lr}
 8028752:	af00      	add	r7, sp, #0
  HW_IPCC_TRACES_EvtNot();
 8028754:	f7f3 faee 	bl	801bd34 <HW_IPCC_TRACES_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_TRACES_CHANNEL );
 8028758:	2108      	movs	r1, #8
 802875a:	4802      	ldr	r0, [pc, #8]	; (8028764 <HW_IPCC_TRACES_EvtHandler+0x14>)
 802875c:	f7ff fe78 	bl	8028450 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8028760:	bf00      	nop
}
 8028762:	bd80      	pop	{r7, pc}
 8028764:	58000c00 	.word	0x58000c00

08028768 <MX_USB_Device_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_Device_Init(void)
{
 8028768:	b580      	push	{r7, lr}
 802876a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_Device_Init_PreTreatment */

  /* USER CODE END USB_Device_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &CDC_Desc, DEVICE_FS) != USBD_OK) {
 802876c:	2200      	movs	r2, #0
 802876e:	4912      	ldr	r1, [pc, #72]	; (80287b8 <MX_USB_Device_Init+0x50>)
 8028770:	4812      	ldr	r0, [pc, #72]	; (80287bc <MX_USB_Device_Init+0x54>)
 8028772:	f7f0 f925 	bl	80189c0 <USBD_Init>
 8028776:	4603      	mov	r3, r0
 8028778:	2b00      	cmp	r3, #0
 802877a:	d001      	beq.n	8028780 <MX_USB_Device_Init+0x18>
    Error_Handler();
 802877c:	f7e2 fbb6 	bl	800aeec <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK) {
 8028780:	490f      	ldr	r1, [pc, #60]	; (80287c0 <MX_USB_Device_Init+0x58>)
 8028782:	480e      	ldr	r0, [pc, #56]	; (80287bc <MX_USB_Device_Init+0x54>)
 8028784:	f7f0 f94c 	bl	8018a20 <USBD_RegisterClass>
 8028788:	4603      	mov	r3, r0
 802878a:	2b00      	cmp	r3, #0
 802878c:	d001      	beq.n	8028792 <MX_USB_Device_Init+0x2a>
    Error_Handler();
 802878e:	f7e2 fbad 	bl	800aeec <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK) {
 8028792:	490c      	ldr	r1, [pc, #48]	; (80287c4 <MX_USB_Device_Init+0x5c>)
 8028794:	4809      	ldr	r0, [pc, #36]	; (80287bc <MX_USB_Device_Init+0x54>)
 8028796:	f7f0 f89d 	bl	80188d4 <USBD_CDC_RegisterInterface>
 802879a:	4603      	mov	r3, r0
 802879c:	2b00      	cmp	r3, #0
 802879e:	d001      	beq.n	80287a4 <MX_USB_Device_Init+0x3c>
    Error_Handler();
 80287a0:	f7e2 fba4 	bl	800aeec <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK) {
 80287a4:	4805      	ldr	r0, [pc, #20]	; (80287bc <MX_USB_Device_Init+0x54>)
 80287a6:	f7f0 f962 	bl	8018a6e <USBD_Start>
 80287aa:	4603      	mov	r3, r0
 80287ac:	2b00      	cmp	r3, #0
 80287ae:	d001      	beq.n	80287b4 <MX_USB_Device_Init+0x4c>
    Error_Handler();
 80287b0:	f7e2 fb9c 	bl	800aeec <Error_Handler>
  }
  /* USER CODE BEGIN USB_Device_Init_PostTreatment */

  /* USER CODE END USB_Device_Init_PostTreatment */
}
 80287b4:	bf00      	nop
 80287b6:	bd80      	pop	{r7, pc}
 80287b8:	20000158 	.word	0x20000158
 80287bc:	200123d8 	.word	0x200123d8
 80287c0:	20000028 	.word	0x20000028
 80287c4:	20000144 	.word	0x20000144

080287c8 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 80287c8:	b580      	push	{r7, lr}
 80287ca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 80287cc:	2200      	movs	r2, #0
 80287ce:	4905      	ldr	r1, [pc, #20]	; (80287e4 <CDC_Init_FS+0x1c>)
 80287d0:	4805      	ldr	r0, [pc, #20]	; (80287e8 <CDC_Init_FS+0x20>)
 80287d2:	f7f0 f894 	bl	80188fe <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 80287d6:	4905      	ldr	r1, [pc, #20]	; (80287ec <CDC_Init_FS+0x24>)
 80287d8:	4803      	ldr	r0, [pc, #12]	; (80287e8 <CDC_Init_FS+0x20>)
 80287da:	f7f0 f8ae 	bl	801893a <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 80287de:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 80287e0:	4618      	mov	r0, r3
 80287e2:	bd80      	pop	{r7, pc}
 80287e4:	20012ea8 	.word	0x20012ea8
 80287e8:	200123d8 	.word	0x200123d8
 80287ec:	200126a8 	.word	0x200126a8

080287f0 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 80287f0:	b480      	push	{r7}
 80287f2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 80287f4:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 80287f6:	4618      	mov	r0, r3
 80287f8:	46bd      	mov	sp, r7
 80287fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80287fe:	4770      	bx	lr

08028800 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 8028800:	b480      	push	{r7}
 8028802:	b083      	sub	sp, #12
 8028804:	af00      	add	r7, sp, #0
 8028806:	4603      	mov	r3, r0
 8028808:	6039      	str	r1, [r7, #0]
 802880a:	71fb      	strb	r3, [r7, #7]
 802880c:	4613      	mov	r3, r2
 802880e:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 8028810:	79fb      	ldrb	r3, [r7, #7]
 8028812:	2b23      	cmp	r3, #35	; 0x23
 8028814:	d84a      	bhi.n	80288ac <CDC_Control_FS+0xac>
 8028816:	a201      	add	r2, pc, #4	; (adr r2, 802881c <CDC_Control_FS+0x1c>)
 8028818:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802881c:	080288ad 	.word	0x080288ad
 8028820:	080288ad 	.word	0x080288ad
 8028824:	080288ad 	.word	0x080288ad
 8028828:	080288ad 	.word	0x080288ad
 802882c:	080288ad 	.word	0x080288ad
 8028830:	080288ad 	.word	0x080288ad
 8028834:	080288ad 	.word	0x080288ad
 8028838:	080288ad 	.word	0x080288ad
 802883c:	080288ad 	.word	0x080288ad
 8028840:	080288ad 	.word	0x080288ad
 8028844:	080288ad 	.word	0x080288ad
 8028848:	080288ad 	.word	0x080288ad
 802884c:	080288ad 	.word	0x080288ad
 8028850:	080288ad 	.word	0x080288ad
 8028854:	080288ad 	.word	0x080288ad
 8028858:	080288ad 	.word	0x080288ad
 802885c:	080288ad 	.word	0x080288ad
 8028860:	080288ad 	.word	0x080288ad
 8028864:	080288ad 	.word	0x080288ad
 8028868:	080288ad 	.word	0x080288ad
 802886c:	080288ad 	.word	0x080288ad
 8028870:	080288ad 	.word	0x080288ad
 8028874:	080288ad 	.word	0x080288ad
 8028878:	080288ad 	.word	0x080288ad
 802887c:	080288ad 	.word	0x080288ad
 8028880:	080288ad 	.word	0x080288ad
 8028884:	080288ad 	.word	0x080288ad
 8028888:	080288ad 	.word	0x080288ad
 802888c:	080288ad 	.word	0x080288ad
 8028890:	080288ad 	.word	0x080288ad
 8028894:	080288ad 	.word	0x080288ad
 8028898:	080288ad 	.word	0x080288ad
 802889c:	080288ad 	.word	0x080288ad
 80288a0:	080288ad 	.word	0x080288ad
 80288a4:	080288ad 	.word	0x080288ad
 80288a8:	080288ad 	.word	0x080288ad
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 80288ac:	bf00      	nop
  }

  return (USBD_OK);
 80288ae:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 80288b0:	4618      	mov	r0, r3
 80288b2:	370c      	adds	r7, #12
 80288b4:	46bd      	mov	sp, r7
 80288b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80288ba:	4770      	bx	lr

080288bc <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 80288bc:	b580      	push	{r7, lr}
 80288be:	b082      	sub	sp, #8
 80288c0:	af00      	add	r7, sp, #0
 80288c2:	6078      	str	r0, [r7, #4]
 80288c4:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 80288c6:	6879      	ldr	r1, [r7, #4]
 80288c8:	4805      	ldr	r0, [pc, #20]	; (80288e0 <CDC_Receive_FS+0x24>)
 80288ca:	f7f0 f836 	bl	801893a <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 80288ce:	4804      	ldr	r0, [pc, #16]	; (80288e0 <CDC_Receive_FS+0x24>)
 80288d0:	f7f0 f84c 	bl	801896c <USBD_CDC_ReceivePacket>
  return (USBD_OK);
 80288d4:	2300      	movs	r3, #0
  /* USER CODE END 6 */
}
 80288d6:	4618      	mov	r0, r3
 80288d8:	3708      	adds	r7, #8
 80288da:	46bd      	mov	sp, r7
 80288dc:	bd80      	pop	{r7, pc}
 80288de:	bf00      	nop
 80288e0:	200123d8 	.word	0x200123d8

080288e4 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 80288e4:	b480      	push	{r7}
 80288e6:	b087      	sub	sp, #28
 80288e8:	af00      	add	r7, sp, #0
 80288ea:	60f8      	str	r0, [r7, #12]
 80288ec:	60b9      	str	r1, [r7, #8]
 80288ee:	4613      	mov	r3, r2
 80288f0:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 80288f2:	2300      	movs	r3, #0
 80288f4:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 80288f6:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 80288fa:	4618      	mov	r0, r3
 80288fc:	371c      	adds	r7, #28
 80288fe:	46bd      	mov	sp, r7
 8028900:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028904:	4770      	bx	lr
	...

08028908 <USBD_CDC_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8028908:	b480      	push	{r7}
 802890a:	b083      	sub	sp, #12
 802890c:	af00      	add	r7, sp, #0
 802890e:	4603      	mov	r3, r0
 8028910:	6039      	str	r1, [r7, #0]
 8028912:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_CDC_DeviceDesc);
 8028914:	683b      	ldr	r3, [r7, #0]
 8028916:	2212      	movs	r2, #18
 8028918:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_DeviceDesc;
 802891a:	4b03      	ldr	r3, [pc, #12]	; (8028928 <USBD_CDC_DeviceDescriptor+0x20>)
}
 802891c:	4618      	mov	r0, r3
 802891e:	370c      	adds	r7, #12
 8028920:	46bd      	mov	sp, r7
 8028922:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028926:	4770      	bx	lr
 8028928:	20000178 	.word	0x20000178

0802892c <USBD_CDC_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 802892c:	b480      	push	{r7}
 802892e:	b083      	sub	sp, #12
 8028930:	af00      	add	r7, sp, #0
 8028932:	4603      	mov	r3, r0
 8028934:	6039      	str	r1, [r7, #0]
 8028936:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8028938:	683b      	ldr	r3, [r7, #0]
 802893a:	2204      	movs	r2, #4
 802893c:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 802893e:	4b03      	ldr	r3, [pc, #12]	; (802894c <USBD_CDC_LangIDStrDescriptor+0x20>)
}
 8028940:	4618      	mov	r0, r3
 8028942:	370c      	adds	r7, #12
 8028944:	46bd      	mov	sp, r7
 8028946:	f85d 7b04 	ldr.w	r7, [sp], #4
 802894a:	4770      	bx	lr
 802894c:	2000018c 	.word	0x2000018c

08028950 <USBD_CDC_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8028950:	b580      	push	{r7, lr}
 8028952:	b082      	sub	sp, #8
 8028954:	af00      	add	r7, sp, #0
 8028956:	4603      	mov	r3, r0
 8028958:	6039      	str	r1, [r7, #0]
 802895a:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 802895c:	79fb      	ldrb	r3, [r7, #7]
 802895e:	2b00      	cmp	r3, #0
 8028960:	d105      	bne.n	802896e <USBD_CDC_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING, USBD_StrDesc, length);
 8028962:	683a      	ldr	r2, [r7, #0]
 8028964:	4907      	ldr	r1, [pc, #28]	; (8028984 <USBD_CDC_ProductStrDescriptor+0x34>)
 8028966:	4808      	ldr	r0, [pc, #32]	; (8028988 <USBD_CDC_ProductStrDescriptor+0x38>)
 8028968:	f7f1 f869 	bl	8019a3e <USBD_GetString>
 802896c:	e004      	b.n	8028978 <USBD_CDC_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING, USBD_StrDesc, length);
 802896e:	683a      	ldr	r2, [r7, #0]
 8028970:	4904      	ldr	r1, [pc, #16]	; (8028984 <USBD_CDC_ProductStrDescriptor+0x34>)
 8028972:	4805      	ldr	r0, [pc, #20]	; (8028988 <USBD_CDC_ProductStrDescriptor+0x38>)
 8028974:	f7f1 f863 	bl	8019a3e <USBD_GetString>
  }
  return USBD_StrDesc;
 8028978:	4b02      	ldr	r3, [pc, #8]	; (8028984 <USBD_CDC_ProductStrDescriptor+0x34>)
}
 802897a:	4618      	mov	r0, r3
 802897c:	3708      	adds	r7, #8
 802897e:	46bd      	mov	sp, r7
 8028980:	bd80      	pop	{r7, pc}
 8028982:	bf00      	nop
 8028984:	200136a8 	.word	0x200136a8
 8028988:	0802c6d4 	.word	0x0802c6d4

0802898c <USBD_CDC_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 802898c:	b580      	push	{r7, lr}
 802898e:	b082      	sub	sp, #8
 8028990:	af00      	add	r7, sp, #0
 8028992:	4603      	mov	r3, r0
 8028994:	6039      	str	r1, [r7, #0]
 8028996:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8028998:	683a      	ldr	r2, [r7, #0]
 802899a:	4904      	ldr	r1, [pc, #16]	; (80289ac <USBD_CDC_ManufacturerStrDescriptor+0x20>)
 802899c:	4804      	ldr	r0, [pc, #16]	; (80289b0 <USBD_CDC_ManufacturerStrDescriptor+0x24>)
 802899e:	f7f1 f84e 	bl	8019a3e <USBD_GetString>
  return USBD_StrDesc;
 80289a2:	4b02      	ldr	r3, [pc, #8]	; (80289ac <USBD_CDC_ManufacturerStrDescriptor+0x20>)
}
 80289a4:	4618      	mov	r0, r3
 80289a6:	3708      	adds	r7, #8
 80289a8:	46bd      	mov	sp, r7
 80289aa:	bd80      	pop	{r7, pc}
 80289ac:	200136a8 	.word	0x200136a8
 80289b0:	0802c6ec 	.word	0x0802c6ec

080289b4 <USBD_CDC_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80289b4:	b580      	push	{r7, lr}
 80289b6:	b082      	sub	sp, #8
 80289b8:	af00      	add	r7, sp, #0
 80289ba:	4603      	mov	r3, r0
 80289bc:	6039      	str	r1, [r7, #0]
 80289be:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 80289c0:	683b      	ldr	r3, [r7, #0]
 80289c2:	221a      	movs	r2, #26
 80289c4:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 80289c6:	f000 f843 	bl	8028a50 <Get_SerialNum>

  /* USER CODE BEGIN USBD_CDC_SerialStrDescriptor */

  /* USER CODE END USBD_CDC_SerialStrDescriptor */

  return (uint8_t *) USBD_StringSerial;
 80289ca:	4b02      	ldr	r3, [pc, #8]	; (80289d4 <USBD_CDC_SerialStrDescriptor+0x20>)
}
 80289cc:	4618      	mov	r0, r3
 80289ce:	3708      	adds	r7, #8
 80289d0:	46bd      	mov	sp, r7
 80289d2:	bd80      	pop	{r7, pc}
 80289d4:	20000190 	.word	0x20000190

080289d8 <USBD_CDC_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80289d8:	b580      	push	{r7, lr}
 80289da:	b082      	sub	sp, #8
 80289dc:	af00      	add	r7, sp, #0
 80289de:	4603      	mov	r3, r0
 80289e0:	6039      	str	r1, [r7, #0]
 80289e2:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 80289e4:	79fb      	ldrb	r3, [r7, #7]
 80289e6:	2b00      	cmp	r3, #0
 80289e8:	d105      	bne.n	80289f6 <USBD_CDC_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING, USBD_StrDesc, length);
 80289ea:	683a      	ldr	r2, [r7, #0]
 80289ec:	4907      	ldr	r1, [pc, #28]	; (8028a0c <USBD_CDC_ConfigStrDescriptor+0x34>)
 80289ee:	4808      	ldr	r0, [pc, #32]	; (8028a10 <USBD_CDC_ConfigStrDescriptor+0x38>)
 80289f0:	f7f1 f825 	bl	8019a3e <USBD_GetString>
 80289f4:	e004      	b.n	8028a00 <USBD_CDC_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING, USBD_StrDesc, length);
 80289f6:	683a      	ldr	r2, [r7, #0]
 80289f8:	4904      	ldr	r1, [pc, #16]	; (8028a0c <USBD_CDC_ConfigStrDescriptor+0x34>)
 80289fa:	4805      	ldr	r0, [pc, #20]	; (8028a10 <USBD_CDC_ConfigStrDescriptor+0x38>)
 80289fc:	f7f1 f81f 	bl	8019a3e <USBD_GetString>
  }
  return USBD_StrDesc;
 8028a00:	4b02      	ldr	r3, [pc, #8]	; (8028a0c <USBD_CDC_ConfigStrDescriptor+0x34>)
}
 8028a02:	4618      	mov	r0, r3
 8028a04:	3708      	adds	r7, #8
 8028a06:	46bd      	mov	sp, r7
 8028a08:	bd80      	pop	{r7, pc}
 8028a0a:	bf00      	nop
 8028a0c:	200136a8 	.word	0x200136a8
 8028a10:	0802c700 	.word	0x0802c700

08028a14 <USBD_CDC_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_CDC_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8028a14:	b580      	push	{r7, lr}
 8028a16:	b082      	sub	sp, #8
 8028a18:	af00      	add	r7, sp, #0
 8028a1a:	4603      	mov	r3, r0
 8028a1c:	6039      	str	r1, [r7, #0]
 8028a1e:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8028a20:	79fb      	ldrb	r3, [r7, #7]
 8028a22:	2b00      	cmp	r3, #0
 8028a24:	d105      	bne.n	8028a32 <USBD_CDC_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING, USBD_StrDesc, length);
 8028a26:	683a      	ldr	r2, [r7, #0]
 8028a28:	4907      	ldr	r1, [pc, #28]	; (8028a48 <USBD_CDC_InterfaceStrDescriptor+0x34>)
 8028a2a:	4808      	ldr	r0, [pc, #32]	; (8028a4c <USBD_CDC_InterfaceStrDescriptor+0x38>)
 8028a2c:	f7f1 f807 	bl	8019a3e <USBD_GetString>
 8028a30:	e004      	b.n	8028a3c <USBD_CDC_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING, USBD_StrDesc, length);
 8028a32:	683a      	ldr	r2, [r7, #0]
 8028a34:	4904      	ldr	r1, [pc, #16]	; (8028a48 <USBD_CDC_InterfaceStrDescriptor+0x34>)
 8028a36:	4805      	ldr	r0, [pc, #20]	; (8028a4c <USBD_CDC_InterfaceStrDescriptor+0x38>)
 8028a38:	f7f1 f801 	bl	8019a3e <USBD_GetString>
  }
  return USBD_StrDesc;
 8028a3c:	4b02      	ldr	r3, [pc, #8]	; (8028a48 <USBD_CDC_InterfaceStrDescriptor+0x34>)
}
 8028a3e:	4618      	mov	r0, r3
 8028a40:	3708      	adds	r7, #8
 8028a42:	46bd      	mov	sp, r7
 8028a44:	bd80      	pop	{r7, pc}
 8028a46:	bf00      	nop
 8028a48:	200136a8 	.word	0x200136a8
 8028a4c:	0802c70c 	.word	0x0802c70c

08028a50 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 8028a50:	b580      	push	{r7, lr}
 8028a52:	b084      	sub	sp, #16
 8028a54:	af00      	add	r7, sp, #0
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8028a56:	4b0f      	ldr	r3, [pc, #60]	; (8028a94 <Get_SerialNum+0x44>)
 8028a58:	681b      	ldr	r3, [r3, #0]
 8028a5a:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8028a5c:	4b0e      	ldr	r3, [pc, #56]	; (8028a98 <Get_SerialNum+0x48>)
 8028a5e:	681b      	ldr	r3, [r3, #0]
 8028a60:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8028a62:	4b0e      	ldr	r3, [pc, #56]	; (8028a9c <Get_SerialNum+0x4c>)
 8028a64:	681b      	ldr	r3, [r3, #0]
 8028a66:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 8028a68:	68fa      	ldr	r2, [r7, #12]
 8028a6a:	687b      	ldr	r3, [r7, #4]
 8028a6c:	4413      	add	r3, r2
 8028a6e:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 8028a70:	68fb      	ldr	r3, [r7, #12]
 8028a72:	2b00      	cmp	r3, #0
 8028a74:	d009      	beq.n	8028a8a <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 8028a76:	2208      	movs	r2, #8
 8028a78:	4909      	ldr	r1, [pc, #36]	; (8028aa0 <Get_SerialNum+0x50>)
 8028a7a:	68f8      	ldr	r0, [r7, #12]
 8028a7c:	f000 f814 	bl	8028aa8 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 8028a80:	2204      	movs	r2, #4
 8028a82:	4908      	ldr	r1, [pc, #32]	; (8028aa4 <Get_SerialNum+0x54>)
 8028a84:	68b8      	ldr	r0, [r7, #8]
 8028a86:	f000 f80f 	bl	8028aa8 <IntToUnicode>
  }
}
 8028a8a:	bf00      	nop
 8028a8c:	3710      	adds	r7, #16
 8028a8e:	46bd      	mov	sp, r7
 8028a90:	bd80      	pop	{r7, pc}
 8028a92:	bf00      	nop
 8028a94:	1fff7590 	.word	0x1fff7590
 8028a98:	1fff7594 	.word	0x1fff7594
 8028a9c:	1fff7598 	.word	0x1fff7598
 8028aa0:	20000192 	.word	0x20000192
 8028aa4:	200001a2 	.word	0x200001a2

08028aa8 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8028aa8:	b480      	push	{r7}
 8028aaa:	b087      	sub	sp, #28
 8028aac:	af00      	add	r7, sp, #0
 8028aae:	60f8      	str	r0, [r7, #12]
 8028ab0:	60b9      	str	r1, [r7, #8]
 8028ab2:	4613      	mov	r3, r2
 8028ab4:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 8028ab6:	2300      	movs	r3, #0
 8028ab8:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 8028aba:	2300      	movs	r3, #0
 8028abc:	75fb      	strb	r3, [r7, #23]
 8028abe:	e027      	b.n	8028b10 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 8028ac0:	68fb      	ldr	r3, [r7, #12]
 8028ac2:	0f1b      	lsrs	r3, r3, #28
 8028ac4:	2b09      	cmp	r3, #9
 8028ac6:	d80b      	bhi.n	8028ae0 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 8028ac8:	68fb      	ldr	r3, [r7, #12]
 8028aca:	0f1b      	lsrs	r3, r3, #28
 8028acc:	b2da      	uxtb	r2, r3
 8028ace:	7dfb      	ldrb	r3, [r7, #23]
 8028ad0:	005b      	lsls	r3, r3, #1
 8028ad2:	4619      	mov	r1, r3
 8028ad4:	68bb      	ldr	r3, [r7, #8]
 8028ad6:	440b      	add	r3, r1
 8028ad8:	3230      	adds	r2, #48	; 0x30
 8028ada:	b2d2      	uxtb	r2, r2
 8028adc:	701a      	strb	r2, [r3, #0]
 8028ade:	e00a      	b.n	8028af6 <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8028ae0:	68fb      	ldr	r3, [r7, #12]
 8028ae2:	0f1b      	lsrs	r3, r3, #28
 8028ae4:	b2da      	uxtb	r2, r3
 8028ae6:	7dfb      	ldrb	r3, [r7, #23]
 8028ae8:	005b      	lsls	r3, r3, #1
 8028aea:	4619      	mov	r1, r3
 8028aec:	68bb      	ldr	r3, [r7, #8]
 8028aee:	440b      	add	r3, r1
 8028af0:	3237      	adds	r2, #55	; 0x37
 8028af2:	b2d2      	uxtb	r2, r2
 8028af4:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 8028af6:	68fb      	ldr	r3, [r7, #12]
 8028af8:	011b      	lsls	r3, r3, #4
 8028afa:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8028afc:	7dfb      	ldrb	r3, [r7, #23]
 8028afe:	005b      	lsls	r3, r3, #1
 8028b00:	3301      	adds	r3, #1
 8028b02:	68ba      	ldr	r2, [r7, #8]
 8028b04:	4413      	add	r3, r2
 8028b06:	2200      	movs	r2, #0
 8028b08:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 8028b0a:	7dfb      	ldrb	r3, [r7, #23]
 8028b0c:	3301      	adds	r3, #1
 8028b0e:	75fb      	strb	r3, [r7, #23]
 8028b10:	7dfa      	ldrb	r2, [r7, #23]
 8028b12:	79fb      	ldrb	r3, [r7, #7]
 8028b14:	429a      	cmp	r2, r3
 8028b16:	d3d3      	bcc.n	8028ac0 <IntToUnicode+0x18>
  }
}
 8028b18:	bf00      	nop
 8028b1a:	bf00      	nop
 8028b1c:	371c      	adds	r7, #28
 8028b1e:	46bd      	mov	sp, r7
 8028b20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b24:	4770      	bx	lr

08028b26 <LL_AHB2_GRP1_EnableClock>:
{
 8028b26:	b480      	push	{r7}
 8028b28:	b085      	sub	sp, #20
 8028b2a:	af00      	add	r7, sp, #0
 8028b2c:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8028b2e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028b32:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8028b34:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8028b38:	687b      	ldr	r3, [r7, #4]
 8028b3a:	4313      	orrs	r3, r2
 8028b3c:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8028b3e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028b42:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8028b44:	687b      	ldr	r3, [r7, #4]
 8028b46:	4013      	ands	r3, r2
 8028b48:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8028b4a:	68fb      	ldr	r3, [r7, #12]
}
 8028b4c:	bf00      	nop
 8028b4e:	3714      	adds	r7, #20
 8028b50:	46bd      	mov	sp, r7
 8028b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b56:	4770      	bx	lr

08028b58 <LL_APB1_GRP1_EnableClock>:
{
 8028b58:	b480      	push	{r7}
 8028b5a:	b085      	sub	sp, #20
 8028b5c:	af00      	add	r7, sp, #0
 8028b5e:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 8028b60:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028b64:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8028b66:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8028b6a:	687b      	ldr	r3, [r7, #4]
 8028b6c:	4313      	orrs	r3, r2
 8028b6e:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8028b70:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8028b74:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8028b76:	687b      	ldr	r3, [r7, #4]
 8028b78:	4013      	ands	r3, r2
 8028b7a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8028b7c:	68fb      	ldr	r3, [r7, #12]
}
 8028b7e:	bf00      	nop
 8028b80:	3714      	adds	r7, #20
 8028b82:	46bd      	mov	sp, r7
 8028b84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b88:	4770      	bx	lr
	...

08028b8c <HAL_PCD_MspInit>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
#else
void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028b8c:	b580      	push	{r7, lr}
 8028b8e:	b088      	sub	sp, #32
 8028b90:	af00      	add	r7, sp, #0
 8028b92:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028b94:	f107 030c 	add.w	r3, r7, #12
 8028b98:	2200      	movs	r2, #0
 8028b9a:	601a      	str	r2, [r3, #0]
 8028b9c:	605a      	str	r2, [r3, #4]
 8028b9e:	609a      	str	r2, [r3, #8]
 8028ba0:	60da      	str	r2, [r3, #12]
 8028ba2:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB)
 8028ba4:	687b      	ldr	r3, [r7, #4]
 8028ba6:	681b      	ldr	r3, [r3, #0]
 8028ba8:	4a1d      	ldr	r2, [pc, #116]	; (8028c20 <HAL_PCD_MspInit+0x94>)
 8028baa:	4293      	cmp	r3, r2
 8028bac:	d134      	bne.n	8028c18 <HAL_PCD_MspInit+0x8c>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8028bae:	2001      	movs	r0, #1
 8028bb0:	f7ff ffb9 	bl	8028b26 <LL_AHB2_GRP1_EnableClock>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8028bb4:	2004      	movs	r0, #4
 8028bb6:	f7ff ffb6 	bl	8028b26 <LL_AHB2_GRP1_EnableClock>
    /**USB GPIO Configuration
    PA12     ------> USB_DP
    PA11     ------> USB_DM
    PC9     ------> USB_NOE
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11;
 8028bba:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8028bbe:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028bc0:	2302      	movs	r3, #2
 8028bc2:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028bc4:	2300      	movs	r3, #0
 8028bc6:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028bc8:	2300      	movs	r3, #0
 8028bca:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_USB;
 8028bcc:	230a      	movs	r3, #10
 8028bce:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028bd0:	f107 030c 	add.w	r3, r7, #12
 8028bd4:	4619      	mov	r1, r3
 8028bd6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8028bda:	f7e5 f93d 	bl	800de58 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8028bde:	f44f 7300 	mov.w	r3, #512	; 0x200
 8028be2:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8028be4:	2302      	movs	r3, #2
 8028be6:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028be8:	2300      	movs	r3, #0
 8028bea:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028bec:	2300      	movs	r3, #0
 8028bee:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_USB;
 8028bf0:	230a      	movs	r3, #10
 8028bf2:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8028bf4:	f107 030c 	add.w	r3, r7, #12
 8028bf8:	4619      	mov	r1, r3
 8028bfa:	480a      	ldr	r0, [pc, #40]	; (8028c24 <HAL_PCD_MspInit+0x98>)
 8028bfc:	f7e5 f92c 	bl	800de58 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 8028c00:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8028c04:	f7ff ffa8 	bl	8028b58 <LL_APB1_GRP1_EnableClock>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_LP_IRQn, 5, 0);
 8028c08:	2200      	movs	r2, #0
 8028c0a:	2105      	movs	r1, #5
 8028c0c:	2014      	movs	r0, #20
 8028c0e:	f7e4 ff15 	bl	800da3c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_IRQn);
 8028c12:	2014      	movs	r0, #20
 8028c14:	f7e4 ff2c 	bl	800da70 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8028c18:	bf00      	nop
 8028c1a:	3720      	adds	r7, #32
 8028c1c:	46bd      	mov	sp, r7
 8028c1e:	bd80      	pop	{r7, pc}
 8028c20:	40006800 	.word	0x40006800
 8028c24:	48000800 	.word	0x48000800

08028c28 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028c28:	b580      	push	{r7, lr}
 8028c2a:	b082      	sub	sp, #8
 8028c2c:	af00      	add	r7, sp, #0
 8028c2e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SetupStageCallback_PreTreatment */

  /* USER CODE END  HAL_PCD_SetupStageCallback_PreTreatment */
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8028c30:	687b      	ldr	r3, [r7, #4]
 8028c32:	f8d3 22f0 	ldr.w	r2, [r3, #752]	; 0x2f0
 8028c36:	687b      	ldr	r3, [r7, #4]
 8028c38:	f503 732c 	add.w	r3, r3, #688	; 0x2b0
 8028c3c:	4619      	mov	r1, r3
 8028c3e:	4610      	mov	r0, r2
 8028c40:	f7ef ff60 	bl	8018b04 <USBD_LL_SetupStage>
  /* USER CODE BEGIN HAL_PCD_SetupStageCallback_PostTreatment */

  /* USER CODE END  HAL_PCD_SetupStageCallback_PostTreatment */
}
 8028c44:	bf00      	nop
 8028c46:	3708      	adds	r7, #8
 8028c48:	46bd      	mov	sp, r7
 8028c4a:	bd80      	pop	{r7, pc}

08028c4c <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028c4c:	b580      	push	{r7, lr}
 8028c4e:	b082      	sub	sp, #8
 8028c50:	af00      	add	r7, sp, #0
 8028c52:	6078      	str	r0, [r7, #4]
 8028c54:	460b      	mov	r3, r1
 8028c56:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_DataOutStageCallback_PreTreatment */

  /* USER CODE END HAL_PCD_DataOutStageCallback_PreTreatment */
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8028c58:	687b      	ldr	r3, [r7, #4]
 8028c5a:	f8d3 02f0 	ldr.w	r0, [r3, #752]	; 0x2f0
 8028c5e:	78fa      	ldrb	r2, [r7, #3]
 8028c60:	6879      	ldr	r1, [r7, #4]
 8028c62:	4613      	mov	r3, r2
 8028c64:	009b      	lsls	r3, r3, #2
 8028c66:	4413      	add	r3, r2
 8028c68:	00db      	lsls	r3, r3, #3
 8028c6a:	440b      	add	r3, r1
 8028c6c:	f503 73be 	add.w	r3, r3, #380	; 0x17c
 8028c70:	681a      	ldr	r2, [r3, #0]
 8028c72:	78fb      	ldrb	r3, [r7, #3]
 8028c74:	4619      	mov	r1, r3
 8028c76:	f7ef ff9a 	bl	8018bae <USBD_LL_DataOutStage>
  /* USER CODE BEGIN HAL_PCD_DataOutStageCallback_PostTreatment */

  /* USER CODE END HAL_PCD_DataOutStageCallback_PostTreatment */
}
 8028c7a:	bf00      	nop
 8028c7c:	3708      	adds	r7, #8
 8028c7e:	46bd      	mov	sp, r7
 8028c80:	bd80      	pop	{r7, pc}

08028c82 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028c82:	b580      	push	{r7, lr}
 8028c84:	b082      	sub	sp, #8
 8028c86:	af00      	add	r7, sp, #0
 8028c88:	6078      	str	r0, [r7, #4]
 8028c8a:	460b      	mov	r3, r1
 8028c8c:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_DataInStageCallback_PreTreatment */

  /* USER CODE END HAL_PCD_DataInStageCallback_PreTreatment */
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8028c8e:	687b      	ldr	r3, [r7, #4]
 8028c90:	f8d3 02f0 	ldr.w	r0, [r3, #752]	; 0x2f0
 8028c94:	78fa      	ldrb	r2, [r7, #3]
 8028c96:	6879      	ldr	r1, [r7, #4]
 8028c98:	4613      	mov	r3, r2
 8028c9a:	009b      	lsls	r3, r3, #2
 8028c9c:	4413      	add	r3, r2
 8028c9e:	00db      	lsls	r3, r3, #3
 8028ca0:	440b      	add	r3, r1
 8028ca2:	333c      	adds	r3, #60	; 0x3c
 8028ca4:	681a      	ldr	r2, [r3, #0]
 8028ca6:	78fb      	ldrb	r3, [r7, #3]
 8028ca8:	4619      	mov	r1, r3
 8028caa:	f7ef ffe3 	bl	8018c74 <USBD_LL_DataInStage>
  /* USER CODE BEGIN HAL_PCD_DataInStageCallback_PostTreatment  */

  /* USER CODE END HAL_PCD_DataInStageCallback_PostTreatment */
}
 8028cae:	bf00      	nop
 8028cb0:	3708      	adds	r7, #8
 8028cb2:	46bd      	mov	sp, r7
 8028cb4:	bd80      	pop	{r7, pc}

08028cb6 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028cb6:	b580      	push	{r7, lr}
 8028cb8:	b082      	sub	sp, #8
 8028cba:	af00      	add	r7, sp, #0
 8028cbc:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SOFCallback_PreTreatment */

  /* USER CODE END HAL_PCD_SOFCallback_PreTreatment */
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8028cbe:	687b      	ldr	r3, [r7, #4]
 8028cc0:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8028cc4:	4618      	mov	r0, r3
 8028cc6:	f7f0 f8f7 	bl	8018eb8 <USBD_LL_SOF>
  /* USER CODE BEGIN HAL_PCD_SOFCallback_PostTreatment */

  /* USER CODE END HAL_PCD_SOFCallback_PostTreatment */
}
 8028cca:	bf00      	nop
 8028ccc:	3708      	adds	r7, #8
 8028cce:	46bd      	mov	sp, r7
 8028cd0:	bd80      	pop	{r7, pc}

08028cd2 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028cd2:	b580      	push	{r7, lr}
 8028cd4:	b084      	sub	sp, #16
 8028cd6:	af00      	add	r7, sp, #0
 8028cd8:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_ResetCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ResetCallback_PreTreatment */
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8028cda:	2301      	movs	r3, #1
 8028cdc:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8028cde:	687b      	ldr	r3, [r7, #4]
 8028ce0:	689b      	ldr	r3, [r3, #8]
 8028ce2:	2b02      	cmp	r3, #2
 8028ce4:	d001      	beq.n	8028cea <HAL_PCD_ResetCallback+0x18>
  {
    Error_Handler();
 8028ce6:	f7e2 f901 	bl	800aeec <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8028cea:	687b      	ldr	r3, [r7, #4]
 8028cec:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8028cf0:	7bfa      	ldrb	r2, [r7, #15]
 8028cf2:	4611      	mov	r1, r2
 8028cf4:	4618      	mov	r0, r3
 8028cf6:	f7f0 f8a1 	bl	8018e3c <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8028cfa:	687b      	ldr	r3, [r7, #4]
 8028cfc:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8028d00:	4618      	mov	r0, r3
 8028d02:	f7f0 f84d 	bl	8018da0 <USBD_LL_Reset>
  /* USER CODE BEGIN HAL_PCD_ResetCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ResetCallback_PostTreatment */
}
 8028d06:	bf00      	nop
 8028d08:	3710      	adds	r7, #16
 8028d0a:	46bd      	mov	sp, r7
 8028d0c:	bd80      	pop	{r7, pc}
	...

08028d10 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028d10:	b580      	push	{r7, lr}
 8028d12:	b082      	sub	sp, #8
 8028d14:	af00      	add	r7, sp, #0
 8028d16:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SuspendCallback_PreTreatment */

  /* USER CODE END HAL_PCD_SuspendCallback_PreTreatment */
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8028d18:	687b      	ldr	r3, [r7, #4]
 8028d1a:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8028d1e:	4618      	mov	r0, r3
 8028d20:	f7f0 f89c 	bl	8018e5c <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8028d24:	687b      	ldr	r3, [r7, #4]
 8028d26:	699b      	ldr	r3, [r3, #24]
 8028d28:	2b00      	cmp	r3, #0
 8028d2a:	d005      	beq.n	8028d38 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8028d2c:	4b04      	ldr	r3, [pc, #16]	; (8028d40 <HAL_PCD_SuspendCallback+0x30>)
 8028d2e:	691b      	ldr	r3, [r3, #16]
 8028d30:	4a03      	ldr	r2, [pc, #12]	; (8028d40 <HAL_PCD_SuspendCallback+0x30>)
 8028d32:	f043 0306 	orr.w	r3, r3, #6
 8028d36:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
  /* USER CODE BEGIN HAL_PCD_SuspendCallback_PostTreatment */

  /* USER CODE END HAL_PCD_SuspendCallback_PostTreatment */
}
 8028d38:	bf00      	nop
 8028d3a:	3708      	adds	r7, #8
 8028d3c:	46bd      	mov	sp, r7
 8028d3e:	bd80      	pop	{r7, pc}
 8028d40:	e000ed00 	.word	0xe000ed00

08028d44 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8028d44:	b580      	push	{r7, lr}
 8028d46:	b082      	sub	sp, #8
 8028d48:	af00      	add	r7, sp, #0
 8028d4a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_ResumeCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ResumeCallback_PreTreatment */

  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
 8028d4c:	687b      	ldr	r3, [r7, #4]
 8028d4e:	699b      	ldr	r3, [r3, #24]
 8028d50:	2b00      	cmp	r3, #0
 8028d52:	d007      	beq.n	8028d64 <HAL_PCD_ResumeCallback+0x20>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8028d54:	4b08      	ldr	r3, [pc, #32]	; (8028d78 <HAL_PCD_ResumeCallback+0x34>)
 8028d56:	691b      	ldr	r3, [r3, #16]
 8028d58:	4a07      	ldr	r2, [pc, #28]	; (8028d78 <HAL_PCD_ResumeCallback+0x34>)
 8028d5a:	f023 0306 	bic.w	r3, r3, #6
 8028d5e:	6113      	str	r3, [r2, #16]
    SystemClockConfig_Resume();
 8028d60:	f000 f9fc 	bl	802915c <SystemClockConfig_Resume>
  }
  /* USER CODE END 3 */

  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8028d64:	687b      	ldr	r3, [r7, #4]
 8028d66:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8028d6a:	4618      	mov	r0, r3
 8028d6c:	f7f0 f88c 	bl	8018e88 <USBD_LL_Resume>
  /* USER CODE BEGIN HAL_PCD_ResumeCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ResumeCallback_PostTreatment */
}
 8028d70:	bf00      	nop
 8028d72:	3708      	adds	r7, #8
 8028d74:	46bd      	mov	sp, r7
 8028d76:	bd80      	pop	{r7, pc}
 8028d78:	e000ed00 	.word	0xe000ed00

08028d7c <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8028d7c:	b580      	push	{r7, lr}
 8028d7e:	b082      	sub	sp, #8
 8028d80:	af00      	add	r7, sp, #0
 8028d82:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  hpcd_USB_FS.pData = pdev;
 8028d84:	4a2c      	ldr	r2, [pc, #176]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028d86:	687b      	ldr	r3, [r7, #4]
 8028d88:	f8c2 32f0 	str.w	r3, [r2, #752]	; 0x2f0
  /* Link the driver to the stack. */
  pdev->pData = &hpcd_USB_FS;
 8028d8c:	687b      	ldr	r3, [r7, #4]
 8028d8e:	4a2a      	ldr	r2, [pc, #168]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028d90:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4
/* Enable USB power on Pwrctrl CR2 register. */
  HAL_PWREx_EnableVddUSB();
 8028d94:	f7e8 f82c 	bl	8010df0 <HAL_PWREx_EnableVddUSB>

  hpcd_USB_FS.Instance = USB;
 8028d98:	4b27      	ldr	r3, [pc, #156]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028d9a:	4a28      	ldr	r2, [pc, #160]	; (8028e3c <USBD_LL_Init+0xc0>)
 8028d9c:	601a      	str	r2, [r3, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8028d9e:	4b26      	ldr	r3, [pc, #152]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028da0:	2208      	movs	r2, #8
 8028da2:	605a      	str	r2, [r3, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8028da4:	4b24      	ldr	r3, [pc, #144]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028da6:	2202      	movs	r2, #2
 8028da8:	609a      	str	r2, [r3, #8]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8028daa:	4b23      	ldr	r3, [pc, #140]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028dac:	2202      	movs	r2, #2
 8028dae:	611a      	str	r2, [r3, #16]
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
 8028db0:	4b21      	ldr	r3, [pc, #132]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028db2:	2200      	movs	r2, #0
 8028db4:	615a      	str	r2, [r3, #20]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8028db6:	4b20      	ldr	r3, [pc, #128]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028db8:	2200      	movs	r2, #0
 8028dba:	619a      	str	r2, [r3, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8028dbc:	4b1e      	ldr	r3, [pc, #120]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028dbe:	2200      	movs	r2, #0
 8028dc0:	61da      	str	r2, [r3, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8028dc2:	4b1d      	ldr	r3, [pc, #116]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028dc4:	2200      	movs	r2, #0
 8028dc6:	621a      	str	r2, [r3, #32]
  /* register Msp Callbacks (before the Init) */
  HAL_PCD_RegisterCallback(&hpcd_USB_FS, HAL_PCD_MSPINIT_CB_ID, PCD_MspInit);
  HAL_PCD_RegisterCallback(&hpcd_USB_FS, HAL_PCD_MSPDEINIT_CB_ID, PCD_MspDeInit);
  #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8028dc8:	481b      	ldr	r0, [pc, #108]	; (8028e38 <USBD_LL_Init+0xbc>)
 8028dca:	f7e6 fabf 	bl	800f34c <HAL_PCD_Init>
 8028dce:	4603      	mov	r3, r0
 8028dd0:	2b00      	cmp	r3, #0
 8028dd2:	d001      	beq.n	8028dd8 <USBD_LL_Init+0x5c>
  {
    Error_Handler( );
 8028dd4:	f7e2 f88a 	bl	800aeec <Error_Handler>
  /* USER CODE BEGIN RegisterCallBackSecondPart */

  /* USER CODE END RegisterCallBackSecondPart */
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN EndPoint_Configuration */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8028dd8:	687b      	ldr	r3, [r7, #4]
 8028dda:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028dde:	2318      	movs	r3, #24
 8028de0:	2200      	movs	r2, #0
 8028de2:	2100      	movs	r1, #0
 8028de4:	f7e7 ff78 	bl	8010cd8 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8028de8:	687b      	ldr	r3, [r7, #4]
 8028dea:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028dee:	2358      	movs	r3, #88	; 0x58
 8028df0:	2200      	movs	r2, #0
 8028df2:	2180      	movs	r1, #128	; 0x80
 8028df4:	f7e7 ff70 	bl	8010cd8 <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration */
  /* USER CODE BEGIN EndPoint_Configuration_CDC */
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);
 8028df8:	687b      	ldr	r3, [r7, #4]
 8028dfa:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028dfe:	23c0      	movs	r3, #192	; 0xc0
 8028e00:	2200      	movs	r2, #0
 8028e02:	2181      	movs	r1, #129	; 0x81
 8028e04:	f7e7 ff68 	bl	8010cd8 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8028e08:	687b      	ldr	r3, [r7, #4]
 8028e0a:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028e0e:	f44f 7388 	mov.w	r3, #272	; 0x110
 8028e12:	2200      	movs	r2, #0
 8028e14:	2101      	movs	r1, #1
 8028e16:	f7e7 ff5f 	bl	8010cd8 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);
 8028e1a:	687b      	ldr	r3, [r7, #4]
 8028e1c:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028e20:	f44f 7380 	mov.w	r3, #256	; 0x100
 8028e24:	2200      	movs	r2, #0
 8028e26:	2182      	movs	r1, #130	; 0x82
 8028e28:	f7e7 ff56 	bl	8010cd8 <HAL_PCDEx_PMAConfig>
  /* USER CODE END EndPoint_Configuration_CDC */
  return USBD_OK;
 8028e2c:	2300      	movs	r3, #0
}
 8028e2e:	4618      	mov	r0, r3
 8028e30:	3708      	adds	r7, #8
 8028e32:	46bd      	mov	sp, r7
 8028e34:	bd80      	pop	{r7, pc}
 8028e36:	bf00      	nop
 8028e38:	200138a8 	.word	0x200138a8
 8028e3c:	40006800 	.word	0x40006800

08028e40 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8028e40:	b580      	push	{r7, lr}
 8028e42:	b084      	sub	sp, #16
 8028e44:	af00      	add	r7, sp, #0
 8028e46:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028e48:	2300      	movs	r3, #0
 8028e4a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028e4c:	2300      	movs	r3, #0
 8028e4e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8028e50:	687b      	ldr	r3, [r7, #4]
 8028e52:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028e56:	4618      	mov	r0, r3
 8028e58:	f7e6 fb5d 	bl	800f516 <HAL_PCD_Start>
 8028e5c:	4603      	mov	r3, r0
 8028e5e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028e60:	7bfb      	ldrb	r3, [r7, #15]
 8028e62:	4618      	mov	r0, r3
 8028e64:	f000 f980 	bl	8029168 <USBD_Get_USB_Status>
 8028e68:	4603      	mov	r3, r0
 8028e6a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028e6c:	7bbb      	ldrb	r3, [r7, #14]
}
 8028e6e:	4618      	mov	r0, r3
 8028e70:	3710      	adds	r7, #16
 8028e72:	46bd      	mov	sp, r7
 8028e74:	bd80      	pop	{r7, pc}

08028e76 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8028e76:	b580      	push	{r7, lr}
 8028e78:	b084      	sub	sp, #16
 8028e7a:	af00      	add	r7, sp, #0
 8028e7c:	6078      	str	r0, [r7, #4]
 8028e7e:	4608      	mov	r0, r1
 8028e80:	4611      	mov	r1, r2
 8028e82:	461a      	mov	r2, r3
 8028e84:	4603      	mov	r3, r0
 8028e86:	70fb      	strb	r3, [r7, #3]
 8028e88:	460b      	mov	r3, r1
 8028e8a:	70bb      	strb	r3, [r7, #2]
 8028e8c:	4613      	mov	r3, r2
 8028e8e:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028e90:	2300      	movs	r3, #0
 8028e92:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028e94:	2300      	movs	r3, #0
 8028e96:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8028e98:	687b      	ldr	r3, [r7, #4]
 8028e9a:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8028e9e:	78bb      	ldrb	r3, [r7, #2]
 8028ea0:	883a      	ldrh	r2, [r7, #0]
 8028ea2:	78f9      	ldrb	r1, [r7, #3]
 8028ea4:	f7e6 fca5 	bl	800f7f2 <HAL_PCD_EP_Open>
 8028ea8:	4603      	mov	r3, r0
 8028eaa:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028eac:	7bfb      	ldrb	r3, [r7, #15]
 8028eae:	4618      	mov	r0, r3
 8028eb0:	f000 f95a 	bl	8029168 <USBD_Get_USB_Status>
 8028eb4:	4603      	mov	r3, r0
 8028eb6:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028eb8:	7bbb      	ldrb	r3, [r7, #14]
}
 8028eba:	4618      	mov	r0, r3
 8028ebc:	3710      	adds	r7, #16
 8028ebe:	46bd      	mov	sp, r7
 8028ec0:	bd80      	pop	{r7, pc}

08028ec2 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028ec2:	b580      	push	{r7, lr}
 8028ec4:	b084      	sub	sp, #16
 8028ec6:	af00      	add	r7, sp, #0
 8028ec8:	6078      	str	r0, [r7, #4]
 8028eca:	460b      	mov	r3, r1
 8028ecc:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028ece:	2300      	movs	r3, #0
 8028ed0:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028ed2:	2300      	movs	r3, #0
 8028ed4:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8028ed6:	687b      	ldr	r3, [r7, #4]
 8028ed8:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028edc:	78fa      	ldrb	r2, [r7, #3]
 8028ede:	4611      	mov	r1, r2
 8028ee0:	4618      	mov	r0, r3
 8028ee2:	f7e6 fcec 	bl	800f8be <HAL_PCD_EP_Close>
 8028ee6:	4603      	mov	r3, r0
 8028ee8:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028eea:	7bfb      	ldrb	r3, [r7, #15]
 8028eec:	4618      	mov	r0, r3
 8028eee:	f000 f93b 	bl	8029168 <USBD_Get_USB_Status>
 8028ef2:	4603      	mov	r3, r0
 8028ef4:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028ef6:	7bbb      	ldrb	r3, [r7, #14]
}
 8028ef8:	4618      	mov	r0, r3
 8028efa:	3710      	adds	r7, #16
 8028efc:	46bd      	mov	sp, r7
 8028efe:	bd80      	pop	{r7, pc}

08028f00 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028f00:	b580      	push	{r7, lr}
 8028f02:	b084      	sub	sp, #16
 8028f04:	af00      	add	r7, sp, #0
 8028f06:	6078      	str	r0, [r7, #4]
 8028f08:	460b      	mov	r3, r1
 8028f0a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028f0c:	2300      	movs	r3, #0
 8028f0e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028f10:	2300      	movs	r3, #0
 8028f12:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8028f14:	687b      	ldr	r3, [r7, #4]
 8028f16:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028f1a:	78fa      	ldrb	r2, [r7, #3]
 8028f1c:	4611      	mov	r1, r2
 8028f1e:	4618      	mov	r0, r3
 8028f20:	f7e6 fdad 	bl	800fa7e <HAL_PCD_EP_SetStall>
 8028f24:	4603      	mov	r3, r0
 8028f26:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028f28:	7bfb      	ldrb	r3, [r7, #15]
 8028f2a:	4618      	mov	r0, r3
 8028f2c:	f000 f91c 	bl	8029168 <USBD_Get_USB_Status>
 8028f30:	4603      	mov	r3, r0
 8028f32:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028f34:	7bbb      	ldrb	r3, [r7, #14]
}
 8028f36:	4618      	mov	r0, r3
 8028f38:	3710      	adds	r7, #16
 8028f3a:	46bd      	mov	sp, r7
 8028f3c:	bd80      	pop	{r7, pc}

08028f3e <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028f3e:	b580      	push	{r7, lr}
 8028f40:	b084      	sub	sp, #16
 8028f42:	af00      	add	r7, sp, #0
 8028f44:	6078      	str	r0, [r7, #4]
 8028f46:	460b      	mov	r3, r1
 8028f48:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028f4a:	2300      	movs	r3, #0
 8028f4c:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028f4e:	2300      	movs	r3, #0
 8028f50:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8028f52:	687b      	ldr	r3, [r7, #4]
 8028f54:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028f58:	78fa      	ldrb	r2, [r7, #3]
 8028f5a:	4611      	mov	r1, r2
 8028f5c:	4618      	mov	r0, r3
 8028f5e:	f7e6 fde0 	bl	800fb22 <HAL_PCD_EP_ClrStall>
 8028f62:	4603      	mov	r3, r0
 8028f64:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028f66:	7bfb      	ldrb	r3, [r7, #15]
 8028f68:	4618      	mov	r0, r3
 8028f6a:	f000 f8fd 	bl	8029168 <USBD_Get_USB_Status>
 8028f6e:	4603      	mov	r3, r0
 8028f70:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8028f72:	7bbb      	ldrb	r3, [r7, #14]
}
 8028f74:	4618      	mov	r0, r3
 8028f76:	3710      	adds	r7, #16
 8028f78:	46bd      	mov	sp, r7
 8028f7a:	bd80      	pop	{r7, pc}

08028f7c <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8028f7c:	b480      	push	{r7}
 8028f7e:	b085      	sub	sp, #20
 8028f80:	af00      	add	r7, sp, #0
 8028f82:	6078      	str	r0, [r7, #4]
 8028f84:	460b      	mov	r3, r1
 8028f86:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8028f88:	687b      	ldr	r3, [r7, #4]
 8028f8a:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028f8e:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 8028f90:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8028f94:	2b00      	cmp	r3, #0
 8028f96:	da0c      	bge.n	8028fb2 <USBD_LL_IsStallEP+0x36>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8028f98:	78fb      	ldrb	r3, [r7, #3]
 8028f9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8028f9e:	68f9      	ldr	r1, [r7, #12]
 8028fa0:	1c5a      	adds	r2, r3, #1
 8028fa2:	4613      	mov	r3, r2
 8028fa4:	009b      	lsls	r3, r3, #2
 8028fa6:	4413      	add	r3, r2
 8028fa8:	00db      	lsls	r3, r3, #3
 8028faa:	440b      	add	r3, r1
 8028fac:	3302      	adds	r3, #2
 8028fae:	781b      	ldrb	r3, [r3, #0]
 8028fb0:	e00b      	b.n	8028fca <USBD_LL_IsStallEP+0x4e>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8028fb2:	78fb      	ldrb	r3, [r7, #3]
 8028fb4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8028fb8:	68f9      	ldr	r1, [r7, #12]
 8028fba:	4613      	mov	r3, r2
 8028fbc:	009b      	lsls	r3, r3, #2
 8028fbe:	4413      	add	r3, r2
 8028fc0:	00db      	lsls	r3, r3, #3
 8028fc2:	440b      	add	r3, r1
 8028fc4:	f503 73b5 	add.w	r3, r3, #362	; 0x16a
 8028fc8:	781b      	ldrb	r3, [r3, #0]
  }
}
 8028fca:	4618      	mov	r0, r3
 8028fcc:	3714      	adds	r7, #20
 8028fce:	46bd      	mov	sp, r7
 8028fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028fd4:	4770      	bx	lr

08028fd6 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8028fd6:	b580      	push	{r7, lr}
 8028fd8:	b084      	sub	sp, #16
 8028fda:	af00      	add	r7, sp, #0
 8028fdc:	6078      	str	r0, [r7, #4]
 8028fde:	460b      	mov	r3, r1
 8028fe0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8028fe2:	2300      	movs	r3, #0
 8028fe4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8028fe6:	2300      	movs	r3, #0
 8028fe8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8028fea:	687b      	ldr	r3, [r7, #4]
 8028fec:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8028ff0:	78fa      	ldrb	r2, [r7, #3]
 8028ff2:	4611      	mov	r1, r2
 8028ff4:	4618      	mov	r0, r3
 8028ff6:	f7e6 fbd7 	bl	800f7a8 <HAL_PCD_SetAddress>
 8028ffa:	4603      	mov	r3, r0
 8028ffc:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8028ffe:	7bfb      	ldrb	r3, [r7, #15]
 8029000:	4618      	mov	r0, r3
 8029002:	f000 f8b1 	bl	8029168 <USBD_Get_USB_Status>
 8029006:	4603      	mov	r3, r0
 8029008:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 802900a:	7bbb      	ldrb	r3, [r7, #14]
}
 802900c:	4618      	mov	r0, r3
 802900e:	3710      	adds	r7, #16
 8029010:	46bd      	mov	sp, r7
 8029012:	bd80      	pop	{r7, pc}

08029014 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8029014:	b580      	push	{r7, lr}
 8029016:	b086      	sub	sp, #24
 8029018:	af00      	add	r7, sp, #0
 802901a:	60f8      	str	r0, [r7, #12]
 802901c:	607a      	str	r2, [r7, #4]
 802901e:	603b      	str	r3, [r7, #0]
 8029020:	460b      	mov	r3, r1
 8029022:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8029024:	2300      	movs	r3, #0
 8029026:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8029028:	2300      	movs	r3, #0
 802902a:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 802902c:	68fb      	ldr	r3, [r7, #12]
 802902e:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8029032:	7af9      	ldrb	r1, [r7, #11]
 8029034:	683b      	ldr	r3, [r7, #0]
 8029036:	687a      	ldr	r2, [r7, #4]
 8029038:	f7e6 fcde 	bl	800f9f8 <HAL_PCD_EP_Transmit>
 802903c:	4603      	mov	r3, r0
 802903e:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8029040:	7dfb      	ldrb	r3, [r7, #23]
 8029042:	4618      	mov	r0, r3
 8029044:	f000 f890 	bl	8029168 <USBD_Get_USB_Status>
 8029048:	4603      	mov	r3, r0
 802904a:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 802904c:	7dbb      	ldrb	r3, [r7, #22]
}
 802904e:	4618      	mov	r0, r3
 8029050:	3718      	adds	r7, #24
 8029052:	46bd      	mov	sp, r7
 8029054:	bd80      	pop	{r7, pc}

08029056 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8029056:	b580      	push	{r7, lr}
 8029058:	b086      	sub	sp, #24
 802905a:	af00      	add	r7, sp, #0
 802905c:	60f8      	str	r0, [r7, #12]
 802905e:	607a      	str	r2, [r7, #4]
 8029060:	603b      	str	r3, [r7, #0]
 8029062:	460b      	mov	r3, r1
 8029064:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8029066:	2300      	movs	r3, #0
 8029068:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 802906a:	2300      	movs	r3, #0
 802906c:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 802906e:	68fb      	ldr	r3, [r7, #12]
 8029070:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8029074:	7af9      	ldrb	r1, [r7, #11]
 8029076:	683b      	ldr	r3, [r7, #0]
 8029078:	687a      	ldr	r2, [r7, #4]
 802907a:	f7e6 fc68 	bl	800f94e <HAL_PCD_EP_Receive>
 802907e:	4603      	mov	r3, r0
 8029080:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8029082:	7dfb      	ldrb	r3, [r7, #23]
 8029084:	4618      	mov	r0, r3
 8029086:	f000 f86f 	bl	8029168 <USBD_Get_USB_Status>
 802908a:	4603      	mov	r3, r0
 802908c:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 802908e:	7dbb      	ldrb	r3, [r7, #22]
}
 8029090:	4618      	mov	r0, r3
 8029092:	3718      	adds	r7, #24
 8029094:	46bd      	mov	sp, r7
 8029096:	bd80      	pop	{r7, pc}

08029098 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8029098:	b580      	push	{r7, lr}
 802909a:	b082      	sub	sp, #8
 802909c:	af00      	add	r7, sp, #0
 802909e:	6078      	str	r0, [r7, #4]
 80290a0:	460b      	mov	r3, r1
 80290a2:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 80290a4:	687b      	ldr	r3, [r7, #4]
 80290a6:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 80290aa:	78fa      	ldrb	r2, [r7, #3]
 80290ac:	4611      	mov	r1, r2
 80290ae:	4618      	mov	r0, r3
 80290b0:	f7e6 fc8a 	bl	800f9c8 <HAL_PCD_EP_GetRxCount>
 80290b4:	4603      	mov	r3, r0
}
 80290b6:	4618      	mov	r0, r3
 80290b8:	3708      	adds	r7, #8
 80290ba:	46bd      	mov	sp, r7
 80290bc:	bd80      	pop	{r7, pc}
	...

080290c0 <HAL_PCDEx_LPM_Callback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
#else
void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80290c0:	b580      	push	{r7, lr}
 80290c2:	b082      	sub	sp, #8
 80290c4:	af00      	add	r7, sp, #0
 80290c6:	6078      	str	r0, [r7, #4]
 80290c8:	460b      	mov	r3, r1
 80290ca:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN LPM_Callback */
  switch (msg)
 80290cc:	78fb      	ldrb	r3, [r7, #3]
 80290ce:	2b00      	cmp	r3, #0
 80290d0:	d002      	beq.n	80290d8 <HAL_PCDEx_LPM_Callback+0x18>
 80290d2:	2b01      	cmp	r3, #1
 80290d4:	d013      	beq.n	80290fe <HAL_PCDEx_LPM_Callback+0x3e>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
    }
    break;
  }
  /* USER CODE END LPM_Callback */
}
 80290d6:	e023      	b.n	8029120 <HAL_PCDEx_LPM_Callback+0x60>
    if (hpcd->Init.low_power_enable)
 80290d8:	687b      	ldr	r3, [r7, #4]
 80290da:	699b      	ldr	r3, [r3, #24]
 80290dc:	2b00      	cmp	r3, #0
 80290de:	d007      	beq.n	80290f0 <HAL_PCDEx_LPM_Callback+0x30>
      SystemClockConfig_Resume();
 80290e0:	f000 f83c 	bl	802915c <SystemClockConfig_Resume>
      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80290e4:	4b10      	ldr	r3, [pc, #64]	; (8029128 <HAL_PCDEx_LPM_Callback+0x68>)
 80290e6:	691b      	ldr	r3, [r3, #16]
 80290e8:	4a0f      	ldr	r2, [pc, #60]	; (8029128 <HAL_PCDEx_LPM_Callback+0x68>)
 80290ea:	f023 0306 	bic.w	r3, r3, #6
 80290ee:	6113      	str	r3, [r2, #16]
    USBD_LL_Resume(hpcd->pData);
 80290f0:	687b      	ldr	r3, [r7, #4]
 80290f2:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 80290f6:	4618      	mov	r0, r3
 80290f8:	f7ef fec6 	bl	8018e88 <USBD_LL_Resume>
    break;
 80290fc:	e010      	b.n	8029120 <HAL_PCDEx_LPM_Callback+0x60>
    USBD_LL_Suspend(hpcd->pData);
 80290fe:	687b      	ldr	r3, [r7, #4]
 8029100:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
 8029104:	4618      	mov	r0, r3
 8029106:	f7ef fea9 	bl	8018e5c <USBD_LL_Suspend>
    if (hpcd->Init.low_power_enable)
 802910a:	687b      	ldr	r3, [r7, #4]
 802910c:	699b      	ldr	r3, [r3, #24]
 802910e:	2b00      	cmp	r3, #0
 8029110:	d005      	beq.n	802911e <HAL_PCDEx_LPM_Callback+0x5e>
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8029112:	4b05      	ldr	r3, [pc, #20]	; (8029128 <HAL_PCDEx_LPM_Callback+0x68>)
 8029114:	691b      	ldr	r3, [r3, #16]
 8029116:	4a04      	ldr	r2, [pc, #16]	; (8029128 <HAL_PCDEx_LPM_Callback+0x68>)
 8029118:	f043 0306 	orr.w	r3, r3, #6
 802911c:	6113      	str	r3, [r2, #16]
    break;
 802911e:	bf00      	nop
}
 8029120:	bf00      	nop
 8029122:	3708      	adds	r7, #8
 8029124:	46bd      	mov	sp, r7
 8029126:	bd80      	pop	{r7, pc}
 8029128:	e000ed00 	.word	0xe000ed00

0802912c <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 802912c:	b480      	push	{r7}
 802912e:	b083      	sub	sp, #12
 8029130:	af00      	add	r7, sp, #0
 8029132:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 8029134:	4b03      	ldr	r3, [pc, #12]	; (8029144 <USBD_static_malloc+0x18>)
}
 8029136:	4618      	mov	r0, r3
 8029138:	370c      	adds	r7, #12
 802913a:	46bd      	mov	sp, r7
 802913c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029140:	4770      	bx	lr
 8029142:	bf00      	nop
 8029144:	20010c08 	.word	0x20010c08

08029148 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 8029148:	b480      	push	{r7}
 802914a:	b083      	sub	sp, #12
 802914c:	af00      	add	r7, sp, #0
 802914e:	6078      	str	r0, [r7, #4]

}
 8029150:	bf00      	nop
 8029152:	370c      	adds	r7, #12
 8029154:	46bd      	mov	sp, r7
 8029156:	f85d 7b04 	ldr.w	r7, [sp], #4
 802915a:	4770      	bx	lr

0802915c <SystemClockConfig_Resume>:
  * @brief  Configures system clock after wake-up from USB resume callBack:
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
 802915c:	b580      	push	{r7, lr}
 802915e:	af00      	add	r7, sp, #0
  SystemClock_Config();
 8029160:	f7e1 fdf8 	bl	800ad54 <SystemClock_Config>
}
 8029164:	bf00      	nop
 8029166:	bd80      	pop	{r7, pc}

08029168 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8029168:	b480      	push	{r7}
 802916a:	b085      	sub	sp, #20
 802916c:	af00      	add	r7, sp, #0
 802916e:	4603      	mov	r3, r0
 8029170:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8029172:	2300      	movs	r3, #0
 8029174:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 8029176:	79fb      	ldrb	r3, [r7, #7]
 8029178:	2b03      	cmp	r3, #3
 802917a:	d817      	bhi.n	80291ac <USBD_Get_USB_Status+0x44>
 802917c:	a201      	add	r2, pc, #4	; (adr r2, 8029184 <USBD_Get_USB_Status+0x1c>)
 802917e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8029182:	bf00      	nop
 8029184:	08029195 	.word	0x08029195
 8029188:	0802919b 	.word	0x0802919b
 802918c:	080291a1 	.word	0x080291a1
 8029190:	080291a7 	.word	0x080291a7
  {
    case HAL_OK :
      usb_status = USBD_OK;
 8029194:	2300      	movs	r3, #0
 8029196:	73fb      	strb	r3, [r7, #15]
    break;
 8029198:	e00b      	b.n	80291b2 <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 802919a:	2303      	movs	r3, #3
 802919c:	73fb      	strb	r3, [r7, #15]
    break;
 802919e:	e008      	b.n	80291b2 <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 80291a0:	2301      	movs	r3, #1
 80291a2:	73fb      	strb	r3, [r7, #15]
    break;
 80291a4:	e005      	b.n	80291b2 <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 80291a6:	2303      	movs	r3, #3
 80291a8:	73fb      	strb	r3, [r7, #15]
    break;
 80291aa:	e002      	b.n	80291b2 <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 80291ac:	2303      	movs	r3, #3
 80291ae:	73fb      	strb	r3, [r7, #15]
    break;
 80291b0:	bf00      	nop
  }
  return usb_status;
 80291b2:	7bfb      	ldrb	r3, [r7, #15]
}
 80291b4:	4618      	mov	r0, r3
 80291b6:	3714      	adds	r7, #20
 80291b8:	46bd      	mov	sp, r7
 80291ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80291be:	4770      	bx	lr

080291c0 <UTIL_LPM_Init>:

/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
 80291c0:	b480      	push	{r7}
 80291c2:	af00      	add	r7, sp, #0
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 80291c4:	4b05      	ldr	r3, [pc, #20]	; (80291dc <UTIL_LPM_Init+0x1c>)
 80291c6:	2200      	movs	r2, #0
 80291c8:	601a      	str	r2, [r3, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 80291ca:	4b05      	ldr	r3, [pc, #20]	; (80291e0 <UTIL_LPM_Init+0x20>)
 80291cc:	2200      	movs	r2, #0
 80291ce:	601a      	str	r2, [r3, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 80291d0:	bf00      	nop
 80291d2:	46bd      	mov	sp, r7
 80291d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80291d8:	4770      	bx	lr
 80291da:	bf00      	nop
 80291dc:	20010e28 	.word	0x20010e28
 80291e0:	20010e2c 	.word	0x20010e2c

080291e4 <UTIL_LPM_SetOffMode>:
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 80291e4:	b480      	push	{r7}
 80291e6:	b087      	sub	sp, #28
 80291e8:	af00      	add	r7, sp, #0
 80291ea:	6078      	str	r0, [r7, #4]
 80291ec:	460b      	mov	r3, r1
 80291ee:	70fb      	strb	r3, [r7, #3]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80291f0:	f3ef 8310 	mrs	r3, PRIMASK
 80291f4:	613b      	str	r3, [r7, #16]
  return(result);
 80291f6:	693b      	ldr	r3, [r7, #16]
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
 80291f8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80291fa:	b672      	cpsid	i
}
 80291fc:	bf00      	nop
  
  switch(state)
 80291fe:	78fb      	ldrb	r3, [r7, #3]
 8029200:	2b00      	cmp	r3, #0
 8029202:	d008      	beq.n	8029216 <UTIL_LPM_SetOffMode+0x32>
 8029204:	2b01      	cmp	r3, #1
 8029206:	d10e      	bne.n	8029226 <UTIL_LPM_SetOffMode+0x42>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8029208:	4b0d      	ldr	r3, [pc, #52]	; (8029240 <UTIL_LPM_SetOffMode+0x5c>)
 802920a:	681a      	ldr	r2, [r3, #0]
 802920c:	687b      	ldr	r3, [r7, #4]
 802920e:	4313      	orrs	r3, r2
 8029210:	4a0b      	ldr	r2, [pc, #44]	; (8029240 <UTIL_LPM_SetOffMode+0x5c>)
 8029212:	6013      	str	r3, [r2, #0]
      break;
 8029214:	e008      	b.n	8029228 <UTIL_LPM_SetOffMode+0x44>
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 8029216:	687b      	ldr	r3, [r7, #4]
 8029218:	43da      	mvns	r2, r3
 802921a:	4b09      	ldr	r3, [pc, #36]	; (8029240 <UTIL_LPM_SetOffMode+0x5c>)
 802921c:	681b      	ldr	r3, [r3, #0]
 802921e:	4013      	ands	r3, r2
 8029220:	4a07      	ldr	r2, [pc, #28]	; (8029240 <UTIL_LPM_SetOffMode+0x5c>)
 8029222:	6013      	str	r3, [r2, #0]
      break;
 8029224:	e000      	b.n	8029228 <UTIL_LPM_SetOffMode+0x44>
    }
  default :
    {
      break;
 8029226:	bf00      	nop
 8029228:	697b      	ldr	r3, [r7, #20]
 802922a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802922c:	68fb      	ldr	r3, [r7, #12]
 802922e:	f383 8810 	msr	PRIMASK, r3
}
 8029232:	bf00      	nop
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8029234:	bf00      	nop
 8029236:	371c      	adds	r7, #28
 8029238:	46bd      	mov	sp, r7
 802923a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802923e:	4770      	bx	lr
 8029240:	20010e2c 	.word	0x20010e2c

08029244 <_ZdlPvj>:
 8029244:	f000 b814 	b.w	8029270 <_ZdlPv>

08029248 <_Znwj>:
 8029248:	2801      	cmp	r0, #1
 802924a:	bf38      	it	cc
 802924c:	2001      	movcc	r0, #1
 802924e:	b510      	push	{r4, lr}
 8029250:	4604      	mov	r4, r0
 8029252:	4620      	mov	r0, r4
 8029254:	f002 ff34 	bl	802c0c0 <malloc>
 8029258:	b930      	cbnz	r0, 8029268 <_Znwj+0x20>
 802925a:	f000 f81d 	bl	8029298 <_ZSt15get_new_handlerv>
 802925e:	b908      	cbnz	r0, 8029264 <_Znwj+0x1c>
 8029260:	f002 fefa 	bl	802c058 <abort>
 8029264:	4780      	blx	r0
 8029266:	e7f4      	b.n	8029252 <_Znwj+0xa>
 8029268:	bd10      	pop	{r4, pc}

0802926a <__cxa_pure_virtual>:
 802926a:	b508      	push	{r3, lr}
 802926c:	f000 f80e 	bl	802928c <_ZSt9terminatev>

08029270 <_ZdlPv>:
 8029270:	f002 bf2e 	b.w	802c0d0 <free>

08029274 <_ZN10__cxxabiv111__terminateEPFvvE>:
 8029274:	b508      	push	{r3, lr}
 8029276:	4780      	blx	r0
 8029278:	f002 feee 	bl	802c058 <abort>

0802927c <_ZSt13get_terminatev>:
 802927c:	4b02      	ldr	r3, [pc, #8]	; (8029288 <_ZSt13get_terminatev+0xc>)
 802927e:	6818      	ldr	r0, [r3, #0]
 8029280:	f3bf 8f5b 	dmb	ish
 8029284:	4770      	bx	lr
 8029286:	bf00      	nop
 8029288:	200001ac 	.word	0x200001ac

0802928c <_ZSt9terminatev>:
 802928c:	b508      	push	{r3, lr}
 802928e:	f7ff fff5 	bl	802927c <_ZSt13get_terminatev>
 8029292:	f7ff ffef 	bl	8029274 <_ZN10__cxxabiv111__terminateEPFvvE>
	...

08029298 <_ZSt15get_new_handlerv>:
 8029298:	4b02      	ldr	r3, [pc, #8]	; (80292a4 <_ZSt15get_new_handlerv+0xc>)
 802929a:	6818      	ldr	r0, [r3, #0]
 802929c:	f3bf 8f5b 	dmb	ish
 80292a0:	4770      	bx	lr
 80292a2:	bf00      	nop
 80292a4:	20011e80 	.word	0x20011e80

080292a8 <ceil>:
 80292a8:	ec51 0b10 	vmov	r0, r1, d0
 80292ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80292b0:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80292b4:	f2a7 36ff 	subw	r6, r7, #1023	; 0x3ff
 80292b8:	2e13      	cmp	r6, #19
 80292ba:	ee10 5a10 	vmov	r5, s0
 80292be:	ee10 8a10 	vmov	r8, s0
 80292c2:	460c      	mov	r4, r1
 80292c4:	dc30      	bgt.n	8029328 <ceil+0x80>
 80292c6:	2e00      	cmp	r6, #0
 80292c8:	da12      	bge.n	80292f0 <ceil+0x48>
 80292ca:	a335      	add	r3, pc, #212	; (adr r3, 80293a0 <ceil+0xf8>)
 80292cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80292d0:	f7de fa5c 	bl	800778c <__adddf3>
 80292d4:	2200      	movs	r2, #0
 80292d6:	2300      	movs	r3, #0
 80292d8:	f7de fe9e 	bl	8008018 <__aeabi_dcmpgt>
 80292dc:	b128      	cbz	r0, 80292ea <ceil+0x42>
 80292de:	2c00      	cmp	r4, #0
 80292e0:	db55      	blt.n	802938e <ceil+0xe6>
 80292e2:	432c      	orrs	r4, r5
 80292e4:	d057      	beq.n	8029396 <ceil+0xee>
 80292e6:	4c30      	ldr	r4, [pc, #192]	; (80293a8 <ceil+0x100>)
 80292e8:	2500      	movs	r5, #0
 80292ea:	4621      	mov	r1, r4
 80292ec:	4628      	mov	r0, r5
 80292ee:	e025      	b.n	802933c <ceil+0x94>
 80292f0:	4f2e      	ldr	r7, [pc, #184]	; (80293ac <ceil+0x104>)
 80292f2:	4137      	asrs	r7, r6
 80292f4:	ea01 0307 	and.w	r3, r1, r7
 80292f8:	4303      	orrs	r3, r0
 80292fa:	d01f      	beq.n	802933c <ceil+0x94>
 80292fc:	a328      	add	r3, pc, #160	; (adr r3, 80293a0 <ceil+0xf8>)
 80292fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029302:	f7de fa43 	bl	800778c <__adddf3>
 8029306:	2200      	movs	r2, #0
 8029308:	2300      	movs	r3, #0
 802930a:	f7de fe85 	bl	8008018 <__aeabi_dcmpgt>
 802930e:	2800      	cmp	r0, #0
 8029310:	d0eb      	beq.n	80292ea <ceil+0x42>
 8029312:	2c00      	cmp	r4, #0
 8029314:	bfc2      	ittt	gt
 8029316:	f44f 1380 	movgt.w	r3, #1048576	; 0x100000
 802931a:	fa43 f606 	asrgt.w	r6, r3, r6
 802931e:	19a4      	addgt	r4, r4, r6
 8029320:	ea24 0407 	bic.w	r4, r4, r7
 8029324:	2500      	movs	r5, #0
 8029326:	e7e0      	b.n	80292ea <ceil+0x42>
 8029328:	2e33      	cmp	r6, #51	; 0x33
 802932a:	dd0b      	ble.n	8029344 <ceil+0x9c>
 802932c:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 8029330:	d104      	bne.n	802933c <ceil+0x94>
 8029332:	ee10 2a10 	vmov	r2, s0
 8029336:	460b      	mov	r3, r1
 8029338:	f7de fa28 	bl	800778c <__adddf3>
 802933c:	ec41 0b10 	vmov	d0, r0, r1
 8029340:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029344:	f2a7 4713 	subw	r7, r7, #1043	; 0x413
 8029348:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 802934c:	fa23 f707 	lsr.w	r7, r3, r7
 8029350:	4207      	tst	r7, r0
 8029352:	d0f3      	beq.n	802933c <ceil+0x94>
 8029354:	a312      	add	r3, pc, #72	; (adr r3, 80293a0 <ceil+0xf8>)
 8029356:	e9d3 2300 	ldrd	r2, r3, [r3]
 802935a:	f7de fa17 	bl	800778c <__adddf3>
 802935e:	2200      	movs	r2, #0
 8029360:	2300      	movs	r3, #0
 8029362:	f7de fe59 	bl	8008018 <__aeabi_dcmpgt>
 8029366:	2800      	cmp	r0, #0
 8029368:	d0bf      	beq.n	80292ea <ceil+0x42>
 802936a:	2c00      	cmp	r4, #0
 802936c:	dd02      	ble.n	8029374 <ceil+0xcc>
 802936e:	2e14      	cmp	r6, #20
 8029370:	d103      	bne.n	802937a <ceil+0xd2>
 8029372:	3401      	adds	r4, #1
 8029374:	ea25 0507 	bic.w	r5, r5, r7
 8029378:	e7b7      	b.n	80292ea <ceil+0x42>
 802937a:	2301      	movs	r3, #1
 802937c:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 8029380:	fa03 f606 	lsl.w	r6, r3, r6
 8029384:	4435      	add	r5, r6
 8029386:	4545      	cmp	r5, r8
 8029388:	bf38      	it	cc
 802938a:	18e4      	addcc	r4, r4, r3
 802938c:	e7f2      	b.n	8029374 <ceil+0xcc>
 802938e:	2500      	movs	r5, #0
 8029390:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8029394:	e7a9      	b.n	80292ea <ceil+0x42>
 8029396:	4625      	mov	r5, r4
 8029398:	e7a7      	b.n	80292ea <ceil+0x42>
 802939a:	bf00      	nop
 802939c:	f3af 8000 	nop.w
 80293a0:	8800759c 	.word	0x8800759c
 80293a4:	7e37e43c 	.word	0x7e37e43c
 80293a8:	3ff00000 	.word	0x3ff00000
 80293ac:	000fffff 	.word	0x000fffff

080293b0 <fabs>:
 80293b0:	ec51 0b10 	vmov	r0, r1, d0
 80293b4:	ee10 2a10 	vmov	r2, s0
 80293b8:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 80293bc:	ec43 2b10 	vmov	d0, r2, r3
 80293c0:	4770      	bx	lr
 80293c2:	0000      	movs	r0, r0
 80293c4:	0000      	movs	r0, r0
	...

080293c8 <floor>:
 80293c8:	ec51 0b10 	vmov	r0, r1, d0
 80293cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80293d0:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80293d4:	f2a7 36ff 	subw	r6, r7, #1023	; 0x3ff
 80293d8:	2e13      	cmp	r6, #19
 80293da:	ee10 5a10 	vmov	r5, s0
 80293de:	ee10 8a10 	vmov	r8, s0
 80293e2:	460c      	mov	r4, r1
 80293e4:	dc32      	bgt.n	802944c <floor+0x84>
 80293e6:	2e00      	cmp	r6, #0
 80293e8:	da14      	bge.n	8029414 <floor+0x4c>
 80293ea:	a333      	add	r3, pc, #204	; (adr r3, 80294b8 <floor+0xf0>)
 80293ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80293f0:	f7de f9cc 	bl	800778c <__adddf3>
 80293f4:	2200      	movs	r2, #0
 80293f6:	2300      	movs	r3, #0
 80293f8:	f7de fe0e 	bl	8008018 <__aeabi_dcmpgt>
 80293fc:	b138      	cbz	r0, 802940e <floor+0x46>
 80293fe:	2c00      	cmp	r4, #0
 8029400:	da57      	bge.n	80294b2 <floor+0xea>
 8029402:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 8029406:	431d      	orrs	r5, r3
 8029408:	d001      	beq.n	802940e <floor+0x46>
 802940a:	4c2d      	ldr	r4, [pc, #180]	; (80294c0 <floor+0xf8>)
 802940c:	2500      	movs	r5, #0
 802940e:	4621      	mov	r1, r4
 8029410:	4628      	mov	r0, r5
 8029412:	e025      	b.n	8029460 <floor+0x98>
 8029414:	4f2b      	ldr	r7, [pc, #172]	; (80294c4 <floor+0xfc>)
 8029416:	4137      	asrs	r7, r6
 8029418:	ea01 0307 	and.w	r3, r1, r7
 802941c:	4303      	orrs	r3, r0
 802941e:	d01f      	beq.n	8029460 <floor+0x98>
 8029420:	a325      	add	r3, pc, #148	; (adr r3, 80294b8 <floor+0xf0>)
 8029422:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029426:	f7de f9b1 	bl	800778c <__adddf3>
 802942a:	2200      	movs	r2, #0
 802942c:	2300      	movs	r3, #0
 802942e:	f7de fdf3 	bl	8008018 <__aeabi_dcmpgt>
 8029432:	2800      	cmp	r0, #0
 8029434:	d0eb      	beq.n	802940e <floor+0x46>
 8029436:	2c00      	cmp	r4, #0
 8029438:	bfbe      	ittt	lt
 802943a:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 802943e:	fa43 f606 	asrlt.w	r6, r3, r6
 8029442:	19a4      	addlt	r4, r4, r6
 8029444:	ea24 0407 	bic.w	r4, r4, r7
 8029448:	2500      	movs	r5, #0
 802944a:	e7e0      	b.n	802940e <floor+0x46>
 802944c:	2e33      	cmp	r6, #51	; 0x33
 802944e:	dd0b      	ble.n	8029468 <floor+0xa0>
 8029450:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 8029454:	d104      	bne.n	8029460 <floor+0x98>
 8029456:	ee10 2a10 	vmov	r2, s0
 802945a:	460b      	mov	r3, r1
 802945c:	f7de f996 	bl	800778c <__adddf3>
 8029460:	ec41 0b10 	vmov	d0, r0, r1
 8029464:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029468:	f2a7 4713 	subw	r7, r7, #1043	; 0x413
 802946c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8029470:	fa23 f707 	lsr.w	r7, r3, r7
 8029474:	4207      	tst	r7, r0
 8029476:	d0f3      	beq.n	8029460 <floor+0x98>
 8029478:	a30f      	add	r3, pc, #60	; (adr r3, 80294b8 <floor+0xf0>)
 802947a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802947e:	f7de f985 	bl	800778c <__adddf3>
 8029482:	2200      	movs	r2, #0
 8029484:	2300      	movs	r3, #0
 8029486:	f7de fdc7 	bl	8008018 <__aeabi_dcmpgt>
 802948a:	2800      	cmp	r0, #0
 802948c:	d0bf      	beq.n	802940e <floor+0x46>
 802948e:	2c00      	cmp	r4, #0
 8029490:	da02      	bge.n	8029498 <floor+0xd0>
 8029492:	2e14      	cmp	r6, #20
 8029494:	d103      	bne.n	802949e <floor+0xd6>
 8029496:	3401      	adds	r4, #1
 8029498:	ea25 0507 	bic.w	r5, r5, r7
 802949c:	e7b7      	b.n	802940e <floor+0x46>
 802949e:	2301      	movs	r3, #1
 80294a0:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 80294a4:	fa03 f606 	lsl.w	r6, r3, r6
 80294a8:	4435      	add	r5, r6
 80294aa:	4545      	cmp	r5, r8
 80294ac:	bf38      	it	cc
 80294ae:	18e4      	addcc	r4, r4, r3
 80294b0:	e7f2      	b.n	8029498 <floor+0xd0>
 80294b2:	2500      	movs	r5, #0
 80294b4:	462c      	mov	r4, r5
 80294b6:	e7aa      	b.n	802940e <floor+0x46>
 80294b8:	8800759c 	.word	0x8800759c
 80294bc:	7e37e43c 	.word	0x7e37e43c
 80294c0:	bff00000 	.word	0xbff00000
 80294c4:	000fffff 	.word	0x000fffff

080294c8 <trunc>:
 80294c8:	ec51 0b10 	vmov	r0, r1, d0
 80294cc:	f3c1 520a 	ubfx	r2, r1, #20, #11
 80294d0:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
 80294d4:	2b13      	cmp	r3, #19
 80294d6:	b5d0      	push	{r4, r6, r7, lr}
 80294d8:	460c      	mov	r4, r1
 80294da:	dc10      	bgt.n	80294fe <trunc+0x36>
 80294dc:	2b00      	cmp	r3, #0
 80294de:	bfa5      	ittet	ge
 80294e0:	4a11      	ldrge	r2, [pc, #68]	; (8029528 <trunc+0x60>)
 80294e2:	fa42 f303 	asrge.w	r3, r2, r3
 80294e6:	2100      	movlt	r1, #0
 80294e8:	2100      	movge	r1, #0
 80294ea:	bfb9      	ittee	lt
 80294ec:	2000      	movlt	r0, #0
 80294ee:	f004 4100 	andlt.w	r1, r4, #2147483648	; 0x80000000
 80294f2:	2000      	movge	r0, #0
 80294f4:	ea24 0103 	bicge.w	r1, r4, r3
 80294f8:	ec41 0b10 	vmov	d0, r0, r1
 80294fc:	bdd0      	pop	{r4, r6, r7, pc}
 80294fe:	2b33      	cmp	r3, #51	; 0x33
 8029500:	dd08      	ble.n	8029514 <trunc+0x4c>
 8029502:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8029506:	d1f7      	bne.n	80294f8 <trunc+0x30>
 8029508:	ee10 2a10 	vmov	r2, s0
 802950c:	460b      	mov	r3, r1
 802950e:	f7de f93d 	bl	800778c <__adddf3>
 8029512:	e7f1      	b.n	80294f8 <trunc+0x30>
 8029514:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
 8029518:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 802951c:	fa23 f202 	lsr.w	r2, r3, r2
 8029520:	ea20 0602 	bic.w	r6, r0, r2
 8029524:	4630      	mov	r0, r6
 8029526:	e7e7      	b.n	80294f8 <trunc+0x30>
 8029528:	000fffff 	.word	0x000fffff

0802952c <fabsf>:
 802952c:	ee10 3a10 	vmov	r3, s0
 8029530:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8029534:	ee00 3a10 	vmov	s0, r3
 8029538:	4770      	bx	lr
	...

0802953c <floorf>:
 802953c:	ee10 3a10 	vmov	r3, s0
 8029540:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8029544:	3a7f      	subs	r2, #127	; 0x7f
 8029546:	2a16      	cmp	r2, #22
 8029548:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802954c:	dc2a      	bgt.n	80295a4 <floorf+0x68>
 802954e:	2a00      	cmp	r2, #0
 8029550:	da11      	bge.n	8029576 <floorf+0x3a>
 8029552:	eddf 7a18 	vldr	s15, [pc, #96]	; 80295b4 <floorf+0x78>
 8029556:	ee30 0a27 	vadd.f32	s0, s0, s15
 802955a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802955e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029562:	dd05      	ble.n	8029570 <floorf+0x34>
 8029564:	2b00      	cmp	r3, #0
 8029566:	da23      	bge.n	80295b0 <floorf+0x74>
 8029568:	4a13      	ldr	r2, [pc, #76]	; (80295b8 <floorf+0x7c>)
 802956a:	2900      	cmp	r1, #0
 802956c:	bf18      	it	ne
 802956e:	4613      	movne	r3, r2
 8029570:	ee00 3a10 	vmov	s0, r3
 8029574:	4770      	bx	lr
 8029576:	4911      	ldr	r1, [pc, #68]	; (80295bc <floorf+0x80>)
 8029578:	4111      	asrs	r1, r2
 802957a:	420b      	tst	r3, r1
 802957c:	d0fa      	beq.n	8029574 <floorf+0x38>
 802957e:	eddf 7a0d 	vldr	s15, [pc, #52]	; 80295b4 <floorf+0x78>
 8029582:	ee30 0a27 	vadd.f32	s0, s0, s15
 8029586:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802958a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802958e:	ddef      	ble.n	8029570 <floorf+0x34>
 8029590:	2b00      	cmp	r3, #0
 8029592:	bfbe      	ittt	lt
 8029594:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 8029598:	fa40 f202 	asrlt.w	r2, r0, r2
 802959c:	189b      	addlt	r3, r3, r2
 802959e:	ea23 0301 	bic.w	r3, r3, r1
 80295a2:	e7e5      	b.n	8029570 <floorf+0x34>
 80295a4:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 80295a8:	d3e4      	bcc.n	8029574 <floorf+0x38>
 80295aa:	ee30 0a00 	vadd.f32	s0, s0, s0
 80295ae:	4770      	bx	lr
 80295b0:	2300      	movs	r3, #0
 80295b2:	e7dd      	b.n	8029570 <floorf+0x34>
 80295b4:	7149f2ca 	.word	0x7149f2ca
 80295b8:	bf800000 	.word	0xbf800000
 80295bc:	007fffff 	.word	0x007fffff

080295c0 <fmaxf>:
 80295c0:	b508      	push	{r3, lr}
 80295c2:	ed2d 8b02 	vpush	{d8}
 80295c6:	eeb0 8a40 	vmov.f32	s16, s0
 80295ca:	eef0 8a60 	vmov.f32	s17, s1
 80295ce:	f000 f82d 	bl	802962c <__fpclassifyf>
 80295d2:	b148      	cbz	r0, 80295e8 <fmaxf+0x28>
 80295d4:	eeb0 0a68 	vmov.f32	s0, s17
 80295d8:	f000 f828 	bl	802962c <__fpclassifyf>
 80295dc:	b130      	cbz	r0, 80295ec <fmaxf+0x2c>
 80295de:	eeb4 8ae8 	vcmpe.f32	s16, s17
 80295e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80295e6:	dc01      	bgt.n	80295ec <fmaxf+0x2c>
 80295e8:	eeb0 8a68 	vmov.f32	s16, s17
 80295ec:	eeb0 0a48 	vmov.f32	s0, s16
 80295f0:	ecbd 8b02 	vpop	{d8}
 80295f4:	bd08      	pop	{r3, pc}

080295f6 <fminf>:
 80295f6:	b508      	push	{r3, lr}
 80295f8:	ed2d 8b02 	vpush	{d8}
 80295fc:	eeb0 8a40 	vmov.f32	s16, s0
 8029600:	eef0 8a60 	vmov.f32	s17, s1
 8029604:	f000 f812 	bl	802962c <__fpclassifyf>
 8029608:	b148      	cbz	r0, 802961e <fminf+0x28>
 802960a:	eeb0 0a68 	vmov.f32	s0, s17
 802960e:	f000 f80d 	bl	802962c <__fpclassifyf>
 8029612:	b130      	cbz	r0, 8029622 <fminf+0x2c>
 8029614:	eeb4 8ae8 	vcmpe.f32	s16, s17
 8029618:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802961c:	d401      	bmi.n	8029622 <fminf+0x2c>
 802961e:	eeb0 8a68 	vmov.f32	s16, s17
 8029622:	eeb0 0a48 	vmov.f32	s0, s16
 8029626:	ecbd 8b02 	vpop	{d8}
 802962a:	bd08      	pop	{r3, pc}

0802962c <__fpclassifyf>:
 802962c:	ee10 3a10 	vmov	r3, s0
 8029630:	f033 4000 	bics.w	r0, r3, #2147483648	; 0x80000000
 8029634:	d00d      	beq.n	8029652 <__fpclassifyf+0x26>
 8029636:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 802963a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802963e:	d30a      	bcc.n	8029656 <__fpclassifyf+0x2a>
 8029640:	4b07      	ldr	r3, [pc, #28]	; (8029660 <__fpclassifyf+0x34>)
 8029642:	1e42      	subs	r2, r0, #1
 8029644:	429a      	cmp	r2, r3
 8029646:	d908      	bls.n	802965a <__fpclassifyf+0x2e>
 8029648:	f1a0 43ff 	sub.w	r3, r0, #2139095040	; 0x7f800000
 802964c:	4258      	negs	r0, r3
 802964e:	4158      	adcs	r0, r3
 8029650:	4770      	bx	lr
 8029652:	2002      	movs	r0, #2
 8029654:	4770      	bx	lr
 8029656:	2004      	movs	r0, #4
 8029658:	4770      	bx	lr
 802965a:	2003      	movs	r0, #3
 802965c:	4770      	bx	lr
 802965e:	bf00      	nop
 8029660:	007ffffe 	.word	0x007ffffe

08029664 <roundf>:
 8029664:	ee10 0a10 	vmov	r0, s0
 8029668:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 802966c:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
 8029670:	2a16      	cmp	r2, #22
 8029672:	dc15      	bgt.n	80296a0 <roundf+0x3c>
 8029674:	2a00      	cmp	r2, #0
 8029676:	da08      	bge.n	802968a <roundf+0x26>
 8029678:	3201      	adds	r2, #1
 802967a:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802967e:	d101      	bne.n	8029684 <roundf+0x20>
 8029680:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
 8029684:	ee00 3a10 	vmov	s0, r3
 8029688:	4770      	bx	lr
 802968a:	4908      	ldr	r1, [pc, #32]	; (80296ac <roundf+0x48>)
 802968c:	4111      	asrs	r1, r2
 802968e:	4208      	tst	r0, r1
 8029690:	d0fa      	beq.n	8029688 <roundf+0x24>
 8029692:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8029696:	4113      	asrs	r3, r2
 8029698:	4403      	add	r3, r0
 802969a:	ea23 0301 	bic.w	r3, r3, r1
 802969e:	e7f1      	b.n	8029684 <roundf+0x20>
 80296a0:	2a80      	cmp	r2, #128	; 0x80
 80296a2:	d1f1      	bne.n	8029688 <roundf+0x24>
 80296a4:	ee30 0a00 	vadd.f32	s0, s0, s0
 80296a8:	4770      	bx	lr
 80296aa:	bf00      	nop
 80296ac:	007fffff 	.word	0x007fffff

080296b0 <sinf>:
 80296b0:	ee10 3a10 	vmov	r3, s0
 80296b4:	b507      	push	{r0, r1, r2, lr}
 80296b6:	4a1d      	ldr	r2, [pc, #116]	; (802972c <sinf+0x7c>)
 80296b8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80296bc:	4293      	cmp	r3, r2
 80296be:	dc05      	bgt.n	80296cc <sinf+0x1c>
 80296c0:	eddf 0a1b 	vldr	s1, [pc, #108]	; 8029730 <sinf+0x80>
 80296c4:	2000      	movs	r0, #0
 80296c6:	f002 fa77 	bl	802bbb8 <__kernel_sinf>
 80296ca:	e004      	b.n	80296d6 <sinf+0x26>
 80296cc:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80296d0:	db04      	blt.n	80296dc <sinf+0x2c>
 80296d2:	ee30 0a40 	vsub.f32	s0, s0, s0
 80296d6:	b003      	add	sp, #12
 80296d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80296dc:	4668      	mov	r0, sp
 80296de:	f001 fe41 	bl	802b364 <__ieee754_rem_pio2f>
 80296e2:	f000 0003 	and.w	r0, r0, #3
 80296e6:	2801      	cmp	r0, #1
 80296e8:	d008      	beq.n	80296fc <sinf+0x4c>
 80296ea:	2802      	cmp	r0, #2
 80296ec:	d00d      	beq.n	802970a <sinf+0x5a>
 80296ee:	b9b0      	cbnz	r0, 802971e <sinf+0x6e>
 80296f0:	eddd 0a01 	vldr	s1, [sp, #4]
 80296f4:	ed9d 0a00 	vldr	s0, [sp]
 80296f8:	2001      	movs	r0, #1
 80296fa:	e7e4      	b.n	80296c6 <sinf+0x16>
 80296fc:	eddd 0a01 	vldr	s1, [sp, #4]
 8029700:	ed9d 0a00 	vldr	s0, [sp]
 8029704:	f001 ff6e 	bl	802b5e4 <__kernel_cosf>
 8029708:	e7e5      	b.n	80296d6 <sinf+0x26>
 802970a:	eddd 0a01 	vldr	s1, [sp, #4]
 802970e:	ed9d 0a00 	vldr	s0, [sp]
 8029712:	2001      	movs	r0, #1
 8029714:	f002 fa50 	bl	802bbb8 <__kernel_sinf>
 8029718:	eeb1 0a40 	vneg.f32	s0, s0
 802971c:	e7db      	b.n	80296d6 <sinf+0x26>
 802971e:	eddd 0a01 	vldr	s1, [sp, #4]
 8029722:	ed9d 0a00 	vldr	s0, [sp]
 8029726:	f001 ff5d 	bl	802b5e4 <__kernel_cosf>
 802972a:	e7f5      	b.n	8029718 <sinf+0x68>
 802972c:	3f490fd8 	.word	0x3f490fd8
 8029730:	00000000 	.word	0x00000000

08029734 <fmod>:
 8029734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029736:	ed2d 8b02 	vpush	{d8}
 802973a:	ec57 6b10 	vmov	r6, r7, d0
 802973e:	ec55 4b11 	vmov	r4, r5, d1
 8029742:	f000 fa49 	bl	8029bd8 <__ieee754_fmod>
 8029746:	4b18      	ldr	r3, [pc, #96]	; (80297a8 <fmod+0x74>)
 8029748:	eeb0 8a40 	vmov.f32	s16, s0
 802974c:	eef0 8a60 	vmov.f32	s17, s1
 8029750:	f993 3000 	ldrsb.w	r3, [r3]
 8029754:	3301      	adds	r3, #1
 8029756:	d020      	beq.n	802979a <fmod+0x66>
 8029758:	4622      	mov	r2, r4
 802975a:	462b      	mov	r3, r5
 802975c:	4620      	mov	r0, r4
 802975e:	4629      	mov	r1, r5
 8029760:	f7de fc64 	bl	800802c <__aeabi_dcmpun>
 8029764:	b9c8      	cbnz	r0, 802979a <fmod+0x66>
 8029766:	4632      	mov	r2, r6
 8029768:	463b      	mov	r3, r7
 802976a:	4630      	mov	r0, r6
 802976c:	4639      	mov	r1, r7
 802976e:	f7de fc5d 	bl	800802c <__aeabi_dcmpun>
 8029772:	b990      	cbnz	r0, 802979a <fmod+0x66>
 8029774:	2200      	movs	r2, #0
 8029776:	2300      	movs	r3, #0
 8029778:	4620      	mov	r0, r4
 802977a:	4629      	mov	r1, r5
 802977c:	f7de fc24 	bl	8007fc8 <__aeabi_dcmpeq>
 8029780:	b158      	cbz	r0, 802979a <fmod+0x66>
 8029782:	f002 fc71 	bl	802c068 <__errno>
 8029786:	2321      	movs	r3, #33	; 0x21
 8029788:	6003      	str	r3, [r0, #0]
 802978a:	2200      	movs	r2, #0
 802978c:	2300      	movs	r3, #0
 802978e:	4610      	mov	r0, r2
 8029790:	4619      	mov	r1, r3
 8029792:	f7de fadb 	bl	8007d4c <__aeabi_ddiv>
 8029796:	ec41 0b18 	vmov	d8, r0, r1
 802979a:	eeb0 0a48 	vmov.f32	s0, s16
 802979e:	eef0 0a68 	vmov.f32	s1, s17
 80297a2:	ecbd 8b02 	vpop	{d8}
 80297a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80297a8:	200001b0 	.word	0x200001b0

080297ac <pow>:
 80297ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80297b0:	ec59 8b10 	vmov	r8, r9, d0
 80297b4:	ec57 6b11 	vmov	r6, r7, d1
 80297b8:	f000 fb22 	bl	8029e00 <__ieee754_pow>
 80297bc:	4b4e      	ldr	r3, [pc, #312]	; (80298f8 <pow+0x14c>)
 80297be:	f993 3000 	ldrsb.w	r3, [r3]
 80297c2:	3301      	adds	r3, #1
 80297c4:	ec55 4b10 	vmov	r4, r5, d0
 80297c8:	d015      	beq.n	80297f6 <pow+0x4a>
 80297ca:	4632      	mov	r2, r6
 80297cc:	463b      	mov	r3, r7
 80297ce:	4630      	mov	r0, r6
 80297d0:	4639      	mov	r1, r7
 80297d2:	f7de fc2b 	bl	800802c <__aeabi_dcmpun>
 80297d6:	b970      	cbnz	r0, 80297f6 <pow+0x4a>
 80297d8:	4642      	mov	r2, r8
 80297da:	464b      	mov	r3, r9
 80297dc:	4640      	mov	r0, r8
 80297de:	4649      	mov	r1, r9
 80297e0:	f7de fc24 	bl	800802c <__aeabi_dcmpun>
 80297e4:	2200      	movs	r2, #0
 80297e6:	2300      	movs	r3, #0
 80297e8:	b148      	cbz	r0, 80297fe <pow+0x52>
 80297ea:	4630      	mov	r0, r6
 80297ec:	4639      	mov	r1, r7
 80297ee:	f7de fbeb 	bl	8007fc8 <__aeabi_dcmpeq>
 80297f2:	2800      	cmp	r0, #0
 80297f4:	d17d      	bne.n	80298f2 <pow+0x146>
 80297f6:	ec45 4b10 	vmov	d0, r4, r5
 80297fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80297fe:	4640      	mov	r0, r8
 8029800:	4649      	mov	r1, r9
 8029802:	f7de fbe1 	bl	8007fc8 <__aeabi_dcmpeq>
 8029806:	b1e0      	cbz	r0, 8029842 <pow+0x96>
 8029808:	2200      	movs	r2, #0
 802980a:	2300      	movs	r3, #0
 802980c:	4630      	mov	r0, r6
 802980e:	4639      	mov	r1, r7
 8029810:	f7de fbda 	bl	8007fc8 <__aeabi_dcmpeq>
 8029814:	2800      	cmp	r0, #0
 8029816:	d16c      	bne.n	80298f2 <pow+0x146>
 8029818:	ec47 6b10 	vmov	d0, r6, r7
 802981c:	f002 fa14 	bl	802bc48 <finite>
 8029820:	2800      	cmp	r0, #0
 8029822:	d0e8      	beq.n	80297f6 <pow+0x4a>
 8029824:	2200      	movs	r2, #0
 8029826:	2300      	movs	r3, #0
 8029828:	4630      	mov	r0, r6
 802982a:	4639      	mov	r1, r7
 802982c:	f7de fbd6 	bl	8007fdc <__aeabi_dcmplt>
 8029830:	2800      	cmp	r0, #0
 8029832:	d0e0      	beq.n	80297f6 <pow+0x4a>
 8029834:	f002 fc18 	bl	802c068 <__errno>
 8029838:	2321      	movs	r3, #33	; 0x21
 802983a:	6003      	str	r3, [r0, #0]
 802983c:	2400      	movs	r4, #0
 802983e:	4d2f      	ldr	r5, [pc, #188]	; (80298fc <pow+0x150>)
 8029840:	e7d9      	b.n	80297f6 <pow+0x4a>
 8029842:	ec45 4b10 	vmov	d0, r4, r5
 8029846:	f002 f9ff 	bl	802bc48 <finite>
 802984a:	bbb8      	cbnz	r0, 80298bc <pow+0x110>
 802984c:	ec49 8b10 	vmov	d0, r8, r9
 8029850:	f002 f9fa 	bl	802bc48 <finite>
 8029854:	b390      	cbz	r0, 80298bc <pow+0x110>
 8029856:	ec47 6b10 	vmov	d0, r6, r7
 802985a:	f002 f9f5 	bl	802bc48 <finite>
 802985e:	b368      	cbz	r0, 80298bc <pow+0x110>
 8029860:	4622      	mov	r2, r4
 8029862:	462b      	mov	r3, r5
 8029864:	4620      	mov	r0, r4
 8029866:	4629      	mov	r1, r5
 8029868:	f7de fbe0 	bl	800802c <__aeabi_dcmpun>
 802986c:	b160      	cbz	r0, 8029888 <pow+0xdc>
 802986e:	f002 fbfb 	bl	802c068 <__errno>
 8029872:	2321      	movs	r3, #33	; 0x21
 8029874:	6003      	str	r3, [r0, #0]
 8029876:	2200      	movs	r2, #0
 8029878:	2300      	movs	r3, #0
 802987a:	4610      	mov	r0, r2
 802987c:	4619      	mov	r1, r3
 802987e:	f7de fa65 	bl	8007d4c <__aeabi_ddiv>
 8029882:	4604      	mov	r4, r0
 8029884:	460d      	mov	r5, r1
 8029886:	e7b6      	b.n	80297f6 <pow+0x4a>
 8029888:	f002 fbee 	bl	802c068 <__errno>
 802988c:	2322      	movs	r3, #34	; 0x22
 802988e:	6003      	str	r3, [r0, #0]
 8029890:	2200      	movs	r2, #0
 8029892:	2300      	movs	r3, #0
 8029894:	4640      	mov	r0, r8
 8029896:	4649      	mov	r1, r9
 8029898:	f7de fba0 	bl	8007fdc <__aeabi_dcmplt>
 802989c:	2400      	movs	r4, #0
 802989e:	b158      	cbz	r0, 80298b8 <pow+0x10c>
 80298a0:	ec47 6b10 	vmov	d0, r6, r7
 80298a4:	f002 f9e4 	bl	802bc70 <rint>
 80298a8:	4632      	mov	r2, r6
 80298aa:	ec51 0b10 	vmov	r0, r1, d0
 80298ae:	463b      	mov	r3, r7
 80298b0:	f7de fb8a 	bl	8007fc8 <__aeabi_dcmpeq>
 80298b4:	2800      	cmp	r0, #0
 80298b6:	d0c2      	beq.n	802983e <pow+0x92>
 80298b8:	4d11      	ldr	r5, [pc, #68]	; (8029900 <pow+0x154>)
 80298ba:	e79c      	b.n	80297f6 <pow+0x4a>
 80298bc:	2200      	movs	r2, #0
 80298be:	2300      	movs	r3, #0
 80298c0:	4620      	mov	r0, r4
 80298c2:	4629      	mov	r1, r5
 80298c4:	f7de fb80 	bl	8007fc8 <__aeabi_dcmpeq>
 80298c8:	2800      	cmp	r0, #0
 80298ca:	d094      	beq.n	80297f6 <pow+0x4a>
 80298cc:	ec49 8b10 	vmov	d0, r8, r9
 80298d0:	f002 f9ba 	bl	802bc48 <finite>
 80298d4:	2800      	cmp	r0, #0
 80298d6:	d08e      	beq.n	80297f6 <pow+0x4a>
 80298d8:	ec47 6b10 	vmov	d0, r6, r7
 80298dc:	f002 f9b4 	bl	802bc48 <finite>
 80298e0:	2800      	cmp	r0, #0
 80298e2:	d088      	beq.n	80297f6 <pow+0x4a>
 80298e4:	f002 fbc0 	bl	802c068 <__errno>
 80298e8:	2322      	movs	r3, #34	; 0x22
 80298ea:	6003      	str	r3, [r0, #0]
 80298ec:	2400      	movs	r4, #0
 80298ee:	2500      	movs	r5, #0
 80298f0:	e781      	b.n	80297f6 <pow+0x4a>
 80298f2:	4d04      	ldr	r5, [pc, #16]	; (8029904 <pow+0x158>)
 80298f4:	2400      	movs	r4, #0
 80298f6:	e77e      	b.n	80297f6 <pow+0x4a>
 80298f8:	200001b0 	.word	0x200001b0
 80298fc:	fff00000 	.word	0xfff00000
 8029900:	7ff00000 	.word	0x7ff00000
 8029904:	3ff00000 	.word	0x3ff00000

08029908 <expf>:
 8029908:	b508      	push	{r3, lr}
 802990a:	ed2d 8b02 	vpush	{d8}
 802990e:	eef0 8a40 	vmov.f32	s17, s0
 8029912:	f001 f84b 	bl	802a9ac <__ieee754_expf>
 8029916:	4b16      	ldr	r3, [pc, #88]	; (8029970 <expf+0x68>)
 8029918:	f993 3000 	ldrsb.w	r3, [r3]
 802991c:	3301      	adds	r3, #1
 802991e:	eeb0 8a40 	vmov.f32	s16, s0
 8029922:	d011      	beq.n	8029948 <expf+0x40>
 8029924:	eeb0 0a68 	vmov.f32	s0, s17
 8029928:	f002 fab4 	bl	802be94 <finitef>
 802992c:	b160      	cbz	r0, 8029948 <expf+0x40>
 802992e:	eddf 7a11 	vldr	s15, [pc, #68]	; 8029974 <expf+0x6c>
 8029932:	eef4 8ae7 	vcmpe.f32	s17, s15
 8029936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802993a:	dd0a      	ble.n	8029952 <expf+0x4a>
 802993c:	f002 fb94 	bl	802c068 <__errno>
 8029940:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 8029978 <expf+0x70>
 8029944:	2322      	movs	r3, #34	; 0x22
 8029946:	6003      	str	r3, [r0, #0]
 8029948:	eeb0 0a48 	vmov.f32	s0, s16
 802994c:	ecbd 8b02 	vpop	{d8}
 8029950:	bd08      	pop	{r3, pc}
 8029952:	eddf 7a0a 	vldr	s15, [pc, #40]	; 802997c <expf+0x74>
 8029956:	eef4 8ae7 	vcmpe.f32	s17, s15
 802995a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802995e:	d5f3      	bpl.n	8029948 <expf+0x40>
 8029960:	f002 fb82 	bl	802c068 <__errno>
 8029964:	2322      	movs	r3, #34	; 0x22
 8029966:	ed9f 8a06 	vldr	s16, [pc, #24]	; 8029980 <expf+0x78>
 802996a:	6003      	str	r3, [r0, #0]
 802996c:	e7ec      	b.n	8029948 <expf+0x40>
 802996e:	bf00      	nop
 8029970:	200001b0 	.word	0x200001b0
 8029974:	42b17180 	.word	0x42b17180
 8029978:	7f800000 	.word	0x7f800000
 802997c:	c2cff1b5 	.word	0xc2cff1b5
 8029980:	00000000 	.word	0x00000000

08029984 <logf>:
 8029984:	b508      	push	{r3, lr}
 8029986:	ed2d 8b02 	vpush	{d8}
 802998a:	eeb0 8a40 	vmov.f32	s16, s0
 802998e:	f001 f8e1 	bl	802ab54 <__ieee754_logf>
 8029992:	4b14      	ldr	r3, [pc, #80]	; (80299e4 <logf+0x60>)
 8029994:	f993 3000 	ldrsb.w	r3, [r3]
 8029998:	3301      	adds	r3, #1
 802999a:	d014      	beq.n	80299c6 <logf+0x42>
 802999c:	eeb4 8a48 	vcmp.f32	s16, s16
 80299a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80299a4:	d60f      	bvs.n	80299c6 <logf+0x42>
 80299a6:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80299aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80299ae:	dc0a      	bgt.n	80299c6 <logf+0x42>
 80299b0:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80299b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80299b8:	d108      	bne.n	80299cc <logf+0x48>
 80299ba:	f002 fb55 	bl	802c068 <__errno>
 80299be:	2322      	movs	r3, #34	; 0x22
 80299c0:	ed9f 0a09 	vldr	s0, [pc, #36]	; 80299e8 <logf+0x64>
 80299c4:	6003      	str	r3, [r0, #0]
 80299c6:	ecbd 8b02 	vpop	{d8}
 80299ca:	bd08      	pop	{r3, pc}
 80299cc:	f002 fb4c 	bl	802c068 <__errno>
 80299d0:	ecbd 8b02 	vpop	{d8}
 80299d4:	2321      	movs	r3, #33	; 0x21
 80299d6:	6003      	str	r3, [r0, #0]
 80299d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80299dc:	4803      	ldr	r0, [pc, #12]	; (80299ec <logf+0x68>)
 80299de:	f002 ba67 	b.w	802beb0 <nanf>
 80299e2:	bf00      	nop
 80299e4:	200001b0 	.word	0x200001b0
 80299e8:	ff800000 	.word	0xff800000
 80299ec:	0802d8f0 	.word	0x0802d8f0

080299f0 <log10f>:
 80299f0:	b508      	push	{r3, lr}
 80299f2:	ed2d 8b02 	vpush	{d8}
 80299f6:	eeb0 8a40 	vmov.f32	s16, s0
 80299fa:	f001 f99b 	bl	802ad34 <__ieee754_log10f>
 80299fe:	4b14      	ldr	r3, [pc, #80]	; (8029a50 <log10f+0x60>)
 8029a00:	f993 3000 	ldrsb.w	r3, [r3]
 8029a04:	3301      	adds	r3, #1
 8029a06:	d014      	beq.n	8029a32 <log10f+0x42>
 8029a08:	eeb4 8a48 	vcmp.f32	s16, s16
 8029a0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a10:	d60f      	bvs.n	8029a32 <log10f+0x42>
 8029a12:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8029a16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a1a:	d80a      	bhi.n	8029a32 <log10f+0x42>
 8029a1c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8029a20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a24:	d108      	bne.n	8029a38 <log10f+0x48>
 8029a26:	f002 fb1f 	bl	802c068 <__errno>
 8029a2a:	2322      	movs	r3, #34	; 0x22
 8029a2c:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8029a54 <log10f+0x64>
 8029a30:	6003      	str	r3, [r0, #0]
 8029a32:	ecbd 8b02 	vpop	{d8}
 8029a36:	bd08      	pop	{r3, pc}
 8029a38:	f002 fb16 	bl	802c068 <__errno>
 8029a3c:	ecbd 8b02 	vpop	{d8}
 8029a40:	2321      	movs	r3, #33	; 0x21
 8029a42:	6003      	str	r3, [r0, #0]
 8029a44:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8029a48:	4803      	ldr	r0, [pc, #12]	; (8029a58 <log10f+0x68>)
 8029a4a:	f002 ba31 	b.w	802beb0 <nanf>
 8029a4e:	bf00      	nop
 8029a50:	200001b0 	.word	0x200001b0
 8029a54:	ff800000 	.word	0xff800000
 8029a58:	0802d8f0 	.word	0x0802d8f0

08029a5c <powf>:
 8029a5c:	b508      	push	{r3, lr}
 8029a5e:	ed2d 8b04 	vpush	{d8-d9}
 8029a62:	eeb0 9a40 	vmov.f32	s18, s0
 8029a66:	eef0 8a60 	vmov.f32	s17, s1
 8029a6a:	f001 f9bb 	bl	802ade4 <__ieee754_powf>
 8029a6e:	4b43      	ldr	r3, [pc, #268]	; (8029b7c <powf+0x120>)
 8029a70:	f993 3000 	ldrsb.w	r3, [r3]
 8029a74:	3301      	adds	r3, #1
 8029a76:	eeb0 8a40 	vmov.f32	s16, s0
 8029a7a:	d012      	beq.n	8029aa2 <powf+0x46>
 8029a7c:	eef4 8a68 	vcmp.f32	s17, s17
 8029a80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a84:	d60d      	bvs.n	8029aa2 <powf+0x46>
 8029a86:	eeb4 9a49 	vcmp.f32	s18, s18
 8029a8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a8e:	d70d      	bvc.n	8029aac <powf+0x50>
 8029a90:	eef5 8a40 	vcmp.f32	s17, #0.0
 8029a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029a98:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8029a9c:	bf08      	it	eq
 8029a9e:	eeb0 8a67 	vmoveq.f32	s16, s15
 8029aa2:	eeb0 0a48 	vmov.f32	s0, s16
 8029aa6:	ecbd 8b04 	vpop	{d8-d9}
 8029aaa:	bd08      	pop	{r3, pc}
 8029aac:	eddf 9a34 	vldr	s19, [pc, #208]	; 8029b80 <powf+0x124>
 8029ab0:	eeb4 9a69 	vcmp.f32	s18, s19
 8029ab4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029ab8:	d116      	bne.n	8029ae8 <powf+0x8c>
 8029aba:	eef4 8a69 	vcmp.f32	s17, s19
 8029abe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029ac2:	d057      	beq.n	8029b74 <powf+0x118>
 8029ac4:	eeb0 0a68 	vmov.f32	s0, s17
 8029ac8:	f002 f9e4 	bl	802be94 <finitef>
 8029acc:	2800      	cmp	r0, #0
 8029ace:	d0e8      	beq.n	8029aa2 <powf+0x46>
 8029ad0:	eef4 8ae9 	vcmpe.f32	s17, s19
 8029ad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029ad8:	d5e3      	bpl.n	8029aa2 <powf+0x46>
 8029ada:	f002 fac5 	bl	802c068 <__errno>
 8029ade:	2321      	movs	r3, #33	; 0x21
 8029ae0:	6003      	str	r3, [r0, #0]
 8029ae2:	ed9f 8a28 	vldr	s16, [pc, #160]	; 8029b84 <powf+0x128>
 8029ae6:	e7dc      	b.n	8029aa2 <powf+0x46>
 8029ae8:	f002 f9d4 	bl	802be94 <finitef>
 8029aec:	bb50      	cbnz	r0, 8029b44 <powf+0xe8>
 8029aee:	eeb0 0a49 	vmov.f32	s0, s18
 8029af2:	f002 f9cf 	bl	802be94 <finitef>
 8029af6:	b328      	cbz	r0, 8029b44 <powf+0xe8>
 8029af8:	eeb0 0a68 	vmov.f32	s0, s17
 8029afc:	f002 f9ca 	bl	802be94 <finitef>
 8029b00:	b300      	cbz	r0, 8029b44 <powf+0xe8>
 8029b02:	eeb4 8a48 	vcmp.f32	s16, s16
 8029b06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029b0a:	d706      	bvc.n	8029b1a <powf+0xbe>
 8029b0c:	f002 faac 	bl	802c068 <__errno>
 8029b10:	2321      	movs	r3, #33	; 0x21
 8029b12:	ee89 8aa9 	vdiv.f32	s16, s19, s19
 8029b16:	6003      	str	r3, [r0, #0]
 8029b18:	e7c3      	b.n	8029aa2 <powf+0x46>
 8029b1a:	f002 faa5 	bl	802c068 <__errno>
 8029b1e:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8029b22:	2322      	movs	r3, #34	; 0x22
 8029b24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029b28:	6003      	str	r3, [r0, #0]
 8029b2a:	d508      	bpl.n	8029b3e <powf+0xe2>
 8029b2c:	eeb0 0a68 	vmov.f32	s0, s17
 8029b30:	f002 f9c4 	bl	802bebc <rintf>
 8029b34:	eeb4 0a68 	vcmp.f32	s0, s17
 8029b38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029b3c:	d1d1      	bne.n	8029ae2 <powf+0x86>
 8029b3e:	ed9f 8a12 	vldr	s16, [pc, #72]	; 8029b88 <powf+0x12c>
 8029b42:	e7ae      	b.n	8029aa2 <powf+0x46>
 8029b44:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8029b48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029b4c:	d1a9      	bne.n	8029aa2 <powf+0x46>
 8029b4e:	eeb0 0a49 	vmov.f32	s0, s18
 8029b52:	f002 f99f 	bl	802be94 <finitef>
 8029b56:	2800      	cmp	r0, #0
 8029b58:	d0a3      	beq.n	8029aa2 <powf+0x46>
 8029b5a:	eeb0 0a68 	vmov.f32	s0, s17
 8029b5e:	f002 f999 	bl	802be94 <finitef>
 8029b62:	2800      	cmp	r0, #0
 8029b64:	d09d      	beq.n	8029aa2 <powf+0x46>
 8029b66:	f002 fa7f 	bl	802c068 <__errno>
 8029b6a:	2322      	movs	r3, #34	; 0x22
 8029b6c:	ed9f 8a04 	vldr	s16, [pc, #16]	; 8029b80 <powf+0x124>
 8029b70:	6003      	str	r3, [r0, #0]
 8029b72:	e796      	b.n	8029aa2 <powf+0x46>
 8029b74:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 8029b78:	e793      	b.n	8029aa2 <powf+0x46>
 8029b7a:	bf00      	nop
 8029b7c:	200001b0 	.word	0x200001b0
 8029b80:	00000000 	.word	0x00000000
 8029b84:	ff800000 	.word	0xff800000
 8029b88:	7f800000 	.word	0x7f800000

08029b8c <sqrtf>:
 8029b8c:	b508      	push	{r3, lr}
 8029b8e:	ed2d 8b02 	vpush	{d8}
 8029b92:	eeb0 8a40 	vmov.f32	s16, s0
 8029b96:	f001 fd21 	bl	802b5dc <__ieee754_sqrtf>
 8029b9a:	4b0d      	ldr	r3, [pc, #52]	; (8029bd0 <sqrtf+0x44>)
 8029b9c:	f993 3000 	ldrsb.w	r3, [r3]
 8029ba0:	3301      	adds	r3, #1
 8029ba2:	d011      	beq.n	8029bc8 <sqrtf+0x3c>
 8029ba4:	eeb4 8a48 	vcmp.f32	s16, s16
 8029ba8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029bac:	d60c      	bvs.n	8029bc8 <sqrtf+0x3c>
 8029bae:	eddf 8a09 	vldr	s17, [pc, #36]	; 8029bd4 <sqrtf+0x48>
 8029bb2:	eeb4 8ae8 	vcmpe.f32	s16, s17
 8029bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029bba:	d505      	bpl.n	8029bc8 <sqrtf+0x3c>
 8029bbc:	f002 fa54 	bl	802c068 <__errno>
 8029bc0:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 8029bc4:	2321      	movs	r3, #33	; 0x21
 8029bc6:	6003      	str	r3, [r0, #0]
 8029bc8:	ecbd 8b02 	vpop	{d8}
 8029bcc:	bd08      	pop	{r3, pc}
 8029bce:	bf00      	nop
 8029bd0:	200001b0 	.word	0x200001b0
 8029bd4:	00000000 	.word	0x00000000

08029bd8 <__ieee754_fmod>:
 8029bd8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029bdc:	ec53 2b11 	vmov	r2, r3, d1
 8029be0:	f023 4e00 	bic.w	lr, r3, #2147483648	; 0x80000000
 8029be4:	ea5e 0402 	orrs.w	r4, lr, r2
 8029be8:	ec51 0b10 	vmov	r0, r1, d0
 8029bec:	ee11 7a10 	vmov	r7, s2
 8029bf0:	ee11 ca10 	vmov	ip, s2
 8029bf4:	461e      	mov	r6, r3
 8029bf6:	d00d      	beq.n	8029c14 <__ieee754_fmod+0x3c>
 8029bf8:	4c7a      	ldr	r4, [pc, #488]	; (8029de4 <__ieee754_fmod+0x20c>)
 8029bfa:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
 8029bfe:	45a0      	cmp	r8, r4
 8029c00:	4689      	mov	r9, r1
 8029c02:	dc07      	bgt.n	8029c14 <__ieee754_fmod+0x3c>
 8029c04:	4254      	negs	r4, r2
 8029c06:	4d78      	ldr	r5, [pc, #480]	; (8029de8 <__ieee754_fmod+0x210>)
 8029c08:	4314      	orrs	r4, r2
 8029c0a:	ea4e 74d4 	orr.w	r4, lr, r4, lsr #31
 8029c0e:	42ac      	cmp	r4, r5
 8029c10:	46ab      	mov	fp, r5
 8029c12:	d909      	bls.n	8029c28 <__ieee754_fmod+0x50>
 8029c14:	f7dd ff70 	bl	8007af8 <__aeabi_dmul>
 8029c18:	4602      	mov	r2, r0
 8029c1a:	460b      	mov	r3, r1
 8029c1c:	f7de f896 	bl	8007d4c <__aeabi_ddiv>
 8029c20:	ec41 0b10 	vmov	d0, r0, r1
 8029c24:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029c28:	45f0      	cmp	r8, lr
 8029c2a:	ee10 aa10 	vmov	sl, s0
 8029c2e:	ee10 4a10 	vmov	r4, s0
 8029c32:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8029c36:	dc0a      	bgt.n	8029c4e <__ieee754_fmod+0x76>
 8029c38:	dbf2      	blt.n	8029c20 <__ieee754_fmod+0x48>
 8029c3a:	4290      	cmp	r0, r2
 8029c3c:	d3f0      	bcc.n	8029c20 <__ieee754_fmod+0x48>
 8029c3e:	d106      	bne.n	8029c4e <__ieee754_fmod+0x76>
 8029c40:	4a6a      	ldr	r2, [pc, #424]	; (8029dec <__ieee754_fmod+0x214>)
 8029c42:	0fed      	lsrs	r5, r5, #31
 8029c44:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 8029c48:	e9d5 0100 	ldrd	r0, r1, [r5]
 8029c4c:	e7e8      	b.n	8029c20 <__ieee754_fmod+0x48>
 8029c4e:	ea19 0f0b 	tst.w	r9, fp
 8029c52:	d14a      	bne.n	8029cea <__ieee754_fmod+0x112>
 8029c54:	f1b8 0f00 	cmp.w	r8, #0
 8029c58:	d13f      	bne.n	8029cda <__ieee754_fmod+0x102>
 8029c5a:	4965      	ldr	r1, [pc, #404]	; (8029df0 <__ieee754_fmod+0x218>)
 8029c5c:	4653      	mov	r3, sl
 8029c5e:	2b00      	cmp	r3, #0
 8029c60:	dc38      	bgt.n	8029cd4 <__ieee754_fmod+0xfc>
 8029c62:	4b61      	ldr	r3, [pc, #388]	; (8029de8 <__ieee754_fmod+0x210>)
 8029c64:	4033      	ands	r3, r6
 8029c66:	2b00      	cmp	r3, #0
 8029c68:	d14f      	bne.n	8029d0a <__ieee754_fmod+0x132>
 8029c6a:	f1be 0f00 	cmp.w	lr, #0
 8029c6e:	d144      	bne.n	8029cfa <__ieee754_fmod+0x122>
 8029c70:	4a5f      	ldr	r2, [pc, #380]	; (8029df0 <__ieee754_fmod+0x218>)
 8029c72:	463b      	mov	r3, r7
 8029c74:	2b00      	cmp	r3, #0
 8029c76:	dc3d      	bgt.n	8029cf4 <__ieee754_fmod+0x11c>
 8029c78:	4b5e      	ldr	r3, [pc, #376]	; (8029df4 <__ieee754_fmod+0x21c>)
 8029c7a:	4299      	cmp	r1, r3
 8029c7c:	db4a      	blt.n	8029d14 <__ieee754_fmod+0x13c>
 8029c7e:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8029c82:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8029c86:	485b      	ldr	r0, [pc, #364]	; (8029df4 <__ieee754_fmod+0x21c>)
 8029c88:	4282      	cmp	r2, r0
 8029c8a:	db57      	blt.n	8029d3c <__ieee754_fmod+0x164>
 8029c8c:	f3c6 0613 	ubfx	r6, r6, #0, #20
 8029c90:	f446 1680 	orr.w	r6, r6, #1048576	; 0x100000
 8029c94:	1a89      	subs	r1, r1, r2
 8029c96:	1b98      	subs	r0, r3, r6
 8029c98:	eba4 070c 	sub.w	r7, r4, ip
 8029c9c:	2900      	cmp	r1, #0
 8029c9e:	d164      	bne.n	8029d6a <__ieee754_fmod+0x192>
 8029ca0:	4564      	cmp	r4, ip
 8029ca2:	bf38      	it	cc
 8029ca4:	f100 30ff 	addcc.w	r0, r0, #4294967295	; 0xffffffff
 8029ca8:	2800      	cmp	r0, #0
 8029caa:	bfa4      	itt	ge
 8029cac:	463c      	movge	r4, r7
 8029cae:	4603      	movge	r3, r0
 8029cb0:	ea53 0104 	orrs.w	r1, r3, r4
 8029cb4:	d0c4      	beq.n	8029c40 <__ieee754_fmod+0x68>
 8029cb6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8029cba:	db6b      	blt.n	8029d94 <__ieee754_fmod+0x1bc>
 8029cbc:	494d      	ldr	r1, [pc, #308]	; (8029df4 <__ieee754_fmod+0x21c>)
 8029cbe:	428a      	cmp	r2, r1
 8029cc0:	db6e      	blt.n	8029da0 <__ieee754_fmod+0x1c8>
 8029cc2:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 8029cc6:	f202 32ff 	addw	r2, r2, #1023	; 0x3ff
 8029cca:	431d      	orrs	r5, r3
 8029ccc:	ea45 5102 	orr.w	r1, r5, r2, lsl #20
 8029cd0:	4620      	mov	r0, r4
 8029cd2:	e7a5      	b.n	8029c20 <__ieee754_fmod+0x48>
 8029cd4:	3901      	subs	r1, #1
 8029cd6:	005b      	lsls	r3, r3, #1
 8029cd8:	e7c1      	b.n	8029c5e <__ieee754_fmod+0x86>
 8029cda:	4946      	ldr	r1, [pc, #280]	; (8029df4 <__ieee754_fmod+0x21c>)
 8029cdc:	ea4f 23c8 	mov.w	r3, r8, lsl #11
 8029ce0:	2b00      	cmp	r3, #0
 8029ce2:	ddbe      	ble.n	8029c62 <__ieee754_fmod+0x8a>
 8029ce4:	3901      	subs	r1, #1
 8029ce6:	005b      	lsls	r3, r3, #1
 8029ce8:	e7fa      	b.n	8029ce0 <__ieee754_fmod+0x108>
 8029cea:	ea4f 5128 	mov.w	r1, r8, asr #20
 8029cee:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
 8029cf2:	e7b6      	b.n	8029c62 <__ieee754_fmod+0x8a>
 8029cf4:	3a01      	subs	r2, #1
 8029cf6:	005b      	lsls	r3, r3, #1
 8029cf8:	e7bc      	b.n	8029c74 <__ieee754_fmod+0x9c>
 8029cfa:	4a3e      	ldr	r2, [pc, #248]	; (8029df4 <__ieee754_fmod+0x21c>)
 8029cfc:	ea4f 23ce 	mov.w	r3, lr, lsl #11
 8029d00:	2b00      	cmp	r3, #0
 8029d02:	ddb9      	ble.n	8029c78 <__ieee754_fmod+0xa0>
 8029d04:	3a01      	subs	r2, #1
 8029d06:	005b      	lsls	r3, r3, #1
 8029d08:	e7fa      	b.n	8029d00 <__ieee754_fmod+0x128>
 8029d0a:	ea4f 522e 	mov.w	r2, lr, asr #20
 8029d0e:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
 8029d12:	e7b1      	b.n	8029c78 <__ieee754_fmod+0xa0>
 8029d14:	1a5c      	subs	r4, r3, r1
 8029d16:	2c1f      	cmp	r4, #31
 8029d18:	dc0a      	bgt.n	8029d30 <__ieee754_fmod+0x158>
 8029d1a:	f201 431e 	addw	r3, r1, #1054	; 0x41e
 8029d1e:	fa08 f804 	lsl.w	r8, r8, r4
 8029d22:	fa2a f303 	lsr.w	r3, sl, r3
 8029d26:	ea43 0308 	orr.w	r3, r3, r8
 8029d2a:	fa0a f404 	lsl.w	r4, sl, r4
 8029d2e:	e7aa      	b.n	8029c86 <__ieee754_fmod+0xae>
 8029d30:	4b31      	ldr	r3, [pc, #196]	; (8029df8 <__ieee754_fmod+0x220>)
 8029d32:	1a5b      	subs	r3, r3, r1
 8029d34:	fa0a f303 	lsl.w	r3, sl, r3
 8029d38:	2400      	movs	r4, #0
 8029d3a:	e7a4      	b.n	8029c86 <__ieee754_fmod+0xae>
 8029d3c:	eba0 0c02 	sub.w	ip, r0, r2
 8029d40:	f1bc 0f1f 	cmp.w	ip, #31
 8029d44:	dc0a      	bgt.n	8029d5c <__ieee754_fmod+0x184>
 8029d46:	f202 461e 	addw	r6, r2, #1054	; 0x41e
 8029d4a:	fa0e fe0c 	lsl.w	lr, lr, ip
 8029d4e:	fa27 f606 	lsr.w	r6, r7, r6
 8029d52:	ea46 060e 	orr.w	r6, r6, lr
 8029d56:	fa07 fc0c 	lsl.w	ip, r7, ip
 8029d5a:	e79b      	b.n	8029c94 <__ieee754_fmod+0xbc>
 8029d5c:	4e26      	ldr	r6, [pc, #152]	; (8029df8 <__ieee754_fmod+0x220>)
 8029d5e:	1ab6      	subs	r6, r6, r2
 8029d60:	fa07 f606 	lsl.w	r6, r7, r6
 8029d64:	f04f 0c00 	mov.w	ip, #0
 8029d68:	e794      	b.n	8029c94 <__ieee754_fmod+0xbc>
 8029d6a:	4564      	cmp	r4, ip
 8029d6c:	bf38      	it	cc
 8029d6e:	f100 30ff 	addcc.w	r0, r0, #4294967295	; 0xffffffff
 8029d72:	2800      	cmp	r0, #0
 8029d74:	da05      	bge.n	8029d82 <__ieee754_fmod+0x1aa>
 8029d76:	0fe0      	lsrs	r0, r4, #31
 8029d78:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8029d7c:	0064      	lsls	r4, r4, #1
 8029d7e:	3901      	subs	r1, #1
 8029d80:	e789      	b.n	8029c96 <__ieee754_fmod+0xbe>
 8029d82:	ea50 0307 	orrs.w	r3, r0, r7
 8029d86:	f43f af5b 	beq.w	8029c40 <__ieee754_fmod+0x68>
 8029d8a:	0ffb      	lsrs	r3, r7, #31
 8029d8c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8029d90:	007c      	lsls	r4, r7, #1
 8029d92:	e7f4      	b.n	8029d7e <__ieee754_fmod+0x1a6>
 8029d94:	0fe1      	lsrs	r1, r4, #31
 8029d96:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8029d9a:	0064      	lsls	r4, r4, #1
 8029d9c:	3a01      	subs	r2, #1
 8029d9e:	e78a      	b.n	8029cb6 <__ieee754_fmod+0xde>
 8029da0:	1a89      	subs	r1, r1, r2
 8029da2:	2914      	cmp	r1, #20
 8029da4:	dc0a      	bgt.n	8029dbc <__ieee754_fmod+0x1e4>
 8029da6:	f202 421e 	addw	r2, r2, #1054	; 0x41e
 8029daa:	fa03 f202 	lsl.w	r2, r3, r2
 8029dae:	40cc      	lsrs	r4, r1
 8029db0:	4322      	orrs	r2, r4
 8029db2:	410b      	asrs	r3, r1
 8029db4:	ea43 0105 	orr.w	r1, r3, r5
 8029db8:	4610      	mov	r0, r2
 8029dba:	e731      	b.n	8029c20 <__ieee754_fmod+0x48>
 8029dbc:	291f      	cmp	r1, #31
 8029dbe:	dc07      	bgt.n	8029dd0 <__ieee754_fmod+0x1f8>
 8029dc0:	f202 421e 	addw	r2, r2, #1054	; 0x41e
 8029dc4:	40cc      	lsrs	r4, r1
 8029dc6:	fa03 f202 	lsl.w	r2, r3, r2
 8029dca:	4322      	orrs	r2, r4
 8029dcc:	462b      	mov	r3, r5
 8029dce:	e7f1      	b.n	8029db4 <__ieee754_fmod+0x1dc>
 8029dd0:	f1c2 427f 	rsb	r2, r2, #4278190080	; 0xff000000
 8029dd4:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 8029dd8:	f502 427b 	add.w	r2, r2, #64256	; 0xfb00
 8029ddc:	32e2      	adds	r2, #226	; 0xe2
 8029dde:	fa43 f202 	asr.w	r2, r3, r2
 8029de2:	e7f3      	b.n	8029dcc <__ieee754_fmod+0x1f4>
 8029de4:	7fefffff 	.word	0x7fefffff
 8029de8:	7ff00000 	.word	0x7ff00000
 8029dec:	0802d8f8 	.word	0x0802d8f8
 8029df0:	fffffbed 	.word	0xfffffbed
 8029df4:	fffffc02 	.word	0xfffffc02
 8029df8:	fffffbe2 	.word	0xfffffbe2
 8029dfc:	00000000 	.word	0x00000000

08029e00 <__ieee754_pow>:
 8029e00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029e04:	ed2d 8b06 	vpush	{d8-d10}
 8029e08:	b08d      	sub	sp, #52	; 0x34
 8029e0a:	ed8d 1b02 	vstr	d1, [sp, #8]
 8029e0e:	e9dd 0702 	ldrd	r0, r7, [sp, #8]
 8029e12:	f027 4600 	bic.w	r6, r7, #2147483648	; 0x80000000
 8029e16:	ea56 0100 	orrs.w	r1, r6, r0
 8029e1a:	ec53 2b10 	vmov	r2, r3, d0
 8029e1e:	f000 84d1 	beq.w	802a7c4 <__ieee754_pow+0x9c4>
 8029e22:	497f      	ldr	r1, [pc, #508]	; (802a020 <__ieee754_pow+0x220>)
 8029e24:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 8029e28:	428c      	cmp	r4, r1
 8029e2a:	ee10 8a10 	vmov	r8, s0
 8029e2e:	4699      	mov	r9, r3
 8029e30:	dc09      	bgt.n	8029e46 <__ieee754_pow+0x46>
 8029e32:	d103      	bne.n	8029e3c <__ieee754_pow+0x3c>
 8029e34:	b97a      	cbnz	r2, 8029e56 <__ieee754_pow+0x56>
 8029e36:	42a6      	cmp	r6, r4
 8029e38:	dd02      	ble.n	8029e40 <__ieee754_pow+0x40>
 8029e3a:	e00c      	b.n	8029e56 <__ieee754_pow+0x56>
 8029e3c:	428e      	cmp	r6, r1
 8029e3e:	dc02      	bgt.n	8029e46 <__ieee754_pow+0x46>
 8029e40:	428e      	cmp	r6, r1
 8029e42:	d110      	bne.n	8029e66 <__ieee754_pow+0x66>
 8029e44:	b178      	cbz	r0, 8029e66 <__ieee754_pow+0x66>
 8029e46:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 8029e4a:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 8029e4e:	ea54 0308 	orrs.w	r3, r4, r8
 8029e52:	f000 84b7 	beq.w	802a7c4 <__ieee754_pow+0x9c4>
 8029e56:	4873      	ldr	r0, [pc, #460]	; (802a024 <__ieee754_pow+0x224>)
 8029e58:	b00d      	add	sp, #52	; 0x34
 8029e5a:	ecbd 8b06 	vpop	{d8-d10}
 8029e5e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029e62:	f001 befd 	b.w	802bc60 <nan>
 8029e66:	f1b9 0f00 	cmp.w	r9, #0
 8029e6a:	da36      	bge.n	8029eda <__ieee754_pow+0xda>
 8029e6c:	496e      	ldr	r1, [pc, #440]	; (802a028 <__ieee754_pow+0x228>)
 8029e6e:	428e      	cmp	r6, r1
 8029e70:	dc51      	bgt.n	8029f16 <__ieee754_pow+0x116>
 8029e72:	f1a1 7154 	sub.w	r1, r1, #55574528	; 0x3500000
 8029e76:	428e      	cmp	r6, r1
 8029e78:	f340 84af 	ble.w	802a7da <__ieee754_pow+0x9da>
 8029e7c:	1531      	asrs	r1, r6, #20
 8029e7e:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
 8029e82:	2914      	cmp	r1, #20
 8029e84:	dd0f      	ble.n	8029ea6 <__ieee754_pow+0xa6>
 8029e86:	f1c1 0134 	rsb	r1, r1, #52	; 0x34
 8029e8a:	fa20 fc01 	lsr.w	ip, r0, r1
 8029e8e:	fa0c f101 	lsl.w	r1, ip, r1
 8029e92:	4281      	cmp	r1, r0
 8029e94:	f040 84a1 	bne.w	802a7da <__ieee754_pow+0x9da>
 8029e98:	f00c 0c01 	and.w	ip, ip, #1
 8029e9c:	f1cc 0102 	rsb	r1, ip, #2
 8029ea0:	9100      	str	r1, [sp, #0]
 8029ea2:	b180      	cbz	r0, 8029ec6 <__ieee754_pow+0xc6>
 8029ea4:	e059      	b.n	8029f5a <__ieee754_pow+0x15a>
 8029ea6:	2800      	cmp	r0, #0
 8029ea8:	d155      	bne.n	8029f56 <__ieee754_pow+0x156>
 8029eaa:	f1c1 0114 	rsb	r1, r1, #20
 8029eae:	fa46 fc01 	asr.w	ip, r6, r1
 8029eb2:	fa0c f101 	lsl.w	r1, ip, r1
 8029eb6:	42b1      	cmp	r1, r6
 8029eb8:	f040 848c 	bne.w	802a7d4 <__ieee754_pow+0x9d4>
 8029ebc:	f00c 0c01 	and.w	ip, ip, #1
 8029ec0:	f1cc 0102 	rsb	r1, ip, #2
 8029ec4:	9100      	str	r1, [sp, #0]
 8029ec6:	4959      	ldr	r1, [pc, #356]	; (802a02c <__ieee754_pow+0x22c>)
 8029ec8:	428e      	cmp	r6, r1
 8029eca:	d12d      	bne.n	8029f28 <__ieee754_pow+0x128>
 8029ecc:	2f00      	cmp	r7, #0
 8029ece:	da79      	bge.n	8029fc4 <__ieee754_pow+0x1c4>
 8029ed0:	4956      	ldr	r1, [pc, #344]	; (802a02c <__ieee754_pow+0x22c>)
 8029ed2:	2000      	movs	r0, #0
 8029ed4:	f7dd ff3a 	bl	8007d4c <__aeabi_ddiv>
 8029ed8:	e016      	b.n	8029f08 <__ieee754_pow+0x108>
 8029eda:	2100      	movs	r1, #0
 8029edc:	9100      	str	r1, [sp, #0]
 8029ede:	2800      	cmp	r0, #0
 8029ee0:	d13b      	bne.n	8029f5a <__ieee754_pow+0x15a>
 8029ee2:	494f      	ldr	r1, [pc, #316]	; (802a020 <__ieee754_pow+0x220>)
 8029ee4:	428e      	cmp	r6, r1
 8029ee6:	d1ee      	bne.n	8029ec6 <__ieee754_pow+0xc6>
 8029ee8:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
 8029eec:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 8029ef0:	ea53 0308 	orrs.w	r3, r3, r8
 8029ef4:	f000 8466 	beq.w	802a7c4 <__ieee754_pow+0x9c4>
 8029ef8:	4b4d      	ldr	r3, [pc, #308]	; (802a030 <__ieee754_pow+0x230>)
 8029efa:	429c      	cmp	r4, r3
 8029efc:	dd0d      	ble.n	8029f1a <__ieee754_pow+0x11a>
 8029efe:	2f00      	cmp	r7, #0
 8029f00:	f280 8464 	bge.w	802a7cc <__ieee754_pow+0x9cc>
 8029f04:	2000      	movs	r0, #0
 8029f06:	2100      	movs	r1, #0
 8029f08:	ec41 0b10 	vmov	d0, r0, r1
 8029f0c:	b00d      	add	sp, #52	; 0x34
 8029f0e:	ecbd 8b06 	vpop	{d8-d10}
 8029f12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029f16:	2102      	movs	r1, #2
 8029f18:	e7e0      	b.n	8029edc <__ieee754_pow+0xdc>
 8029f1a:	2f00      	cmp	r7, #0
 8029f1c:	daf2      	bge.n	8029f04 <__ieee754_pow+0x104>
 8029f1e:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
 8029f22:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 8029f26:	e7ef      	b.n	8029f08 <__ieee754_pow+0x108>
 8029f28:	f1b7 4f80 	cmp.w	r7, #1073741824	; 0x40000000
 8029f2c:	d104      	bne.n	8029f38 <__ieee754_pow+0x138>
 8029f2e:	4610      	mov	r0, r2
 8029f30:	4619      	mov	r1, r3
 8029f32:	f7dd fde1 	bl	8007af8 <__aeabi_dmul>
 8029f36:	e7e7      	b.n	8029f08 <__ieee754_pow+0x108>
 8029f38:	493e      	ldr	r1, [pc, #248]	; (802a034 <__ieee754_pow+0x234>)
 8029f3a:	428f      	cmp	r7, r1
 8029f3c:	d10d      	bne.n	8029f5a <__ieee754_pow+0x15a>
 8029f3e:	f1b9 0f00 	cmp.w	r9, #0
 8029f42:	db0a      	blt.n	8029f5a <__ieee754_pow+0x15a>
 8029f44:	ec43 2b10 	vmov	d0, r2, r3
 8029f48:	b00d      	add	sp, #52	; 0x34
 8029f4a:	ecbd 8b06 	vpop	{d8-d10}
 8029f4e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029f52:	f000 bc77 	b.w	802a844 <__ieee754_sqrt>
 8029f56:	2100      	movs	r1, #0
 8029f58:	9100      	str	r1, [sp, #0]
 8029f5a:	ec43 2b10 	vmov	d0, r2, r3
 8029f5e:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8029f62:	f7ff fa25 	bl	80293b0 <fabs>
 8029f66:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8029f6a:	ec51 0b10 	vmov	r0, r1, d0
 8029f6e:	f1b8 0f00 	cmp.w	r8, #0
 8029f72:	d12a      	bne.n	8029fca <__ieee754_pow+0x1ca>
 8029f74:	b12c      	cbz	r4, 8029f82 <__ieee754_pow+0x182>
 8029f76:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 802a02c <__ieee754_pow+0x22c>
 8029f7a:	f029 4e40 	bic.w	lr, r9, #3221225472	; 0xc0000000
 8029f7e:	45e6      	cmp	lr, ip
 8029f80:	d123      	bne.n	8029fca <__ieee754_pow+0x1ca>
 8029f82:	2f00      	cmp	r7, #0
 8029f84:	da05      	bge.n	8029f92 <__ieee754_pow+0x192>
 8029f86:	4602      	mov	r2, r0
 8029f88:	460b      	mov	r3, r1
 8029f8a:	2000      	movs	r0, #0
 8029f8c:	4927      	ldr	r1, [pc, #156]	; (802a02c <__ieee754_pow+0x22c>)
 8029f8e:	f7dd fedd 	bl	8007d4c <__aeabi_ddiv>
 8029f92:	f1b9 0f00 	cmp.w	r9, #0
 8029f96:	dab7      	bge.n	8029f08 <__ieee754_pow+0x108>
 8029f98:	9b00      	ldr	r3, [sp, #0]
 8029f9a:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 8029f9e:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 8029fa2:	4323      	orrs	r3, r4
 8029fa4:	d108      	bne.n	8029fb8 <__ieee754_pow+0x1b8>
 8029fa6:	4602      	mov	r2, r0
 8029fa8:	460b      	mov	r3, r1
 8029faa:	4610      	mov	r0, r2
 8029fac:	4619      	mov	r1, r3
 8029fae:	f7dd fbeb 	bl	8007788 <__aeabi_dsub>
 8029fb2:	4602      	mov	r2, r0
 8029fb4:	460b      	mov	r3, r1
 8029fb6:	e78d      	b.n	8029ed4 <__ieee754_pow+0xd4>
 8029fb8:	9b00      	ldr	r3, [sp, #0]
 8029fba:	2b01      	cmp	r3, #1
 8029fbc:	d1a4      	bne.n	8029f08 <__ieee754_pow+0x108>
 8029fbe:	4602      	mov	r2, r0
 8029fc0:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8029fc4:	4610      	mov	r0, r2
 8029fc6:	4619      	mov	r1, r3
 8029fc8:	e79e      	b.n	8029f08 <__ieee754_pow+0x108>
 8029fca:	ea4f 7cd9 	mov.w	ip, r9, lsr #31
 8029fce:	f10c 35ff 	add.w	r5, ip, #4294967295	; 0xffffffff
 8029fd2:	950a      	str	r5, [sp, #40]	; 0x28
 8029fd4:	9d00      	ldr	r5, [sp, #0]
 8029fd6:	46ac      	mov	ip, r5
 8029fd8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8029fda:	ea5c 0505 	orrs.w	r5, ip, r5
 8029fde:	d0e4      	beq.n	8029faa <__ieee754_pow+0x1aa>
 8029fe0:	4b15      	ldr	r3, [pc, #84]	; (802a038 <__ieee754_pow+0x238>)
 8029fe2:	429e      	cmp	r6, r3
 8029fe4:	f340 80fc 	ble.w	802a1e0 <__ieee754_pow+0x3e0>
 8029fe8:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
 8029fec:	429e      	cmp	r6, r3
 8029fee:	4b10      	ldr	r3, [pc, #64]	; (802a030 <__ieee754_pow+0x230>)
 8029ff0:	dd07      	ble.n	802a002 <__ieee754_pow+0x202>
 8029ff2:	429c      	cmp	r4, r3
 8029ff4:	dc0a      	bgt.n	802a00c <__ieee754_pow+0x20c>
 8029ff6:	2f00      	cmp	r7, #0
 8029ff8:	da84      	bge.n	8029f04 <__ieee754_pow+0x104>
 8029ffa:	a307      	add	r3, pc, #28	; (adr r3, 802a018 <__ieee754_pow+0x218>)
 8029ffc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a000:	e795      	b.n	8029f2e <__ieee754_pow+0x12e>
 802a002:	429c      	cmp	r4, r3
 802a004:	dbf7      	blt.n	8029ff6 <__ieee754_pow+0x1f6>
 802a006:	4b09      	ldr	r3, [pc, #36]	; (802a02c <__ieee754_pow+0x22c>)
 802a008:	429c      	cmp	r4, r3
 802a00a:	dd17      	ble.n	802a03c <__ieee754_pow+0x23c>
 802a00c:	2f00      	cmp	r7, #0
 802a00e:	dcf4      	bgt.n	8029ffa <__ieee754_pow+0x1fa>
 802a010:	e778      	b.n	8029f04 <__ieee754_pow+0x104>
 802a012:	bf00      	nop
 802a014:	f3af 8000 	nop.w
 802a018:	8800759c 	.word	0x8800759c
 802a01c:	7e37e43c 	.word	0x7e37e43c
 802a020:	7ff00000 	.word	0x7ff00000
 802a024:	0802d8f0 	.word	0x0802d8f0
 802a028:	433fffff 	.word	0x433fffff
 802a02c:	3ff00000 	.word	0x3ff00000
 802a030:	3fefffff 	.word	0x3fefffff
 802a034:	3fe00000 	.word	0x3fe00000
 802a038:	41e00000 	.word	0x41e00000
 802a03c:	4b64      	ldr	r3, [pc, #400]	; (802a1d0 <__ieee754_pow+0x3d0>)
 802a03e:	2200      	movs	r2, #0
 802a040:	f7dd fba2 	bl	8007788 <__aeabi_dsub>
 802a044:	a356      	add	r3, pc, #344	; (adr r3, 802a1a0 <__ieee754_pow+0x3a0>)
 802a046:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a04a:	4604      	mov	r4, r0
 802a04c:	460d      	mov	r5, r1
 802a04e:	f7dd fd53 	bl	8007af8 <__aeabi_dmul>
 802a052:	a355      	add	r3, pc, #340	; (adr r3, 802a1a8 <__ieee754_pow+0x3a8>)
 802a054:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a058:	4606      	mov	r6, r0
 802a05a:	460f      	mov	r7, r1
 802a05c:	4620      	mov	r0, r4
 802a05e:	4629      	mov	r1, r5
 802a060:	f7dd fd4a 	bl	8007af8 <__aeabi_dmul>
 802a064:	4b5b      	ldr	r3, [pc, #364]	; (802a1d4 <__ieee754_pow+0x3d4>)
 802a066:	4682      	mov	sl, r0
 802a068:	468b      	mov	fp, r1
 802a06a:	2200      	movs	r2, #0
 802a06c:	4620      	mov	r0, r4
 802a06e:	4629      	mov	r1, r5
 802a070:	f7dd fd42 	bl	8007af8 <__aeabi_dmul>
 802a074:	4602      	mov	r2, r0
 802a076:	460b      	mov	r3, r1
 802a078:	a14d      	add	r1, pc, #308	; (adr r1, 802a1b0 <__ieee754_pow+0x3b0>)
 802a07a:	e9d1 0100 	ldrd	r0, r1, [r1]
 802a07e:	f7dd fb83 	bl	8007788 <__aeabi_dsub>
 802a082:	4622      	mov	r2, r4
 802a084:	462b      	mov	r3, r5
 802a086:	f7dd fd37 	bl	8007af8 <__aeabi_dmul>
 802a08a:	4602      	mov	r2, r0
 802a08c:	460b      	mov	r3, r1
 802a08e:	2000      	movs	r0, #0
 802a090:	4951      	ldr	r1, [pc, #324]	; (802a1d8 <__ieee754_pow+0x3d8>)
 802a092:	f7dd fb79 	bl	8007788 <__aeabi_dsub>
 802a096:	4622      	mov	r2, r4
 802a098:	4680      	mov	r8, r0
 802a09a:	4689      	mov	r9, r1
 802a09c:	462b      	mov	r3, r5
 802a09e:	4620      	mov	r0, r4
 802a0a0:	4629      	mov	r1, r5
 802a0a2:	f7dd fd29 	bl	8007af8 <__aeabi_dmul>
 802a0a6:	4602      	mov	r2, r0
 802a0a8:	460b      	mov	r3, r1
 802a0aa:	4640      	mov	r0, r8
 802a0ac:	4649      	mov	r1, r9
 802a0ae:	f7dd fd23 	bl	8007af8 <__aeabi_dmul>
 802a0b2:	a341      	add	r3, pc, #260	; (adr r3, 802a1b8 <__ieee754_pow+0x3b8>)
 802a0b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a0b8:	f7dd fd1e 	bl	8007af8 <__aeabi_dmul>
 802a0bc:	4602      	mov	r2, r0
 802a0be:	460b      	mov	r3, r1
 802a0c0:	4650      	mov	r0, sl
 802a0c2:	4659      	mov	r1, fp
 802a0c4:	f7dd fb60 	bl	8007788 <__aeabi_dsub>
 802a0c8:	4602      	mov	r2, r0
 802a0ca:	460b      	mov	r3, r1
 802a0cc:	4680      	mov	r8, r0
 802a0ce:	4689      	mov	r9, r1
 802a0d0:	4630      	mov	r0, r6
 802a0d2:	4639      	mov	r1, r7
 802a0d4:	f7dd fb5a 	bl	800778c <__adddf3>
 802a0d8:	2400      	movs	r4, #0
 802a0da:	4632      	mov	r2, r6
 802a0dc:	463b      	mov	r3, r7
 802a0de:	4620      	mov	r0, r4
 802a0e0:	460d      	mov	r5, r1
 802a0e2:	f7dd fb51 	bl	8007788 <__aeabi_dsub>
 802a0e6:	4602      	mov	r2, r0
 802a0e8:	460b      	mov	r3, r1
 802a0ea:	4640      	mov	r0, r8
 802a0ec:	4649      	mov	r1, r9
 802a0ee:	f7dd fb4b 	bl	8007788 <__aeabi_dsub>
 802a0f2:	9b00      	ldr	r3, [sp, #0]
 802a0f4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802a0f6:	3b01      	subs	r3, #1
 802a0f8:	4313      	orrs	r3, r2
 802a0fa:	4682      	mov	sl, r0
 802a0fc:	468b      	mov	fp, r1
 802a0fe:	f040 81f1 	bne.w	802a4e4 <__ieee754_pow+0x6e4>
 802a102:	ed9f 7b2f 	vldr	d7, [pc, #188]	; 802a1c0 <__ieee754_pow+0x3c0>
 802a106:	eeb0 8a47 	vmov.f32	s16, s14
 802a10a:	eef0 8a67 	vmov.f32	s17, s15
 802a10e:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 802a112:	2600      	movs	r6, #0
 802a114:	4632      	mov	r2, r6
 802a116:	463b      	mov	r3, r7
 802a118:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802a11c:	f7dd fb34 	bl	8007788 <__aeabi_dsub>
 802a120:	4622      	mov	r2, r4
 802a122:	462b      	mov	r3, r5
 802a124:	f7dd fce8 	bl	8007af8 <__aeabi_dmul>
 802a128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802a12c:	4680      	mov	r8, r0
 802a12e:	4689      	mov	r9, r1
 802a130:	4650      	mov	r0, sl
 802a132:	4659      	mov	r1, fp
 802a134:	f7dd fce0 	bl	8007af8 <__aeabi_dmul>
 802a138:	4602      	mov	r2, r0
 802a13a:	460b      	mov	r3, r1
 802a13c:	4640      	mov	r0, r8
 802a13e:	4649      	mov	r1, r9
 802a140:	f7dd fb24 	bl	800778c <__adddf3>
 802a144:	4632      	mov	r2, r6
 802a146:	463b      	mov	r3, r7
 802a148:	4680      	mov	r8, r0
 802a14a:	4689      	mov	r9, r1
 802a14c:	4620      	mov	r0, r4
 802a14e:	4629      	mov	r1, r5
 802a150:	f7dd fcd2 	bl	8007af8 <__aeabi_dmul>
 802a154:	460b      	mov	r3, r1
 802a156:	4604      	mov	r4, r0
 802a158:	460d      	mov	r5, r1
 802a15a:	4602      	mov	r2, r0
 802a15c:	4649      	mov	r1, r9
 802a15e:	4640      	mov	r0, r8
 802a160:	f7dd fb14 	bl	800778c <__adddf3>
 802a164:	4b1d      	ldr	r3, [pc, #116]	; (802a1dc <__ieee754_pow+0x3dc>)
 802a166:	4299      	cmp	r1, r3
 802a168:	ec45 4b19 	vmov	d9, r4, r5
 802a16c:	4606      	mov	r6, r0
 802a16e:	460f      	mov	r7, r1
 802a170:	468b      	mov	fp, r1
 802a172:	f340 82fe 	ble.w	802a772 <__ieee754_pow+0x972>
 802a176:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
 802a17a:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 802a17e:	4303      	orrs	r3, r0
 802a180:	f000 81f0 	beq.w	802a564 <__ieee754_pow+0x764>
 802a184:	a310      	add	r3, pc, #64	; (adr r3, 802a1c8 <__ieee754_pow+0x3c8>)
 802a186:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a18a:	ec51 0b18 	vmov	r0, r1, d8
 802a18e:	f7dd fcb3 	bl	8007af8 <__aeabi_dmul>
 802a192:	a30d      	add	r3, pc, #52	; (adr r3, 802a1c8 <__ieee754_pow+0x3c8>)
 802a194:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a198:	e6cb      	b.n	8029f32 <__ieee754_pow+0x132>
 802a19a:	bf00      	nop
 802a19c:	f3af 8000 	nop.w
 802a1a0:	60000000 	.word	0x60000000
 802a1a4:	3ff71547 	.word	0x3ff71547
 802a1a8:	f85ddf44 	.word	0xf85ddf44
 802a1ac:	3e54ae0b 	.word	0x3e54ae0b
 802a1b0:	55555555 	.word	0x55555555
 802a1b4:	3fd55555 	.word	0x3fd55555
 802a1b8:	652b82fe 	.word	0x652b82fe
 802a1bc:	3ff71547 	.word	0x3ff71547
 802a1c0:	00000000 	.word	0x00000000
 802a1c4:	bff00000 	.word	0xbff00000
 802a1c8:	8800759c 	.word	0x8800759c
 802a1cc:	7e37e43c 	.word	0x7e37e43c
 802a1d0:	3ff00000 	.word	0x3ff00000
 802a1d4:	3fd00000 	.word	0x3fd00000
 802a1d8:	3fe00000 	.word	0x3fe00000
 802a1dc:	408fffff 	.word	0x408fffff
 802a1e0:	4bd7      	ldr	r3, [pc, #860]	; (802a540 <__ieee754_pow+0x740>)
 802a1e2:	ea03 0309 	and.w	r3, r3, r9
 802a1e6:	2200      	movs	r2, #0
 802a1e8:	b92b      	cbnz	r3, 802a1f6 <__ieee754_pow+0x3f6>
 802a1ea:	4bd6      	ldr	r3, [pc, #856]	; (802a544 <__ieee754_pow+0x744>)
 802a1ec:	f7dd fc84 	bl	8007af8 <__aeabi_dmul>
 802a1f0:	f06f 0234 	mvn.w	r2, #52	; 0x34
 802a1f4:	460c      	mov	r4, r1
 802a1f6:	1523      	asrs	r3, r4, #20
 802a1f8:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 802a1fc:	4413      	add	r3, r2
 802a1fe:	9309      	str	r3, [sp, #36]	; 0x24
 802a200:	4bd1      	ldr	r3, [pc, #836]	; (802a548 <__ieee754_pow+0x748>)
 802a202:	f3c4 0413 	ubfx	r4, r4, #0, #20
 802a206:	f044 557f 	orr.w	r5, r4, #1069547520	; 0x3fc00000
 802a20a:	429c      	cmp	r4, r3
 802a20c:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
 802a210:	dd08      	ble.n	802a224 <__ieee754_pow+0x424>
 802a212:	4bce      	ldr	r3, [pc, #824]	; (802a54c <__ieee754_pow+0x74c>)
 802a214:	429c      	cmp	r4, r3
 802a216:	f340 8163 	ble.w	802a4e0 <__ieee754_pow+0x6e0>
 802a21a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a21c:	3301      	adds	r3, #1
 802a21e:	9309      	str	r3, [sp, #36]	; 0x24
 802a220:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
 802a224:	2400      	movs	r4, #0
 802a226:	00e3      	lsls	r3, r4, #3
 802a228:	930b      	str	r3, [sp, #44]	; 0x2c
 802a22a:	4bc9      	ldr	r3, [pc, #804]	; (802a550 <__ieee754_pow+0x750>)
 802a22c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 802a230:	ed93 7b00 	vldr	d7, [r3]
 802a234:	4629      	mov	r1, r5
 802a236:	ec53 2b17 	vmov	r2, r3, d7
 802a23a:	eeb0 8a47 	vmov.f32	s16, s14
 802a23e:	eef0 8a67 	vmov.f32	s17, s15
 802a242:	4682      	mov	sl, r0
 802a244:	f7dd faa0 	bl	8007788 <__aeabi_dsub>
 802a248:	4652      	mov	r2, sl
 802a24a:	4606      	mov	r6, r0
 802a24c:	460f      	mov	r7, r1
 802a24e:	462b      	mov	r3, r5
 802a250:	ec51 0b18 	vmov	r0, r1, d8
 802a254:	f7dd fa9a 	bl	800778c <__adddf3>
 802a258:	4602      	mov	r2, r0
 802a25a:	460b      	mov	r3, r1
 802a25c:	2000      	movs	r0, #0
 802a25e:	49bd      	ldr	r1, [pc, #756]	; (802a554 <__ieee754_pow+0x754>)
 802a260:	f7dd fd74 	bl	8007d4c <__aeabi_ddiv>
 802a264:	ec41 0b19 	vmov	d9, r0, r1
 802a268:	4602      	mov	r2, r0
 802a26a:	460b      	mov	r3, r1
 802a26c:	4630      	mov	r0, r6
 802a26e:	4639      	mov	r1, r7
 802a270:	f7dd fc42 	bl	8007af8 <__aeabi_dmul>
 802a274:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802a278:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802a27c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 802a280:	2300      	movs	r3, #0
 802a282:	9304      	str	r3, [sp, #16]
 802a284:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 802a288:	46ab      	mov	fp, r5
 802a28a:	106d      	asrs	r5, r5, #1
 802a28c:	f045 5500 	orr.w	r5, r5, #536870912	; 0x20000000
 802a290:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
 802a294:	eb05 4384 	add.w	r3, r5, r4, lsl #18
 802a298:	2200      	movs	r2, #0
 802a29a:	4640      	mov	r0, r8
 802a29c:	4649      	mov	r1, r9
 802a29e:	4614      	mov	r4, r2
 802a2a0:	461d      	mov	r5, r3
 802a2a2:	f7dd fc29 	bl	8007af8 <__aeabi_dmul>
 802a2a6:	4602      	mov	r2, r0
 802a2a8:	460b      	mov	r3, r1
 802a2aa:	4630      	mov	r0, r6
 802a2ac:	4639      	mov	r1, r7
 802a2ae:	f7dd fa6b 	bl	8007788 <__aeabi_dsub>
 802a2b2:	ec53 2b18 	vmov	r2, r3, d8
 802a2b6:	4606      	mov	r6, r0
 802a2b8:	460f      	mov	r7, r1
 802a2ba:	4620      	mov	r0, r4
 802a2bc:	4629      	mov	r1, r5
 802a2be:	f7dd fa63 	bl	8007788 <__aeabi_dsub>
 802a2c2:	4602      	mov	r2, r0
 802a2c4:	460b      	mov	r3, r1
 802a2c6:	4650      	mov	r0, sl
 802a2c8:	4659      	mov	r1, fp
 802a2ca:	f7dd fa5d 	bl	8007788 <__aeabi_dsub>
 802a2ce:	4642      	mov	r2, r8
 802a2d0:	464b      	mov	r3, r9
 802a2d2:	f7dd fc11 	bl	8007af8 <__aeabi_dmul>
 802a2d6:	4602      	mov	r2, r0
 802a2d8:	460b      	mov	r3, r1
 802a2da:	4630      	mov	r0, r6
 802a2dc:	4639      	mov	r1, r7
 802a2de:	f7dd fa53 	bl	8007788 <__aeabi_dsub>
 802a2e2:	ec53 2b19 	vmov	r2, r3, d9
 802a2e6:	f7dd fc07 	bl	8007af8 <__aeabi_dmul>
 802a2ea:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802a2ee:	ec41 0b18 	vmov	d8, r0, r1
 802a2f2:	4610      	mov	r0, r2
 802a2f4:	4619      	mov	r1, r3
 802a2f6:	f7dd fbff 	bl	8007af8 <__aeabi_dmul>
 802a2fa:	a37d      	add	r3, pc, #500	; (adr r3, 802a4f0 <__ieee754_pow+0x6f0>)
 802a2fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a300:	4604      	mov	r4, r0
 802a302:	460d      	mov	r5, r1
 802a304:	f7dd fbf8 	bl	8007af8 <__aeabi_dmul>
 802a308:	a37b      	add	r3, pc, #492	; (adr r3, 802a4f8 <__ieee754_pow+0x6f8>)
 802a30a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a30e:	f7dd fa3d 	bl	800778c <__adddf3>
 802a312:	4622      	mov	r2, r4
 802a314:	462b      	mov	r3, r5
 802a316:	f7dd fbef 	bl	8007af8 <__aeabi_dmul>
 802a31a:	a379      	add	r3, pc, #484	; (adr r3, 802a500 <__ieee754_pow+0x700>)
 802a31c:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a320:	f7dd fa34 	bl	800778c <__adddf3>
 802a324:	4622      	mov	r2, r4
 802a326:	462b      	mov	r3, r5
 802a328:	f7dd fbe6 	bl	8007af8 <__aeabi_dmul>
 802a32c:	a376      	add	r3, pc, #472	; (adr r3, 802a508 <__ieee754_pow+0x708>)
 802a32e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a332:	f7dd fa2b 	bl	800778c <__adddf3>
 802a336:	4622      	mov	r2, r4
 802a338:	462b      	mov	r3, r5
 802a33a:	f7dd fbdd 	bl	8007af8 <__aeabi_dmul>
 802a33e:	a374      	add	r3, pc, #464	; (adr r3, 802a510 <__ieee754_pow+0x710>)
 802a340:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a344:	f7dd fa22 	bl	800778c <__adddf3>
 802a348:	4622      	mov	r2, r4
 802a34a:	462b      	mov	r3, r5
 802a34c:	f7dd fbd4 	bl	8007af8 <__aeabi_dmul>
 802a350:	a371      	add	r3, pc, #452	; (adr r3, 802a518 <__ieee754_pow+0x718>)
 802a352:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a356:	f7dd fa19 	bl	800778c <__adddf3>
 802a35a:	4622      	mov	r2, r4
 802a35c:	4606      	mov	r6, r0
 802a35e:	460f      	mov	r7, r1
 802a360:	462b      	mov	r3, r5
 802a362:	4620      	mov	r0, r4
 802a364:	4629      	mov	r1, r5
 802a366:	f7dd fbc7 	bl	8007af8 <__aeabi_dmul>
 802a36a:	4602      	mov	r2, r0
 802a36c:	460b      	mov	r3, r1
 802a36e:	4630      	mov	r0, r6
 802a370:	4639      	mov	r1, r7
 802a372:	f7dd fbc1 	bl	8007af8 <__aeabi_dmul>
 802a376:	4642      	mov	r2, r8
 802a378:	4604      	mov	r4, r0
 802a37a:	460d      	mov	r5, r1
 802a37c:	464b      	mov	r3, r9
 802a37e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802a382:	f7dd fa03 	bl	800778c <__adddf3>
 802a386:	ec53 2b18 	vmov	r2, r3, d8
 802a38a:	f7dd fbb5 	bl	8007af8 <__aeabi_dmul>
 802a38e:	4622      	mov	r2, r4
 802a390:	462b      	mov	r3, r5
 802a392:	f7dd f9fb 	bl	800778c <__adddf3>
 802a396:	4642      	mov	r2, r8
 802a398:	4682      	mov	sl, r0
 802a39a:	468b      	mov	fp, r1
 802a39c:	464b      	mov	r3, r9
 802a39e:	4640      	mov	r0, r8
 802a3a0:	4649      	mov	r1, r9
 802a3a2:	f7dd fba9 	bl	8007af8 <__aeabi_dmul>
 802a3a6:	4b6c      	ldr	r3, [pc, #432]	; (802a558 <__ieee754_pow+0x758>)
 802a3a8:	2200      	movs	r2, #0
 802a3aa:	4606      	mov	r6, r0
 802a3ac:	460f      	mov	r7, r1
 802a3ae:	f7dd f9ed 	bl	800778c <__adddf3>
 802a3b2:	4652      	mov	r2, sl
 802a3b4:	465b      	mov	r3, fp
 802a3b6:	f7dd f9e9 	bl	800778c <__adddf3>
 802a3ba:	9c04      	ldr	r4, [sp, #16]
 802a3bc:	460d      	mov	r5, r1
 802a3be:	4622      	mov	r2, r4
 802a3c0:	460b      	mov	r3, r1
 802a3c2:	4640      	mov	r0, r8
 802a3c4:	4649      	mov	r1, r9
 802a3c6:	f7dd fb97 	bl	8007af8 <__aeabi_dmul>
 802a3ca:	4b63      	ldr	r3, [pc, #396]	; (802a558 <__ieee754_pow+0x758>)
 802a3cc:	4680      	mov	r8, r0
 802a3ce:	4689      	mov	r9, r1
 802a3d0:	2200      	movs	r2, #0
 802a3d2:	4620      	mov	r0, r4
 802a3d4:	4629      	mov	r1, r5
 802a3d6:	f7dd f9d7 	bl	8007788 <__aeabi_dsub>
 802a3da:	4632      	mov	r2, r6
 802a3dc:	463b      	mov	r3, r7
 802a3de:	f7dd f9d3 	bl	8007788 <__aeabi_dsub>
 802a3e2:	4602      	mov	r2, r0
 802a3e4:	460b      	mov	r3, r1
 802a3e6:	4650      	mov	r0, sl
 802a3e8:	4659      	mov	r1, fp
 802a3ea:	f7dd f9cd 	bl	8007788 <__aeabi_dsub>
 802a3ee:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802a3f2:	f7dd fb81 	bl	8007af8 <__aeabi_dmul>
 802a3f6:	4622      	mov	r2, r4
 802a3f8:	4606      	mov	r6, r0
 802a3fa:	460f      	mov	r7, r1
 802a3fc:	462b      	mov	r3, r5
 802a3fe:	ec51 0b18 	vmov	r0, r1, d8
 802a402:	f7dd fb79 	bl	8007af8 <__aeabi_dmul>
 802a406:	4602      	mov	r2, r0
 802a408:	460b      	mov	r3, r1
 802a40a:	4630      	mov	r0, r6
 802a40c:	4639      	mov	r1, r7
 802a40e:	f7dd f9bd 	bl	800778c <__adddf3>
 802a412:	4606      	mov	r6, r0
 802a414:	460f      	mov	r7, r1
 802a416:	4602      	mov	r2, r0
 802a418:	460b      	mov	r3, r1
 802a41a:	4640      	mov	r0, r8
 802a41c:	4649      	mov	r1, r9
 802a41e:	f7dd f9b5 	bl	800778c <__adddf3>
 802a422:	9c04      	ldr	r4, [sp, #16]
 802a424:	a33e      	add	r3, pc, #248	; (adr r3, 802a520 <__ieee754_pow+0x720>)
 802a426:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a42a:	4620      	mov	r0, r4
 802a42c:	460d      	mov	r5, r1
 802a42e:	f7dd fb63 	bl	8007af8 <__aeabi_dmul>
 802a432:	4642      	mov	r2, r8
 802a434:	ec41 0b18 	vmov	d8, r0, r1
 802a438:	464b      	mov	r3, r9
 802a43a:	4620      	mov	r0, r4
 802a43c:	4629      	mov	r1, r5
 802a43e:	f7dd f9a3 	bl	8007788 <__aeabi_dsub>
 802a442:	4602      	mov	r2, r0
 802a444:	460b      	mov	r3, r1
 802a446:	4630      	mov	r0, r6
 802a448:	4639      	mov	r1, r7
 802a44a:	f7dd f99d 	bl	8007788 <__aeabi_dsub>
 802a44e:	a336      	add	r3, pc, #216	; (adr r3, 802a528 <__ieee754_pow+0x728>)
 802a450:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a454:	f7dd fb50 	bl	8007af8 <__aeabi_dmul>
 802a458:	a335      	add	r3, pc, #212	; (adr r3, 802a530 <__ieee754_pow+0x730>)
 802a45a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a45e:	4606      	mov	r6, r0
 802a460:	460f      	mov	r7, r1
 802a462:	4620      	mov	r0, r4
 802a464:	4629      	mov	r1, r5
 802a466:	f7dd fb47 	bl	8007af8 <__aeabi_dmul>
 802a46a:	4602      	mov	r2, r0
 802a46c:	460b      	mov	r3, r1
 802a46e:	4630      	mov	r0, r6
 802a470:	4639      	mov	r1, r7
 802a472:	f7dd f98b 	bl	800778c <__adddf3>
 802a476:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802a478:	4b38      	ldr	r3, [pc, #224]	; (802a55c <__ieee754_pow+0x75c>)
 802a47a:	4413      	add	r3, r2
 802a47c:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a480:	f7dd f984 	bl	800778c <__adddf3>
 802a484:	4682      	mov	sl, r0
 802a486:	9809      	ldr	r0, [sp, #36]	; 0x24
 802a488:	468b      	mov	fp, r1
 802a48a:	f7dd facb 	bl	8007a24 <__aeabi_i2d>
 802a48e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802a490:	4b33      	ldr	r3, [pc, #204]	; (802a560 <__ieee754_pow+0x760>)
 802a492:	4413      	add	r3, r2
 802a494:	e9d3 8900 	ldrd	r8, r9, [r3]
 802a498:	4606      	mov	r6, r0
 802a49a:	460f      	mov	r7, r1
 802a49c:	4652      	mov	r2, sl
 802a49e:	465b      	mov	r3, fp
 802a4a0:	ec51 0b18 	vmov	r0, r1, d8
 802a4a4:	f7dd f972 	bl	800778c <__adddf3>
 802a4a8:	4642      	mov	r2, r8
 802a4aa:	464b      	mov	r3, r9
 802a4ac:	f7dd f96e 	bl	800778c <__adddf3>
 802a4b0:	4632      	mov	r2, r6
 802a4b2:	463b      	mov	r3, r7
 802a4b4:	f7dd f96a 	bl	800778c <__adddf3>
 802a4b8:	9c04      	ldr	r4, [sp, #16]
 802a4ba:	4632      	mov	r2, r6
 802a4bc:	463b      	mov	r3, r7
 802a4be:	4620      	mov	r0, r4
 802a4c0:	460d      	mov	r5, r1
 802a4c2:	f7dd f961 	bl	8007788 <__aeabi_dsub>
 802a4c6:	4642      	mov	r2, r8
 802a4c8:	464b      	mov	r3, r9
 802a4ca:	f7dd f95d 	bl	8007788 <__aeabi_dsub>
 802a4ce:	ec53 2b18 	vmov	r2, r3, d8
 802a4d2:	f7dd f959 	bl	8007788 <__aeabi_dsub>
 802a4d6:	4602      	mov	r2, r0
 802a4d8:	460b      	mov	r3, r1
 802a4da:	4650      	mov	r0, sl
 802a4dc:	4659      	mov	r1, fp
 802a4de:	e606      	b.n	802a0ee <__ieee754_pow+0x2ee>
 802a4e0:	2401      	movs	r4, #1
 802a4e2:	e6a0      	b.n	802a226 <__ieee754_pow+0x426>
 802a4e4:	ed9f 7b14 	vldr	d7, [pc, #80]	; 802a538 <__ieee754_pow+0x738>
 802a4e8:	e60d      	b.n	802a106 <__ieee754_pow+0x306>
 802a4ea:	bf00      	nop
 802a4ec:	f3af 8000 	nop.w
 802a4f0:	4a454eef 	.word	0x4a454eef
 802a4f4:	3fca7e28 	.word	0x3fca7e28
 802a4f8:	93c9db65 	.word	0x93c9db65
 802a4fc:	3fcd864a 	.word	0x3fcd864a
 802a500:	a91d4101 	.word	0xa91d4101
 802a504:	3fd17460 	.word	0x3fd17460
 802a508:	518f264d 	.word	0x518f264d
 802a50c:	3fd55555 	.word	0x3fd55555
 802a510:	db6fabff 	.word	0xdb6fabff
 802a514:	3fdb6db6 	.word	0x3fdb6db6
 802a518:	33333303 	.word	0x33333303
 802a51c:	3fe33333 	.word	0x3fe33333
 802a520:	e0000000 	.word	0xe0000000
 802a524:	3feec709 	.word	0x3feec709
 802a528:	dc3a03fd 	.word	0xdc3a03fd
 802a52c:	3feec709 	.word	0x3feec709
 802a530:	145b01f5 	.word	0x145b01f5
 802a534:	be3e2fe0 	.word	0xbe3e2fe0
 802a538:	00000000 	.word	0x00000000
 802a53c:	3ff00000 	.word	0x3ff00000
 802a540:	7ff00000 	.word	0x7ff00000
 802a544:	43400000 	.word	0x43400000
 802a548:	0003988e 	.word	0x0003988e
 802a54c:	000bb679 	.word	0x000bb679
 802a550:	0802d908 	.word	0x0802d908
 802a554:	3ff00000 	.word	0x3ff00000
 802a558:	40080000 	.word	0x40080000
 802a55c:	0802d928 	.word	0x0802d928
 802a560:	0802d918 	.word	0x0802d918
 802a564:	a3b5      	add	r3, pc, #724	; (adr r3, 802a83c <__ieee754_pow+0xa3c>)
 802a566:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a56a:	4640      	mov	r0, r8
 802a56c:	4649      	mov	r1, r9
 802a56e:	f7dd f90d 	bl	800778c <__adddf3>
 802a572:	4622      	mov	r2, r4
 802a574:	ec41 0b1a 	vmov	d10, r0, r1
 802a578:	462b      	mov	r3, r5
 802a57a:	4630      	mov	r0, r6
 802a57c:	4639      	mov	r1, r7
 802a57e:	f7dd f903 	bl	8007788 <__aeabi_dsub>
 802a582:	4602      	mov	r2, r0
 802a584:	460b      	mov	r3, r1
 802a586:	ec51 0b1a 	vmov	r0, r1, d10
 802a58a:	f7dd fd45 	bl	8008018 <__aeabi_dcmpgt>
 802a58e:	2800      	cmp	r0, #0
 802a590:	f47f adf8 	bne.w	802a184 <__ieee754_pow+0x384>
 802a594:	4aa4      	ldr	r2, [pc, #656]	; (802a828 <__ieee754_pow+0xa28>)
 802a596:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 802a59a:	4293      	cmp	r3, r2
 802a59c:	f340 810b 	ble.w	802a7b6 <__ieee754_pow+0x9b6>
 802a5a0:	151b      	asrs	r3, r3, #20
 802a5a2:	f44f 1a80 	mov.w	sl, #1048576	; 0x100000
 802a5a6:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
 802a5aa:	fa4a f303 	asr.w	r3, sl, r3
 802a5ae:	445b      	add	r3, fp
 802a5b0:	f3c3 520a 	ubfx	r2, r3, #20, #11
 802a5b4:	4e9d      	ldr	r6, [pc, #628]	; (802a82c <__ieee754_pow+0xa2c>)
 802a5b6:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
 802a5ba:	4116      	asrs	r6, r2
 802a5bc:	f3c3 0a13 	ubfx	sl, r3, #0, #20
 802a5c0:	2000      	movs	r0, #0
 802a5c2:	ea23 0106 	bic.w	r1, r3, r6
 802a5c6:	f1c2 0214 	rsb	r2, r2, #20
 802a5ca:	f44a 1a80 	orr.w	sl, sl, #1048576	; 0x100000
 802a5ce:	fa4a fa02 	asr.w	sl, sl, r2
 802a5d2:	f1bb 0f00 	cmp.w	fp, #0
 802a5d6:	4602      	mov	r2, r0
 802a5d8:	460b      	mov	r3, r1
 802a5da:	4620      	mov	r0, r4
 802a5dc:	4629      	mov	r1, r5
 802a5de:	bfb8      	it	lt
 802a5e0:	f1ca 0a00 	rsblt	sl, sl, #0
 802a5e4:	f7dd f8d0 	bl	8007788 <__aeabi_dsub>
 802a5e8:	ec41 0b19 	vmov	d9, r0, r1
 802a5ec:	4642      	mov	r2, r8
 802a5ee:	464b      	mov	r3, r9
 802a5f0:	ec51 0b19 	vmov	r0, r1, d9
 802a5f4:	f7dd f8ca 	bl	800778c <__adddf3>
 802a5f8:	2400      	movs	r4, #0
 802a5fa:	a379      	add	r3, pc, #484	; (adr r3, 802a7e0 <__ieee754_pow+0x9e0>)
 802a5fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a600:	4620      	mov	r0, r4
 802a602:	460d      	mov	r5, r1
 802a604:	f7dd fa78 	bl	8007af8 <__aeabi_dmul>
 802a608:	ec53 2b19 	vmov	r2, r3, d9
 802a60c:	4606      	mov	r6, r0
 802a60e:	460f      	mov	r7, r1
 802a610:	4620      	mov	r0, r4
 802a612:	4629      	mov	r1, r5
 802a614:	f7dd f8b8 	bl	8007788 <__aeabi_dsub>
 802a618:	4602      	mov	r2, r0
 802a61a:	460b      	mov	r3, r1
 802a61c:	4640      	mov	r0, r8
 802a61e:	4649      	mov	r1, r9
 802a620:	f7dd f8b2 	bl	8007788 <__aeabi_dsub>
 802a624:	a370      	add	r3, pc, #448	; (adr r3, 802a7e8 <__ieee754_pow+0x9e8>)
 802a626:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a62a:	f7dd fa65 	bl	8007af8 <__aeabi_dmul>
 802a62e:	a370      	add	r3, pc, #448	; (adr r3, 802a7f0 <__ieee754_pow+0x9f0>)
 802a630:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a634:	4680      	mov	r8, r0
 802a636:	4689      	mov	r9, r1
 802a638:	4620      	mov	r0, r4
 802a63a:	4629      	mov	r1, r5
 802a63c:	f7dd fa5c 	bl	8007af8 <__aeabi_dmul>
 802a640:	4602      	mov	r2, r0
 802a642:	460b      	mov	r3, r1
 802a644:	4640      	mov	r0, r8
 802a646:	4649      	mov	r1, r9
 802a648:	f7dd f8a0 	bl	800778c <__adddf3>
 802a64c:	4604      	mov	r4, r0
 802a64e:	460d      	mov	r5, r1
 802a650:	4602      	mov	r2, r0
 802a652:	460b      	mov	r3, r1
 802a654:	4630      	mov	r0, r6
 802a656:	4639      	mov	r1, r7
 802a658:	f7dd f898 	bl	800778c <__adddf3>
 802a65c:	4632      	mov	r2, r6
 802a65e:	463b      	mov	r3, r7
 802a660:	4680      	mov	r8, r0
 802a662:	4689      	mov	r9, r1
 802a664:	f7dd f890 	bl	8007788 <__aeabi_dsub>
 802a668:	4602      	mov	r2, r0
 802a66a:	460b      	mov	r3, r1
 802a66c:	4620      	mov	r0, r4
 802a66e:	4629      	mov	r1, r5
 802a670:	f7dd f88a 	bl	8007788 <__aeabi_dsub>
 802a674:	4642      	mov	r2, r8
 802a676:	4606      	mov	r6, r0
 802a678:	460f      	mov	r7, r1
 802a67a:	464b      	mov	r3, r9
 802a67c:	4640      	mov	r0, r8
 802a67e:	4649      	mov	r1, r9
 802a680:	f7dd fa3a 	bl	8007af8 <__aeabi_dmul>
 802a684:	a35c      	add	r3, pc, #368	; (adr r3, 802a7f8 <__ieee754_pow+0x9f8>)
 802a686:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a68a:	4604      	mov	r4, r0
 802a68c:	460d      	mov	r5, r1
 802a68e:	f7dd fa33 	bl	8007af8 <__aeabi_dmul>
 802a692:	a35b      	add	r3, pc, #364	; (adr r3, 802a800 <__ieee754_pow+0xa00>)
 802a694:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a698:	f7dd f876 	bl	8007788 <__aeabi_dsub>
 802a69c:	4622      	mov	r2, r4
 802a69e:	462b      	mov	r3, r5
 802a6a0:	f7dd fa2a 	bl	8007af8 <__aeabi_dmul>
 802a6a4:	a358      	add	r3, pc, #352	; (adr r3, 802a808 <__ieee754_pow+0xa08>)
 802a6a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a6aa:	f7dd f86f 	bl	800778c <__adddf3>
 802a6ae:	4622      	mov	r2, r4
 802a6b0:	462b      	mov	r3, r5
 802a6b2:	f7dd fa21 	bl	8007af8 <__aeabi_dmul>
 802a6b6:	a356      	add	r3, pc, #344	; (adr r3, 802a810 <__ieee754_pow+0xa10>)
 802a6b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a6bc:	f7dd f864 	bl	8007788 <__aeabi_dsub>
 802a6c0:	4622      	mov	r2, r4
 802a6c2:	462b      	mov	r3, r5
 802a6c4:	f7dd fa18 	bl	8007af8 <__aeabi_dmul>
 802a6c8:	a353      	add	r3, pc, #332	; (adr r3, 802a818 <__ieee754_pow+0xa18>)
 802a6ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a6ce:	f7dd f85d 	bl	800778c <__adddf3>
 802a6d2:	4622      	mov	r2, r4
 802a6d4:	462b      	mov	r3, r5
 802a6d6:	f7dd fa0f 	bl	8007af8 <__aeabi_dmul>
 802a6da:	4602      	mov	r2, r0
 802a6dc:	460b      	mov	r3, r1
 802a6de:	4640      	mov	r0, r8
 802a6e0:	4649      	mov	r1, r9
 802a6e2:	f7dd f851 	bl	8007788 <__aeabi_dsub>
 802a6e6:	4604      	mov	r4, r0
 802a6e8:	460d      	mov	r5, r1
 802a6ea:	4602      	mov	r2, r0
 802a6ec:	460b      	mov	r3, r1
 802a6ee:	4640      	mov	r0, r8
 802a6f0:	4649      	mov	r1, r9
 802a6f2:	f7dd fa01 	bl	8007af8 <__aeabi_dmul>
 802a6f6:	2200      	movs	r2, #0
 802a6f8:	ec41 0b19 	vmov	d9, r0, r1
 802a6fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802a700:	4620      	mov	r0, r4
 802a702:	4629      	mov	r1, r5
 802a704:	f7dd f840 	bl	8007788 <__aeabi_dsub>
 802a708:	4602      	mov	r2, r0
 802a70a:	460b      	mov	r3, r1
 802a70c:	ec51 0b19 	vmov	r0, r1, d9
 802a710:	f7dd fb1c 	bl	8007d4c <__aeabi_ddiv>
 802a714:	4632      	mov	r2, r6
 802a716:	4604      	mov	r4, r0
 802a718:	460d      	mov	r5, r1
 802a71a:	463b      	mov	r3, r7
 802a71c:	4640      	mov	r0, r8
 802a71e:	4649      	mov	r1, r9
 802a720:	f7dd f9ea 	bl	8007af8 <__aeabi_dmul>
 802a724:	4632      	mov	r2, r6
 802a726:	463b      	mov	r3, r7
 802a728:	f7dd f830 	bl	800778c <__adddf3>
 802a72c:	4602      	mov	r2, r0
 802a72e:	460b      	mov	r3, r1
 802a730:	4620      	mov	r0, r4
 802a732:	4629      	mov	r1, r5
 802a734:	f7dd f828 	bl	8007788 <__aeabi_dsub>
 802a738:	4642      	mov	r2, r8
 802a73a:	464b      	mov	r3, r9
 802a73c:	f7dd f824 	bl	8007788 <__aeabi_dsub>
 802a740:	460b      	mov	r3, r1
 802a742:	4602      	mov	r2, r0
 802a744:	493a      	ldr	r1, [pc, #232]	; (802a830 <__ieee754_pow+0xa30>)
 802a746:	2000      	movs	r0, #0
 802a748:	f7dd f81e 	bl	8007788 <__aeabi_dsub>
 802a74c:	e9cd 0100 	strd	r0, r1, [sp]
 802a750:	9b01      	ldr	r3, [sp, #4]
 802a752:	eb03 530a 	add.w	r3, r3, sl, lsl #20
 802a756:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 802a75a:	da2f      	bge.n	802a7bc <__ieee754_pow+0x9bc>
 802a75c:	4650      	mov	r0, sl
 802a75e:	ed9d 0b00 	vldr	d0, [sp]
 802a762:	f001 fb11 	bl	802bd88 <scalbn>
 802a766:	ec51 0b10 	vmov	r0, r1, d0
 802a76a:	ec53 2b18 	vmov	r2, r3, d8
 802a76e:	f7ff bbe0 	b.w	8029f32 <__ieee754_pow+0x132>
 802a772:	4b30      	ldr	r3, [pc, #192]	; (802a834 <__ieee754_pow+0xa34>)
 802a774:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 802a778:	429e      	cmp	r6, r3
 802a77a:	f77f af0b 	ble.w	802a594 <__ieee754_pow+0x794>
 802a77e:	4b2e      	ldr	r3, [pc, #184]	; (802a838 <__ieee754_pow+0xa38>)
 802a780:	440b      	add	r3, r1
 802a782:	4303      	orrs	r3, r0
 802a784:	d00b      	beq.n	802a79e <__ieee754_pow+0x99e>
 802a786:	a326      	add	r3, pc, #152	; (adr r3, 802a820 <__ieee754_pow+0xa20>)
 802a788:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a78c:	ec51 0b18 	vmov	r0, r1, d8
 802a790:	f7dd f9b2 	bl	8007af8 <__aeabi_dmul>
 802a794:	a322      	add	r3, pc, #136	; (adr r3, 802a820 <__ieee754_pow+0xa20>)
 802a796:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a79a:	f7ff bbca 	b.w	8029f32 <__ieee754_pow+0x132>
 802a79e:	4622      	mov	r2, r4
 802a7a0:	462b      	mov	r3, r5
 802a7a2:	f7dc fff1 	bl	8007788 <__aeabi_dsub>
 802a7a6:	4642      	mov	r2, r8
 802a7a8:	464b      	mov	r3, r9
 802a7aa:	f7dd fc2b 	bl	8008004 <__aeabi_dcmpge>
 802a7ae:	2800      	cmp	r0, #0
 802a7b0:	f43f aef0 	beq.w	802a594 <__ieee754_pow+0x794>
 802a7b4:	e7e7      	b.n	802a786 <__ieee754_pow+0x986>
 802a7b6:	f04f 0a00 	mov.w	sl, #0
 802a7ba:	e717      	b.n	802a5ec <__ieee754_pow+0x7ec>
 802a7bc:	e9dd 0100 	ldrd	r0, r1, [sp]
 802a7c0:	4619      	mov	r1, r3
 802a7c2:	e7d2      	b.n	802a76a <__ieee754_pow+0x96a>
 802a7c4:	491a      	ldr	r1, [pc, #104]	; (802a830 <__ieee754_pow+0xa30>)
 802a7c6:	2000      	movs	r0, #0
 802a7c8:	f7ff bb9e 	b.w	8029f08 <__ieee754_pow+0x108>
 802a7cc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802a7d0:	f7ff bb9a 	b.w	8029f08 <__ieee754_pow+0x108>
 802a7d4:	9000      	str	r0, [sp, #0]
 802a7d6:	f7ff bb76 	b.w	8029ec6 <__ieee754_pow+0xc6>
 802a7da:	2100      	movs	r1, #0
 802a7dc:	f7ff bb60 	b.w	8029ea0 <__ieee754_pow+0xa0>
 802a7e0:	00000000 	.word	0x00000000
 802a7e4:	3fe62e43 	.word	0x3fe62e43
 802a7e8:	fefa39ef 	.word	0xfefa39ef
 802a7ec:	3fe62e42 	.word	0x3fe62e42
 802a7f0:	0ca86c39 	.word	0x0ca86c39
 802a7f4:	be205c61 	.word	0xbe205c61
 802a7f8:	72bea4d0 	.word	0x72bea4d0
 802a7fc:	3e663769 	.word	0x3e663769
 802a800:	c5d26bf1 	.word	0xc5d26bf1
 802a804:	3ebbbd41 	.word	0x3ebbbd41
 802a808:	af25de2c 	.word	0xaf25de2c
 802a80c:	3f11566a 	.word	0x3f11566a
 802a810:	16bebd93 	.word	0x16bebd93
 802a814:	3f66c16c 	.word	0x3f66c16c
 802a818:	5555553e 	.word	0x5555553e
 802a81c:	3fc55555 	.word	0x3fc55555
 802a820:	c2f8f359 	.word	0xc2f8f359
 802a824:	01a56e1f 	.word	0x01a56e1f
 802a828:	3fe00000 	.word	0x3fe00000
 802a82c:	000fffff 	.word	0x000fffff
 802a830:	3ff00000 	.word	0x3ff00000
 802a834:	4090cbff 	.word	0x4090cbff
 802a838:	3f6f3400 	.word	0x3f6f3400
 802a83c:	652b82fe 	.word	0x652b82fe
 802a840:	3c971547 	.word	0x3c971547

0802a844 <__ieee754_sqrt>:
 802a844:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a848:	ec55 4b10 	vmov	r4, r5, d0
 802a84c:	4e56      	ldr	r6, [pc, #344]	; (802a9a8 <__ieee754_sqrt+0x164>)
 802a84e:	43ae      	bics	r6, r5
 802a850:	ee10 0a10 	vmov	r0, s0
 802a854:	ee10 3a10 	vmov	r3, s0
 802a858:	4629      	mov	r1, r5
 802a85a:	462a      	mov	r2, r5
 802a85c:	d110      	bne.n	802a880 <__ieee754_sqrt+0x3c>
 802a85e:	ee10 2a10 	vmov	r2, s0
 802a862:	462b      	mov	r3, r5
 802a864:	f7dd f948 	bl	8007af8 <__aeabi_dmul>
 802a868:	4602      	mov	r2, r0
 802a86a:	460b      	mov	r3, r1
 802a86c:	4620      	mov	r0, r4
 802a86e:	4629      	mov	r1, r5
 802a870:	f7dc ff8c 	bl	800778c <__adddf3>
 802a874:	4604      	mov	r4, r0
 802a876:	460d      	mov	r5, r1
 802a878:	ec45 4b10 	vmov	d0, r4, r5
 802a87c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a880:	2d00      	cmp	r5, #0
 802a882:	dc10      	bgt.n	802a8a6 <__ieee754_sqrt+0x62>
 802a884:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
 802a888:	4330      	orrs	r0, r6
 802a88a:	d0f5      	beq.n	802a878 <__ieee754_sqrt+0x34>
 802a88c:	b15d      	cbz	r5, 802a8a6 <__ieee754_sqrt+0x62>
 802a88e:	ee10 2a10 	vmov	r2, s0
 802a892:	462b      	mov	r3, r5
 802a894:	ee10 0a10 	vmov	r0, s0
 802a898:	f7dc ff76 	bl	8007788 <__aeabi_dsub>
 802a89c:	4602      	mov	r2, r0
 802a89e:	460b      	mov	r3, r1
 802a8a0:	f7dd fa54 	bl	8007d4c <__aeabi_ddiv>
 802a8a4:	e7e6      	b.n	802a874 <__ieee754_sqrt+0x30>
 802a8a6:	1509      	asrs	r1, r1, #20
 802a8a8:	d076      	beq.n	802a998 <__ieee754_sqrt+0x154>
 802a8aa:	f3c2 0213 	ubfx	r2, r2, #0, #20
 802a8ae:	07ce      	lsls	r6, r1, #31
 802a8b0:	f442 1080 	orr.w	r0, r2, #1048576	; 0x100000
 802a8b4:	bf5e      	ittt	pl
 802a8b6:	0fda      	lsrpl	r2, r3, #31
 802a8b8:	005b      	lslpl	r3, r3, #1
 802a8ba:	eb02 0040 	addpl.w	r0, r2, r0, lsl #1
 802a8be:	0fda      	lsrs	r2, r3, #31
 802a8c0:	f2a1 35ff 	subw	r5, r1, #1023	; 0x3ff
 802a8c4:	eb02 0240 	add.w	r2, r2, r0, lsl #1
 802a8c8:	2000      	movs	r0, #0
 802a8ca:	106d      	asrs	r5, r5, #1
 802a8cc:	005b      	lsls	r3, r3, #1
 802a8ce:	f04f 0e16 	mov.w	lr, #22
 802a8d2:	4684      	mov	ip, r0
 802a8d4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 802a8d8:	eb0c 0401 	add.w	r4, ip, r1
 802a8dc:	4294      	cmp	r4, r2
 802a8de:	bfde      	ittt	le
 802a8e0:	1b12      	suble	r2, r2, r4
 802a8e2:	eb04 0c01 	addle.w	ip, r4, r1
 802a8e6:	1840      	addle	r0, r0, r1
 802a8e8:	0052      	lsls	r2, r2, #1
 802a8ea:	f1be 0e01 	subs.w	lr, lr, #1
 802a8ee:	eb02 72d3 	add.w	r2, r2, r3, lsr #31
 802a8f2:	ea4f 0151 	mov.w	r1, r1, lsr #1
 802a8f6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802a8fa:	d1ed      	bne.n	802a8d8 <__ieee754_sqrt+0x94>
 802a8fc:	4671      	mov	r1, lr
 802a8fe:	2720      	movs	r7, #32
 802a900:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 802a904:	4562      	cmp	r2, ip
 802a906:	eb04 060e 	add.w	r6, r4, lr
 802a90a:	dc02      	bgt.n	802a912 <__ieee754_sqrt+0xce>
 802a90c:	d113      	bne.n	802a936 <__ieee754_sqrt+0xf2>
 802a90e:	429e      	cmp	r6, r3
 802a910:	d811      	bhi.n	802a936 <__ieee754_sqrt+0xf2>
 802a912:	2e00      	cmp	r6, #0
 802a914:	eb06 0e04 	add.w	lr, r6, r4
 802a918:	da43      	bge.n	802a9a2 <__ieee754_sqrt+0x15e>
 802a91a:	f1be 0f00 	cmp.w	lr, #0
 802a91e:	db40      	blt.n	802a9a2 <__ieee754_sqrt+0x15e>
 802a920:	f10c 0801 	add.w	r8, ip, #1
 802a924:	eba2 020c 	sub.w	r2, r2, ip
 802a928:	429e      	cmp	r6, r3
 802a92a:	bf88      	it	hi
 802a92c:	f102 32ff 	addhi.w	r2, r2, #4294967295	; 0xffffffff
 802a930:	1b9b      	subs	r3, r3, r6
 802a932:	4421      	add	r1, r4
 802a934:	46c4      	mov	ip, r8
 802a936:	0052      	lsls	r2, r2, #1
 802a938:	3f01      	subs	r7, #1
 802a93a:	eb02 72d3 	add.w	r2, r2, r3, lsr #31
 802a93e:	ea4f 0454 	mov.w	r4, r4, lsr #1
 802a942:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802a946:	d1dd      	bne.n	802a904 <__ieee754_sqrt+0xc0>
 802a948:	4313      	orrs	r3, r2
 802a94a:	d006      	beq.n	802a95a <__ieee754_sqrt+0x116>
 802a94c:	1c4c      	adds	r4, r1, #1
 802a94e:	bf13      	iteet	ne
 802a950:	3101      	addne	r1, #1
 802a952:	3001      	addeq	r0, #1
 802a954:	4639      	moveq	r1, r7
 802a956:	f021 0101 	bicne.w	r1, r1, #1
 802a95a:	1043      	asrs	r3, r0, #1
 802a95c:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
 802a960:	0849      	lsrs	r1, r1, #1
 802a962:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 802a966:	07c2      	lsls	r2, r0, #31
 802a968:	bf48      	it	mi
 802a96a:	f041 4100 	orrmi.w	r1, r1, #2147483648	; 0x80000000
 802a96e:	eb03 5705 	add.w	r7, r3, r5, lsl #20
 802a972:	460c      	mov	r4, r1
 802a974:	463d      	mov	r5, r7
 802a976:	e77f      	b.n	802a878 <__ieee754_sqrt+0x34>
 802a978:	0ada      	lsrs	r2, r3, #11
 802a97a:	3815      	subs	r0, #21
 802a97c:	055b      	lsls	r3, r3, #21
 802a97e:	2a00      	cmp	r2, #0
 802a980:	d0fa      	beq.n	802a978 <__ieee754_sqrt+0x134>
 802a982:	02d7      	lsls	r7, r2, #11
 802a984:	d50a      	bpl.n	802a99c <__ieee754_sqrt+0x158>
 802a986:	f1c1 0420 	rsb	r4, r1, #32
 802a98a:	fa23 f404 	lsr.w	r4, r3, r4
 802a98e:	1e4d      	subs	r5, r1, #1
 802a990:	408b      	lsls	r3, r1
 802a992:	4322      	orrs	r2, r4
 802a994:	1b41      	subs	r1, r0, r5
 802a996:	e788      	b.n	802a8aa <__ieee754_sqrt+0x66>
 802a998:	4608      	mov	r0, r1
 802a99a:	e7f0      	b.n	802a97e <__ieee754_sqrt+0x13a>
 802a99c:	0052      	lsls	r2, r2, #1
 802a99e:	3101      	adds	r1, #1
 802a9a0:	e7ef      	b.n	802a982 <__ieee754_sqrt+0x13e>
 802a9a2:	46e0      	mov	r8, ip
 802a9a4:	e7be      	b.n	802a924 <__ieee754_sqrt+0xe0>
 802a9a6:	bf00      	nop
 802a9a8:	7ff00000 	.word	0x7ff00000

0802a9ac <__ieee754_expf>:
 802a9ac:	ee10 2a10 	vmov	r2, s0
 802a9b0:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 802a9b4:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802a9b8:	d902      	bls.n	802a9c0 <__ieee754_expf+0x14>
 802a9ba:	ee30 0a00 	vadd.f32	s0, s0, s0
 802a9be:	4770      	bx	lr
 802a9c0:	ea4f 73d2 	mov.w	r3, r2, lsr #31
 802a9c4:	d106      	bne.n	802a9d4 <__ieee754_expf+0x28>
 802a9c6:	eddf 7a51 	vldr	s15, [pc, #324]	; 802ab0c <__ieee754_expf+0x160>
 802a9ca:	2b00      	cmp	r3, #0
 802a9cc:	bf18      	it	ne
 802a9ce:	eeb0 0a67 	vmovne.f32	s0, s15
 802a9d2:	4770      	bx	lr
 802a9d4:	484e      	ldr	r0, [pc, #312]	; (802ab10 <__ieee754_expf+0x164>)
 802a9d6:	4282      	cmp	r2, r0
 802a9d8:	dd04      	ble.n	802a9e4 <__ieee754_expf+0x38>
 802a9da:	ed9f 0a4e 	vldr	s0, [pc, #312]	; 802ab14 <__ieee754_expf+0x168>
 802a9de:	ee20 0a00 	vmul.f32	s0, s0, s0
 802a9e2:	4770      	bx	lr
 802a9e4:	2a00      	cmp	r2, #0
 802a9e6:	da03      	bge.n	802a9f0 <__ieee754_expf+0x44>
 802a9e8:	4a4b      	ldr	r2, [pc, #300]	; (802ab18 <__ieee754_expf+0x16c>)
 802a9ea:	4291      	cmp	r1, r2
 802a9ec:	f200 808a 	bhi.w	802ab04 <__ieee754_expf+0x158>
 802a9f0:	4a4a      	ldr	r2, [pc, #296]	; (802ab1c <__ieee754_expf+0x170>)
 802a9f2:	4291      	cmp	r1, r2
 802a9f4:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 802a9f8:	d954      	bls.n	802aaa4 <__ieee754_expf+0xf8>
 802a9fa:	4a49      	ldr	r2, [pc, #292]	; (802ab20 <__ieee754_expf+0x174>)
 802a9fc:	4291      	cmp	r1, r2
 802a9fe:	ea4f 0283 	mov.w	r2, r3, lsl #2
 802aa02:	d836      	bhi.n	802aa72 <__ieee754_expf+0xc6>
 802aa04:	4947      	ldr	r1, [pc, #284]	; (802ab24 <__ieee754_expf+0x178>)
 802aa06:	4411      	add	r1, r2
 802aa08:	ed91 7a00 	vldr	s14, [r1]
 802aa0c:	4946      	ldr	r1, [pc, #280]	; (802ab28 <__ieee754_expf+0x17c>)
 802aa0e:	440a      	add	r2, r1
 802aa10:	edd2 7a00 	vldr	s15, [r2]
 802aa14:	ee30 7a47 	vsub.f32	s14, s0, s14
 802aa18:	f1c3 0201 	rsb	r2, r3, #1
 802aa1c:	1ad2      	subs	r2, r2, r3
 802aa1e:	ee37 0a67 	vsub.f32	s0, s14, s15
 802aa22:	ee60 6a00 	vmul.f32	s13, s0, s0
 802aa26:	eddf 5a41 	vldr	s11, [pc, #260]	; 802ab2c <__ieee754_expf+0x180>
 802aa2a:	ed9f 5a41 	vldr	s10, [pc, #260]	; 802ab30 <__ieee754_expf+0x184>
 802aa2e:	eea6 5aa5 	vfma.f32	s10, s13, s11
 802aa32:	eddf 5a40 	vldr	s11, [pc, #256]	; 802ab34 <__ieee754_expf+0x188>
 802aa36:	eee5 5a26 	vfma.f32	s11, s10, s13
 802aa3a:	ed9f 5a3f 	vldr	s10, [pc, #252]	; 802ab38 <__ieee754_expf+0x18c>
 802aa3e:	eea5 5aa6 	vfma.f32	s10, s11, s13
 802aa42:	eddf 5a3e 	vldr	s11, [pc, #248]	; 802ab3c <__ieee754_expf+0x190>
 802aa46:	eee5 5a26 	vfma.f32	s11, s10, s13
 802aa4a:	eeb0 5a40 	vmov.f32	s10, s0
 802aa4e:	eea5 5ae6 	vfms.f32	s10, s11, s13
 802aa52:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 802aa56:	eef0 6a45 	vmov.f32	s13, s10
 802aa5a:	ee20 5a05 	vmul.f32	s10, s0, s10
 802aa5e:	bb92      	cbnz	r2, 802aac6 <__ieee754_expf+0x11a>
 802aa60:	ee76 6ae5 	vsub.f32	s13, s13, s11
 802aa64:	eec5 7a26 	vdiv.f32	s15, s10, s13
 802aa68:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802aa6c:	ee36 0a40 	vsub.f32	s0, s12, s0
 802aa70:	4770      	bx	lr
 802aa72:	4b33      	ldr	r3, [pc, #204]	; (802ab40 <__ieee754_expf+0x194>)
 802aa74:	ed9f 7a33 	vldr	s14, [pc, #204]	; 802ab44 <__ieee754_expf+0x198>
 802aa78:	4413      	add	r3, r2
 802aa7a:	edd3 7a00 	vldr	s15, [r3]
 802aa7e:	eee0 7a07 	vfma.f32	s15, s0, s14
 802aa82:	ed9f 7a31 	vldr	s14, [pc, #196]	; 802ab48 <__ieee754_expf+0x19c>
 802aa86:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802aa8a:	ee17 2a90 	vmov	r2, s15
 802aa8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802aa92:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802aa96:	eeb0 7a40 	vmov.f32	s14, s0
 802aa9a:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 802ab4c <__ieee754_expf+0x1a0>
 802aa9e:	ee67 7a80 	vmul.f32	s15, s15, s0
 802aaa2:	e7bc      	b.n	802aa1e <__ieee754_expf+0x72>
 802aaa4:	f1b1 5f46 	cmp.w	r1, #830472192	; 0x31800000
 802aaa8:	d20b      	bcs.n	802aac2 <__ieee754_expf+0x116>
 802aaaa:	eddf 6a1a 	vldr	s13, [pc, #104]	; 802ab14 <__ieee754_expf+0x168>
 802aaae:	ee70 6a26 	vadd.f32	s13, s0, s13
 802aab2:	eef4 6ac6 	vcmpe.f32	s13, s12
 802aab6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aaba:	dd02      	ble.n	802aac2 <__ieee754_expf+0x116>
 802aabc:	ee30 0a06 	vadd.f32	s0, s0, s12
 802aac0:	4770      	bx	lr
 802aac2:	2200      	movs	r2, #0
 802aac4:	e7ad      	b.n	802aa22 <__ieee754_expf+0x76>
 802aac6:	ee75 6ae6 	vsub.f32	s13, s11, s13
 802aaca:	f112 0f7d 	cmn.w	r2, #125	; 0x7d
 802aace:	ee85 0a26 	vdiv.f32	s0, s10, s13
 802aad2:	bfb8      	it	lt
 802aad4:	3264      	addlt	r2, #100	; 0x64
 802aad6:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802aada:	ee37 0ac7 	vsub.f32	s0, s15, s14
 802aade:	ee76 7a40 	vsub.f32	s15, s12, s0
 802aae2:	ee17 3a90 	vmov	r3, s15
 802aae6:	bfab      	itete	ge
 802aae8:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 802aaec:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 802aaf0:	ee00 3a10 	vmovge	s0, r3
 802aaf4:	eddf 7a16 	vldrlt	s15, [pc, #88]	; 802ab50 <__ieee754_expf+0x1a4>
 802aaf8:	bfbc      	itt	lt
 802aafa:	ee00 3a10 	vmovlt	s0, r3
 802aafe:	ee20 0a27 	vmullt.f32	s0, s0, s15
 802ab02:	4770      	bx	lr
 802ab04:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802ab0c <__ieee754_expf+0x160>
 802ab08:	4770      	bx	lr
 802ab0a:	bf00      	nop
 802ab0c:	00000000 	.word	0x00000000
 802ab10:	42b17217 	.word	0x42b17217
 802ab14:	7149f2ca 	.word	0x7149f2ca
 802ab18:	42cff1b5 	.word	0x42cff1b5
 802ab1c:	3eb17218 	.word	0x3eb17218
 802ab20:	3f851591 	.word	0x3f851591
 802ab24:	0802d940 	.word	0x0802d940
 802ab28:	0802d948 	.word	0x0802d948
 802ab2c:	3331bb4c 	.word	0x3331bb4c
 802ab30:	b5ddea0e 	.word	0xb5ddea0e
 802ab34:	388ab355 	.word	0x388ab355
 802ab38:	bb360b61 	.word	0xbb360b61
 802ab3c:	3e2aaaab 	.word	0x3e2aaaab
 802ab40:	0802d938 	.word	0x0802d938
 802ab44:	3fb8aa3b 	.word	0x3fb8aa3b
 802ab48:	3f317180 	.word	0x3f317180
 802ab4c:	3717f7d1 	.word	0x3717f7d1
 802ab50:	0d800000 	.word	0x0d800000

0802ab54 <__ieee754_logf>:
 802ab54:	ee10 3a10 	vmov	r3, s0
 802ab58:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802ab5c:	d106      	bne.n	802ab6c <__ieee754_logf+0x18>
 802ab5e:	ed9f 7a65 	vldr	s14, [pc, #404]	; 802acf4 <__ieee754_logf+0x1a0>
 802ab62:	eddf 7a65 	vldr	s15, [pc, #404]	; 802acf8 <__ieee754_logf+0x1a4>
 802ab66:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802ab6a:	4770      	bx	lr
 802ab6c:	2b00      	cmp	r3, #0
 802ab6e:	da02      	bge.n	802ab76 <__ieee754_logf+0x22>
 802ab70:	ee30 7a40 	vsub.f32	s14, s0, s0
 802ab74:	e7f5      	b.n	802ab62 <__ieee754_logf+0xe>
 802ab76:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802ab7a:	db02      	blt.n	802ab82 <__ieee754_logf+0x2e>
 802ab7c:	ee30 0a00 	vadd.f32	s0, s0, s0
 802ab80:	4770      	bx	lr
 802ab82:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802ab86:	bfb8      	it	lt
 802ab88:	eddf 7a5c 	vldrlt	s15, [pc, #368]	; 802acfc <__ieee754_logf+0x1a8>
 802ab8c:	485c      	ldr	r0, [pc, #368]	; (802ad00 <__ieee754_logf+0x1ac>)
 802ab8e:	bfbe      	ittt	lt
 802ab90:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802ab94:	f06f 0118 	mvnlt.w	r1, #24
 802ab98:	ee17 3a90 	vmovlt	r3, s15
 802ab9c:	ea4f 52e3 	mov.w	r2, r3, asr #23
 802aba0:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802aba4:	4418      	add	r0, r3
 802aba6:	bfa8      	it	ge
 802aba8:	2100      	movge	r1, #0
 802abaa:	3a7f      	subs	r2, #127	; 0x7f
 802abac:	440a      	add	r2, r1
 802abae:	f400 0100 	and.w	r1, r0, #8388608	; 0x800000
 802abb2:	f081 517e 	eor.w	r1, r1, #1065353216	; 0x3f800000
 802abb6:	4319      	orrs	r1, r3
 802abb8:	ee00 1a10 	vmov	s0, r1
 802abbc:	4951      	ldr	r1, [pc, #324]	; (802ad04 <__ieee754_logf+0x1b0>)
 802abbe:	eb02 52d0 	add.w	r2, r2, r0, lsr #23
 802abc2:	f103 000f 	add.w	r0, r3, #15
 802abc6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802abca:	4001      	ands	r1, r0
 802abcc:	ee30 0a67 	vsub.f32	s0, s0, s15
 802abd0:	bb89      	cbnz	r1, 802ac36 <__ieee754_logf+0xe2>
 802abd2:	eeb5 0a40 	vcmp.f32	s0, #0.0
 802abd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abda:	d10f      	bne.n	802abfc <__ieee754_logf+0xa8>
 802abdc:	2a00      	cmp	r2, #0
 802abde:	f000 8085 	beq.w	802acec <__ieee754_logf+0x198>
 802abe2:	ee07 2a90 	vmov	s15, r2
 802abe6:	ed9f 0a48 	vldr	s0, [pc, #288]	; 802ad08 <__ieee754_logf+0x1b4>
 802abea:	ed9f 7a48 	vldr	s14, [pc, #288]	; 802ad0c <__ieee754_logf+0x1b8>
 802abee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802abf2:	ee27 0a80 	vmul.f32	s0, s15, s0
 802abf6:	eea7 0a87 	vfma.f32	s0, s15, s14
 802abfa:	4770      	bx	lr
 802abfc:	eddf 6a44 	vldr	s13, [pc, #272]	; 802ad10 <__ieee754_logf+0x1bc>
 802ac00:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802ac04:	eee0 7a66 	vfms.f32	s15, s0, s13
 802ac08:	ee20 7a00 	vmul.f32	s14, s0, s0
 802ac0c:	ee27 7a27 	vmul.f32	s14, s14, s15
 802ac10:	b912      	cbnz	r2, 802ac18 <__ieee754_logf+0xc4>
 802ac12:	ee30 0a47 	vsub.f32	s0, s0, s14
 802ac16:	4770      	bx	lr
 802ac18:	ee07 2a90 	vmov	s15, r2
 802ac1c:	eddf 6a3a 	vldr	s13, [pc, #232]	; 802ad08 <__ieee754_logf+0x1b4>
 802ac20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ac24:	eea7 7ae6 	vfms.f32	s14, s15, s13
 802ac28:	ee37 0a40 	vsub.f32	s0, s14, s0
 802ac2c:	ed9f 7a37 	vldr	s14, [pc, #220]	; 802ad0c <__ieee754_logf+0x1b8>
 802ac30:	ee97 0a87 	vfnms.f32	s0, s15, s14
 802ac34:	4770      	bx	lr
 802ac36:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802ac3a:	ee70 7a27 	vadd.f32	s15, s0, s15
 802ac3e:	eddf 5a35 	vldr	s11, [pc, #212]	; 802ad14 <__ieee754_logf+0x1c0>
 802ac42:	eddf 4a35 	vldr	s9, [pc, #212]	; 802ad18 <__ieee754_logf+0x1c4>
 802ac46:	4935      	ldr	r1, [pc, #212]	; (802ad1c <__ieee754_logf+0x1c8>)
 802ac48:	ee80 6a27 	vdiv.f32	s12, s0, s15
 802ac4c:	4419      	add	r1, r3
 802ac4e:	f5c3 1357 	rsb	r3, r3, #3522560	; 0x35c000
 802ac52:	f503 7322 	add.w	r3, r3, #648	; 0x288
 802ac56:	430b      	orrs	r3, r1
 802ac58:	2b00      	cmp	r3, #0
 802ac5a:	ee07 2a90 	vmov	s15, r2
 802ac5e:	ee26 5a06 	vmul.f32	s10, s12, s12
 802ac62:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802ac66:	ee25 7a05 	vmul.f32	s14, s10, s10
 802ac6a:	eddf 7a2d 	vldr	s15, [pc, #180]	; 802ad20 <__ieee754_logf+0x1cc>
 802ac6e:	eee7 7a25 	vfma.f32	s15, s14, s11
 802ac72:	eddf 5a2c 	vldr	s11, [pc, #176]	; 802ad24 <__ieee754_logf+0x1d0>
 802ac76:	eee7 5a87 	vfma.f32	s11, s15, s14
 802ac7a:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802ad28 <__ieee754_logf+0x1d4>
 802ac7e:	eee7 7a24 	vfma.f32	s15, s14, s9
 802ac82:	eddf 4a2a 	vldr	s9, [pc, #168]	; 802ad2c <__ieee754_logf+0x1d8>
 802ac86:	eee7 4a87 	vfma.f32	s9, s15, s14
 802ac8a:	eddf 7a29 	vldr	s15, [pc, #164]	; 802ad30 <__ieee754_logf+0x1dc>
 802ac8e:	eee4 7a87 	vfma.f32	s15, s9, s14
 802ac92:	ee67 7a85 	vmul.f32	s15, s15, s10
 802ac96:	eee5 7a87 	vfma.f32	s15, s11, s14
 802ac9a:	dd1c      	ble.n	802acd6 <__ieee754_logf+0x182>
 802ac9c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802aca0:	ee20 7a07 	vmul.f32	s14, s0, s14
 802aca4:	ee27 7a00 	vmul.f32	s14, s14, s0
 802aca8:	ee77 7a87 	vadd.f32	s15, s15, s14
 802acac:	ee67 7a86 	vmul.f32	s15, s15, s12
 802acb0:	b922      	cbnz	r2, 802acbc <__ieee754_logf+0x168>
 802acb2:	ee77 7a67 	vsub.f32	s15, s14, s15
 802acb6:	ee30 0a67 	vsub.f32	s0, s0, s15
 802acba:	4770      	bx	lr
 802acbc:	ed9f 6a12 	vldr	s12, [pc, #72]	; 802ad08 <__ieee754_logf+0x1b4>
 802acc0:	eee6 7a86 	vfma.f32	s15, s13, s12
 802acc4:	ee77 7a67 	vsub.f32	s15, s14, s15
 802acc8:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802accc:	eddf 7a0f 	vldr	s15, [pc, #60]	; 802ad0c <__ieee754_logf+0x1b8>
 802acd0:	ee96 0aa7 	vfnms.f32	s0, s13, s15
 802acd4:	4770      	bx	lr
 802acd6:	ee70 7a67 	vsub.f32	s15, s0, s15
 802acda:	ee67 7a86 	vmul.f32	s15, s15, s12
 802acde:	2a00      	cmp	r2, #0
 802ace0:	d0e9      	beq.n	802acb6 <__ieee754_logf+0x162>
 802ace2:	ed9f 7a09 	vldr	s14, [pc, #36]	; 802ad08 <__ieee754_logf+0x1b4>
 802ace6:	eee6 7ac7 	vfms.f32	s15, s13, s14
 802acea:	e7ed      	b.n	802acc8 <__ieee754_logf+0x174>
 802acec:	ed9f 0a02 	vldr	s0, [pc, #8]	; 802acf8 <__ieee754_logf+0x1a4>
 802acf0:	4770      	bx	lr
 802acf2:	bf00      	nop
 802acf4:	cc000000 	.word	0xcc000000
 802acf8:	00000000 	.word	0x00000000
 802acfc:	4c000000 	.word	0x4c000000
 802ad00:	004afb20 	.word	0x004afb20
 802ad04:	007ffff0 	.word	0x007ffff0
 802ad08:	3717f7d1 	.word	0x3717f7d1
 802ad0c:	3f317180 	.word	0x3f317180
 802ad10:	3eaaaaab 	.word	0x3eaaaaab
 802ad14:	3e1cd04f 	.word	0x3e1cd04f
 802ad18:	3e178897 	.word	0x3e178897
 802ad1c:	ffcf5c30 	.word	0xffcf5c30
 802ad20:	3e638e29 	.word	0x3e638e29
 802ad24:	3ecccccd 	.word	0x3ecccccd
 802ad28:	3e3a3325 	.word	0x3e3a3325
 802ad2c:	3e924925 	.word	0x3e924925
 802ad30:	3f2aaaab 	.word	0x3f2aaaab

0802ad34 <__ieee754_log10f>:
 802ad34:	b508      	push	{r3, lr}
 802ad36:	ee10 2a10 	vmov	r2, s0
 802ad3a:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 802ad3e:	ed2d 8b02 	vpush	{d8}
 802ad42:	d108      	bne.n	802ad56 <__ieee754_log10f+0x22>
 802ad44:	ed9f 7a21 	vldr	s14, [pc, #132]	; 802adcc <__ieee754_log10f+0x98>
 802ad48:	eddf 7a21 	vldr	s15, [pc, #132]	; 802add0 <__ieee754_log10f+0x9c>
 802ad4c:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802ad50:	ecbd 8b02 	vpop	{d8}
 802ad54:	bd08      	pop	{r3, pc}
 802ad56:	2a00      	cmp	r2, #0
 802ad58:	da02      	bge.n	802ad60 <__ieee754_log10f+0x2c>
 802ad5a:	ee30 7a40 	vsub.f32	s14, s0, s0
 802ad5e:	e7f3      	b.n	802ad48 <__ieee754_log10f+0x14>
 802ad60:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802ad64:	db02      	blt.n	802ad6c <__ieee754_log10f+0x38>
 802ad66:	ee30 0a00 	vadd.f32	s0, s0, s0
 802ad6a:	e7f1      	b.n	802ad50 <__ieee754_log10f+0x1c>
 802ad6c:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802ad70:	bfbf      	itttt	lt
 802ad72:	eddf 7a18 	vldrlt	s15, [pc, #96]	; 802add4 <__ieee754_log10f+0xa0>
 802ad76:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802ad7a:	f06f 0118 	mvnlt.w	r1, #24
 802ad7e:	ee17 2a90 	vmovlt	r2, s15
 802ad82:	ea4f 53e2 	mov.w	r3, r2, asr #23
 802ad86:	bfa8      	it	ge
 802ad88:	2100      	movge	r1, #0
 802ad8a:	3b7f      	subs	r3, #127	; 0x7f
 802ad8c:	440b      	add	r3, r1
 802ad8e:	0fd9      	lsrs	r1, r3, #31
 802ad90:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 802ad94:	ee07 3a90 	vmov	s15, r3
 802ad98:	f3c2 0216 	ubfx	r2, r2, #0, #23
 802ad9c:	f1c1 037f 	rsb	r3, r1, #127	; 0x7f
 802ada0:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 802ada4:	ee00 3a10 	vmov	s0, r3
 802ada8:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 802adac:	f7ff fed2 	bl	802ab54 <__ieee754_logf>
 802adb0:	eddf 7a09 	vldr	s15, [pc, #36]	; 802add8 <__ieee754_log10f+0xa4>
 802adb4:	ee20 0a27 	vmul.f32	s0, s0, s15
 802adb8:	eddf 7a08 	vldr	s15, [pc, #32]	; 802addc <__ieee754_log10f+0xa8>
 802adbc:	eea8 0a27 	vfma.f32	s0, s16, s15
 802adc0:	eddf 7a07 	vldr	s15, [pc, #28]	; 802ade0 <__ieee754_log10f+0xac>
 802adc4:	eea8 0a27 	vfma.f32	s0, s16, s15
 802adc8:	e7c2      	b.n	802ad50 <__ieee754_log10f+0x1c>
 802adca:	bf00      	nop
 802adcc:	cc000000 	.word	0xcc000000
 802add0:	00000000 	.word	0x00000000
 802add4:	4c000000 	.word	0x4c000000
 802add8:	3ede5bd9 	.word	0x3ede5bd9
 802addc:	355427db 	.word	0x355427db
 802ade0:	3e9a2080 	.word	0x3e9a2080

0802ade4 <__ieee754_powf>:
 802ade4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ade8:	ee10 5a90 	vmov	r5, s1
 802adec:	f035 4700 	bics.w	r7, r5, #2147483648	; 0x80000000
 802adf0:	ed2d 8b02 	vpush	{d8}
 802adf4:	eeb0 8a40 	vmov.f32	s16, s0
 802adf8:	eef0 8a60 	vmov.f32	s17, s1
 802adfc:	f000 8291 	beq.w	802b322 <__ieee754_powf+0x53e>
 802ae00:	ee10 8a10 	vmov	r8, s0
 802ae04:	f028 4400 	bic.w	r4, r8, #2147483648	; 0x80000000
 802ae08:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802ae0c:	dc06      	bgt.n	802ae1c <__ieee754_powf+0x38>
 802ae0e:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802ae12:	dd0a      	ble.n	802ae2a <__ieee754_powf+0x46>
 802ae14:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802ae18:	f000 8283 	beq.w	802b322 <__ieee754_powf+0x53e>
 802ae1c:	ecbd 8b02 	vpop	{d8}
 802ae20:	48d8      	ldr	r0, [pc, #864]	; (802b184 <__ieee754_powf+0x3a0>)
 802ae22:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802ae26:	f001 b843 	b.w	802beb0 <nanf>
 802ae2a:	f1b8 0f00 	cmp.w	r8, #0
 802ae2e:	da1f      	bge.n	802ae70 <__ieee754_powf+0x8c>
 802ae30:	f1b7 4f97 	cmp.w	r7, #1266679808	; 0x4b800000
 802ae34:	da2e      	bge.n	802ae94 <__ieee754_powf+0xb0>
 802ae36:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802ae3a:	f2c0 827b 	blt.w	802b334 <__ieee754_powf+0x550>
 802ae3e:	15fb      	asrs	r3, r7, #23
 802ae40:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802ae44:	fa47 f603 	asr.w	r6, r7, r3
 802ae48:	fa06 f303 	lsl.w	r3, r6, r3
 802ae4c:	42bb      	cmp	r3, r7
 802ae4e:	f040 8271 	bne.w	802b334 <__ieee754_powf+0x550>
 802ae52:	f006 0601 	and.w	r6, r6, #1
 802ae56:	f1c6 0602 	rsb	r6, r6, #2
 802ae5a:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802ae5e:	d120      	bne.n	802aea2 <__ieee754_powf+0xbe>
 802ae60:	2d00      	cmp	r5, #0
 802ae62:	f280 8264 	bge.w	802b32e <__ieee754_powf+0x54a>
 802ae66:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802ae6a:	ee87 0a88 	vdiv.f32	s0, s15, s16
 802ae6e:	e00d      	b.n	802ae8c <__ieee754_powf+0xa8>
 802ae70:	2600      	movs	r6, #0
 802ae72:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802ae76:	d1f0      	bne.n	802ae5a <__ieee754_powf+0x76>
 802ae78:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802ae7c:	f000 8251 	beq.w	802b322 <__ieee754_powf+0x53e>
 802ae80:	dd0a      	ble.n	802ae98 <__ieee754_powf+0xb4>
 802ae82:	2d00      	cmp	r5, #0
 802ae84:	f280 8250 	bge.w	802b328 <__ieee754_powf+0x544>
 802ae88:	ed9f 0abf 	vldr	s0, [pc, #764]	; 802b188 <__ieee754_powf+0x3a4>
 802ae8c:	ecbd 8b02 	vpop	{d8}
 802ae90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ae94:	2602      	movs	r6, #2
 802ae96:	e7ec      	b.n	802ae72 <__ieee754_powf+0x8e>
 802ae98:	2d00      	cmp	r5, #0
 802ae9a:	daf5      	bge.n	802ae88 <__ieee754_powf+0xa4>
 802ae9c:	eeb1 0a68 	vneg.f32	s0, s17
 802aea0:	e7f4      	b.n	802ae8c <__ieee754_powf+0xa8>
 802aea2:	f1b5 4f80 	cmp.w	r5, #1073741824	; 0x40000000
 802aea6:	d102      	bne.n	802aeae <__ieee754_powf+0xca>
 802aea8:	ee28 0a08 	vmul.f32	s0, s16, s16
 802aeac:	e7ee      	b.n	802ae8c <__ieee754_powf+0xa8>
 802aeae:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 802aeb2:	eeb0 0a48 	vmov.f32	s0, s16
 802aeb6:	d108      	bne.n	802aeca <__ieee754_powf+0xe6>
 802aeb8:	f1b8 0f00 	cmp.w	r8, #0
 802aebc:	db05      	blt.n	802aeca <__ieee754_powf+0xe6>
 802aebe:	ecbd 8b02 	vpop	{d8}
 802aec2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802aec6:	f000 bb89 	b.w	802b5dc <__ieee754_sqrtf>
 802aeca:	f7fe fb2f 	bl	802952c <fabsf>
 802aece:	b124      	cbz	r4, 802aeda <__ieee754_powf+0xf6>
 802aed0:	f028 4340 	bic.w	r3, r8, #3221225472	; 0xc0000000
 802aed4:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802aed8:	d117      	bne.n	802af0a <__ieee754_powf+0x126>
 802aeda:	2d00      	cmp	r5, #0
 802aedc:	bfbc      	itt	lt
 802aede:	eef7 7a00 	vmovlt.f32	s15, #112	; 0x3f800000  1.0
 802aee2:	ee87 0a80 	vdivlt.f32	s0, s15, s0
 802aee6:	f1b8 0f00 	cmp.w	r8, #0
 802aeea:	dacf      	bge.n	802ae8c <__ieee754_powf+0xa8>
 802aeec:	f1a4 547e 	sub.w	r4, r4, #1065353216	; 0x3f800000
 802aef0:	ea54 0306 	orrs.w	r3, r4, r6
 802aef4:	d104      	bne.n	802af00 <__ieee754_powf+0x11c>
 802aef6:	ee70 7a40 	vsub.f32	s15, s0, s0
 802aefa:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 802aefe:	e7c5      	b.n	802ae8c <__ieee754_powf+0xa8>
 802af00:	2e01      	cmp	r6, #1
 802af02:	d1c3      	bne.n	802ae8c <__ieee754_powf+0xa8>
 802af04:	eeb1 0a40 	vneg.f32	s0, s0
 802af08:	e7c0      	b.n	802ae8c <__ieee754_powf+0xa8>
 802af0a:	ea4f 70d8 	mov.w	r0, r8, lsr #31
 802af0e:	3801      	subs	r0, #1
 802af10:	ea56 0300 	orrs.w	r3, r6, r0
 802af14:	d104      	bne.n	802af20 <__ieee754_powf+0x13c>
 802af16:	ee38 8a48 	vsub.f32	s16, s16, s16
 802af1a:	ee88 0a08 	vdiv.f32	s0, s16, s16
 802af1e:	e7b5      	b.n	802ae8c <__ieee754_powf+0xa8>
 802af20:	f1b7 4f9a 	cmp.w	r7, #1291845632	; 0x4d000000
 802af24:	dd6b      	ble.n	802affe <__ieee754_powf+0x21a>
 802af26:	4b99      	ldr	r3, [pc, #612]	; (802b18c <__ieee754_powf+0x3a8>)
 802af28:	429c      	cmp	r4, r3
 802af2a:	dc06      	bgt.n	802af3a <__ieee754_powf+0x156>
 802af2c:	2d00      	cmp	r5, #0
 802af2e:	daab      	bge.n	802ae88 <__ieee754_powf+0xa4>
 802af30:	ed9f 0a97 	vldr	s0, [pc, #604]	; 802b190 <__ieee754_powf+0x3ac>
 802af34:	ee20 0a00 	vmul.f32	s0, s0, s0
 802af38:	e7a8      	b.n	802ae8c <__ieee754_powf+0xa8>
 802af3a:	4b96      	ldr	r3, [pc, #600]	; (802b194 <__ieee754_powf+0x3b0>)
 802af3c:	429c      	cmp	r4, r3
 802af3e:	dd02      	ble.n	802af46 <__ieee754_powf+0x162>
 802af40:	2d00      	cmp	r5, #0
 802af42:	dcf5      	bgt.n	802af30 <__ieee754_powf+0x14c>
 802af44:	e7a0      	b.n	802ae88 <__ieee754_powf+0xa4>
 802af46:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802af4a:	ee30 0a67 	vsub.f32	s0, s0, s15
 802af4e:	eddf 6a92 	vldr	s13, [pc, #584]	; 802b198 <__ieee754_powf+0x3b4>
 802af52:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 802af56:	eee0 6a67 	vfms.f32	s13, s0, s15
 802af5a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802af5e:	eee6 7ac0 	vfms.f32	s15, s13, s0
 802af62:	ee20 7a00 	vmul.f32	s14, s0, s0
 802af66:	ee67 7a27 	vmul.f32	s15, s14, s15
 802af6a:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 802b19c <__ieee754_powf+0x3b8>
 802af6e:	ee67 7a67 	vnmul.f32	s15, s14, s15
 802af72:	ed9f 7a8b 	vldr	s14, [pc, #556]	; 802b1a0 <__ieee754_powf+0x3bc>
 802af76:	eee0 7a07 	vfma.f32	s15, s0, s14
 802af7a:	ed9f 7a8a 	vldr	s14, [pc, #552]	; 802b1a4 <__ieee754_powf+0x3c0>
 802af7e:	eef0 6a67 	vmov.f32	s13, s15
 802af82:	eee0 6a07 	vfma.f32	s13, s0, s14
 802af86:	ee16 3a90 	vmov	r3, s13
 802af8a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802af8e:	f023 030f 	bic.w	r3, r3, #15
 802af92:	ee00 3a90 	vmov	s1, r3
 802af96:	eee0 0a47 	vfms.f32	s1, s0, s14
 802af9a:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802af9e:	f425 657f 	bic.w	r5, r5, #4080	; 0xff0
 802afa2:	f025 050f 	bic.w	r5, r5, #15
 802afa6:	ee07 5a10 	vmov	s14, r5
 802afaa:	ee67 0aa8 	vmul.f32	s1, s15, s17
 802afae:	ee38 7ac7 	vsub.f32	s14, s17, s14
 802afb2:	ee07 3a90 	vmov	s15, r3
 802afb6:	eee7 0a27 	vfma.f32	s1, s14, s15
 802afba:	3e01      	subs	r6, #1
 802afbc:	ea56 0200 	orrs.w	r2, r6, r0
 802afc0:	ee07 5a10 	vmov	s14, r5
 802afc4:	ee67 7a87 	vmul.f32	s15, s15, s14
 802afc8:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 802afcc:	ee30 7aa7 	vadd.f32	s14, s1, s15
 802afd0:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 802afd4:	ee17 4a10 	vmov	r4, s14
 802afd8:	bf08      	it	eq
 802afda:	eeb0 8a40 	vmoveq.f32	s16, s0
 802afde:	2c00      	cmp	r4, #0
 802afe0:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802afe4:	f340 8184 	ble.w	802b2f0 <__ieee754_powf+0x50c>
 802afe8:	f1b3 4f86 	cmp.w	r3, #1124073472	; 0x43000000
 802afec:	f340 80fc 	ble.w	802b1e8 <__ieee754_powf+0x404>
 802aff0:	eddf 7a67 	vldr	s15, [pc, #412]	; 802b190 <__ieee754_powf+0x3ac>
 802aff4:	ee28 0a27 	vmul.f32	s0, s16, s15
 802aff8:	ee20 0a27 	vmul.f32	s0, s0, s15
 802affc:	e746      	b.n	802ae8c <__ieee754_powf+0xa8>
 802affe:	f018 4fff 	tst.w	r8, #2139095040	; 0x7f800000
 802b002:	bf01      	itttt	eq
 802b004:	eddf 7a68 	vldreq	s15, [pc, #416]	; 802b1a8 <__ieee754_powf+0x3c4>
 802b008:	ee60 7a27 	vmuleq.f32	s15, s0, s15
 802b00c:	f06f 0217 	mvneq.w	r2, #23
 802b010:	ee17 4a90 	vmoveq	r4, s15
 802b014:	ea4f 53e4 	mov.w	r3, r4, asr #23
 802b018:	bf18      	it	ne
 802b01a:	2200      	movne	r2, #0
 802b01c:	3b7f      	subs	r3, #127	; 0x7f
 802b01e:	4413      	add	r3, r2
 802b020:	4a62      	ldr	r2, [pc, #392]	; (802b1ac <__ieee754_powf+0x3c8>)
 802b022:	f3c4 0416 	ubfx	r4, r4, #0, #23
 802b026:	4294      	cmp	r4, r2
 802b028:	f044 517e 	orr.w	r1, r4, #1065353216	; 0x3f800000
 802b02c:	dd06      	ble.n	802b03c <__ieee754_powf+0x258>
 802b02e:	4a60      	ldr	r2, [pc, #384]	; (802b1b0 <__ieee754_powf+0x3cc>)
 802b030:	4294      	cmp	r4, r2
 802b032:	f340 80a4 	ble.w	802b17e <__ieee754_powf+0x39a>
 802b036:	3301      	adds	r3, #1
 802b038:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
 802b03c:	2400      	movs	r4, #0
 802b03e:	4a5d      	ldr	r2, [pc, #372]	; (802b1b4 <__ieee754_powf+0x3d0>)
 802b040:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 802b044:	ee07 1a90 	vmov	s15, r1
 802b048:	ed92 7a00 	vldr	s14, [r2]
 802b04c:	4a5a      	ldr	r2, [pc, #360]	; (802b1b8 <__ieee754_powf+0x3d4>)
 802b04e:	ee37 6a27 	vadd.f32	s12, s14, s15
 802b052:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 802b056:	eec5 6a86 	vdiv.f32	s13, s11, s12
 802b05a:	1049      	asrs	r1, r1, #1
 802b05c:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 802b060:	f501 2180 	add.w	r1, r1, #262144	; 0x40000
 802b064:	eb01 5144 	add.w	r1, r1, r4, lsl #21
 802b068:	ee37 5ac7 	vsub.f32	s10, s15, s14
 802b06c:	ee06 1a10 	vmov	s12, r1
 802b070:	ee65 4a26 	vmul.f32	s9, s10, s13
 802b074:	ee36 7a47 	vsub.f32	s14, s12, s14
 802b078:	ee14 7a90 	vmov	r7, s9
 802b07c:	4017      	ands	r7, r2
 802b07e:	ee05 7a90 	vmov	s11, r7
 802b082:	eea5 5ac6 	vfms.f32	s10, s11, s12
 802b086:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b08a:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 802b1bc <__ieee754_powf+0x3d8>
 802b08e:	eea5 5ae7 	vfms.f32	s10, s11, s15
 802b092:	ee64 7aa4 	vmul.f32	s15, s9, s9
 802b096:	ee25 6a26 	vmul.f32	s12, s10, s13
 802b09a:	eddf 6a49 	vldr	s13, [pc, #292]	; 802b1c0 <__ieee754_powf+0x3dc>
 802b09e:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802b0a2:	eddf 6a48 	vldr	s13, [pc, #288]	; 802b1c4 <__ieee754_powf+0x3e0>
 802b0a6:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b0aa:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 802b198 <__ieee754_powf+0x3b4>
 802b0ae:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b0b2:	eddf 6a45 	vldr	s13, [pc, #276]	; 802b1c8 <__ieee754_powf+0x3e4>
 802b0b6:	eee7 6a27 	vfma.f32	s13, s14, s15
 802b0ba:	ed9f 7a44 	vldr	s14, [pc, #272]	; 802b1cc <__ieee754_powf+0x3e8>
 802b0be:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b0c2:	ee74 6aa5 	vadd.f32	s13, s9, s11
 802b0c6:	ee27 5aa7 	vmul.f32	s10, s15, s15
 802b0ca:	ee66 6a86 	vmul.f32	s13, s13, s12
 802b0ce:	eee5 6a07 	vfma.f32	s13, s10, s14
 802b0d2:	eeb0 5a08 	vmov.f32	s10, #8	; 0x40400000  3.0
 802b0d6:	eef0 7a45 	vmov.f32	s15, s10
 802b0da:	eee5 7aa5 	vfma.f32	s15, s11, s11
 802b0de:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b0e2:	ee17 1a90 	vmov	r1, s15
 802b0e6:	4011      	ands	r1, r2
 802b0e8:	ee07 1a90 	vmov	s15, r1
 802b0ec:	ee37 7ac5 	vsub.f32	s14, s15, s10
 802b0f0:	eea5 7ae5 	vfms.f32	s14, s11, s11
 802b0f4:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802b0f8:	ee27 7a24 	vmul.f32	s14, s14, s9
 802b0fc:	eea6 7a27 	vfma.f32	s14, s12, s15
 802b100:	eeb0 6a47 	vmov.f32	s12, s14
 802b104:	eea5 6aa7 	vfma.f32	s12, s11, s15
 802b108:	ee16 1a10 	vmov	r1, s12
 802b10c:	4011      	ands	r1, r2
 802b10e:	ee06 1a90 	vmov	s13, r1
 802b112:	eee5 6ae7 	vfms.f32	s13, s11, s15
 802b116:	eddf 7a2e 	vldr	s15, [pc, #184]	; 802b1d0 <__ieee754_powf+0x3ec>
 802b11a:	eddf 5a2e 	vldr	s11, [pc, #184]	; 802b1d4 <__ieee754_powf+0x3f0>
 802b11e:	ee37 7a66 	vsub.f32	s14, s14, s13
 802b122:	ee06 1a10 	vmov	s12, r1
 802b126:	ee27 7a27 	vmul.f32	s14, s14, s15
 802b12a:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802b1d8 <__ieee754_powf+0x3f4>
 802b12e:	492b      	ldr	r1, [pc, #172]	; (802b1dc <__ieee754_powf+0x3f8>)
 802b130:	eea6 7a27 	vfma.f32	s14, s12, s15
 802b134:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 802b138:	edd1 7a00 	vldr	s15, [r1]
 802b13c:	ee37 7a27 	vadd.f32	s14, s14, s15
 802b140:	ee07 3a90 	vmov	s15, r3
 802b144:	4b26      	ldr	r3, [pc, #152]	; (802b1e0 <__ieee754_powf+0x3fc>)
 802b146:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802b14a:	eef0 7a47 	vmov.f32	s15, s14
 802b14e:	eee6 7a25 	vfma.f32	s15, s12, s11
 802b152:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 802b156:	edd4 0a00 	vldr	s1, [r4]
 802b15a:	ee77 7aa0 	vadd.f32	s15, s15, s1
 802b15e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b162:	ee17 3a90 	vmov	r3, s15
 802b166:	4013      	ands	r3, r2
 802b168:	ee07 3a90 	vmov	s15, r3
 802b16c:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802b170:	ee76 6ae0 	vsub.f32	s13, s13, s1
 802b174:	eee6 6a65 	vfms.f32	s13, s12, s11
 802b178:	ee77 7a66 	vsub.f32	s15, s14, s13
 802b17c:	e70f      	b.n	802af9e <__ieee754_powf+0x1ba>
 802b17e:	2401      	movs	r4, #1
 802b180:	e75d      	b.n	802b03e <__ieee754_powf+0x25a>
 802b182:	bf00      	nop
 802b184:	0802d8f0 	.word	0x0802d8f0
 802b188:	00000000 	.word	0x00000000
 802b18c:	3f7ffff7 	.word	0x3f7ffff7
 802b190:	7149f2ca 	.word	0x7149f2ca
 802b194:	3f800007 	.word	0x3f800007
 802b198:	3eaaaaab 	.word	0x3eaaaaab
 802b19c:	3fb8aa3b 	.word	0x3fb8aa3b
 802b1a0:	36eca570 	.word	0x36eca570
 802b1a4:	3fb8aa00 	.word	0x3fb8aa00
 802b1a8:	4b800000 	.word	0x4b800000
 802b1ac:	001cc471 	.word	0x001cc471
 802b1b0:	005db3d6 	.word	0x005db3d6
 802b1b4:	0802d950 	.word	0x0802d950
 802b1b8:	fffff000 	.word	0xfffff000
 802b1bc:	3e6c3255 	.word	0x3e6c3255
 802b1c0:	3e53f142 	.word	0x3e53f142
 802b1c4:	3e8ba305 	.word	0x3e8ba305
 802b1c8:	3edb6db7 	.word	0x3edb6db7
 802b1cc:	3f19999a 	.word	0x3f19999a
 802b1d0:	3f76384f 	.word	0x3f76384f
 802b1d4:	3f763800 	.word	0x3f763800
 802b1d8:	369dc3a0 	.word	0x369dc3a0
 802b1dc:	0802d960 	.word	0x0802d960
 802b1e0:	0802d958 	.word	0x0802d958
 802b1e4:	3338aa3c 	.word	0x3338aa3c
 802b1e8:	f040 8092 	bne.w	802b310 <__ieee754_powf+0x52c>
 802b1ec:	ed5f 6a03 	vldr	s13, [pc, #-12]	; 802b1e4 <__ieee754_powf+0x400>
 802b1f0:	ee37 7a67 	vsub.f32	s14, s14, s15
 802b1f4:	ee70 6aa6 	vadd.f32	s13, s1, s13
 802b1f8:	eef4 6ac7 	vcmpe.f32	s13, s14
 802b1fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b200:	f73f aef6 	bgt.w	802aff0 <__ieee754_powf+0x20c>
 802b204:	15db      	asrs	r3, r3, #23
 802b206:	f1a3 007e 	sub.w	r0, r3, #126	; 0x7e
 802b20a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 802b20e:	4103      	asrs	r3, r0
 802b210:	4423      	add	r3, r4
 802b212:	4949      	ldr	r1, [pc, #292]	; (802b338 <__ieee754_powf+0x554>)
 802b214:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802b218:	3a7f      	subs	r2, #127	; 0x7f
 802b21a:	4111      	asrs	r1, r2
 802b21c:	ea23 0101 	bic.w	r1, r3, r1
 802b220:	ee07 1a10 	vmov	s14, r1
 802b224:	f3c3 0016 	ubfx	r0, r3, #0, #23
 802b228:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802b22c:	f1c2 0217 	rsb	r2, r2, #23
 802b230:	4110      	asrs	r0, r2
 802b232:	2c00      	cmp	r4, #0
 802b234:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b238:	bfb8      	it	lt
 802b23a:	4240      	neglt	r0, r0
 802b23c:	ee37 7aa0 	vadd.f32	s14, s15, s1
 802b240:	eddf 6a3e 	vldr	s13, [pc, #248]	; 802b33c <__ieee754_powf+0x558>
 802b244:	ee17 3a10 	vmov	r3, s14
 802b248:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802b24c:	f023 030f 	bic.w	r3, r3, #15
 802b250:	ee07 3a10 	vmov	s14, r3
 802b254:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b258:	ee70 0ae7 	vsub.f32	s1, s1, s15
 802b25c:	eddf 7a38 	vldr	s15, [pc, #224]	; 802b340 <__ieee754_powf+0x55c>
 802b260:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b264:	eee0 7aa6 	vfma.f32	s15, s1, s13
 802b268:	eddf 6a36 	vldr	s13, [pc, #216]	; 802b344 <__ieee754_powf+0x560>
 802b26c:	eeb0 0a67 	vmov.f32	s0, s15
 802b270:	eea7 0a26 	vfma.f32	s0, s14, s13
 802b274:	eeb0 6a40 	vmov.f32	s12, s0
 802b278:	eea7 6a66 	vfms.f32	s12, s14, s13
 802b27c:	ee20 7a00 	vmul.f32	s14, s0, s0
 802b280:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802b284:	eddf 6a30 	vldr	s13, [pc, #192]	; 802b348 <__ieee754_powf+0x564>
 802b288:	ed9f 6a30 	vldr	s12, [pc, #192]	; 802b34c <__ieee754_powf+0x568>
 802b28c:	eea7 6a26 	vfma.f32	s12, s14, s13
 802b290:	eddf 6a2f 	vldr	s13, [pc, #188]	; 802b350 <__ieee754_powf+0x56c>
 802b294:	eee6 6a07 	vfma.f32	s13, s12, s14
 802b298:	ed9f 6a2e 	vldr	s12, [pc, #184]	; 802b354 <__ieee754_powf+0x570>
 802b29c:	eea6 6a87 	vfma.f32	s12, s13, s14
 802b2a0:	eddf 6a2d 	vldr	s13, [pc, #180]	; 802b358 <__ieee754_powf+0x574>
 802b2a4:	eee6 6a07 	vfma.f32	s13, s12, s14
 802b2a8:	eeb0 6a40 	vmov.f32	s12, s0
 802b2ac:	eea6 6ac7 	vfms.f32	s12, s13, s14
 802b2b0:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 802b2b4:	eeb0 7a46 	vmov.f32	s14, s12
 802b2b8:	ee77 6a66 	vsub.f32	s13, s14, s13
 802b2bc:	ee20 6a06 	vmul.f32	s12, s0, s12
 802b2c0:	eee0 7a27 	vfma.f32	s15, s0, s15
 802b2c4:	ee86 7a26 	vdiv.f32	s14, s12, s13
 802b2c8:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b2cc:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802b2d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802b2d4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802b2d8:	ee10 3a10 	vmov	r3, s0
 802b2dc:	eb03 53c0 	add.w	r3, r3, r0, lsl #23
 802b2e0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802b2e4:	da1a      	bge.n	802b31c <__ieee754_powf+0x538>
 802b2e6:	f000 fe45 	bl	802bf74 <scalbnf>
 802b2ea:	ee20 0a08 	vmul.f32	s0, s0, s16
 802b2ee:	e5cd      	b.n	802ae8c <__ieee754_powf+0xa8>
 802b2f0:	4a1a      	ldr	r2, [pc, #104]	; (802b35c <__ieee754_powf+0x578>)
 802b2f2:	4293      	cmp	r3, r2
 802b2f4:	dd02      	ble.n	802b2fc <__ieee754_powf+0x518>
 802b2f6:	eddf 7a1a 	vldr	s15, [pc, #104]	; 802b360 <__ieee754_powf+0x57c>
 802b2fa:	e67b      	b.n	802aff4 <__ieee754_powf+0x210>
 802b2fc:	d108      	bne.n	802b310 <__ieee754_powf+0x52c>
 802b2fe:	ee37 7a67 	vsub.f32	s14, s14, s15
 802b302:	eeb4 7ae0 	vcmpe.f32	s14, s1
 802b306:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b30a:	f6ff af7b 	blt.w	802b204 <__ieee754_powf+0x420>
 802b30e:	e7f2      	b.n	802b2f6 <__ieee754_powf+0x512>
 802b310:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 802b314:	f73f af76 	bgt.w	802b204 <__ieee754_powf+0x420>
 802b318:	2000      	movs	r0, #0
 802b31a:	e78f      	b.n	802b23c <__ieee754_powf+0x458>
 802b31c:	ee00 3a10 	vmov	s0, r3
 802b320:	e7e3      	b.n	802b2ea <__ieee754_powf+0x506>
 802b322:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b326:	e5b1      	b.n	802ae8c <__ieee754_powf+0xa8>
 802b328:	eeb0 0a68 	vmov.f32	s0, s17
 802b32c:	e5ae      	b.n	802ae8c <__ieee754_powf+0xa8>
 802b32e:	eeb0 0a48 	vmov.f32	s0, s16
 802b332:	e5ab      	b.n	802ae8c <__ieee754_powf+0xa8>
 802b334:	2600      	movs	r6, #0
 802b336:	e590      	b.n	802ae5a <__ieee754_powf+0x76>
 802b338:	007fffff 	.word	0x007fffff
 802b33c:	3f317218 	.word	0x3f317218
 802b340:	35bfbe8c 	.word	0x35bfbe8c
 802b344:	3f317200 	.word	0x3f317200
 802b348:	3331bb4c 	.word	0x3331bb4c
 802b34c:	b5ddea0e 	.word	0xb5ddea0e
 802b350:	388ab355 	.word	0x388ab355
 802b354:	bb360b61 	.word	0xbb360b61
 802b358:	3e2aaaab 	.word	0x3e2aaaab
 802b35c:	43160000 	.word	0x43160000
 802b360:	0da24260 	.word	0x0da24260

0802b364 <__ieee754_rem_pio2f>:
 802b364:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b366:	ee10 6a10 	vmov	r6, s0
 802b36a:	4b8e      	ldr	r3, [pc, #568]	; (802b5a4 <__ieee754_rem_pio2f+0x240>)
 802b36c:	f026 4500 	bic.w	r5, r6, #2147483648	; 0x80000000
 802b370:	429d      	cmp	r5, r3
 802b372:	b087      	sub	sp, #28
 802b374:	eef0 7a40 	vmov.f32	s15, s0
 802b378:	4604      	mov	r4, r0
 802b37a:	dc05      	bgt.n	802b388 <__ieee754_rem_pio2f+0x24>
 802b37c:	2300      	movs	r3, #0
 802b37e:	ed80 0a00 	vstr	s0, [r0]
 802b382:	6043      	str	r3, [r0, #4]
 802b384:	2000      	movs	r0, #0
 802b386:	e01a      	b.n	802b3be <__ieee754_rem_pio2f+0x5a>
 802b388:	4b87      	ldr	r3, [pc, #540]	; (802b5a8 <__ieee754_rem_pio2f+0x244>)
 802b38a:	429d      	cmp	r5, r3
 802b38c:	dc46      	bgt.n	802b41c <__ieee754_rem_pio2f+0xb8>
 802b38e:	2e00      	cmp	r6, #0
 802b390:	ed9f 0a86 	vldr	s0, [pc, #536]	; 802b5ac <__ieee754_rem_pio2f+0x248>
 802b394:	4b86      	ldr	r3, [pc, #536]	; (802b5b0 <__ieee754_rem_pio2f+0x24c>)
 802b396:	f025 050f 	bic.w	r5, r5, #15
 802b39a:	dd1f      	ble.n	802b3dc <__ieee754_rem_pio2f+0x78>
 802b39c:	429d      	cmp	r5, r3
 802b39e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802b3a2:	d00e      	beq.n	802b3c2 <__ieee754_rem_pio2f+0x5e>
 802b3a4:	ed9f 7a83 	vldr	s14, [pc, #524]	; 802b5b4 <__ieee754_rem_pio2f+0x250>
 802b3a8:	ee37 0ac7 	vsub.f32	s0, s15, s14
 802b3ac:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802b3b0:	ed80 0a00 	vstr	s0, [r0]
 802b3b4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b3b8:	2001      	movs	r0, #1
 802b3ba:	edc4 7a01 	vstr	s15, [r4, #4]
 802b3be:	b007      	add	sp, #28
 802b3c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802b3c2:	ed9f 0a7d 	vldr	s0, [pc, #500]	; 802b5b8 <__ieee754_rem_pio2f+0x254>
 802b3c6:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 802b5bc <__ieee754_rem_pio2f+0x258>
 802b3ca:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802b3ce:	ee77 6ac7 	vsub.f32	s13, s15, s14
 802b3d2:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802b3d6:	edc0 6a00 	vstr	s13, [r0]
 802b3da:	e7eb      	b.n	802b3b4 <__ieee754_rem_pio2f+0x50>
 802b3dc:	429d      	cmp	r5, r3
 802b3de:	ee77 7a80 	vadd.f32	s15, s15, s0
 802b3e2:	d00e      	beq.n	802b402 <__ieee754_rem_pio2f+0x9e>
 802b3e4:	ed9f 7a73 	vldr	s14, [pc, #460]	; 802b5b4 <__ieee754_rem_pio2f+0x250>
 802b3e8:	ee37 0a87 	vadd.f32	s0, s15, s14
 802b3ec:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802b3f0:	ed80 0a00 	vstr	s0, [r0]
 802b3f4:	ee77 7a87 	vadd.f32	s15, s15, s14
 802b3f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802b3fc:	edc4 7a01 	vstr	s15, [r4, #4]
 802b400:	e7dd      	b.n	802b3be <__ieee754_rem_pio2f+0x5a>
 802b402:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 802b5b8 <__ieee754_rem_pio2f+0x254>
 802b406:	ed9f 7a6d 	vldr	s14, [pc, #436]	; 802b5bc <__ieee754_rem_pio2f+0x258>
 802b40a:	ee77 7a80 	vadd.f32	s15, s15, s0
 802b40e:	ee77 6a87 	vadd.f32	s13, s15, s14
 802b412:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802b416:	edc0 6a00 	vstr	s13, [r0]
 802b41a:	e7eb      	b.n	802b3f4 <__ieee754_rem_pio2f+0x90>
 802b41c:	4b68      	ldr	r3, [pc, #416]	; (802b5c0 <__ieee754_rem_pio2f+0x25c>)
 802b41e:	429d      	cmp	r5, r3
 802b420:	dc72      	bgt.n	802b508 <__ieee754_rem_pio2f+0x1a4>
 802b422:	f7fe f883 	bl	802952c <fabsf>
 802b426:	ed9f 7a67 	vldr	s14, [pc, #412]	; 802b5c4 <__ieee754_rem_pio2f+0x260>
 802b42a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802b42e:	eee0 7a07 	vfma.f32	s15, s0, s14
 802b432:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802b436:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802b43a:	ee17 0a90 	vmov	r0, s15
 802b43e:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802b5ac <__ieee754_rem_pio2f+0x248>
 802b442:	eea7 0a67 	vfms.f32	s0, s14, s15
 802b446:	281f      	cmp	r0, #31
 802b448:	eddf 7a5a 	vldr	s15, [pc, #360]	; 802b5b4 <__ieee754_rem_pio2f+0x250>
 802b44c:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b450:	eeb1 6a47 	vneg.f32	s12, s14
 802b454:	ee70 6a67 	vsub.f32	s13, s0, s15
 802b458:	ee16 2a90 	vmov	r2, s13
 802b45c:	dc1c      	bgt.n	802b498 <__ieee754_rem_pio2f+0x134>
 802b45e:	495a      	ldr	r1, [pc, #360]	; (802b5c8 <__ieee754_rem_pio2f+0x264>)
 802b460:	1e47      	subs	r7, r0, #1
 802b462:	f025 03ff 	bic.w	r3, r5, #255	; 0xff
 802b466:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 802b46a:	428b      	cmp	r3, r1
 802b46c:	d014      	beq.n	802b498 <__ieee754_rem_pio2f+0x134>
 802b46e:	6022      	str	r2, [r4, #0]
 802b470:	ed94 7a00 	vldr	s14, [r4]
 802b474:	ee30 0a47 	vsub.f32	s0, s0, s14
 802b478:	2e00      	cmp	r6, #0
 802b47a:	ee30 0a67 	vsub.f32	s0, s0, s15
 802b47e:	ed84 0a01 	vstr	s0, [r4, #4]
 802b482:	da9c      	bge.n	802b3be <__ieee754_rem_pio2f+0x5a>
 802b484:	eeb1 7a47 	vneg.f32	s14, s14
 802b488:	eeb1 0a40 	vneg.f32	s0, s0
 802b48c:	ed84 7a00 	vstr	s14, [r4]
 802b490:	ed84 0a01 	vstr	s0, [r4, #4]
 802b494:	4240      	negs	r0, r0
 802b496:	e792      	b.n	802b3be <__ieee754_rem_pio2f+0x5a>
 802b498:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 802b49c:	15eb      	asrs	r3, r5, #23
 802b49e:	ebc1 55d5 	rsb	r5, r1, r5, lsr #23
 802b4a2:	2d08      	cmp	r5, #8
 802b4a4:	dde3      	ble.n	802b46e <__ieee754_rem_pio2f+0x10a>
 802b4a6:	eddf 7a44 	vldr	s15, [pc, #272]	; 802b5b8 <__ieee754_rem_pio2f+0x254>
 802b4aa:	eef0 6a40 	vmov.f32	s13, s0
 802b4ae:	eee6 6a27 	vfma.f32	s13, s12, s15
 802b4b2:	ee30 0a66 	vsub.f32	s0, s0, s13
 802b4b6:	eea6 0a27 	vfma.f32	s0, s12, s15
 802b4ba:	eddf 7a40 	vldr	s15, [pc, #256]	; 802b5bc <__ieee754_rem_pio2f+0x258>
 802b4be:	ee97 0a27 	vfnms.f32	s0, s14, s15
 802b4c2:	ee76 5ac0 	vsub.f32	s11, s13, s0
 802b4c6:	eef0 7a40 	vmov.f32	s15, s0
 802b4ca:	ee15 2a90 	vmov	r2, s11
 802b4ce:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 802b4d2:	1a5b      	subs	r3, r3, r1
 802b4d4:	2b19      	cmp	r3, #25
 802b4d6:	dc04      	bgt.n	802b4e2 <__ieee754_rem_pio2f+0x17e>
 802b4d8:	edc4 5a00 	vstr	s11, [r4]
 802b4dc:	eeb0 0a66 	vmov.f32	s0, s13
 802b4e0:	e7c6      	b.n	802b470 <__ieee754_rem_pio2f+0x10c>
 802b4e2:	eddf 5a3a 	vldr	s11, [pc, #232]	; 802b5cc <__ieee754_rem_pio2f+0x268>
 802b4e6:	eeb0 0a66 	vmov.f32	s0, s13
 802b4ea:	eea6 0a25 	vfma.f32	s0, s12, s11
 802b4ee:	ee76 7ac0 	vsub.f32	s15, s13, s0
 802b4f2:	eddf 6a37 	vldr	s13, [pc, #220]	; 802b5d0 <__ieee754_rem_pio2f+0x26c>
 802b4f6:	eee6 7a25 	vfma.f32	s15, s12, s11
 802b4fa:	eed7 7a26 	vfnms.f32	s15, s14, s13
 802b4fe:	ee30 7a67 	vsub.f32	s14, s0, s15
 802b502:	ed84 7a00 	vstr	s14, [r4]
 802b506:	e7b3      	b.n	802b470 <__ieee754_rem_pio2f+0x10c>
 802b508:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 802b50c:	db06      	blt.n	802b51c <__ieee754_rem_pio2f+0x1b8>
 802b50e:	ee70 7a40 	vsub.f32	s15, s0, s0
 802b512:	edc0 7a01 	vstr	s15, [r0, #4]
 802b516:	edc0 7a00 	vstr	s15, [r0]
 802b51a:	e733      	b.n	802b384 <__ieee754_rem_pio2f+0x20>
 802b51c:	15ea      	asrs	r2, r5, #23
 802b51e:	3a86      	subs	r2, #134	; 0x86
 802b520:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 802b524:	ee07 3a90 	vmov	s15, r3
 802b528:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802b52c:	eddf 6a29 	vldr	s13, [pc, #164]	; 802b5d4 <__ieee754_rem_pio2f+0x270>
 802b530:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802b534:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b538:	ed8d 7a03 	vstr	s14, [sp, #12]
 802b53c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b540:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802b544:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802b548:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b54c:	ed8d 7a04 	vstr	s14, [sp, #16]
 802b550:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b554:	eef5 7a40 	vcmp.f32	s15, #0.0
 802b558:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b55c:	edcd 7a05 	vstr	s15, [sp, #20]
 802b560:	d11e      	bne.n	802b5a0 <__ieee754_rem_pio2f+0x23c>
 802b562:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802b566:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b56a:	bf14      	ite	ne
 802b56c:	2302      	movne	r3, #2
 802b56e:	2301      	moveq	r3, #1
 802b570:	4919      	ldr	r1, [pc, #100]	; (802b5d8 <__ieee754_rem_pio2f+0x274>)
 802b572:	9101      	str	r1, [sp, #4]
 802b574:	2102      	movs	r1, #2
 802b576:	9100      	str	r1, [sp, #0]
 802b578:	a803      	add	r0, sp, #12
 802b57a:	4621      	mov	r1, r4
 802b57c:	f000 f892 	bl	802b6a4 <__kernel_rem_pio2f>
 802b580:	2e00      	cmp	r6, #0
 802b582:	f6bf af1c 	bge.w	802b3be <__ieee754_rem_pio2f+0x5a>
 802b586:	edd4 7a00 	vldr	s15, [r4]
 802b58a:	eef1 7a67 	vneg.f32	s15, s15
 802b58e:	edc4 7a00 	vstr	s15, [r4]
 802b592:	edd4 7a01 	vldr	s15, [r4, #4]
 802b596:	eef1 7a67 	vneg.f32	s15, s15
 802b59a:	edc4 7a01 	vstr	s15, [r4, #4]
 802b59e:	e779      	b.n	802b494 <__ieee754_rem_pio2f+0x130>
 802b5a0:	2303      	movs	r3, #3
 802b5a2:	e7e5      	b.n	802b570 <__ieee754_rem_pio2f+0x20c>
 802b5a4:	3f490fd8 	.word	0x3f490fd8
 802b5a8:	4016cbe3 	.word	0x4016cbe3
 802b5ac:	3fc90f80 	.word	0x3fc90f80
 802b5b0:	3fc90fd0 	.word	0x3fc90fd0
 802b5b4:	37354443 	.word	0x37354443
 802b5b8:	37354400 	.word	0x37354400
 802b5bc:	2e85a308 	.word	0x2e85a308
 802b5c0:	43490f80 	.word	0x43490f80
 802b5c4:	3f22f984 	.word	0x3f22f984
 802b5c8:	0802d968 	.word	0x0802d968
 802b5cc:	2e85a300 	.word	0x2e85a300
 802b5d0:	248d3132 	.word	0x248d3132
 802b5d4:	43800000 	.word	0x43800000
 802b5d8:	0802d9e8 	.word	0x0802d9e8

0802b5dc <__ieee754_sqrtf>:
 802b5dc:	eeb1 0ac0 	vsqrt.f32	s0, s0
 802b5e0:	4770      	bx	lr
	...

0802b5e4 <__kernel_cosf>:
 802b5e4:	ee10 3a10 	vmov	r3, s0
 802b5e8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802b5ec:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802b5f0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 802b5f4:	da05      	bge.n	802b602 <__kernel_cosf+0x1e>
 802b5f6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802b5fa:	ee17 2a90 	vmov	r2, s15
 802b5fe:	2a00      	cmp	r2, #0
 802b600:	d03d      	beq.n	802b67e <__kernel_cosf+0x9a>
 802b602:	ee60 5a00 	vmul.f32	s11, s0, s0
 802b606:	eddf 7a1f 	vldr	s15, [pc, #124]	; 802b684 <__kernel_cosf+0xa0>
 802b60a:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 802b688 <__kernel_cosf+0xa4>
 802b60e:	eddf 6a1f 	vldr	s13, [pc, #124]	; 802b68c <__kernel_cosf+0xa8>
 802b612:	4a1f      	ldr	r2, [pc, #124]	; (802b690 <__kernel_cosf+0xac>)
 802b614:	eea5 7aa7 	vfma.f32	s14, s11, s15
 802b618:	4293      	cmp	r3, r2
 802b61a:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802b694 <__kernel_cosf+0xb0>
 802b61e:	eee7 7a25 	vfma.f32	s15, s14, s11
 802b622:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 802b698 <__kernel_cosf+0xb4>
 802b626:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802b62a:	eddf 7a1c 	vldr	s15, [pc, #112]	; 802b69c <__kernel_cosf+0xb8>
 802b62e:	eee7 7a25 	vfma.f32	s15, s14, s11
 802b632:	eeb0 7a66 	vmov.f32	s14, s13
 802b636:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802b63a:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802b63e:	ee65 7aa6 	vmul.f32	s15, s11, s13
 802b642:	ee67 6a25 	vmul.f32	s13, s14, s11
 802b646:	ee20 7ac0 	vnmul.f32	s14, s1, s0
 802b64a:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802b64e:	dc04      	bgt.n	802b65a <__kernel_cosf+0x76>
 802b650:	ee37 7ac7 	vsub.f32	s14, s15, s14
 802b654:	ee36 0a47 	vsub.f32	s0, s12, s14
 802b658:	4770      	bx	lr
 802b65a:	4a11      	ldr	r2, [pc, #68]	; (802b6a0 <__kernel_cosf+0xbc>)
 802b65c:	4293      	cmp	r3, r2
 802b65e:	bfda      	itte	le
 802b660:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 802b664:	ee06 3a90 	vmovle	s13, r3
 802b668:	eef5 6a02 	vmovgt.f32	s13, #82	; 0x3e900000  0.2812500
 802b66c:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802b670:	ee36 0a66 	vsub.f32	s0, s12, s13
 802b674:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b678:	ee30 0a67 	vsub.f32	s0, s0, s15
 802b67c:	4770      	bx	lr
 802b67e:	eeb0 0a46 	vmov.f32	s0, s12
 802b682:	4770      	bx	lr
 802b684:	ad47d74e 	.word	0xad47d74e
 802b688:	310f74f6 	.word	0x310f74f6
 802b68c:	3d2aaaab 	.word	0x3d2aaaab
 802b690:	3e999999 	.word	0x3e999999
 802b694:	b493f27c 	.word	0xb493f27c
 802b698:	37d00d01 	.word	0x37d00d01
 802b69c:	bab60b61 	.word	0xbab60b61
 802b6a0:	3f480000 	.word	0x3f480000

0802b6a4 <__kernel_rem_pio2f>:
 802b6a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802b6a8:	ed2d 8b04 	vpush	{d8-d9}
 802b6ac:	b0d7      	sub	sp, #348	; 0x15c
 802b6ae:	4616      	mov	r6, r2
 802b6b0:	4698      	mov	r8, r3
 802b6b2:	9a64      	ldr	r2, [sp, #400]	; 0x190
 802b6b4:	4bbb      	ldr	r3, [pc, #748]	; (802b9a4 <__kernel_rem_pio2f+0x300>)
 802b6b6:	9001      	str	r0, [sp, #4]
 802b6b8:	f853 7022 	ldr.w	r7, [r3, r2, lsl #2]
 802b6bc:	1d33      	adds	r3, r6, #4
 802b6be:	460d      	mov	r5, r1
 802b6c0:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 802b6c4:	db29      	blt.n	802b71a <__kernel_rem_pio2f+0x76>
 802b6c6:	1ef1      	subs	r1, r6, #3
 802b6c8:	bf48      	it	mi
 802b6ca:	1d31      	addmi	r1, r6, #4
 802b6cc:	10c9      	asrs	r1, r1, #3
 802b6ce:	1c4c      	adds	r4, r1, #1
 802b6d0:	00e3      	lsls	r3, r4, #3
 802b6d2:	9302      	str	r3, [sp, #8]
 802b6d4:	9b65      	ldr	r3, [sp, #404]	; 0x194
 802b6d6:	ed9f 7ab7 	vldr	s14, [pc, #732]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802b6da:	eba1 0009 	sub.w	r0, r1, r9
 802b6de:	eb03 0e80 	add.w	lr, r3, r0, lsl #2
 802b6e2:	eba6 04c4 	sub.w	r4, r6, r4, lsl #3
 802b6e6:	eb07 0c09 	add.w	ip, r7, r9
 802b6ea:	f10d 0a68 	add.w	sl, sp, #104	; 0x68
 802b6ee:	2300      	movs	r3, #0
 802b6f0:	4563      	cmp	r3, ip
 802b6f2:	dd14      	ble.n	802b71e <__kernel_rem_pio2f+0x7a>
 802b6f4:	ab1a      	add	r3, sp, #104	; 0x68
 802b6f6:	eb03 0388 	add.w	r3, r3, r8, lsl #2
 802b6fa:	46cc      	mov	ip, r9
 802b6fc:	f50d 7a84 	add.w	sl, sp, #264	; 0x108
 802b700:	f1c8 0b01 	rsb	fp, r8, #1
 802b704:	eb0b 020c 	add.w	r2, fp, ip
 802b708:	4297      	cmp	r7, r2
 802b70a:	db27      	blt.n	802b75c <__kernel_rem_pio2f+0xb8>
 802b70c:	f8dd e004 	ldr.w	lr, [sp, #4]
 802b710:	eddf 7aa8 	vldr	s15, [pc, #672]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802b714:	4618      	mov	r0, r3
 802b716:	2200      	movs	r2, #0
 802b718:	e016      	b.n	802b748 <__kernel_rem_pio2f+0xa4>
 802b71a:	2100      	movs	r1, #0
 802b71c:	e7d7      	b.n	802b6ce <__kernel_rem_pio2f+0x2a>
 802b71e:	42d8      	cmn	r0, r3
 802b720:	bf5d      	ittte	pl
 802b722:	f85e 2023 	ldrpl.w	r2, [lr, r3, lsl #2]
 802b726:	ee07 2a90 	vmovpl	s15, r2
 802b72a:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 802b72e:	eef0 7a47 	vmovmi.f32	s15, s14
 802b732:	ecea 7a01 	vstmia	sl!, {s15}
 802b736:	3301      	adds	r3, #1
 802b738:	e7da      	b.n	802b6f0 <__kernel_rem_pio2f+0x4c>
 802b73a:	ecfe 6a01 	vldmia	lr!, {s13}
 802b73e:	ed90 7a00 	vldr	s14, [r0]
 802b742:	eee6 7a87 	vfma.f32	s15, s13, s14
 802b746:	3201      	adds	r2, #1
 802b748:	454a      	cmp	r2, r9
 802b74a:	f1a0 0004 	sub.w	r0, r0, #4
 802b74e:	ddf4      	ble.n	802b73a <__kernel_rem_pio2f+0x96>
 802b750:	ecea 7a01 	vstmia	sl!, {s15}
 802b754:	3304      	adds	r3, #4
 802b756:	f10c 0c01 	add.w	ip, ip, #1
 802b75a:	e7d3      	b.n	802b704 <__kernel_rem_pio2f+0x60>
 802b75c:	ab06      	add	r3, sp, #24
 802b75e:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 802b762:	9304      	str	r3, [sp, #16]
 802b764:	9b65      	ldr	r3, [sp, #404]	; 0x194
 802b766:	eddf 8a92 	vldr	s17, [pc, #584]	; 802b9b0 <__kernel_rem_pio2f+0x30c>
 802b76a:	ed9f 9a90 	vldr	s18, [pc, #576]	; 802b9ac <__kernel_rem_pio2f+0x308>
 802b76e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 802b772:	9303      	str	r3, [sp, #12]
 802b774:	46ba      	mov	sl, r7
 802b776:	ab56      	add	r3, sp, #344	; 0x158
 802b778:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 802b77c:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 802b780:	ab06      	add	r3, sp, #24
 802b782:	4618      	mov	r0, r3
 802b784:	4652      	mov	r2, sl
 802b786:	2a00      	cmp	r2, #0
 802b788:	dc51      	bgt.n	802b82e <__kernel_rem_pio2f+0x18a>
 802b78a:	4620      	mov	r0, r4
 802b78c:	9305      	str	r3, [sp, #20]
 802b78e:	f000 fbf1 	bl	802bf74 <scalbnf>
 802b792:	eeb0 8a40 	vmov.f32	s16, s0
 802b796:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 802b79a:	ee28 0a00 	vmul.f32	s0, s16, s0
 802b79e:	f7fd fecd 	bl	802953c <floorf>
 802b7a2:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 802b7a6:	eea0 8a67 	vfms.f32	s16, s0, s15
 802b7aa:	2c00      	cmp	r4, #0
 802b7ac:	9b05      	ldr	r3, [sp, #20]
 802b7ae:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 802b7b2:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 802b7b6:	edcd 7a00 	vstr	s15, [sp]
 802b7ba:	ee38 8a40 	vsub.f32	s16, s16, s0
 802b7be:	dd4b      	ble.n	802b858 <__kernel_rem_pio2f+0x1b4>
 802b7c0:	f10a 3cff 	add.w	ip, sl, #4294967295	; 0xffffffff
 802b7c4:	aa06      	add	r2, sp, #24
 802b7c6:	f1c4 0e08 	rsb	lr, r4, #8
 802b7ca:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 802b7ce:	ee17 1a90 	vmov	r1, s15
 802b7d2:	fa42 f00e 	asr.w	r0, r2, lr
 802b7d6:	4401      	add	r1, r0
 802b7d8:	9100      	str	r1, [sp, #0]
 802b7da:	fa00 f00e 	lsl.w	r0, r0, lr
 802b7de:	a906      	add	r1, sp, #24
 802b7e0:	1a12      	subs	r2, r2, r0
 802b7e2:	f841 202c 	str.w	r2, [r1, ip, lsl #2]
 802b7e6:	f1c4 0007 	rsb	r0, r4, #7
 802b7ea:	fa42 fb00 	asr.w	fp, r2, r0
 802b7ee:	f1bb 0f00 	cmp.w	fp, #0
 802b7f2:	dd43      	ble.n	802b87c <__kernel_rem_pio2f+0x1d8>
 802b7f4:	9a00      	ldr	r2, [sp, #0]
 802b7f6:	f04f 0e00 	mov.w	lr, #0
 802b7fa:	3201      	adds	r2, #1
 802b7fc:	9200      	str	r2, [sp, #0]
 802b7fe:	4670      	mov	r0, lr
 802b800:	45f2      	cmp	sl, lr
 802b802:	dc6c      	bgt.n	802b8de <__kernel_rem_pio2f+0x23a>
 802b804:	2c00      	cmp	r4, #0
 802b806:	dd04      	ble.n	802b812 <__kernel_rem_pio2f+0x16e>
 802b808:	2c01      	cmp	r4, #1
 802b80a:	d079      	beq.n	802b900 <__kernel_rem_pio2f+0x25c>
 802b80c:	2c02      	cmp	r4, #2
 802b80e:	f000 8082 	beq.w	802b916 <__kernel_rem_pio2f+0x272>
 802b812:	f1bb 0f02 	cmp.w	fp, #2
 802b816:	d131      	bne.n	802b87c <__kernel_rem_pio2f+0x1d8>
 802b818:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b81c:	ee30 8a48 	vsub.f32	s16, s0, s16
 802b820:	b360      	cbz	r0, 802b87c <__kernel_rem_pio2f+0x1d8>
 802b822:	4620      	mov	r0, r4
 802b824:	f000 fba6 	bl	802bf74 <scalbnf>
 802b828:	ee38 8a40 	vsub.f32	s16, s16, s0
 802b82c:	e026      	b.n	802b87c <__kernel_rem_pio2f+0x1d8>
 802b82e:	ee60 7a28 	vmul.f32	s15, s0, s17
 802b832:	3a01      	subs	r2, #1
 802b834:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802b838:	a942      	add	r1, sp, #264	; 0x108
 802b83a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802b83e:	eb01 0c82 	add.w	ip, r1, r2, lsl #2
 802b842:	eea7 0ac9 	vfms.f32	s0, s15, s18
 802b846:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802b84a:	eca0 0a01 	vstmia	r0!, {s0}
 802b84e:	ed9c 0a00 	vldr	s0, [ip]
 802b852:	ee37 0a80 	vadd.f32	s0, s15, s0
 802b856:	e796      	b.n	802b786 <__kernel_rem_pio2f+0xe2>
 802b858:	d107      	bne.n	802b86a <__kernel_rem_pio2f+0x1c6>
 802b85a:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
 802b85e:	a906      	add	r1, sp, #24
 802b860:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 802b864:	ea4f 2b22 	mov.w	fp, r2, asr #8
 802b868:	e7c1      	b.n	802b7ee <__kernel_rem_pio2f+0x14a>
 802b86a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802b86e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802b872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b876:	da2f      	bge.n	802b8d8 <__kernel_rem_pio2f+0x234>
 802b878:	f04f 0b00 	mov.w	fp, #0
 802b87c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802b880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b884:	f040 8098 	bne.w	802b9b8 <__kernel_rem_pio2f+0x314>
 802b888:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
 802b88c:	469c      	mov	ip, r3
 802b88e:	2200      	movs	r2, #0
 802b890:	45bc      	cmp	ip, r7
 802b892:	da48      	bge.n	802b926 <__kernel_rem_pio2f+0x282>
 802b894:	2a00      	cmp	r2, #0
 802b896:	d05f      	beq.n	802b958 <__kernel_rem_pio2f+0x2b4>
 802b898:	aa06      	add	r2, sp, #24
 802b89a:	3c08      	subs	r4, #8
 802b89c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 802b8a0:	2900      	cmp	r1, #0
 802b8a2:	d07d      	beq.n	802b9a0 <__kernel_rem_pio2f+0x2fc>
 802b8a4:	4620      	mov	r0, r4
 802b8a6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b8aa:	9301      	str	r3, [sp, #4]
 802b8ac:	f000 fb62 	bl	802bf74 <scalbnf>
 802b8b0:	9b01      	ldr	r3, [sp, #4]
 802b8b2:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 802b9b0 <__kernel_rem_pio2f+0x30c>
 802b8b6:	4619      	mov	r1, r3
 802b8b8:	2900      	cmp	r1, #0
 802b8ba:	f280 80af 	bge.w	802ba1c <__kernel_rem_pio2f+0x378>
 802b8be:	4618      	mov	r0, r3
 802b8c0:	2400      	movs	r4, #0
 802b8c2:	2800      	cmp	r0, #0
 802b8c4:	f2c0 80d0 	blt.w	802ba68 <__kernel_rem_pio2f+0x3c4>
 802b8c8:	a942      	add	r1, sp, #264	; 0x108
 802b8ca:	eb01 0680 	add.w	r6, r1, r0, lsl #2
 802b8ce:	4a36      	ldr	r2, [pc, #216]	; (802b9a8 <__kernel_rem_pio2f+0x304>)
 802b8d0:	eddf 7a38 	vldr	s15, [pc, #224]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802b8d4:	2100      	movs	r1, #0
 802b8d6:	e0bb      	b.n	802ba50 <__kernel_rem_pio2f+0x3ac>
 802b8d8:	f04f 0b02 	mov.w	fp, #2
 802b8dc:	e78a      	b.n	802b7f4 <__kernel_rem_pio2f+0x150>
 802b8de:	681a      	ldr	r2, [r3, #0]
 802b8e0:	b948      	cbnz	r0, 802b8f6 <__kernel_rem_pio2f+0x252>
 802b8e2:	b11a      	cbz	r2, 802b8ec <__kernel_rem_pio2f+0x248>
 802b8e4:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 802b8e8:	601a      	str	r2, [r3, #0]
 802b8ea:	2201      	movs	r2, #1
 802b8ec:	f10e 0e01 	add.w	lr, lr, #1
 802b8f0:	3304      	adds	r3, #4
 802b8f2:	4610      	mov	r0, r2
 802b8f4:	e784      	b.n	802b800 <__kernel_rem_pio2f+0x15c>
 802b8f6:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 802b8fa:	601a      	str	r2, [r3, #0]
 802b8fc:	4602      	mov	r2, r0
 802b8fe:	e7f5      	b.n	802b8ec <__kernel_rem_pio2f+0x248>
 802b900:	f10a 3cff 	add.w	ip, sl, #4294967295	; 0xffffffff
 802b904:	ab06      	add	r3, sp, #24
 802b906:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 802b90a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802b90e:	aa06      	add	r2, sp, #24
 802b910:	f842 302c 	str.w	r3, [r2, ip, lsl #2]
 802b914:	e77d      	b.n	802b812 <__kernel_rem_pio2f+0x16e>
 802b916:	f10a 3cff 	add.w	ip, sl, #4294967295	; 0xffffffff
 802b91a:	ab06      	add	r3, sp, #24
 802b91c:	f853 302c 	ldr.w	r3, [r3, ip, lsl #2]
 802b920:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 802b924:	e7f3      	b.n	802b90e <__kernel_rem_pio2f+0x26a>
 802b926:	a906      	add	r1, sp, #24
 802b928:	f851 002c 	ldr.w	r0, [r1, ip, lsl #2]
 802b92c:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 802b930:	4302      	orrs	r2, r0
 802b932:	e7ad      	b.n	802b890 <__kernel_rem_pio2f+0x1ec>
 802b934:	3001      	adds	r0, #1
 802b936:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802b93a:	2a00      	cmp	r2, #0
 802b93c:	d0fa      	beq.n	802b934 <__kernel_rem_pio2f+0x290>
 802b93e:	a91a      	add	r1, sp, #104	; 0x68
 802b940:	eb0a 0208 	add.w	r2, sl, r8
 802b944:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 802b948:	f10a 0301 	add.w	r3, sl, #1
 802b94c:	eb0a 0100 	add.w	r1, sl, r0
 802b950:	4299      	cmp	r1, r3
 802b952:	da04      	bge.n	802b95e <__kernel_rem_pio2f+0x2ba>
 802b954:	468a      	mov	sl, r1
 802b956:	e70e      	b.n	802b776 <__kernel_rem_pio2f+0xd2>
 802b958:	9b04      	ldr	r3, [sp, #16]
 802b95a:	2001      	movs	r0, #1
 802b95c:	e7eb      	b.n	802b936 <__kernel_rem_pio2f+0x292>
 802b95e:	9803      	ldr	r0, [sp, #12]
 802b960:	f8dd c004 	ldr.w	ip, [sp, #4]
 802b964:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 802b968:	9000      	str	r0, [sp, #0]
 802b96a:	ee07 0a90 	vmov	s15, r0
 802b96e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802b972:	2000      	movs	r0, #0
 802b974:	ece2 7a01 	vstmia	r2!, {s15}
 802b978:	eddf 7a0e 	vldr	s15, [pc, #56]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802b97c:	4696      	mov	lr, r2
 802b97e:	4548      	cmp	r0, r9
 802b980:	dd06      	ble.n	802b990 <__kernel_rem_pio2f+0x2ec>
 802b982:	a842      	add	r0, sp, #264	; 0x108
 802b984:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 802b988:	edc0 7a00 	vstr	s15, [r0]
 802b98c:	3301      	adds	r3, #1
 802b98e:	e7df      	b.n	802b950 <__kernel_rem_pio2f+0x2ac>
 802b990:	ecfc 6a01 	vldmia	ip!, {s13}
 802b994:	ed3e 7a01 	vldmdb	lr!, {s14}
 802b998:	3001      	adds	r0, #1
 802b99a:	eee6 7a87 	vfma.f32	s15, s13, s14
 802b99e:	e7ee      	b.n	802b97e <__kernel_rem_pio2f+0x2da>
 802b9a0:	3b01      	subs	r3, #1
 802b9a2:	e779      	b.n	802b898 <__kernel_rem_pio2f+0x1f4>
 802b9a4:	0802dd2c 	.word	0x0802dd2c
 802b9a8:	0802dd00 	.word	0x0802dd00
 802b9ac:	43800000 	.word	0x43800000
 802b9b0:	3b800000 	.word	0x3b800000
 802b9b4:	00000000 	.word	0x00000000
 802b9b8:	9b02      	ldr	r3, [sp, #8]
 802b9ba:	eeb0 0a48 	vmov.f32	s0, s16
 802b9be:	1b98      	subs	r0, r3, r6
 802b9c0:	f000 fad8 	bl	802bf74 <scalbnf>
 802b9c4:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 802b9ac <__kernel_rem_pio2f+0x308>
 802b9c8:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802b9cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b9d0:	db1b      	blt.n	802ba0a <__kernel_rem_pio2f+0x366>
 802b9d2:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 802b9b0 <__kernel_rem_pio2f+0x30c>
 802b9d6:	ee60 7a27 	vmul.f32	s15, s0, s15
 802b9da:	aa06      	add	r2, sp, #24
 802b9dc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802b9e0:	a906      	add	r1, sp, #24
 802b9e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802b9e6:	3408      	adds	r4, #8
 802b9e8:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802b9ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802b9f0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802b9f4:	ee10 3a10 	vmov	r3, s0
 802b9f8:	f842 302a 	str.w	r3, [r2, sl, lsl #2]
 802b9fc:	ee17 2a90 	vmov	r2, s15
 802ba00:	f10a 0301 	add.w	r3, sl, #1
 802ba04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802ba08:	e74c      	b.n	802b8a4 <__kernel_rem_pio2f+0x200>
 802ba0a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802ba0e:	aa06      	add	r2, sp, #24
 802ba10:	ee10 3a10 	vmov	r3, s0
 802ba14:	f842 302a 	str.w	r3, [r2, sl, lsl #2]
 802ba18:	4653      	mov	r3, sl
 802ba1a:	e743      	b.n	802b8a4 <__kernel_rem_pio2f+0x200>
 802ba1c:	aa42      	add	r2, sp, #264	; 0x108
 802ba1e:	eb02 0081 	add.w	r0, r2, r1, lsl #2
 802ba22:	aa06      	add	r2, sp, #24
 802ba24:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 802ba28:	9201      	str	r2, [sp, #4]
 802ba2a:	ee07 2a90 	vmov	s15, r2
 802ba2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ba32:	3901      	subs	r1, #1
 802ba34:	ee67 7a80 	vmul.f32	s15, s15, s0
 802ba38:	ee20 0a07 	vmul.f32	s0, s0, s14
 802ba3c:	edc0 7a00 	vstr	s15, [r0]
 802ba40:	e73a      	b.n	802b8b8 <__kernel_rem_pio2f+0x214>
 802ba42:	ecf2 6a01 	vldmia	r2!, {s13}
 802ba46:	ecb6 7a01 	vldmia	r6!, {s14}
 802ba4a:	eee6 7a87 	vfma.f32	s15, s13, s14
 802ba4e:	3101      	adds	r1, #1
 802ba50:	42b9      	cmp	r1, r7
 802ba52:	dc01      	bgt.n	802ba58 <__kernel_rem_pio2f+0x3b4>
 802ba54:	428c      	cmp	r4, r1
 802ba56:	daf4      	bge.n	802ba42 <__kernel_rem_pio2f+0x39e>
 802ba58:	aa56      	add	r2, sp, #344	; 0x158
 802ba5a:	eb02 0184 	add.w	r1, r2, r4, lsl #2
 802ba5e:	ed41 7a28 	vstr	s15, [r1, #-160]	; 0xffffff60
 802ba62:	3801      	subs	r0, #1
 802ba64:	3401      	adds	r4, #1
 802ba66:	e72c      	b.n	802b8c2 <__kernel_rem_pio2f+0x21e>
 802ba68:	9a64      	ldr	r2, [sp, #400]	; 0x190
 802ba6a:	2a02      	cmp	r2, #2
 802ba6c:	dc0a      	bgt.n	802ba84 <__kernel_rem_pio2f+0x3e0>
 802ba6e:	2a00      	cmp	r2, #0
 802ba70:	dc61      	bgt.n	802bb36 <__kernel_rem_pio2f+0x492>
 802ba72:	d03c      	beq.n	802baee <__kernel_rem_pio2f+0x44a>
 802ba74:	9b00      	ldr	r3, [sp, #0]
 802ba76:	f003 0007 	and.w	r0, r3, #7
 802ba7a:	b057      	add	sp, #348	; 0x15c
 802ba7c:	ecbd 8b04 	vpop	{d8-d9}
 802ba80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ba84:	9a64      	ldr	r2, [sp, #400]	; 0x190
 802ba86:	2a03      	cmp	r2, #3
 802ba88:	d1f4      	bne.n	802ba74 <__kernel_rem_pio2f+0x3d0>
 802ba8a:	aa2e      	add	r2, sp, #184	; 0xb8
 802ba8c:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 802ba90:	4608      	mov	r0, r1
 802ba92:	461c      	mov	r4, r3
 802ba94:	2c00      	cmp	r4, #0
 802ba96:	f1a0 0004 	sub.w	r0, r0, #4
 802ba9a:	dc59      	bgt.n	802bb50 <__kernel_rem_pio2f+0x4ac>
 802ba9c:	4618      	mov	r0, r3
 802ba9e:	2801      	cmp	r0, #1
 802baa0:	f1a1 0104 	sub.w	r1, r1, #4
 802baa4:	dc64      	bgt.n	802bb70 <__kernel_rem_pio2f+0x4cc>
 802baa6:	ed5f 7a3d 	vldr	s15, [pc, #-244]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802baaa:	2b01      	cmp	r3, #1
 802baac:	dc70      	bgt.n	802bb90 <__kernel_rem_pio2f+0x4ec>
 802baae:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 802bab2:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 802bab6:	f1bb 0f00 	cmp.w	fp, #0
 802baba:	d172      	bne.n	802bba2 <__kernel_rem_pio2f+0x4fe>
 802babc:	edc5 6a00 	vstr	s13, [r5]
 802bac0:	ed85 7a01 	vstr	s14, [r5, #4]
 802bac4:	edc5 7a02 	vstr	s15, [r5, #8]
 802bac8:	e7d4      	b.n	802ba74 <__kernel_rem_pio2f+0x3d0>
 802baca:	aa2e      	add	r2, sp, #184	; 0xb8
 802bacc:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 802bad0:	ed91 7a00 	vldr	s14, [r1]
 802bad4:	ee77 7a87 	vadd.f32	s15, s15, s14
 802bad8:	3b01      	subs	r3, #1
 802bada:	2b00      	cmp	r3, #0
 802badc:	daf5      	bge.n	802baca <__kernel_rem_pio2f+0x426>
 802bade:	f1bb 0f00 	cmp.w	fp, #0
 802bae2:	d001      	beq.n	802bae8 <__kernel_rem_pio2f+0x444>
 802bae4:	eef1 7a67 	vneg.f32	s15, s15
 802bae8:	edc5 7a00 	vstr	s15, [r5]
 802baec:	e7c2      	b.n	802ba74 <__kernel_rem_pio2f+0x3d0>
 802baee:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802baf2:	e7f2      	b.n	802bada <__kernel_rem_pio2f+0x436>
 802baf4:	aa2e      	add	r2, sp, #184	; 0xb8
 802baf6:	eb02 0081 	add.w	r0, r2, r1, lsl #2
 802bafa:	edd0 7a00 	vldr	s15, [r0]
 802bafe:	ee37 7a27 	vadd.f32	s14, s14, s15
 802bb02:	3901      	subs	r1, #1
 802bb04:	2900      	cmp	r1, #0
 802bb06:	daf5      	bge.n	802baf4 <__kernel_rem_pio2f+0x450>
 802bb08:	f1bb 0f00 	cmp.w	fp, #0
 802bb0c:	d017      	beq.n	802bb3e <__kernel_rem_pio2f+0x49a>
 802bb0e:	eef1 7a47 	vneg.f32	s15, s14
 802bb12:	edc5 7a00 	vstr	s15, [r5]
 802bb16:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
 802bb1a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bb1e:	a82f      	add	r0, sp, #188	; 0xbc
 802bb20:	2101      	movs	r1, #1
 802bb22:	428b      	cmp	r3, r1
 802bb24:	da0e      	bge.n	802bb44 <__kernel_rem_pio2f+0x4a0>
 802bb26:	f1bb 0f00 	cmp.w	fp, #0
 802bb2a:	d001      	beq.n	802bb30 <__kernel_rem_pio2f+0x48c>
 802bb2c:	eef1 7a67 	vneg.f32	s15, s15
 802bb30:	edc5 7a01 	vstr	s15, [r5, #4]
 802bb34:	e79e      	b.n	802ba74 <__kernel_rem_pio2f+0x3d0>
 802bb36:	ed1f 7a61 	vldr	s14, [pc, #-388]	; 802b9b4 <__kernel_rem_pio2f+0x310>
 802bb3a:	4619      	mov	r1, r3
 802bb3c:	e7e2      	b.n	802bb04 <__kernel_rem_pio2f+0x460>
 802bb3e:	eef0 7a47 	vmov.f32	s15, s14
 802bb42:	e7e6      	b.n	802bb12 <__kernel_rem_pio2f+0x46e>
 802bb44:	ecb0 7a01 	vldmia	r0!, {s14}
 802bb48:	3101      	adds	r1, #1
 802bb4a:	ee77 7a87 	vadd.f32	s15, s15, s14
 802bb4e:	e7e8      	b.n	802bb22 <__kernel_rem_pio2f+0x47e>
 802bb50:	edd0 7a00 	vldr	s15, [r0]
 802bb54:	edd0 6a01 	vldr	s13, [r0, #4]
 802bb58:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802bb5c:	3c01      	subs	r4, #1
 802bb5e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bb62:	ed80 7a00 	vstr	s14, [r0]
 802bb66:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802bb6a:	edc0 7a01 	vstr	s15, [r0, #4]
 802bb6e:	e791      	b.n	802ba94 <__kernel_rem_pio2f+0x3f0>
 802bb70:	edd1 7a00 	vldr	s15, [r1]
 802bb74:	edd1 6a01 	vldr	s13, [r1, #4]
 802bb78:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802bb7c:	3801      	subs	r0, #1
 802bb7e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bb82:	ed81 7a00 	vstr	s14, [r1]
 802bb86:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802bb8a:	edc1 7a01 	vstr	s15, [r1, #4]
 802bb8e:	e786      	b.n	802ba9e <__kernel_rem_pio2f+0x3fa>
 802bb90:	aa2e      	add	r2, sp, #184	; 0xb8
 802bb92:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 802bb96:	ed91 7a00 	vldr	s14, [r1]
 802bb9a:	3b01      	subs	r3, #1
 802bb9c:	ee77 7a87 	vadd.f32	s15, s15, s14
 802bba0:	e783      	b.n	802baaa <__kernel_rem_pio2f+0x406>
 802bba2:	eef1 6a66 	vneg.f32	s13, s13
 802bba6:	eeb1 7a47 	vneg.f32	s14, s14
 802bbaa:	edc5 6a00 	vstr	s13, [r5]
 802bbae:	ed85 7a01 	vstr	s14, [r5, #4]
 802bbb2:	eef1 7a67 	vneg.f32	s15, s15
 802bbb6:	e785      	b.n	802bac4 <__kernel_rem_pio2f+0x420>

0802bbb8 <__kernel_sinf>:
 802bbb8:	ee10 3a10 	vmov	r3, s0
 802bbbc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802bbc0:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802bbc4:	da04      	bge.n	802bbd0 <__kernel_sinf+0x18>
 802bbc6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802bbca:	ee17 3a90 	vmov	r3, s15
 802bbce:	b35b      	cbz	r3, 802bc28 <__kernel_sinf+0x70>
 802bbd0:	ee20 7a00 	vmul.f32	s14, s0, s0
 802bbd4:	eddf 7a15 	vldr	s15, [pc, #84]	; 802bc2c <__kernel_sinf+0x74>
 802bbd8:	ed9f 6a15 	vldr	s12, [pc, #84]	; 802bc30 <__kernel_sinf+0x78>
 802bbdc:	eea7 6a27 	vfma.f32	s12, s14, s15
 802bbe0:	eddf 7a14 	vldr	s15, [pc, #80]	; 802bc34 <__kernel_sinf+0x7c>
 802bbe4:	eee6 7a07 	vfma.f32	s15, s12, s14
 802bbe8:	ed9f 6a13 	vldr	s12, [pc, #76]	; 802bc38 <__kernel_sinf+0x80>
 802bbec:	eea7 6a87 	vfma.f32	s12, s15, s14
 802bbf0:	eddf 7a12 	vldr	s15, [pc, #72]	; 802bc3c <__kernel_sinf+0x84>
 802bbf4:	ee60 6a07 	vmul.f32	s13, s0, s14
 802bbf8:	eee6 7a07 	vfma.f32	s15, s12, s14
 802bbfc:	b930      	cbnz	r0, 802bc0c <__kernel_sinf+0x54>
 802bbfe:	ed9f 6a10 	vldr	s12, [pc, #64]	; 802bc40 <__kernel_sinf+0x88>
 802bc02:	eea7 6a27 	vfma.f32	s12, s14, s15
 802bc06:	eea6 0a26 	vfma.f32	s0, s12, s13
 802bc0a:	4770      	bx	lr
 802bc0c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 802bc10:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 802bc14:	eee0 7a86 	vfma.f32	s15, s1, s12
 802bc18:	eed7 0a87 	vfnms.f32	s1, s15, s14
 802bc1c:	eddf 7a09 	vldr	s15, [pc, #36]	; 802bc44 <__kernel_sinf+0x8c>
 802bc20:	eee6 0aa7 	vfma.f32	s1, s13, s15
 802bc24:	ee30 0a60 	vsub.f32	s0, s0, s1
 802bc28:	4770      	bx	lr
 802bc2a:	bf00      	nop
 802bc2c:	2f2ec9d3 	.word	0x2f2ec9d3
 802bc30:	b2d72f34 	.word	0xb2d72f34
 802bc34:	3638ef1b 	.word	0x3638ef1b
 802bc38:	b9500d01 	.word	0xb9500d01
 802bc3c:	3c088889 	.word	0x3c088889
 802bc40:	be2aaaab 	.word	0xbe2aaaab
 802bc44:	3e2aaaab 	.word	0x3e2aaaab

0802bc48 <finite>:
 802bc48:	b082      	sub	sp, #8
 802bc4a:	ed8d 0b00 	vstr	d0, [sp]
 802bc4e:	9801      	ldr	r0, [sp, #4]
 802bc50:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 802bc54:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
 802bc58:	0fc0      	lsrs	r0, r0, #31
 802bc5a:	b002      	add	sp, #8
 802bc5c:	4770      	bx	lr
	...

0802bc60 <nan>:
 802bc60:	ed9f 0b01 	vldr	d0, [pc, #4]	; 802bc68 <nan+0x8>
 802bc64:	4770      	bx	lr
 802bc66:	bf00      	nop
 802bc68:	00000000 	.word	0x00000000
 802bc6c:	7ff80000 	.word	0x7ff80000

0802bc70 <rint>:
 802bc70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802bc72:	ec51 0b10 	vmov	r0, r1, d0
 802bc76:	f3c1 520a 	ubfx	r2, r1, #20, #11
 802bc7a:	f2a2 36ff 	subw	r6, r2, #1023	; 0x3ff
 802bc7e:	2e13      	cmp	r6, #19
 802bc80:	ee10 4a10 	vmov	r4, s0
 802bc84:	460b      	mov	r3, r1
 802bc86:	ea4f 75d1 	mov.w	r5, r1, lsr #31
 802bc8a:	dc58      	bgt.n	802bd3e <rint+0xce>
 802bc8c:	2e00      	cmp	r6, #0
 802bc8e:	da2b      	bge.n	802bce8 <rint+0x78>
 802bc90:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 802bc94:	4302      	orrs	r2, r0
 802bc96:	d023      	beq.n	802bce0 <rint+0x70>
 802bc98:	f3c1 0213 	ubfx	r2, r1, #0, #20
 802bc9c:	4302      	orrs	r2, r0
 802bc9e:	4254      	negs	r4, r2
 802bca0:	4314      	orrs	r4, r2
 802bca2:	0c4b      	lsrs	r3, r1, #17
 802bca4:	0b24      	lsrs	r4, r4, #12
 802bca6:	045b      	lsls	r3, r3, #17
 802bca8:	f404 2400 	and.w	r4, r4, #524288	; 0x80000
 802bcac:	ea44 0103 	orr.w	r1, r4, r3
 802bcb0:	4b32      	ldr	r3, [pc, #200]	; (802bd7c <rint+0x10c>)
 802bcb2:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 802bcb6:	e9d3 6700 	ldrd	r6, r7, [r3]
 802bcba:	4602      	mov	r2, r0
 802bcbc:	460b      	mov	r3, r1
 802bcbe:	4630      	mov	r0, r6
 802bcc0:	4639      	mov	r1, r7
 802bcc2:	f7db fd63 	bl	800778c <__adddf3>
 802bcc6:	e9cd 0100 	strd	r0, r1, [sp]
 802bcca:	463b      	mov	r3, r7
 802bccc:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bcd0:	4632      	mov	r2, r6
 802bcd2:	f7db fd59 	bl	8007788 <__aeabi_dsub>
 802bcd6:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 802bcda:	ea43 77c5 	orr.w	r7, r3, r5, lsl #31
 802bcde:	4639      	mov	r1, r7
 802bce0:	ec41 0b10 	vmov	d0, r0, r1
 802bce4:	b003      	add	sp, #12
 802bce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bce8:	4a25      	ldr	r2, [pc, #148]	; (802bd80 <rint+0x110>)
 802bcea:	4132      	asrs	r2, r6
 802bcec:	ea01 0702 	and.w	r7, r1, r2
 802bcf0:	4307      	orrs	r7, r0
 802bcf2:	d0f5      	beq.n	802bce0 <rint+0x70>
 802bcf4:	0851      	lsrs	r1, r2, #1
 802bcf6:	ea03 0252 	and.w	r2, r3, r2, lsr #1
 802bcfa:	4314      	orrs	r4, r2
 802bcfc:	d00c      	beq.n	802bd18 <rint+0xa8>
 802bcfe:	ea23 0201 	bic.w	r2, r3, r1
 802bd02:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 802bd06:	2e13      	cmp	r6, #19
 802bd08:	fa43 f606 	asr.w	r6, r3, r6
 802bd0c:	bf0c      	ite	eq
 802bd0e:	f04f 4400 	moveq.w	r4, #2147483648	; 0x80000000
 802bd12:	2400      	movne	r4, #0
 802bd14:	ea42 0306 	orr.w	r3, r2, r6
 802bd18:	4918      	ldr	r1, [pc, #96]	; (802bd7c <rint+0x10c>)
 802bd1a:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
 802bd1e:	4622      	mov	r2, r4
 802bd20:	e9d5 4500 	ldrd	r4, r5, [r5]
 802bd24:	4620      	mov	r0, r4
 802bd26:	4629      	mov	r1, r5
 802bd28:	f7db fd30 	bl	800778c <__adddf3>
 802bd2c:	e9cd 0100 	strd	r0, r1, [sp]
 802bd30:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bd34:	4622      	mov	r2, r4
 802bd36:	462b      	mov	r3, r5
 802bd38:	f7db fd26 	bl	8007788 <__aeabi_dsub>
 802bd3c:	e7d0      	b.n	802bce0 <rint+0x70>
 802bd3e:	2e33      	cmp	r6, #51	; 0x33
 802bd40:	dd07      	ble.n	802bd52 <rint+0xe2>
 802bd42:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 802bd46:	d1cb      	bne.n	802bce0 <rint+0x70>
 802bd48:	ee10 2a10 	vmov	r2, s0
 802bd4c:	f7db fd1e 	bl	800778c <__adddf3>
 802bd50:	e7c6      	b.n	802bce0 <rint+0x70>
 802bd52:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
 802bd56:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 802bd5a:	40d6      	lsrs	r6, r2
 802bd5c:	4230      	tst	r0, r6
 802bd5e:	d0bf      	beq.n	802bce0 <rint+0x70>
 802bd60:	ea14 0056 	ands.w	r0, r4, r6, lsr #1
 802bd64:	ea4f 0156 	mov.w	r1, r6, lsr #1
 802bd68:	bf1f      	itttt	ne
 802bd6a:	ea24 0101 	bicne.w	r1, r4, r1
 802bd6e:	f04f 4480 	movne.w	r4, #1073741824	; 0x40000000
 802bd72:	fa44 f202 	asrne.w	r2, r4, r2
 802bd76:	ea41 0402 	orrne.w	r4, r1, r2
 802bd7a:	e7cd      	b.n	802bd18 <rint+0xa8>
 802bd7c:	0802dd38 	.word	0x0802dd38
 802bd80:	000fffff 	.word	0x000fffff
 802bd84:	00000000 	.word	0x00000000

0802bd88 <scalbn>:
 802bd88:	b570      	push	{r4, r5, r6, lr}
 802bd8a:	ec55 4b10 	vmov	r4, r5, d0
 802bd8e:	f3c5 520a 	ubfx	r2, r5, #20, #11
 802bd92:	4606      	mov	r6, r0
 802bd94:	462b      	mov	r3, r5
 802bd96:	b99a      	cbnz	r2, 802bdc0 <scalbn+0x38>
 802bd98:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
 802bd9c:	4323      	orrs	r3, r4
 802bd9e:	d036      	beq.n	802be0e <scalbn+0x86>
 802bda0:	4b39      	ldr	r3, [pc, #228]	; (802be88 <scalbn+0x100>)
 802bda2:	4629      	mov	r1, r5
 802bda4:	ee10 0a10 	vmov	r0, s0
 802bda8:	2200      	movs	r2, #0
 802bdaa:	f7db fea5 	bl	8007af8 <__aeabi_dmul>
 802bdae:	4b37      	ldr	r3, [pc, #220]	; (802be8c <scalbn+0x104>)
 802bdb0:	429e      	cmp	r6, r3
 802bdb2:	4604      	mov	r4, r0
 802bdb4:	460d      	mov	r5, r1
 802bdb6:	da10      	bge.n	802bdda <scalbn+0x52>
 802bdb8:	a32b      	add	r3, pc, #172	; (adr r3, 802be68 <scalbn+0xe0>)
 802bdba:	e9d3 2300 	ldrd	r2, r3, [r3]
 802bdbe:	e03a      	b.n	802be36 <scalbn+0xae>
 802bdc0:	f240 71ff 	movw	r1, #2047	; 0x7ff
 802bdc4:	428a      	cmp	r2, r1
 802bdc6:	d10c      	bne.n	802bde2 <scalbn+0x5a>
 802bdc8:	ee10 2a10 	vmov	r2, s0
 802bdcc:	4620      	mov	r0, r4
 802bdce:	4629      	mov	r1, r5
 802bdd0:	f7db fcdc 	bl	800778c <__adddf3>
 802bdd4:	4604      	mov	r4, r0
 802bdd6:	460d      	mov	r5, r1
 802bdd8:	e019      	b.n	802be0e <scalbn+0x86>
 802bdda:	f3c1 520a 	ubfx	r2, r1, #20, #11
 802bdde:	460b      	mov	r3, r1
 802bde0:	3a36      	subs	r2, #54	; 0x36
 802bde2:	4432      	add	r2, r6
 802bde4:	f240 71fe 	movw	r1, #2046	; 0x7fe
 802bde8:	428a      	cmp	r2, r1
 802bdea:	dd08      	ble.n	802bdfe <scalbn+0x76>
 802bdec:	2d00      	cmp	r5, #0
 802bdee:	a120      	add	r1, pc, #128	; (adr r1, 802be70 <scalbn+0xe8>)
 802bdf0:	e9d1 0100 	ldrd	r0, r1, [r1]
 802bdf4:	da1c      	bge.n	802be30 <scalbn+0xa8>
 802bdf6:	a120      	add	r1, pc, #128	; (adr r1, 802be78 <scalbn+0xf0>)
 802bdf8:	e9d1 0100 	ldrd	r0, r1, [r1]
 802bdfc:	e018      	b.n	802be30 <scalbn+0xa8>
 802bdfe:	2a00      	cmp	r2, #0
 802be00:	dd08      	ble.n	802be14 <scalbn+0x8c>
 802be02:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802be06:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 802be0a:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 802be0e:	ec45 4b10 	vmov	d0, r4, r5
 802be12:	bd70      	pop	{r4, r5, r6, pc}
 802be14:	f112 0f35 	cmn.w	r2, #53	; 0x35
 802be18:	da19      	bge.n	802be4e <scalbn+0xc6>
 802be1a:	f24c 3350 	movw	r3, #50000	; 0xc350
 802be1e:	429e      	cmp	r6, r3
 802be20:	f005 4300 	and.w	r3, r5, #2147483648	; 0x80000000
 802be24:	dd0a      	ble.n	802be3c <scalbn+0xb4>
 802be26:	a112      	add	r1, pc, #72	; (adr r1, 802be70 <scalbn+0xe8>)
 802be28:	e9d1 0100 	ldrd	r0, r1, [r1]
 802be2c:	2b00      	cmp	r3, #0
 802be2e:	d1e2      	bne.n	802bdf6 <scalbn+0x6e>
 802be30:	a30f      	add	r3, pc, #60	; (adr r3, 802be70 <scalbn+0xe8>)
 802be32:	e9d3 2300 	ldrd	r2, r3, [r3]
 802be36:	f7db fe5f 	bl	8007af8 <__aeabi_dmul>
 802be3a:	e7cb      	b.n	802bdd4 <scalbn+0x4c>
 802be3c:	a10a      	add	r1, pc, #40	; (adr r1, 802be68 <scalbn+0xe0>)
 802be3e:	e9d1 0100 	ldrd	r0, r1, [r1]
 802be42:	2b00      	cmp	r3, #0
 802be44:	d0b8      	beq.n	802bdb8 <scalbn+0x30>
 802be46:	a10e      	add	r1, pc, #56	; (adr r1, 802be80 <scalbn+0xf8>)
 802be48:	e9d1 0100 	ldrd	r0, r1, [r1]
 802be4c:	e7b4      	b.n	802bdb8 <scalbn+0x30>
 802be4e:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802be52:	3236      	adds	r2, #54	; 0x36
 802be54:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 802be58:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
 802be5c:	4620      	mov	r0, r4
 802be5e:	4b0c      	ldr	r3, [pc, #48]	; (802be90 <scalbn+0x108>)
 802be60:	2200      	movs	r2, #0
 802be62:	e7e8      	b.n	802be36 <scalbn+0xae>
 802be64:	f3af 8000 	nop.w
 802be68:	c2f8f359 	.word	0xc2f8f359
 802be6c:	01a56e1f 	.word	0x01a56e1f
 802be70:	8800759c 	.word	0x8800759c
 802be74:	7e37e43c 	.word	0x7e37e43c
 802be78:	8800759c 	.word	0x8800759c
 802be7c:	fe37e43c 	.word	0xfe37e43c
 802be80:	c2f8f359 	.word	0xc2f8f359
 802be84:	81a56e1f 	.word	0x81a56e1f
 802be88:	43500000 	.word	0x43500000
 802be8c:	ffff3cb0 	.word	0xffff3cb0
 802be90:	3c900000 	.word	0x3c900000

0802be94 <finitef>:
 802be94:	b082      	sub	sp, #8
 802be96:	ed8d 0a01 	vstr	s0, [sp, #4]
 802be9a:	9801      	ldr	r0, [sp, #4]
 802be9c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802bea0:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802bea4:	bfac      	ite	ge
 802bea6:	2000      	movge	r0, #0
 802bea8:	2001      	movlt	r0, #1
 802beaa:	b002      	add	sp, #8
 802beac:	4770      	bx	lr
	...

0802beb0 <nanf>:
 802beb0:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802beb8 <nanf+0x8>
 802beb4:	4770      	bx	lr
 802beb6:	bf00      	nop
 802beb8:	7fc00000 	.word	0x7fc00000

0802bebc <rintf>:
 802bebc:	ee10 2a10 	vmov	r2, s0
 802bec0:	b513      	push	{r0, r1, r4, lr}
 802bec2:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 802bec6:	397f      	subs	r1, #127	; 0x7f
 802bec8:	2916      	cmp	r1, #22
 802beca:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802bece:	dc47      	bgt.n	802bf60 <rintf+0xa4>
 802bed0:	b32b      	cbz	r3, 802bf1e <rintf+0x62>
 802bed2:	2900      	cmp	r1, #0
 802bed4:	ee10 3a10 	vmov	r3, s0
 802bed8:	ea4f 70d2 	mov.w	r0, r2, lsr #31
 802bedc:	da21      	bge.n	802bf22 <rintf+0x66>
 802bede:	f3c2 0316 	ubfx	r3, r2, #0, #23
 802bee2:	425b      	negs	r3, r3
 802bee4:	4921      	ldr	r1, [pc, #132]	; (802bf6c <rintf+0xb0>)
 802bee6:	0a5b      	lsrs	r3, r3, #9
 802bee8:	0d12      	lsrs	r2, r2, #20
 802beea:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802beee:	0512      	lsls	r2, r2, #20
 802bef0:	4313      	orrs	r3, r2
 802bef2:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 802bef6:	ee07 3a90 	vmov	s15, r3
 802befa:	edd1 6a00 	vldr	s13, [r1]
 802befe:	ee36 7aa7 	vadd.f32	s14, s13, s15
 802bf02:	ed8d 7a01 	vstr	s14, [sp, #4]
 802bf06:	eddd 7a01 	vldr	s15, [sp, #4]
 802bf0a:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802bf0e:	ee17 3a90 	vmov	r3, s15
 802bf12:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802bf16:	ea43 73c0 	orr.w	r3, r3, r0, lsl #31
 802bf1a:	ee00 3a10 	vmov	s0, r3
 802bf1e:	b002      	add	sp, #8
 802bf20:	bd10      	pop	{r4, pc}
 802bf22:	4a13      	ldr	r2, [pc, #76]	; (802bf70 <rintf+0xb4>)
 802bf24:	410a      	asrs	r2, r1
 802bf26:	4213      	tst	r3, r2
 802bf28:	d0f9      	beq.n	802bf1e <rintf+0x62>
 802bf2a:	0854      	lsrs	r4, r2, #1
 802bf2c:	ea13 0252 	ands.w	r2, r3, r2, lsr #1
 802bf30:	d006      	beq.n	802bf40 <rintf+0x84>
 802bf32:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 802bf36:	ea23 0304 	bic.w	r3, r3, r4
 802bf3a:	fa42 f101 	asr.w	r1, r2, r1
 802bf3e:	430b      	orrs	r3, r1
 802bf40:	4a0a      	ldr	r2, [pc, #40]	; (802bf6c <rintf+0xb0>)
 802bf42:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 802bf46:	ed90 7a00 	vldr	s14, [r0]
 802bf4a:	ee07 3a90 	vmov	s15, r3
 802bf4e:	ee77 7a27 	vadd.f32	s15, s14, s15
 802bf52:	edcd 7a01 	vstr	s15, [sp, #4]
 802bf56:	ed9d 0a01 	vldr	s0, [sp, #4]
 802bf5a:	ee30 0a47 	vsub.f32	s0, s0, s14
 802bf5e:	e7de      	b.n	802bf1e <rintf+0x62>
 802bf60:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802bf64:	d3db      	bcc.n	802bf1e <rintf+0x62>
 802bf66:	ee30 0a00 	vadd.f32	s0, s0, s0
 802bf6a:	e7d8      	b.n	802bf1e <rintf+0x62>
 802bf6c:	0802dd48 	.word	0x0802dd48
 802bf70:	007fffff 	.word	0x007fffff

0802bf74 <scalbnf>:
 802bf74:	ee10 3a10 	vmov	r3, s0
 802bf78:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802bf7c:	d025      	beq.n	802bfca <scalbnf+0x56>
 802bf7e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802bf82:	d302      	bcc.n	802bf8a <scalbnf+0x16>
 802bf84:	ee30 0a00 	vadd.f32	s0, s0, s0
 802bf88:	4770      	bx	lr
 802bf8a:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
 802bf8e:	d122      	bne.n	802bfd6 <scalbnf+0x62>
 802bf90:	4b2a      	ldr	r3, [pc, #168]	; (802c03c <scalbnf+0xc8>)
 802bf92:	eddf 7a2b 	vldr	s15, [pc, #172]	; 802c040 <scalbnf+0xcc>
 802bf96:	4298      	cmp	r0, r3
 802bf98:	ee20 0a27 	vmul.f32	s0, s0, s15
 802bf9c:	db16      	blt.n	802bfcc <scalbnf+0x58>
 802bf9e:	ee10 3a10 	vmov	r3, s0
 802bfa2:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802bfa6:	3a19      	subs	r2, #25
 802bfa8:	4402      	add	r2, r0
 802bfaa:	2afe      	cmp	r2, #254	; 0xfe
 802bfac:	dd15      	ble.n	802bfda <scalbnf+0x66>
 802bfae:	ee10 3a10 	vmov	r3, s0
 802bfb2:	eddf 7a24 	vldr	s15, [pc, #144]	; 802c044 <scalbnf+0xd0>
 802bfb6:	eddf 6a24 	vldr	s13, [pc, #144]	; 802c048 <scalbnf+0xd4>
 802bfba:	2b00      	cmp	r3, #0
 802bfbc:	eeb0 7a67 	vmov.f32	s14, s15
 802bfc0:	bfb8      	it	lt
 802bfc2:	eef0 7a66 	vmovlt.f32	s15, s13
 802bfc6:	ee27 0a27 	vmul.f32	s0, s14, s15
 802bfca:	4770      	bx	lr
 802bfcc:	eddf 7a1f 	vldr	s15, [pc, #124]	; 802c04c <scalbnf+0xd8>
 802bfd0:	ee20 0a27 	vmul.f32	s0, s0, s15
 802bfd4:	4770      	bx	lr
 802bfd6:	0dd2      	lsrs	r2, r2, #23
 802bfd8:	e7e6      	b.n	802bfa8 <scalbnf+0x34>
 802bfda:	2a00      	cmp	r2, #0
 802bfdc:	dd06      	ble.n	802bfec <scalbnf+0x78>
 802bfde:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802bfe2:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802bfe6:	ee00 3a10 	vmov	s0, r3
 802bfea:	4770      	bx	lr
 802bfec:	f112 0f16 	cmn.w	r2, #22
 802bff0:	da1a      	bge.n	802c028 <scalbnf+0xb4>
 802bff2:	f24c 3350 	movw	r3, #50000	; 0xc350
 802bff6:	4298      	cmp	r0, r3
 802bff8:	ee10 3a10 	vmov	r3, s0
 802bffc:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 802c000:	dd0a      	ble.n	802c018 <scalbnf+0xa4>
 802c002:	ed9f 0a10 	vldr	s0, [pc, #64]	; 802c044 <scalbnf+0xd0>
 802c006:	ed9f 7a10 	vldr	s14, [pc, #64]	; 802c048 <scalbnf+0xd4>
 802c00a:	eef0 7a40 	vmov.f32	s15, s0
 802c00e:	2b00      	cmp	r3, #0
 802c010:	bf18      	it	ne
 802c012:	eeb0 0a47 	vmovne.f32	s0, s14
 802c016:	e7db      	b.n	802bfd0 <scalbnf+0x5c>
 802c018:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 802c04c <scalbnf+0xd8>
 802c01c:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 802c050 <scalbnf+0xdc>
 802c020:	eef0 7a40 	vmov.f32	s15, s0
 802c024:	2b00      	cmp	r3, #0
 802c026:	e7f3      	b.n	802c010 <scalbnf+0x9c>
 802c028:	3219      	adds	r2, #25
 802c02a:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802c02e:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c032:	eddf 7a08 	vldr	s15, [pc, #32]	; 802c054 <scalbnf+0xe0>
 802c036:	ee07 3a10 	vmov	s14, r3
 802c03a:	e7c4      	b.n	802bfc6 <scalbnf+0x52>
 802c03c:	ffff3cb0 	.word	0xffff3cb0
 802c040:	4c000000 	.word	0x4c000000
 802c044:	7149f2ca 	.word	0x7149f2ca
 802c048:	f149f2ca 	.word	0xf149f2ca
 802c04c:	0da24260 	.word	0x0da24260
 802c050:	8da24260 	.word	0x8da24260
 802c054:	33000000 	.word	0x33000000

0802c058 <abort>:
 802c058:	b508      	push	{r3, lr}
 802c05a:	2006      	movs	r0, #6
 802c05c:	f000 f9a2 	bl	802c3a4 <raise>
 802c060:	2001      	movs	r0, #1
 802c062:	f7e0 f87d 	bl	800c160 <_exit>
	...

0802c068 <__errno>:
 802c068:	4b01      	ldr	r3, [pc, #4]	; (802c070 <__errno+0x8>)
 802c06a:	6818      	ldr	r0, [r3, #0]
 802c06c:	4770      	bx	lr
 802c06e:	bf00      	nop
 802c070:	200001b4 	.word	0x200001b4

0802c074 <__libc_init_array>:
 802c074:	b570      	push	{r4, r5, r6, lr}
 802c076:	4d0d      	ldr	r5, [pc, #52]	; (802c0ac <__libc_init_array+0x38>)
 802c078:	4c0d      	ldr	r4, [pc, #52]	; (802c0b0 <__libc_init_array+0x3c>)
 802c07a:	1b64      	subs	r4, r4, r5
 802c07c:	10a4      	asrs	r4, r4, #2
 802c07e:	2600      	movs	r6, #0
 802c080:	42a6      	cmp	r6, r4
 802c082:	d109      	bne.n	802c098 <__libc_init_array+0x24>
 802c084:	4d0b      	ldr	r5, [pc, #44]	; (802c0b4 <__libc_init_array+0x40>)
 802c086:	4c0c      	ldr	r4, [pc, #48]	; (802c0b8 <__libc_init_array+0x44>)
 802c088:	f000 f9c8 	bl	802c41c <_init>
 802c08c:	1b64      	subs	r4, r4, r5
 802c08e:	10a4      	asrs	r4, r4, #2
 802c090:	2600      	movs	r6, #0
 802c092:	42a6      	cmp	r6, r4
 802c094:	d105      	bne.n	802c0a2 <__libc_init_array+0x2e>
 802c096:	bd70      	pop	{r4, r5, r6, pc}
 802c098:	f855 3b04 	ldr.w	r3, [r5], #4
 802c09c:	4798      	blx	r3
 802c09e:	3601      	adds	r6, #1
 802c0a0:	e7ee      	b.n	802c080 <__libc_init_array+0xc>
 802c0a2:	f855 3b04 	ldr.w	r3, [r5], #4
 802c0a6:	4798      	blx	r3
 802c0a8:	3601      	adds	r6, #1
 802c0aa:	e7f2      	b.n	802c092 <__libc_init_array+0x1e>
 802c0ac:	0802ddb8 	.word	0x0802ddb8
 802c0b0:	0802ddb8 	.word	0x0802ddb8
 802c0b4:	0802ddb8 	.word	0x0802ddb8
 802c0b8:	0802ddd8 	.word	0x0802ddd8

0802c0bc <__retarget_lock_acquire_recursive>:
 802c0bc:	4770      	bx	lr

0802c0be <__retarget_lock_release_recursive>:
 802c0be:	4770      	bx	lr

0802c0c0 <malloc>:
 802c0c0:	4b02      	ldr	r3, [pc, #8]	; (802c0cc <malloc+0xc>)
 802c0c2:	4601      	mov	r1, r0
 802c0c4:	6818      	ldr	r0, [r3, #0]
 802c0c6:	f000 b871 	b.w	802c1ac <_malloc_r>
 802c0ca:	bf00      	nop
 802c0cc:	200001b4 	.word	0x200001b4

0802c0d0 <free>:
 802c0d0:	4b02      	ldr	r3, [pc, #8]	; (802c0dc <free+0xc>)
 802c0d2:	4601      	mov	r1, r0
 802c0d4:	6818      	ldr	r0, [r3, #0]
 802c0d6:	f000 b819 	b.w	802c10c <_free_r>
 802c0da:	bf00      	nop
 802c0dc:	200001b4 	.word	0x200001b4

0802c0e0 <memcpy>:
 802c0e0:	440a      	add	r2, r1
 802c0e2:	4291      	cmp	r1, r2
 802c0e4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 802c0e8:	d100      	bne.n	802c0ec <memcpy+0xc>
 802c0ea:	4770      	bx	lr
 802c0ec:	b510      	push	{r4, lr}
 802c0ee:	f811 4b01 	ldrb.w	r4, [r1], #1
 802c0f2:	f803 4f01 	strb.w	r4, [r3, #1]!
 802c0f6:	4291      	cmp	r1, r2
 802c0f8:	d1f9      	bne.n	802c0ee <memcpy+0xe>
 802c0fa:	bd10      	pop	{r4, pc}

0802c0fc <memset>:
 802c0fc:	4402      	add	r2, r0
 802c0fe:	4603      	mov	r3, r0
 802c100:	4293      	cmp	r3, r2
 802c102:	d100      	bne.n	802c106 <memset+0xa>
 802c104:	4770      	bx	lr
 802c106:	f803 1b01 	strb.w	r1, [r3], #1
 802c10a:	e7f9      	b.n	802c100 <memset+0x4>

0802c10c <_free_r>:
 802c10c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802c10e:	2900      	cmp	r1, #0
 802c110:	d048      	beq.n	802c1a4 <_free_r+0x98>
 802c112:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802c116:	9001      	str	r0, [sp, #4]
 802c118:	2b00      	cmp	r3, #0
 802c11a:	f1a1 0404 	sub.w	r4, r1, #4
 802c11e:	bfb8      	it	lt
 802c120:	18e4      	addlt	r4, r4, r3
 802c122:	f000 f96f 	bl	802c404 <__malloc_lock>
 802c126:	4a20      	ldr	r2, [pc, #128]	; (802c1a8 <_free_r+0x9c>)
 802c128:	9801      	ldr	r0, [sp, #4]
 802c12a:	6813      	ldr	r3, [r2, #0]
 802c12c:	4615      	mov	r5, r2
 802c12e:	b933      	cbnz	r3, 802c13e <_free_r+0x32>
 802c130:	6063      	str	r3, [r4, #4]
 802c132:	6014      	str	r4, [r2, #0]
 802c134:	b003      	add	sp, #12
 802c136:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 802c13a:	f000 b969 	b.w	802c410 <__malloc_unlock>
 802c13e:	42a3      	cmp	r3, r4
 802c140:	d90b      	bls.n	802c15a <_free_r+0x4e>
 802c142:	6821      	ldr	r1, [r4, #0]
 802c144:	1862      	adds	r2, r4, r1
 802c146:	4293      	cmp	r3, r2
 802c148:	bf04      	itt	eq
 802c14a:	681a      	ldreq	r2, [r3, #0]
 802c14c:	685b      	ldreq	r3, [r3, #4]
 802c14e:	6063      	str	r3, [r4, #4]
 802c150:	bf04      	itt	eq
 802c152:	1852      	addeq	r2, r2, r1
 802c154:	6022      	streq	r2, [r4, #0]
 802c156:	602c      	str	r4, [r5, #0]
 802c158:	e7ec      	b.n	802c134 <_free_r+0x28>
 802c15a:	461a      	mov	r2, r3
 802c15c:	685b      	ldr	r3, [r3, #4]
 802c15e:	b10b      	cbz	r3, 802c164 <_free_r+0x58>
 802c160:	42a3      	cmp	r3, r4
 802c162:	d9fa      	bls.n	802c15a <_free_r+0x4e>
 802c164:	6811      	ldr	r1, [r2, #0]
 802c166:	1855      	adds	r5, r2, r1
 802c168:	42a5      	cmp	r5, r4
 802c16a:	d10b      	bne.n	802c184 <_free_r+0x78>
 802c16c:	6824      	ldr	r4, [r4, #0]
 802c16e:	4421      	add	r1, r4
 802c170:	1854      	adds	r4, r2, r1
 802c172:	42a3      	cmp	r3, r4
 802c174:	6011      	str	r1, [r2, #0]
 802c176:	d1dd      	bne.n	802c134 <_free_r+0x28>
 802c178:	681c      	ldr	r4, [r3, #0]
 802c17a:	685b      	ldr	r3, [r3, #4]
 802c17c:	6053      	str	r3, [r2, #4]
 802c17e:	4421      	add	r1, r4
 802c180:	6011      	str	r1, [r2, #0]
 802c182:	e7d7      	b.n	802c134 <_free_r+0x28>
 802c184:	d902      	bls.n	802c18c <_free_r+0x80>
 802c186:	230c      	movs	r3, #12
 802c188:	6003      	str	r3, [r0, #0]
 802c18a:	e7d3      	b.n	802c134 <_free_r+0x28>
 802c18c:	6825      	ldr	r5, [r4, #0]
 802c18e:	1961      	adds	r1, r4, r5
 802c190:	428b      	cmp	r3, r1
 802c192:	bf04      	itt	eq
 802c194:	6819      	ldreq	r1, [r3, #0]
 802c196:	685b      	ldreq	r3, [r3, #4]
 802c198:	6063      	str	r3, [r4, #4]
 802c19a:	bf04      	itt	eq
 802c19c:	1949      	addeq	r1, r1, r5
 802c19e:	6021      	streq	r1, [r4, #0]
 802c1a0:	6054      	str	r4, [r2, #4]
 802c1a2:	e7c7      	b.n	802c134 <_free_r+0x28>
 802c1a4:	b003      	add	sp, #12
 802c1a6:	bd30      	pop	{r4, r5, pc}
 802c1a8:	20011e84 	.word	0x20011e84

0802c1ac <_malloc_r>:
 802c1ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802c1ae:	1ccd      	adds	r5, r1, #3
 802c1b0:	f025 0503 	bic.w	r5, r5, #3
 802c1b4:	3508      	adds	r5, #8
 802c1b6:	2d0c      	cmp	r5, #12
 802c1b8:	bf38      	it	cc
 802c1ba:	250c      	movcc	r5, #12
 802c1bc:	2d00      	cmp	r5, #0
 802c1be:	4606      	mov	r6, r0
 802c1c0:	db01      	blt.n	802c1c6 <_malloc_r+0x1a>
 802c1c2:	42a9      	cmp	r1, r5
 802c1c4:	d903      	bls.n	802c1ce <_malloc_r+0x22>
 802c1c6:	230c      	movs	r3, #12
 802c1c8:	6033      	str	r3, [r6, #0]
 802c1ca:	2000      	movs	r0, #0
 802c1cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802c1ce:	f000 f919 	bl	802c404 <__malloc_lock>
 802c1d2:	4921      	ldr	r1, [pc, #132]	; (802c258 <_malloc_r+0xac>)
 802c1d4:	680a      	ldr	r2, [r1, #0]
 802c1d6:	4614      	mov	r4, r2
 802c1d8:	b99c      	cbnz	r4, 802c202 <_malloc_r+0x56>
 802c1da:	4f20      	ldr	r7, [pc, #128]	; (802c25c <_malloc_r+0xb0>)
 802c1dc:	683b      	ldr	r3, [r7, #0]
 802c1de:	b923      	cbnz	r3, 802c1ea <_malloc_r+0x3e>
 802c1e0:	4621      	mov	r1, r4
 802c1e2:	4630      	mov	r0, r6
 802c1e4:	f000 f8a6 	bl	802c334 <_sbrk_r>
 802c1e8:	6038      	str	r0, [r7, #0]
 802c1ea:	4629      	mov	r1, r5
 802c1ec:	4630      	mov	r0, r6
 802c1ee:	f000 f8a1 	bl	802c334 <_sbrk_r>
 802c1f2:	1c43      	adds	r3, r0, #1
 802c1f4:	d123      	bne.n	802c23e <_malloc_r+0x92>
 802c1f6:	230c      	movs	r3, #12
 802c1f8:	6033      	str	r3, [r6, #0]
 802c1fa:	4630      	mov	r0, r6
 802c1fc:	f000 f908 	bl	802c410 <__malloc_unlock>
 802c200:	e7e3      	b.n	802c1ca <_malloc_r+0x1e>
 802c202:	6823      	ldr	r3, [r4, #0]
 802c204:	1b5b      	subs	r3, r3, r5
 802c206:	d417      	bmi.n	802c238 <_malloc_r+0x8c>
 802c208:	2b0b      	cmp	r3, #11
 802c20a:	d903      	bls.n	802c214 <_malloc_r+0x68>
 802c20c:	6023      	str	r3, [r4, #0]
 802c20e:	441c      	add	r4, r3
 802c210:	6025      	str	r5, [r4, #0]
 802c212:	e004      	b.n	802c21e <_malloc_r+0x72>
 802c214:	6863      	ldr	r3, [r4, #4]
 802c216:	42a2      	cmp	r2, r4
 802c218:	bf0c      	ite	eq
 802c21a:	600b      	streq	r3, [r1, #0]
 802c21c:	6053      	strne	r3, [r2, #4]
 802c21e:	4630      	mov	r0, r6
 802c220:	f000 f8f6 	bl	802c410 <__malloc_unlock>
 802c224:	f104 000b 	add.w	r0, r4, #11
 802c228:	1d23      	adds	r3, r4, #4
 802c22a:	f020 0007 	bic.w	r0, r0, #7
 802c22e:	1ac2      	subs	r2, r0, r3
 802c230:	d0cc      	beq.n	802c1cc <_malloc_r+0x20>
 802c232:	1a1b      	subs	r3, r3, r0
 802c234:	50a3      	str	r3, [r4, r2]
 802c236:	e7c9      	b.n	802c1cc <_malloc_r+0x20>
 802c238:	4622      	mov	r2, r4
 802c23a:	6864      	ldr	r4, [r4, #4]
 802c23c:	e7cc      	b.n	802c1d8 <_malloc_r+0x2c>
 802c23e:	1cc4      	adds	r4, r0, #3
 802c240:	f024 0403 	bic.w	r4, r4, #3
 802c244:	42a0      	cmp	r0, r4
 802c246:	d0e3      	beq.n	802c210 <_malloc_r+0x64>
 802c248:	1a21      	subs	r1, r4, r0
 802c24a:	4630      	mov	r0, r6
 802c24c:	f000 f872 	bl	802c334 <_sbrk_r>
 802c250:	3001      	adds	r0, #1
 802c252:	d1dd      	bne.n	802c210 <_malloc_r+0x64>
 802c254:	e7cf      	b.n	802c1f6 <_malloc_r+0x4a>
 802c256:	bf00      	nop
 802c258:	20011e84 	.word	0x20011e84
 802c25c:	20011e88 	.word	0x20011e88

0802c260 <cleanup_glue>:
 802c260:	b538      	push	{r3, r4, r5, lr}
 802c262:	460c      	mov	r4, r1
 802c264:	6809      	ldr	r1, [r1, #0]
 802c266:	4605      	mov	r5, r0
 802c268:	b109      	cbz	r1, 802c26e <cleanup_glue+0xe>
 802c26a:	f7ff fff9 	bl	802c260 <cleanup_glue>
 802c26e:	4621      	mov	r1, r4
 802c270:	4628      	mov	r0, r5
 802c272:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802c276:	f7ff bf49 	b.w	802c10c <_free_r>
	...

0802c27c <_reclaim_reent>:
 802c27c:	4b2c      	ldr	r3, [pc, #176]	; (802c330 <_reclaim_reent+0xb4>)
 802c27e:	681b      	ldr	r3, [r3, #0]
 802c280:	4283      	cmp	r3, r0
 802c282:	b570      	push	{r4, r5, r6, lr}
 802c284:	4604      	mov	r4, r0
 802c286:	d051      	beq.n	802c32c <_reclaim_reent+0xb0>
 802c288:	6a43      	ldr	r3, [r0, #36]	; 0x24
 802c28a:	b143      	cbz	r3, 802c29e <_reclaim_reent+0x22>
 802c28c:	68db      	ldr	r3, [r3, #12]
 802c28e:	2b00      	cmp	r3, #0
 802c290:	d14a      	bne.n	802c328 <_reclaim_reent+0xac>
 802c292:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802c294:	6819      	ldr	r1, [r3, #0]
 802c296:	b111      	cbz	r1, 802c29e <_reclaim_reent+0x22>
 802c298:	4620      	mov	r0, r4
 802c29a:	f7ff ff37 	bl	802c10c <_free_r>
 802c29e:	6961      	ldr	r1, [r4, #20]
 802c2a0:	b111      	cbz	r1, 802c2a8 <_reclaim_reent+0x2c>
 802c2a2:	4620      	mov	r0, r4
 802c2a4:	f7ff ff32 	bl	802c10c <_free_r>
 802c2a8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802c2aa:	b111      	cbz	r1, 802c2b2 <_reclaim_reent+0x36>
 802c2ac:	4620      	mov	r0, r4
 802c2ae:	f7ff ff2d 	bl	802c10c <_free_r>
 802c2b2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 802c2b4:	b111      	cbz	r1, 802c2bc <_reclaim_reent+0x40>
 802c2b6:	4620      	mov	r0, r4
 802c2b8:	f7ff ff28 	bl	802c10c <_free_r>
 802c2bc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 802c2be:	b111      	cbz	r1, 802c2c6 <_reclaim_reent+0x4a>
 802c2c0:	4620      	mov	r0, r4
 802c2c2:	f7ff ff23 	bl	802c10c <_free_r>
 802c2c6:	6c21      	ldr	r1, [r4, #64]	; 0x40
 802c2c8:	b111      	cbz	r1, 802c2d0 <_reclaim_reent+0x54>
 802c2ca:	4620      	mov	r0, r4
 802c2cc:	f7ff ff1e 	bl	802c10c <_free_r>
 802c2d0:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 802c2d2:	b111      	cbz	r1, 802c2da <_reclaim_reent+0x5e>
 802c2d4:	4620      	mov	r0, r4
 802c2d6:	f7ff ff19 	bl	802c10c <_free_r>
 802c2da:	6da1      	ldr	r1, [r4, #88]	; 0x58
 802c2dc:	b111      	cbz	r1, 802c2e4 <_reclaim_reent+0x68>
 802c2de:	4620      	mov	r0, r4
 802c2e0:	f7ff ff14 	bl	802c10c <_free_r>
 802c2e4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802c2e6:	b111      	cbz	r1, 802c2ee <_reclaim_reent+0x72>
 802c2e8:	4620      	mov	r0, r4
 802c2ea:	f7ff ff0f 	bl	802c10c <_free_r>
 802c2ee:	69a3      	ldr	r3, [r4, #24]
 802c2f0:	b1e3      	cbz	r3, 802c32c <_reclaim_reent+0xb0>
 802c2f2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802c2f4:	4620      	mov	r0, r4
 802c2f6:	4798      	blx	r3
 802c2f8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 802c2fa:	b1b9      	cbz	r1, 802c32c <_reclaim_reent+0xb0>
 802c2fc:	4620      	mov	r0, r4
 802c2fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 802c302:	f7ff bfad 	b.w	802c260 <cleanup_glue>
 802c306:	5949      	ldr	r1, [r1, r5]
 802c308:	b941      	cbnz	r1, 802c31c <_reclaim_reent+0xa0>
 802c30a:	3504      	adds	r5, #4
 802c30c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802c30e:	2d80      	cmp	r5, #128	; 0x80
 802c310:	68d9      	ldr	r1, [r3, #12]
 802c312:	d1f8      	bne.n	802c306 <_reclaim_reent+0x8a>
 802c314:	4620      	mov	r0, r4
 802c316:	f7ff fef9 	bl	802c10c <_free_r>
 802c31a:	e7ba      	b.n	802c292 <_reclaim_reent+0x16>
 802c31c:	680e      	ldr	r6, [r1, #0]
 802c31e:	4620      	mov	r0, r4
 802c320:	f7ff fef4 	bl	802c10c <_free_r>
 802c324:	4631      	mov	r1, r6
 802c326:	e7ef      	b.n	802c308 <_reclaim_reent+0x8c>
 802c328:	2500      	movs	r5, #0
 802c32a:	e7ef      	b.n	802c30c <_reclaim_reent+0x90>
 802c32c:	bd70      	pop	{r4, r5, r6, pc}
 802c32e:	bf00      	nop
 802c330:	200001b4 	.word	0x200001b4

0802c334 <_sbrk_r>:
 802c334:	b538      	push	{r3, r4, r5, lr}
 802c336:	4d06      	ldr	r5, [pc, #24]	; (802c350 <_sbrk_r+0x1c>)
 802c338:	2300      	movs	r3, #0
 802c33a:	4604      	mov	r4, r0
 802c33c:	4608      	mov	r0, r1
 802c33e:	602b      	str	r3, [r5, #0]
 802c340:	f7df ff18 	bl	800c174 <_sbrk>
 802c344:	1c43      	adds	r3, r0, #1
 802c346:	d102      	bne.n	802c34e <_sbrk_r+0x1a>
 802c348:	682b      	ldr	r3, [r5, #0]
 802c34a:	b103      	cbz	r3, 802c34e <_sbrk_r+0x1a>
 802c34c:	6023      	str	r3, [r4, #0]
 802c34e:	bd38      	pop	{r3, r4, r5, pc}
 802c350:	20013ba8 	.word	0x20013ba8

0802c354 <_raise_r>:
 802c354:	291f      	cmp	r1, #31
 802c356:	b538      	push	{r3, r4, r5, lr}
 802c358:	4604      	mov	r4, r0
 802c35a:	460d      	mov	r5, r1
 802c35c:	d904      	bls.n	802c368 <_raise_r+0x14>
 802c35e:	2316      	movs	r3, #22
 802c360:	6003      	str	r3, [r0, #0]
 802c362:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802c366:	bd38      	pop	{r3, r4, r5, pc}
 802c368:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802c36a:	b112      	cbz	r2, 802c372 <_raise_r+0x1e>
 802c36c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802c370:	b94b      	cbnz	r3, 802c386 <_raise_r+0x32>
 802c372:	4620      	mov	r0, r4
 802c374:	f000 f830 	bl	802c3d8 <_getpid_r>
 802c378:	462a      	mov	r2, r5
 802c37a:	4601      	mov	r1, r0
 802c37c:	4620      	mov	r0, r4
 802c37e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802c382:	f000 b817 	b.w	802c3b4 <_kill_r>
 802c386:	2b01      	cmp	r3, #1
 802c388:	d00a      	beq.n	802c3a0 <_raise_r+0x4c>
 802c38a:	1c59      	adds	r1, r3, #1
 802c38c:	d103      	bne.n	802c396 <_raise_r+0x42>
 802c38e:	2316      	movs	r3, #22
 802c390:	6003      	str	r3, [r0, #0]
 802c392:	2001      	movs	r0, #1
 802c394:	e7e7      	b.n	802c366 <_raise_r+0x12>
 802c396:	2400      	movs	r4, #0
 802c398:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802c39c:	4628      	mov	r0, r5
 802c39e:	4798      	blx	r3
 802c3a0:	2000      	movs	r0, #0
 802c3a2:	e7e0      	b.n	802c366 <_raise_r+0x12>

0802c3a4 <raise>:
 802c3a4:	4b02      	ldr	r3, [pc, #8]	; (802c3b0 <raise+0xc>)
 802c3a6:	4601      	mov	r1, r0
 802c3a8:	6818      	ldr	r0, [r3, #0]
 802c3aa:	f7ff bfd3 	b.w	802c354 <_raise_r>
 802c3ae:	bf00      	nop
 802c3b0:	200001b4 	.word	0x200001b4

0802c3b4 <_kill_r>:
 802c3b4:	b538      	push	{r3, r4, r5, lr}
 802c3b6:	4d07      	ldr	r5, [pc, #28]	; (802c3d4 <_kill_r+0x20>)
 802c3b8:	2300      	movs	r3, #0
 802c3ba:	4604      	mov	r4, r0
 802c3bc:	4608      	mov	r0, r1
 802c3be:	4611      	mov	r1, r2
 802c3c0:	602b      	str	r3, [r5, #0]
 802c3c2:	f7df febd 	bl	800c140 <_kill>
 802c3c6:	1c43      	adds	r3, r0, #1
 802c3c8:	d102      	bne.n	802c3d0 <_kill_r+0x1c>
 802c3ca:	682b      	ldr	r3, [r5, #0]
 802c3cc:	b103      	cbz	r3, 802c3d0 <_kill_r+0x1c>
 802c3ce:	6023      	str	r3, [r4, #0]
 802c3d0:	bd38      	pop	{r3, r4, r5, pc}
 802c3d2:	bf00      	nop
 802c3d4:	20013ba8 	.word	0x20013ba8

0802c3d8 <_getpid_r>:
 802c3d8:	f7df beaa 	b.w	800c130 <_getpid>

0802c3dc <strncpy>:
 802c3dc:	b510      	push	{r4, lr}
 802c3de:	3901      	subs	r1, #1
 802c3e0:	4603      	mov	r3, r0
 802c3e2:	b132      	cbz	r2, 802c3f2 <strncpy+0x16>
 802c3e4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802c3e8:	f803 4b01 	strb.w	r4, [r3], #1
 802c3ec:	3a01      	subs	r2, #1
 802c3ee:	2c00      	cmp	r4, #0
 802c3f0:	d1f7      	bne.n	802c3e2 <strncpy+0x6>
 802c3f2:	441a      	add	r2, r3
 802c3f4:	2100      	movs	r1, #0
 802c3f6:	4293      	cmp	r3, r2
 802c3f8:	d100      	bne.n	802c3fc <strncpy+0x20>
 802c3fa:	bd10      	pop	{r4, pc}
 802c3fc:	f803 1b01 	strb.w	r1, [r3], #1
 802c400:	e7f9      	b.n	802c3f6 <strncpy+0x1a>
	...

0802c404 <__malloc_lock>:
 802c404:	4801      	ldr	r0, [pc, #4]	; (802c40c <__malloc_lock+0x8>)
 802c406:	f7ff be59 	b.w	802c0bc <__retarget_lock_acquire_recursive>
 802c40a:	bf00      	nop
 802c40c:	20013ba0 	.word	0x20013ba0

0802c410 <__malloc_unlock>:
 802c410:	4801      	ldr	r0, [pc, #4]	; (802c418 <__malloc_unlock+0x8>)
 802c412:	f7ff be54 	b.w	802c0be <__retarget_lock_release_recursive>
 802c416:	bf00      	nop
 802c418:	20013ba0 	.word	0x20013ba0

0802c41c <_init>:
 802c41c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802c41e:	bf00      	nop
 802c420:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802c422:	bc08      	pop	{r3}
 802c424:	469e      	mov	lr, r3
 802c426:	4770      	bx	lr

0802c428 <_fini>:
 802c428:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802c42a:	bf00      	nop
 802c42c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802c42e:	bc08      	pop	{r3}
 802c430:	469e      	mov	lr, r3
 802c432:	4770      	bx	lr
